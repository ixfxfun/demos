var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value3) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value3);
var __privateSet = (obj, member, value3, setter3) => (__accessCheck(obj, member, "write to private field"), setter3 ? setter3.call(obj, value3) : member.set(obj, value3), value3);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@lit-labs/ssr-dom-shim/lib/element-internals.js
var ElementInternalsShim = class ElementInternals {
  get shadowRoot() {
    return this.__host.__shadowRoot;
  }
  constructor(_host) {
    this.ariaAtomic = "";
    this.ariaAutoComplete = "";
    this.ariaBrailleLabel = "";
    this.ariaBrailleRoleDescription = "";
    this.ariaBusy = "";
    this.ariaChecked = "";
    this.ariaColCount = "";
    this.ariaColIndex = "";
    this.ariaColSpan = "";
    this.ariaCurrent = "";
    this.ariaDescription = "";
    this.ariaDisabled = "";
    this.ariaExpanded = "";
    this.ariaHasPopup = "";
    this.ariaHidden = "";
    this.ariaInvalid = "";
    this.ariaKeyShortcuts = "";
    this.ariaLabel = "";
    this.ariaLevel = "";
    this.ariaLive = "";
    this.ariaModal = "";
    this.ariaMultiLine = "";
    this.ariaMultiSelectable = "";
    this.ariaOrientation = "";
    this.ariaPlaceholder = "";
    this.ariaPosInSet = "";
    this.ariaPressed = "";
    this.ariaReadOnly = "";
    this.ariaRequired = "";
    this.ariaRoleDescription = "";
    this.ariaRowCount = "";
    this.ariaRowIndex = "";
    this.ariaRowSpan = "";
    this.ariaSelected = "";
    this.ariaSetSize = "";
    this.ariaSort = "";
    this.ariaValueMax = "";
    this.ariaValueMin = "";
    this.ariaValueNow = "";
    this.ariaValueText = "";
    this.role = "";
    this.form = null;
    this.labels = [];
    this.states = /* @__PURE__ */ new Set();
    this.validationMessage = "";
    this.validity = {};
    this.willValidate = true;
    this.__host = _host;
  }
  checkValidity() {
    console.warn("`ElementInternals.checkValidity()` was called on the server.This method always returns true.");
    return true;
  }
  reportValidity() {
    return true;
  }
  setFormValue() {
  }
  setValidity() {
  }
};

// node_modules/@lit-labs/ssr-dom-shim/index.js
var attributes = /* @__PURE__ */ new WeakMap();
var attributesForElement = (element) => {
  let attrs = attributes.get(element);
  if (attrs === void 0) {
    attributes.set(element, attrs = /* @__PURE__ */ new Map());
  }
  return attrs;
};
var ElementShim = class Element {
  constructor() {
    this.__shadowRootMode = null;
    this.__shadowRoot = null;
    this.__internals = null;
  }
  get attributes() {
    return Array.from(attributesForElement(this)).map(([name, value3]) => ({
      name,
      value: value3
    }));
  }
  get shadowRoot() {
    if (this.__shadowRootMode === "closed") {
      return null;
    }
    return this.__shadowRoot;
  }
  get localName() {
    return this.constructor.__localName;
  }
  get tagName() {
    return this.localName?.toUpperCase();
  }
  setAttribute(name, value3) {
    attributesForElement(this).set(name, String(value3));
  }
  removeAttribute(name) {
    attributesForElement(this).delete(name);
  }
  toggleAttribute(name, force) {
    if (this.hasAttribute(name)) {
      if (force === void 0 || !force) {
        this.removeAttribute(name);
        return false;
      }
    } else {
      if (force === void 0 || force) {
        this.setAttribute(name, "");
        return true;
      } else {
        return false;
      }
    }
    return true;
  }
  hasAttribute(name) {
    return attributesForElement(this).has(name);
  }
  attachShadow(init6) {
    const shadowRoot = { host: this };
    this.__shadowRootMode = init6.mode;
    if (init6 && init6.mode === "open") {
      this.__shadowRoot = shadowRoot;
    }
    return shadowRoot;
  }
  attachInternals() {
    if (this.__internals !== null) {
      throw new Error(`Failed to execute 'attachInternals' on 'HTMLElement': ElementInternals for the specified element was already attached.`);
    }
    const internals = new ElementInternalsShim(this);
    this.__internals = internals;
    return internals;
  }
  getAttribute(name) {
    const value3 = attributesForElement(this).get(name);
    return value3 ?? null;
  }
};
var HTMLElementShim = class HTMLElement2 extends ElementShim {
};
var HTMLElementShimWithRealType = HTMLElementShim;
var CustomElementRegistryShim = class CustomElementRegistry {
  constructor() {
    this.__definitions = /* @__PURE__ */ new Map();
  }
  define(name, ctor) {
    if (this.__definitions.has(name)) {
      if (process.env.NODE_ENV === "development") {
        console.warn(`'CustomElementRegistry' already has "${name}" defined. This may have been caused by live reload or hot module replacement in which case it can be safely ignored.
Make sure to test your application with a production build as repeat registrations will throw in production.`);
      } else {
        throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': the name "${name}" has already been used with this registry`);
      }
    }
    ctor.__localName = name;
    this.__definitions.set(name, {
      ctor,
      // Note it's important we read `observedAttributes` in case it is a getter
      // with side-effects, as is the case in Lit, where it triggers class
      // finalization.
      //
      // TODO(aomarks) To be spec compliant, we should also capture the
      // registration-time lifecycle methods like `connectedCallback`. For them
      // to be actually accessible to e.g. the Lit SSR element renderer, though,
      // we'd need to introduce a new API for accessing them (since `get` only
      // returns the constructor).
      observedAttributes: ctor.observedAttributes ?? []
    });
  }
  get(name) {
    const definition = this.__definitions.get(name);
    return definition?.ctor;
  }
};
var CustomElementRegistryShimWithRealType = CustomElementRegistryShim;
var customElements2 = new CustomElementRegistryShimWithRealType();

// node_modules/@lit/reactive-element/node/css-tag.js
var t2 = globalThis;
var e = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var s = Symbol();
var o = /* @__PURE__ */ new WeakMap();
var n = class {
  constructor(t6, e5, o5) {
    if (this._$cssResult$ = true, o5 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t6, this.t = e5;
  }
  get styleSheet() {
    let t6 = this.o;
    const s3 = this.t;
    if (e && void 0 === t6) {
      const e5 = void 0 !== s3 && 1 === s3.length;
      e5 && (t6 = o.get(s3)), void 0 === t6 && ((this.o = t6 = new CSSStyleSheet()).replaceSync(this.cssText), e5 && o.set(s3, t6));
    }
    return t6;
  }
  toString() {
    return this.cssText;
  }
};
var r = (t6) => new n("string" == typeof t6 ? t6 : t6 + "", void 0, s);
var i = (t6, ...e5) => {
  const o5 = 1 === t6.length ? t6[0] : e5.reduce((e6, s3, o6) => e6 + ((t7) => {
    if (true === t7._$cssResult$) return t7.cssText;
    if ("number" == typeof t7) return t7;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t7 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s3) + t6[o6 + 1], t6[0]);
  return new n(o5, t6, s);
};
var S = (s3, o5) => {
  if (e) s3.adoptedStyleSheets = o5.map((t6) => t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet);
  else for (const e5 of o5) {
    const o6 = document.createElement("style"), n6 = t2.litNonce;
    void 0 !== n6 && o6.setAttribute("nonce", n6), o6.textContent = e5.cssText, s3.appendChild(o6);
  }
};
var c = e || void 0 === t2.CSSStyleSheet ? (t6) => t6 : (t6) => t6 instanceof CSSStyleSheet ? ((t7) => {
  let e5 = "";
  for (const s3 of t7.cssRules) e5 += s3.cssText;
  return r(e5);
})(t6) : t6;

// node_modules/@lit/reactive-element/node/reactive-element.js
var { is: r2, defineProperty: h, getOwnPropertyDescriptor: o2, getOwnPropertyNames: n2, getOwnPropertySymbols: a, getPrototypeOf: c2 } = Object;
var l = globalThis;
l.customElements ??= customElements2;
var p = l.trustedTypes;
var d = p ? p.emptyScript : "";
var u = l.reactiveElementPolyfillSupport;
var f = (t6, s3) => t6;
var b = { toAttribute(t6, s3) {
  switch (s3) {
    case Boolean:
      t6 = t6 ? d : null;
      break;
    case Object:
    case Array:
      t6 = null == t6 ? t6 : JSON.stringify(t6);
  }
  return t6;
}, fromAttribute(t6, s3) {
  let i4 = t6;
  switch (s3) {
    case Boolean:
      i4 = null !== t6;
      break;
    case Number:
      i4 = null === t6 ? null : Number(t6);
      break;
    case Object:
    case Array:
      try {
        i4 = JSON.parse(t6);
      } catch (t7) {
        i4 = null;
      }
  }
  return i4;
} };
var y = (t6, s3) => !r2(t6, s3);
var m = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
Symbol.metadata ??= Symbol("metadata"), l.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
var g = class extends (globalThis.HTMLElement ?? HTMLElementShimWithRealType) {
  static addInitializer(t6) {
    this._$Ei(), (this.l ??= []).push(t6);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t6, s3 = m) {
    if (s3.state && (s3.attribute = false), this._$Ei(), this.elementProperties.set(t6, s3), !s3.noAccessor) {
      const i4 = Symbol(), e5 = this.getPropertyDescriptor(t6, i4, s3);
      void 0 !== e5 && h(this.prototype, t6, e5);
    }
  }
  static getPropertyDescriptor(t6, s3, i4) {
    const { get: e5, set: r5 } = o2(this.prototype, t6) ?? { get() {
      return this[s3];
    }, set(t7) {
      this[s3] = t7;
    } };
    return { get() {
      return e5?.call(this);
    }, set(s4) {
      const h5 = e5?.call(this);
      r5.call(this, s4), this.requestUpdate(t6, h5, i4);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t6) {
    return this.elementProperties.get(t6) ?? m;
  }
  static _$Ei() {
    if (this.hasOwnProperty(f("elementProperties"))) return;
    const t6 = c2(this);
    t6.finalize(), void 0 !== t6.l && (this.l = [...t6.l]), this.elementProperties = new Map(t6.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(f("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(f("properties"))) {
      const t7 = this.properties, s3 = [...n2(t7), ...a(t7)];
      for (const i4 of s3) this.createProperty(i4, t7[i4]);
    }
    const t6 = this[Symbol.metadata];
    if (null !== t6) {
      const s3 = litPropertyMetadata.get(t6);
      if (void 0 !== s3) for (const [t7, i4] of s3) this.elementProperties.set(t7, i4);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t7, s3] of this.elementProperties) {
      const i4 = this._$Eu(t7, s3);
      void 0 !== i4 && this._$Eh.set(i4, t7);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t6) {
    const s3 = [];
    if (Array.isArray(t6)) {
      const e5 = new Set(t6.flat(1 / 0).reverse());
      for (const t7 of e5) s3.unshift(c(t7));
    } else void 0 !== t6 && s3.push(c(t6));
    return s3;
  }
  static _$Eu(t6, s3) {
    const i4 = s3.attribute;
    return false === i4 ? void 0 : "string" == typeof i4 ? i4 : "string" == typeof t6 ? t6.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t6) => this.enableUpdating = t6), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t6) => t6(this));
  }
  addController(t6) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t6), void 0 !== this.renderRoot && this.isConnected && t6.hostConnected?.();
  }
  removeController(t6) {
    this._$EO?.delete(t6);
  }
  _$E_() {
    const t6 = /* @__PURE__ */ new Map(), s3 = this.constructor.elementProperties;
    for (const i4 of s3.keys()) this.hasOwnProperty(i4) && (t6.set(i4, this[i4]), delete this[i4]);
    t6.size > 0 && (this._$Ep = t6);
  }
  createRenderRoot() {
    const t6 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S(t6, this.constructor.elementStyles), t6;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t6) => t6.hostConnected?.());
  }
  enableUpdating(t6) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t6) => t6.hostDisconnected?.());
  }
  attributeChangedCallback(t6, s3, i4) {
    this._$AK(t6, i4);
  }
  _$EC(t6, s3) {
    const i4 = this.constructor.elementProperties.get(t6), e5 = this.constructor._$Eu(t6, i4);
    if (void 0 !== e5 && true === i4.reflect) {
      const r5 = (void 0 !== i4.converter?.toAttribute ? i4.converter : b).toAttribute(s3, i4.type);
      this._$Em = t6, null == r5 ? this.removeAttribute(e5) : this.setAttribute(e5, r5), this._$Em = null;
    }
  }
  _$AK(t6, s3) {
    const i4 = this.constructor, e5 = i4._$Eh.get(t6);
    if (void 0 !== e5 && this._$Em !== e5) {
      const t7 = i4.getPropertyOptions(e5), r5 = "function" == typeof t7.converter ? { fromAttribute: t7.converter } : void 0 !== t7.converter?.fromAttribute ? t7.converter : b;
      this._$Em = e5, this[e5] = r5.fromAttribute(s3, t7.type), this._$Em = null;
    }
  }
  requestUpdate(t6, s3, i4) {
    if (void 0 !== t6) {
      if (i4 ??= this.constructor.getPropertyOptions(t6), !(i4.hasChanged ?? y)(this[t6], s3)) return;
      this.P(t6, s3, i4);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t6, s3, i4) {
    this._$AL.has(t6) || this._$AL.set(t6, s3), true === i4.reflect && this._$Em !== t6 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t6);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t7) {
      Promise.reject(t7);
    }
    const t6 = this.scheduleUpdate();
    return null != t6 && await t6, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t8, s4] of this._$Ep) this[t8] = s4;
        this._$Ep = void 0;
      }
      const t7 = this.constructor.elementProperties;
      if (t7.size > 0) for (const [s4, i4] of t7) true !== i4.wrapped || this._$AL.has(s4) || void 0 === this[s4] || this.P(s4, this[s4], i4);
    }
    let t6 = false;
    const s3 = this._$AL;
    try {
      t6 = this.shouldUpdate(s3), t6 ? (this.willUpdate(s3), this._$EO?.forEach((t7) => t7.hostUpdate?.()), this.update(s3)) : this._$EU();
    } catch (s4) {
      throw t6 = false, this._$EU(), s4;
    }
    t6 && this._$AE(s3);
  }
  willUpdate(t6) {
  }
  _$AE(t6) {
    this._$EO?.forEach((t7) => t7.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t6)), this.updated(t6);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t6) {
    return true;
  }
  update(t6) {
    this._$Ej &&= this._$Ej.forEach((t7) => this._$EC(t7, this[t7])), this._$EU();
  }
  updated(t6) {
  }
  firstUpdated(t6) {
  }
};
g.elementStyles = [], g.shadowRootOptions = { mode: "open" }, g[f("elementProperties")] = /* @__PURE__ */ new Map(), g[f("finalized")] = /* @__PURE__ */ new Map(), u?.({ ReactiveElement: g }), (l.reactiveElementVersions ??= []).push("2.0.4");

// node_modules/lit-html/node/lit-html.js
var n3 = globalThis;
var c3 = n3.trustedTypes;
var h2 = c3 ? c3.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
var f2 = "$lit$";
var v = `lit$${Math.random().toFixed(9).slice(2)}$`;
var m2 = "?" + v;
var _ = `<${m2}>`;
var w = void 0 === n3.document ? { createTreeWalker: () => ({}) } : document;
var lt = () => w.createComment("");
var st = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
var g2 = Array.isArray;
var $ = (t6) => g2(t6) || "function" == typeof t6?.[Symbol.iterator];
var x = "[ 	\n\f\r]";
var T = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var E = /-->/g;
var k = />/g;
var O = RegExp(`>|${x}(?:([^\\s"'>=/]+)(${x}*=${x}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var S2 = /'/g;
var j = /"/g;
var M = /^(?:script|style|textarea|title)$/i;
var P = (t6) => (i4, ...s3) => ({ _$litType$: t6, strings: i4, values: s3 });
var ke = P(1);
var Oe = P(2);
var Se = P(3);
var R = Symbol.for("lit-noChange");
var D = Symbol.for("lit-nothing");
var V = /* @__PURE__ */ new WeakMap();
var I = w.createTreeWalker(w, 129);
function N(t6, i4) {
  if (!g2(t6) || !t6.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== h2 ? h2.createHTML(i4) : i4;
}
var U = (t6, i4) => {
  const s3 = t6.length - 1, e5 = [];
  let h5, o5 = 2 === i4 ? "<svg>" : 3 === i4 ? "<math>" : "", n6 = T;
  for (let i5 = 0; i5 < s3; i5++) {
    const s4 = t6[i5];
    let r5, l3, c5 = -1, a3 = 0;
    for (; a3 < s4.length && (n6.lastIndex = a3, l3 = n6.exec(s4), null !== l3); ) a3 = n6.lastIndex, n6 === T ? "!--" === l3[1] ? n6 = E : void 0 !== l3[1] ? n6 = k : void 0 !== l3[2] ? (M.test(l3[2]) && (h5 = RegExp("</" + l3[2], "g")), n6 = O) : void 0 !== l3[3] && (n6 = O) : n6 === O ? ">" === l3[0] ? (n6 = h5 ?? T, c5 = -1) : void 0 === l3[1] ? c5 = -2 : (c5 = n6.lastIndex - l3[2].length, r5 = l3[1], n6 = void 0 === l3[3] ? O : '"' === l3[3] ? j : S2) : n6 === j || n6 === S2 ? n6 = O : n6 === E || n6 === k ? n6 = T : (n6 = O, h5 = void 0);
    const u3 = n6 === O && t6[i5 + 1].startsWith("/>") ? " " : "";
    o5 += n6 === T ? s4 + _ : c5 >= 0 ? (e5.push(r5), s4.slice(0, c5) + f2 + s4.slice(c5) + v + u3) : s4 + v + (-2 === c5 ? i5 : u3);
  }
  return [N(t6, o5 + (t6[s3] || "<?>") + (2 === i4 ? "</svg>" : 3 === i4 ? "</math>" : "")), e5];
};
var B = class _B {
  constructor({ strings: t6, _$litType$: i4 }, s3) {
    let e5;
    this.parts = [];
    let h5 = 0, o5 = 0;
    const n6 = t6.length - 1, r5 = this.parts, [l3, a3] = U(t6, i4);
    if (this.el = _B.createElement(l3, s3), I.currentNode = this.el.content, 2 === i4 || 3 === i4) {
      const t7 = this.el.content.firstChild;
      t7.replaceWith(...t7.childNodes);
    }
    for (; null !== (e5 = I.nextNode()) && r5.length < n6; ) {
      if (1 === e5.nodeType) {
        if (e5.hasAttributes()) for (const t7 of e5.getAttributeNames()) if (t7.endsWith(f2)) {
          const i5 = a3[o5++], s4 = e5.getAttribute(t7).split(v), n7 = /([.?@])?(.*)/.exec(i5);
          r5.push({ type: 1, index: h5, name: n7[2], strings: s4, ctor: "." === n7[1] ? Y : "?" === n7[1] ? Z : "@" === n7[1] ? q : G }), e5.removeAttribute(t7);
        } else t7.startsWith(v) && (r5.push({ type: 6, index: h5 }), e5.removeAttribute(t7));
        if (M.test(e5.tagName)) {
          const t7 = e5.textContent.split(v), i5 = t7.length - 1;
          if (i5 > 0) {
            e5.textContent = c3 ? c3.emptyScript : "";
            for (let s4 = 0; s4 < i5; s4++) e5.append(t7[s4], lt()), I.nextNode(), r5.push({ type: 2, index: ++h5 });
            e5.append(t7[i5], lt());
          }
        }
      } else if (8 === e5.nodeType) if (e5.data === m2) r5.push({ type: 2, index: h5 });
      else {
        let t7 = -1;
        for (; -1 !== (t7 = e5.data.indexOf(v, t7 + 1)); ) r5.push({ type: 7, index: h5 }), t7 += v.length - 1;
      }
      h5++;
    }
  }
  static createElement(t6, i4) {
    const s3 = w.createElement("template");
    return s3.innerHTML = t6, s3;
  }
};
function z(t6, i4, s3 = t6, e5) {
  if (i4 === R) return i4;
  let h5 = void 0 !== e5 ? s3.o?.[e5] : s3.l;
  const o5 = st(i4) ? void 0 : i4._$litDirective$;
  return h5?.constructor !== o5 && (h5?._$AO?.(false), void 0 === o5 ? h5 = void 0 : (h5 = new o5(t6), h5._$AT(t6, s3, e5)), void 0 !== e5 ? (s3.o ??= [])[e5] = h5 : s3.l = h5), void 0 !== h5 && (i4 = z(t6, h5._$AS(t6, i4.values), h5, e5)), i4;
}
var F = class {
  constructor(t6, i4) {
    this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i4;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t6) {
    const { el: { content: i4 }, parts: s3 } = this._$AD, e5 = (t6?.creationScope ?? w).importNode(i4, true);
    I.currentNode = e5;
    let h5 = I.nextNode(), o5 = 0, n6 = 0, r5 = s3[0];
    for (; void 0 !== r5; ) {
      if (o5 === r5.index) {
        let i5;
        2 === r5.type ? i5 = new et(h5, h5.nextSibling, this, t6) : 1 === r5.type ? i5 = new r5.ctor(h5, r5.name, r5.strings, this, t6) : 6 === r5.type && (i5 = new K(h5, this, t6)), this._$AV.push(i5), r5 = s3[++n6];
      }
      o5 !== r5?.index && (h5 = I.nextNode(), o5++);
    }
    return I.currentNode = w, e5;
  }
  p(t6) {
    let i4 = 0;
    for (const s3 of this._$AV) void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t6, s3, i4), i4 += s3.strings.length - 2) : s3._$AI(t6[i4])), i4++;
  }
};
var et = class _et {
  get _$AU() {
    return this._$AM?._$AU ?? this.v;
  }
  constructor(t6, i4, s3, e5) {
    this.type = 2, this._$AH = D, this._$AN = void 0, this._$AA = t6, this._$AB = i4, this._$AM = s3, this.options = e5, this.v = e5?.isConnected ?? true;
  }
  get parentNode() {
    let t6 = this._$AA.parentNode;
    const i4 = this._$AM;
    return void 0 !== i4 && 11 === t6?.nodeType && (t6 = i4.parentNode), t6;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t6, i4 = this) {
    t6 = z(this, t6, i4), st(t6) ? t6 === D || null == t6 || "" === t6 ? (this._$AH !== D && this._$AR(), this._$AH = D) : t6 !== this._$AH && t6 !== R && this._(t6) : void 0 !== t6._$litType$ ? this.$(t6) : void 0 !== t6.nodeType ? this.T(t6) : $(t6) ? this.k(t6) : this._(t6);
  }
  O(t6) {
    return this._$AA.parentNode.insertBefore(t6, this._$AB);
  }
  T(t6) {
    this._$AH !== t6 && (this._$AR(), this._$AH = this.O(t6));
  }
  _(t6) {
    this._$AH !== D && st(this._$AH) ? this._$AA.nextSibling.data = t6 : this.T(w.createTextNode(t6)), this._$AH = t6;
  }
  $(t6) {
    const { values: i4, _$litType$: s3 } = t6, e5 = "number" == typeof s3 ? this._$AC(t6) : (void 0 === s3.el && (s3.el = B.createElement(N(s3.h, s3.h[0]), this.options)), s3);
    if (this._$AH?._$AD === e5) this._$AH.p(i4);
    else {
      const t7 = new F(e5, this), s4 = t7.u(this.options);
      t7.p(i4), this.T(s4), this._$AH = t7;
    }
  }
  _$AC(t6) {
    let i4 = V.get(t6.strings);
    return void 0 === i4 && V.set(t6.strings, i4 = new B(t6)), i4;
  }
  k(t6) {
    g2(this._$AH) || (this._$AH = [], this._$AR());
    const i4 = this._$AH;
    let s3, e5 = 0;
    for (const h5 of t6) e5 === i4.length ? i4.push(s3 = new _et(this.O(lt()), this.O(lt()), this, this.options)) : s3 = i4[e5], s3._$AI(h5), e5++;
    e5 < i4.length && (this._$AR(s3 && s3._$AB.nextSibling, e5), i4.length = e5);
  }
  _$AR(t6 = this._$AA.nextSibling, i4) {
    for (this._$AP?.(false, true, i4); t6 && t6 !== this._$AB; ) {
      const i5 = t6.nextSibling;
      t6.remove(), t6 = i5;
    }
  }
  setConnected(t6) {
    void 0 === this._$AM && (this.v = t6, this._$AP?.(t6));
  }
};
var G = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t6, i4, s3, e5, h5) {
    this.type = 1, this._$AH = D, this._$AN = void 0, this.element = t6, this.name = i4, this._$AM = e5, this.options = h5, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = D;
  }
  _$AI(t6, i4 = this, s3, e5) {
    const h5 = this.strings;
    let o5 = false;
    if (void 0 === h5) t6 = z(this, t6, i4, 0), o5 = !st(t6) || t6 !== this._$AH && t6 !== R, o5 && (this._$AH = t6);
    else {
      const e6 = t6;
      let n6, r5;
      for (t6 = h5[0], n6 = 0; n6 < h5.length - 1; n6++) r5 = z(this, e6[s3 + n6], i4, n6), r5 === R && (r5 = this._$AH[n6]), o5 ||= !st(r5) || r5 !== this._$AH[n6], r5 === D ? t6 = D : t6 !== D && (t6 += (r5 ?? "") + h5[n6 + 1]), this._$AH[n6] = r5;
    }
    o5 && !e5 && this.j(t6);
  }
  j(t6) {
    t6 === D ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t6 ?? "");
  }
};
var Y = class extends G {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t6) {
    this.element[this.name] = t6 === D ? void 0 : t6;
  }
};
var Z = class extends G {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t6) {
    this.element.toggleAttribute(this.name, !!t6 && t6 !== D);
  }
};
var q = class extends G {
  constructor(t6, i4, s3, e5, h5) {
    super(t6, i4, s3, e5, h5), this.type = 5;
  }
  _$AI(t6, i4 = this) {
    if ((t6 = z(this, t6, i4, 0) ?? D) === R) return;
    const s3 = this._$AH, e5 = t6 === D && s3 !== D || t6.capture !== s3.capture || t6.once !== s3.once || t6.passive !== s3.passive, h5 = t6 !== D && (s3 === D || e5);
    e5 && this.element.removeEventListener(this.name, this, s3), h5 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
  }
  handleEvent(t6) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t6) : this._$AH.handleEvent(t6);
  }
};
var K = class {
  constructor(t6, i4, s3) {
    this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t6) {
    z(this, t6);
  }
};
var si = { M: f2, P: v, A: m2, C: 1, L: U, R: F, D: $, V: z, I: et, H: G, N: Z, U: q, B: Y, F: K };
var Re = n3.litHtmlPolyfillSupport;
Re?.(B, et), (n3.litHtmlVersions ??= []).push("3.2.0");
var Q = (t6, i4, s3) => {
  const e5 = s3?.renderBefore ?? i4;
  let h5 = e5._$litPart$;
  if (void 0 === h5) {
    const t7 = s3?.renderBefore ?? null;
    e5._$litPart$ = h5 = new et(i4.insertBefore(lt(), t7), t7, void 0, s3 ?? {});
  }
  return h5._$AI(t6), h5;
};

// node_modules/lit-element/lit-element.js
var h3 = class extends g {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    const t6 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t6.firstChild, t6;
  }
  update(t6) {
    const e5 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t6), this.o = Q(e5, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this.o?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.o?.setConnected(false);
  }
  render() {
    return R;
  }
};
h3._$litElement$ = true, h3["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: h3 });
var f3 = globalThis.litElementPolyfillSupport;
f3?.({ LitElement: h3 });
(globalThis.litElementVersions ??= []).push("4.1.0");

// node_modules/@lit/reactive-element/node/decorators/custom-element.js
var t3 = (t6) => (e5, o5) => {
  void 0 !== o5 ? o5.addInitializer(() => {
    customElements.define(t6, e5);
  }) : customElements.define(t6, e5);
};

// node_modules/@lit/reactive-element/node/decorators/property.js
var o3 = { attribute: true, type: String, converter: b, reflect: false, hasChanged: y };
var r3 = (t6 = o3, e5, r5) => {
  const { kind: n6, metadata: i4 } = r5;
  let s3 = globalThis.litPropertyMetadata.get(i4);
  if (void 0 === s3 && globalThis.litPropertyMetadata.set(i4, s3 = /* @__PURE__ */ new Map()), s3.set(r5.name, t6), "accessor" === n6) {
    const { name: o5 } = r5;
    return { set(r6) {
      const n7 = e5.get.call(this);
      e5.set.call(this, r6), this.requestUpdate(o5, n7, t6);
    }, init(e6) {
      return void 0 !== e6 && this.P(o5, void 0, t6), e6;
    } };
  }
  if ("setter" === n6) {
    const { name: o5 } = r5;
    return function(r6) {
      const n7 = this[o5];
      e5.call(this, r6), this.requestUpdate(o5, n7, t6);
    };
  }
  throw Error("Unsupported decorator location: " + n6);
};
function n4(t6) {
  return (e5, o5) => "object" == typeof o5 ? r3(t6, e5, o5) : ((t7, e6, o6) => {
    const r5 = e6.hasOwnProperty(o6);
    return e6.constructor.createProperty(o6, r5 ? { ...t7, wrapped: true } : t7), r5 ? Object.getOwnPropertyDescriptor(e6, o6) : void 0;
  })(t6, e5, o5);
}

// node_modules/lit-html/node/directive-helpers.js
var { I: et2 } = si;
var rt = (o5) => void 0 === o5.strings;

// node_modules/lit-html/node/directive.js
var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var e3 = (t6) => (...e5) => ({ _$litDirective$: t6, values: e5 });
var i2 = class {
  constructor(t6) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t6, e5, i4) {
    this.t = t6, this._$AM = e5, this.i = i4;
  }
  _$AS(t6, e5) {
    return this.update(t6, e5);
  }
  update(t6, e5) {
    return this.render(...e5);
  }
};

// node_modules/lit-html/node/async-directive.js
var mt = (i4, t6) => {
  const e5 = i4._$AN;
  if (void 0 === e5) return false;
  for (const i5 of e5) i5._$AO?.(t6, false), mt(i5, t6);
  return true;
};
var _t = (i4) => {
  let t6, e5;
  do {
    if (void 0 === (t6 = i4._$AM)) break;
    e5 = t6._$AN, e5.delete(i4), i4 = t6;
  } while (0 === e5?.size);
};
var wt = (i4) => {
  for (let t6; t6 = i4._$AM; i4 = t6) {
    let e5 = t6._$AN;
    if (void 0 === e5) t6._$AN = e5 = /* @__PURE__ */ new Set();
    else if (e5.has(i4)) break;
    e5.add(i4), gt(t6);
  }
};
function bt(i4) {
  void 0 !== this._$AN ? (_t(this), this._$AM = i4, wt(this)) : this._$AM = i4;
}
function yt(i4, t6 = false, e5 = 0) {
  const s3 = this._$AH, o5 = this._$AN;
  if (void 0 !== o5 && 0 !== o5.size) if (t6) if (Array.isArray(s3)) for (let i5 = e5; i5 < s3.length; i5++) mt(s3[i5], false), _t(s3[i5]);
  else null != s3 && (mt(s3, false), _t(s3));
  else mt(this, i4);
}
var gt = (i4) => {
  i4.type == t4.CHILD && (i4._$AP ??= yt, i4._$AQ ??= bt);
};
var $t = class extends i2 {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(i4, t6, e5) {
    super._$AT(i4, t6, e5), wt(this), this.isConnected = i4._$AU;
  }
  _$AO(i4, t6 = true) {
    i4 !== this.isConnected && (this.isConnected = i4, i4 ? this.reconnected?.() : this.disconnected?.()), t6 && (mt(this, i4), _t(this));
  }
  setValue(i4) {
    if (rt(this.t)) this.t._$AI(i4, this);
    else {
      const t6 = [...this.t._$AH];
      t6[this.i] = i4, this.t._$AI(t6, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};

// node_modules/lit-html/node/directives/ref.js
var ii = () => new Zt();
var Zt = class {
};
var qt = /* @__PURE__ */ new WeakMap();
var Kt = e3(class extends $t {
  render(t6) {
    return D;
  }
  update(t6, [i4]) {
    const s3 = i4 !== this.Y;
    return s3 && void 0 !== this.Y && this.rt(void 0), (s3 || this.lt !== this.ct) && (this.Y = i4, this.ht = t6.options?.host, this.rt(this.ct = t6.element)), D;
  }
  rt(t6) {
    if (this.isConnected || (t6 = void 0), "function" == typeof this.Y) {
      const i4 = this.ht ?? globalThis;
      let s3 = qt.get(i4);
      void 0 === s3 && (s3 = /* @__PURE__ */ new WeakMap(), qt.set(i4, s3)), void 0 !== s3.get(this.Y) && this.Y.call(this.ht, void 0), s3.set(this.Y, t6), void 0 !== t6 && this.Y.call(this.ht, t6);
    } else this.Y.value = t6;
  }
  get lt() {
    return "function" == typeof this.Y ? qt.get(this.ht ?? globalThis)?.get(this.Y) : this.Y?.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});

// src/components/video-selector.ts
var _fileInputEl, _selectEl;
var VideoSelector = class extends h3 {
  constructor() {
    super(...arguments);
    this.playing = false;
    this.cameras = [];
    __privateAdd(this, _fileInputEl, ii());
    __privateAdd(this, _selectEl, ii());
  }
  render() {
    const source = this.source;
    let sel = ``;
    if (source) {
      if (source.kind === `camera`) {
        const first2 = this.cameras[0];
        if (source.id === `` && first2) {
          sel = first2.id;
        } else {
          sel = source.id;
        }
      }
    }
    const cameras = this.cameras.length === 0 ? ke`` : ke`
          ${this.cameras.map((d3) => ke`<option .source=${d3} ?selected=${d3.id === sel} value=${d3.id}>${d3.label}</option>`)}`;
    return ke`
    <div id="contents">
      <div id="toolbar"><button @click=${this.onStartStopClick}>${this.playing ? `Stop` : `Start`}</button></div>
      <select ${Kt(__privateGet(this, _selectEl))} @change=${this.onCameraSelectChange}>
        ${cameras}
      </select>
      <input @change=${this.onFileChange} ${Kt(__privateGet(this, _fileInputEl))} id="fileInput" type="file" accept="video/*" />
      <button @click=${this.onFileSelect}>File</button>
    </div>
    `;
  }
  getSelected() {
    const el2 = __privateGet(this, _selectEl).value;
    if (!el2) return;
    const item = el2.item(el2.selectedIndex);
    if (!item) return;
    return item.source;
  }
  /**
  * Start stop source & processing
  */
  onStartStopClick() {
    this.dispatchEvent(new CustomEvent(`startstop`, { detail: this.getSelected() }));
  }
  onFileSelect() {
    __privateGet(this, _fileInputEl).value?.click();
  }
  notifySourceState(state) {
    this.playing = state === `started`;
  }
  onFileChange(event2) {
    const target = event2.target;
    if (!target) return;
    if (!target.files) return;
    const files = target.files;
    if (files.length === 0) return;
    const url = URL.createObjectURL(files[0]);
    const s3 = {
      id: url,
      label: `file`,
      kind: `file`
    };
    this.dispatchEvent(new CustomEvent(`change`, {
      detail: s3
    }));
  }
  /**
   * User has selected a camera
   * @param event
   * @returns 
   */
  onCameraSelectChange(event2) {
    const t6 = event2.target;
    const opt = t6.item(t6.selectedIndex);
    if (!opt) return;
    const value3 = opt.value;
    this.source = {
      kind: `camera`,
      label: opt.innerText,
      id: value3
    };
    this.dispatchEvent(new CustomEvent(`change`, { detail: this.source }));
  }
};
_fileInputEl = new WeakMap();
_selectEl = new WeakMap();
VideoSelector.styles = i`
    :host {
      display:block;
      background-color: hsla(0,0%,30%,0.5);
    }
    #contents {
      padding: 0.5rem;
    }
    input {
      display: none;
    }
    #toolbar {
      margin-bottom: 0.5rem;
    }
  `;
__decorateClass([
  n4()
], VideoSelector.prototype, "source", 2);
__decorateClass([
  n4()
], VideoSelector.prototype, "playing", 2);
__decorateClass([
  n4()
], VideoSelector.prototype, "cameras", 2);
VideoSelector = __decorateClass([
  t3("video-selector")
], VideoSelector);

// src/util/drawing.ts
var PiPi = Math.PI * 2;
var traceLine = (ctx, ...points) => {
  if (points.length < 2) return;
  ctx.moveTo(points[0].x, points[0].y);
  for (let i4 = 1; i4 < points.length; i4++) {
    if (points[i4] === void 0) continue;
    ctx.lineTo(points[i4].x, points[i4].y);
  }
};
var drawDot = (ctx, point3, radius, fillStyle, label, labelFillStyle) => {
  ctx.beginPath();
  ctx.arc(point3.x, point3.y, radius, 0, PiPi, false);
  if (fillStyle) {
    ctx.fillStyle = fillStyle;
  }
  ctx.fill();
  if (label) {
    if (labelFillStyle) ctx.fillStyle = labelFillStyle;
    ctx.fillText(label, point3.x + radius, point3.y - radius);
  }
};
var toAbsolute = (el2) => (pt2) => {
  return { x: pt2.x * el2.width, y: pt2.y * el2.height };
};
var vpScale = (el2) => {
  const s3 = Math.min(el2.width, el2.height);
  return (v3) => {
    return v3 * s3;
  };
};
var wrap = (el2) => {
  const ctx = el2.getContext(`2d`);
  if (!ctx) throw new Error(`Context unavailable`);
  const abs5 = toAbsolute(el2);
  const dot3 = (point3, radius, fillStyle, label, labelFillStyle) => {
    drawDot(ctx, abs5(point3), scale4(radius), fillStyle, label, labelFillStyle);
  };
  const clear4 = () => {
    ctx.clearRect(0, 0, el2.width, el2.height);
  };
  const fill2 = (style) => {
    if (style) ctx.fillStyle = style;
    ctx.fillRect(0, 0, el2.width, el2.height);
  };
  const line3 = (a3, b3, width) => {
    a3 = abs5(a3);
    b3 = abs5(b3);
    width = scale4(width);
    ctx.beginPath();
    ctx.moveTo(a3.x, a3.y);
    ctx.lineTo(b3.x, b3.y);
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  };
  const joinPoints = (width, ...points) => {
    width = scale4(width);
    ctx.beginPath();
    for (let i4 = 0; i4 < points.length; i4++) {
      const pt2 = abs5(points[i4]);
      if (i4 === 0) {
        ctx.moveTo(pt2.x, pt2.y);
      } else {
        ctx.lineTo(pt2.x, pt2.y);
      }
    }
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  };
  const scale4 = vpScale(el2);
  const testPattern = () => {
    ctx.beginPath();
    ctx.strokeStyle = `red`;
    ctx.lineWidth = 2;
    traceLine(ctx, { x: 0, y: 0 }, { x: el2.width, y: el2.height });
    traceLine(ctx, { x: 0, y: el2.height }, { x: el2.width, y: 0 });
    ctx.stroke();
  };
  const text3 = (text4, point3, style) => {
    point3 = abs5(point3);
    if (style) ctx.fillStyle = style;
    ctx.fillText(text4, point3.x, point3.y);
  };
  return { dot: dot3, abs: abs5, clear: clear4, testPattern, scale: scale4, line: line3, joinPoints, fill: fill2, text: text3, ctx };
};
var typewriter = (ctx, x3 = 0, y3 = 0) => {
  const measure = (msg) => {
    const m4 = ctx.measureText(msg);
    return {
      width: m4.width,
      height: m4.fontBoundingBoxAscent + m4.fontBoundingBoxDescent
    };
  };
  const move = (toX, toY) => {
    x3 = toX;
    y3 = toY;
  };
  const line3 = (msg, colour) => {
    const r5 = measure(msg);
    if (colour) ctx.fillStyle = colour;
    ctx.fillText(msg, x3, y3);
    y3 += r5.height;
  };
  const word = (msg, colour) => {
    const r5 = measure(msg);
    if (colour) ctx.fillStyle = colour;
    ctx.fillText(msg, x3, y3);
    x3 += r5.width;
  };
  return { line: line3, word, move };
};

// node_modules/@mediapipe/tasks-vision/vision_bundle.mjs
var t5 = "undefined" != typeof self ? self : {};
function e4(e5) {
  t: {
    for (var n6 = ["CLOSURE_FLAGS"], r5 = t5, i4 = 0; i4 < n6.length; i4++) if (null == (r5 = r5[n6[i4]])) {
      n6 = null;
      break t;
    }
    n6 = r5;
  }
  return null != (e5 = n6 && n6[e5]) && e5;
}
function n5() {
  throw Error("Invalid UTF8");
}
function r4(t6, e5) {
  return e5 = String.fromCharCode.apply(null, e5), null == t6 ? e5 : t6 + e5;
}
var i3;
var s2;
var o4 = "undefined" != typeof TextDecoder;
var a2;
var h4 = "undefined" != typeof TextEncoder;
function c4(t6) {
  if (h4) t6 = (a2 ||= new TextEncoder()).encode(t6);
  else {
    let n6 = 0;
    const r5 = new Uint8Array(3 * t6.length);
    for (let i4 = 0; i4 < t6.length; i4++) {
      var e5 = t6.charCodeAt(i4);
      if (128 > e5) r5[n6++] = e5;
      else {
        if (2048 > e5) r5[n6++] = e5 >> 6 | 192;
        else {
          if (55296 <= e5 && 57343 >= e5) {
            if (56319 >= e5 && i4 < t6.length) {
              const s3 = t6.charCodeAt(++i4);
              if (56320 <= s3 && 57343 >= s3) {
                e5 = 1024 * (e5 - 55296) + s3 - 56320 + 65536, r5[n6++] = e5 >> 18 | 240, r5[n6++] = e5 >> 12 & 63 | 128, r5[n6++] = e5 >> 6 & 63 | 128, r5[n6++] = 63 & e5 | 128;
                continue;
              }
              i4--;
            }
            e5 = 65533;
          }
          r5[n6++] = e5 >> 12 | 224, r5[n6++] = e5 >> 6 & 63 | 128;
        }
        r5[n6++] = 63 & e5 | 128;
      }
    }
    t6 = n6 === r5.length ? r5 : r5.subarray(0, n6);
  }
  return t6;
}
var u2;
var l2 = e4(610401301);
var d2 = e4(188588736);
var f4 = t5.navigator;
function p2(t6) {
  return !!l2 && (!!u2 && u2.brands.some(({ brand: e5 }) => e5 && -1 != e5.indexOf(t6)));
}
function g3(e5) {
  var n6;
  return (n6 = t5.navigator) && (n6 = n6.userAgent) || (n6 = ""), -1 != n6.indexOf(e5);
}
function m3() {
  return !!l2 && (!!u2 && 0 < u2.brands.length);
}
function y2() {
  return m3() ? p2("Chromium") : (g3("Chrome") || g3("CriOS")) && !(!m3() && g3("Edge")) || g3("Silk");
}
function _2(t6) {
  return _2[" "](t6), t6;
}
u2 = f4 && f4.userAgentData || null, _2[" "] = function() {
};
var v2 = !m3() && (g3("Trident") || g3("MSIE"));
!g3("Android") || y2(), y2(), g3("Safari") && (y2() || !m3() && g3("Coast") || !m3() && g3("Opera") || !m3() && g3("Edge") || (m3() ? p2("Microsoft Edge") : g3("Edg/")) || m3() && p2("Opera"));
var E2 = {};
var w2 = null;
function T2(t6) {
  var e5 = t6.length, n6 = 3 * e5 / 4;
  n6 % 3 ? n6 = Math.floor(n6) : -1 != "=.".indexOf(t6[e5 - 1]) && (n6 = -1 != "=.".indexOf(t6[e5 - 2]) ? n6 - 2 : n6 - 1);
  var r5 = new Uint8Array(n6), i4 = 0;
  return function(t7, e6) {
    function n7(e7) {
      for (; r6 < t7.length; ) {
        var n8 = t7.charAt(r6++), i6 = w2[n8];
        if (null != i6) return i6;
        if (!/^[\s\xa0]*$/.test(n8)) throw Error("Unknown base64 encoding at char: " + n8);
      }
      return e7;
    }
    A();
    for (var r6 = 0; ; ) {
      var i5 = n7(-1), s3 = n7(0), o5 = n7(64), a3 = n7(64);
      if (64 === a3 && -1 === i5) break;
      e6(i5 << 2 | s3 >> 4), 64 != o5 && (e6(s3 << 4 & 240 | o5 >> 2), 64 != a3 && e6(o5 << 6 & 192 | a3));
    }
  }(t6, function(t7) {
    r5[i4++] = t7;
  }), i4 !== n6 ? r5.subarray(0, i4) : r5;
}
function A() {
  if (!w2) {
    w2 = {};
    for (var t6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e5 = ["+/=", "+/", "-_=", "-_.", "-_"], n6 = 0; 5 > n6; n6++) {
      var r5 = t6.concat(e5[n6].split(""));
      E2[n6] = r5;
      for (var i4 = 0; i4 < r5.length; i4++) {
        var s3 = r5[i4];
        void 0 === w2[s3] && (w2[s3] = i4);
      }
    }
  }
}
var b2 = "undefined" != typeof Uint8Array;
var k2 = !v2 && "function" == typeof btoa;
function x2(t6) {
  if (!k2) {
    var e5;
    void 0 === e5 && (e5 = 0), A(), e5 = E2[e5];
    var n6 = Array(Math.floor(t6.length / 3)), r5 = e5[64] || "";
    let h5 = 0, c5 = 0;
    for (; h5 < t6.length - 2; h5 += 3) {
      var i4 = t6[h5], s3 = t6[h5 + 1], o5 = t6[h5 + 2], a3 = e5[i4 >> 2];
      i4 = e5[(3 & i4) << 4 | s3 >> 4], s3 = e5[(15 & s3) << 2 | o5 >> 6], o5 = e5[63 & o5], n6[c5++] = a3 + i4 + s3 + o5;
    }
    switch (a3 = 0, o5 = r5, t6.length - h5) {
      case 2:
        o5 = e5[(15 & (a3 = t6[h5 + 1])) << 2] || r5;
      case 1:
        t6 = t6[h5], n6[c5] = e5[t6 >> 2] + e5[(3 & t6) << 4 | a3 >> 4] + o5 + r5;
    }
    return n6.join("");
  }
  for (e5 = "", n6 = 0, r5 = t6.length - 10240; n6 < r5; ) e5 += String.fromCharCode.apply(null, t6.subarray(n6, n6 += 10240));
  return e5 += String.fromCharCode.apply(null, n6 ? t6.subarray(n6) : t6), btoa(e5);
}
var S3 = /[-_.]/g;
var L = { "-": "+", _: "/", ".": "=" };
function F2(t6) {
  return L[t6] || "";
}
function R2(t6) {
  if (!k2) return T2(t6);
  S3.test(t6) && (t6 = t6.replace(S3, F2)), t6 = atob(t6);
  const e5 = new Uint8Array(t6.length);
  for (let n6 = 0; n6 < t6.length; n6++) e5[n6] = t6.charCodeAt(n6);
  return e5;
}
function M2(t6) {
  return b2 && null != t6 && t6 instanceof Uint8Array;
}
var P2;
function C() {
  return P2 ||= new Uint8Array(0);
}
var O2 = {};
var I2;
function U2(t6) {
  if (t6 !== O2) throw Error("illegal external caller");
}
function D2() {
  return I2 ||= new B2(null, O2);
}
function N2(t6) {
  U2(O2);
  var e5 = t6.g;
  return null == (e5 = null == e5 || M2(e5) ? e5 : "string" == typeof e5 ? R2(e5) : null) ? e5 : t6.g = e5;
}
var B2 = class {
  constructor(t6, e5) {
    if (U2(e5), this.g = t6, null != t6 && 0 === t6.length) throw Error("ByteString should be constructed with non-empty values");
  }
  h() {
    const t6 = N2(this);
    return t6 ? new Uint8Array(t6) : C();
  }
};
function G2(t6, e5) {
  return Error(`Invalid wire type: ${t6} (at position ${e5})`);
}
function j2() {
  return Error("Failed to read varint, encoding is invalid.");
}
function V2(t6, e5) {
  return Error(`Tried to read past the end of the data ${e5} > ${t6}`);
}
function X(t6) {
  if ("string" == typeof t6) return { buffer: R2(t6), P: false };
  if (Array.isArray(t6)) return { buffer: new Uint8Array(t6), P: false };
  if (t6.constructor === Uint8Array) return { buffer: t6, P: false };
  if (t6.constructor === ArrayBuffer) return { buffer: new Uint8Array(t6), P: false };
  if (t6.constructor === B2) return { buffer: N2(t6) || C(), P: true };
  if (t6 instanceof Uint8Array) return { buffer: new Uint8Array(t6.buffer, t6.byteOffset, t6.byteLength), P: false };
  throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
}
function H() {
  return "function" == typeof BigInt;
}
var W = "function" == typeof Uint8Array.prototype.slice;
var z2;
var K2 = 0;
var Y2 = 0;
function $2(t6) {
  const e5 = 0 > t6;
  let n6 = (t6 = Math.abs(t6)) >>> 0;
  if (t6 = Math.floor((t6 - n6) / 4294967296), e5) {
    const [e6, r5] = rt2(n6, t6);
    t6 = r5, n6 = e6;
  }
  K2 = n6 >>> 0, Y2 = t6 >>> 0;
}
function q2(t6) {
  const e5 = z2 ||= new DataView(new ArrayBuffer(8));
  e5.setFloat32(0, +t6, true), Y2 = 0, K2 = e5.getUint32(0, true);
}
function J(t6, e5) {
  return 4294967296 * e5 + (t6 >>> 0);
}
function Z2(t6, e5) {
  const n6 = 2147483648 & e5;
  return n6 && (e5 = ~e5 >>> 0, 0 == (t6 = 1 + ~t6 >>> 0) && (e5 = e5 + 1 >>> 0)), t6 = J(t6, e5), n6 ? -t6 : t6;
}
function Q2(t6, e5) {
  if (t6 >>>= 0, 2097151 >= (e5 >>>= 0)) var n6 = "" + (4294967296 * e5 + t6);
  else H() ? n6 = "" + (BigInt(e5) << BigInt(32) | BigInt(t6)) : (t6 = (16777215 & t6) + 6777216 * (n6 = 16777215 & (t6 >>> 24 | e5 << 8)) + 6710656 * (e5 = e5 >> 16 & 65535), n6 += 8147497 * e5, e5 *= 2, 1e7 <= t6 && (n6 += Math.floor(t6 / 1e7), t6 %= 1e7), 1e7 <= n6 && (e5 += Math.floor(n6 / 1e7), n6 %= 1e7), n6 = e5 + tt(n6) + tt(t6));
  return n6;
}
function tt(t6) {
  return t6 = String(t6), "0000000".slice(t6.length) + t6;
}
function et3() {
  var t6 = K2, e5 = Y2;
  if (2147483648 & e5) if (H()) t6 = "" + (BigInt(0 | e5) << BigInt(32) | BigInt(t6 >>> 0));
  else {
    const [n6, r5] = rt2(t6, e5);
    t6 = "-" + Q2(n6, r5);
  }
  else t6 = Q2(t6, e5);
  return t6;
}
function nt(t6) {
  if (16 > t6.length) $2(Number(t6));
  else if (H()) t6 = BigInt(t6), K2 = Number(t6 & BigInt(4294967295)) >>> 0, Y2 = Number(t6 >> BigInt(32) & BigInt(4294967295));
  else {
    const e5 = +("-" === t6[0]);
    Y2 = K2 = 0;
    const n6 = t6.length;
    for (let r5 = e5, i4 = (n6 - e5) % 6 + e5; i4 <= n6; r5 = i4, i4 += 6) {
      const e6 = Number(t6.slice(r5, i4));
      Y2 *= 1e6, K2 = 1e6 * K2 + e6, 4294967296 <= K2 && (Y2 += Math.trunc(K2 / 4294967296), Y2 >>>= 0, K2 >>>= 0);
    }
    if (e5) {
      const [t7, e6] = rt2(K2, Y2);
      K2 = t7, Y2 = e6;
    }
  }
}
function rt2(t6, e5) {
  return e5 = ~e5, t6 ? t6 = 1 + ~t6 : e5 += 1, [t6, e5];
}
function it(t6, e5) {
  let n6, r5 = 0, i4 = 0, s3 = 0;
  const o5 = t6.h;
  let a3 = t6.g;
  do {
    n6 = o5[a3++], r5 |= (127 & n6) << s3, s3 += 7;
  } while (32 > s3 && 128 & n6);
  for (32 < s3 && (i4 |= (127 & n6) >> 4), s3 = 3; 32 > s3 && 128 & n6; s3 += 7) n6 = o5[a3++], i4 |= (127 & n6) << s3;
  if (dt(t6, a3), 128 > n6) return e5(r5 >>> 0, i4 >>> 0);
  throw j2();
}
function st2(t6) {
  let e5 = 0, n6 = t6.g;
  const r5 = n6 + 10, i4 = t6.h;
  for (; n6 < r5; ) {
    const r6 = i4[n6++];
    if (e5 |= r6, 0 == (128 & r6)) return dt(t6, n6), !!(127 & e5);
  }
  throw j2();
}
function ot(t6) {
  const e5 = t6.h;
  let n6 = t6.g, r5 = e5[n6++], i4 = 127 & r5;
  if (128 & r5 && (r5 = e5[n6++], i4 |= (127 & r5) << 7, 128 & r5 && (r5 = e5[n6++], i4 |= (127 & r5) << 14, 128 & r5 && (r5 = e5[n6++], i4 |= (127 & r5) << 21, 128 & r5 && (r5 = e5[n6++], i4 |= r5 << 28, 128 & r5 && 128 & e5[n6++] && 128 & e5[n6++] && 128 & e5[n6++] && 128 & e5[n6++] && 128 & e5[n6++]))))) throw j2();
  return dt(t6, n6), i4;
}
function at(t6) {
  return ot(t6) >>> 0;
}
function ht(t6) {
  var e5 = t6.h;
  const n6 = t6.g, r5 = e5[n6], i4 = e5[n6 + 1], s3 = e5[n6 + 2];
  return e5 = e5[n6 + 3], dt(t6, t6.g + 4), (r5 << 0 | i4 << 8 | s3 << 16 | e5 << 24) >>> 0;
}
function ct(t6) {
  var e5 = ht(t6);
  t6 = 2 * (e5 >> 31) + 1;
  const n6 = e5 >>> 23 & 255;
  return e5 &= 8388607, 255 == n6 ? e5 ? NaN : 1 / 0 * t6 : 0 == n6 ? t6 * Math.pow(2, -149) * e5 : t6 * Math.pow(2, n6 - 150) * (e5 + Math.pow(2, 23));
}
function ut(t6) {
  return ot(t6);
}
function lt2(t6, e5, { ca: n6 = false } = {}) {
  t6.ca = n6, e5 && (e5 = X(e5), t6.h = e5.buffer, t6.m = e5.P, t6.j = 0, t6.l = t6.h.length, t6.g = t6.j);
}
function dt(t6, e5) {
  if (t6.g = e5, e5 > t6.l) throw V2(t6.l, e5);
}
function ft(t6, e5) {
  if (0 > e5) throw Error(`Tried to read a negative byte length: ${e5}`);
  const n6 = t6.g, r5 = n6 + e5;
  if (r5 > t6.l) throw V2(e5, t6.l - n6);
  return t6.g = r5, n6;
}
function pt(t6, e5) {
  if (0 == e5) return D2();
  var n6 = ft(t6, e5);
  return t6.ca && t6.m ? n6 = t6.h.subarray(n6, n6 + e5) : (t6 = t6.h, n6 = n6 === (e5 = n6 + e5) ? C() : W ? t6.slice(n6, e5) : new Uint8Array(t6.subarray(n6, e5))), 0 == n6.length ? D2() : new B2(n6, O2);
}
var gt2 = [];
function mt2(t6) {
  var e5 = t6.g;
  if (e5.g == e5.l) return false;
  t6.l = t6.g.g;
  var n6 = at(t6.g);
  if (e5 = n6 >>> 3, !(0 <= (n6 &= 7) && 5 >= n6)) throw G2(n6, t6.l);
  if (1 > e5) throw Error(`Invalid field number: ${e5} (at position ${t6.l})`);
  return t6.m = e5, t6.h = n6, true;
}
function yt2(t6) {
  switch (t6.h) {
    case 0:
      0 != t6.h ? yt2(t6) : st2(t6.g);
      break;
    case 1:
      dt(t6 = t6.g, t6.g + 8);
      break;
    case 2:
      if (2 != t6.h) yt2(t6);
      else {
        var e5 = at(t6.g);
        dt(t6 = t6.g, t6.g + e5);
      }
      break;
    case 5:
      dt(t6 = t6.g, t6.g + 4);
      break;
    case 3:
      for (e5 = t6.m; ; ) {
        if (!mt2(t6)) throw Error("Unmatched start-group tag: stream EOF");
        if (4 == t6.h) {
          if (t6.m != e5) throw Error("Unmatched end-group tag");
          break;
        }
        yt2(t6);
      }
      break;
    default:
      throw G2(t6.h, t6.l);
  }
}
function _t2(t6, e5, n6) {
  const r5 = t6.g.l, i4 = at(t6.g), s3 = t6.g.g + i4;
  let o5 = s3 - r5;
  if (0 >= o5 && (t6.g.l = s3, n6(e5, t6, void 0, void 0, void 0), o5 = s3 - t6.g.g), o5) throw Error(`Message parsing ended unexpectedly. Expected to read ${i4} bytes, instead read ${i4 - o5} bytes, either the data ended unexpectedly or the message misreported its own length`);
  return t6.g.g = s3, t6.g.l = r5, e5;
}
function vt(t6) {
  var e5 = at(t6.g), a3 = ft(t6 = t6.g, e5);
  if (t6 = t6.h, o4) {
    var h5, c5 = t6;
    (h5 = s2) || (h5 = s2 = new TextDecoder("utf-8", { fatal: true })), e5 = a3 + e5, c5 = 0 === a3 && e5 === c5.length ? c5 : c5.subarray(a3, e5);
    try {
      var u3 = h5.decode(c5);
    } catch (t7) {
      if (void 0 === i3) {
        try {
          h5.decode(new Uint8Array([128]));
        } catch (t8) {
        }
        try {
          h5.decode(new Uint8Array([97])), i3 = true;
        } catch (t8) {
          i3 = false;
        }
      }
      throw !i3 && (s2 = void 0), t7;
    }
  } else {
    e5 = (u3 = a3) + e5, a3 = [];
    let i4, s3 = null;
    for (; u3 < e5; ) {
      var l3 = t6[u3++];
      128 > l3 ? a3.push(l3) : 224 > l3 ? u3 >= e5 ? n5() : (i4 = t6[u3++], 194 > l3 || 128 != (192 & i4) ? (u3--, n5()) : a3.push((31 & l3) << 6 | 63 & i4)) : 240 > l3 ? u3 >= e5 - 1 ? n5() : (i4 = t6[u3++], 128 != (192 & i4) || 224 === l3 && 160 > i4 || 237 === l3 && 160 <= i4 || 128 != (192 & (h5 = t6[u3++])) ? (u3--, n5()) : a3.push((15 & l3) << 12 | (63 & i4) << 6 | 63 & h5)) : 244 >= l3 ? u3 >= e5 - 2 ? n5() : (i4 = t6[u3++], 128 != (192 & i4) || 0 != i4 - 144 + (l3 << 28) >> 30 || 128 != (192 & (h5 = t6[u3++])) || 128 != (192 & (c5 = t6[u3++])) ? (u3--, n5()) : (l3 = (7 & l3) << 18 | (63 & i4) << 12 | (63 & h5) << 6 | 63 & c5, l3 -= 65536, a3.push(55296 + (l3 >> 10 & 1023), 56320 + (1023 & l3)))) : n5(), 8192 <= a3.length && (s3 = r4(s3, a3), a3.length = 0);
    }
    u3 = r4(s3, a3);
  }
  return u3;
}
function Et(t6) {
  const e5 = at(t6.g);
  return pt(t6.g, e5);
}
function wt2(t6, e5, n6) {
  var r5 = at(t6.g);
  for (r5 = t6.g.g + r5; t6.g.g < r5; ) n6.push(e5(t6.g));
}
var Tt = [];
function At(t6) {
  return t6 ? /^\d+$/.test(t6) ? (nt(t6), new bt2(K2, Y2)) : null : kt ||= new bt2(0, 0);
}
var bt2 = class {
  constructor(t6, e5) {
    this.h = t6 >>> 0, this.g = e5 >>> 0;
  }
};
var kt;
function xt(t6) {
  return t6 ? /^-?\d+$/.test(t6) ? (nt(t6), new St(K2, Y2)) : null : Lt ||= new St(0, 0);
}
var St = class {
  constructor(t6, e5) {
    this.h = t6 >>> 0, this.g = e5 >>> 0;
  }
};
var Lt;
function Ft(t6, e5, n6) {
  for (; 0 < n6 || 127 < e5; ) t6.g.push(127 & e5 | 128), e5 = (e5 >>> 7 | n6 << 25) >>> 0, n6 >>>= 7;
  t6.g.push(e5);
}
function Rt(t6, e5) {
  for (; 127 < e5; ) t6.g.push(127 & e5 | 128), e5 >>>= 7;
  t6.g.push(e5);
}
function Mt(t6, e5) {
  if (0 <= e5) Rt(t6, e5);
  else {
    for (let n6 = 0; 9 > n6; n6++) t6.g.push(127 & e5 | 128), e5 >>= 7;
    t6.g.push(1);
  }
}
function Pt(t6, e5) {
  t6.g.push(e5 >>> 0 & 255), t6.g.push(e5 >>> 8 & 255), t6.g.push(e5 >>> 16 & 255), t6.g.push(e5 >>> 24 & 255);
}
function Ct(t6, e5) {
  0 !== e5.length && (t6.l.push(e5), t6.h += e5.length);
}
function Ot(t6, e5, n6) {
  Rt(t6.g, 8 * e5 + n6);
}
function It(t6, e5) {
  return Ot(t6, e5, 2), e5 = t6.g.end(), Ct(t6, e5), e5.push(t6.h), e5;
}
function Ut(t6, e5) {
  var n6 = e5.pop();
  for (n6 = t6.h + t6.g.length() - n6; 127 < n6; ) e5.push(127 & n6 | 128), n6 >>>= 7, t6.h++;
  e5.push(n6), t6.h++;
}
function Dt(t6, e5, n6) {
  Ot(t6, e5, 2), Rt(t6.g, n6.length), Ct(t6, t6.g.end()), Ct(t6, n6);
}
function Nt(t6, e5, n6, r5) {
  null != n6 && (e5 = It(t6, e5), r5(n6, t6), Ut(t6, e5));
}
var Bt = class {
  constructor(t6, e5, n6, r5) {
    this.g = t6, this.h = e5, this.l = n6, this.pa = r5;
  }
};
function Gt(t6) {
  return Array.prototype.slice.call(t6);
}
function jt(t6) {
  return "function" == typeof Symbol && "symbol" == typeof Symbol() ? Symbol() : t6;
}
var Vt = jt();
var Xt = jt("0di");
var Ht = jt("2ex");
var Wt = jt("0dg");
var zt = Vt ? (t6, e5) => {
  t6[Vt] |= e5;
} : (t6, e5) => {
  void 0 !== t6.g ? t6.g |= e5 : Object.defineProperties(t6, { g: { value: e5, configurable: true, writable: true, enumerable: false } });
};
var Kt2 = Vt ? (t6, e5) => {
  t6[Vt] &= ~e5;
} : (t6, e5) => {
  void 0 !== t6.g && (t6.g &= ~e5);
};
function Yt(t6, e5, n6) {
  return n6 ? t6 | e5 : t6 & ~e5;
}
var $t2 = Vt ? (t6) => 0 | t6[Vt] : (t6) => 0 | t6.g;
var qt2 = Vt ? (t6) => t6[Vt] : (t6) => t6.g;
var Jt = Vt ? (t6, e5) => (t6[Vt] = e5, t6) : (t6, e5) => (void 0 !== t6.g ? t6.g = e5 : Object.defineProperties(t6, { g: { value: e5, configurable: true, writable: true, enumerable: false } }), t6);
function Zt2(t6) {
  return zt(t6, 34), t6;
}
function Qt(t6, e5) {
  Jt(e5, -14591 & (0 | t6));
}
function te(t6, e5) {
  Jt(e5, -14557 & (34 | t6));
}
function ee(t6) {
  return 0 === (t6 = t6 >> 14 & 1023) ? 536870912 : t6;
}
var ne;
var re = {};
var ie = {};
function se(t6) {
  return !(!t6 || "object" != typeof t6 || t6.Ja !== ie);
}
function oe(t6) {
  return null !== t6 && "object" == typeof t6 && !Array.isArray(t6) && t6.constructor === Object;
}
function ae(t6, e5, n6) {
  if (null != t6) {
    if ("string" == typeof t6) t6 = t6 ? new B2(t6, O2) : D2();
    else if (t6.constructor !== B2) if (M2(t6)) t6 = t6.length ? new B2(n6 ? t6 : new Uint8Array(t6), O2) : D2();
    else {
      if (!e5) throw Error();
      t6 = void 0;
    }
  }
  return t6;
}
function he(t6, e5, n6) {
  if (!Array.isArray(t6) || t6.length) return false;
  const r5 = $t2(t6);
  return !!(1 & r5) || !(!e5 || !(Array.isArray(e5) ? e5.includes(n6) : e5.has(n6))) && (Jt(t6, 1 | r5), true);
}
var ce = [];
function ue(t6) {
  if (2 & t6) throw Error();
}
Jt(ce, 55), ne = Object.freeze(ce);
var le = class _le {
  constructor(t6, e5, n6) {
    this.l = 0, this.g = t6, this.h = e5, this.m = n6;
  }
  next() {
    if (this.l < this.g.length) {
      const t6 = this.g[this.l++];
      return { done: false, value: this.h ? this.h.call(this.m, t6) : t6 };
    }
    return { done: true, value: void 0 };
  }
  [Symbol.iterator]() {
    return new _le(this.g, this.h, this.m);
  }
};
var de;
var fe;
var pe;
function ge(t6, e5) {
  (e5 = de ? e5[de] : void 0) && (t6[de] = Gt(e5));
}
function me(t6, e5) {
  t6.__closure__error__context__984382 || (t6.__closure__error__context__984382 = {}), t6.__closure__error__context__984382.severity = e5;
}
function ye() {
  const e5 = Error();
  me(e5, "incident"), function(e6) {
    t5.setTimeout(() => {
      throw e6;
    }, 0);
  }(e5);
}
function _e(t6) {
  return me(t6 = Error(t6), "warning"), t6;
}
function ve(t6) {
  return null == t6 || "number" == typeof t6 ? t6 : "NaN" === t6 || "Infinity" === t6 || "-Infinity" === t6 ? Number(t6) : void 0;
}
function Ee(t6) {
  return null == t6 || "boolean" == typeof t6 ? t6 : "number" == typeof t6 ? !!t6 : void 0;
}
Object.freeze(new class {
}()), Object.freeze(new class {
}());
var we = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
function Te(t6) {
  const e5 = typeof t6;
  return "number" === e5 ? Number.isFinite(t6) : "string" === e5 && we.test(t6);
}
function Ae(t6) {
  if (null == t6) return t6;
  if ("string" == typeof t6) {
    if (!t6) return;
    t6 = +t6;
  }
  return "number" == typeof t6 && Number.isFinite(t6) ? 0 | t6 : void 0;
}
function be(t6) {
  if (null == t6) return t6;
  if ("string" == typeof t6) {
    if (!t6) return;
    t6 = +t6;
  }
  return "number" == typeof t6 && Number.isFinite(t6) ? t6 >>> 0 : void 0;
}
function ke2(t6) {
  return "-" !== t6[0] && (20 > t6.length || 20 === t6.length && 184467 > Number(t6.substring(0, 6)));
}
function xe(t6) {
  return "-" === t6[0] ? 20 > t6.length || 20 === t6.length && -922337 < Number(t6.substring(0, 7)) : 19 > t6.length || 19 === t6.length && 922337 > Number(t6.substring(0, 6));
}
function Se2(t6) {
  return t6 = Math.trunc(t6), Number.isSafeInteger(t6) || ($2(t6), t6 = Z2(K2, Y2)), t6;
}
function Le(t6) {
  var e5 = Math.trunc(Number(t6));
  return Number.isSafeInteger(e5) ? String(e5) : (-1 !== (e5 = t6.indexOf(".")) && (t6 = t6.substring(0, e5)), xe(t6) || (nt(t6), t6 = et3()), t6);
}
function Fe(t6) {
  return null == t6 ? t6 : Te(t6) ? "number" == typeof t6 ? Se2(t6) : Le(t6) : void 0;
}
function Re2(t6) {
  if ("string" != typeof t6) throw Error();
  return t6;
}
function Me(t6) {
  if (null != t6 && "string" != typeof t6) throw Error();
  return t6;
}
function Pe(t6) {
  return null == t6 || "string" == typeof t6 ? t6 : void 0;
}
function Ce(t6, e5, n6, r5) {
  if (null != t6 && "object" == typeof t6 && t6.X === re) return t6;
  if (!Array.isArray(t6)) return n6 ? 2 & r5 ? (t6 = e5[Xt]) ? e5 = t6 : (Zt2((t6 = new e5()).s), e5 = e5[Xt] = t6) : e5 = new e5() : e5 = void 0, e5;
  let i4 = n6 = $t2(t6);
  return 0 === i4 && (i4 |= 32 & r5), i4 |= 2 & r5, i4 !== n6 && Jt(t6, i4), new e5(t6);
}
function Oe2(t6, e5, n6) {
  if (e5) {
    var r5 = !!r5;
    if (!Te(e5 = t6)) throw _e("int64");
    "string" == typeof e5 ? r5 = Le(e5) : r5 ? (r5 = Math.trunc(e5), Number.isSafeInteger(r5) ? r5 = String(r5) : xe(e5 = String(r5)) ? r5 = e5 : ($2(r5), r5 = et3())) : r5 = Se2(e5);
  } else r5 = Fe(t6);
  return "string" == typeof (n6 = null == (t6 = r5) ? n6 ? 0 : void 0 : t6) && (r5 = +n6, Number.isSafeInteger(r5)) ? r5 : n6;
}
var Ie;
var Ue;
var De;
function Ne(t6) {
  switch (typeof t6) {
    case "boolean":
      return Ue ||= [0, void 0, true];
    case "number":
      return 0 < t6 ? void 0 : 0 === t6 ? De ||= [0, void 0] : [-t6, void 0];
    case "string":
      return [0, t6];
    case "object":
      return t6;
  }
}
function Be(t6, e5) {
  return Ge(t6, e5[0], e5[1]);
}
function Ge(t6, e5, n6) {
  if (null == t6 && (t6 = Ie), Ie = void 0, null == t6) {
    var r5 = 96;
    n6 ? (t6 = [n6], r5 |= 512) : t6 = [], e5 && (r5 = -16760833 & r5 | (1023 & e5) << 14);
  } else {
    if (!Array.isArray(t6)) throw Error("narr");
    if (2048 & (r5 = $t2(t6))) throw Error("farr");
    if (64 & r5) return t6;
    if (r5 |= 64, n6 && (r5 |= 512, n6 !== t6[0])) throw Error("mid");
    t: {
      const i4 = (n6 = t6).length;
      if (i4) {
        const t7 = i4 - 1;
        if (oe(n6[t7])) {
          if (1024 <= (e5 = t7 - (+!!(512 & (r5 |= 256)) - 1))) throw Error("pvtlmt");
          r5 = -16760833 & r5 | (1023 & e5) << 14;
          break t;
        }
      }
      if (e5) {
        if (1024 < (e5 = Math.max(e5, i4 - (+!!(512 & r5) - 1)))) throw Error("spvt");
        r5 = -16760833 & r5 | (1023 & e5) << 14;
      }
    }
  }
  return Jt(t6, r5), t6;
}
var je = {};
var Ve = function() {
  try {
    return _2(new class extends Map {
      constructor() {
        super();
      }
    }()), false;
  } catch {
    return true;
  }
}();
var Xe = class {
  constructor() {
    this.g = /* @__PURE__ */ new Map();
  }
  get(t6) {
    return this.g.get(t6);
  }
  set(t6, e5) {
    return this.g.set(t6, e5), this.size = this.g.size, this;
  }
  delete(t6) {
    return t6 = this.g.delete(t6), this.size = this.g.size, t6;
  }
  clear() {
    this.g.clear(), this.size = this.g.size;
  }
  has(t6) {
    return this.g.has(t6);
  }
  entries() {
    return this.g.entries();
  }
  keys() {
    return this.g.keys();
  }
  values() {
    return this.g.values();
  }
  forEach(t6, e5) {
    return this.g.forEach(t6, e5);
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
var He = Ve ? (Object.setPrototypeOf(Xe.prototype, Map.prototype), Object.defineProperties(Xe.prototype, { size: { value: 0, configurable: true, enumerable: true, writable: true } }), Xe) : class extends Map {
  constructor() {
    super();
  }
};
function We(t6) {
  return t6;
}
function ze(t6) {
  if (2 & t6.N) throw Error("Cannot mutate an immutable Map");
}
var Ke = class extends He {
  constructor(t6, e5, n6 = We, r5 = We) {
    super();
    let i4 = $t2(t6);
    i4 |= 64, Jt(t6, i4), this.N = i4, this.U = e5, this.S = n6, this.Z = this.U ? Ye : r5;
    for (let s3 = 0; s3 < t6.length; s3++) {
      const o5 = t6[s3], a3 = n6(o5[0], false, true);
      let h5 = o5[1];
      e5 ? void 0 === h5 && (h5 = null) : h5 = r5(o5[1], false, true, void 0, void 0, i4), super.set(a3, h5);
    }
  }
  oa(t6 = $e) {
    if (0 !== this.size) return this.Y(t6);
  }
  Y(t6 = $e) {
    const e5 = [], n6 = super.entries();
    for (var r5; !(r5 = n6.next()).done; ) (r5 = r5.value)[0] = t6(r5[0]), r5[1] = t6(r5[1]), e5.push(r5);
    return e5;
  }
  clear() {
    ze(this), super.clear();
  }
  delete(t6) {
    return ze(this), super.delete(this.S(t6, true, false));
  }
  entries() {
    var t6 = this.na();
    return new le(t6, qe, this);
  }
  keys() {
    return this.Ia();
  }
  values() {
    var t6 = this.na();
    return new le(t6, Ke.prototype.get, this);
  }
  forEach(t6, e5) {
    super.forEach((n6, r5) => {
      t6.call(e5, this.get(r5), r5, this);
    });
  }
  set(t6, e5) {
    return ze(this), null == (t6 = this.S(t6, true, false)) ? this : null == e5 ? (super.delete(t6), this) : super.set(t6, this.Z(e5, true, true, this.U, false, this.N));
  }
  Oa(t6) {
    const e5 = this.S(t6[0], false, true);
    t6 = t6[1], t6 = this.U ? void 0 === t6 ? null : t6 : this.Z(t6, false, true, void 0, false, this.N), super.set(e5, t6);
  }
  has(t6) {
    return super.has(this.S(t6, false, false));
  }
  get(t6) {
    t6 = this.S(t6, false, false);
    const e5 = super.get(t6);
    if (void 0 !== e5) {
      var n6 = this.U;
      return n6 ? ((n6 = this.Z(e5, false, true, n6, this.ta, this.N)) !== e5 && super.set(t6, n6), n6) : e5;
    }
  }
  na() {
    return Array.from(super.keys());
  }
  Ia() {
    return super.keys();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
function Ye(t6, e5, n6, r5, i4, s3) {
  return t6 = Ce(t6, r5, n6, s3), i4 && (t6 = an(t6)), t6;
}
function $e(t6) {
  return t6;
}
function qe(t6) {
  return [t6, this.get(t6)];
}
var Je;
function Ze() {
  return Je ||= new Ke(Zt2([]), void 0, void 0, void 0, je);
}
function Qe(t6, e5, n6, r5, i4) {
  if (null != t6) {
    if (Array.isArray(t6)) t6 = he(t6, void 0, 0) ? void 0 : i4 && 2 & $t2(t6) ? t6 : tn(t6, e5, n6, void 0 !== r5, i4);
    else if (oe(t6)) {
      const s3 = {};
      for (let o5 in t6) s3[o5] = Qe(t6[o5], e5, n6, r5, i4);
      t6 = s3;
    } else t6 = e5(t6, r5);
    return t6;
  }
}
function tn(t6, e5, n6, r5, i4) {
  const s3 = r5 || n6 ? $t2(t6) : 0;
  r5 = r5 ? !!(32 & s3) : void 0;
  const o5 = Gt(t6);
  for (let t7 = 0; t7 < o5.length; t7++) o5[t7] = Qe(o5[t7], e5, n6, r5, i4);
  return n6 && (ge(o5, t6), n6(s3, o5)), o5;
}
function en(t6) {
  return Qe(t6, nn, void 0, void 0, false);
}
function nn(t6) {
  return t6.X === re ? t6.toJSON() : t6 instanceof Ke ? t6.oa(en) : function(t7) {
    switch (typeof t7) {
      case "number":
        return isFinite(t7) ? t7 : String(t7);
      case "boolean":
        return t7 ? 1 : 0;
      case "object":
        if (t7) if (Array.isArray(t7)) {
          if (he(t7, void 0, 0)) return;
        } else {
          if (M2(t7)) return x2(t7);
          if (t7 instanceof B2) {
            const e5 = t7.g;
            return null == e5 ? "" : "string" == typeof e5 ? e5 : t7.g = x2(e5);
          }
          if (t7 instanceof Ke) return t7.oa();
        }
    }
    return t7;
  }(t6);
}
function rn(t6, e5, n6 = te) {
  if (null != t6) {
    if (b2 && t6 instanceof Uint8Array) return e5 ? t6 : new Uint8Array(t6);
    if (Array.isArray(t6)) {
      var r5 = $t2(t6);
      return 2 & r5 || (e5 &&= 0 === r5 || !!(32 & r5) && !(64 & r5 || !(16 & r5)), t6 = e5 ? Jt(t6, -12293 & (34 | r5)) : tn(t6, rn, 4 & r5 ? te : n6, true, true)), t6;
    }
    return t6.X === re ? (n6 = t6.s, t6 = 2 & (r5 = qt2(n6)) ? t6 : sn(t6, n6, r5, true)) : t6 instanceof Ke && !(2 & t6.N) && (n6 = Zt2(t6.Y(rn)), t6 = new Ke(n6, t6.U, t6.S, t6.Z)), t6;
  }
}
function sn(t6, e5, n6, r5) {
  return t6 = t6.constructor, Ie = e5 = on(e5, n6, r5), e5 = new t6(e5), Ie = void 0, e5;
}
function on(t6, e5, n6) {
  const r5 = n6 || 2 & e5 ? te : Qt, i4 = !!(32 & e5);
  return t6 = function(t7, e6, n7) {
    const r6 = Gt(t7);
    var i5 = r6.length;
    const s3 = 256 & e6 ? r6[i5 - 1] : void 0;
    for (i5 += s3 ? -1 : 0, e6 = 512 & e6 ? 1 : 0; e6 < i5; e6++) r6[e6] = n7(r6[e6]);
    if (s3) {
      e6 = r6[e6] = {};
      for (const t8 in s3) e6[t8] = n7(s3[t8]);
    }
    return ge(r6, t7), r6;
  }(t6, e5, (t7) => rn(t7, i4, r5)), zt(t6, 32 | (n6 ? 2 : 0)), t6;
}
function an(t6) {
  const e5 = t6.s, n6 = qt2(e5);
  return 2 & n6 ? sn(t6, e5, n6, false) : t6;
}
function hn(t6, e5, n6, r5) {
  return !(4 & e5) || null != n6 && (!r5 && 0 === n6 && (4096 & e5 || 8192 & e5) && 5 > (t6.constructor[Wt] = 1 + (0 | t6.constructor[Wt])) && ye(), 0 !== n6 && !(n6 & e5));
}
function cn(t6, e5) {
  return ln(t6 = t6.s, qt2(t6), e5);
}
function un(t6, e5, n6, r5) {
  if (!(0 > (e5 = r5 + (+!!(512 & e5) - 1)) || e5 >= t6.length || e5 >= n6)) return t6[e5];
}
function ln(t6, e5, n6, r5) {
  if (-1 === n6) return null;
  const i4 = ee(e5);
  if (!(n6 >= i4)) {
    var s3 = t6.length;
    return r5 && 256 & e5 && null != (r5 = t6[s3 - 1][n6]) ? (un(t6, e5, i4, n6) && null != Ht && (4 <= (e5 = (t6 = pe ??= {})[Ht] || 0) || (t6[Ht] = e5 + 1, ye())), r5) : un(t6, e5, i4, n6);
  }
  return 256 & e5 ? t6[t6.length - 1][n6] : void 0;
}
function dn(t6, e5, n6, r5) {
  const i4 = t6.s;
  let s3 = qt2(i4);
  return ue(s3), fn(i4, s3, e5, n6, r5), t6;
}
function fn(t6, e5, n6, r5, i4) {
  const s3 = ee(e5);
  if (n6 >= s3 || i4) {
    let o5 = e5;
    if (256 & e5) i4 = t6[t6.length - 1];
    else {
      if (null == r5) return o5;
      i4 = t6[s3 + (+!!(512 & e5) - 1)] = {}, o5 |= 256;
    }
    return i4[n6] = r5, n6 < s3 && (t6[n6 + (+!!(512 & e5) - 1)] = void 0), o5 !== e5 && Jt(t6, o5), o5;
  }
  return t6[n6 + (+!!(512 & e5) - 1)] = r5, 256 & e5 && (n6 in (t6 = t6[t6.length - 1]) && delete t6[n6]), e5;
}
function pn(t6, e5, n6, r5, i4) {
  var s3 = 2 & e5;
  let o5 = ln(t6, e5, n6, i4);
  Array.isArray(o5) || (o5 = ne);
  const a3 = !(2 & r5);
  r5 = !(1 & r5);
  const h5 = !!(32 & e5);
  let c5 = $t2(o5);
  return 0 !== c5 || !h5 || s3 || a3 ? 1 & c5 || (c5 |= 1, Jt(o5, c5)) : (c5 |= 33, Jt(o5, c5)), s3 ? (t6 = false, 2 & c5 || (Zt2(o5), t6 = !!(4 & c5)), (r5 || t6) && Object.freeze(o5)) : (s3 = !!(2 & c5) || !!(2048 & c5), r5 && s3 ? (o5 = Gt(o5), r5 = 1, h5 && !a3 && (r5 |= 32), Jt(o5, r5), fn(t6, e5, n6, o5, i4)) : a3 && 32 & c5 && !s3 && Kt2(o5, 32)), o5;
}
function gn(t6, e5) {
  t6 = t6.s;
  let n6 = qt2(t6);
  const r5 = ln(t6, n6, e5), i4 = ve(r5);
  return null != i4 && i4 !== r5 && fn(t6, n6, e5, i4), i4;
}
function mn(t6) {
  t6 = t6.s;
  let e5 = qt2(t6);
  const n6 = ln(t6, e5, 1), r5 = ae(n6, true, !!(34 & e5));
  return null != r5 && r5 !== n6 && fn(t6, e5, 1, r5), r5;
}
function yn(t6, e5, n6) {
  const r5 = t6.s;
  let i4 = qt2(r5);
  const s3 = 2 & i4 ? 1 : 2;
  let o5 = _n(r5, i4, e5);
  var a3 = $t2(o5);
  if (hn(t6, a3, void 0, false)) {
    (4 & a3 || Object.isFrozen(o5)) && (o5 = Gt(o5), a3 = In(a3, i4), i4 = fn(r5, i4, e5, o5));
    let s4 = t6 = 0;
    for (; t6 < o5.length; t6++) {
      const e6 = n6(o5[t6]);
      null != e6 && (o5[s4++] = e6);
    }
    s4 < t6 && (o5.length = s4), a3 = Yt(a3 = vn(a3, i4), 20, true), a3 = Yt(a3, 4096, false), a3 = Yt(a3, 8192, false), Jt(o5, a3), 2 & a3 && Object.freeze(o5);
  }
  return En(a3) || (n6 = a3, (a3 = (t6 = 1 === s3 || 4 === s3 && !!(32 & a3)) ? Yt(a3, 2, true) : Un(a3, i4, false)) !== n6 && Jt(o5, a3), t6 && Object.freeze(o5)), 2 === s3 && En(a3) && (o5 = Gt(o5), a3 = Un(a3 = In(a3, i4), i4, false), Jt(o5, a3), fn(r5, i4, e5, o5)), o5;
}
function _n(t6, e5, n6) {
  return t6 = ln(t6, e5, n6), Array.isArray(t6) ? t6 : ne;
}
function vn(t6, e5) {
  return 0 === t6 && (t6 = In(t6, e5)), Yt(t6, 1, true);
}
function En(t6) {
  return !!(2 & t6) && !!(4 & t6) || !!(2048 & t6);
}
function wn(t6) {
  t6 = Gt(t6);
  for (let e5 = 0; e5 < t6.length; e5++) {
    const n6 = t6[e5] = Gt(t6[e5]);
    Array.isArray(n6[1]) && (n6[1] = Zt2(n6[1]));
  }
  return t6;
}
function Tn(t6, e5, n6) {
  {
    const a3 = t6.s;
    let h5 = qt2(a3);
    if (ue(h5), null == n6) fn(a3, h5, e5);
    else {
      var r5, i4 = $t2(n6), s3 = i4, o5 = !!(2 & i4) || Object.isFrozen(n6);
      if ((r5 = !o5) && (r5 = false), hn(t6, i4)) for (i4 = 21, o5 && (n6 = Gt(n6), s3 = 0, i4 = Un(i4 = In(i4, h5), h5, true)), t6 = 0; t6 < n6.length; t6++) n6[t6] = Re2(n6[t6]);
      r5 && (n6 = Gt(n6), s3 = 0, i4 = Un(i4 = In(i4, h5), h5, true)), i4 !== s3 && Jt(n6, i4), fn(a3, h5, e5, n6);
    }
  }
}
function An(t6, e5, n6, r5) {
  t6 = t6.s;
  let i4 = qt2(t6);
  ue(i4), fn(t6, i4, e5, ("0" === r5 ? 0 === Number(n6) : n6 === r5) ? void 0 : n6);
}
function bn(t6, e5, n6, r5) {
  const i4 = qt2(t6);
  ue(i4), t6 = pn(t6, i4, e5, 2), r5 = n6(r5, !!(4 & (e5 = $t2(t6))) && !!(4096 & e5)), t6.push(r5);
}
function kn(t6) {
  return t6;
}
function xn(t6, e5) {
  return Sn(t6 = t6.s, qt2(t6), ws) === e5 ? e5 : -1;
}
function Sn(t6, e5, n6) {
  let r5 = 0;
  for (let i4 = 0; i4 < n6.length; i4++) {
    const s3 = n6[i4];
    null != ln(t6, e5, s3) && (0 !== r5 && (e5 = fn(t6, e5, r5)), r5 = s3);
  }
  return r5;
}
function Ln(t6, e5, n6, r5) {
  let i4 = qt2(t6);
  ue(i4);
  const s3 = ln(t6, i4, n6, r5);
  let o5;
  if (null != s3 && s3.X === re) return (e5 = an(s3)) !== s3 && fn(t6, i4, n6, e5, r5), e5.s;
  if (Array.isArray(s3)) {
    const t7 = $t2(s3);
    o5 = 2 & t7 ? on(s3, t7, false) : s3, o5 = Be(o5, e5);
  } else o5 = Be(void 0, e5);
  return o5 !== s3 && fn(t6, i4, n6, o5, r5), o5;
}
function Fn(t6, e5, n6, r5) {
  t6 = t6.s;
  let i4 = qt2(t6);
  const s3 = ln(t6, i4, n6, r5);
  return (e5 = Ce(s3, e5, false, i4)) !== s3 && null != e5 && fn(t6, i4, n6, e5, r5), e5;
}
function Rn(t6, e5, n6, r5 = false) {
  if (null == (e5 = Fn(t6, e5, n6, r5))) return e5;
  t6 = t6.s;
  let i4 = qt2(t6);
  if (!(2 & i4)) {
    const s3 = an(e5);
    s3 !== e5 && fn(t6, i4, n6, e5 = s3, r5);
  }
  return e5;
}
function Mn(t6, e5, n6, r5, i4, s3) {
  var o5 = 2, a3 = !!(2 & e5);
  o5 = a3 ? 1 : o5, i4 = !!i4, s3 &&= !a3, a3 = _n(t6, e5, r5);
  var h5 = $t2(a3);
  const c5 = !!(4 & h5);
  if (!c5) {
    var u3 = a3, l3 = e5;
    const t7 = !!(2 & (h5 = vn(h5, e5)));
    t7 && (l3 = Yt(l3, 2, true));
    let r6 = !t7, i5 = true, s4 = 0, o6 = 0;
    for (; s4 < u3.length; s4++) {
      const e6 = Ce(u3[s4], n6, false, l3);
      if (e6 instanceof n6) {
        if (!t7) {
          const t8 = !!(2 & $t2(e6.s));
          r6 &&= !t8, i5 &&= t8;
        }
        u3[o6++] = e6;
      }
    }
    o6 < s4 && (u3.length = o6), h5 = Yt(h5, 4, true), h5 = Yt(h5, 16, i5), h5 = Yt(h5, 8, r6), Jt(u3, h5), t7 && Object.freeze(u3);
  }
  if (s3 && !(8 & h5 || !a3.length && (1 === o5 || 4 === o5 && 32 & h5))) {
    for (En(h5) && (a3 = Gt(a3), h5 = In(h5, e5), e5 = fn(t6, e5, r5, a3)), n6 = a3, s3 = h5, u3 = 0; u3 < n6.length; u3++) (h5 = n6[u3]) !== (l3 = an(h5)) && (n6[u3] = l3);
    s3 = Yt(s3, 8, true), s3 = Yt(s3, 16, !n6.length), Jt(n6, s3), h5 = s3;
  }
  return En(h5) || (n6 = h5, (h5 = (s3 = 1 === o5 || 4 === o5 && !!(32 & h5)) ? Yt(h5, !a3.length || 16 & h5 && (!c5 || 32 & h5) ? 2 : 2048, true) : Un(h5, e5, i4)) !== n6 && Jt(a3, h5), s3 && Object.freeze(a3)), 2 === o5 && En(h5) && (a3 = Gt(a3), h5 = Un(h5 = In(h5, e5), e5, i4), Jt(a3, h5), fn(t6, e5, r5, a3)), a3;
}
function Pn(t6, e5, n6) {
  t6 = t6.s;
  const r5 = qt2(t6);
  return Mn(t6, r5, e5, n6, false, !(2 & r5));
}
function Cn(t6, e5, n6, r5, i4) {
  return null == r5 && (r5 = void 0), dn(t6, n6, r5, i4);
}
function On(t6, e5, n6, r5) {
  null == r5 && (r5 = void 0), t6 = t6.s;
  let i4 = qt2(t6);
  ue(i4), (n6 = Sn(t6, i4, n6)) && n6 !== e5 && null != r5 && (i4 = fn(t6, i4, n6)), fn(t6, i4, e5, r5);
}
function In(t6, e5) {
  return t6 = Yt(t6, 2, !!(2 & e5)), t6 = Yt(t6, 32, true), Yt(t6, 2048, false);
}
function Un(t6, e5, n6) {
  return 32 & e5 && n6 || (t6 = Yt(t6, 32, false)), t6;
}
function Dn(t6, e5, n6, r5) {
  t6 = t6.s;
  const i4 = qt2(t6);
  ue(i4), e5 = Mn(t6, i4, n6, e5, true), n6 = null != r5 ? r5 : new n6(), e5.push(n6), 2 & $t2(n6.s) ? Kt2(e5, 8) : Kt2(e5, 16);
}
function Nn(t6, e5) {
  return Ae(cn(t6, e5));
}
function Bn(t6, e5) {
  return t6 ?? e5;
}
function Gn(t6, e5) {
  return Bn(gn(t6, e5), 0);
}
function jn(t6, e5) {
  return Bn(Pe(cn(t6, e5)), "");
}
function Vn(t6, e5, n6) {
  if (null != n6 && "boolean" != typeof n6) throw t6 = typeof n6, Error(`Expected boolean but got ${"object" != t6 ? t6 : n6 ? Array.isArray(n6) ? "array" : t6 : "null"}: ${n6}`);
  dn(t6, e5, n6);
}
function Xn(t6, e5, n6) {
  if (null != n6) {
    if ("number" != typeof n6) throw _e("int32");
    if (!Number.isFinite(n6)) throw _e("int32");
    n6 |= 0;
  }
  dn(t6, e5, n6);
}
function Hn(t6, e5, n6) {
  if (null != n6 && "number" != typeof n6) throw Error(`Value of float/double field must be a number, found ${typeof n6}: ${n6}`);
  dn(t6, e5, n6);
}
function Wn(t6, e5, n6) {
  e5.g ? e5.m(t6, e5.g, e5.h, n6, true) : e5.m(t6, e5.h, n6, true);
}
Ke.prototype.toJSON = void 0, Ke.prototype.Ja = ie;
var zn = class {
  constructor(t6, e5) {
    this.s = Ge(t6, e5);
  }
  toJSON() {
    return Kn(this, tn(this.s, nn, void 0, void 0, false), true);
  }
  l() {
    var t6 = ko;
    return t6.g ? t6.l(this, t6.g, t6.h, true) : t6.l(this, t6.h, t6.defaultValue, true);
  }
  clone() {
    const t6 = this.s;
    return sn(this, t6, qt2(t6), false);
  }
  P() {
    return !!(2 & $t2(this.s));
  }
};
function Kn(t6, e5, n6) {
  var r5 = d2 ? void 0 : t6.constructor.B;
  const i4 = qt2(n6 ? t6.s : e5);
  if (!(t6 = e5.length)) return e5;
  let s3, o5;
  if (oe(n6 = e5[t6 - 1])) {
    t: {
      var a3 = n6;
      let t7 = {}, e6 = false;
      for (var h5 in a3) {
        let n7 = a3[h5];
        if (Array.isArray(n7)) {
          let t8 = n7;
          (he(n7, r5, +h5) || se(n7) && 0 === n7.size) && (n7 = null), n7 != t8 && (e6 = true);
        }
        null != n7 ? t7[h5] = n7 : e6 = true;
      }
      if (e6) {
        for (var c5 in t7) {
          a3 = t7;
          break t;
        }
        a3 = null;
      }
    }
    a3 != n6 && (s3 = true), t6--;
  }
  for (h5 = +!!(512 & i4) - 1; 0 < t6 && (n6 = e5[c5 = t6 - 1], c5 -= h5, null == n6 || he(n6, r5, c5) || se(n6) && 0 === n6.size); t6--) o5 = true;
  return s3 || o5 ? (e5 = Array.prototype.slice.call(e5, 0, t6), a3 && e5.push(a3), e5) : e5;
}
function Yn(t6) {
  return Array.isArray(t6) ? t6[0] instanceof Bt ? t6 : [$r, t6] : [t6, void 0];
}
function $n(t6, e5) {
  if (Array.isArray(e5)) {
    var n6 = $t2(e5);
    if (4 & n6) return e5;
    for (var r5 = 0, i4 = 0; r5 < e5.length; r5++) {
      const n7 = t6(e5[r5]);
      null != n7 && (e5[i4++] = n7);
    }
    return i4 < r5 && (e5.length = i4), Jt(e5, -12289 & (5 | n6)), 2 & n6 && Object.freeze(e5), e5;
  }
}
zn.prototype.X = re, zn.prototype.toString = function() {
  return Kn(this, this.s, false).toString();
};
var qn = Symbol();
function Jn(t6) {
  let e5 = t6[qn];
  if (!e5) {
    const n6 = sr(t6), r5 = yr(t6), i4 = r5.l;
    e5 = i4 ? (t7, e6) => i4(t7, e6, r5) : (t7, e6) => {
      for (; mt2(e6) && 4 != e6.h; ) {
        var i5 = e6.m, s3 = r5[i5];
        if (!s3) {
          var o5 = r5.ea;
          o5 && (o5 = o5[i5]) && (s3 = r5[i5] = Zn(o5));
        }
        s3 && s3(e6, t7, i5) || (i5 = (s3 = e6).l, yt2(s3), s3.ia ? s3 = void 0 : (o5 = s3.g.g - i5, s3.g.g = i5, s3 = pt(s3.g, o5)), i5 = t7, s3 && (de ||= Symbol(), (o5 = i5[de]) ? o5.push(s3) : i5[de] = [s3]));
      }
      n6 === tr || n6 === er || n6.j || (t7[fe ||= Symbol()] = n6);
    }, t6[qn] = e5;
  }
  return e5;
}
function Zn(t6) {
  const e5 = (t6 = Yn(t6))[0].g;
  if (t6 = t6[1]) {
    const n6 = Jn(t6), r5 = yr(t6).T;
    return (t7, i4, s3) => e5(t7, i4, s3, r5, n6);
  }
  return e5;
}
var Qn = class {
};
var tr;
var er;
var nr = Symbol();
function rr(t6, e5, n6) {
  const r5 = n6[1];
  let i4;
  if (r5) {
    const n7 = r5[nr];
    i4 = n7 ? n7.T : Ne(r5[0]), t6[e5] = n7 ?? r5;
  }
  i4 && i4 === Ue ? (t6.g || (t6.g = /* @__PURE__ */ new Set())).add(e5) : n6[0] && (t6.h || (t6.h = /* @__PURE__ */ new Set())).add(e5);
}
function ir(t6, e5) {
  return [t6.l, !e5 || 0 < e5[0] ? void 0 : e5];
}
function sr(t6) {
  var e5 = t6[nr];
  if (e5) return e5;
  if (!(e5 = ar(t6, t6[nr] = new Qn(), ir, ir, rr)).ea && !e5.h && !e5.g) {
    let n6 = true;
    for (let t7 in e5) isNaN(t7) || (n6 = false);
    n6 ? (Ne(t6[0]) === Ue ? er ? e5 = er : ((e5 = new Qn()).T = Ne(true), e5 = er = e5) : e5 = tr ||= new Qn(), e5 = t6[nr] = e5) : e5.j = true;
  }
  return e5;
}
function or(t6, e5, n6) {
  t6[e5] = n6;
}
function ar(t6, e5, n6, r5, i4 = or) {
  e5.T = Ne(t6[0]);
  let s3 = 0;
  var o5 = t6[++s3];
  o5 && o5.constructor === Object && (e5.ea = o5, "function" == typeof (o5 = t6[++s3]) && (e5.l = o5, e5.m = t6[++s3], o5 = t6[++s3]));
  const a3 = {};
  for (; Array.isArray(o5) && "number" == typeof o5[0] && 0 < o5[0]; ) {
    for (var h5 = 0; h5 < o5.length; h5++) a3[o5[h5]] = o5;
    o5 = t6[++s3];
  }
  for (h5 = 1; void 0 !== o5; ) {
    let l3;
    "number" == typeof o5 && (h5 += o5, o5 = t6[++s3]);
    var c5 = void 0;
    if (o5 instanceof Bt ? l3 = o5 : (l3 = qr, s3--), l3.pa) {
      o5 = t6[++s3], c5 = t6;
      var u3 = s3;
      "function" == typeof o5 && (o5 = o5(), c5[u3] = o5), c5 = o5;
    }
    for (u3 = h5 + 1, "number" == typeof (o5 = t6[++s3]) && 0 > o5 && (u3 -= o5, o5 = t6[++s3]); h5 < u3; h5++) {
      const t7 = a3[h5];
      i4(e5, h5, c5 ? r5(l3, c5, t7) : n6(l3, t7));
    }
  }
  return e5;
}
var hr = Symbol();
function cr(t6) {
  let e5 = t6[hr];
  if (!e5) {
    const n6 = fr(t6);
    e5 = (t7, e6) => Er(t7, e6, n6), t6[hr] = e5;
  }
  return e5;
}
var ur = Symbol();
function lr(t6) {
  return t6.h;
}
function dr(t6, e5) {
  let n6, r5;
  const i4 = t6.h;
  return (t7, s3, o5) => i4(t7, s3, o5, r5 ||= fr(e5).T, n6 ||= cr(e5));
}
function fr(t6) {
  let e5 = t6[ur];
  return e5 || (e5 = ar(t6, t6[ur] = {}, lr, dr), _r(t6), e5);
}
var pr = Symbol();
function gr(t6, e5) {
  const n6 = t6.g;
  return e5 ? (t7, r5, i4) => n6(t7, r5, i4, e5) : n6;
}
function mr(t6, e5, n6) {
  const r5 = t6.g;
  let i4, s3;
  return (t7, o5, a3) => r5(t7, o5, a3, s3 ||= yr(e5).T, i4 ||= Jn(e5), n6);
}
function yr(t6) {
  let e5 = t6[pr];
  return e5 || (sr(t6), e5 = ar(t6, t6[pr] = {}, gr, mr), _r(t6), e5);
}
function _r(t6) {
  pr in t6 && nr in t6 && ur in t6 && (t6.length = 0);
}
function vr(t6, e5) {
  var n6 = t6[e5];
  if (n6) return n6;
  if ((n6 = t6.ea) && (n6 = n6[e5])) {
    var r5 = (n6 = Yn(n6))[0].h;
    if (n6 = n6[1]) {
      const e6 = cr(n6), i4 = fr(n6).T;
      n6 = (n6 = t6.m) ? n6(i4, e6) : (t7, n7, s3) => r5(t7, n7, s3, i4, e6);
    } else n6 = r5;
    return t6[e5] = n6;
  }
}
function Er(t6, e5, n6) {
  for (var r5 = qt2(t6), i4 = +!!(512 & r5) - 1, s3 = t6.length, o5 = 512 & r5 ? 1 : 0, a3 = s3 + (256 & r5 ? -1 : 0); o5 < a3; o5++) {
    const r6 = t6[o5];
    if (null == r6) continue;
    const s4 = o5 - i4, a4 = vr(n6, s4);
    a4 && a4(e5, r6, s4);
  }
  if (256 & r5) {
    r5 = t6[s3 - 1];
    for (let t7 in r5) i4 = +t7, Number.isNaN(i4) || null != (s3 = r5[t7]) && (a3 = vr(n6, i4)) && a3(e5, s3, i4);
  }
  if (t6 = de ? t6[de] : void 0) for (Ct(e5, e5.g.end()), n6 = 0; n6 < t6.length; n6++) Ct(e5, N2(t6[n6]) || C());
}
function wr(t6, e5) {
  return new Bt(t6, e5, false, false);
}
function Tr(t6, e5) {
  return new Bt(t6, e5, true, false);
}
function Ar(t6, e5) {
  return new Bt(t6, e5, false, true);
}
function br(t6, e5, n6) {
  fn(t6, qt2(t6), e5, n6);
}
var kr = Ar(function(t6, e5, n6, r5, i4) {
  return 2 === t6.h && (t6 = _t2(t6, Be([void 0, void 0], r5), i4), ue(r5 = qt2(e5)), (i4 = ln(e5, r5, n6)) instanceof Ke ? 0 != (2 & i4.N) ? ((i4 = i4.Y()).push(t6), fn(e5, r5, n6, i4)) : i4.Oa(t6) : Array.isArray(i4) ? (2 & $t2(i4) && fn(e5, r5, n6, i4 = wn(i4)), i4.push(t6)) : fn(e5, r5, n6, [t6]), true);
}, function(t6, e5, n6, r5, i4) {
  if (e5 instanceof Ke) e5.forEach((e6, s3) => {
    Nt(t6, n6, Be([s3, e6], r5), i4);
  });
  else if (Array.isArray(e5)) for (let s3 = 0; s3 < e5.length; s3++) {
    const o5 = e5[s3];
    Array.isArray(o5) && Nt(t6, n6, Be(o5, r5), i4);
  }
});
function xr(t6, e5, n6) {
  t: if (null != e5) {
    if (Te(e5)) {
      if ("string" == typeof e5) {
        e5 = Le(e5);
        break t;
      }
      if ("number" == typeof e5) {
        e5 = Se2(e5);
        break t;
      }
    }
    e5 = void 0;
  }
  null != e5 && ("string" == typeof e5 && xt(e5), null != e5 && (Ot(t6, n6, 0), "number" == typeof e5 ? (t6 = t6.g, $2(e5), Ft(t6, K2, Y2)) : (n6 = xt(e5), Ft(t6.g, n6.h, n6.g))));
}
function Sr(t6, e5, n6) {
  null != (e5 = Ae(e5)) && null != e5 && (Ot(t6, n6, 0), Mt(t6.g, e5));
}
function Lr(t6, e5, n6) {
  null != (e5 = Ee(e5)) && (Ot(t6, n6, 0), t6.g.g.push(e5 ? 1 : 0));
}
function Fr(t6, e5, n6) {
  null != (e5 = Pe(e5)) && Dt(t6, n6, c4(e5));
}
function Rr(t6, e5, n6, r5, i4) {
  Nt(t6, n6, e5 instanceof zn ? e5.s : Array.isArray(e5) ? Be(e5, r5) : void 0, i4);
}
function Mr(t6, e5, n6) {
  null != (e5 = null == e5 || "string" == typeof e5 || M2(e5) || e5 instanceof B2 ? e5 : void 0) && Dt(t6, n6, X(e5).buffer);
}
function Pr(t6, e5, n6) {
  return (5 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n6, 2, false), 2 == t6.h ? wt2(t6, ct, e5) : e5.push(ct(t6.g)), true);
}
var Cr;
var Or = wr(function(t6, e5, n6) {
  if (1 !== t6.h) return false;
  var r5 = t6.g;
  t6 = ht(r5);
  const i4 = ht(r5);
  r5 = 2 * (i4 >> 31) + 1;
  const s3 = i4 >>> 20 & 2047;
  return t6 = 4294967296 * (1048575 & i4) + t6, br(e5, n6, 2047 == s3 ? t6 ? NaN : 1 / 0 * r5 : 0 == s3 ? r5 * Math.pow(2, -1074) * t6 : r5 * Math.pow(2, s3 - 1075) * (t6 + 4503599627370496)), true;
}, function(t6, e5, n6) {
  null != (e5 = ve(e5)) && (Ot(t6, n6, 1), t6 = t6.g, (n6 = z2 ||= new DataView(new ArrayBuffer(8))).setFloat64(0, +e5, true), K2 = n6.getUint32(0, true), Y2 = n6.getUint32(4, true), Pt(t6, K2), Pt(t6, Y2));
});
var Ir = wr(function(t6, e5, n6) {
  return 5 === t6.h && (br(e5, n6, ct(t6.g)), true);
}, function(t6, e5, n6) {
  null != (e5 = ve(e5)) && (Ot(t6, n6, 5), t6 = t6.g, q2(e5), Pt(t6, K2));
});
var Ur = Tr(Pr, function(t6, e5, n6) {
  if (null != (e5 = $n(ve, e5))) for (let o5 = 0; o5 < e5.length; o5++) {
    var r5 = t6, i4 = n6, s3 = e5[o5];
    null != s3 && (Ot(r5, i4, 5), r5 = r5.g, q2(s3), Pt(r5, K2));
  }
});
var Dr = Tr(Pr, function(t6, e5, n6) {
  if (null != (e5 = $n(ve, e5)) && e5.length) {
    Ot(t6, n6, 2), Rt(t6.g, 4 * e5.length);
    for (let r5 = 0; r5 < e5.length; r5++) n6 = t6.g, q2(e5[r5]), Pt(n6, K2);
  }
});
var Nr = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, it(t6.g, Z2)), true);
}, xr);
var Br = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, 0 === (t6 = it(t6.g, Z2)) ? void 0 : t6), true);
}, xr);
var Gr = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, it(t6.g, J)), true);
}, function(t6, e5, n6) {
  t: if (null != e5) {
    if (Te(e5)) {
      if ("string" == typeof e5) {
        var r5 = Math.trunc(Number(e5));
        Number.isSafeInteger(r5) && 0 <= r5 ? e5 = String(r5) : (-1 !== (r5 = e5.indexOf(".")) && (e5 = e5.substring(0, r5)), ke2(e5) || (nt(e5), e5 = Q2(K2, Y2)));
        break t;
      }
      if ("number" == typeof e5) {
        e5 = 0 <= (e5 = Math.trunc(e5)) && Number.isSafeInteger(e5) ? e5 : function(t7) {
          if (0 > t7) {
            $2(t7);
            const e6 = Q2(K2, Y2);
            return t7 = Number(e6), Number.isSafeInteger(t7) ? t7 : e6;
          }
          return ke2(String(t7)) ? t7 : ($2(t7), J(K2, Y2));
        }(e5);
        break t;
      }
    }
    e5 = void 0;
  }
  null != e5 && ("string" == typeof e5 && At(e5), null != e5 && (Ot(t6, n6, 0), "number" == typeof e5 ? (t6 = t6.g, $2(e5), Ft(t6, K2, Y2)) : (n6 = At(e5), Ft(t6.g, n6.h, n6.g))));
});
var jr = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, ot(t6.g)), true);
}, Sr);
var Vr = Tr(function(t6, e5, n6) {
  return (0 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n6, 2, false), 2 == t6.h ? wt2(t6, ot, e5) : e5.push(ot(t6.g)), true);
}, function(t6, e5, n6) {
  if (null != (e5 = $n(Ae, e5)) && e5.length) {
    n6 = It(t6, n6);
    for (let n7 = 0; n7 < e5.length; n7++) Mt(t6.g, e5[n7]);
    Ut(t6, n6);
  }
});
var Xr = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, 0 === (t6 = ot(t6.g)) ? void 0 : t6), true);
}, Sr);
var Hr = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, st2(t6.g)), true);
}, Lr);
var Wr = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, false === (t6 = st2(t6.g)) ? void 0 : t6), true);
}, Lr);
var zr = Tr(function(t6, e5, n6) {
  return 2 === t6.h && (bn(e5, n6, kn, t6 = vt(t6)), true);
}, function(t6, e5, n6) {
  if (null != (e5 = $n(Pe, e5))) for (let o5 = 0; o5 < e5.length; o5++) {
    var r5 = t6, i4 = n6, s3 = e5[o5];
    null != s3 && Dt(r5, i4, c4(s3));
  }
});
var Kr = wr(function(t6, e5, n6) {
  return 2 === t6.h && (br(e5, n6, "" === (t6 = vt(t6)) ? void 0 : t6), true);
}, Fr);
var Yr = wr(function(t6, e5, n6) {
  return 2 === t6.h && (br(e5, n6, vt(t6)), true);
}, Fr);
var $r = Ar(function(t6, e5, n6, r5, i4) {
  return 2 === t6.h && (_t2(t6, Ln(e5, r5, n6, true), i4), true);
}, Rr);
var qr = Ar(function(t6, e5, n6, r5, i4) {
  return 2 === t6.h && (_t2(t6, Ln(e5, r5, n6), i4), true);
}, Rr);
Cr = new Bt(function(t6, e5, n6, r5, i4) {
  if (2 !== t6.h) return false;
  r5 = Be(void 0, r5);
  let s3 = qt2(e5);
  ue(s3);
  let o5 = pn(e5, s3, n6, 3);
  return s3 = qt2(e5), 4 & $t2(o5) && (o5 = Gt(o5), Jt(o5, -2079 & (1 | $t2(o5))), fn(e5, s3, n6, o5)), o5.push(r5), _t2(t6, r5, i4), true;
}, function(t6, e5, n6, r5, i4) {
  if (Array.isArray(e5)) for (let s3 = 0; s3 < e5.length; s3++) Rr(t6, e5[s3], n6, r5, i4);
}, true, true);
var Jr = Ar(function(t6, e5, n6, r5, i4, s3) {
  if (2 !== t6.h) return false;
  let o5 = qt2(e5);
  return ue(o5), (s3 = Sn(e5, o5, s3)) && n6 !== s3 && fn(e5, o5, s3), _t2(t6, e5 = Ln(e5, r5, n6), i4), true;
}, Rr);
var Zr = wr(function(t6, e5, n6) {
  return 2 === t6.h && (br(e5, n6, Et(t6)), true);
}, Mr);
var Qr = Tr(function(t6, e5, n6) {
  return (0 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n6, 2, false), 2 == t6.h ? wt2(t6, at, e5) : e5.push(at(t6.g)), true);
}, function(t6, e5, n6) {
  if (null != (e5 = $n(be, e5))) for (let o5 = 0; o5 < e5.length; o5++) {
    var r5 = t6, i4 = n6, s3 = e5[o5];
    null != s3 && (Ot(r5, i4, 0), Rt(r5.g, s3));
  }
});
var ti = wr(function(t6, e5, n6) {
  return 0 === t6.h && (br(e5, n6, ot(t6.g)), true);
}, function(t6, e5, n6) {
  null != (e5 = Ae(e5)) && (e5 = parseInt(e5, 10), Ot(t6, n6, 0), Mt(t6.g, e5));
});
var ei = Tr(function(t6, e5, n6) {
  return (0 === t6.h || 2 === t6.h) && (e5 = pn(e5, qt2(e5), n6, 2, false), 2 == t6.h ? wt2(t6, ut, e5) : e5.push(ot(t6.g)), true);
}, function(t6, e5, n6) {
  if (null != (e5 = $n(Ae, e5)) && e5.length) {
    n6 = It(t6, n6);
    for (let n7 = 0; n7 < e5.length; n7++) Mt(t6.g, e5[n7]);
    Ut(t6, n6);
  }
});
var ni = class {
  constructor(t6, e5) {
    this.h = t6, this.g = e5, this.l = Rn, this.m = Cn, this.defaultValue = void 0;
  }
};
function ri(t6, e5) {
  return new ni(t6, e5);
}
function ii2(t6, e5) {
  return (n6, r5) => {
    if (Tt.length) {
      const t7 = Tt.pop();
      t7.o(r5), lt2(t7.g, n6, r5), n6 = t7;
    } else n6 = new class {
      constructor(t7, e6) {
        if (gt2.length) {
          const n7 = gt2.pop();
          lt2(n7, t7, e6), t7 = n7;
        } else t7 = new class {
          constructor(t8, e7) {
            this.h = null, this.m = false, this.g = this.l = this.j = 0, lt2(this, t8, e7);
          }
          clear() {
            this.h = null, this.m = false, this.g = this.l = this.j = 0, this.ca = false;
          }
        }(t7, e6);
        this.g = t7, this.l = this.g.g, this.h = this.m = -1, this.o(e6);
      }
      o({ ia: t7 = false } = {}) {
        this.ia = t7;
      }
    }(n6, r5);
    try {
      const r6 = new t6(), s3 = r6.s;
      Jn(e5)(s3, n6);
      var i4 = r6;
    } finally {
      n6.g.clear(), n6.m = -1, n6.h = -1, 100 > Tt.length && Tt.push(n6);
    }
    return i4;
  };
}
function si2(t6) {
  return function() {
    const e5 = new class {
      constructor() {
        this.l = [], this.h = 0, this.g = new class {
          constructor() {
            this.g = [];
          }
          length() {
            return this.g.length;
          }
          end() {
            const t7 = this.g;
            return this.g = [], t7;
          }
        }();
      }
    }();
    Er(this.s, e5, fr(t6)), Ct(e5, e5.g.end());
    const n6 = new Uint8Array(e5.h), r5 = e5.l, i4 = r5.length;
    let s3 = 0;
    for (let t7 = 0; t7 < i4; t7++) {
      const e6 = r5[t7];
      n6.set(e6, s3), s3 += e6.length;
    }
    return e5.l = [n6], n6;
  };
}
var oi = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ai = [0, Kr, wr(function(t6, e5, n6) {
  return 2 === t6.h && (br(e5, n6, (t6 = Et(t6)) === D2() ? void 0 : t6), true);
}, function(t6, e5, n6) {
  if (null != e5) {
    if (e5 instanceof zn) {
      const r5 = e5.Qa;
      return void (r5 && (e5 = r5(e5), null != e5 && Dt(t6, n6, X(e5).buffer)));
    }
    if (Array.isArray(e5)) return;
  }
  Mr(t6, e5, n6);
})];
var hi = [0, Yr];
var ci = [0, jr, ti, Hr, -1, Vr, ti, -1];
var ui = [0, Hr, -1];
var li = class extends zn {
  constructor() {
    super();
  }
};
li.B = [6];
var di = [0, Hr, Yr, Hr, ti, -1, ei, Yr, -1, ui, ti];
var fi = [0, Yr, -2];
var pi = class extends zn {
  constructor() {
    super();
  }
};
var gi = [0];
var mi = [0, jr, Hr, -4];
var yi = class extends zn {
  constructor(t6) {
    super(t6, 2);
  }
};
var _i = {};
var vi = [-2, _i, Hr];
_i[336783863] = [0, Yr, Hr, -1, jr, [0, [1, 2, 3, 4, 5, 6], Jr, gi, Jr, di, Jr, fi, Jr, mi, Jr, ci, Jr, [0, Yr]], hi, Hr, [0, [1, 3], [2, 4], Jr, [0, Vr], -1, Jr, [0, zr], -1, Cr, [0, Yr, -1]], Yr];
var Ei = [0, Kr, Wr];
var wi = [0, Br, -1, Wr, -3, Br, Vr, Kr, Xr, Br, -1, Wr, Xr, Wr, -2, Kr];
var Ti = [-1, {}];
var Ai = [0, Yr, 1, Ti];
var bi = [0, Yr, zr, Ti];
function ki(t6, e5) {
  An(t6, 2, Me(e5), "");
}
function xi(t6, e5) {
  bn(t6.s, 3, Re2, e5);
}
function Si(t6, e5) {
  bn(t6.s, 4, Re2, e5);
}
var Li = class extends zn {
  constructor(t6) {
    super(t6, 500);
  }
  o(t6) {
    return Cn(this, 0, 7, t6);
  }
};
Li.B = [3, 4, 5, 6, 8, 13, 17, 1005];
var Fi = [-500, Kr, -1, zr, -3, vi, Cr, ai, Xr, -1, Ai, bi, Cr, Ei, Kr, wi, Xr, zr, 987, zr];
var Ri = [0, Kr, -1, Ti];
var Mi = [-500, Yr, -1, [-1, {}], 998, Yr];
var Pi = [-500, Yr, zr, -1, [-2, {}, Hr], 997, zr, -1];
var Ci = [-500, Yr, zr, Ti, 998, zr];
function Oi(t6, e5) {
  Dn(t6, 1, Li, e5);
}
function Ii(t6, e5) {
  bn(t6.s, 10, Re2, e5);
}
function Ui(t6, e5) {
  bn(t6.s, 15, Re2, e5);
}
var Di = class extends zn {
  constructor(t6) {
    super(t6, 500);
  }
  o(t6) {
    return Cn(this, 0, 1001, t6);
  }
};
Di.B = [1, 6, 7, 9, 10, 15, 16, 17, 14, 1002];
var Ni = [-500, Cr, Fi, 4, Cr, Mi, Cr, Pi, Xr, Cr, Ci, zr, Xr, Ai, bi, Cr, Ri, zr, -2, wi, Kr, -1, Wr, 979, Ti, Cr, ai];
var Bi = ii2(Di, Ni);
Di.prototype.g = si2(Ni);
var Gi = [0, Cr, [0, jr, -2]];
var ji = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Vi = [0, jr, Ir, Yr, -1];
var Xi = class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    return Pn(this, ji, 1);
  }
};
Xi.B = [1];
var Hi = [0, Cr, Vi];
var Wi = ii2(Xi, Hi);
var zi = [0, jr, Ir];
var Ki = [0, jr, -1, Gi];
var Yi = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var $i = [0, jr, -3];
var qi = [0, Ir, -3];
var Ji = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Zi = [0, Ir, -1, Yr, Ir];
var Qi = class extends zn {
  constructor(t6) {
    super(t6);
  }
  h() {
    return Rn(this, Yi, 2);
  }
  g() {
    return Pn(this, Ji, 5);
  }
};
Qi.B = [5];
var ts = [0, ti, $i, qi, Ki, Cr, Zi];
var es = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
es.B = [1, 2, 3, 8, 9];
var ns = ii2(es, [0, zr, Vr, Dr, ts, Yr, -1, Nr, Cr, zi, zr, Nr]);
var rs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var is = [0, Ir, -4];
var ss = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ss.B = [1];
var os = ii2(ss, [0, Cr, is]);
var as = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var hs = [0, Ir, -4];
var cs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
cs.B = [1];
var us = ii2(cs, [0, Cr, hs]);
var ls = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ls.B = [3];
var ds = [0, jr, -1, Dr, ti];
var fs = class extends zn {
  constructor() {
    super();
  }
};
fs.prototype.g = si2([0, Ir, -4, Nr]);
var ps = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var gs = [0, 1, jr, Yr, Hi];
var ms = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ms.B = [1];
var ys = ii2(ms, [0, Cr, gs, Nr]);
var _s = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
_s.B = [1];
var vs = class extends zn {
  constructor(t6) {
    super(t6);
  }
  qa() {
    const t6 = mn(this);
    return null == t6 ? D2() : t6;
  }
};
var Es = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ws = [1, 2];
var Ts = [0, ws, Jr, [0, Dr], Jr, [0, Zr], jr, Yr];
var As = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
As.B = [1];
var bs = ii2(As, [0, Cr, Ts, Nr]);
var ks = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
ks.B = [4, 5];
var xs = [0, Yr, jr, Ir, zr, -1];
var Ss = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ls = [0, Hr, -1];
var Fs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Rs = [1, 2, 3, 4, 5];
var Ms = class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    return null != mn(this);
  }
  h() {
    return null != Pe(cn(this, 2));
  }
};
var Ps = [0, Zr, Yr, [0, jr, Nr, -1], [0, Gr, Nr]];
var Cs = class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    return Ee(cn(this, 2)) ?? false;
  }
};
var Os = [0, Ps, Hr, [0, Rs, Jr, mi, Jr, di, Jr, ci, Jr, gi, Jr, fi], ti];
var Is = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Us = [0, Os, Ir, -1, jr];
var Ds = ri(502141897, Is);
_i[502141897] = Us;
var Ns = [0, Ps];
_i[512499200] = Ns;
var Bs = [0, Ns];
_i[515723506] = Bs;
var Gs = ii2(class extends zn {
  constructor(t6) {
    super(t6);
  }
}, [0, [0, ti, -1, Ur, Qr], ds]);
var js = [0, Os];
_i[508981768] = js;
var Vs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Xs = [0, Os, Ir, js, Hr];
var Hs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ws = [0, Os, Us, Xs, Ir, Bs];
_i[508968149] = Xs;
var zs = ri(508968150, Hs);
_i[508968150] = Ws;
var Ks = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ys = ri(513916220, Ks);
_i[513916220] = [0, Os, Ws, jr];
var $s = class extends zn {
  constructor(t6) {
    super(t6);
  }
  h() {
    return Rn(this, ks, 2);
  }
  g() {
    dn(this, 2);
  }
};
var qs = [0, Os, xs];
_i[478825465] = qs;
var Js = [0, Os];
_i[478825422] = Js;
var Zs = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Qs = [0, Os, Js, qs, -1];
var to = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var eo = [0, Os, Ir, jr];
var no = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ro = [0, Os, Ir];
var io = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var so = [0, Os, eo, ro, Ir];
var oo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var ao = [0, Os, so, Qs];
_i[463370452] = Qs, _i[464864288] = eo, _i[474472470] = ro;
var ho = ri(462713202, io);
_i[462713202] = so;
var co = ri(479097054, oo);
_i[479097054] = ao;
var uo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var lo = [0, Os];
var fo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var po = [0, Os, Ir, -1, jr];
_i[514774813] = po;
var go = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var mo = [0, Os, Ir, Hr];
_i[518928384] = mo;
var yo = class extends zn {
  constructor() {
    super();
  }
};
yo.prototype.g = si2([0, Os, ro, lo, Us, Xs, po, mo]);
var _o = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var vo = ri(456383383, _o);
_i[456383383] = [0, Os, xs];
var Eo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var wo = ri(476348187, Eo);
_i[476348187] = [0, Os, Ls];
var To = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Ao = [0, ti, -1];
var bo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
bo.B = [3];
var ko = ri(458105876, class extends zn {
  constructor(t6) {
    super(t6);
  }
  g() {
    var t6 = this.s;
    const e5 = qt2(t6);
    var n6 = 2 & e5;
    return t6 = function(t7, e6, n7) {
      var r5 = bo;
      const i4 = 2 & e6;
      let s3 = false;
      if (null == n7) {
        if (i4) return Ze();
        n7 = [];
      } else if (n7.constructor === Ke) {
        if (0 == (2 & n7.N) || i4) return n7;
        n7 = n7.Y();
      } else Array.isArray(n7) ? s3 = !!(2 & $t2(n7)) : n7 = [];
      if (i4) {
        if (!n7.length) return Ze();
        s3 || (s3 = true, Zt2(n7));
      } else s3 && (s3 = false, n7 = wn(n7));
      return s3 || (64 & $t2(n7) ? Kt2(n7, 32) : 32 & e6 && zt(n7, 32)), fn(t7, e6, 2, r5 = new Ke(n7, r5, Oe2, void 0), false), r5;
    }(t6, e5, ln(t6, e5, 2)), null == t6 || !n6 && bo && (t6.ta = true), n6 = t6;
  }
});
_i[458105876] = [0, Ao, kr, [true, Nr, [0, Yr, -1, zr]]];
var xo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var So = ri(458105758, xo);
_i[458105758] = [0, Os, Yr, Ao];
var Lo = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
Lo.B = [5, 6];
var Fo = ri(443442058, Lo);
_i[443442058] = [0, Os, Yr, jr, Ir, zr, -1];
var Ro = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Mo = ri(516587230, Ro);
function Po(t6, e5) {
  return e5 = e5 ? e5.clone() : new ks(), void 0 !== t6.displayNamesLocale ? dn(e5, 1, Me(t6.displayNamesLocale)) : void 0 === t6.displayNamesLocale && dn(e5, 1), void 0 !== t6.maxResults ? Xn(e5, 2, t6.maxResults) : "maxResults" in t6 && dn(e5, 2), void 0 !== t6.scoreThreshold ? Hn(e5, 3, t6.scoreThreshold) : "scoreThreshold" in t6 && dn(e5, 3), void 0 !== t6.categoryAllowlist ? Tn(e5, 4, t6.categoryAllowlist) : "categoryAllowlist" in t6 && dn(e5, 4), void 0 !== t6.categoryDenylist ? Tn(e5, 5, t6.categoryDenylist) : "categoryDenylist" in t6 && dn(e5, 5), e5;
}
function Co(t6, e5 = -1, n6 = "") {
  return { categories: t6.map((t7) => ({ index: Bn(Nn(t7, 1), 0) ?? -1, score: Gn(t7, 2) ?? 0, categoryName: jn(t7, 3) ?? "", displayName: jn(t7, 4) ?? "" })), headIndex: e5, headName: n6 };
}
function Oo(t6) {
  var e5 = yn(t6, 3, ve), n6 = yn(t6, 2, Ae), r5 = yn(t6, 1, Pe), i4 = yn(t6, 9, Pe);
  const s3 = { categories: [], keypoints: [] };
  for (let t7 = 0; t7 < e5.length; t7++) s3.categories.push({ score: e5[t7], index: n6[t7] ?? -1, categoryName: r5[t7] ?? "", displayName: i4[t7] ?? "" });
  if ((e5 = Rn(t6, Qi, 4)?.h()) && (s3.boundingBox = { originX: Nn(e5, 1) ?? 0, originY: Nn(e5, 2) ?? 0, width: Nn(e5, 3) ?? 0, height: Nn(e5, 4) ?? 0, angle: 0 }), Rn(t6, Qi, 4)?.g().length) for (const e6 of Rn(t6, Qi, 4).g()) s3.keypoints.push({ x: gn(e6, 1) ?? 0, y: gn(e6, 2) ?? 0, score: gn(e6, 4) ?? 0, label: Pe(cn(e6, 3)) ?? "" });
  return s3;
}
function Io(t6) {
  const e5 = [];
  for (const n6 of Pn(t6, as, 1)) e5.push({ x: Gn(n6, 1) ?? 0, y: Gn(n6, 2) ?? 0, z: Gn(n6, 3) ?? 0, visibility: Gn(n6, 4) ?? 0 });
  return e5;
}
function Uo(t6) {
  const e5 = [];
  for (const n6 of Pn(t6, rs, 1)) e5.push({ x: Gn(n6, 1) ?? 0, y: Gn(n6, 2) ?? 0, z: Gn(n6, 3) ?? 0, visibility: Gn(n6, 4) ?? 0 });
  return e5;
}
function Do(t6) {
  return Array.from(t6, (t7) => 127 < t7 ? t7 - 256 : t7);
}
function No(t6, e5) {
  if (t6.length !== e5.length) throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t6.length} vs. ${e5.length}).`);
  let n6 = 0, r5 = 0, i4 = 0;
  for (let s3 = 0; s3 < t6.length; s3++) n6 += t6[s3] * e5[s3], r5 += t6[s3] * t6[s3], i4 += e5[s3] * e5[s3];
  if (0 >= r5 || 0 >= i4) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return n6 / Math.sqrt(r5 * i4);
}
var Bo;
_i[516587230] = [0, Os, po, mo, Ir];
var Go = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
async function jo() {
  if (void 0 === Bo) try {
    await WebAssembly.instantiate(Go), Bo = true;
  } catch {
    Bo = false;
  }
  return Bo;
}
async function Vo(t6, e5 = "") {
  const n6 = await jo() ? "wasm_internal" : "wasm_nosimd_internal";
  return { wasmLoaderPath: `${e5}/${t6}_${n6}.js`, wasmBinaryPath: `${e5}/${t6}_${n6}.wasm` };
}
var Xo = class {
};
function Ho() {
  var t6 = navigator;
  return "undefined" != typeof OffscreenCanvas && (!function(t7 = navigator) {
    return (t7 = t7.userAgent).includes("Safari") && !t7.includes("Chrome");
  }(t6) || !!((t6 = t6.userAgent.match(/Version\/([\d]+).*Safari/)) && 1 <= t6.length && 17 <= Number(t6[1])));
}
async function Wo(t6) {
  if ("function" != typeof importScripts) {
    const e5 = document.createElement("script");
    return e5.src = t6.toString(), e5.crossOrigin = "anonymous", new Promise((t7, n6) => {
      e5.addEventListener("load", () => {
        t7();
      }, false), e5.addEventListener("error", (t8) => {
        n6(t8);
      }, false), document.body.appendChild(e5);
    });
  }
  importScripts(t6.toString());
}
function zo(t6) {
  return void 0 !== t6.videoWidth ? [t6.videoWidth, t6.videoHeight] : void 0 !== t6.naturalWidth ? [t6.naturalWidth, t6.naturalHeight] : void 0 !== t6.displayWidth ? [t6.displayWidth, t6.displayHeight] : [t6.width, t6.height];
}
function Ko(t6, e5, n6) {
  t6.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n6(e5 = t6.i.stringToNewUTF8(e5)), t6.i._free(e5);
}
function Yo(t6, e5, n6) {
  if (!t6.i.canvas) throw Error("No OpenGL canvas configured.");
  if (n6 ? t6.i._bindTextureToStream(n6) : t6.i._bindTextureToCanvas(), !(n6 = t6.i.canvas.getContext("webgl2") || t6.i.canvas.getContext("webgl"))) throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
  t6.i.gpuOriginForWebTexturesIsBottomLeft && n6.pixelStorei(n6.UNPACK_FLIP_Y_WEBGL, true), n6.texImage2D(n6.TEXTURE_2D, 0, n6.RGBA, n6.RGBA, n6.UNSIGNED_BYTE, e5), t6.i.gpuOriginForWebTexturesIsBottomLeft && n6.pixelStorei(n6.UNPACK_FLIP_Y_WEBGL, false);
  const [r5, i4] = zo(e5);
  return !t6.l || r5 === t6.i.canvas.width && i4 === t6.i.canvas.height || (t6.i.canvas.width = r5, t6.i.canvas.height = i4), [r5, i4];
}
function $o(t6, e5, n6) {
  t6.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
  const r5 = new Uint32Array(e5.length);
  for (let n7 = 0; n7 < e5.length; n7++) r5[n7] = t6.i.stringToNewUTF8(e5[n7]);
  e5 = t6.i._malloc(4 * r5.length), t6.i.HEAPU32.set(r5, e5 >> 2), n6(e5);
  for (const e6 of r5) t6.i._free(e6);
  t6.i._free(e5);
}
function qo(t6, e5, n6) {
  t6.i.simpleListeners = t6.i.simpleListeners || {}, t6.i.simpleListeners[e5] = n6;
}
function Jo(t6, e5, n6) {
  let r5 = [];
  t6.i.simpleListeners = t6.i.simpleListeners || {}, t6.i.simpleListeners[e5] = (t7, e6, i4) => {
    e6 ? (n6(r5, i4), r5 = []) : r5.push(t7);
  };
}
Xo.forVisionTasks = function(t6) {
  return Vo("vision", t6);
}, Xo.forTextTasks = function(t6) {
  return Vo("text", t6);
}, Xo.forGenAiExperimentalTasks = function(t6) {
  return Vo("genai_experimental", t6);
}, Xo.forGenAiTasks = function(t6) {
  return Vo("genai", t6);
}, Xo.forAudioTasks = function(t6) {
  return Vo("audio", t6);
}, Xo.isSimdSupported = function() {
  return jo();
};
async function Zo(t6, e5, n6, r5) {
  return t6 = await (async (t7, e6, n7, r6, i4) => {
    if (e6 && await Wo(e6), !self.ModuleFactory) throw Error("ModuleFactory not set.");
    if (n7 && (await Wo(n7), !self.ModuleFactory)) throw Error("ModuleFactory not set.");
    return self.Module && i4 && ((e6 = self.Module).locateFile = i4.locateFile, i4.mainScriptUrlOrBlob && (e6.mainScriptUrlOrBlob = i4.mainScriptUrlOrBlob)), i4 = await self.ModuleFactory(self.Module || i4), self.ModuleFactory = self.Module = void 0, new t7(i4, r6);
  })(t6, n6.wasmLoaderPath, n6.assetLoaderPath, e5, { locateFile: (t7) => t7.endsWith(".wasm") ? n6.wasmBinaryPath.toString() : n6.assetBinaryPath && t7.endsWith(".data") ? n6.assetBinaryPath.toString() : t7 }), await t6.o(r5), t6;
}
function Qo(t6, e5) {
  const n6 = Rn(t6.baseOptions, Ms, 1) || new Ms();
  "string" == typeof e5 ? (dn(n6, 2, Me(e5)), dn(n6, 1)) : e5 instanceof Uint8Array && (dn(n6, 1, ae(e5, false, false)), dn(n6, 2)), Cn(t6.baseOptions, 0, 1, n6);
}
function ta(t6) {
  try {
    const e5 = t6.K.length;
    if (1 === e5) throw Error(t6.K[0].message);
    if (1 < e5) throw Error("Encountered multiple errors: " + t6.K.map((t7) => t7.message).join(", "));
  } finally {
    t6.K = [];
  }
}
function ea(t6, e5) {
  t6.J = Math.max(t6.J, e5);
}
function na(t6, e5) {
  t6.C = new Li(), ki(t6.C, "PassThroughCalculator"), xi(t6.C, "free_memory"), Si(t6.C, "free_memory_unused_out"), Ii(e5, "free_memory"), Oi(e5, t6.C);
}
function ra(t6, e5) {
  xi(t6.C, e5), Si(t6.C, e5 + "_unused_out");
}
function ia(t6) {
  t6.g.addBoolToStream(true, "free_memory", t6.J);
}
var sa = class {
  constructor(t6) {
    this.g = t6, this.K = [], this.J = 0, this.g.setAutoRenderToScreen(false);
  }
  l(t6, e5 = true) {
    if (e5) {
      const e6 = t6.baseOptions || {};
      if (t6.baseOptions?.modelAssetBuffer && t6.baseOptions?.modelAssetPath) throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
      if (!(Rn(this.baseOptions, Ms, 1)?.g() || Rn(this.baseOptions, Ms, 1)?.h() || t6.baseOptions?.modelAssetBuffer || t6.baseOptions?.modelAssetPath)) throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
      if (function(t7, e7) {
        let n6 = Rn(t7.baseOptions, Fs, 3);
        if (!n6) {
          var r5 = n6 = new Fs(), i4 = new pi();
          On(r5, 4, Rs, i4);
        }
        "delegate" in e7 && ("GPU" === e7.delegate ? (e7 = n6, r5 = new li(), On(e7, 2, Rs, r5)) : (e7 = n6, r5 = new pi(), On(e7, 4, Rs, r5))), Cn(t7.baseOptions, 0, 3, n6);
      }(this, e6), e6.modelAssetPath) return fetch(e6.modelAssetPath.toString()).then((t7) => {
        if (t7.ok) return t7.arrayBuffer();
        throw Error(`Failed to fetch model: ${e6.modelAssetPath} (${t7.status})`);
      }).then((t7) => {
        try {
          this.g.i.FS_unlink("/model.dat");
        } catch {
        }
        this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(t7), true, false, false), Qo(this, "/model.dat"), this.m(), this.L();
      });
      if (e6.modelAssetBuffer instanceof Uint8Array) Qo(this, e6.modelAssetBuffer);
      else if (e6.modelAssetBuffer) return async function(t7) {
        const e7 = [];
        for (var n6 = 0; ; ) {
          const { done: r5, value: i4 } = await t7.read();
          if (r5) break;
          e7.push(i4), n6 += i4.length;
        }
        if (0 === e7.length) return new Uint8Array(0);
        if (1 === e7.length) return e7[0];
        t7 = new Uint8Array(n6), n6 = 0;
        for (const r5 of e7) t7.set(r5, n6), n6 += r5.length;
        return t7;
      }(e6.modelAssetBuffer).then((t7) => {
        Qo(this, t7), this.m(), this.L();
      });
    }
    return this.m(), this.L(), Promise.resolve();
  }
  L() {
  }
  fa() {
    let t6;
    if (this.g.fa((e5) => {
      t6 = Bi(e5);
    }), !t6) throw Error("Failed to retrieve CalculatorGraphConfig");
    return t6;
  }
  setGraph(t6, e5) {
    this.g.attachErrorListener((t7, e6) => {
      this.K.push(Error(e6));
    }), this.g.Ma(), this.g.setGraph(t6, e5), this.C = void 0, ta(this);
  }
  finishProcessing() {
    this.g.finishProcessing(), ta(this);
  }
  close() {
    this.C = void 0, this.g.closeGraph();
  }
};
function oa(t6, e5) {
  if (!t6) throw Error(`Unable to obtain required WebGL resource: ${e5}`);
  return t6;
}
sa.prototype.close = sa.prototype.close, function(e5, n6) {
  e5 = e5.split(".");
  var r5, i4 = t5;
  e5[0] in i4 || void 0 === i4.execScript || i4.execScript("var " + e5[0]);
  for (; e5.length && (r5 = e5.shift()); ) e5.length || void 0 === n6 ? i4 = i4[r5] && i4[r5] !== Object.prototype[r5] ? i4[r5] : i4[r5] = {} : i4[r5] = n6;
}("TaskRunner", sa);
var aa = class {
  constructor(t6, e5, n6, r5) {
    this.g = t6, this.h = e5, this.m = n6, this.l = r5;
  }
  bind() {
    this.g.bindVertexArray(this.h);
  }
  close() {
    this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
  }
};
function ha(t6, e5, n6) {
  const r5 = t6.g;
  if (n6 = oa(r5.createShader(n6), "Failed to create WebGL shader"), r5.shaderSource(n6, e5), r5.compileShader(n6), !r5.getShaderParameter(n6, r5.COMPILE_STATUS)) throw Error(`Could not compile WebGL shader: ${r5.getShaderInfoLog(n6)}`);
  return r5.attachShader(t6.h, n6), n6;
}
function ca(t6, e5) {
  const n6 = t6.g, r5 = oa(n6.createVertexArray(), "Failed to create vertex array");
  n6.bindVertexArray(r5);
  const i4 = oa(n6.createBuffer(), "Failed to create buffer");
  n6.bindBuffer(n6.ARRAY_BUFFER, i4), n6.enableVertexAttribArray(t6.K), n6.vertexAttribPointer(t6.K, 2, n6.FLOAT, false, 0, 0), n6.bufferData(n6.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n6.STATIC_DRAW);
  const s3 = oa(n6.createBuffer(), "Failed to create buffer");
  return n6.bindBuffer(n6.ARRAY_BUFFER, s3), n6.enableVertexAttribArray(t6.J), n6.vertexAttribPointer(t6.J, 2, n6.FLOAT, false, 0, 0), n6.bufferData(n6.ARRAY_BUFFER, new Float32Array(e5 ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), n6.STATIC_DRAW), n6.bindBuffer(n6.ARRAY_BUFFER, null), n6.bindVertexArray(null), new aa(n6, r5, i4, s3);
}
function ua(t6, e5) {
  if (t6.g) {
    if (e5 !== t6.g) throw Error("Cannot change GL context once initialized");
  } else t6.g = e5;
}
function la(t6, e5, n6, r5) {
  return ua(t6, e5), t6.h || (t6.m(), t6.D()), n6 ? (t6.v || (t6.v = ca(t6, true)), n6 = t6.v) : (t6.A || (t6.A = ca(t6, false)), n6 = t6.A), e5.useProgram(t6.h), n6.bind(), t6.l(), t6 = r5(), n6.g.bindVertexArray(null), t6;
}
function da(t6, e5, n6) {
  return ua(t6, e5), t6 = oa(e5.createTexture(), "Failed to create texture"), e5.bindTexture(e5.TEXTURE_2D, t6), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_WRAP_S, e5.CLAMP_TO_EDGE), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_WRAP_T, e5.CLAMP_TO_EDGE), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_MIN_FILTER, n6 ?? e5.LINEAR), e5.texParameteri(e5.TEXTURE_2D, e5.TEXTURE_MAG_FILTER, n6 ?? e5.LINEAR), e5.bindTexture(e5.TEXTURE_2D, null), t6;
}
function fa(t6, e5, n6) {
  ua(t6, e5), t6.u || (t6.u = oa(e5.createFramebuffer(), "Failed to create framebuffe.")), e5.bindFramebuffer(e5.FRAMEBUFFER, t6.u), e5.framebufferTexture2D(e5.FRAMEBUFFER, e5.COLOR_ATTACHMENT0, e5.TEXTURE_2D, n6, 0);
}
function pa(t6) {
  t6.g?.bindFramebuffer(t6.g.FRAMEBUFFER, null);
}
var ga = class {
  H() {
    return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n ";
  }
  m() {
    const t6 = this.g;
    if (this.h = oa(t6.createProgram(), "Failed to create WebGL program"), this.ba = ha(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", t6.VERTEX_SHADER), this.aa = ha(this, this.H(), t6.FRAGMENT_SHADER), t6.linkProgram(this.h), !t6.getProgramParameter(this.h, t6.LINK_STATUS)) throw Error(`Error during program linking: ${t6.getProgramInfoLog(this.h)}`);
    this.K = t6.getAttribLocation(this.h, "aVertex"), this.J = t6.getAttribLocation(this.h, "aTex");
  }
  D() {
  }
  l() {
  }
  close() {
    if (this.h) {
      const t6 = this.g;
      t6.deleteProgram(this.h), t6.deleteShader(this.ba), t6.deleteShader(this.aa);
    }
    this.u && this.g.deleteFramebuffer(this.u), this.A && this.A.close(), this.v && this.v.close();
  }
};
var ma = class extends ga {
  H() {
    return "\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n ";
  }
  D() {
    const t6 = this.g;
    t6.activeTexture(t6.TEXTURE1), this.C = da(this, t6, t6.LINEAR), t6.activeTexture(t6.TEXTURE2), this.j = da(this, t6, t6.NEAREST);
  }
  m() {
    super.m();
    const t6 = this.g;
    this.M = oa(t6.getUniformLocation(this.h, "backgroundTexture"), "Uniform location"), this.V = oa(t6.getUniformLocation(this.h, "colorMappingTexture"), "Uniform location"), this.L = oa(t6.getUniformLocation(this.h, "maskTexture"), "Uniform location");
  }
  l() {
    super.l();
    const t6 = this.g;
    t6.uniform1i(this.L, 0), t6.uniform1i(this.M, 1), t6.uniform1i(this.V, 2);
  }
  close() {
    this.C && this.g.deleteTexture(this.C), this.j && this.g.deleteTexture(this.j), super.close();
  }
};
var ya = class extends ga {
  H() {
    return "\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n ";
  }
  D() {
    const t6 = this.g;
    t6.activeTexture(t6.TEXTURE1), this.j = da(this, t6), t6.activeTexture(t6.TEXTURE2), this.C = da(this, t6);
  }
  m() {
    super.m();
    const t6 = this.g;
    this.L = oa(t6.getUniformLocation(this.h, "defaultTexture"), "Uniform location"), this.M = oa(t6.getUniformLocation(this.h, "overlayTexture"), "Uniform location"), this.I = oa(t6.getUniformLocation(this.h, "maskTexture"), "Uniform location");
  }
  l() {
    super.l();
    const t6 = this.g;
    t6.uniform1i(this.I, 0), t6.uniform1i(this.L, 1), t6.uniform1i(this.M, 2);
  }
  close() {
    this.j && this.g.deleteTexture(this.j), this.C && this.g.deleteTexture(this.C), super.close();
  }
};
function _a(t6, e5) {
  switch (e5) {
    case 0:
      return t6.g.find((t7) => t7 instanceof Uint8Array);
    case 1:
      return t6.g.find((t7) => t7 instanceof Float32Array);
    case 2:
      return t6.g.find((t7) => "undefined" != typeof WebGLTexture && t7 instanceof WebGLTexture);
    default:
      throw Error(`Type is not supported: ${e5}`);
  }
}
function va(t6) {
  var e5 = _a(t6, 1);
  if (!e5) {
    if (e5 = _a(t6, 0)) e5 = new Float32Array(e5).map((t7) => t7 / 255);
    else {
      e5 = new Float32Array(t6.width * t6.height);
      const r5 = wa(t6);
      var n6 = Aa(t6);
      if (fa(n6, r5, Ea(t6)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in self.document) {
        n6 = new Float32Array(t6.width * t6.height * 4), r5.readPixels(0, 0, t6.width, t6.height, r5.RGBA, r5.FLOAT, n6);
        for (let t7 = 0, r6 = 0; t7 < e5.length; ++t7, r6 += 4) e5[t7] = n6[r6];
      } else r5.readPixels(0, 0, t6.width, t6.height, r5.RED, r5.FLOAT, e5);
    }
    t6.g.push(e5);
  }
  return e5;
}
function Ea(t6) {
  let e5 = _a(t6, 2);
  if (!e5) {
    const n6 = wa(t6);
    e5 = ba(t6);
    const r5 = va(t6), i4 = Ta(t6);
    n6.texImage2D(n6.TEXTURE_2D, 0, i4, t6.width, t6.height, 0, n6.RED, n6.FLOAT, r5), ka(t6);
  }
  return e5;
}
function wa(t6) {
  if (!t6.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return t6.h || (t6.h = oa(t6.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t6.h;
}
function Ta(t6) {
  if (t6 = wa(t6), !xa) if (t6.getExtension("EXT_color_buffer_float") && t6.getExtension("OES_texture_float_linear") && t6.getExtension("EXT_float_blend")) xa = t6.R32F;
  else {
    if (!t6.getExtension("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
    xa = t6.R16F;
  }
  return xa;
}
function Aa(t6) {
  return t6.l || (t6.l = new ga()), t6.l;
}
function ba(t6) {
  const e5 = wa(t6);
  e5.viewport(0, 0, t6.width, t6.height), e5.activeTexture(e5.TEXTURE0);
  let n6 = _a(t6, 2);
  return n6 || (n6 = da(Aa(t6), e5, t6.m ? e5.LINEAR : e5.NEAREST), t6.g.push(n6), t6.j = true), e5.bindTexture(e5.TEXTURE_2D, n6), n6;
}
function ka(t6) {
  t6.h.bindTexture(t6.h.TEXTURE_2D, null);
}
var xa;
var Sa = class {
  constructor(t6, e5, n6, r5, i4, s3, o5) {
    this.g = t6, this.m = e5, this.j = n6, this.canvas = r5, this.l = i4, this.width = s3, this.height = o5, this.j && (0 === --La && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources."));
  }
  Ha() {
    return !!_a(this, 0);
  }
  la() {
    return !!_a(this, 1);
  }
  R() {
    return !!_a(this, 2);
  }
  ka() {
    return (e5 = _a(t6 = this, 0)) || (e5 = va(t6), e5 = new Uint8Array(e5.map((t7) => 255 * t7)), t6.g.push(e5)), e5;
    var t6, e5;
  }
  ja() {
    return va(this);
  }
  O() {
    return Ea(this);
  }
  clone() {
    const t6 = [];
    for (const e5 of this.g) {
      let n6;
      if (e5 instanceof Uint8Array) n6 = new Uint8Array(e5);
      else if (e5 instanceof Float32Array) n6 = new Float32Array(e5);
      else {
        if (!(e5 instanceof WebGLTexture)) throw Error(`Type is not supported: ${e5}`);
        {
          const t7 = wa(this), e6 = Aa(this);
          t7.activeTexture(t7.TEXTURE1), n6 = da(e6, t7, this.m ? t7.LINEAR : t7.NEAREST), t7.bindTexture(t7.TEXTURE_2D, n6);
          const r5 = Ta(this);
          t7.texImage2D(t7.TEXTURE_2D, 0, r5, this.width, this.height, 0, t7.RED, t7.FLOAT, null), t7.bindTexture(t7.TEXTURE_2D, null), fa(e6, t7, n6), la(e6, t7, false, () => {
            ba(this), t7.clearColor(0, 0, 0, 0), t7.clear(t7.COLOR_BUFFER_BIT), t7.drawArrays(t7.TRIANGLE_FAN, 0, 4), ka(this);
          }), pa(e6), ka(this);
        }
      }
      t6.push(n6);
    }
    return new Sa(t6, this.m, this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && wa(this).deleteTexture(_a(this, 2)), La = -1;
  }
};
Sa.prototype.close = Sa.prototype.close, Sa.prototype.clone = Sa.prototype.clone, Sa.prototype.getAsWebGLTexture = Sa.prototype.O, Sa.prototype.getAsFloat32Array = Sa.prototype.ja, Sa.prototype.getAsUint8Array = Sa.prototype.ka, Sa.prototype.hasWebGLTexture = Sa.prototype.R, Sa.prototype.hasFloat32Array = Sa.prototype.la, Sa.prototype.hasUint8Array = Sa.prototype.Ha;
var La = 250;
var Fa = { color: "white", lineWidth: 4, radius: 6 };
function Ra(t6) {
  return { ...Fa, fillColor: (t6 = t6 || {}).color, ...t6 };
}
function Ma(t6, e5) {
  return t6 instanceof Function ? t6(e5) : t6;
}
function Pa(t6, e5, n6) {
  return Math.max(Math.min(e5, n6), Math.min(Math.max(e5, n6), t6));
}
function Ca(t6) {
  if (!t6.l) throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");
  return t6.l;
}
function Oa(t6) {
  if (!t6.j) throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");
  return t6.j;
}
function Ia(t6, e5, n6) {
  if (e5.R()) n6(e5.O());
  else {
    const r5 = e5.la() ? e5.ja() : e5.ka();
    t6.m = t6.m ?? new ga();
    const i4 = Oa(t6);
    n6((t6 = new Sa([r5], e5.m, false, i4.canvas, t6.m, e5.width, e5.height)).O()), t6.close();
  }
}
function Ua(t6, e5, n6, r5) {
  const i4 = function(t7) {
    return t7.g || (t7.g = new ma()), t7.g;
  }(t6), s3 = Oa(t6), o5 = Array.isArray(n6) ? new ImageData(new Uint8ClampedArray(n6), 1, 1) : n6;
  la(i4, s3, true, () => {
    !function(t8, e6, n7, r6) {
      const i5 = t8.g;
      if (i5.activeTexture(i5.TEXTURE0), i5.bindTexture(i5.TEXTURE_2D, e6), i5.activeTexture(i5.TEXTURE1), i5.bindTexture(i5.TEXTURE_2D, t8.C), i5.texImage2D(i5.TEXTURE_2D, 0, i5.RGBA, i5.RGBA, i5.UNSIGNED_BYTE, n7), t8.I && function(t9, e7) {
        if (t9 !== e7) return false;
        t9 = t9.entries(), e7 = e7.entries();
        for (const [r7, i6] of t9) {
          t9 = r7;
          const s4 = i6;
          var n8 = e7.next();
          if (n8.done) return false;
          const [o6, a3] = n8.value;
          if (n8 = a3, t9 !== o6 || s4[0] !== n8[0] || s4[1] !== n8[1] || s4[2] !== n8[2] || s4[3] !== n8[3]) return false;
        }
        return !!e7.next().done;
      }(t8.I, r6)) i5.activeTexture(i5.TEXTURE2), i5.bindTexture(i5.TEXTURE_2D, t8.j);
      else {
        t8.I = r6;
        const e7 = Array(1024).fill(0);
        r6.forEach((t9, n8) => {
          if (4 !== t9.length) throw Error(`Color at index ${n8} is not a four-channel value.`);
          e7[4 * n8] = t9[0], e7[4 * n8 + 1] = t9[1], e7[4 * n8 + 2] = t9[2], e7[4 * n8 + 3] = t9[3];
        }), i5.activeTexture(i5.TEXTURE2), i5.bindTexture(i5.TEXTURE_2D, t8.j), i5.texImage2D(i5.TEXTURE_2D, 0, i5.RGBA, 256, 1, 0, i5.RGBA, i5.UNSIGNED_BYTE, new Uint8Array(e7));
      }
    }(i4, e5, o5, r5), s3.clearColor(0, 0, 0, 0), s3.clear(s3.COLOR_BUFFER_BIT), s3.drawArrays(s3.TRIANGLE_FAN, 0, 4);
    const t7 = i4.g;
    t7.activeTexture(t7.TEXTURE0), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE1), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE2), t7.bindTexture(t7.TEXTURE_2D, null);
  });
}
function Da(t6, e5, n6, r5) {
  const i4 = Oa(t6), s3 = function(t7) {
    return t7.h || (t7.h = new ya()), t7.h;
  }(t6), o5 = Array.isArray(n6) ? new ImageData(new Uint8ClampedArray(n6), 1, 1) : n6, a3 = Array.isArray(r5) ? new ImageData(new Uint8ClampedArray(r5), 1, 1) : r5;
  la(s3, i4, true, () => {
    var t7 = s3.g;
    t7.activeTexture(t7.TEXTURE0), t7.bindTexture(t7.TEXTURE_2D, e5), t7.activeTexture(t7.TEXTURE1), t7.bindTexture(t7.TEXTURE_2D, s3.j), t7.texImage2D(t7.TEXTURE_2D, 0, t7.RGBA, t7.RGBA, t7.UNSIGNED_BYTE, o5), t7.activeTexture(t7.TEXTURE2), t7.bindTexture(t7.TEXTURE_2D, s3.C), t7.texImage2D(t7.TEXTURE_2D, 0, t7.RGBA, t7.RGBA, t7.UNSIGNED_BYTE, a3), i4.clearColor(0, 0, 0, 0), i4.clear(i4.COLOR_BUFFER_BIT), i4.drawArrays(i4.TRIANGLE_FAN, 0, 4), i4.bindTexture(i4.TEXTURE_2D, null), (t7 = s3.g).activeTexture(t7.TEXTURE0), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE1), t7.bindTexture(t7.TEXTURE_2D, null), t7.activeTexture(t7.TEXTURE2), t7.bindTexture(t7.TEXTURE_2D, null);
  });
}
var Na = class {
  constructor(t6, e5) {
    t6 instanceof CanvasRenderingContext2D || t6 instanceof OffscreenCanvasRenderingContext2D ? (this.l = t6, this.j = e5) : this.j = t6;
  }
  Aa(t6, e5) {
    if (t6) {
      var n6 = Ca(this);
      e5 = Ra(e5), n6.save();
      var r5 = n6.canvas, i4 = 0;
      for (const s3 of t6) n6.fillStyle = Ma(e5.fillColor, { index: i4, from: s3 }), n6.strokeStyle = Ma(e5.color, { index: i4, from: s3 }), n6.lineWidth = Ma(e5.lineWidth, { index: i4, from: s3 }), (t6 = new Path2D()).arc(s3.x * r5.width, s3.y * r5.height, Ma(e5.radius, { index: i4, from: s3 }), 0, 2 * Math.PI), n6.fill(t6), n6.stroke(t6), ++i4;
      n6.restore();
    }
  }
  za(t6, e5, n6) {
    if (t6 && e5) {
      var r5 = Ca(this);
      n6 = Ra(n6), r5.save();
      var i4 = r5.canvas, s3 = 0;
      for (const o5 of e5) {
        r5.beginPath(), e5 = t6[o5.start];
        const a3 = t6[o5.end];
        e5 && a3 && (r5.strokeStyle = Ma(n6.color, { index: s3, from: e5, to: a3 }), r5.lineWidth = Ma(n6.lineWidth, { index: s3, from: e5, to: a3 }), r5.moveTo(e5.x * i4.width, e5.y * i4.height), r5.lineTo(a3.x * i4.width, a3.y * i4.height)), ++s3, r5.stroke();
      }
      r5.restore();
    }
  }
  wa(t6, e5) {
    const n6 = Ca(this);
    e5 = Ra(e5), n6.save(), n6.beginPath(), n6.lineWidth = Ma(e5.lineWidth, {}), n6.strokeStyle = Ma(e5.color, {}), n6.fillStyle = Ma(e5.fillColor, {}), n6.moveTo(t6.originX, t6.originY), n6.lineTo(t6.originX + t6.width, t6.originY), n6.lineTo(t6.originX + t6.width, t6.originY + t6.height), n6.lineTo(t6.originX, t6.originY + t6.height), n6.lineTo(t6.originX, t6.originY), n6.stroke(), n6.fill(), n6.restore();
  }
  xa(t6, e5, n6 = [0, 0, 0, 255]) {
    this.l ? function(t7, e6, n7, r5) {
      const i4 = Oa(t7);
      Ia(t7, e6, (e7) => {
        Ua(t7, e7, n7, r5), (e7 = Ca(t7)).drawImage(i4.canvas, 0, 0, e7.canvas.width, e7.canvas.height);
      });
    }(this, t6, n6, e5) : Ua(this, t6.O(), n6, e5);
  }
  ya(t6, e5, n6) {
    this.l ? function(t7, e6, n7, r5) {
      const i4 = Oa(t7);
      Ia(t7, e6, (e7) => {
        Da(t7, e7, n7, r5), (e7 = Ca(t7)).drawImage(i4.canvas, 0, 0, e7.canvas.width, e7.canvas.height);
      });
    }(this, t6, e5, n6) : Da(this, t6.O(), e5, n6);
  }
  close() {
    this.g?.close(), this.g = void 0, this.h?.close(), this.h = void 0, this.m?.close(), this.m = void 0;
  }
};
function Ba(t6, e5) {
  switch (e5) {
    case 0:
      return t6.g.find((t7) => t7 instanceof ImageData);
    case 1:
      return t6.g.find((t7) => "undefined" != typeof ImageBitmap && t7 instanceof ImageBitmap);
    case 2:
      return t6.g.find((t7) => "undefined" != typeof WebGLTexture && t7 instanceof WebGLTexture);
    default:
      throw Error(`Type is not supported: ${e5}`);
  }
}
function Ga(t6) {
  var e5 = Ba(t6, 0);
  if (!e5) {
    e5 = Va(t6);
    const n6 = Xa(t6), r5 = new Uint8Array(t6.width * t6.height * 4);
    fa(n6, e5, ja(t6)), e5.readPixels(0, 0, t6.width, t6.height, e5.RGBA, e5.UNSIGNED_BYTE, r5), pa(n6), e5 = new ImageData(new Uint8ClampedArray(r5.buffer), t6.width, t6.height), t6.g.push(e5);
  }
  return e5;
}
function ja(t6) {
  let e5 = Ba(t6, 2);
  if (!e5) {
    const n6 = Va(t6);
    e5 = Ha(t6);
    const r5 = Ba(t6, 1) || Ga(t6);
    n6.texImage2D(n6.TEXTURE_2D, 0, n6.RGBA, n6.RGBA, n6.UNSIGNED_BYTE, r5), Wa(t6);
  }
  return e5;
}
function Va(t6) {
  if (!t6.canvas) throw Error("Conversion to different image formats require that a canvas is passed when iniitializing the image.");
  return t6.h || (t6.h = oa(t6.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t6.h;
}
function Xa(t6) {
  return t6.l || (t6.l = new ga()), t6.l;
}
function Ha(t6) {
  const e5 = Va(t6);
  e5.viewport(0, 0, t6.width, t6.height), e5.activeTexture(e5.TEXTURE0);
  let n6 = Ba(t6, 2);
  return n6 || (n6 = da(Xa(t6), e5), t6.g.push(n6), t6.m = true), e5.bindTexture(e5.TEXTURE_2D, n6), n6;
}
function Wa(t6) {
  t6.h.bindTexture(t6.h.TEXTURE_2D, null);
}
function za(t6) {
  const e5 = Va(t6);
  return la(Xa(t6), e5, true, () => function(t7, e6) {
    const n6 = t7.canvas;
    if (n6.width === t7.width && n6.height === t7.height) return e6();
    const r5 = n6.width, i4 = n6.height;
    return n6.width = t7.width, n6.height = t7.height, t7 = e6(), n6.width = r5, n6.height = i4, t7;
  }(t6, () => {
    if (e5.bindFramebuffer(e5.FRAMEBUFFER, null), e5.clearColor(0, 0, 0, 0), e5.clear(e5.COLOR_BUFFER_BIT), e5.drawArrays(e5.TRIANGLE_FAN, 0, 4), !(t6.canvas instanceof OffscreenCanvas)) throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return t6.canvas.transferToImageBitmap();
  }));
}
Na.prototype.close = Na.prototype.close, Na.prototype.drawConfidenceMask = Na.prototype.ya, Na.prototype.drawCategoryMask = Na.prototype.xa, Na.prototype.drawBoundingBox = Na.prototype.wa, Na.prototype.drawConnectors = Na.prototype.za, Na.prototype.drawLandmarks = Na.prototype.Aa, Na.lerp = function(t6, e5, n6, r5, i4) {
  return Pa(r5 * (1 - (t6 - e5) / (n6 - e5)) + i4 * (1 - (n6 - t6) / (n6 - e5)), r5, i4);
}, Na.clamp = Pa;
var Ka = class {
  constructor(t6, e5, n6, r5, i4, s3, o5) {
    this.g = t6, this.j = e5, this.m = n6, this.canvas = r5, this.l = i4, this.width = s3, this.height = o5, (this.j || this.m) && (0 === --Ya && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources."));
  }
  Ga() {
    return !!Ba(this, 0);
  }
  ma() {
    return !!Ba(this, 1);
  }
  R() {
    return !!Ba(this, 2);
  }
  Ea() {
    return Ga(this);
  }
  Da() {
    var t6 = Ba(this, 1);
    return t6 || (ja(this), Ha(this), t6 = za(this), Wa(this), this.g.push(t6), this.j = true), t6;
  }
  O() {
    return ja(this);
  }
  clone() {
    const t6 = [];
    for (const e5 of this.g) {
      let n6;
      if (e5 instanceof ImageData) n6 = new ImageData(e5.data, this.width, this.height);
      else if (e5 instanceof WebGLTexture) {
        const t7 = Va(this), e6 = Xa(this);
        t7.activeTexture(t7.TEXTURE1), n6 = da(e6, t7), t7.bindTexture(t7.TEXTURE_2D, n6), t7.texImage2D(t7.TEXTURE_2D, 0, t7.RGBA, this.width, this.height, 0, t7.RGBA, t7.UNSIGNED_BYTE, null), t7.bindTexture(t7.TEXTURE_2D, null), fa(e6, t7, n6), la(e6, t7, false, () => {
          Ha(this), t7.clearColor(0, 0, 0, 0), t7.clear(t7.COLOR_BUFFER_BIT), t7.drawArrays(t7.TRIANGLE_FAN, 0, 4), Wa(this);
        }), pa(e6), Wa(this);
      } else {
        if (!(e5 instanceof ImageBitmap)) throw Error(`Type is not supported: ${e5}`);
        ja(this), Ha(this), n6 = za(this), Wa(this);
      }
      t6.push(n6);
    }
    return new Ka(t6, this.ma(), this.R(), this.canvas, this.l, this.width, this.height);
  }
  close() {
    this.j && Ba(this, 1).close(), this.m && Va(this).deleteTexture(Ba(this, 2)), Ya = -1;
  }
};
Ka.prototype.close = Ka.prototype.close, Ka.prototype.clone = Ka.prototype.clone, Ka.prototype.getAsWebGLTexture = Ka.prototype.O, Ka.prototype.getAsImageBitmap = Ka.prototype.Da, Ka.prototype.getAsImageData = Ka.prototype.Ea, Ka.prototype.hasWebGLTexture = Ka.prototype.R, Ka.prototype.hasImageBitmap = Ka.prototype.ma, Ka.prototype.hasImageData = Ka.prototype.Ga;
var Ya = 250;
function $a(...t6) {
  return t6.map(([t7, e5]) => ({ start: t7, end: e5 }));
}
var qa = /* @__PURE__ */ function(t6) {
  return class extends t6 {
    Ma() {
      this.i._registerModelResourcesGraphService();
    }
  };
}((Ja = class {
  constructor(t6, e5) {
    this.l = true, this.i = t6, this.g = null, this.h = 0, this.m = "function" == typeof this.i._addIntToInputStream, void 0 !== e5 ? this.i.canvas = e5 : Ho() ? this.i.canvas = new OffscreenCanvas(1, 1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.i.canvas = document.createElement("canvas"));
  }
  async initializeGraph(t6) {
    const e5 = await (await fetch(t6)).arrayBuffer();
    t6 = !(t6.endsWith(".pbtxt") || t6.endsWith(".textproto")), this.setGraph(new Uint8Array(e5), t6);
  }
  setGraphFromString(t6) {
    this.setGraph(new TextEncoder().encode(t6), false);
  }
  setGraph(t6, e5) {
    const n6 = t6.length, r5 = this.i._malloc(n6);
    this.i.HEAPU8.set(t6, r5), e5 ? this.i._changeBinaryGraph(n6, r5) : this.i._changeTextGraph(n6, r5), this.i._free(r5);
  }
  configureAudio(t6, e5, n6, r5, i4) {
    this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), Ko(this, r5 || "input_audio", (r6) => {
      Ko(this, i4 = i4 || "audio_header", (i5) => {
        this.i._configureAudio(r6, i5, t6, e5, n6);
      });
    });
  }
  setAutoResizeCanvas(t6) {
    this.l = t6;
  }
  setAutoRenderToScreen(t6) {
    this.i._setAutoRenderToScreen(t6);
  }
  setGpuBufferVerticalFlip(t6) {
    this.i.gpuOriginForWebTexturesIsBottomLeft = t6;
  }
  fa(t6) {
    qo(this, "__graph_config__", (e5) => {
      t6(e5);
    }), Ko(this, "__graph_config__", (t7) => {
      this.i._getGraphConfig(t7, void 0);
    }), delete this.i.simpleListeners.__graph_config__;
  }
  attachErrorListener(t6) {
    this.i.errorListener = t6;
  }
  attachEmptyPacketListener(t6, e5) {
    this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}, this.i.emptyPacketListeners[t6] = e5;
  }
  addAudioToStream(t6, e5, n6) {
    this.addAudioToStreamWithShape(t6, 0, 0, e5, n6);
  }
  addAudioToStreamWithShape(t6, e5, n6, r5, i4) {
    const s3 = 4 * t6.length;
    this.h !== s3 && (this.g && this.i._free(this.g), this.g = this.i._malloc(s3), this.h = s3), this.i.HEAPF32.set(t6, this.g / 4), Ko(this, r5, (t7) => {
      this.i._addAudioToInputStream(this.g, e5, n6, t7, i4);
    });
  }
  addGpuBufferToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const [r5, i4] = Yo(this, t6, e6);
      this.i._addBoundTextureToStream(e6, r5, i4, n6);
    });
  }
  addBoolToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      this.i._addBoolToInputStream(t6, e6, n6);
    });
  }
  addDoubleToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      this.i._addDoubleToInputStream(t6, e6, n6);
    });
  }
  addFloatToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      this.i._addFloatToInputStream(t6, e6, n6);
    });
  }
  addIntToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      this.i._addIntToInputStream(t6, e6, n6);
    });
  }
  addUintToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      this.i._addUintToInputStream(t6, e6, n6);
    });
  }
  addStringToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      Ko(this, t6, (t7) => {
        this.i._addStringToInputStream(t7, e6, n6);
      });
    });
  }
  addStringRecordToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      $o(this, Object.keys(t6), (r5) => {
        $o(this, Object.values(t6), (i4) => {
          this.i._addFlatHashMapToInputStream(r5, i4, Object.keys(t6).length, e6, n6);
        });
      });
    });
  }
  addProtoToStream(t6, e5, n6, r5) {
    Ko(this, n6, (n7) => {
      Ko(this, e5, (e6) => {
        const i4 = this.i._malloc(t6.length);
        this.i.HEAPU8.set(t6, i4), this.i._addProtoToInputStream(i4, t6.length, e6, n7, r5), this.i._free(i4);
      });
    });
  }
  addEmptyPacketToStream(t6, e5) {
    Ko(this, t6, (t7) => {
      this.i._addEmptyPacketToInputStream(t7, e5);
    });
  }
  addBoolVectorToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateBoolVector(t6.length);
      if (!r5) throw Error("Unable to allocate new bool vector on heap.");
      for (const e7 of t6) this.i._addBoolVectorEntry(r5, e7);
      this.i._addBoolVectorToInputStream(r5, e6, n6);
    });
  }
  addDoubleVectorToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateDoubleVector(t6.length);
      if (!r5) throw Error("Unable to allocate new double vector on heap.");
      for (const e7 of t6) this.i._addDoubleVectorEntry(r5, e7);
      this.i._addDoubleVectorToInputStream(r5, e6, n6);
    });
  }
  addFloatVectorToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateFloatVector(t6.length);
      if (!r5) throw Error("Unable to allocate new float vector on heap.");
      for (const e7 of t6) this.i._addFloatVectorEntry(r5, e7);
      this.i._addFloatVectorToInputStream(r5, e6, n6);
    });
  }
  addIntVectorToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateIntVector(t6.length);
      if (!r5) throw Error("Unable to allocate new int vector on heap.");
      for (const e7 of t6) this.i._addIntVectorEntry(r5, e7);
      this.i._addIntVectorToInputStream(r5, e6, n6);
    });
  }
  addUintVectorToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateUintVector(t6.length);
      if (!r5) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const e7 of t6) this.i._addUintVectorEntry(r5, e7);
      this.i._addUintVectorToInputStream(r5, e6, n6);
    });
  }
  addStringVectorToStream(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const r5 = this.i._allocateStringVector(t6.length);
      if (!r5) throw Error("Unable to allocate new string vector on heap.");
      for (const e7 of t6) Ko(this, e7, (t7) => {
        this.i._addStringVectorEntry(r5, t7);
      });
      this.i._addStringVectorToInputStream(r5, e6, n6);
    });
  }
  addBoolToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addBoolToInputSidePacket(t6, e6);
    });
  }
  addDoubleToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addDoubleToInputSidePacket(t6, e6);
    });
  }
  addFloatToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addFloatToInputSidePacket(t6, e6);
    });
  }
  addIntToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addIntToInputSidePacket(t6, e6);
    });
  }
  addUintToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      this.i._addUintToInputSidePacket(t6, e6);
    });
  }
  addStringToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      Ko(this, t6, (t7) => {
        this.i._addStringToInputSidePacket(t7, e6);
      });
    });
  }
  addProtoToInputSidePacket(t6, e5, n6) {
    Ko(this, n6, (n7) => {
      Ko(this, e5, (e6) => {
        const r5 = this.i._malloc(t6.length);
        this.i.HEAPU8.set(t6, r5), this.i._addProtoToInputSidePacket(r5, t6.length, e6, n7), this.i._free(r5);
      });
    });
  }
  addBoolVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n6 = this.i._allocateBoolVector(t6.length);
      if (!n6) throw Error("Unable to allocate new bool vector on heap.");
      for (const e7 of t6) this.i._addBoolVectorEntry(n6, e7);
      this.i._addBoolVectorToInputSidePacket(n6, e6);
    });
  }
  addDoubleVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n6 = this.i._allocateDoubleVector(t6.length);
      if (!n6) throw Error("Unable to allocate new double vector on heap.");
      for (const e7 of t6) this.i._addDoubleVectorEntry(n6, e7);
      this.i._addDoubleVectorToInputSidePacket(n6, e6);
    });
  }
  addFloatVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n6 = this.i._allocateFloatVector(t6.length);
      if (!n6) throw Error("Unable to allocate new float vector on heap.");
      for (const e7 of t6) this.i._addFloatVectorEntry(n6, e7);
      this.i._addFloatVectorToInputSidePacket(n6, e6);
    });
  }
  addIntVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n6 = this.i._allocateIntVector(t6.length);
      if (!n6) throw Error("Unable to allocate new int vector on heap.");
      for (const e7 of t6) this.i._addIntVectorEntry(n6, e7);
      this.i._addIntVectorToInputSidePacket(n6, e6);
    });
  }
  addUintVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n6 = this.i._allocateUintVector(t6.length);
      if (!n6) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const e7 of t6) this.i._addUintVectorEntry(n6, e7);
      this.i._addUintVectorToInputSidePacket(n6, e6);
    });
  }
  addStringVectorToInputSidePacket(t6, e5) {
    Ko(this, e5, (e6) => {
      const n6 = this.i._allocateStringVector(t6.length);
      if (!n6) throw Error("Unable to allocate new string vector on heap.");
      for (const e7 of t6) Ko(this, e7, (t7) => {
        this.i._addStringVectorEntry(n6, t7);
      });
      this.i._addStringVectorToInputSidePacket(n6, e6);
    });
  }
  attachBoolListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachBoolListener(t7);
    });
  }
  attachBoolVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachBoolVectorListener(t7);
    });
  }
  attachIntListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachIntListener(t7);
    });
  }
  attachIntVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachIntVectorListener(t7);
    });
  }
  attachUintListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachUintListener(t7);
    });
  }
  attachUintVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachUintVectorListener(t7);
    });
  }
  attachDoubleListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachDoubleListener(t7);
    });
  }
  attachDoubleVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachDoubleVectorListener(t7);
    });
  }
  attachFloatListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachFloatListener(t7);
    });
  }
  attachFloatVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachFloatVectorListener(t7);
    });
  }
  attachStringListener(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachStringListener(t7);
    });
  }
  attachStringVectorListener(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachStringVectorListener(t7);
    });
  }
  attachProtoListener(t6, e5, n6) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachProtoListener(t7, n6 || false);
    });
  }
  attachProtoVectorListener(t6, e5, n6) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.i._attachProtoVectorListener(t7, n6 || false);
    });
  }
  attachAudioListener(t6, e5, n6) {
    this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), qo(this, t6, (t7, n7) => {
      t7 = new Float32Array(t7.buffer, t7.byteOffset, t7.length / 4), e5(t7, n7);
    }), Ko(this, t6, (t7) => {
      this.i._attachAudioListener(t7, n6 || false);
    });
  }
  finishProcessing() {
    this.i._waitUntilIdle();
  }
  closeGraph() {
    this.i._closeGraph(), this.i.simpleListeners = void 0, this.i.emptyPacketListeners = void 0;
  }
}, class extends Ja {
  get ha() {
    return this.i;
  }
  sa(t6, e5, n6) {
    Ko(this, e5, (e6) => {
      const [r5, i4] = Yo(this, t6, e6);
      this.ha._addBoundTextureAsImageToStream(e6, r5, i4, n6);
    });
  }
  W(t6, e5) {
    qo(this, t6, e5), Ko(this, t6, (t7) => {
      this.ha._attachImageListener(t7);
    });
  }
  da(t6, e5) {
    Jo(this, t6, e5), Ko(this, t6, (t7) => {
      this.ha._attachImageVectorListener(t7);
    });
  }
}));
var Ja;
var Za = class extends qa {
};
async function Qa(t6, e5, n6) {
  return async function(t7, e6, n7, r5) {
    return Zo(t7, e6, n7, r5);
  }(t6, n6.canvas ?? (Ho() ? void 0 : document.createElement("canvas")), e5, n6);
}
function th(t6, e5, n6, r5) {
  if (t6.V) {
    const s3 = new fs();
    if (n6?.regionOfInterest) {
      if (!t6.ra) throw Error("This task doesn't support region-of-interest.");
      var i4 = n6.regionOfInterest;
      if (i4.left >= i4.right || i4.top >= i4.bottom) throw Error("Expected RectF with left < right and top < bottom.");
      if (0 > i4.left || 0 > i4.top || 1 < i4.right || 1 < i4.bottom) throw Error("Expected RectF values to be in [0,1].");
      Hn(s3, 1, (i4.left + i4.right) / 2), Hn(s3, 2, (i4.top + i4.bottom) / 2), Hn(s3, 4, i4.right - i4.left), Hn(s3, 3, i4.bottom - i4.top);
    } else Hn(s3, 1, 0.5), Hn(s3, 2, 0.5), Hn(s3, 4, 1), Hn(s3, 3, 1);
    if (n6?.rotationDegrees) {
      if (0 != n6?.rotationDegrees % 90) throw Error("Expected rotation to be a multiple of 90\xB0.");
      if (Hn(s3, 5, -Math.PI * n6.rotationDegrees / 180), 0 != n6?.rotationDegrees % 180) {
        const [t7, r6] = zo(e5);
        n6 = Gn(s3, 3) * r6 / t7, i4 = Gn(s3, 4) * t7 / r6, Hn(s3, 4, n6), Hn(s3, 3, i4);
      }
    }
    t6.g.addProtoToStream(s3.g(), "mediapipe.NormalizedRect", t6.V, r5);
  }
  t6.g.sa(e5, t6.ba, r5 ?? performance.now()), t6.finishProcessing();
}
function eh(t6, e5, n6) {
  if (t6.baseOptions?.g()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
  th(t6, e5, n6, t6.J + 1);
}
function nh(t6, e5, n6, r5) {
  if (!t6.baseOptions?.g()) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
  th(t6, e5, n6, r5);
}
function rh(t6, e5, n6, r5) {
  var i4 = e5.data;
  const s3 = e5.width, o5 = s3 * (e5 = e5.height);
  if ((i4 instanceof Uint8Array || i4 instanceof Float32Array) && i4.length !== o5) throw Error("Unsupported channel count: " + i4.length / o5);
  return t6 = new Sa([i4], n6, false, t6.g.i.canvas, t6.M, s3, e5), r5 ? t6.clone() : t6;
}
var ih = class extends sa {
  constructor(t6, e5, n6, r5) {
    super(t6), this.g = t6, this.ba = e5, this.V = n6, this.ra = r5, this.M = new ga();
  }
  l(t6, e5 = true) {
    if ("runningMode" in t6 && Vn(this.baseOptions, 2, !!t6.runningMode && "IMAGE" !== t6.runningMode), void 0 !== t6.canvas && this.g.i.canvas !== t6.canvas) throw Error("You must create a new task to reset the canvas.");
    return super.l(t6, e5);
  }
  close() {
    this.M.close(), super.close();
  }
};
ih.prototype.close = ih.prototype.close;
var sh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect_in", false), this.j = { detections: [] }, Cn(t6 = this.h = new Is(), 0, 1, e5 = new Cs()), Hn(this.h, 2, 0.5), Hn(this.h, 3, 0.3);
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "minDetectionConfidence" in t6 && Hn(this.h, 2, t6.minDetectionConfidence ?? 0.5), "minSuppressionThreshold" in t6 && Hn(this.h, 3, t6.minSuppressionThreshold ?? 0.3), this.l(t6);
  }
  F(t6, e5) {
    return this.j = { detections: [] }, eh(this, t6, e5), this.j;
  }
  G(t6, e5, n6) {
    return this.j = { detections: [] }, nh(this, t6, n6, e5), this.j;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect_in"), Ui(t6, "detections");
    const e5 = new yi();
    Wn(e5, Ds, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect_in"), Si(n6, "DETECTIONS:detections"), n6.o(e5), Oi(t6, n6), this.g.attachProtoVectorListener("detections", (t7, e6) => {
      for (const e7 of t7) t7 = ns(e7), this.j.detections.push(Oo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("detections", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
sh.prototype.detectForVideo = sh.prototype.G, sh.prototype.detect = sh.prototype.F, sh.prototype.setOptions = sh.prototype.o, sh.createFromModelPath = async function(t6, e5) {
  return Qa(sh, t6, { baseOptions: { modelAssetPath: e5 } });
}, sh.createFromModelBuffer = function(t6, e5) {
  return Qa(sh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, sh.createFromOptions = function(t6, e5) {
  return Qa(sh, t6, e5);
};
var oh = $a([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]);
var ah = $a([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]);
var hh = $a([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]);
var ch = $a([474, 475], [475, 476], [476, 477], [477, 474]);
var uh = $a([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]);
var lh = $a([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]);
var dh = $a([469, 470], [470, 471], [471, 472], [472, 469]);
var fh = $a([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]);
var ph = [...oh, ...ah, ...hh, ...uh, ...lh, ...fh];
var gh = $a([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
function mh(t6) {
  t6.u = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
}
var yh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.u = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = false, Cn(t6 = this.h = new Hs(), 0, 1, e5 = new Cs()), this.H = new Vs(), Cn(this.h, 0, 3, this.H), this.j = new Is(), Cn(this.h, 0, 2, this.j), Xn(this.j, 4, 1), Hn(this.j, 2, 0.5), Hn(this.H, 2, 0.5), Hn(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "numFaces" in t6 && Xn(this.j, 4, t6.numFaces ?? 1), "minFaceDetectionConfidence" in t6 && Hn(this.j, 2, t6.minFaceDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.h, 4, t6.minTrackingConfidence ?? 0.5), "minFacePresenceConfidence" in t6 && Hn(this.H, 2, t6.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t6 && (this.outputFaceBlendshapes = !!t6.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in t6 && (this.outputFacialTransformationMatrixes = !!t6.outputFacialTransformationMatrixes), this.l(t6);
  }
  F(t6, e5) {
    return mh(this), eh(this, t6, e5), this.u;
  }
  G(t6, e5, n6) {
    return mh(this), nh(this, t6, n6, e5), this.u;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "face_landmarks");
    const e5 = new yi();
    Wn(e5, zs, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "NORM_LANDMARKS:face_landmarks"), n6.o(e5), Oi(t6, n6), this.g.attachProtoVectorListener("face_landmarks", (t7, e6) => {
      for (const e7 of t7) t7 = us(e7), this.u.faceLandmarks.push(Io(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("face_landmarks", (t7) => {
      ea(this, t7);
    }), this.outputFaceBlendshapes && (Ui(t6, "blendshapes"), Si(n6, "BLENDSHAPES:blendshapes"), this.g.attachProtoVectorListener("blendshapes", (t7, e6) => {
      if (this.outputFaceBlendshapes) for (const e7 of t7) t7 = Wi(e7), this.u.faceBlendshapes.push(Co(t7.g() ?? []));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("blendshapes", (t7) => {
      ea(this, t7);
    })), this.outputFacialTransformationMatrixes && (Ui(t6, "face_geometry"), Si(n6, "FACE_GEOMETRY:face_geometry"), this.g.attachProtoVectorListener("face_geometry", (t7, e6) => {
      if (this.outputFacialTransformationMatrixes) for (const e7 of t7) (t7 = Rn(Gs(e7), ls, 2)) && this.u.facialTransformationMatrixes.push({ rows: Bn(Nn(t7, 1), 0) ?? 0, columns: Bn(Nn(t7, 2), 0) ?? 0, data: yn(t7, 3, ve).slice() ?? [] });
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("face_geometry", (t7) => {
      ea(this, t7);
    })), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
yh.prototype.detectForVideo = yh.prototype.G, yh.prototype.detect = yh.prototype.F, yh.prototype.setOptions = yh.prototype.o, yh.createFromModelPath = function(t6, e5) {
  return Qa(yh, t6, { baseOptions: { modelAssetPath: e5 } });
}, yh.createFromModelBuffer = function(t6, e5) {
  return Qa(yh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, yh.createFromOptions = function(t6, e5) {
  return Qa(yh, t6, e5);
}, yh.FACE_LANDMARKS_LIPS = oh, yh.FACE_LANDMARKS_LEFT_EYE = ah, yh.FACE_LANDMARKS_LEFT_EYEBROW = hh, yh.FACE_LANDMARKS_LEFT_IRIS = ch, yh.FACE_LANDMARKS_RIGHT_EYE = uh, yh.FACE_LANDMARKS_RIGHT_EYEBROW = lh, yh.FACE_LANDMARKS_RIGHT_IRIS = dh, yh.FACE_LANDMARKS_FACE_OVAL = fh, yh.FACE_LANDMARKS_CONTOURS = ph, yh.FACE_LANDMARKS_TESSELATION = gh;
var _h = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", true), Cn(t6 = this.j = new Ks(), 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.j, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.j, 0, 1, t6);
  }
  o(t6) {
    return super.l(t6);
  }
  Pa(t6, e5, n6) {
    const r5 = "function" != typeof e5 ? e5 : {};
    if (this.h = "function" == typeof e5 ? e5 : n6, eh(this, t6, r5 ?? {}), !this.h) return this.u;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "stylized_image");
    const e5 = new yi();
    Wn(e5, Ys, this.j);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "STYLIZED_IMAGE:stylized_image"), n6.o(e5), Oi(t6, n6), this.g.W("stylized_image", (t7, e6) => {
      var n7 = !this.h, r5 = t7.data, i4 = t7.width;
      const s3 = i4 * (t7 = t7.height);
      if (r5 instanceof Uint8Array) if (r5.length === 3 * s3) {
        const e7 = new Uint8ClampedArray(4 * s3);
        for (let t8 = 0; t8 < s3; ++t8) e7[4 * t8] = r5[3 * t8], e7[4 * t8 + 1] = r5[3 * t8 + 1], e7[4 * t8 + 2] = r5[3 * t8 + 2], e7[4 * t8 + 3] = 255;
        r5 = new ImageData(e7, i4, t7);
      } else {
        if (r5.length !== 4 * s3) throw Error("Unsupported channel count: " + r5.length / s3);
        r5 = new ImageData(new Uint8ClampedArray(r5.buffer, r5.byteOffset, r5.length), i4, t7);
      }
      else if (!(r5 instanceof WebGLTexture)) throw Error(`Unsupported format: ${r5.constructor.name}`);
      i4 = new Ka([r5], false, false, this.g.i.canvas, this.M, i4, t7), this.u = n7 = n7 ? i4.clone() : i4, this.h && this.h(n7), ea(this, e6);
    }), this.g.attachEmptyPacketListener("stylized_image", (t7) => {
      this.u = null, this.h && this.h(null), ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
_h.prototype.stylize = _h.prototype.Pa, _h.prototype.setOptions = _h.prototype.o, _h.createFromModelPath = function(t6, e5) {
  return Qa(_h, t6, { baseOptions: { modelAssetPath: e5 } });
}, _h.createFromModelBuffer = function(t6, e5) {
  return Qa(_h, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, _h.createFromOptions = function(t6, e5) {
  return Qa(_h, t6, e5);
};
var vh = $a([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
function Eh(t6) {
  t6.gestures = [], t6.landmarks = [], t6.worldLandmarks = [], t6.handedness = [];
}
function wh(t6) {
  return 0 === t6.gestures.length ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] } : { gestures: t6.gestures, landmarks: t6.landmarks, worldLandmarks: t6.worldLandmarks, handedness: t6.handedness, handednesses: t6.handedness };
}
function Th(t6, e5 = true) {
  const n6 = [];
  for (const i4 of t6) {
    var r5 = Wi(i4);
    t6 = [];
    for (const n7 of r5.g()) r5 = e5 && null != Nn(n7, 1) ? Bn(Nn(n7, 1), 0) : -1, t6.push({ score: Gn(n7, 2) ?? 0, index: r5, categoryName: jn(n7, 3) ?? "", displayName: jn(n7, 4) ?? "" });
    n6.push(t6);
  }
  return n6;
}
var Ah = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Cn(t6 = this.v = new oo(), 0, 1, e5 = new Cs()), this.A = new io(), Cn(this.v, 0, 2, this.A), this.u = new no(), Cn(this.A, 0, 3, this.u), this.h = new to(), Cn(this.A, 0, 2, this.h), this.j = new Zs(), Cn(this.v, 0, 3, this.j), Hn(this.h, 2, 0.5), Hn(this.A, 4, 0.5), Hn(this.u, 2, 0.5);
  }
  get baseOptions() {
    return Rn(this.v, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.v, 0, 1, t6);
  }
  o(t6) {
    if (Xn(this.h, 3, t6.numHands ?? 1), "minHandDetectionConfidence" in t6 && Hn(this.h, 2, t6.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.A, 4, t6.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t6 && Hn(this.u, 2, t6.minHandPresenceConfidence ?? 0.5), t6.cannedGesturesClassifierOptions) {
      var e5 = new $s(), n6 = e5, r5 = Po(t6.cannedGesturesClassifierOptions, Rn(this.j, $s, 3)?.h());
      Cn(n6, 0, 2, r5), Cn(this.j, 0, 3, e5);
    } else void 0 === t6.cannedGesturesClassifierOptions && Rn(this.j, $s, 3)?.g();
    return t6.customGesturesClassifierOptions ? (Cn(n6 = e5 = new $s(), 0, 2, r5 = Po(t6.customGesturesClassifierOptions, Rn(this.j, $s, 4)?.h())), Cn(this.j, 0, 4, e5)) : void 0 === t6.customGesturesClassifierOptions && Rn(this.j, $s, 4)?.g(), this.l(t6);
  }
  Ka(t6, e5) {
    return Eh(this), eh(this, t6, e5), wh(this);
  }
  La(t6, e5, n6) {
    return Eh(this), nh(this, t6, n6, e5), wh(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "hand_gestures"), Ui(t6, "hand_landmarks"), Ui(t6, "world_hand_landmarks"), Ui(t6, "handedness");
    const e5 = new yi();
    Wn(e5, co, this.v);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "HAND_GESTURES:hand_gestures"), Si(n6, "LANDMARKS:hand_landmarks"), Si(n6, "WORLD_LANDMARKS:world_hand_landmarks"), Si(n6, "HANDEDNESS:handedness"), n6.o(e5), Oi(t6, n6), this.g.attachProtoVectorListener("hand_landmarks", (t7, e6) => {
      for (const e7 of t7) {
        t7 = us(e7);
        const n7 = [];
        for (const e8 of Pn(t7, as, 1)) n7.push({ x: Gn(e8, 1) ?? 0, y: Gn(e8, 2) ?? 0, z: Gn(e8, 3) ?? 0, visibility: Gn(e8, 4) ?? 0 });
        this.landmarks.push(n7);
      }
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("world_hand_landmarks", (t7, e6) => {
      for (const e7 of t7) {
        t7 = os(e7);
        const n7 = [];
        for (const e8 of Pn(t7, rs, 1)) n7.push({ x: Gn(e8, 1) ?? 0, y: Gn(e8, 2) ?? 0, z: Gn(e8, 3) ?? 0, visibility: Gn(e8, 4) ?? 0 });
        this.worldLandmarks.push(n7);
      }
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("world_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("hand_gestures", (t7, e6) => {
      this.gestures.push(...Th(t7, false)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("hand_gestures", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("handedness", (t7, e6) => {
      this.handedness.push(...Th(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("handedness", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
function bh(t6) {
  return { landmarks: t6.landmarks, worldLandmarks: t6.worldLandmarks, handednesses: t6.handedness, handedness: t6.handedness };
}
Ah.prototype.recognizeForVideo = Ah.prototype.La, Ah.prototype.recognize = Ah.prototype.Ka, Ah.prototype.setOptions = Ah.prototype.o, Ah.createFromModelPath = function(t6, e5) {
  return Qa(Ah, t6, { baseOptions: { modelAssetPath: e5 } });
}, Ah.createFromModelBuffer = function(t6, e5) {
  return Qa(Ah, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Ah.createFromOptions = function(t6, e5) {
  return Qa(Ah, t6, e5);
}, Ah.HAND_CONNECTIONS = vh;
var kh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.handedness = [], Cn(t6 = this.j = new io(), 0, 1, e5 = new Cs()), this.u = new no(), Cn(this.j, 0, 3, this.u), this.h = new to(), Cn(this.j, 0, 2, this.h), Xn(this.h, 3, 1), Hn(this.h, 2, 0.5), Hn(this.u, 2, 0.5), Hn(this.j, 4, 0.5);
  }
  get baseOptions() {
    return Rn(this.j, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.j, 0, 1, t6);
  }
  o(t6) {
    return "numHands" in t6 && Xn(this.h, 3, t6.numHands ?? 1), "minHandDetectionConfidence" in t6 && Hn(this.h, 2, t6.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.j, 4, t6.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t6 && Hn(this.u, 2, t6.minHandPresenceConfidence ?? 0.5), this.l(t6);
  }
  F(t6, e5) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], eh(this, t6, e5), bh(this);
  }
  G(t6, e5, n6) {
    return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], nh(this, t6, n6, e5), bh(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "hand_landmarks"), Ui(t6, "world_hand_landmarks"), Ui(t6, "handedness");
    const e5 = new yi();
    Wn(e5, ho, this.j);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "LANDMARKS:hand_landmarks"), Si(n6, "WORLD_LANDMARKS:world_hand_landmarks"), Si(n6, "HANDEDNESS:handedness"), n6.o(e5), Oi(t6, n6), this.g.attachProtoVectorListener("hand_landmarks", (t7, e6) => {
      for (const e7 of t7) t7 = us(e7), this.landmarks.push(Io(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("world_hand_landmarks", (t7, e6) => {
      for (const e7 of t7) t7 = os(e7), this.worldLandmarks.push(Uo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("world_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoVectorListener("handedness", (t7, e6) => {
      var n7 = this.handedness, r5 = n7.push;
      const i4 = [];
      for (const e7 of t7) {
        t7 = Wi(e7);
        const n8 = [];
        for (const e8 of t7.g()) n8.push({ score: Gn(e8, 2) ?? 0, index: Bn(Nn(e8, 1), 0) ?? -1, categoryName: jn(e8, 3) ?? "", displayName: jn(e8, 4) ?? "" });
        i4.push(n8);
      }
      r5.call(n7, ...i4), ea(this, e6);
    }), this.g.attachEmptyPacketListener("handedness", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
kh.prototype.detectForVideo = kh.prototype.G, kh.prototype.detect = kh.prototype.F, kh.prototype.setOptions = kh.prototype.o, kh.createFromModelPath = function(t6, e5) {
  return Qa(kh, t6, { baseOptions: { modelAssetPath: e5 } });
}, kh.createFromModelBuffer = function(t6, e5) {
  return Qa(kh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, kh.createFromOptions = function(t6, e5) {
  return Qa(kh, t6, e5);
}, kh.HAND_CONNECTIONS = vh;
var xh = $a([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
function Sh(t6) {
  t6.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] };
}
function Lh(t6) {
  try {
    if (!t6.I) return t6.h;
    t6.I(t6.h);
  } finally {
    ia(t6);
  }
}
function Fh(t6, e5) {
  t6 = us(t6), e5.push(Io(t6));
}
var Rh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "input_frames_image", null, false), this.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] }, this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = false, Cn(t6 = this.A = new yo(), 0, 1, e5 = new Cs()), this.u = new no(), Cn(this.A, 0, 2, this.u), this.aa = new uo(), Cn(this.A, 0, 3, this.aa), this.j = new Is(), Cn(this.A, 0, 4, this.j), this.H = new Vs(), Cn(this.A, 0, 5, this.H), this.v = new fo(), Cn(this.A, 0, 6, this.v), this.D = new go(), Cn(this.A, 0, 7, this.D), Hn(this.j, 2, 0.5), Hn(this.j, 3, 0.3), Hn(this.H, 2, 0.5), Hn(this.v, 2, 0.5), Hn(this.v, 3, 0.3), Hn(this.D, 2, 0.5), Hn(this.u, 2, 0.5);
  }
  get baseOptions() {
    return Rn(this.A, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.A, 0, 1, t6);
  }
  o(t6) {
    return "minFaceDetectionConfidence" in t6 && Hn(this.j, 2, t6.minFaceDetectionConfidence ?? 0.5), "minFaceSuppressionThreshold" in t6 && Hn(this.j, 3, t6.minFaceSuppressionThreshold ?? 0.3), "minFacePresenceConfidence" in t6 && Hn(this.H, 2, t6.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t6 && (this.outputFaceBlendshapes = !!t6.outputFaceBlendshapes), "minPoseDetectionConfidence" in t6 && Hn(this.v, 2, t6.minPoseDetectionConfidence ?? 0.5), "minPoseSuppressionThreshold" in t6 && Hn(this.v, 3, t6.minPoseSuppressionThreshold ?? 0.3), "minPosePresenceConfidence" in t6 && Hn(this.D, 2, t6.minPosePresenceConfidence ?? 0.5), "outputPoseSegmentationMasks" in t6 && (this.outputPoseSegmentationMasks = !!t6.outputPoseSegmentationMasks), "minHandLandmarksConfidence" in t6 && Hn(this.u, 2, t6.minHandLandmarksConfidence ?? 0.5), this.l(t6);
  }
  F(t6, e5, n6) {
    const r5 = "function" != typeof e5 ? e5 : {};
    return this.I = "function" == typeof e5 ? e5 : n6, Sh(this), eh(this, t6, r5), Lh(this);
  }
  G(t6, e5, n6, r5) {
    const i4 = "function" != typeof n6 ? n6 : {};
    return this.I = "function" == typeof n6 ? n6 : r5, Sh(this), nh(this, t6, i4, e5), Lh(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "input_frames_image"), Ui(t6, "pose_landmarks"), Ui(t6, "pose_world_landmarks"), Ui(t6, "face_landmarks"), Ui(t6, "left_hand_landmarks"), Ui(t6, "left_hand_world_landmarks"), Ui(t6, "right_hand_landmarks"), Ui(t6, "right_hand_world_landmarks");
    const e5 = new yi(), n6 = new oi();
    An(n6, 1, Me("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""), function(t7, e6) {
      if (null != e6) if (Array.isArray(e6)) dn(t7, 2, tn(e6, nn, void 0, void 0, false));
      else {
        if (!("string" == typeof e6 || e6 instanceof B2 || M2(e6))) throw Error("invalid value in Any.value field: " + e6 + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
        An(t7, 2, ae(e6, false, false), D2());
      }
    }(n6, this.A.g());
    const r5 = new Li();
    ki(r5, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), Dn(r5, 8, oi, n6), xi(r5, "IMAGE:input_frames_image"), Si(r5, "POSE_LANDMARKS:pose_landmarks"), Si(r5, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), Si(r5, "FACE_LANDMARKS:face_landmarks"), Si(r5, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), Si(r5, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), Si(r5, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), Si(r5, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), r5.o(e5), Oi(t6, r5), na(this, t6), this.g.attachProtoListener("pose_landmarks", (t7, e6) => {
      Fh(t7, this.h.poseLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("pose_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("pose_world_landmarks", (t7, e6) => {
      var n7 = this.h.poseWorldLandmarks;
      t7 = os(t7), n7.push(Uo(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("pose_world_landmarks", (t7) => {
      ea(this, t7);
    }), this.outputPoseSegmentationMasks && (Si(r5, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), ra(this, "pose_segmentation_mask"), this.g.W("pose_segmentation_mask", (t7, e6) => {
      this.h.poseSegmentationMasks = [rh(this, t7, true, !this.I)], ea(this, e6);
    }), this.g.attachEmptyPacketListener("pose_segmentation_mask", (t7) => {
      this.h.poseSegmentationMasks = [], ea(this, t7);
    })), this.g.attachProtoListener("face_landmarks", (t7, e6) => {
      Fh(t7, this.h.faceLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("face_landmarks", (t7) => {
      ea(this, t7);
    }), this.outputFaceBlendshapes && (Ui(t6, "extra_blendshapes"), Si(r5, "FACE_BLENDSHAPES:extra_blendshapes"), this.g.attachProtoListener("extra_blendshapes", (t7, e6) => {
      var n7 = this.h.faceBlendshapes;
      this.outputFaceBlendshapes && (t7 = Wi(t7), n7.push(Co(t7.g() ?? []))), ea(this, e6);
    }), this.g.attachEmptyPacketListener("extra_blendshapes", (t7) => {
      ea(this, t7);
    })), this.g.attachProtoListener("left_hand_landmarks", (t7, e6) => {
      Fh(t7, this.h.leftHandLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("left_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("left_hand_world_landmarks", (t7, e6) => {
      var n7 = this.h.leftHandWorldLandmarks;
      t7 = os(t7), n7.push(Uo(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("left_hand_world_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("right_hand_landmarks", (t7, e6) => {
      Fh(t7, this.h.rightHandLandmarks), ea(this, e6);
    }), this.g.attachEmptyPacketListener("right_hand_landmarks", (t7) => {
      ea(this, t7);
    }), this.g.attachProtoListener("right_hand_world_landmarks", (t7, e6) => {
      var n7 = this.h.rightHandWorldLandmarks;
      t7 = os(t7), n7.push(Uo(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("right_hand_world_landmarks", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Rh.prototype.detectForVideo = Rh.prototype.G, Rh.prototype.detect = Rh.prototype.F, Rh.prototype.setOptions = Rh.prototype.o, Rh.createFromModelPath = function(t6, e5) {
  return Qa(Rh, t6, { baseOptions: { modelAssetPath: e5 } });
}, Rh.createFromModelBuffer = function(t6, e5) {
  return Qa(Rh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Rh.createFromOptions = function(t6, e5) {
  return Qa(Rh, t6, e5);
}, Rh.HAND_CONNECTIONS = vh, Rh.POSE_CONNECTIONS = xh, Rh.FACE_LANDMARKS_LIPS = oh, Rh.FACE_LANDMARKS_LEFT_EYE = ah, Rh.FACE_LANDMARKS_LEFT_EYEBROW = hh, Rh.FACE_LANDMARKS_LEFT_IRIS = ch, Rh.FACE_LANDMARKS_RIGHT_EYE = uh, Rh.FACE_LANDMARKS_RIGHT_EYEBROW = lh, Rh.FACE_LANDMARKS_RIGHT_IRIS = dh, Rh.FACE_LANDMARKS_FACE_OVAL = fh, Rh.FACE_LANDMARKS_CONTOURS = ph, Rh.FACE_LANDMARKS_TESSELATION = gh;
var Mh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "input_image", "norm_rect", true), this.j = { classifications: [] }, Cn(t6 = this.h = new _o(), 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return Cn(this.h, 0, 2, Po(t6, Rn(this.h, ks, 2))), this.l(t6);
  }
  ua(t6, e5) {
    return this.j = { classifications: [] }, eh(this, t6, e5), this.j;
  }
  va(t6, e5, n6) {
    return this.j = { classifications: [] }, nh(this, t6, n6, e5), this.j;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "input_image"), Ii(t6, "norm_rect"), Ui(t6, "classifications");
    const e5 = new yi();
    Wn(e5, vo, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), xi(n6, "IMAGE:input_image"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "CLASSIFICATIONS:classifications"), n6.o(e5), Oi(t6, n6), this.g.attachProtoListener("classifications", (t7, e6) => {
      this.j = function(t8) {
        const e7 = { classifications: Pn(t8, ps, 1).map((t9) => Co(Rn(t9, Xi, 4)?.g() ?? [], Bn(Nn(t9, 2), 0), jn(t9, 3))) };
        return null != Fe(cn(t8, 2)) && (e7.timestampMs = Bn(Fe(cn(t8, 2)), 0)), e7;
      }(ys(t7)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("classifications", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Mh.prototype.classifyForVideo = Mh.prototype.va, Mh.prototype.classify = Mh.prototype.ua, Mh.prototype.setOptions = Mh.prototype.o, Mh.createFromModelPath = function(t6, e5) {
  return Qa(Mh, t6, { baseOptions: { modelAssetPath: e5 } });
}, Mh.createFromModelBuffer = function(t6, e5) {
  return Qa(Mh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Mh.createFromOptions = function(t6, e5) {
  return Qa(Mh, t6, e5);
};
var Ph = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", true), this.h = new Eo(), this.embeddings = { embeddings: [] }, Cn(t6 = this.h, 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    var e5 = this.h, n6 = Rn(this.h, Ss, 2);
    return n6 = n6 ? n6.clone() : new Ss(), void 0 !== t6.l2Normalize ? Vn(n6, 1, t6.l2Normalize) : "l2Normalize" in t6 && dn(n6, 1), void 0 !== t6.quantize ? Vn(n6, 2, t6.quantize) : "quantize" in t6 && dn(n6, 2), Cn(e5, 0, 2, n6), this.l(t6);
  }
  Ba(t6, e5) {
    return eh(this, t6, e5), this.embeddings;
  }
  Ca(t6, e5, n6) {
    return nh(this, t6, n6, e5), this.embeddings;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "embeddings_out");
    const e5 = new yi();
    Wn(e5, wo, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "EMBEDDINGS:embeddings_out"), n6.o(e5), Oi(t6, n6), this.g.attachProtoListener("embeddings_out", (t7, e6) => {
      t7 = bs(t7), this.embeddings = function(t8) {
        return { embeddings: Pn(t8, Es, 1).map((t9) => {
          const e7 = { headIndex: Bn(Nn(t9, 3), 0) ?? -1, headName: jn(t9, 4) ?? "" };
          if (void 0 !== Fn(t9, _s, xn(t9, 1))) t9 = yn(t9 = Rn(t9, _s, xn(t9, 1)), 1, ve), e7.floatEmbedding = t9.slice();
          else {
            const n7 = new Uint8Array(0);
            e7.quantizedEmbedding = Rn(t9, vs, xn(t9, 2))?.qa()?.h() ?? n7;
          }
          return e7;
        }), timestampMs: Bn(Fe(cn(t8, 2)), 0) };
      }(t7), ea(this, e6);
    }), this.g.attachEmptyPacketListener("embeddings_out", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Ph.cosineSimilarity = function(t6, e5) {
  if (t6.floatEmbedding && e5.floatEmbedding) t6 = No(t6.floatEmbedding, e5.floatEmbedding);
  else {
    if (!t6.quantizedEmbedding || !e5.quantizedEmbedding) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
    t6 = No(Do(t6.quantizedEmbedding), Do(e5.quantizedEmbedding));
  }
  return t6;
}, Ph.prototype.embedForVideo = Ph.prototype.Ca, Ph.prototype.embed = Ph.prototype.Ba, Ph.prototype.setOptions = Ph.prototype.o, Ph.createFromModelPath = function(t6, e5) {
  return Qa(Ph, t6, { baseOptions: { modelAssetPath: e5 } });
}, Ph.createFromModelBuffer = function(t6, e5) {
  return Qa(Ph, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Ph.createFromOptions = function(t6, e5) {
  return Qa(Ph, t6, e5);
};
var Ch = class {
  constructor(t6, e5, n6) {
    this.confidenceMasks = t6, this.categoryMask = e5, this.qualityScores = n6;
  }
  close() {
    this.confidenceMasks?.forEach((t6) => {
      t6.close();
    }), this.categoryMask?.close();
  }
};
function Oh(t6) {
  t6.categoryMask = void 0, t6.confidenceMasks = void 0, t6.qualityScores = void 0;
}
function Ih(t6) {
  try {
    const e5 = new Ch(t6.confidenceMasks, t6.categoryMask, t6.qualityScores);
    if (!t6.j) return e5;
    t6.j(e5);
  } finally {
    ia(t6);
  }
}
Ch.prototype.close = Ch.prototype.close;
var Uh = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.u = [], this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new xo(), this.v = new To(), Cn(this.h, 0, 3, this.v), Cn(t6 = this.h, 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return void 0 !== t6.displayNamesLocale ? dn(this.h, 2, Me(t6.displayNamesLocale)) : "displayNamesLocale" in t6 && dn(this.h, 2), "outputCategoryMask" in t6 && (this.outputCategoryMask = t6.outputCategoryMask ?? false), "outputConfidenceMasks" in t6 && (this.outputConfidenceMasks = t6.outputConfidenceMasks ?? true), super.l(t6);
  }
  L() {
    !function(t6) {
      const e5 = Pn(t6.fa(), Li, 1).filter((t7) => jn(t7, 1).includes("mediapipe.tasks.TensorsToSegmentationCalculator"));
      if (t6.u = [], 1 < e5.length) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
      1 === e5.length && (Rn(e5[0], yi, 7)?.l()?.g() ?? /* @__PURE__ */ new Map()).forEach((e6, n6) => {
        t6.u[Number(n6)] = jn(e6, 1);
      });
    }(this);
  }
  ga(t6, e5, n6) {
    const r5 = "function" != typeof e5 ? e5 : {};
    return this.j = "function" == typeof e5 ? e5 : n6, Oh(this), eh(this, t6, r5), Ih(this);
  }
  Na(t6, e5, n6, r5) {
    const i4 = "function" != typeof n6 ? n6 : {};
    return this.j = "function" == typeof n6 ? n6 : r5, Oh(this), nh(this, t6, i4, e5), Ih(this);
  }
  Fa() {
    return this.u;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect");
    const e5 = new yi();
    Wn(e5, So, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), n6.o(e5), Oi(t6, n6), na(this, t6), this.outputConfidenceMasks && (Ui(t6, "confidence_masks"), Si(n6, "CONFIDENCE_MASKS:confidence_masks"), ra(this, "confidence_masks"), this.g.da("confidence_masks", (t7, e6) => {
      this.confidenceMasks = t7.map((t8) => rh(this, t8, true, !this.j)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("confidence_masks", (t7) => {
      this.confidenceMasks = [], ea(this, t7);
    })), this.outputCategoryMask && (Ui(t6, "category_mask"), Si(n6, "CATEGORY_MASK:category_mask"), ra(this, "category_mask"), this.g.W("category_mask", (t7, e6) => {
      this.categoryMask = rh(this, t7, false, !this.j), ea(this, e6);
    }), this.g.attachEmptyPacketListener("category_mask", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    })), Ui(t6, "quality_scores"), Si(n6, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (t7, e6) => {
      this.qualityScores = t7, ea(this, e6);
    }), this.g.attachEmptyPacketListener("quality_scores", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
Uh.prototype.getLabels = Uh.prototype.Fa, Uh.prototype.segmentForVideo = Uh.prototype.Na, Uh.prototype.segment = Uh.prototype.ga, Uh.prototype.setOptions = Uh.prototype.o, Uh.createFromModelPath = function(t6, e5) {
  return Qa(Uh, t6, { baseOptions: { modelAssetPath: e5 } });
}, Uh.createFromModelBuffer = function(t6, e5) {
  return Qa(Uh, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, Uh.createFromOptions = function(t6, e5) {
  return Qa(Uh, t6, e5);
};
var Dh = class {
  constructor(t6, e5, n6) {
    this.confidenceMasks = t6, this.categoryMask = e5, this.qualityScores = n6;
  }
  close() {
    this.confidenceMasks?.forEach((t6) => {
      t6.close();
    }), this.categoryMask?.close();
  }
};
Dh.prototype.close = Dh.prototype.close;
var Nh = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Bh = [0, jr, -2];
var Gh = [0, Or, -3, Hr];
var jh = [0, Or, -3, Hr, Or, -1];
var Vh = [0, jh];
var Xh = [0, Vh, Bh];
var Hh = [0, jh, Bh];
var Wh = [0, jh, jr, -1];
var zh = [0, Wh, Bh];
var Kh = [0, Or, -3, Hr, Bh, -1];
var Yh = [0, Or, -3, Hr, ti];
var $h = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var qh = [0, Or, -1, Hr];
var Jh = class extends zn {
  constructor() {
    super();
  }
};
Jh.B = [1];
var Zh = class extends zn {
  constructor(t6) {
    super(t6);
  }
};
var Qh = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15];
var tc = [0, Qh, Jr, jh, Jr, Hh, Jr, Vh, Jr, Xh, Jr, qh, Jr, Yh, Jr, Gh, Jr, [0, Yr, Or, -2, Hr, jr, Hr, -1, 2, Or, Bh], Jr, Wh, Jr, zh, Or, Bh, Yr, Jr, Kh, Jr, [0, Cr, qh]];
var ec = [0, Yr, jr, -1, Hr];
var nc = class extends zn {
  constructor() {
    super();
  }
};
nc.B = [1], nc.prototype.g = si2([0, Cr, tc, Yr, ec]);
var rc = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect_in", false), this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new xo(), this.v = new To(), Cn(this.h, 0, 3, this.v), Cn(t6 = this.h, 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "outputCategoryMask" in t6 && (this.outputCategoryMask = t6.outputCategoryMask ?? false), "outputConfidenceMasks" in t6 && (this.outputConfidenceMasks = t6.outputConfidenceMasks ?? true), super.l(t6);
  }
  ga(t6, e5, n6, r5) {
    const i4 = "function" != typeof n6 ? n6 : {};
    this.j = "function" == typeof n6 ? n6 : r5, this.qualityScores = this.categoryMask = this.confidenceMasks = void 0, n6 = this.J + 1, r5 = new nc();
    const s3 = new Zh();
    var o5 = new Nh();
    if (Xn(o5, 1, 255), Cn(s3, 0, 12, o5), e5.keypoint && e5.scribble) throw Error("Cannot provide both keypoint and scribble.");
    if (e5.keypoint) {
      var a3 = new $h();
      Vn(a3, 3, true), Hn(a3, 1, e5.keypoint.x), Hn(a3, 2, e5.keypoint.y), On(s3, 5, Qh, a3);
    } else {
      if (!e5.scribble) throw Error("Must provide either a keypoint or a scribble.");
      for (a3 of (o5 = new Jh(), e5.scribble)) Vn(e5 = new $h(), 3, true), Hn(e5, 1, a3.x), Hn(e5, 2, a3.y), Dn(o5, 1, $h, e5);
      On(s3, 15, Qh, o5);
    }
    Dn(r5, 1, Zh, s3), this.g.addProtoToStream(r5.g(), "drishti.RenderData", "roi_in", n6), eh(this, t6, i4);
    t: {
      try {
        const t7 = new Dh(this.confidenceMasks, this.categoryMask, this.qualityScores);
        if (!this.j) {
          var h5 = t7;
          break t;
        }
        this.j(t7);
      } finally {
        ia(this);
      }
      h5 = void 0;
    }
    return h5;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "roi_in"), Ii(t6, "norm_rect_in");
    const e5 = new yi();
    Wn(e5, So, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "ROI:roi_in"), xi(n6, "NORM_RECT:norm_rect_in"), n6.o(e5), Oi(t6, n6), na(this, t6), this.outputConfidenceMasks && (Ui(t6, "confidence_masks"), Si(n6, "CONFIDENCE_MASKS:confidence_masks"), ra(this, "confidence_masks"), this.g.da("confidence_masks", (t7, e6) => {
      this.confidenceMasks = t7.map((t8) => rh(this, t8, true, !this.j)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("confidence_masks", (t7) => {
      this.confidenceMasks = [], ea(this, t7);
    })), this.outputCategoryMask && (Ui(t6, "category_mask"), Si(n6, "CATEGORY_MASK:category_mask"), ra(this, "category_mask"), this.g.W("category_mask", (t7, e6) => {
      this.categoryMask = rh(this, t7, false, !this.j), ea(this, e6);
    }), this.g.attachEmptyPacketListener("category_mask", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    })), Ui(t6, "quality_scores"), Si(n6, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", (t7, e6) => {
      this.qualityScores = t7, ea(this, e6);
    }), this.g.attachEmptyPacketListener("quality_scores", (t7) => {
      this.categoryMask = void 0, ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
rc.prototype.segment = rc.prototype.ga, rc.prototype.setOptions = rc.prototype.o, rc.createFromModelPath = function(t6, e5) {
  return Qa(rc, t6, { baseOptions: { modelAssetPath: e5 } });
}, rc.createFromModelBuffer = function(t6, e5) {
  return Qa(rc, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, rc.createFromOptions = function(t6, e5) {
  return Qa(rc, t6, e5);
};
var ic = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "input_frame_gpu", "norm_rect", false), this.j = { detections: [] }, Cn(t6 = this.h = new Lo(), 0, 1, e5 = new Cs());
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return void 0 !== t6.displayNamesLocale ? dn(this.h, 2, Me(t6.displayNamesLocale)) : "displayNamesLocale" in t6 && dn(this.h, 2), void 0 !== t6.maxResults ? Xn(this.h, 3, t6.maxResults) : "maxResults" in t6 && dn(this.h, 3), void 0 !== t6.scoreThreshold ? Hn(this.h, 4, t6.scoreThreshold) : "scoreThreshold" in t6 && dn(this.h, 4), void 0 !== t6.categoryAllowlist ? Tn(this.h, 5, t6.categoryAllowlist) : "categoryAllowlist" in t6 && dn(this.h, 5), void 0 !== t6.categoryDenylist ? Tn(this.h, 6, t6.categoryDenylist) : "categoryDenylist" in t6 && dn(this.h, 6), this.l(t6);
  }
  F(t6, e5) {
    return this.j = { detections: [] }, eh(this, t6, e5), this.j;
  }
  G(t6, e5, n6) {
    return this.j = { detections: [] }, nh(this, t6, n6, e5), this.j;
  }
  m() {
    var t6 = new Di();
    Ii(t6, "input_frame_gpu"), Ii(t6, "norm_rect"), Ui(t6, "detections");
    const e5 = new yi();
    Wn(e5, Fo, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.ObjectDetectorGraph"), xi(n6, "IMAGE:input_frame_gpu"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "DETECTIONS:detections"), n6.o(e5), Oi(t6, n6), this.g.attachProtoVectorListener("detections", (t7, e6) => {
      for (const e7 of t7) t7 = ns(e7), this.j.detections.push(Oo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("detections", (t7) => {
      ea(this, t7);
    }), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
ic.prototype.detectForVideo = ic.prototype.G, ic.prototype.detect = ic.prototype.F, ic.prototype.setOptions = ic.prototype.o, ic.createFromModelPath = async function(t6, e5) {
  return Qa(ic, t6, { baseOptions: { modelAssetPath: e5 } });
}, ic.createFromModelBuffer = function(t6, e5) {
  return Qa(ic, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, ic.createFromOptions = function(t6, e5) {
  return Qa(ic, t6, e5);
};
var sc = class {
  constructor(t6, e5, n6) {
    this.landmarks = t6, this.worldLandmarks = e5, this.segmentationMasks = n6;
  }
  close() {
    this.segmentationMasks?.forEach((t6) => {
      t6.close();
    });
  }
};
function oc(t6) {
  t6.landmarks = [], t6.worldLandmarks = [], t6.segmentationMasks = void 0;
}
function ac(t6) {
  try {
    const e5 = new sc(t6.landmarks, t6.worldLandmarks, t6.segmentationMasks);
    if (!t6.j) return e5;
    t6.j(e5);
  } finally {
    ia(t6);
  }
}
sc.prototype.close = sc.prototype.close;
var hc = class extends ih {
  constructor(t6, e5) {
    super(new Za(t6, e5), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = false, Cn(t6 = this.h = new Ro(), 0, 1, e5 = new Cs()), this.D = new go(), Cn(this.h, 0, 3, this.D), this.v = new fo(), Cn(this.h, 0, 2, this.v), Xn(this.v, 4, 1), Hn(this.v, 2, 0.5), Hn(this.D, 2, 0.5), Hn(this.h, 4, 0.5);
  }
  get baseOptions() {
    return Rn(this.h, Cs, 1);
  }
  set baseOptions(t6) {
    Cn(this.h, 0, 1, t6);
  }
  o(t6) {
    return "numPoses" in t6 && Xn(this.v, 4, t6.numPoses ?? 1), "minPoseDetectionConfidence" in t6 && Hn(this.v, 2, t6.minPoseDetectionConfidence ?? 0.5), "minTrackingConfidence" in t6 && Hn(this.h, 4, t6.minTrackingConfidence ?? 0.5), "minPosePresenceConfidence" in t6 && Hn(this.D, 2, t6.minPosePresenceConfidence ?? 0.5), "outputSegmentationMasks" in t6 && (this.outputSegmentationMasks = t6.outputSegmentationMasks ?? false), this.l(t6);
  }
  F(t6, e5, n6) {
    const r5 = "function" != typeof e5 ? e5 : {};
    return this.j = "function" == typeof e5 ? e5 : n6, oc(this), eh(this, t6, r5), ac(this);
  }
  G(t6, e5, n6, r5) {
    const i4 = "function" != typeof n6 ? n6 : {};
    return this.j = "function" == typeof n6 ? n6 : r5, oc(this), nh(this, t6, i4, e5), ac(this);
  }
  m() {
    var t6 = new Di();
    Ii(t6, "image_in"), Ii(t6, "norm_rect"), Ui(t6, "normalized_landmarks"), Ui(t6, "world_landmarks"), Ui(t6, "segmentation_masks");
    const e5 = new yi();
    Wn(e5, Mo, this.h);
    const n6 = new Li();
    ki(n6, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), xi(n6, "IMAGE:image_in"), xi(n6, "NORM_RECT:norm_rect"), Si(n6, "NORM_LANDMARKS:normalized_landmarks"), Si(n6, "WORLD_LANDMARKS:world_landmarks"), n6.o(e5), Oi(t6, n6), na(this, t6), this.g.attachProtoVectorListener("normalized_landmarks", (t7, e6) => {
      this.landmarks = [];
      for (const e7 of t7) t7 = us(e7), this.landmarks.push(Io(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("normalized_landmarks", (t7) => {
      this.landmarks = [], ea(this, t7);
    }), this.g.attachProtoVectorListener("world_landmarks", (t7, e6) => {
      this.worldLandmarks = [];
      for (const e7 of t7) t7 = os(e7), this.worldLandmarks.push(Uo(t7));
      ea(this, e6);
    }), this.g.attachEmptyPacketListener("world_landmarks", (t7) => {
      this.worldLandmarks = [], ea(this, t7);
    }), this.outputSegmentationMasks && (Si(n6, "SEGMENTATION_MASK:segmentation_masks"), ra(this, "segmentation_masks"), this.g.da("segmentation_masks", (t7, e6) => {
      this.segmentationMasks = t7.map((t8) => rh(this, t8, true, !this.j)), ea(this, e6);
    }), this.g.attachEmptyPacketListener("segmentation_masks", (t7) => {
      this.segmentationMasks = [], ea(this, t7);
    })), t6 = t6.g(), this.setGraph(new Uint8Array(t6), true);
  }
};
hc.prototype.detectForVideo = hc.prototype.G, hc.prototype.detect = hc.prototype.F, hc.prototype.setOptions = hc.prototype.o, hc.createFromModelPath = function(t6, e5) {
  return Qa(hc, t6, { baseOptions: { modelAssetPath: e5 } });
}, hc.createFromModelBuffer = function(t6, e5) {
  return Qa(hc, t6, { baseOptions: { modelAssetBuffer: e5 } });
}, hc.createFromOptions = function(t6, e5) {
  return Qa(hc, t6, e5);
}, hc.POSE_CONNECTIONS = xh;

// node_modules/ixfx/bundle/chunk-51aI8Tpl.js
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all) __defProp2(target, name, {
    get: all[name],
    enumerable: true
  });
};
var __copyProps = (to3, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") for (var keys = __getOwnPropNames(from3), i4 = 0, n6 = keys.length, key; i4 < n6; i4++) {
    key = keys[i4];
    if (!__hasOwnProp.call(to3, key) && key !== except) __defProp2(to3, key, {
      get: ((k3) => from3[k3]).bind(null, key),
      enumerable: !(desc = __getOwnPropDesc2(from3, key)) || desc.enumerable
    });
  }
  return to3;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
  value: mod,
  enumerable: true
}) : target, mod));

// node_modules/ixfx/bundle/src-BBD50Kth.js
var getErrorMessage = (ex) => {
  if (typeof ex === `string`) return ex;
  if (ex instanceof Error) return ex.message;
  return ex;
};
var throwIfFailed = (...results) => {
  const failed = results.filter((r5) => resultIsError(r5));
  if (failed.length === 0) return;
  const messages = failed.map((f5) => resultErrorToString(f5));
  throw new Error(messages.join(`, `));
};
function resultThrow(...results) {
  for (const r5 of results) {
    const rr2 = typeof r5 === `object` ? r5 : r5();
    if (rr2 === void 0) continue;
    if (rr2.success) continue;
    throw resultToError(rr2);
  }
  return true;
}
function resultThrowSingle(result) {
  if (result.success) return true;
  throw resultToError(result);
}
var resultFirstFail_ = (...results) => {
  for (const r5 of results) {
    const rr2 = typeof r5 === `object` ? r5 : r5();
    if (rr2 === void 0) continue;
    if (!rr2.success) return rr2;
  }
};
function resultIsError(result) {
  if (typeof result !== `object`) return false;
  return !result.success;
}
function resultIsOk(result) {
  if (typeof result !== `object`) return false;
  return result.success;
}
function resultToError(result) {
  if (typeof result.error === `string`) throw new Error(result.error, { cause: result.info });
  if (result.error instanceof Error) throw result.error;
  return new Error(JSON.stringify(result.error), { cause: result.info });
}
function resultToValue(result) {
  if (resultIsOk(result)) return result.value;
  throw resultToError(result);
}
function resultErrorToString(result) {
  if (result.error instanceof Error) return getErrorMessage(result.error);
  if (typeof result.error === `string`) return result.error;
  return JSON.stringify(result.error);
}
function errorResult(error, info) {
  return {
    success: false,
    error,
    info
  };
}
var resultsCollate = (...results) => {
  let rr2;
  for (const r5 of results) {
    rr2 = typeof r5 === `object` ? r5 : r5();
    if (rr2 === void 0) continue;
    if (!rr2.success) return rr2;
  }
  if (!rr2) throw new Error(`No results`);
  return rr2;
};
var resultWithFail = (result, callback) => {
  if (resultIsError(result)) callback(result);
};
var isPowerOfTwo = (x3) => Math.log2(x3) % 1 === 0;
var ifNaN = (v3, fallback) => {
  if (typeof v3 !== `number`) throw new TypeError(`v is not a number. Got: ${typeof v3}`);
  if (Number.isNaN(v3)) return fallback;
  return v3;
};
var integerParse = (value3, range = ``, defaultValue = NaN) => {
  if (typeof value3 === `undefined`) return defaultValue;
  if (value3 === null) return defaultValue;
  try {
    const parsed = Number.parseInt(typeof value3 === `number` ? value3.toString() : value3);
    const r5 = integerTest(parsed, range, `parsed`);
    return r5.success ? parsed : defaultValue;
  } catch {
    return defaultValue;
  }
};
var numberTest = (value3, range = ``, parameterName = `?`, info) => {
  if (value3 === null) return {
    success: false,
    error: `Parameter '${parameterName}' is null`,
    info
  };
  if (typeof value3 === `undefined`) return {
    success: false,
    error: `Parameter '${parameterName}' is undefined`,
    info
  };
  if (Number.isNaN(value3)) return {
    success: false,
    error: `Parameter '${parameterName}' is NaN`,
    info
  };
  if (typeof value3 !== `number`) return {
    success: false,
    error: `Parameter '${parameterName}' is not a number (${JSON.stringify(value3)})`,
    info
  };
  switch (range) {
    case `finite`: {
      if (!Number.isFinite(value3)) return {
        success: false,
        error: `Parameter '${parameterName} must be finite (Got: ${value3})`,
        info
      };
      break;
    }
    case `positive`: {
      if (value3 < 0) return {
        success: false,
        error: `Parameter '${parameterName}' must be at least zero (${value3})`,
        info
      };
      break;
    }
    case `negative`: {
      if (value3 > 0) return {
        success: false,
        error: `Parameter '${parameterName}' must be zero or lower (${value3})`,
        info
      };
      break;
    }
    case `aboveZero`: {
      if (value3 <= 0) return {
        success: false,
        error: `Parameter '${parameterName}' must be above zero (${value3})`,
        info
      };
      break;
    }
    case `belowZero`: {
      if (value3 >= 0) return {
        success: false,
        error: `Parameter '${parameterName}' must be below zero (${value3})`,
        info
      };
      break;
    }
    case `percentage`: {
      if (value3 > 1 || value3 < 0) return {
        success: false,
        error: `Parameter '${parameterName}' must be in percentage range (0 to 1). (${value3})`,
        info
      };
      break;
    }
    case `nonZero`: {
      if (value3 === 0) return {
        success: false,
        error: `Parameter '${parameterName}' must non-zero. (${value3})`,
        info
      };
      break;
    }
    case `bipolar`: {
      if (value3 > 1 || value3 < -1) return {
        success: false,
        error: `Parameter '${parameterName}' must be in bipolar percentage range (-1 to 1). (${value3})`,
        info
      };
      break;
    }
  }
  return {
    success: true,
    value: value3,
    info
  };
};
var numberDecimalTest = (a3, b3, decimals = 3) => {
  if (decimals === 0) {
    a3 = Math.floor(a3);
    b3 = Math.floor(b3);
    if (a3 === b3) return {
      success: true,
      value: a3
    };
    return {
      success: false,
      error: `A is not identical to B`
    };
  }
  const mult = Math.pow(10, decimals);
  const aa2 = Math.floor(a3 * mult);
  const bb = Math.floor(b3 * mult);
  if (aa2 !== bb) return {
    success: false,
    error: `A is not close enough to B. A: ${a3} B: ${b3} Decimals: ${decimals}`
  };
  return {
    success: true,
    value: a3
  };
};
var percentTest = (value3, parameterName = `?`, info) => numberTest(value3, `percentage`, parameterName, info);
var integerTest = (value3, range = ``, parameterName = `?`) => {
  return resultsCollate(numberTest(value3, range, parameterName), () => {
    if (!Number.isInteger(value3)) return {
      success: false,
      error: `Param '${parameterName}' is not an integer`
    };
    return {
      success: true,
      value: value3
    };
  });
};
var integerArrayTest = (numbers) => {
  for (const v3 of numbers) if (Math.abs(v3) % 1 !== 0) return {
    success: false,
    error: `Value is not an integer: ${v3}`
  };
  return {
    success: true,
    value: numbers
  };
};
var isInteger = (value3) => {
  if (typeof value3 === `string`) value3 = Number.parseFloat(value3);
  const r5 = integerTest(value3);
  return r5.success;
};
var numberInclusiveRangeTest = (value3, min4, max4, parameterName = `?`) => {
  if (typeof value3 !== `number`) return {
    success: false,
    error: `Param '${parameterName}' is not a number type. Got type: '${typeof value3}' value: '${JSON.stringify(value3)}'`
  };
  if (Number.isNaN(value3)) return {
    success: false,
    error: `Param '${parameterName}' is not within range ${min4}-${max4}. Got: NaN`
  };
  if (Number.isFinite(value3)) {
    if (value3 < min4) return {
      success: false,
      error: `Param '${parameterName}' is below range ${min4}-${max4}. Got: ${value3}`
    };
    else if (value3 > max4) return {
      success: false,
      error: `Param '${parameterName}' is above range ${min4}-${max4}. Got: ${value3}`
    };
    return {
      success: true,
      value: value3
    };
  } else return {
    success: false,
    error: `Param '${parameterName}' is not within range ${min4}-${max4}. Got: infinite`
  };
};
var arrayTest = (value3, parameterName = `?`) => {
  if (!Array.isArray(value3)) return {
    success: false,
    error: `Parameter '${parameterName}' is expected to be an array'`
  };
  return {
    success: true,
    value: value3
  };
};
var arrayIndexTest = (array3, index, name = `index`) => {
  return resultsCollate(arrayTest(array3), integerTest(index, `positive`, name), numberInclusiveRangeTest(index, 0, array3.length - 1, name));
};
var arrayStringsTest = (value3) => {
  if (!Array.isArray(value3)) return {
    success: false,
    error: `Value is not an array`
  };
  if (value3.some((v3) => typeof v3 !== `string`)) return {
    success: false,
    error: `Contains something not a string`
  };
  return {
    success: true,
    value: value3
  };
};
var nullUndefTest = (value3, parameterName = `?`) => {
  if (typeof value3 === `undefined`) return {
    success: false,
    error: `${parameterName} param is undefined`
  };
  if (value3 === null) return {
    success: false,
    error: `${parameterName} param is null`
  };
  return {
    success: true,
    value: value3
  };
};
var isDefined = (argument) => argument !== void 0;
var isFunction = (object) => object instanceof Function;
var functionTest = (value3, parameterName = `?`) => {
  if (value3 === void 0) return {
    success: false,
    error: `Param '${parameterName}' is undefined. Expected: function.`
  };
  if (value3 === null) return {
    success: false,
    error: `Param '${parameterName}' is null. Expected: function.`
  };
  if (typeof value3 !== `function`) return {
    success: false,
    error: `Param '${parameterName}' is type '${typeof value3}'. Expected: function`
  };
  return {
    success: true,
    value: value3
  };
};
var testPlainObject = (value3) => {
  if (typeof value3 !== `object` || value3 === null) return {
    success: false,
    error: `Value is null or not object type`
  };
  const prototype = Object.getPrototypeOf(value3);
  const t6 = (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value3) && !(Symbol.iterator in value3);
  if (t6) return {
    success: true,
    value: value3
  };
  return {
    success: false,
    error: `Fancy object`
  };
};
var testPlainObjectOrPrimitive = (value3) => {
  const t6 = typeof value3;
  if (t6 === `symbol`) return {
    success: false,
    error: `Symbol type`
  };
  if (t6 === `function`) return {
    success: false,
    error: `Function type`
  };
  if (t6 === `bigint`) return {
    success: true,
    value: value3
  };
  if (t6 === `number`) return {
    success: true,
    value: value3
  };
  if (t6 === `string`) return {
    success: true,
    value: value3
  };
  if (t6 === `boolean`) return {
    success: true,
    value: value3
  };
  return testPlainObject(value3);
};
var rangeIntegerTest = (v3, expected) => {
  return resultsCollate(rangeTest(v3, expected), integerArrayTest(v3));
};
var rangeTest = (numbers, expected) => {
  for (const v3 of numbers) {
    if (expected.minExclusive !== void 0) {
      if (v3 <= expected.minExclusive) return {
        success: false,
        error: `Value '${v3}' must be higher than minExclusive: '${expected.minExclusive}'`
      };
    }
    if (expected.minInclusive !== void 0) {
      if (v3 < expected.minInclusive) return {
        success: false,
        error: `Value '${v3}' must be equal or higher than minInclusive: '${expected.minInclusive}'`
      };
    }
    if (expected.maxExclusive !== void 0) {
      if (v3 >= expected.maxExclusive) return {
        success: false,
        error: `Value '${v3}' must be less than maxExclusive: '${expected.maxExclusive}'`
      };
    }
    if (expected.maxInclusive !== void 0) {
      if (v3 > expected.maxInclusive) return {
        success: false,
        error: `Value '${v3}' must be equal or less than maxInclusive: '${expected.maxInclusive}'`
      };
    }
  }
  return {
    success: true,
    value: numbers
  };
};
var stringTest = (value3, range = ``, parameterName = `?`) => {
  if (typeof value3 !== `string`) return {
    success: false,
    error: `Param '${parameterName} is not type string. Got: ${typeof value3}`
  };
  switch (range) {
    case `non-empty`:
      if (value3.length === 0) return {
        success: false,
        error: `Param '${parameterName} is empty`
      };
      break;
  }
  return {
    success: true,
    value: value3
  };
};
var src_exports = {};
__export(src_exports, {
  arrayIndexTest: () => arrayIndexTest,
  arrayStringsTest: () => arrayStringsTest,
  arrayTest: () => arrayTest,
  errorResult: () => errorResult,
  functionTest: () => functionTest,
  getErrorMessage: () => getErrorMessage,
  ifNaN: () => ifNaN,
  integerArrayTest: () => integerArrayTest,
  integerParse: () => integerParse,
  integerTest: () => integerTest,
  isDefined: () => isDefined,
  isFunction: () => isFunction,
  isInteger: () => isInteger,
  isPowerOfTwo: () => isPowerOfTwo,
  nullUndefTest: () => nullUndefTest,
  numberDecimalTest: () => numberDecimalTest,
  numberInclusiveRangeTest: () => numberInclusiveRangeTest,
  numberTest: () => numberTest,
  percentTest: () => percentTest,
  rangeIntegerTest: () => rangeIntegerTest,
  rangeTest: () => rangeTest,
  resultErrorToString: () => resultErrorToString,
  resultFirstFail_: () => resultFirstFail_,
  resultIsError: () => resultIsError,
  resultIsOk: () => resultIsOk,
  resultThrow: () => resultThrow,
  resultThrowSingle: () => resultThrowSingle,
  resultToError: () => resultToError,
  resultToValue: () => resultToValue,
  resultWithFail: () => resultWithFail,
  resultsCollate: () => resultsCollate,
  stringTest: () => stringTest,
  testPlainObject: () => testPlainObject,
  testPlainObjectOrPrimitive: () => testPlainObjectOrPrimitive,
  throwIfFailed: () => throwIfFailed
});

// node_modules/ixfx/bundle/is-primitive-eBwrK4Yg.js
function isPrimitive(value3) {
  if (typeof value3 === `number`) return true;
  if (typeof value3 === `string`) return true;
  if (typeof value3 === `bigint`) return true;
  if (typeof value3 === `boolean`) return true;
  return false;
}

// node_modules/ixfx/bundle/interval-type-DajslxUJ.js
var removeCircularReferences = (value3, replaceWith = null, seen = /* @__PURE__ */ new WeakSet(), path3 = ``) => {
  if (value3 === null) return value3;
  if (typeof value3 !== `object`) throw new TypeError(`Param 'value' must be an object. Got type: ${typeof value3}`);
  seen.add(value3);
  const entries2 = Object.entries(value3);
  for (const entry of entries2) {
    if (entry[1] === null) continue;
    if (typeof entry[1] !== `object`) continue;
    if (seen.has(entry[1])) {
      entry[1] = replaceWith;
      continue;
    }
    entry[1] = removeCircularReferences(entry[1], replaceWith, seen, `${entry[0]}.`);
  }
  return Object.fromEntries(entries2);
};
var toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string` ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor);
var defaultToString = (value3) => {
  if (value3 === null) return `null`;
  if (typeof value3 === `boolean` || typeof value3 === `number`) return value3.toString();
  if (typeof value3 === `string`) return value3;
  if (typeof value3 === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);
  try {
    const s3 = JSON.stringify(value3);
    return s3;
  } catch (error) {
    if (typeof value3 === `object`) return JSON.stringify(removeCircularReferences(value3, `(circular)`));
    else throw error;
  }
};
var toStringOrdered = (itemToMakeStringFor) => {
  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;
  const allKeys = /* @__PURE__ */ new Set();
  JSON.stringify(itemToMakeStringFor, (key, value3) => (allKeys.add(key), value3));
  return JSON.stringify(itemToMakeStringFor, [...allKeys].sort());
};
var isEqualDefault = (a3, b3) => a3 === b3;
var isEqualValueIgnoreOrder = (a3, b3) => {
  if (a3 === b3) return true;
  return toStringOrdered(a3) === toStringOrdered(b3);
};
var compareIterableValuesShallow = (a3, b3, eq = isEqualDefault) => {
  const shared = [];
  const aUnique = [];
  const bUnique = [];
  for (const elementOfA of a3) {
    let seenInB = false;
    for (const elementOfB of b3) if (eq(elementOfA, elementOfB)) {
      seenInB = true;
      break;
    }
    if (seenInB) shared.push(elementOfA);
    else aUnique.push(elementOfA);
  }
  for (const elementOfB of b3) {
    let seenInA = false;
    for (const elementOfA of a3) if (eq(elementOfB, elementOfA)) seenInA = true;
    if (!seenInA) bUnique.push(elementOfB);
  }
  const isSame = aUnique.length === 0 && bUnique.length === 0;
  return {
    shared,
    isSame,
    a: aUnique,
    b: bUnique
  };
};
function round(a3, b3, roundUp) {
  resultThrow(integerTest(a3, `positive`, `decimalPlaces`));
  const up = typeof b3 === `boolean` ? b3 : roundUp ?? false;
  let rounder;
  if (a3 === 0) rounder = Math.round;
  else {
    const p3 = Math.pow(10, a3);
    if (up) rounder = (v3) => Math.ceil(v3 * p3) / p3;
    else rounder = (v3) => Math.floor(v3 * p3) / p3;
  }
  if (typeof b3 === `number`) return rounder(b3);
  return rounder;
}
function intervalToMs(interval2, defaultNumber) {
  if (isInterval(interval2)) {
    if (typeof interval2 === `number`) return interval2;
    let ms2 = interval2.millis ?? 0;
    ms2 += (interval2.hours ?? 0) * 60 * 60 * 1e3;
    ms2 += (interval2.mins ?? 0) * 60 * 1e3;
    ms2 += (interval2.secs ?? 0) * 1e3;
    return ms2;
  } else {
    if (typeof defaultNumber !== `undefined`) return defaultNumber;
    throw new Error(`Not a valid interval: ${JSON.stringify(interval2)}`);
  }
}
function isInterval(interval2) {
  if (typeof interval2 === `undefined`) return false;
  if (interval2 === null) return false;
  if (typeof interval2 === `number`) {
    if (Number.isNaN(interval2)) return false;
    if (!Number.isFinite(interval2)) return false;
    return true;
  }
  if (typeof interval2 !== `object`) return false;
  const hasMillis = `millis` in interval2;
  const hasSecs = `secs` in interval2;
  const hasMins = `mins` in interval2;
  const hasHours = `hours` in interval2;
  if (hasMillis && !numberTest(interval2.millis).success) return false;
  if (hasSecs && !numberTest(interval2.secs).success) return false;
  if (hasMins && !numberTest(interval2.mins).success) return false;
  if (hasHours && !numberTest(interval2.hours).success) return false;
  if (hasMillis || hasSecs || hasHours || hasMins) return true;
  return false;
}
var elapsedToHumanString = (millisOrFunction, rounding = 2) => {
  let interval2 = 0;
  if (typeof millisOrFunction === `function`) {
    const intervalResult = millisOrFunction();
    return elapsedToHumanString(intervalResult);
  } else if (typeof millisOrFunction === `number`) interval2 = millisOrFunction;
  else if (typeof millisOrFunction === `object`) interval2 = intervalToMs(interval2);
  let ms2 = intervalToMs(interval2);
  if (typeof ms2 === `undefined`) return `(undefined)`;
  if (ms2 < 1e3) return `${round(rounding, ms2)}ms`;
  ms2 /= 1e3;
  if (ms2 < 120) return `${ms2.toFixed(1)}secs`;
  ms2 /= 60;
  if (ms2 < 60) return `${ms2.toFixed(2)}mins`;
  ms2 /= 60;
  return `${ms2.toFixed(2)}hrs`;
};

// node_modules/ixfx/bundle/basic-D0XoOdBJ.js
var numericComparer = (a3, b3) => {
  if (a3 === b3) return 0;
  if (a3 > b3) return 1;
  return -1;
};
var jsComparer = (x3, y3) => {
  if (x3 === void 0 && y3 === void 0) return 0;
  if (x3 === void 0) return 1;
  if (y3 === void 0) return -1;
  const xString = defaultToString(x3);
  const yString = defaultToString(y3);
  if (xString < yString) return -1;
  if (xString > yString) return 1;
  return 0;
};
var defaultComparer = (x3, y3) => {
  if (typeof x3 === `number` && typeof y3 === `number`) return numericComparer(x3, y3);
  return jsComparer(x3, y3);
};
var maps_exports = {};
__export(maps_exports, {
  addObjectEntriesMutate: () => addObjectEntriesMutate,
  addValue: () => addValue,
  addValueMutate: () => addValueMutate,
  addValueMutator: () => addValueMutator,
  deleteByValueCompareMutate: () => deleteByValueCompareMutate,
  filterValues: () => filterValues,
  findBySomeKey: () => findBySomeKey,
  findEntryByPredicate: () => findEntryByPredicate,
  findEntryByValue: () => findEntryByValue,
  findValue: () => findValue,
  fromIterable: () => fromIterable,
  fromObject: () => fromObject,
  getClosestIntegerKey: () => getClosestIntegerKey,
  getOrGenerate: () => getOrGenerate,
  getOrGenerateSync: () => getOrGenerateSync,
  hasAnyValue: () => hasAnyValue,
  hasKeyValue: () => hasKeyValue,
  mapToArray: () => mapToArray,
  mapToObjectTransform: () => mapToObjectTransform,
  mergeByKey: () => mergeByKey,
  some: () => some,
  sortByValue: () => sortByValue,
  sortByValueProperty: () => sortByValueProperty,
  toArray: () => toArray,
  toObject: () => toObject,
  transformMap: () => transformMap,
  zipKeyValue: () => zipKeyValue
});
var getClosestIntegerKey = (data, target) => {
  target = Math.round(target);
  if (data.has(target)) return target;
  else {
    let offset3 = 1;
    while (offset3 < 1e3) {
      if (data.has(target - offset3)) return target - offset3;
      else if (data.has(target + offset3)) return target + offset3;
      offset3++;
    }
    throw new Error(`Could not find target ${target.toString()}`);
  }
};
var findBySomeKey = (data, keys) => {
  for (const key of keys) if (data.has(key)) return data.get(key);
};
var hasKeyValue = (map2, key, value3, comparer = isEqualDefault) => {
  if (!map2.has(key)) return false;
  const values3 = [...map2.values()];
  return values3.some((v3) => comparer(v3, value3));
};
var deleteByValueCompareMutate = (map2, value3, comparer = isEqualDefault) => {
  for (const entry of map2.entries()) if (comparer(entry[1], value3)) map2.delete(entry[0]);
};
var findEntryByPredicate = (map2, predicate) => {
  for (const entry of map2.entries()) if (predicate(entry[1], entry[0])) return entry;
};
var findEntryByValue = (map2, value3, isEqual4 = isEqualDefault) => {
  for (const entry of map2.entries()) if (isEqual4(entry[1], value3)) return entry;
};
var addValueMutate = (map2, hasher, collisionPolicy, ...values3) => {
  const m4 = map2 ?? /* @__PURE__ */ new Map();
  const f5 = addValueMutator(m4, hasher, collisionPolicy);
  f5(...values3);
  return m4;
};
var addValue = (map2, hasher, collisionPolicy, ...values3) => {
  const m4 = map2 === void 0 ? /* @__PURE__ */ new Map() : new Map(map2);
  for (const v3 of values3) {
    const hashResult = hasher(v3);
    if (collisionPolicy !== `overwrite`) {
      if (m4.has(hashResult)) {
        if (collisionPolicy === `throw`) throw new Error(`Key '${hashResult}' already in map`);
        if (collisionPolicy === `skip`) continue;
      }
    }
    m4.set(hashResult, v3);
  }
  return m4;
};
var addValueMutator = (map2, hasher, collisionPolicy = `overwrite`) => {
  return (...values3) => {
    for (const v3 of values3) {
      const hashResult = hasher(v3);
      if (collisionPolicy !== `overwrite`) {
        if (map2.has(hashResult)) {
          if (collisionPolicy === `throw`) throw new Error(`Key '${hashResult}' already in map`);
          if (collisionPolicy === `skip`) continue;
        }
      }
      map2.set(hashResult, v3);
    }
    return map2;
  };
};
var sortByValue = (map2, comparer) => {
  const f5 = comparer ?? defaultComparer;
  return [...map2.entries()].sort((a3, b3) => f5(a3[1], b3[1]));
};
var sortByValueProperty = (map2, property, compareFunction) => {
  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;
  return [...map2.entries()].sort((aE, bE) => {
    const a3 = aE[1];
    const b3 = bE[1];
    return cfn(a3[property], b3[property]);
  });
};
var hasAnyValue = (map2, value3, comparer) => {
  const entries2 = [...map2.entries()];
  return entries2.some((kv) => comparer(kv[1], value3));
};
function* filterValues(map2, predicate) {
  for (const v3 of map2.values()) if (predicate(v3)) yield v3;
}
var toArray = (map2) => [...map2.values()];
var fromIterable = (data, keyFunction = toStringDefault, collisionPolicy = `overwrite`) => {
  const m4 = /* @__PURE__ */ new Map();
  for (const d3 of data) {
    const key = keyFunction(d3);
    if (m4.has(key)) {
      if (collisionPolicy === `throw`) throw new Error(`Key '${key}' is already used and new data will overwrite it. `);
      if (collisionPolicy === `skip`) continue;
    }
    m4.set(key, d3);
  }
  return m4;
};
var fromObject = (data) => {
  const map2 = /* @__PURE__ */ new Map();
  if (Array.isArray(data)) for (const d3 of data) addObjectEntriesMutate(map2, d3);
  else addObjectEntriesMutate(map2, data);
  return map2;
};
var addObjectEntriesMutate = (map2, data) => {
  const entries2 = Object.entries(data);
  for (const [key, value3] of entries2) map2.set(key, value3);
};
var findValue = (map2, predicate) => [...map2.values()].find((v3) => predicate(v3));
var some = (map2, predicate) => [...map2.values()].some((v3) => predicate(v3));
var mapToObjectTransform = (m4, valueTransform) => [...m4].reduce((object, [key, value3]) => {
  const t6 = valueTransform(value3);
  object[key] = t6;
  return object;
}, {});
var zipKeyValue = (keys, values3) => {
  if (keys.length !== values3.length) throw new Error(`Keys and values arrays should be same length`);
  return Object.fromEntries(keys.map((k3, index) => [k3, values3[index]]));
};
var transformMap = (source, transformer) => new Map(Array.from(source, (v3) => [v3[0], transformer(v3[1], v3[0])]));
var toObject = (m4) => [...m4].reduce((object, [key, value3]) => {
  object[key] = value3;
  return object;
}, {});
var mapToArray = (m4, transformer) => [...m4.entries()].map((x3) => transformer(x3[0], x3[1]));
var mergeByKey = (reconcile, ...maps) => {
  const result = /* @__PURE__ */ new Map();
  for (const m4 of maps) for (const [mk, mv] of m4) {
    let v3 = result.get(mk);
    v3 = v3 ? reconcile(v3, mv) : mv;
    result.set(mk, v3);
  }
  return result;
};
var getOrGenerateSync = (map2, fn2) => (key, args) => {
  let value3 = map2.get(key);
  if (value3 !== void 0) return value3;
  value3 = fn2(key, args);
  map2.set(key, value3);
  return value3;
};
var getOrGenerate = (map2, fn2) => async (key, args) => {
  let value3 = map2.get(key);
  if (value3 !== void 0) return value3;
  value3 = await fn2(key, args);
  if (value3 === void 0) throw new Error(`fn returned undefined`);
  map2.set(key, value3);
  return value3;
};
var continuously = (callback, interval2 = 0, options = {}) => {
  let intervalMs = intervalToMs(interval2, 0);
  resultThrow(integerTest(intervalMs, `positive`, `interval`));
  const fireBeforeWait = options.fireBeforeWait ?? false;
  const onStartCalled = options.onStartCalled;
  const signal = options.signal;
  let disposed = false;
  let runState = `idle`;
  let startCount = 0;
  let startCountTotal = 0;
  let startedAt = performance.now();
  let intervalUsed = interval2 ?? 0;
  let cancelled = false;
  let currentTimer;
  const deschedule = () => {
    if (currentTimer === void 0) return;
    globalThis.clearTimeout(currentTimer);
    currentTimer = void 0;
    startCount = 0;
    startedAt = NaN;
  };
  const schedule = (scheduledCallback) => {
    if (intervalMs === 0) if (typeof requestAnimationFrame === `undefined`) currentTimer = globalThis.setTimeout(scheduledCallback, 0);
    else {
      currentTimer = void 0;
      requestAnimationFrame(scheduledCallback);
    }
    else currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);
  };
  const cancel = () => {
    if (cancelled) return;
    cancelled = true;
    if (runState === `idle`) return;
    runState = `idle`;
    deschedule();
  };
  const loop = async () => {
    if (signal?.aborted) runState = `idle`;
    if (runState === `idle`) return;
    runState = `running`;
    startCount++;
    startCountTotal++;
    const valueOrPromise = callback(startCount, performance.now() - startedAt);
    const value3 = typeof valueOrPromise === `object` ? await valueOrPromise : valueOrPromise;
    if (cancelled) return;
    runState = `scheduled`;
    if (value3 !== void 0 && !value3) {
      cancel();
      return;
    }
    if (cancelled) return;
    schedule(loop);
  };
  const start = () => {
    if (disposed) throw new Error(`Disposed`);
    cancelled = false;
    if (onStartCalled !== void 0) {
      const doWhat = onStartCalled(startCount, performance.now() - startedAt);
      switch (doWhat) {
        case `cancel`: {
          cancel();
          return;
        }
        case `reset`: {
          reset2();
          return;
        }
        case `dispose`: {
          disposed = true;
          cancel();
          return;
        }
      }
    }
    if (runState === `idle`) {
      startCount = 0;
      startedAt = performance.now();
      runState = `scheduled`;
      if (fireBeforeWait) loop();
      else schedule(loop);
    }
  };
  const reset2 = () => {
    if (disposed) throw new Error(`Disposed`);
    cancelled = false;
    startCount = 0;
    startedAt = NaN;
    if (runState !== `idle`) cancel();
    start();
  };
  return {
    start,
    reset: reset2,
    cancel,
    get interval() {
      return intervalUsed;
    },
    get runState() {
      return runState;
    },
    get startCountTotal() {
      return startCountTotal;
    },
    get startCount() {
      return startCount;
    },
    set interval(interval$1) {
      const ms2 = intervalToMs(interval$1, 0);
      resultThrow(integerTest(ms2, `positive`, `interval`));
      intervalMs = ms2;
      intervalUsed = interval$1;
    },
    get isDisposed() {
      return disposed;
    },
    get elapsedMs() {
      return performance.now() - startedAt;
    }
  };
};
var elapsedSince = () => {
  const start = performance.now();
  return () => {
    return performance.now() - start;
  };
};
var elapsedInfinity = () => {
  return () => {
    return Number.POSITIVE_INFINITY;
  };
};
var promiseFromEvent = (target, name) => {
  return new Promise((resolve2) => {
    const handler = (...args) => {
      target.removeEventListener(name, handler);
      if (Array.isArray(args) && args.length === 1) resolve2(args[0]);
      else resolve2(args);
    };
    target.addEventListener(name, handler);
  });
};
if (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {
  if (typeof window === `undefined`) globalThis.requestAnimationFrame = (callback) => {
    setTimeout(callback, 1);
  };
}
var sleep = (optsOrMillis) => {
  const timeoutMs = intervalToMs(optsOrMillis, 1);
  const signal = optsOrMillis.signal;
  const value3 = optsOrMillis.value;
  resultThrow(numberTest(timeoutMs, `positive`, `timeoutMs`));
  if (timeoutMs === 0) return new Promise((resolve2) => requestAnimationFrame((_3) => {
    resolve2(value3);
  }));
  else return new Promise((resolve2, reject) => {
    const onAbortSignal = () => {
      clearTimeout(t6);
      if (signal) {
        signal.removeEventListener(`abort`, onAbortSignal);
        reject(new Error(signal.reason));
      } else reject(/* @__PURE__ */ new Error(`Cancelled`));
    };
    if (signal) signal.addEventListener(`abort`, onAbortSignal);
    const t6 = setTimeout(() => {
      signal?.removeEventListener(`abort`, onAbortSignal);
      if (signal?.aborted) {
        reject(new Error(signal.reason));
        return;
      }
      resolve2(value3);
    }, timeoutMs);
  });
};
var max = () => {
  let max$12 = Number.MIN_SAFE_INTEGER;
  const compute = (value3) => {
    const valueArray = Array.isArray(value3) ? value3 : [value3];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) break;
      max$12 = Math.max(subValue, max$12);
    }
    return max$12;
  };
  return compute;
};
var min = () => {
  let min$12 = Number.MAX_SAFE_INTEGER;
  const compute = (value3) => {
    const valueArray = Array.isArray(value3) ? value3 : [value3];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) break;
      min$12 = Math.min(subValue, min$12);
    }
    return min$12;
  };
  return compute;
};
var sum = () => {
  let t6 = 0;
  const compute = (value3) => {
    const valueArray = Array.isArray(value3) ? value3 : [value3];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) continue;
      t6 += subValue;
    }
    return t6;
  };
  return compute;
};
var average = () => {
  let total2 = 0;
  let tally$12 = 0;
  const compute = (value3) => {
    const valueArray = Array.isArray(value3) ? value3 : [value3];
    for (const subValue of valueArray) {
      if (typeof subValue !== `number`) continue;
      tally$12++;
      total2 += subValue;
    }
    return total2 / tally$12;
  };
  return compute;
};
var tally = (countArrayItems) => {
  let t6 = 0;
  const compute = (value3) => {
    if (countArrayItems) if (Array.isArray(value3)) t6 += value3.length;
    else t6++;
    else t6++;
    return t6;
  };
  return compute;
};
function rank(r5, options = {}) {
  const includeType = options.includeType;
  const emitEqualRanked = options.emitEqualRanked ?? false;
  const emitRepeatHighest = options.emitRepeatHighest ?? false;
  let best;
  return (value3) => {
    if (includeType && typeof value3 !== includeType) return;
    if (best === void 0) {
      best = value3;
      return best;
    } else {
      const result = r5(value3, best);
      if (result == `a`) {
        best = value3;
        return best;
      } else if (result === `eq` && emitEqualRanked) return best;
      else if (emitRepeatHighest) return best;
    }
  };
}

// node_modules/ixfx/bundle/src-CSkWIttj.js
var cycle = (options) => {
  throwIfFailed(arrayTest(options, `options`));
  const opts = [...options];
  let index = 0;
  const next3 = () => {
    index++;
    if (index === opts.length) index = 0;
    return value3();
  };
  const prev = () => {
    index--;
    if (index === -1) index = opts.length - 1;
    return value3();
  };
  const value3 = () => {
    return opts.at(index);
  };
  const select2 = (indexOrValue) => {
    if (typeof indexOrValue === `number`) index = indexOrValue;
    else {
      const found = opts.indexOf(indexOrValue);
      if (found === -1) throw new Error(`Could not find value`);
      index = found;
    }
  };
  const toArray5 = () => [...opts];
  return {
    toArray: toArray5,
    next: next3,
    prev,
    get current() {
      return value3();
    },
    select: select2
  };
};
var atWrap = (array$1, index) => {
  resultThrow(numberTest(index, ``, `index`));
  if (!Array.isArray(array$1)) throw new Error(`Param 'array' is not an array`);
  index = index % array$1.length;
  return array$1.at(index);
};
function chunks(array$1, size) {
  throwIfFailed(integerTest(size, "aboveZero", `size`), arrayTest(array$1, `array`));
  const output = [];
  for (let index = 0; index < array$1.length; index += size) output.push(array$1.slice(index, index + size));
  return output;
}
var toStringDefault2 = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string` ? itemToMakeStringFor : JSON.stringify(itemToMakeStringFor);
var isEqualDefault2 = (a3, b3) => a3 === b3;
var isEqualValueDefault = (a3, b3) => {
  if (a3 === b3) return true;
  return toStringDefault2(a3) === toStringDefault2(b3);
};
var contains = (haystack, needles, eq = isEqualDefault2) => {
  if (!Array.isArray(haystack)) throw new TypeError(`Expects haystack parameter to be an array`);
  if (!Array.isArray(needles)) throw new TypeError(`Expects needles parameter to be an array. Got: ${typeof needles}`);
  for (const needle of needles) {
    let found = false;
    for (const element of haystack) if (eq(needle, element)) {
      found = true;
      break;
    }
    if (!found) return false;
  }
  return true;
};
var containsDuplicateValues = (data, keyFunction = toStringDefault2) => {
  if (typeof data !== `object`) throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${typeof data}`);
  const set5 = /* @__PURE__ */ new Set();
  for (const v3 of data) {
    const string_ = keyFunction(v3);
    if (set5.has(string_)) return true;
    set5.add(string_);
  }
  return false;
};
var containsDuplicateInstances = (array$1) => {
  if (!Array.isArray(array$1)) throw new Error(`Parameter needs to be an array`);
  for (let index = 0; index < array$1.length; index++) for (let x3 = 0; x3 < array$1.length; x3++) {
    if (index === x3) continue;
    if (array$1[index] === array$1[x3]) return true;
  }
  return false;
};
function ensureLength(data, length3, expandStrategy = `undefined`, truncateStrategy = `from-end`) {
  if (data === void 0) throw new Error(`Data undefined`);
  if (!Array.isArray(data)) throw new Error(`data is not an array`);
  if (data.length === length3) return [...data];
  if (data.length > length3) if (truncateStrategy === `from-end`) return data.slice(0, length3);
  else return data.slice(data.length - length3);
  const d3 = [...data];
  const add3 = length3 - d3.length;
  for (let index = 0; index < add3; index++) switch (expandStrategy) {
    case `undefined`: {
      d3.push(void 0);
      break;
    }
    case `repeat`: {
      d3.push(data[index % data.length]);
      break;
    }
    case `first`: {
      d3.push(data[0]);
      break;
    }
    case `last`: {
      d3.push(data.at(-1));
      break;
    }
  }
  return d3;
}
var isEqual = (arrayA, arrayB, equality = isEqualDefault2) => {
  resultThrow(arrayTest(arrayA, `arrayA`), arrayTest(arrayB, `arrayB`));
  if (arrayA.length !== arrayB.length) return false;
  for (let indexA = 0; indexA < arrayA.length; indexA++) if (!equality(arrayA[indexA], arrayB[indexA])) return false;
  return true;
};
var containsIdenticalValues = (array$1, equality) => {
  if (!Array.isArray(array$1)) throw new Error(`Param 'array' is not an array.`);
  if (array$1.length === 0) return true;
  const eq = equality ?? isEqualValueDefault;
  const a3 = array$1[0];
  const r5 = array$1.some((v3) => !eq(a3, v3));
  if (r5) return false;
  return true;
};
var filterAB = (data, filter2) => {
  const a3 = [];
  const b3 = [];
  for (const datum of data) if (filter2(datum)) a3.push(datum);
  else b3.push(datum);
  return [a3, b3];
};
function* filterBetween(array$1, predicate, startIndex, endIndex) {
  resultThrow(arrayTest(array$1, `array`));
  if (typeof startIndex === `undefined`) startIndex = 0;
  if (typeof endIndex === `undefined`) endIndex = array$1.length;
  resultThrow(arrayIndexTest(array$1, startIndex, `startIndex`));
  resultThrow(arrayIndexTest(array$1, endIndex - 1, `endIndex`));
  for (let index = startIndex; index < endIndex; index++) if (predicate(array$1[index], index, array$1)) yield array$1[index];
}
var flatten = (array$1) => [...array$1].flat();
var mapWithEmptyFallback = (array$1, fn2, fallback) => {
  if (typeof array$1 !== `object` || !Array.isArray(array$1) || array$1.length === 0) {
    if (Array.isArray(fallback)) return fallback;
    return [fallback];
  }
  return array$1.map(fn2);
};
var frequencyByGroup = (groupBy$1, data) => {
  if (!Array.isArray(data)) throw new TypeError(`Param 'array' is expected to be an array. Got type: '${typeof data}'`);
  const store = /* @__PURE__ */ new Map();
  for (const value3 of data) {
    const group3 = groupBy$1(value3);
    if (typeof group3 !== `string` && typeof group3 !== `number`) throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${typeof group3}' for value: '${value3}'`);
    let groupValue = store.get(group3);
    groupValue ??= 0;
    groupValue++;
    store.set(group3, groupValue);
  }
  return store;
};
var groupBy = (array$1, grouper) => {
  const map2 = /* @__PURE__ */ new Map();
  for (const a3 of array$1) {
    const key = grouper(a3);
    let existing = map2.get(key);
    if (!existing) {
      existing = [];
      map2.set(key, existing);
    }
    existing.push(a3);
  }
  return map2;
};
var uniqueDeep = (arrays, comparer = isEqualDefault2) => {
  const t6 = [];
  const contains$1 = (v3) => {
    for (const tValue of t6) if (comparer(tValue, v3)) return true;
    return false;
  };
  const flattened = arrays.flat(10);
  for (const v3 of flattened) if (!contains$1(v3)) t6.push(v3);
  return t6;
};
var unique = (arrays, toString5 = toStringDefault2) => {
  const matching = /* @__PURE__ */ new Set();
  const t6 = [];
  const flattened = arrays.flat(10);
  for (const a3 of flattened) {
    const stringRepresentation = toString5(a3);
    if (matching.has(stringRepresentation)) continue;
    matching.add(stringRepresentation);
    t6.push(a3);
  }
  return t6;
};
var insertAt = (data, index, ...values3) => {
  throwIfFailed(arrayTest(data, `data`), arrayIndexTest(data, index, `index`));
  if (index === data.length - 1) return [...data, ...values3];
  if (index === 0) return [...values3, ...data];
  return [
    ...data.slice(0, index),
    ...values3,
    ...data.slice(index)
  ];
};
var interleave = (...arrays) => {
  if (arrays.some((a3) => !Array.isArray(a3))) throw new Error(`All parameters must be an array`);
  const lengths3 = arrays.map((a3) => a3.length);
  if (!containsIdenticalValues(lengths3)) throw new Error(`Arrays must be of same length`);
  const returnValue = [];
  const length3 = lengths3[0];
  for (let index = 0; index < length3; index++) for (const array$1 of arrays) returnValue.push(array$1[index]);
  return returnValue;
};
var intersection = (arrayA, arrayB, equality = isEqualDefault2) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));
var mergeByKey2 = (keyFunction, reconcile, ...arrays) => {
  const result = /* @__PURE__ */ new Map();
  for (const m4 of arrays) for (const mv of m4) {
    if (mv === void 0) continue;
    const mk = keyFunction(mv);
    let v3 = result.get(mk);
    v3 = v3 ? reconcile(v3, mv) : mv;
    result.set(mk, v3);
  }
  return [...result.values()];
};
function* pairwise(values3) {
  resultThrow(arrayTest(values3, `values`));
  if (values3.length < 2) throw new Error(`Array needs to have at least two entries. Length: ${values3.length}`);
  for (let index = 1; index < values3.length; index++) yield [values3[index - 1], values3[index]];
}
var pairwiseReduce = (array$1, reducer, initial) => {
  resultThrow(arrayTest(array$1, `arr`));
  if (array$1.length < 2) return initial;
  for (let index = 0; index < array$1.length - 1; index++) initial = reducer(initial, array$1[index], array$1[index + 1]);
  return initial;
};
var shuffle = (dataToShuffle, rand = Math.random) => {
  resultThrow(arrayTest(dataToShuffle, `dataToShuffle`));
  const array$1 = [...dataToShuffle];
  for (let index = array$1.length - 1; index > 0; index--) {
    const index_ = Math.floor(rand() * (index + 1));
    [array$1[index], array$1[index_]] = [array$1[index_], array$1[index]];
  }
  return array$1;
};
var randomElement = (array$1, rand = Math.random) => {
  resultThrow(arrayTest(array$1, `array`));
  return array$1[Math.floor(rand() * array$1.length)];
};
var randomIndex = (array$1, rand = Math.random) => Math.floor(rand() * array$1.length);
var remove = (data, index) => {
  if (!Array.isArray(data)) throw new TypeError(`'data' parameter should be an array`);
  resultThrow(arrayIndexTest(data, index, `index`));
  return [...data.slice(0, index), ...data.slice(index + 1)];
};
var sample = (array$1, amount) => {
  if (!Array.isArray(array$1)) throw new TypeError(`Param 'array' is not actually an array. Got type: ${typeof array$1}`);
  let subsampleSteps = 1;
  if (amount <= 1) {
    const numberOfItems = array$1.length * amount;
    subsampleSteps = Math.round(array$1.length / numberOfItems);
  } else subsampleSteps = amount;
  resultThrow(integerTest(subsampleSteps, `positive`, `amount`));
  if (subsampleSteps > array$1.length - 1) throw new Error(`Subsample steps exceeds array length`);
  const r5 = [];
  for (let index = subsampleSteps - 1; index < array$1.length; index += subsampleSteps) r5.push(array$1[index]);
  return r5;
};
var sortByNumericProperty = (data, propertyName) => [...data].sort((a3, b3) => {
  resultThrow(arrayTest(data, `data`));
  const av = a3[propertyName];
  const bv = b3[propertyName];
  if (av < bv) return -1;
  if (av > bv) return 1;
  return 0;
});
var sortByProperty = (data, propertyName, comparer) => [...data].sort((a3, b3) => {
  resultThrow(arrayTest(data, `data`));
  const av = a3[propertyName];
  const bv = b3[propertyName];
  if (comparer === void 0) {
    if (av < bv) return -1;
    if (av > bv) return 1;
    return 0;
  } else return comparer(av, bv);
});
function* until(data, predicate, initial) {
  let total$1 = initial;
  for (const datum of data) {
    const r5 = predicate(datum, total$1);
    if (typeof r5 === `boolean`) {
      if (r5) break;
    } else {
      const [stop, accumulator] = r5;
      if (stop) break;
      total$1 = accumulator;
    }
    yield datum;
  }
}
var withoutUndefined = (data) => {
  return data.filter((v3) => v3 !== void 0);
};
var without = (sourceArray, toRemove, comparer = isEqualDefault2) => {
  if (Array.isArray(toRemove)) {
    const returnArray = [];
    for (const source of sourceArray) if (!toRemove.some((v3) => comparer(source, v3))) returnArray.push(source);
    return returnArray;
  } else return sourceArray.filter((v3) => !comparer(v3, toRemove));
};
var zip = (...arrays) => {
  if (arrays.some((a3) => !Array.isArray(a3))) throw new Error(`All parameters must be an array`);
  const lengths3 = arrays.map((a3) => a3.length);
  if (!containsIdenticalValues(lengths3)) throw new Error(`Arrays must be of same length`);
  const returnValue = [];
  const length3 = lengths3[0];
  for (let index = 0; index < length3; index++) returnValue.push(arrays.map((a3) => a3[index]));
  return returnValue;
};
var src_exports$1 = {};
__export(src_exports$1, {
  atWrap: () => atWrap,
  chunks: () => chunks,
  contains: () => contains,
  containsDuplicateInstances: () => containsDuplicateInstances,
  containsDuplicateValues: () => containsDuplicateValues,
  containsIdenticalValues: () => containsIdenticalValues,
  cycle: () => cycle,
  ensureLength: () => ensureLength,
  filterAB: () => filterAB,
  filterBetween: () => filterBetween,
  flatten: () => flatten,
  frequencyByGroup: () => frequencyByGroup,
  groupBy: () => groupBy,
  insertAt: () => insertAt,
  interleave: () => interleave,
  intersection: () => intersection,
  isEqual: () => isEqual,
  mapWithEmptyFallback: () => mapWithEmptyFallback,
  mergeByKey: () => mergeByKey2,
  pairwise: () => pairwise,
  pairwiseReduce: () => pairwiseReduce,
  randomElement: () => randomElement,
  randomIndex: () => randomIndex,
  remove: () => remove,
  sample: () => sample,
  shuffle: () => shuffle,
  sortByNumericProperty: () => sortByNumericProperty,
  sortByProperty: () => sortByProperty,
  unique: () => unique,
  uniqueDeep: () => uniqueDeep,
  until: () => until,
  without: () => without,
  withoutUndefined: () => withoutUndefined,
  zip: () => zip
});
var applyToValues = (object, apply3) => {
  const o5 = { ...object };
  for (const [key, value3] of Object.entries(object)) if (typeof value3 === `number`) o5[key] = apply3(value3);
  else o5[key] = value3;
  return o5;
};
var weight = (data, fn2) => {
  if (!Array.isArray(data)) throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof data}`);
  const weightingFunction = fn2 ?? ((x3) => x3);
  return data.map((value3, index) => {
    if (typeof value3 !== `number`) throw new TypeError(`Param 'data' contains non-number at index: '${index}'. Type: '${typeof value3}' value: '${value3}'`);
    const relativePos = index / (data.length - 1);
    const weightForPosition = weightingFunction(relativePos);
    if (typeof weightForPosition !== `number`) throw new TypeError(`Weighting function returned type '${typeof weightForPosition}' rather than number for input: '${relativePos}'`);
    const finalResult = value3 * weightForPosition;
    return finalResult;
  });
};
var validNumbers = (data) => data.filter((d3) => typeof d3 === `number` && !Number.isNaN(d3));
var dotProduct = (values3) => {
  let r5 = 0;
  const length3 = values3[0].length;
  for (let index = 0; index < length3; index++) {
    let t6 = 0;
    for (const [p3, value3] of values3.entries()) if (p3 === 0) t6 = value3[index];
    else t6 *= value3[index];
    r5 += t6;
  }
  return r5;
};
var average2 = (data) => {
  if (data === void 0) throw new Error(`data parameter is undefined`);
  const valid = validNumbers(data);
  const total$1 = valid.reduce((accumulator, v3) => accumulator + v3, 0);
  return total$1 / valid.length;
};
var min2 = (data) => Math.min(...validNumbers(data));
var maxIndex = (data) => data.reduce((bestIndex, value3, index, array$1) => value3 > array$1[bestIndex] ? index : bestIndex, 0);
var minIndex = (...data) => data.reduce((bestIndex, value3, index, array$1) => value3 < array$1[bestIndex] ? index : bestIndex, 0);
var max2 = (data) => Math.max(...validNumbers(data));
var total = (data) => data.reduce((previous, current) => {
  if (typeof current !== `number`) return previous;
  if (Number.isNaN(current)) return previous;
  if (!Number.isFinite(current)) return previous;
  return previous + current;
}, 0);
var maxFast = (data) => {
  let m4 = Number.MIN_SAFE_INTEGER;
  for (const datum of data) m4 = Math.max(m4, datum);
  return m4;
};
var totalFast = (data) => {
  let m4 = 0;
  for (const datum of data) m4 += datum;
  return m4;
};
var minFast = (data) => {
  let m4 = Number.MIN_SAFE_INTEGER;
  for (const datum of data) m4 = Math.min(m4, datum);
  return m4;
};
var averageWeighted = (data, weightings) => {
  if (typeof weightings === `function`) weightings = weight(data, weightings);
  const ww = zip(data, weightings);
  const [totalV, totalW] = ww.reduce((accumulator, v3) => [accumulator[0] + v3[0] * v3[1], accumulator[1] + v3[1]], [0, 0]);
  return totalV / totalW;
};
var clamp = (value3, min$12 = 0, max$12 = 1) => {
  if (Number.isNaN(value3)) throw new Error(`Param 'value' is NaN`);
  if (Number.isNaN(min$12)) throw new Error(`Param 'min' is NaN`);
  if (Number.isNaN(max$12)) throw new Error(`Param 'max' is NaN`);
  if (value3 < min$12) return min$12;
  if (value3 > max$12) return max$12;
  return value3;
};
var clamper = (min$12 = 0, max$12 = 1) => {
  if (Number.isNaN(min$12)) throw new Error(`Param 'min' is NaN`);
  if (Number.isNaN(max$12)) throw new Error(`Param 'max' is NaN`);
  return (v3) => {
    if (v3 > max$12) return max$12;
    if (v3 < min$12) return min$12;
    return v3;
  };
};
var clampIndex = (v3, arrayOrLength) => {
  if (!Number.isInteger(v3)) throw new TypeError(`v parameter must be an integer (${v3})`);
  const length3 = Array.isArray(arrayOrLength) ? arrayOrLength.length : arrayOrLength;
  if (!Number.isInteger(length3)) throw new TypeError(`length parameter must be an integer (${length3}, ${typeof length3})`);
  v3 = Math.round(v3);
  if (v3 < 0) return 0;
  if (v3 >= length3) return length3 - 1;
  return v3;
};
var maxAbs = (...values3) => {
  let index = -1;
  let maxA = Number.MIN_SAFE_INTEGER;
  for (let index_ = 0; index_ < values3.length; index_++) {
    const vA = Math.abs(values3[index_]);
    if (vA > maxA) {
      maxA = vA;
      index = index_;
    }
  }
  return values3[index];
};
function* count(amount, offset3 = 0) {
  resultThrow(integerTest(amount, ``, `amount`), integerTest(offset3, ``, `offset`));
  if (amount === 0) return;
  let index = 0;
  do
    yield amount < 0 ? -index + offset3 : index + offset3;
  while (index++ < Math.abs(amount) - 1);
}
var differenceFromFixed = (initial, kind = `absolute`) => (value3) => differenceFrom(kind, value3, initial);
var differenceFromLast = (kind = `absolute`, initialValue = NaN) => {
  let lastValue = initialValue;
  return (value3) => {
    const x3 = differenceFrom(kind, value3, lastValue);
    lastValue = value3;
    return x3;
  };
};
var differenceFrom = (kind = `absolute`, value3, from3) => {
  if (Number.isNaN(from3)) return 0;
  const d3 = value3 - from3;
  let r5 = 0;
  if (kind === `absolute`) r5 = Math.abs(d3);
  else if (kind === `numerical`) r5 = d3;
  else if (kind === `relative`) r5 = Math.abs(d3 / from3);
  else if (kind === `relativeSigned`) r5 = d3 / from3;
  else throw new TypeError(`Unknown kind: '${kind}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);
  return r5;
};
var isValid = (possibleNumber) => {
  if (typeof possibleNumber !== `number`) return false;
  if (Number.isNaN(possibleNumber)) return false;
  return true;
};
function* filterIterable(it2) {
  for (const v3 of it2) if (isValid(v3)) yield v3;
}
var thresholdAtLeast = (threshold) => {
  return (v3) => {
    return v3 >= threshold;
  };
};
var rangeInclusive = (min$12, max$12) => {
  return (v3) => {
    return v3 >= min$12 && v3 <= max$12;
  };
};
var flip = (v3) => {
  if (typeof v3 === `function`) v3 = v3();
  resultThrow(numberTest(v3, `percentage`, `v`));
  return 1 - v3;
};
var numericRangeRaw = function* (interval2, start = 0, end, repeating = false) {
  if (interval2 <= 0) throw new Error(`Interval is expected to be above zero`);
  if (typeof end === `undefined`) end = Number.MAX_SAFE_INTEGER;
  let v3 = start;
  do
    while (v3 < end) {
      yield v3;
      v3 += interval2;
    }
  while (repeating);
};
var numericRange = function* (interval2, start = 0, end, repeating = false, rounding) {
  resultThrow(numberTest(interval2, `nonZero`));
  const negativeInterval = interval2 < 0;
  if (end === void 0) {
  } else {
    if (negativeInterval && start < end) throw new Error(`Interval of ${interval2.toString()} will never go from ${start.toString()} to ${end.toString()}`);
    if (!negativeInterval && start > end) throw new Error(`Interval of ${interval2.toString()} will never go from ${start.toString()} to ${end.toString()}`);
  }
  rounding = rounding ?? 1e3;
  if (end === void 0) end = Number.MAX_SAFE_INTEGER;
  else end *= rounding;
  interval2 = interval2 * rounding;
  do {
    let v3 = start * rounding;
    while (!negativeInterval && v3 <= end || negativeInterval && v3 >= end) {
      yield v3 / rounding;
      v3 += interval2;
    }
  } while (repeating);
};
var numericPercent = function(interval2 = 0.01, repeating = false, start = 0, end = 1) {
  resultThrow(numberTest(interval2, `percentage`, `interval`), numberTest(start, `percentage`, `start`), numberTest(end, `percentage`, `end`));
  return numericRange(interval2, start, end, repeating);
};
function round2(a3, b3, roundUp) {
  resultThrow(integerTest(a3, `positive`, `decimalPlaces`));
  const up = typeof b3 === `boolean` ? b3 : roundUp ?? false;
  let rounder;
  if (a3 === 0) rounder = Math.round;
  else {
    const p3 = Math.pow(10, a3);
    if (up) rounder = (v3) => Math.ceil(v3 * p3) / p3;
    else rounder = (v3) => Math.floor(v3 * p3) / p3;
  }
  if (typeof b3 === `number`) return rounder(b3);
  return rounder;
}
function isApprox(rangePercent, baseValue, v3) {
  resultThrow(numberTest(rangePercent, `percentage`, `rangePercent`));
  const range = Math.floor(rangePercent * 100);
  const test3 = (base, value3) => {
    try {
      if (typeof value3 !== `number`) return false;
      if (Number.isNaN(value3)) return false;
      if (!Number.isFinite(value3)) return false;
      const diff = Math.abs(value3 - base);
      const relative2 = base === 0 ? Math.floor(diff * 100) : Math.floor(diff / base * 100);
      return relative2 <= range;
    } catch {
      return false;
    }
  };
  if (baseValue === void 0) return test3;
  resultThrow(numberTest(baseValue, ``, `baseValue`));
  if (v3 === void 0) return (value3) => test3(baseValue, value3);
  else return test3(baseValue, v3);
}
var isCloseToAny = (allowedRangeAbsolute, ...targets) => {
  const targetsMin = targets.map((t6) => t6 - allowedRangeAbsolute);
  const targetsMax = targets.map((t6) => t6 + allowedRangeAbsolute);
  return (...values3) => {
    for (const v3 of values3) for (let index = 0; index < targets.length; index++) if (v3 >= targetsMin[index] && v3 <= targetsMax[index]) return true;
    return false;
  };
};
var bipolar_exports = {};
__export(bipolar_exports, {
  clamp: () => clamp$1,
  fromScalar: () => fromScalar,
  immutable: () => immutable,
  scale: () => scale$1,
  scaleUnclamped: () => scaleUnclamped,
  toScalar: () => toScalar,
  towardZero: () => towardZero
});
var immutable = (startingValueOrBipolar = 0) => {
  if (typeof startingValueOrBipolar === `undefined`) throw new Error(`Start value is undefined`);
  const startingValue = typeof startingValueOrBipolar === `number` ? startingValueOrBipolar : startingValueOrBipolar.value;
  if (startingValue > 1) throw new Error(`Start value cannot be larger than 1`);
  if (startingValue < -1) throw new Error(`Start value cannot be smaller than -1`);
  if (Number.isNaN(startingValue)) throw new Error(`Start value is NaN`);
  const v3 = startingValue;
  return {
    [Symbol.toPrimitive](hint) {
      if (hint === `number`) return v3;
      else if (hint === `string`) return v3.toString();
      return true;
    },
    value: v3,
    towardZero: (amt) => {
      return immutable(towardZero(v3, amt));
    },
    add: (amt) => {
      return immutable(clamp$1(v3 + amt));
    },
    multiply: (amt) => {
      return immutable(clamp$1(v3 * amt));
    },
    inverse: () => {
      return immutable(-v3);
    },
    interpolate: (amt, b3) => {
      return immutable(clamp$1(interpolate(amt, v3, b3)));
    },
    asScalar: (max$12 = 1, min$12 = 0) => {
      return toScalar(v3, max$12, min$12);
    }
  };
};
var toScalar = (bipolarValue, max$12 = 1, min$12 = 0) => {
  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${typeof bipolarValue}`);
  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);
  return scale(bipolarValue, -1, 1, min$12, max$12);
};
var fromScalar = (scalarValue) => {
  resultThrow(numberTest(scalarValue, `percentage`, `v`));
  return scalarValue * 2 - 1;
};
var scale$1 = (inputValue, inMin, inMax) => {
  return clamp$1(scaler(inMin, inMax, -1, 1)(inputValue));
};
var scaleUnclamped = (inputValue, inMin, inMax) => {
  return scaler(inMin, inMax, -1, 1)(inputValue);
};
var clamp$1 = (bipolarValue) => {
  if (typeof bipolarValue !== `number`) throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof bipolarValue}`);
  if (Number.isNaN(bipolarValue)) throw new Error(`Param 'bipolarValue' is NaN`);
  if (bipolarValue > 1) return 1;
  if (bipolarValue < -1) return -1;
  return bipolarValue;
};
var towardZero = (bipolarValue, amount) => {
  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${typeof bipolarValue}`);
  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${typeof amount}`);
  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);
  if (bipolarValue < 0) {
    bipolarValue += amount;
    if (bipolarValue > 0) bipolarValue = 0;
  } else if (bipolarValue > 0) {
    bipolarValue -= amount;
    if (bipolarValue < 0) bipolarValue = 0;
  }
  return bipolarValue;
};
var wrapInteger = (v3, min$12 = 0, max$12 = 360) => {
  resultThrow(integerTest(v3, void 0, `v`), integerTest(min$12, void 0, `min`), integerTest(max$12, void 0, `max`));
  if (v3 === min$12) return min$12;
  if (v3 === max$12) return min$12;
  if (v3 > 0 && v3 < min$12) v3 += min$12;
  v3 -= min$12;
  max$12 -= min$12;
  v3 = v3 % max$12;
  if (v3 < 0) v3 = max$12 - Math.abs(v3) + min$12;
  return v3 + min$12;
};
var wrap2 = (v3, min$12 = 0, max$12 = 1) => {
  resultThrow(numberTest(v3, ``, `min`), numberTest(min$12, ``, `min`), numberTest(max$12, ``, `max`));
  if (v3 === min$12) return min$12;
  if (v3 === max$12) return min$12;
  while (v3 <= min$12 || v3 >= max$12) {
    if (v3 === max$12) break;
    if (v3 === min$12) break;
    if (v3 > max$12) v3 = min$12 + (v3 - max$12);
    else if (v3 < min$12) v3 = max$12 - (min$12 - v3);
  }
  return v3;
};
var wrapRange = (min$12, max$12, fn2, a3, b3) => {
  let r5 = 0;
  const distF = Math.abs(b3 - a3);
  const distFwrap = Math.abs(max$12 - a3 + b3);
  const distBWrap = Math.abs(a3 + (360 - b3));
  const distMin = Math.min(distF, distFwrap, distBWrap);
  if (distMin === distBWrap) r5 = a3 - fn2(distMin);
  else if (distMin === distFwrap) r5 = a3 + fn2(distMin);
  else if (a3 > b3) r5 = a3 - fn2(distMin);
  else r5 = a3 + fn2(distMin);
  return wrapInteger(r5, min$12, max$12);
};
var piPi = Math.PI * 2;
function interpolate(pos1, pos2, pos3, pos4) {
  let amountProcess;
  let limits = `clamp`;
  const handleAmount = (amount) => {
    if (amountProcess) amount = amountProcess(amount);
    if (limits === void 0 || limits === `clamp`) amount = clamp(amount);
    else if (limits === `wrap`) {
      if (amount > 1) amount = amount % 1;
      else if (amount < 0) amount = 1 + amount % 1;
    }
    return amount;
  };
  const doTheEase = (_amt, _a2, _b) => {
    resultThrow(numberTest(_a2, ``, `a`), numberTest(_b, ``, `b`), numberTest(_amt, ``, `amount`));
    _amt = handleAmount(_amt);
    return (1 - _amt) * _a2 + _amt * _b;
  };
  const readOpts = (o5 = {}) => {
    if (o5.transform) {
      if (typeof o5.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o5.transform}`);
      amountProcess = o5.transform;
    }
    limits = o5.limits ?? `clamp`;
  };
  const rawEase = (_amt, _a2, _b) => (1 - _amt) * _a2 + _amt * _b;
  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);
  if (typeof pos2 === `number`) {
    let a3;
    let b3;
    if (pos3 === void 0 || typeof pos3 === `object`) {
      a3 = pos1;
      b3 = pos2;
      readOpts(pos3);
      return (amount) => doTheEase(amount, a3, b3);
    } else if (typeof pos3 === `number`) {
      a3 = pos2;
      b3 = pos3;
      readOpts(pos4);
      return doTheEase(pos1, a3, b3);
    } else throw new Error(`Values for 'a' and 'b' not defined`);
  } else if (pos2 === void 0 || typeof pos2 === `object`) {
    const amount = handleAmount(pos1);
    readOpts(pos2);
    resultThrow(numberTest(amount, ``, `amount`));
    return (aValue, bValue) => rawEase(amount, aValue, bValue);
  }
}
var interpolatorStepped = (incrementAmount, a3 = 0, b3 = 1, startInterpolationAt = 0, options) => {
  let amount = startInterpolationAt;
  return (retargetB, retargetA) => {
    if (retargetB !== void 0) b3 = retargetB;
    if (retargetA !== void 0) a3 = retargetA;
    if (amount >= 1) return b3;
    const value3 = interpolate(amount, a3, b3, options);
    amount += incrementAmount;
    return value3;
  };
};
var interpolateAngle = (amount, aRadians, bRadians, options) => {
  const t6 = wrap2(bRadians - aRadians, 0, piPi);
  return interpolate(amount, aRadians, aRadians + (t6 > Math.PI ? t6 - piPi : t6), options);
};
function* linearSpace(start, end, steps, precision) {
  resultThrow(numberTest(start, ``, `start`), numberTest(end, ``, `end`), numberTest(steps, ``, `steps`));
  const r5 = precision ? round2(precision) : (v3) => v3;
  const step = (end - start) / (steps - 1);
  resultThrow(numberTest(step, ``, `step`));
  if (!Number.isFinite(step)) throw new TypeError(`Calculated step value is infinite`);
  for (let index = 0; index < steps; index++) {
    const v3 = start + step * index;
    yield r5(v3);
  }
}
var BasicQueueMutable = class {
  #store = [];
  enqueue(data) {
    this.#store.push(data);
  }
  dequeue() {
    return this.#store.shift();
  }
  get data() {
    return this.#store;
  }
  get size() {
    return this.#store.length;
  }
};
var PiPi2 = Math.PI * 2;
var movingAverageLight = (scaling = 3) => {
  resultThrow(numberTest(scaling, `aboveZero`, `scaling`));
  let average$12 = 0;
  let count$1 = 0;
  return (v3) => {
    const r5 = numberTest(v3, ``, `v`);
    if (r5.success && v3 !== void 0) {
      count$1++;
      average$12 = average$12 + (v3 - average$12) / Math.min(count$1, scaling);
    }
    return average$12;
  };
};
var movingAverage = (samples = 100, weighter) => {
  const q3 = new BasicQueueMutable();
  return (v3) => {
    const r5 = numberTest(v3);
    if (r5.success && v3 !== void 0) {
      q3.enqueue(v3);
      while (q3.size > samples) q3.dequeue();
    }
    return weighter === void 0 ? average2(q3.data) : averageWeighted(q3.data, weighter);
  };
};
var smoothingFactor = (timeDelta, cutoff) => {
  const r5 = PiPi2 * cutoff * timeDelta;
  return r5 / (r5 + 1);
};
var exponentialSmoothing = (smoothingFactor$1, value3, previous) => {
  return smoothingFactor$1 * value3 + (1 - smoothingFactor$1) * previous;
};
var noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {
  let previousValue = 0;
  let derivativeLast = 0;
  let timestampLast = 0;
  const compute = (value3, timestamp2) => {
    timestamp2 ??= performance.now();
    const timeDelta = timestamp2 - timestampLast;
    const s3 = smoothingFactor(timeDelta, cutoffDefault);
    const valueDelta = (value3 - previousValue) / timeDelta;
    const derivative = exponentialSmoothing(s3, valueDelta, derivativeLast);
    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);
    const a3 = smoothingFactor(timeDelta, cutoff);
    const smoothed = exponentialSmoothing(a3, value3, previousValue);
    previousValue = smoothed;
    derivativeLast = derivative;
    timestampLast = timestamp2;
    return smoothed;
  };
  return compute;
};
var scale = (v3, inMin, inMax, outMin, outMax, easing) => scaler(inMin, inMax, outMin, outMax, easing)(v3);
var scaler = (inMin, inMax, outMin, outMax, easing, clamped) => {
  resultThrow(numberTest(inMin, `finite`, `inMin`), numberTest(inMax, `finite`, `inMax`));
  const oMax = outMax ?? 1;
  const oMin = outMin ?? 0;
  const clampFunction = clamped ? clamper(outMin, outMax) : void 0;
  return (v3) => {
    if (inMin === inMax) return oMax;
    let a3 = (v3 - inMin) / (inMax - inMin);
    if (easing !== void 0) a3 = easing(a3);
    const x3 = a3 * (oMax - oMin) + oMin;
    if (clampFunction) return clampFunction(x3);
    return x3;
  };
};
var scalerNull = () => (v3) => v3;
var scaleClamped = (v3, inMin, inMax, outMin, outMax, easing) => {
  if (typeof outMax === `undefined`) outMax = 1;
  if (typeof outMin === `undefined`) outMin = 0;
  if (inMin === inMax) return outMax;
  const x3 = scale(v3, inMin, inMax, outMin, outMax, easing);
  return clamp(x3, outMin, outMax);
};
var scalePercentages = (percentage, outMin, outMax = 1) => {
  resultThrow(numberTest(percentage, `percentage`, `v`), numberTest(outMin, `percentage`, `outMin`), numberTest(outMax, `percentage`, `outMax`));
  return scale(percentage, 0, 1, outMin, outMax);
};
var scalePercent = (v3, outMin, outMax) => scalerPercent(outMin, outMax)(v3);
var scalerPercent = (outMin, outMax) => {
  return (v3) => {
    resultThrow(numberTest(v3, `percentage`, `v`));
    return scale(v3, 0, 1, outMin, outMax);
  };
};
var scalerTwoWay = (inMin, inMax, outMin = 0, outMax = 1, clamped = false, easing) => {
  const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);
  const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);
  return {
    out: toOut,
    in: toIn
  };
};
var numberArrayCompute = (data, opts = {}) => {
  if (data.length === 0) return {
    total: NaN,
    min: NaN,
    max: NaN,
    avg: NaN,
    count: NaN
  };
  const nonNumbers = opts.nonNumbers ?? `throw`;
  let total$1 = 0;
  let min$12 = Number.MAX_SAFE_INTEGER;
  let max$12 = Number.MIN_SAFE_INTEGER;
  let count$1 = 0;
  for (let index = 0; index < data.length; index++) {
    let value3 = data[index];
    if (typeof value3 !== `number`) {
      if (nonNumbers === `ignore`) continue;
      if (nonNumbers === `throw`) throw new Error(`Param 'data' contains a non-number at index: ${index.toString()}`);
      if (nonNumbers === `nan`) value3 = NaN;
    }
    if (Number.isNaN(value3)) continue;
    if (value3 !== void 0) {
      min$12 = Math.min(min$12, value3);
      max$12 = Math.max(max$12, value3);
      total$1 += value3;
      count$1++;
    }
  }
  return {
    total: total$1,
    max: max$12,
    min: min$12,
    count: count$1,
    avg: total$1 / count$1
  };
};
var normalise_exports = {};
__export(normalise_exports, {
  array: () => array,
  arrayWithContext: () => arrayWithContext,
  stream: () => stream,
  streamWithContext: () => streamWithContext
});
var streamWithContext = (minDefault, maxDefault) => {
  let min$12 = minDefault ?? Number.MAX_SAFE_INTEGER;
  let max$12 = maxDefault ?? Number.MIN_SAFE_INTEGER;
  resultThrow(numberTest(min$12), numberTest(max$12));
  return {
    seen: (v3) => {
      resultThrow(numberTest(v3));
      min$12 = Math.min(min$12, v3);
      max$12 = Math.max(max$12, v3);
      return scale(v3, min$12, max$12);
    },
    reset: (minDefault$1, maxDefault$1) => {
      min$12 = minDefault$1 ?? Number.MAX_SAFE_INTEGER;
      max$12 = maxDefault$1 ?? Number.MIN_SAFE_INTEGER;
    },
    get min() {
      return min$12;
    },
    get max() {
      return max$12;
    },
    get range() {
      return Math.abs(max$12 - min$12);
    }
  };
};
var stream = (minDefault, maxDefault) => {
  const c5 = streamWithContext(minDefault, maxDefault);
  return c5.seen;
};
var arrayWithContext = (values3, minForced, maxForced) => {
  if (!Array.isArray(values3)) throw new TypeError(`Param 'values' should be an array. Got: ${typeof values3}`);
  const mma = numberArrayCompute(values3);
  const min$12 = minForced ?? mma.min;
  const max$12 = maxForced ?? mma.max;
  return {
    values: values3.map((v3) => clamp(scale(v3, min$12, max$12))),
    original: values3,
    min: min$12,
    max: max$12,
    range: Math.abs(max$12 - min$12)
  };
};
var array = (values3, minForced, maxForced) => {
  const c5 = arrayWithContext(values3, minForced, maxForced);
  return c5.values;
};
var proportion = (v3, t6) => {
  if (typeof v3 === `function`) v3 = v3();
  if (typeof t6 === `function`) t6 = t6();
  resultThrow(numberTest(v3, `percentage`, `v`), numberTest(t6, `percentage`, `t`));
  return v3 * t6;
};
var quantiseEvery = (v3, every2, middleRoundsUp = true) => {
  const everyString = every2.toString();
  const decimal = everyString.indexOf(`.`);
  let multiplier = 1;
  if (decimal >= 0) {
    const d3 = everyString.substring(decimal + 1).length;
    multiplier = 10 * d3;
    every2 = Math.floor(multiplier * every2);
    v3 = v3 * multiplier;
  }
  resultThrow(numberTest(v3, ``, `v`), integerTest(every2, ``, `every`));
  let div = v3 / every2;
  const divModule = div % 1;
  div = Math.floor(div);
  if (divModule === 0.5 && middleRoundsUp || divModule > 0.5) div++;
  const vv = every2 * div / multiplier;
  return vv;
};
function rangeMergeValue(value3, previous, nonNumberHandling = `skip`) {
  if (typeof value3 === `number`) {
    if (Number.isNaN(value3) || !Number.isFinite(value3)) {
      if (nonNumberHandling === `error`) throw new TypeError(`Param 'value' is NaN or infinite, and nonNumberHandling is set to 'error'`);
      return previous;
    }
    if (value3 >= previous.min && value3 <= previous.max) return previous;
    return {
      min: Math.min(value3, previous.min),
      max: Math.max(value3, previous.max)
    };
  } else if (nonNumberHandling === `error`) throw new TypeError(`Param 'value' is not a number (type: '${typeof value3}') and nonNumberHandling is set to 'error'`);
  return previous;
}
function rangeScaler(range, outMax = 1, outMin = 0, easing, clamped = true) {
  return scaler(range.min, range.max, outMin, outMax, easing, clamped);
}
function rangeMergeRange(newRange, existingRange) {
  if (newRange.max <= existingRange.max && newRange.min >= existingRange.min) return existingRange;
  return {
    min: Math.min(newRange.min, existingRange.min),
    max: Math.max(newRange.max, existingRange.max)
  };
}
var rangeInit = () => ({
  min: Number.MAX_SAFE_INTEGER,
  max: Number.MIN_SAFE_INTEGER
});
var rangeIsEqual = (a3, b3) => {
  if (typeof a3 === `undefined`) return false;
  if (typeof b3 === `undefined`) return false;
  return a3.max === b3.max && a3.min === b3.min;
};
var rangeIsWithin = (a3, b3) => {
  if (typeof a3 === `undefined`) return false;
  if (typeof b3 === `undefined`) return false;
  if (a3.min >= b3.min && a3.max <= b3.max) return true;
  return false;
};
var rangeStream = (initWith = rangeInit()) => {
  let { min: min$12, max: max$12 } = initWith;
  const seen = (v3) => {
    if (typeof v3 === `number`) {
      if (!Number.isNaN(v3) && Number.isFinite(v3)) {
        min$12 = Math.min(min$12, v3);
        max$12 = Math.max(max$12, v3);
      }
    }
    return {
      min: min$12,
      max: max$12
    };
  };
  const reset2 = () => {
    min$12 = Number.MAX_SAFE_INTEGER;
    max$12 = Number.MIN_SAFE_INTEGER;
  };
  return {
    seen,
    reset: reset2,
    get range() {
      return {
        min: min$12,
        max: max$12
      };
    },
    get min() {
      return min$12;
    },
    get max() {
      return max$12;
    }
  };
};
function rangeCompute(values3, nonNumberHandling = `skip`) {
  let min$12 = Number.MAX_SAFE_INTEGER;
  let max$12 = Number.MIN_SAFE_INTEGER;
  let position = 0;
  for (const v3 of values3) {
    if (typeof v3 === `number`) {
      if (Number.isNaN(v3) || !Number.isFinite(v3)) {
        if (nonNumberHandling === `error`) throw new Error(`Value NaN or infinite at position: ${position}`);
        continue;
      }
    } else {
      if (nonNumberHandling === `error`) throw new Error(`Contains non number value. Type: '${typeof v3}' Position: ${position}`);
      continue;
    }
    if (v3 < min$12) min$12 = v3;
    if (v3 > max$12) max$12 = v3;
    position++;
  }
  return {
    min: min$12,
    max: max$12
  };
}
var softmax = (logits) => {
  const maxLogit = logits.reduce((a3, b3) => Math.max(a3, b3), Number.NEGATIVE_INFINITY);
  const scores = logits.map((l3) => Math.exp(l3 - maxLogit));
  const denom = scores.reduce((a3, b3) => a3 + b3);
  return scores.map((s3) => s3 / denom);
};
var trackSimple = () => {
  let count$1 = 0;
  let min$12 = Number.MAX_SAFE_INTEGER;
  let max$12 = Number.MIN_SAFE_INTEGER;
  let total$1 = 0;
  const seen = (v3) => {
    min$12 = Math.min(v3, min$12);
    max$12 = Math.max(v3, max$12);
    total$1 += v3;
    count$1++;
  };
  const reset2 = () => {
    count$1 = 0;
    min$12 = Number.MAX_SAFE_INTEGER;
    max$12 = Number.MIN_SAFE_INTEGER;
    total$1 = 0;
  };
  const rangeToString = (digits = 2) => {
    return `${min$12.toFixed(2)} - ${max$12.toFixed(2)}`;
  };
  return {
    seen,
    reset: reset2,
    rangeToString,
    get avg() {
      return total$1 / count$1;
    },
    get min() {
      return min$12;
    },
    get max() {
      return max$12;
    },
    get total() {
      return total$1;
    },
    get count() {
      return count$1;
    }
  };
};
var src_exports2 = {};
__export(src_exports2, {
  Bipolar: () => bipolar_exports,
  Normalise: () => normalise_exports,
  applyToValues: () => applyToValues,
  average: () => average2,
  averageWeighted: () => averageWeighted,
  clamp: () => clamp,
  clampIndex: () => clampIndex,
  clamper: () => clamper,
  count: () => count,
  differenceFromFixed: () => differenceFromFixed,
  differenceFromLast: () => differenceFromLast,
  dotProduct: () => dotProduct,
  filterIterable: () => filterIterable,
  flip: () => flip,
  interpolate: () => interpolate,
  interpolateAngle: () => interpolateAngle,
  interpolatorStepped: () => interpolatorStepped,
  isApprox: () => isApprox,
  isCloseToAny: () => isCloseToAny,
  isValid: () => isValid,
  linearSpace: () => linearSpace,
  max: () => max2,
  maxAbs: () => maxAbs,
  maxFast: () => maxFast,
  maxIndex: () => maxIndex,
  min: () => min2,
  minFast: () => minFast,
  minIndex: () => minIndex,
  movingAverage: () => movingAverage,
  movingAverageLight: () => movingAverageLight,
  noiseFilter: () => noiseFilter,
  numberArrayCompute: () => numberArrayCompute,
  numericPercent: () => numericPercent,
  numericRange: () => numericRange,
  numericRangeRaw: () => numericRangeRaw,
  proportion: () => proportion,
  quantiseEvery: () => quantiseEvery,
  rangeCompute: () => rangeCompute,
  rangeInclusive: () => rangeInclusive,
  rangeInit: () => rangeInit,
  rangeIsEqual: () => rangeIsEqual,
  rangeIsWithin: () => rangeIsWithin,
  rangeMergeRange: () => rangeMergeRange,
  rangeMergeValue: () => rangeMergeValue,
  rangeScaler: () => rangeScaler,
  rangeStream: () => rangeStream,
  round: () => round2,
  scale: () => scale,
  scaleClamped: () => scaleClamped,
  scalePercent: () => scalePercent,
  scalePercentages: () => scalePercentages,
  scaler: () => scaler,
  scalerNull: () => scalerNull,
  scalerPercent: () => scalerPercent,
  scalerTwoWay: () => scalerTwoWay,
  softmax: () => softmax,
  thresholdAtLeast: () => thresholdAtLeast,
  total: () => total,
  totalFast: () => totalFast,
  trackSimple: () => trackSimple,
  validNumbers: () => validNumbers,
  weight: () => weight,
  wrap: () => wrap2,
  wrapInteger: () => wrapInteger,
  wrapRange: () => wrapRange
});

// node_modules/ixfx/bundle/src-BC3BytBO.js
var defaultKeyer = (a3) => {
  return typeof a3 === `string` ? a3 : JSON.stringify(a3);
};
var abbreviate = (source, maxLength = 15) => {
  resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));
  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);
  if (source.length > maxLength && source.length > 3) {
    if (maxLength > 15) {
      const chunk$1 = Math.round((maxLength - 2) / 2);
      return source.slice(0, chunk$1) + `...` + source.slice(-chunk$1);
    }
    return source.slice(0, maxLength) + `...`;
  }
  return source;
};
var toStringAbbreviate = (source, maxLength = 20) => {
  if (source === void 0) return `(undefined)`;
  if (source === null) return `(null)`;
  return abbreviate(JSON.stringify(source), maxLength);
};
var afterMatch = (source, match, options = {}) => {
  const ba2 = beforeAfterMatch(source, match, options);
  return ba2[1];
};
var beforeAfterMatch = (source, match, options = {}) => {
  if (source === void 0) throw new Error(`Param 'source' is undefined`);
  let fallback = options.fallback;
  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);
  if (ifNoMatch === `original`) fallback = source;
  if (ifNoMatch === `fallback` && fallback === void 0) throw new Error(`Fallback must be provided`);
  const startPos = options.startPos ?? void 0;
  const fromEnd = options.fromEnd ?? false;
  const m4 = fromEnd ? source.lastIndexOf(match, startPos) : source.indexOf(match, startPos);
  if (m4 < 0 && ifNoMatch === `throw`) throw new Error(`Match '${match}' not found in source.`);
  if (m4 < 0 && ifNoMatch === `original`) return [source, source];
  if (m4 < 0 && ifNoMatch === `fallback`) return [fallback, fallback];
  return [source.slice(0, m4), source.slice(Math.max(0, m4 + match.length))];
};
var isAsyncIterable = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (v3 === null) return false;
  return Symbol.asyncIterator in v3;
};
var isIterable = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (v3 === null) return false;
  return Symbol.iterator in v3;
};
function* slice$2(it2, start = 0, end = Number.POSITIVE_INFINITY) {
  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);
  if (start < 0) throw new Error(`Param 'start' should be at least 0`);
  let index = 0;
  for (const v3 of it2) {
    if (index < start) {
      index++;
      continue;
    }
    if (index > end) break;
    yield v3;
    index++;
  }
}
function reduce$3(it2, f5, start) {
  for (const v3 of it2) start = f5(start, v3);
  return start;
}
var sync_exports = {};
__export(sync_exports, {
  asCallback: () => asCallback$3,
  chunks: () => chunks$2,
  chunksOverlapping: () => chunksOverlapping,
  concat: () => concat$2,
  dropWhile: () => dropWhile$2,
  equals: () => equals$2,
  every: () => every$2,
  fill: () => fill$2,
  filter: () => filter$3,
  find: () => find$2,
  first: () => first,
  flatten: () => flatten$2,
  forEach: () => forEach$2,
  fromArray: () => fromArray$2,
  fromIterable: () => fromIterable$2,
  last: () => last$2,
  map: () => map$2,
  max: () => max$4,
  min: () => min$4,
  next: () => next,
  reduce: () => reduce$3,
  repeat: () => repeat$1,
  slice: () => slice$2,
  some: () => some$3,
  toArray: () => toArray$2,
  unique: () => unique$2,
  uniqueByValue: () => uniqueByValue$2,
  until: () => until$2,
  yieldNumber: () => yieldNumber,
  zip: () => zip$2
});
function* uniqueByValue$2(input, toString5 = toStringDefault, seen = /* @__PURE__ */ new Set()) {
  for (const v3 of input) {
    const key = toString5(v3);
    if (seen.has(key)) continue;
    seen.add(key);
    yield v3;
  }
}
function asCallback$3(input, callback, onDone) {
  for (const value3 of input) callback(value3);
  if (onDone) onDone();
}
function yieldNumber(generator, defaultValue) {
  return () => {
    const v3 = generator.next().value;
    if (v3 === void 0) return defaultValue;
    return v3;
  };
}
function first(it2) {
  for (const value3 of it2) return value3;
}
function last$2(it2) {
  let returnValue;
  for (const value3 of it2) returnValue = value3;
  return returnValue;
}
function* chunksOverlapping(it2, size) {
  if (size <= 1) throw new Error(`Size should be at least 2`);
  let buffer = [];
  for (const v3 of it2) {
    buffer.push(v3);
    if (buffer.length === size) {
      yield buffer;
      buffer = [buffer.at(-1)];
    }
  }
  if (buffer.length <= 1) return;
  if (buffer.length > 0) yield buffer;
}
function* chunks$2(it2, size) {
  let buffer = [];
  for (const v3 of it2) {
    buffer.push(v3);
    if (buffer.length === size) {
      yield buffer;
      buffer = [];
    }
  }
  if (buffer.length > 0) yield buffer;
}
function* concat$2(...its) {
  for (const it2 of its) yield* it2;
}
function* dropWhile$2(it2, f5) {
  for (const v3 of it2) if (!f5(v3)) yield v3;
}
var until$2 = (it2, callback) => {
  for (const _3 of it2) {
    const value3 = callback();
    if (typeof value3 === `boolean` && !value3) break;
  }
};
var next = (it2) => {
  return () => {
    const r5 = it2.next();
    if (r5.done) return;
    return r5.value;
  };
};
function equals$2(it1, it2, equality) {
  while (true) {
    const index1 = it1.next(), index2 = it2.next();
    if (equality !== void 0) {
      if (!equality(index1.value, index2.value)) return false;
    } else if (index1.value !== index2.value) return false;
    if (index1.done ?? index2.done) return index1.done && index2.done;
  }
}
function every$2(it2, f5) {
  for (const v3 of it2) {
    const result = f5(v3);
    if (!result) return false;
  }
  return true;
}
function* fill$2(it2, v3) {
  for (const _3 of it2) yield v3;
}
function forEach$2(iterator, fn2) {
  for (const v3 of iterator) {
    const result = fn2(v3);
    if (typeof result === `boolean` && !result) break;
  }
}
function* filter$3(it2, f5) {
  for (const v3 of it2) {
    if (!f5(v3)) continue;
    yield v3;
  }
}
function find$2(it2, f5) {
  for (const v3 of it2) if (f5(v3)) return v3;
}
function* flatten$2(it2) {
  for (const v3 of it2) if (typeof v3 === `object`) {
    if (Array.isArray(v3)) for (const vv of v3) yield vv;
    else if (isIterable(v3)) for (const vv of v3) yield vv;
  } else yield v3;
}
function* map$2(it2, f5) {
  for (const v3 of it2) yield f5(v3);
}
function* max$4(it2, gt3 = (a3, b3) => a3 > b3) {
  let max$5;
  for (const v3 of it2) {
    if (max$5 === void 0) {
      max$5 = v3;
      yield max$5;
      continue;
    }
    if (gt3(v3, max$5)) {
      max$5 = v3;
      yield max$5;
    }
  }
  return max$5;
}
function* min$4(it2, gt3 = (a3, b3) => a3 > b3) {
  let min$5;
  for (const v3 of it2) {
    if (min$5 === void 0) {
      min$5 = v3;
      yield min$5;
    }
    if (gt3(min$5, v3)) {
      min$5 = v3;
      yield min$5;
    }
  }
}
function some$3(it2, f5) {
  for (const v3 of it2) if (f5(v3)) return true;
  return false;
}
function* repeat$1(genCreator, repeatsOrSignal) {
  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;
  const signal = typeof repeatsOrSignal === `number` ? void 0 : repeatsOrSignal;
  let count3 = repeats;
  while (true) {
    for (const v3 of genCreator()) {
      yield v3;
      if (signal?.aborted) break;
    }
    if (Number.isFinite(repeats)) {
      count3--;
      if (count3 === 0) break;
    }
    if (signal?.aborted) break;
  }
}
function* unique$2(iterable$1) {
  const buffer = [];
  let itera = [];
  itera = Array.isArray(iterable$1) ? iterable$1 : [iterable$1];
  for (const it2 of itera) for (const v3 of it2) {
    if (buffer.includes(v3)) continue;
    buffer.push(v3);
    yield v3;
  }
}
function* zip$2(...its) {
  const iits = its.map((it2) => it2[Symbol.iterator]());
  while (true) {
    const vs2 = iits.map((it2) => it2.next());
    if (vs2.some((v3) => v3.done)) return;
    yield vs2.map((v3) => v3.value);
  }
}
function* fromIterable$2(iterable$1) {
  for (const v3 of iterable$1) yield v3;
}
function toArray$2(it2, options = {}) {
  const result = [];
  const started = Date.now();
  const whileFunction = options.while;
  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;
  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);
  for (const v3 of it2) {
    if (whileFunction) {
      if (!whileFunction(result.length)) break;
    }
    if (result.length >= maxItems) break;
    if (Date.now() - started > maxElapsed) break;
    result.push(v3);
  }
  return result;
}
function* fromArray$2(array$1) {
  for (const v3 of array$1) yield v3;
}
var MapOfSimple = class {
  #store = /* @__PURE__ */ new Map();
  /**
  * Gets a copy of the underlying array storing values at `key`, or an empty array if
  * key does not exist
  * @param key
  * @returns
  */
  get(key) {
    const arr = this.#store.get(key);
    if (!arr) return [];
    return [...arr];
  }
  /**
  * Returns the number of values stored under `key`
  * @param key
  * @returns
  */
  size(key) {
    const arr = this.#store.get(key);
    if (!arr) return 0;
    return arr.length;
  }
  /**
  * Iterate over all values contained under `key`
  * @param key
  * @returns
  */
  *iterateKey(key) {
    const arr = this.#store.get(key);
    if (!arr) return;
    yield* arr.values();
  }
  /**
  * Iterate all values, regardless of key
  */
  *iterateValues() {
    for (const key of this.#store.keys()) yield* this.iterateKey(key);
  }
  /**
  * Iterate all keys
  */
  *iterateKeys() {
    yield* this.#store.keys();
  }
  addKeyedValues(key, ...values3) {
    let arr = this.#store.get(key);
    if (!arr) {
      arr = [];
      this.#store.set(key, arr);
    }
    arr.push(...values3);
  }
  deleteKeyValue(key, value3) {
    const arr = this.#store.get(key);
    if (!arr) return false;
    const arrCopy = arr.filter((v3) => v3 !== value3);
    if (arrCopy.length === arr.length) return false;
    this.#store.set(key, arrCopy);
    return true;
  }
  clear() {
    this.#store.clear();
  }
};
var SimpleEventEmitter = class {
  #listeners = new MapOfSimple();
  #disposed = false;
  dispose() {
    if (this.#disposed) return;
    this.clearEventListeners();
  }
  get isDisposed() {
    return this.#disposed;
  }
  /**
  * Fire event
  * @param type Type of event
  * @param args Arguments for event
  * @returns
  */
  fireEvent(type, args) {
    if (this.#disposed) throw new Error(`Disposed`);
    for (const l3 of this.#listeners.iterateKey(type)) l3(args, this);
  }
  /**
  * Adds event listener.
  *
  * @throws Error if emitter is disposed
  * @typeParam K - Events
  * @param name Event name
  * @param listener Event handler
  */
  addEventListener(name, listener) {
    if (this.#disposed) throw new Error(`Disposed`);
    this.#listeners.addKeyedValues(name, listener);
  }
  /**
  * Remove event listener
  *
  * @param listener
  */
  removeEventListener(type, listener) {
    if (this.#disposed) return;
    this.#listeners.deleteKeyValue(type, listener);
  }
  /**
  * Clear all event listeners
  * @private
  */
  clearEventListeners() {
    if (this.#disposed) return;
    this.#listeners.clear();
  }
};
var src_exports$12 = {};
__export(src_exports$12, { SimpleEventEmitter: () => SimpleEventEmitter });
var async_exports = {};
__export(async_exports, {
  asCallback: () => asCallback$2,
  chunks: () => chunks$1,
  concat: () => concat$1,
  dropWhile: () => dropWhile$1,
  equals: () => equals$1,
  every: () => every$1,
  fill: () => fill$1,
  filter: () => filter$2,
  find: () => find$1,
  flatten: () => flatten$1,
  forEach: () => forEach$1,
  fromArray: () => fromArray$1,
  fromIterable: () => fromIterable$1,
  last: () => last$1,
  map: () => map$1,
  max: () => max$3,
  min: () => min$3,
  nextWithTimeout: () => nextWithTimeout,
  reduce: () => reduce$2,
  repeat: () => repeat,
  slice: () => slice$1,
  some: () => some$2,
  toArray: () => toArray$1,
  unique: () => unique$1,
  uniqueByValue: () => uniqueByValue$1,
  until: () => until$1,
  withDelay: () => withDelay,
  zip: () => zip$1
});
async function* fromArray$1(array$1, interval2 = 1) {
  for (const v3 of array$1) {
    yield v3;
    await sleep(interval2);
  }
}
async function* fromIterable$1(iterable$1, interval2 = 1) {
  for await (const v3 of iterable$1) {
    yield v3;
    await sleep(interval2);
  }
}
async function* chunks$1(it2, size) {
  let buffer = [];
  for await (const v3 of it2) {
    buffer.push(v3);
    if (buffer.length === size) {
      yield buffer;
      buffer = [];
    }
  }
  if (buffer.length > 0) yield buffer;
}
async function* concat$1(...its) {
  for await (const it2 of its) yield* it2;
}
async function* dropWhile$1(it2, f5) {
  for await (const v3 of it2) if (!f5(v3)) yield v3;
}
var until$1 = async (it2, callback) => {
  for await (const _3 of it2) {
    const value3 = await callback();
    if (typeof value3 === `boolean` && !value3) break;
  }
};
var repeat = async function* (genCreator, repeatsOrSignal) {
  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;
  const signal = typeof repeatsOrSignal === `number` ? void 0 : repeatsOrSignal;
  let count3 = repeats;
  while (true) {
    for await (const v3 of genCreator()) {
      yield v3;
      if (signal?.aborted) break;
    }
    if (Number.isFinite(repeats)) {
      count3--;
      if (count3 === 0) break;
    }
    if (signal?.aborted) break;
  }
};
async function equals$1(it1, it2, equality) {
  const iit1 = it1[Symbol.asyncIterator]();
  const iit2 = it2[Symbol.asyncIterator]();
  while (true) {
    const index1 = await iit1.next();
    const index2 = await iit2.next();
    if (equality !== void 0) {
      if (!equality(index1.value, index2.value)) return false;
    } else if (index1.value !== index2.value) return false;
    if (index1.done ?? index2.done) return index1.done && index2.done;
  }
}
async function every$1(it2, f5) {
  for await (const v3 of it2) {
    const result = await f5(v3);
    if (!result) return false;
  }
  return true;
}
async function* fill$1(it2, v3) {
  for await (const _3 of it2) yield v3;
}
async function* filter$2(it2, f5) {
  for await (const v3 of it2) {
    if (!await f5(v3)) continue;
    yield v3;
  }
}
async function find$1(it2, f5) {
  for await (const v3 of it2) if (await f5(v3)) return v3;
}
async function* flatten$1(it2) {
  for await (const v3 of it2) if (typeof v3 === `object`) {
    if (Array.isArray(v3)) for (const vv of v3) yield vv;
    else if (isAsyncIterable(v3)) for await (const vv of v3) yield vv;
    else if (isIterable(v3)) for (const vv of v3) yield vv;
  } else yield v3;
}
var forEach$1 = async function(iterator, fn2, options = {}) {
  const interval2 = options.interval;
  if (Array.isArray(iterator)) for (const x3 of iterator) {
    const r5 = await fn2(x3);
    if (typeof r5 === `boolean` && !r5) break;
    if (interval2) await sleep(interval2);
  }
  else for await (const x3 of iterator) {
    const r5 = await fn2(x3);
    if (typeof r5 === `boolean` && !r5) break;
    if (interval2) await sleep(interval2);
  }
};
async function last$1(it2, opts = {}) {
  const abort = opts.abort;
  let returnValue;
  for await (const value3 of it2) {
    if (abort?.aborted) return void 0;
    returnValue = value3;
  }
  return returnValue;
}
async function* map$1(it2, f5) {
  for await (const v3 of it2) yield f5(v3);
}
async function* max$3(it2, gt3 = (a3, b3) => a3 > b3) {
  let max$5;
  for await (const v3 of it2) {
    if (max$5 === void 0) {
      max$5 = v3;
      yield max$5;
      continue;
    }
    if (gt3(v3, max$5)) {
      max$5 = v3;
      yield v3;
    }
  }
}
async function* min$3(it2, gt3 = (a3, b3) => a3 > b3) {
  let min$5;
  for await (const v3 of it2) {
    if (min$5 === void 0) {
      min$5 = v3;
      yield min$5;
      continue;
    }
    if (gt3(min$5, v3)) {
      min$5 = v3;
      yield v3;
    }
  }
  return min$5;
}
async function reduce$2(it2, f5, start) {
  for await (const v3 of it2) start = f5(start, v3);
  return start;
}
async function asCallback$2(input, callback, onDone) {
  for await (const value3 of input) callback(value3);
  if (onDone) onDone();
}
async function* slice$1(it2, start = 0, end = Number.POSITIVE_INFINITY) {
  console.log(`Async slice start: ${start}`);
  const iit = it2[Symbol.asyncIterator]();
  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);
  for (; start > 0; start--, end--) await iit.next();
  for await (const v3 of it2) if (end-- > 0) yield v3;
  else break;
}
async function* withDelay(it2, delay$1) {
  for (const v3 of it2) {
    await sleep(delay$1);
    yield v3;
  }
}
async function nextWithTimeout(it2, options) {
  const ms2 = intervalToMs(options, 1e3);
  const value3 = await Promise.race([(async () => {
    await sleep({
      millis: ms2,
      signal: options.signal
    });
    return void 0;
  })(), (async () => {
    return await it2.next();
  })()]);
  if (value3 === void 0) throw new Error(`Timeout`);
  return value3;
}
async function some$2(it2, f5) {
  for await (const v3 of it2) if (await f5(v3)) return true;
  return false;
}
async function toArray$1(it2, options = {}) {
  const result = [];
  const iterator = it2[Symbol.asyncIterator]();
  const started = Date.now();
  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;
  const whileFunction = options.while;
  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);
  while (result.length < maxItems && Date.now() - started < maxElapsed) {
    if (whileFunction) {
      if (!whileFunction(result.length)) break;
    }
    const r5 = await iterator.next();
    if (r5.done) break;
    result.push(r5.value);
  }
  return result;
}
async function* unique$1(iterable$1) {
  const buffer = [];
  const itera = Array.isArray(iterable$1) ? iterable$1 : [iterable$1];
  for await (const it2 of itera) for await (const v3 of it2) {
    if (buffer.includes(v3)) continue;
    buffer.push(v3);
    yield v3;
  }
}
async function* uniqueByValue$1(input, toString5 = toStringDefault, seen = /* @__PURE__ */ new Set()) {
  for await (const v3 of input) {
    const key = toString5(v3);
    if (seen.has(key)) continue;
    seen.add(key);
    yield v3;
  }
}
async function* zip$1(...its) {
  const iits = its.map((it2) => it2[Symbol.asyncIterator]());
  while (true) {
    const vs2 = await Promise.all(iits.map((it2) => it2.next()));
    if (vs2.some((v3) => v3.done)) return;
    yield vs2.map((v3) => v3.value);
  }
}
function isGenFactoryNoInput(c5) {
  if (!(`_type` in c5)) return false;
  if (c5._type === `GenFactoryNoInput`) return true;
  return false;
}
function* primitiveToGenerator(value3) {
  yield value3;
}
async function* primitiveToAsyncGenerator(value3) {
  yield value3;
  await sleep(1);
}
function resolveToGen(input) {
  if (Array.isArray(input)) {
    const a3 = input.values();
    a3._name = `arrayInput`;
    return a3;
  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) return primitiveToGenerator(input);
  else if (typeof input === `function`) return input();
  return input;
}
function resolveToAsyncGen(input) {
  if (input === void 0) return;
  if (Array.isArray(input)) return fromArray$1(input);
  else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) return primitiveToAsyncGenerator(input);
  else if (typeof input === `function`) return input();
  else if (isAsyncIterable(input)) return input;
  return fromIterable$1(input);
}
function resolveEl(elOrQuery) {
  if (typeof elOrQuery === `string`) {
    const el2 = document.querySelector(elOrQuery);
    if (!el2) throw new Error(`Element not found '${elOrQuery}'`);
    return el2;
  }
  return elOrQuery;
}
var dom_exports = {};
__export(dom_exports, {
  perValue: () => perValue,
  query: () => query
});
var createMap = (key) => {
  const keyFunction = key ?? ((value3) => value3);
  const map$3 = /* @__PURE__ */ new Map();
  return {
    has(key$1) {
      return map$3.has(keyFunction(key$1));
    },
    get(key$1) {
      return map$3.get(keyFunction(key$1));
    },
    set(key$1, value3) {
      map$3.set(keyFunction(key$1), value3);
    },
    entries() {
      return map$3.entries();
    },
    delete(key$1) {
      map$3.delete(key$1);
    }
  };
};
function perValue(options = {}) {
  const byReference = options.byReference;
  const tagName = options.tagName ?? `div`;
  if (byReference && options.key) throw new Error(`byReference and key options are mutually exclusive`);
  const keyFunction = byReference ? void 0 : options.key ?? toStringDefault;
  const map$3 = createMap(keyFunction);
  const parentElementOrQuery = options.parentEl ?? document.body;
  const parentEl = resolveEl(parentElementOrQuery);
  const usedElements = /* @__PURE__ */ new Set();
  async function* perValue$1(input) {
    for await (const value3 of resolveToGen(input)) {
      let el2 = map$3.get(value3);
      if (!el2) {
        el2 = document.createElement(tagName);
        map$3.set(value3, el2);
        if (options.beforeInsert) options.beforeInsert(el2);
        parentEl.append(el2);
        if (options.afterInsert) options.afterInsert(el2);
      }
      usedElements.add(el2);
      yield {
        el: el2,
        value: value3
      };
    }
    for (const [id, el2] of map$3.entries()) {
      if (usedElements.has(el2)) continue;
      if (options.beforeRemove) options.beforeRemove(el2);
      el2.remove();
      map$3.delete(id);
    }
  }
  perValue$1._name = `dom.perValue`;
  return perValue$1;
}
function query(options = {}) {
  const baseElement = options.baseElement ?? document;
  async function* query$1(input) {
    const gen = resolveToGen(input);
    for await (const value3 of gen) for (const element of baseElement.querySelectorAll(value3)) yield element;
  }
  query$1._name = `dom.query`;
  return query$1;
}
var links_exports = {};
__export(links_exports, {
  average: () => average$1,
  chunk: () => chunk,
  debounce: () => debounce,
  delay: () => delay,
  drop: () => drop,
  duration: () => duration,
  filter: () => filter$1,
  max: () => max$2,
  min: () => min$2,
  rank: () => rank$1,
  rankArray: () => rankArray,
  reduce: () => reduce$1,
  sum: () => sum$1,
  take: () => take,
  tally: () => tally$1,
  transform: () => transform
});
function transform(transformer) {
  async function* transform$1(input) {
    input = resolveToGen(input);
    for await (const value3 of input) yield transformer(value3);
  }
  transform$1._name = `transform`;
  return transform$1;
}
function take(limit2) {
  async function* take$1(input) {
    input = resolveToGen(input);
    let yielded = 0;
    for await (const value3 of input) {
      if (++yielded > limit2) break;
      yield value3;
    }
  }
  take$1._name = `take`;
  return take$1;
}
function reduce$1(reducer) {
  async function* reduce$4(input) {
    input = resolveToGen(input);
    for await (const value3 of input) yield reducer(value3);
  }
  reduce$4._name = `reduce`;
  return reduce$4;
}
function duration(elapsed2) {
  const durationMs = intervalToMs(elapsed2, 0);
  async function* duration$1(input) {
    input = resolveToGen(input);
    const elapsed$1 = elapsedSince();
    for await (const value3 of input) {
      if (elapsed$1() > durationMs) break;
      yield value3;
    }
  }
  duration$1._name = `duration`;
  return duration$1;
}
function delay(options) {
  const before = intervalToMs(options.before, 0);
  const after = intervalToMs(options.after, 0);
  async function* delay$1(input) {
    input = resolveToGen(input);
    for await (const value3 of input) {
      if (before > 0) await sleep(before);
      yield value3;
      if (after > 0) await sleep(after);
    }
  }
  delay$1._name = `delay`;
  return delay$1;
}
function debounce(rate2) {
  const rateMs = intervalToMs(rate2, 0);
  async function* debounce$1(input) {
    input = resolveToGen(input);
    let elapsed2 = elapsedSince();
    for await (const value3 of input) {
      if (elapsed2() < rateMs) continue;
      yield value3;
      elapsed2 = elapsedSince();
    }
  }
  debounce$1._name = `debounce`;
  return debounce$1;
}
function tally$1(countArrayItems = true) {
  async function* tally$2(input) {
    input = resolveToGen(input);
    const p3 = tally(countArrayItems);
    for await (const v3 of input) yield p3(v3);
  }
  tally$2._name = `tally`;
  return tally$2;
}
function min$2() {
  async function* min$5(input) {
    input = resolveToGen(input);
    const p3 = min();
    for await (const value3 of input) {
      const x3 = p3(value3);
      if (x3 === void 0) continue;
      yield x3;
    }
  }
  min$5._name = `min`;
  return min$5;
}
function max$2() {
  async function* max$5(input) {
    input = resolveToGen(input);
    const p3 = max();
    for await (const value3 of input) {
      const x3 = p3(value3);
      if (x3 === void 0) continue;
      yield x3;
    }
  }
  max$5._name = `max`;
  return max$5;
}
function rank$1(r5, options = {}) {
  async function* rank$2(input) {
    input = resolveToGen(input);
    const p3 = rank(r5, options);
    for await (const value3 of input) {
      const x3 = p3(value3);
      if (x3 === void 0) continue;
      yield x3;
    }
  }
  rank$2._name = `rank`;
  return rank$2;
}
function rankArray(r5, options = {}) {
  const includeType = options.includeType;
  const emitEqualRanked = options.emitEqualRanked ?? false;
  const emitRepeatHighest = options.emitRepeatHighest ?? false;
  const withinArrays = options.withinArrays ?? false;
  async function* rankArray$1(input) {
    input = resolveToGen(input);
    let best;
    for await (const value3 of input) {
      let emit = false;
      if (withinArrays) best = void 0;
      for (const subValue of value3) {
        if (includeType && typeof subValue !== includeType) continue;
        if (best === void 0) {
          best = subValue;
          emit = true;
        } else {
          const result = r5(subValue, best);
          if (result == `a`) {
            best = subValue;
            emit = true;
          } else if (result === `eq` && emitEqualRanked) emit = true;
          else if (emitRepeatHighest) emit = true;
        }
      }
      if (emit && best) yield best;
    }
  }
  rankArray$1._name = `rankArray`;
  return rankArray$1;
}
function average$1() {
  async function* average$2(input) {
    input = resolveToGen(input);
    const p3 = average();
    for await (const value3 of input) {
      const x3 = p3(value3);
      if (x3 === void 0) continue;
      yield x3;
    }
  }
  average$2._name = `average`;
  return average$2;
}
function sum$1() {
  async function* total2(input) {
    input = resolveToGen(input);
    const p3 = sum();
    for await (const value3 of input) {
      const x3 = p3(value3);
      if (x3 === void 0) continue;
      yield x3;
    }
  }
  total2._name = `total`;
  return total2;
}
function chunk(size, returnRemainders = true) {
  resultThrow(integerTest(size, `aboveZero`, `size`));
  async function* chunk$1(input) {
    input = resolveToGen(input);
    let buffer = [];
    for await (const value3 of input) {
      buffer.push(value3);
      if (buffer.length >= size) {
        yield buffer;
        buffer = [];
      }
    }
    if (returnRemainders && buffer.length > 0) yield buffer;
  }
  chunk$1._name = `chunk`;
  return chunk$1;
}
function filter$1(predicate) {
  async function* filter$4(input) {
    input = resolveToGen(input);
    for await (const value3 of input) if (predicate(value3)) yield value3;
  }
  filter$4._name = `filter`;
  return filter$4;
}
function drop(predicate) {
  async function* drop$1(input) {
    input = resolveToGen(input);
    for await (const value3 of input) if (!predicate(value3)) yield value3;
  }
  drop$1._name = `drop`;
  return drop$1;
}
function array2(it2, delay$1 = 5) {
  async function* fromArray$3() {
    for (const v3 of it2) {
      await sleep(delay$1);
      yield v3;
    }
  }
  fromArray$3._name = `fromArray`;
  fromArray$3._type = `GenFactoryNoInput`;
  return fromArray$3;
}
function event(target, name) {
  async function* event$1() {
    while (true) yield await promiseFromEvent(target, name);
  }
  event$1._name = `event`;
  event$1._type = `GenFactoryNoInput`;
  return event$1;
}
function func(callback) {
  async function* fromFunction$1() {
    while (true) {
      const v3 = await callback();
      if (typeof v3 === `undefined`) break;
      yield v3;
    }
  }
  fromFunction$1._name = `fromFunction`;
  fromFunction$1._type = `GenFactoryNoInput`;
  return fromFunction$1;
}
function iterable(it2) {
  async function* fromIterable$3() {
    for await (const v3 of it2) yield v3;
  }
  fromIterable$3._name = `fromIterable`;
  fromIterable$3._type = `GenFactoryNoInput`;
  return fromIterable$3;
}
function timestamp(options) {
  const intervalMs = intervalToMs(options.interval, 0);
  const asClockTime = options.asClockTime ?? false;
  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;
  let looped = 0;
  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);
  async function* ts2() {
    const elapsed2 = elapsedSince();
    while (looped < loops && elapsed2() < durationTime) {
      yield asClockTime ? Date.now() : elapsed2();
      const expectedTimeDiff = looped * intervalMs - elapsed2();
      await sleep(Math.max(0, intervalMs + expectedTimeDiff));
      looped++;
    }
  }
  ts2._name = `timestamp`;
  ts2._type = `GenFactoryNoInput`;
  return ts2;
}
var from_exports = {};
__export(from_exports, {
  array: () => array2,
  event: () => event,
  func: () => func,
  iterable: () => iterable,
  timestamp: () => timestamp
});
async function addToArray(array$1, valueToWrap) {
  const outputType = typeof valueToWrap === `function` ? valueToWrap() : valueToWrap;
  for await (const value3 of outputType) array$1.push(value3);
}
async function asArray(valueToWrap, options = {}) {
  const outputType = typeof valueToWrap === `function` ? valueToWrap() : valueToWrap;
  return toArray$1(outputType, options);
}
async function asCallback$1(valueToWrap, callback, onDone) {
  const outputType = typeof valueToWrap === `function` ? valueToWrap() : valueToWrap;
  for await (const value3 of outputType) callback(value3);
  if (onDone) onDone();
}
function asPromise(valueToWrap) {
  let lastValue;
  const outputType = typeof valueToWrap === `function` ? valueToWrap() : valueToWrap;
  async function asPromise$1() {
    const v3 = await outputType.next();
    if (v3.done) return;
    lastValue = v3.value;
    return lastValue;
  }
  return asPromise$1;
}
function asValue(valueToWrap, initialValue) {
  let lastValue = initialValue;
  let awaiting = false;
  const outputType = typeof valueToWrap === `function` ? valueToWrap() : valueToWrap;
  function asValue$1() {
    if (!awaiting) {
      awaiting = true;
      outputType.next().then((v3) => {
        lastValue = v3.value;
        awaiting = false;
      }).catch((error) => {
        awaiting = false;
        throw error;
      });
    }
    return lastValue;
  }
  return asValue$1;
}
async function* combineLatestToArray(sources, options = {}) {
  const onSourceDone = options.onSourceDone ?? `break`;
  const finalValue = options.finalValue ?? `undefined`;
  const afterEmit = options.afterEmit ?? `last`;
  const inputs = sources.map((source, index) => ({
    waiting: void 0,
    index,
    gen: resolveToGen(source),
    done: false,
    lastValue: void 0
  }));
  const isDone2 = () => !inputs.some((v3) => !v3.done);
  const isWaiting = () => inputs.some((v3) => v3.waiting !== void 0);
  const allEmpty = (d3) => !d3.some((v3) => v3 !== void 0);
  let lastEmitted = [];
  while (true) {
    const promises = [];
    for (const input of inputs) {
      if (input.done) continue;
      if (input.waiting !== void 0) {
        promises.push(input.waiting);
        continue;
      }
      const p3 = Promise.resolve((async () => {
        if (input.done) return input;
        const v3 = await input.gen.next();
        input.waiting = void 0;
        if (v3.done) {
          input.done = true;
          if (finalValue === `undefined`) input.lastValue = void 0;
        } else input.lastValue = v3.value;
        return input;
      })());
      input.waiting = p3;
      promises.push(p3);
    }
    const won = await Promise.race(promises);
    if (`done` in won) {
      if (won.done && onSourceDone === `break`) break;
    } else throw new Error(`Missing 'done' property`);
    const d3 = inputs.map((v3) => v3.lastValue);
    if (d3.length === 0) return;
    const dataEmpty = allEmpty(d3);
    if (dataEmpty && !isWaiting()) return;
    if (!isEqual(lastEmitted, d3) && !dataEmpty) {
      lastEmitted = d3;
      yield d3;
    }
    if (afterEmit === `undefined`) for (const input of inputs) {
      if (input.waiting !== void 0) continue;
      input.lastValue = void 0;
    }
    if (isDone2()) break;
  }
}
async function* combineLatestToObject(sources, options = {}) {
  const onSourceDone = options.onSourceDone ?? `break`;
  const finalValue = options.finalValue ?? `undefined`;
  const afterEmit = options.afterEmit ?? `last`;
  const states = /* @__PURE__ */ new Map();
  for (const [key, value3] of Object.entries(sources)) states.set(key, {
    gen: resolveToGen(value3),
    done: false,
    lastValue: void 0,
    waiting: void 0,
    key
  });
  const isDone2 = () => !some(states, (v3) => !v3.done);
  const isWaiting = () => some(states, (v3) => v3.waiting !== void 0);
  const allEmpty = (d3) => {
    for (const v3 of Object.values(d3)) if (v3 !== void 0) return false;
    return true;
  };
  const getData = () => {
    const r5 = {};
    for (const [key, state] of states) r5[key] = state.lastValue;
    return r5;
  };
  let lastEmitted;
  while (true) {
    const promises = [];
    for (const input of states.values()) {
      if (input.done) continue;
      if (input.waiting !== void 0) {
        promises.push(input.waiting);
        continue;
      }
      const p3 = Promise.resolve((async () => {
        if (input.done) return input;
        const v3 = await input.gen.next();
        input.waiting = void 0;
        if (v3.done) {
          input.done = true;
          if (finalValue === `undefined`) input.lastValue = void 0;
        } else input.lastValue = v3.value;
        return input;
      })());
      input.waiting = p3;
      promises.push(p3);
    }
    const won = await Promise.race(promises);
    if (`done` in won) {
      if (won.done && onSourceDone === `break`) break;
    } else throw new Error(`Result missing 'done' property`);
    const d3 = getData();
    const dataEmpty = allEmpty(d3);
    if (dataEmpty && !isWaiting()) return;
    if (!isEqualValueIgnoreOrder(lastEmitted, d3) && !dataEmpty) {
      lastEmitted = d3;
      yield d3;
    }
    if (afterEmit === `undefined`) for (const input of states.values()) {
      if (input.waiting !== void 0) continue;
      input.lastValue = void 0;
    }
    if (isDone2()) break;
  }
}
var getLinkName = (c5) => {
  return c5._name ?? c5.name;
};
function lazy() {
  const chained = [];
  let dataToUse;
  const asGenerator = (data) => {
    if (data === void 0) data = dataToUse;
    let d3 = resolveToAsyncGen(data);
    for (const c5 of chained) if (d3 === void 0) if (isGenFactoryNoInput(c5)) d3 = c5();
    else throw new Error(`Function '${getLinkName(c5)}' requires input. Provide it to the function, or call 'input' earlier.`);
    else d3 = c5(d3);
    return d3;
  };
  const w3 = {
    rankArray: (r5, options) => {
      chained.push(rankArray(r5, options));
      return w3;
    },
    rank: (r5, options) => {
      chained.push(rank$1(r5, options));
      return w3;
    },
    transform: (transformer) => {
      chained.push(transform(transformer));
      return w3;
    },
    reduce: (reducer) => {
      chained.push(reduce$1(reducer));
      return w3;
    },
    drop: (predicate) => {
      chained.push(drop(predicate));
      return w3;
    },
    delay: (options) => {
      chained.push(delay(options));
      return w3;
    },
    duration: (elapsed2) => {
      chained.push(duration(elapsed2));
      return w3;
    },
    debounce: (rate2) => {
      chained.push(debounce(rate2));
      return w3;
    },
    fromFunction: (callback) => {
      chained.push(func(callback));
      return w3;
    },
    take: (limit2) => {
      chained.push(take(limit2));
      return w3;
    },
    chunk: (size, returnRemainders = true) => {
      chained.push(chunk(size, returnRemainders));
      return w3;
    },
    filter: (predicate) => {
      chained.push(filter$1((v3) => predicate(v3)));
      return w3;
    },
    min: () => {
      chained.push(min$2());
      return w3;
    },
    max: () => {
      chained.push(max$2());
      return w3;
    },
    average: () => {
      chained.push(average$1());
      return w3;
    },
    sum: () => {
      chained.push(sum$1());
      return w3;
    },
    tally: (countArrayItems) => {
      chained.push(tally$1(countArrayItems));
      return w3;
    },
    input(data) {
      dataToUse = data;
      return w3;
    },
    asGenerator,
    asAsync(data) {
      let d3 = data ?? dataToUse;
      for (const c5 of chained) if (d3 === void 0 && isGenFactoryNoInput(c5)) d3 = c5();
      else if (d3 === void 0) throw new Error(`Function '${getLinkName(c5)}' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);
      else d3 = c5(d3);
      return w3;
    },
    asArray: async (data) => {
      const g4 = asGenerator(data);
      return await toArray$1(g4);
    },
    firstOutput: async (data) => {
      const g4 = asGenerator(data);
      const v3 = await g4.next();
      return v3.value;
    },
    lastOutput: async (data) => {
      const g4 = asGenerator(data);
      let lastValue;
      for await (const v3 of g4) lastValue = v3;
      return lastValue;
    }
  };
  return w3;
}
var QueueMutable = class {
  #store = [];
  enqueue(data) {
    this.#store.push(data);
  }
  dequeue() {
    return this.#store.shift();
  }
};
async function* mergeFlat(...sources) {
  const sourcesInput = sources.map((source) => resolveToAsyncGen(source));
  const buffer = new QueueMutable();
  let completed = 0;
  const schedule = async (source) => {
    if (source === void 0) {
      completed++;
      return;
    }
    const x3 = await source.next();
    if (x3.done) completed++;
    else {
      buffer.enqueue(x3.value);
      setTimeout(() => schedule(source), 1);
    }
  };
  for (const source of sourcesInput) setTimeout(() => schedule(source), 1);
  const loopSpeed = 10;
  let loopFactor = 1;
  while (completed < sourcesInput.length) {
    const d3 = buffer.dequeue();
    if (d3 === void 0) loopFactor = Math.min(loopFactor + 1, 10);
    else {
      yield d3;
      loopFactor = 1;
    }
    await sleep(loopSpeed * loopFactor);
  }
}
async function* runN(...functions) {
  let input;
  for (const fnOrData of functions) input = typeof fnOrData === `function` ? fnOrData(input ?? []) : resolveToGen(fnOrData);
  if (input === void 0) return;
  for await (const v3 of input) yield v3;
}
async function* run(gen, l0, l1, l22, l3, l4, l5) {
  let input;
  const functions = arguments;
  for (const fnOrData of functions) if (typeof fnOrData === `function`) input = fnOrData(input ?? []);
  else input = resolveToGen(fnOrData);
  if (input === void 0) return;
  for await (const v3 of input) yield v3;
}
function prepare(...functions) {
  const r5 = (source) => {
    return runN(source, ...functions);
  };
  return r5;
}
async function single(f5, input) {
  const iterator = await f5([input]).next();
  return iterator.value;
}
async function* syncToArray(sources, options = {}) {
  const onSourceDone = options.onSourceDone ?? `break`;
  const maximumWaitMs = intervalToMs(options.maximumWait, 2e3);
  const finalValue = options.finalValue ?? `undefined`;
  const inputs = sources.map((source) => ({
    seq: 0,
    lastValue: void 0,
    gen: resolveToGen(source),
    done: false
  }));
  const nextWithTimeoutOpts = { millis: maximumWaitMs };
  let seq = 0;
  const isAllDone = () => !inputs.some((v3) => !v3.done);
  let go2 = true;
  while (go2) {
    seq++;
    for (const input of inputs) {
      if (input.done) {
        input.seq = seq;
        continue;
      }
      const v3 = await nextWithTimeout(input.gen, nextWithTimeoutOpts);
      if (v3.done) {
        input.done = true;
        input.seq = seq;
        if (finalValue === `undefined`) input.lastValue = void 0;
        if (onSourceDone === `break`) return;
      } else {
        input.lastValue = v3.value;
        input.seq = seq;
      }
    }
    if (go2) {
      const d3 = inputs.filter((v3) => v3.seq === seq).map((v3) => v3.lastValue);
      if (d3.length === 0) return;
      if (!d3.some((v3) => typeof v3 !== `undefined`)) return;
      yield d3;
    }
    if (isAllDone()) go2 = false;
  }
}
var chain_exports = {};
__export(chain_exports, {
  Dom: () => dom_exports,
  From: () => from_exports,
  Links: () => links_exports,
  addToArray: () => addToArray,
  asArray: () => asArray,
  asCallback: () => asCallback$1,
  asPromise: () => asPromise,
  asValue: () => asValue,
  combineLatestToArray: () => combineLatestToArray,
  combineLatestToObject: () => combineLatestToObject,
  isGenFactoryNoInput: () => isGenFactoryNoInput,
  lazy: () => lazy,
  mergeFlat: () => mergeFlat,
  prepare: () => prepare,
  resolveToAsyncGen: () => resolveToAsyncGen,
  resolveToGen: () => resolveToGen,
  run: () => run,
  runN: () => runN,
  single: () => single,
  syncToArray: () => syncToArray
});
var maxScore = (iterable$1, scorer) => {
  let highestValue;
  let highestScore = Number.MIN_SAFE_INTEGER;
  for (const value3 of iterable$1) {
    const score = scorer(value3);
    if (score >= highestScore) {
      highestScore = score;
      highestValue = value3;
    }
  }
  return highestValue;
};
var minScore = (iterable$1, scorer) => {
  let lowestValue;
  let lowestScore = Number.MAX_SAFE_INTEGER;
  for (const value3 of iterable$1) {
    const score = scorer(value3);
    if (score <= lowestScore) {
      lowestScore = score;
      lowestValue = value3;
    }
  }
  return lowestValue;
};
var hasEqualValuesShallow = (iterableA, iterableB, eq) => {
  const returnValue = compareIterableValuesShallow(iterableA, iterableB, eq);
  return returnValue.a.length === 0 && returnValue.b.length === 0;
};
var iteratorController = (options) => {
  const delayMs = intervalToMs(options.delay, 10);
  let gen;
  const onValue = options.onValue;
  let state = `stopped`;
  const loop = continuously(async () => {
    if (gen) {
      const r5 = await gen.next();
      if (r5.done) {
        state = `stopped`;
        return false;
      }
      const r22 = onValue(r5.value);
      if (typeof r22 === `boolean`) {
        if (!r22) state = `stopped`;
        return r22;
      }
      return true;
    } else {
      state = `stopped`;
      return false;
    }
  }, delayMs);
  const cancel = () => {
    if (state === `stopped`) return;
    gen = void 0;
    loop.cancel();
    state = `stopped`;
  };
  const pause = () => {
    if (state === `paused`) return;
    loop.cancel();
    state = `paused`;
  };
  const start = () => {
    if (state === `running`) return;
    if (!gen) remake();
    state = `running`;
    loop.start();
  };
  const remake = () => {
    if (options.iterator) gen = options.iterator();
    else throw new Error(`No source iterator`);
  };
  const restart = () => {
    remake();
    start();
  };
  return {
    start,
    cancel,
    restart,
    pause,
    get state() {
      return state;
    }
  };
};
var fromEvent = (eventSource, eventType) => {
  const pullQueue = [];
  const pushQueue = [];
  let done = false;
  const pushValue = (args) => {
    if (pullQueue.length > 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else pushQueue.push(args);
  };
  const pullValue = () => new Promise((resolve2) => {
    if (pushQueue.length > 0) {
      const arguments_ = pushQueue.shift();
      resolve2(...arguments_);
    } else pullQueue.push(resolve2);
  });
  const handler = (...arguments_) => {
    pushValue(arguments_);
  };
  eventSource.addEventListener(eventType, handler);
  const r5 = {
    next: async () => {
      if (done) return {
        done: true,
        value: void 0
      };
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async () => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {
        done: true,
        value: void 0
      };
    },
    throw: async (error) => {
      done = true;
      return {
        done: true,
        value: Promise.reject(new Error(error))
      };
    }
  };
  return r5;
};
var numbersCompute = (data, options = {}) => {
  if (typeof data === `undefined`) throw new Error(`Param 'data' is undefined`);
  if (Array.isArray(data)) return numberArrayCompute(data, options);
  if (isIterable(data)) return numbersComputeIterable(data, options);
  throw new Error(`Param 'data' is neither an array nor iterable`);
};
function numbersComputeIterable(data, options = {}) {
  let total2 = 0;
  const nonNumbers = options.nonNumbers ?? `ignore`;
  let min$5 = Number.MAX_SAFE_INTEGER;
  let max$5 = Number.MIN_SAFE_INTEGER;
  let count3 = 0;
  for (let v3 of data) {
    if (typeof v3 !== `number` || Number.isNaN(v3)) {
      if (nonNumbers === `throw`) throw new TypeError(`Data contains something not a number. Got type '${typeof v3}'`);
      if (nonNumbers === `nan`) v3 = NaN;
      if (nonNumbers === `ignore`) continue;
    }
    total2 += v3;
    count3++;
    min$5 = Math.min(min$5, v3);
    max$5 = Math.max(max$5, v3);
  }
  return {
    avg: total2 / count3,
    total: total2,
    max: max$5,
    min: min$5,
    count: count3
  };
}
function computeAverage(data, options = {}) {
  let count3 = 0;
  let total2 = 0;
  const nonNumbers = options.nonNumbers ?? `ignore`;
  for (let d3 of data) {
    if (typeof d3 !== `number` || Number.isNaN(d3)) {
      if (nonNumbers === `throw`) throw new TypeError(`Data contains something not a number. Got type '${typeof d3}'`);
      if (nonNumbers === `nan`) d3 = NaN;
      if (nonNumbers === `ignore`) continue;
    }
    total2 += d3;
    count3++;
  }
  return total2 / count3;
}
var src_exports3 = {};
__export(src_exports3, {
  Async: () => async_exports,
  Chains: () => chain_exports,
  Sync: () => sync_exports,
  asCallback: () => asCallback,
  chunks: () => chunks2,
  combineLatestToArray: () => combineLatestToArray,
  combineLatestToObject: () => combineLatestToObject,
  computeAverage: () => computeAverage,
  concat: () => concat,
  dropWhile: () => dropWhile,
  equals: () => equals,
  every: () => every,
  fill: () => fill,
  filter: () => filter,
  find: () => find,
  flatten: () => flatten2,
  forEach: () => forEach,
  fromArray: () => fromArray,
  fromEvent: () => fromEvent,
  fromFunction: () => fromFunction,
  fromFunctionAwaited: () => fromFunctionAwaited,
  fromIterable: () => fromIterable2,
  hasEqualValuesShallow: () => hasEqualValuesShallow,
  isAsyncIterable: () => isAsyncIterable,
  isIterable: () => isIterable,
  iteratorController: () => iteratorController,
  last: () => last,
  map: () => map,
  max: () => max$1,
  maxScore: () => maxScore,
  min: () => min$1,
  minScore: () => minScore,
  numbersCompute: () => numbersCompute,
  reduce: () => reduce,
  slice: () => slice,
  some: () => some$1,
  toArray: () => toArray2,
  unique: () => unique2,
  uniqueByValue: () => uniqueByValue,
  until: () => until2,
  zip: () => zip2
});
function min$1(it2, gt3 = (a3, b3) => a3 > b3) {
  return isAsyncIterable(it2) ? min$3(it2, gt3) : min$4(it2, gt3);
}
function max$1(it2, gt3 = (a3, b3) => a3 > b3) {
  return isAsyncIterable(it2) ? max$3(it2, gt3) : max$4(it2, gt3);
}
function dropWhile(it2, f5) {
  return isAsyncIterable(it2) ? dropWhile$1(it2, f5) : dropWhile$2(it2, f5);
}
function until2(it2, callback) {
  if (isAsyncIterable(it2)) return until$1(it2, callback);
  else until$2(it2, callback);
}
function chunks2(it2, size) {
  return isAsyncIterable(it2) ? chunks$1(it2, size) : chunks$2(it2, size);
}
function filter(it2, f5) {
  return isAsyncIterable(it2) ? filter$2(it2, f5) : filter$3(it2, f5);
}
function fill(it2, v3) {
  return isAsyncIterable(it2) ? fill$1(it2, v3) : fill$2(it2, v3);
}
function concat(...its) {
  return isAsyncIterable(its[0]) ? concat$1(...its) : concat$2(...its);
}
function find(it2, f5) {
  return isAsyncIterable(it2) ? find$1(it2, f5) : find$2(it2, f5);
}
function forEach(it2, fn2, options = {}) {
  if (isAsyncIterable(it2)) return forEach$1(it2, fn2, options);
  else forEach$2(it2, fn2);
}
function map(it2, f5) {
  return isAsyncIterable(it2) ? map$1(it2, f5) : map$2(it2, f5);
}
function fromArray(array$1, interval2) {
  return interval2 === void 0 ? fromArray$2(array$1) : fromArray$1(array$1, interval2);
}
function flatten2(it2) {
  return isAsyncIterable(it2) ? flatten$1(it2) : flatten$2(it2);
}
function some$1(it2, f5) {
  return isAsyncIterable(it2) ? some$2(it2, f5) : some$3(it2, f5);
}
function last(it2) {
  return isAsyncIterable(it2) ? last$1(it2) : last$2(it2);
}
function reduce(it2, f5, start) {
  return isAsyncIterable(it2) ? reduce$2(it2, f5, start) : reduce$3(it2, f5, start);
}
function slice(it2, start = 0, end = Number.POSITIVE_INFINITY) {
  return isAsyncIterable(it2) ? slice$1(it2, start, end) : slice$2(it2, start, end);
}
function unique2(iterable$1) {
  if (Array.isArray(iterable$1)) {
    if (iterable$1.length === 0) return fromArray$2([]);
    return isAsyncIterable(iterable$1[0]) ? unique$1(iterable$1) : unique$2(iterable$1);
  } else if (isAsyncIterable(iterable$1)) return unique$1(iterable$1);
  else return unique$2(iterable$1);
}
function* uniqueByValue(input, toString5 = toStringDefault, seen = /* @__PURE__ */ new Set()) {
  yield* isAsyncIterable(input) ? uniqueByValue$1(input, toString5, seen) : uniqueByValue$2(input, toString5, seen);
}
function toArray2(it2, options = {}) {
  return isAsyncIterable(it2) ? toArray$1(it2, options) : toArray$2(it2, options);
}
function every(it2, f5) {
  return isAsyncIterable(it2) ? every$1(it2, f5) : every$2(it2, f5);
}
function equals(it1, it2, equality) {
  const as2 = isAsyncIterable(it1) && isAsyncIterable(it2);
  return as2 ? equals$1(it1, it2, equality) : equals$2(it1, it2, equality);
}
function zip2(...its) {
  if (its.length === 0) return fromArray$2([]);
  return isAsyncIterable(its[0]) ? zip$1(...its) : zip$2(...its);
}
function fromIterable2(iterable$1, interval2) {
  if (isAsyncIterable(iterable$1) || interval2 !== void 0) return fromIterable$1(iterable$1, interval2);
  return fromIterable$2(iterable$1);
}
function* fromFunction(callback) {
  while (true) {
    const v3 = callback();
    yield v3;
  }
}
async function* fromFunctionAwaited(callback) {
  while (true) {
    const v3 = await callback();
    yield v3;
  }
}
function asCallback(input, callback, onDone) {
  if (isAsyncIterable(input)) return asCallback$2(input, callback);
  else {
    asCallback$3(input, callback);
    return;
  }
}

// node_modules/ixfx/bundle/collections.js
var CircularArray = class CircularArray2 extends Array {
  #capacity;
  #pointer;
  constructor(capacity = 0) {
    super();
    resultThrow(integerTest(capacity, `positive`, `capacity`));
    this.#capacity = capacity;
    this.#pointer = 0;
  }
  /**
  * Add to array
  * @param value Thing to add
  * @returns 
  */
  add(value$1) {
    const ca2 = CircularArray2.from(this);
    ca2[this.#pointer] = value$1;
    ca2.#capacity = this.#capacity;
    if (this.#capacity > 0) ca2.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;
    else ca2.#pointer = this.#pointer + 1;
    return ca2;
  }
  get pointer() {
    return this.#pointer;
  }
  get isFull() {
    if (this.#capacity === 0) return false;
    return this.length === this.#capacity;
  }
};
var debug = (opts, message) => {
  opts.debug && console.log(`queue:${message}`);
};
var trimQueue = (opts, queue, toAdd) => {
  const potentialLength = queue.length + toAdd.length;
  const capacity = opts.capacity ?? potentialLength;
  const toRemove = potentialLength - capacity;
  const policy = opts.discardPolicy ?? `additions`;
  switch (policy) {
    case `additions`: {
      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);
      if (queue.length === opts.capacity) return queue;
      else return [...queue, ...toAdd.slice(0, toRemove - 1)];
    }
    case `newer`:
      if (toRemove >= queue.length) {
        if (queue.length === 0) return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];
        return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);
      } else {
        const countToAdd = Math.max(1, toAdd.length - queue.length);
        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);
        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1));
        const t6 = [...toKeep, ...toAddFinal];
        return t6;
      }
    case `older`:
      return [...queue, ...toAdd].slice(toRemove);
    default:
      throw new Error(`Unknown overflow policy ${policy}`);
  }
};
var enqueue = (opts, queue, ...toAdd) => {
  if (opts === void 0) throw new Error(`opts parameter undefined`);
  const potentialLength = queue.length + toAdd.length;
  const overSize = opts.capacity && potentialLength > opts.capacity;
  const toReturn = overSize ? trimQueue(opts, queue, toAdd) : [...queue, ...toAdd];
  if (opts.capacity && toReturn.length !== opts.capacity && overSize) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);
  if (!opts.capacity && toReturn.length !== potentialLength) throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);
  return toReturn;
};
var dequeue = (opts, queue) => {
  if (queue.length === 0) throw new Error(`Queue is empty`);
  return queue.slice(1);
};
var peek = (opts, queue) => queue[0];
var isEmpty = (opts, queue) => queue.length === 0;
var isFull = (opts, queue) => {
  if (opts.capacity) return queue.length >= opts.capacity;
  return false;
};
var QueueMutable2 = class extends SimpleEventEmitter {
  options;
  data;
  eq;
  constructor(opts = {}, data = []) {
    super();
    if (opts === void 0) throw new Error(`opts parameter undefined`);
    this.options = opts;
    this.data = data;
    this.eq = opts.eq ?? isEqualDefault;
  }
  clear() {
    const copy = [...this.data];
    this.data = [];
    this.fireEvent(`removed`, {
      finalData: this.data,
      removed: copy
    });
    this.onClear();
  }
  /**
  * Called when all data is cleared
  */
  onClear() {
  }
  at(index) {
    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);
    const v3 = this.data.at(index);
    if (v3 === void 0) throw new Error(`Index appears to be outside range of queue`);
    return v3;
  }
  enqueue(...toAdd) {
    this.data = enqueue(this.options, this.data, ...toAdd);
    const length3 = this.data.length;
    this.onEnqueue(this.data, toAdd);
    return length3;
  }
  onEnqueue(result, attemptedToAdd) {
    this.fireEvent(`enqueue`, {
      added: attemptedToAdd,
      finalData: result
    });
  }
  dequeue() {
    const v3 = peek(this.options, this.data);
    if (v3 === void 0) return;
    this.data = dequeue(this.options, this.data);
    this.fireEvent(`dequeue`, {
      removed: v3,
      finalData: this.data
    });
    this.onRemoved([v3], this.data);
    return v3;
  }
  onRemoved(removed, finalData) {
    this.fireEvent(`removed`, {
      removed,
      finalData
    });
  }
  /**
  * Removes values that match `predicate`.
  * @param predicate 
  * @returns Returns number of items removed.
  */
  removeWhere(predicate) {
    const countPre = this.data.length;
    const toRemove = this.data.filter((v3) => predicate(v3));
    if (toRemove.length === 0) return 0;
    this.data = this.data.filter((element) => !predicate(element));
    this.onRemoved(toRemove, this.data);
    return countPre - this.data.length;
  }
  /**
  * Return a copy of the array
  * @returns 
  */
  toArray() {
    return [...this.data];
  }
  get isEmpty() {
    return isEmpty(this.options, this.data);
  }
  get isFull() {
    return isFull(this.options, this.data);
  }
  get length() {
    return this.data.length;
  }
  get peek() {
    return peek(this.options, this.data);
  }
};
function mutable$1(options = {}, ...startingItems) {
  return new QueueMutable2({ ...options }, [...startingItems]);
}
var trimStack = (opts, stack, toAdd) => {
  const potentialLength = stack.length + toAdd.length;
  const policy = opts.discardPolicy ?? `additions`;
  const capacity = opts.capacity ?? potentialLength;
  const toRemove = potentialLength - capacity;
  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);
  switch (policy) {
    case `additions`: {
      if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`);
      if (stack.length === opts.capacity) return stack;
      else return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];
    }
    case `newer`:
      if (toRemove >= stack.length) return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);
      else {
        if (opts.debug) console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);
        return [...stack.slice(0, stack.length - toRemove), ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1))];
      }
    case `older`:
      return [...stack, ...toAdd].slice(toRemove);
    default:
      throw new Error(`Unknown discard policy ${policy}`);
  }
};
var push = (opts, stack, ...toAdd) => {
  const potentialLength = stack.length + toAdd.length;
  const overSize = opts.capacity && potentialLength > opts.capacity;
  const toReturn = overSize ? trimStack(opts, stack, toAdd) : [...stack, ...toAdd];
  return toReturn;
};
var pop = (opts, stack) => {
  if (stack.length === 0) throw new Error(`Stack is empty`);
  return stack.slice(0, -1);
};
var peek$1 = (opts, stack) => stack.at(-1);
var isEmpty$1 = (opts, stack) => stack.length === 0;
var isFull$1 = (opts, stack) => {
  if (opts.capacity) return stack.length >= opts.capacity;
  return false;
};
var StackMutable = class {
  opts;
  data;
  constructor(opts = {}, data = []) {
    this.opts = opts;
    this.data = data;
  }
  /**
  * Push data onto the stack.
  * If `toAdd` is empty, nothing happens
  * @param toAdd Data to add
  * @returns Length of stack
  */
  push(...toAdd) {
    if (toAdd.length === 0) return this.data.length;
    this.data = push(this.opts, this.data, ...toAdd);
    return this.data.length;
  }
  forEach(fn2) {
    this.data.forEach(fn2);
  }
  forEachFromTop(fn2) {
    [...this.data].reverse().forEach(fn2);
  }
  pop() {
    const v3 = peek$1(this.opts, this.data);
    this.data = pop(this.opts, this.data);
    return v3;
  }
  get isEmpty() {
    return isEmpty$1(this.opts, this.data);
  }
  get isFull() {
    return isFull$1(this.opts, this.data);
  }
  get peek() {
    return peek$1(this.opts, this.data);
  }
  get length() {
    return this.data.length;
  }
};
var mutable$3 = (opts = {}, ...startingItems) => new StackMutable({ ...opts }, [...startingItems]);
var compare = (a3, b3, eq = isEqualValueIgnoreOrder, parent) => {
  const valueEqual = valueOrIdentityEqual(a3, b3, eq);
  const childrenCompare = compareChildren(a3, b3, eq);
  const diff = {
    valueChanged: !valueEqual,
    a: a3,
    b: b3,
    added: childrenCompare.added,
    removed: childrenCompare.removed,
    childChanged: false
  };
  const diffNode = {
    value: diff,
    childrenStore: [],
    parent
  };
  const childrenDiff = childrenCompare.identical.map((c5) => compare(c5[0], c5[1], eq, diffNode));
  const someChildChange = hasChange(diff) || childrenDiff.some((v3) => hasChange(v3.value));
  setChildren(diffNode, childrenDiff);
  diffNode.toString = () => toString$1(diffNode, 0);
  diffNode.value.childChanged = someChildChange;
  throwTreeTest(diffNode);
  return diffNode;
};
var hasChange = (vv) => {
  if (vv === void 0) return false;
  if (vv.valueChanged) return true;
  if (vv.childChanged) return true;
  if (vv.added.length > 0) return true;
  if (vv.removed.length > 0) return true;
  return false;
};
var compareChildren = (a3, b3, eq = isEqualValueIgnoreOrder) => {
  const childrenOfA = [...a3.children()];
  const childrenOfB = [...b3.children()];
  const identical = [];
  const removed = [];
  for (const childA of childrenOfA) {
    let foundIndex = -1;
    for (const [index, childOfB] of childrenOfB.entries()) {
      const d3 = valueOrIdentityEqual(childA, childOfB, eq);
      if (d3) {
        identical.push([childA, childOfB]);
        foundIndex = index;
        break;
      }
    }
    if (foundIndex === -1) removed.push(childA);
    else childrenOfB.splice(foundIndex, 1);
  }
  const added = [...childrenOfB];
  return {
    added,
    identical,
    removed
  };
};
var valueOrIdentityEqual = (a3, b3, eq) => {
  if (a3.getIdentity() === b3.getIdentity()) return true;
  if (eq(a3.getValue(), b3.getValue())) return true;
  return false;
};
var toStringSingle = (n6) => {
  return JSON.stringify(n6.getValue());
};
var toString$1 = (n6, indent = 0) => {
  if (n6 === void 0) return `(undefined)`;
  let t6 = toStringDiff(n6.value, indent);
  for (const c5 of n6.childrenStore) t6 += toString$1(c5, indent + 2);
  return t6;
};
var toStringDiff = (n6, indent) => {
  const spaces = ` `.repeat(indent);
  if (n6 === void 0) return `${spaces}(undefined)`;
  const t6 = [];
  t6.push(`a: ${toStringSingle(n6.a)} b: ${toStringSingle(n6.b)}`);
  if (n6.valueChanged) t6.push(`Value changed. Child changed: ${n6.childChanged}`);
  else t6.push(`Value unchanged. Child changed: ${n6.childChanged}`);
  if (n6.added.length > 0) {
    t6.push(`Added:`);
    for (const c5 of n6.added) t6.push(` - ` + toStringSingle(c5));
  }
  if (n6.removed.length > 0) {
    t6.push(`Removed: ${n6.removed.length}`);
    for (const c5 of n6.removed) t6.push(` - ` + toStringSingle(c5));
  }
  t6.push(`----
`);
  return t6.map((line3) => spaces + line3).join(`
`);
};
var tree_mutable_exports = {};
__export(tree_mutable_exports, {
  add: () => add$1,
  addValue: () => addValue$1,
  asDynamicTraversable: () => asDynamicTraversable$1,
  breadthFirst: () => breadthFirst$1,
  children: () => children$1,
  childrenLength: () => childrenLength$1,
  childrenValues: () => childrenValues,
  compare: () => compare$1,
  computeMaxDepth: () => computeMaxDepth,
  createNode: () => createNode,
  depthFirst: () => depthFirst$2,
  findAnyChildByValue: () => findAnyChildByValue$1,
  findChildByValue: () => findChildByValue$1,
  findParentsValue: () => findParentsValue,
  followValue: () => followValue$1,
  fromPlainObject: () => fromPlainObject,
  getRoot: () => getRoot,
  hasAnyChild: () => hasAnyChild$1,
  hasAnyParent: () => hasAnyParent$1,
  hasChild: () => hasChild$1,
  hasParent: () => hasParent$1,
  nodeDepth: () => nodeDepth,
  parents: () => parents$1,
  parentsValues: () => parentsValues,
  queryByValue: () => queryByValue,
  queryParentsValue: () => queryParentsValue,
  remove: () => remove2,
  root: () => root,
  rootWrapped: () => rootWrapped,
  setChildren: () => setChildren,
  stripParentage: () => stripParentage,
  throwTreeTest: () => throwTreeTest,
  toStringDeep: () => toStringDeep$2,
  treeTest: () => treeTest,
  value: () => value,
  wrap: () => wrap3
});
var compare$1 = (a3, b3, eq) => {
  return compare(asDynamicTraversable$1(a3), asDynamicTraversable$1(b3), eq);
};
var stripParentage = (node) => {
  const n6 = {
    value: node.value,
    childrenStore: node.childrenStore.map((c5) => stripParentage(c5))
  };
  return n6;
};
var unwrapped = (node) => `wraps` in node ? node.wraps : node;
var wrapped = (node) => `wraps` in node ? node : wrap3(node);
var wrap3 = (n6) => {
  return {
    *children() {
      for (const c5 of n6.childrenStore) yield wrap3(c5);
    },
    getValue: () => n6.value,
    getIdentity: () => n6,
    *queryValue(value$1) {
      for (const v3 of queryByValue(value$1, unwrapped(n6))) yield wrap3(v3);
    },
    *queryParentsValue(child, value$1, eq) {
      for (const v3 of queryParentsValue(unwrapped(child), value$1, eq)) yield wrap3(v3);
    },
    *parentsValues(child) {
      yield* parentsValues(unwrapped(child));
    },
    findParentsValue(child, value$1, eq) {
      const n$1 = findParentsValue(child, value$1, eq);
      if (n$1 !== void 0) return wrap3(n$1);
    },
    getParent: () => n6.parent === void 0 ? void 0 : wrap3(n6.parent),
    hasParent: (parent) => {
      return hasParent$1(n6, unwrapped(parent));
    },
    hasAnyParent: (parent) => {
      return hasAnyParent$1(n6, unwrapped(parent));
    },
    hasChild: (child) => {
      return hasChild$1(unwrapped(child), n6);
    },
    hasAnyChild: (child) => {
      return hasAnyChild$1(unwrapped(child), n6);
    },
    remove: () => {
      remove2(n6);
    },
    addValue: (value$1) => {
      const nodeValue = addValue$1(value$1, n6);
      return wrap3(nodeValue);
    },
    add: (child) => {
      add$1(unwrapped(child), n6);
      return wrapped(child);
    },
    wraps: n6
  };
};
var remove2 = (child) => {
  const p3 = child.parent;
  if (p3 === void 0) return;
  child.parent = void 0;
  p3.childrenStore = without(p3.childrenStore, child);
};
function* depthFirst$2(node) {
  if (!root) return;
  const stack = new StackMutable();
  stack.push(...node.childrenStore);
  let entry = stack.pop();
  while (entry) {
    yield entry;
    if (entry) stack.push(...entry.childrenStore);
    if (stack.isEmpty) break;
    entry = stack.pop();
  }
}
function* breadthFirst$1(node) {
  if (!node) return;
  const queue = new QueueMutable2();
  queue.enqueue(...node.childrenStore);
  let entry = queue.dequeue();
  while (entry) {
    yield entry;
    if (entry) queue.enqueue(...entry.childrenStore);
    if (queue.isEmpty) break;
    entry = queue.dequeue();
  }
}
function treeTest(root$1, seen = []) {
  if (root$1.parent === root$1) return [
    false,
    `Root has itself as parent`,
    root$1
  ];
  if (seen.includes(root$1)) return [
    false,
    `Same node instance is appearing further in tree`,
    root$1
  ];
  seen.push(root$1);
  if (containsDuplicateInstances(root$1.childrenStore)) return [
    false,
    `Children list contains duplicates`,
    root$1
  ];
  for (const c5 of root$1.childrenStore) {
    if (c5.parent !== root$1) return [
      false,
      `Member of childrenStore does not have .parent set`,
      c5
    ];
    if (hasAnyChild$1(root$1, c5)) return [
      false,
      `Child has parent as its own child`,
      c5
    ];
    const v3 = treeTest(c5, seen);
    if (!v3[0]) return v3;
  }
  return [
    true,
    ``,
    root$1
  ];
}
function throwTreeTest(root$1) {
  const v3 = treeTest(root$1);
  if (v3[0]) return;
  throw new Error(`${v3[1]} Node: ${toStringAbbreviate(v3[2].value, 30)}`, { cause: v3[2] });
}
function* children$1(root$1) {
  for (const c5 of root$1.childrenStore) yield c5;
}
function* childrenValues(root$1) {
  for (const c5 of root$1.childrenStore) if (typeof c5.value !== `undefined`) yield c5.value;
}
function* parents$1(root$1) {
  let p3 = root$1.parent;
  while (p3) {
    yield p3;
    p3 = p3.parent;
  }
}
function nodeDepth(node) {
  const p3 = [...parents$1(node)];
  return p3.length;
}
var hasChild$1 = (child, parent) => {
  for (const c5 of parent.childrenStore) if (c5 === child) return true;
  return false;
};
var findChildByValue$1 = (value$1, parent, eq = isEqualDefault) => {
  for (const c5 of parent.childrenStore) if (eq(value$1, c5.value)) return c5;
};
function* queryByValue(value$1, parent, eq = isEqualDefault) {
  for (const c5 of parent.childrenStore) if (eq(value$1, c5.value)) yield c5;
}
var hasAnyChild$1 = (prospectiveChild, parent) => {
  for (const c5 of breadthFirst$1(parent)) if (c5 === prospectiveChild) return true;
  return false;
};
var findAnyChildByValue$1 = (value$1, parent, eq = isEqualDefault) => {
  for (const c5 of breadthFirst$1(parent)) if (eq(c5.value, value$1)) return c5;
};
var getRoot = (node) => {
  if (node.parent) return getRoot(node.parent);
  return node;
};
var hasAnyParent$1 = (child, prospectiveParent) => {
  for (const p3 of parents$1(child)) if (p3 === prospectiveParent) return true;
  return false;
};
function* parentsValues(child) {
  for (const p3 of parents$1(child)) if (typeof p3.value !== `undefined`) yield p3.value;
  return false;
}
function* queryParentsValue(child, value$1, eq = isEqualDefault) {
  for (const p3 of parents$1(child)) if (typeof p3.value !== `undefined`) {
    if (eq(p3.value, value$1)) yield p3;
  }
  return false;
}
function findParentsValue(child, value$1, eq = isEqualDefault) {
  for (const p3 of queryParentsValue(child, value$1, eq)) return p3;
}
var hasParent$1 = (child, prospectiveParent) => {
  return child.parent === prospectiveParent;
};
var computeMaxDepth = (node) => {
  return computeMaxDepthImpl(node, 0);
};
var computeMaxDepthImpl = (node, startingDepth = 0) => {
  let depth = startingDepth;
  for (const c5 of node.childrenStore) depth = Math.max(depth, computeMaxDepthImpl(c5, startingDepth + 1));
  return depth;
};
var add$1 = (child, parent) => {
  throwAttemptedChild(child, parent);
  const p3 = child.parent;
  parent.childrenStore = [...parent.childrenStore, child];
  child.parent = parent;
  if (p3) p3.childrenStore = without(p3.childrenStore, child);
};
var addValue$1 = (value$1, parent) => {
  return createNode(value$1, parent);
};
var root = (value$1) => {
  return createNode(value$1);
};
var fromPlainObject = (value$1, label = ``, parent, seen = []) => {
  const entries2 = Object.entries(value$1);
  parent = parent === void 0 ? root() : addValue$1({
    label,
    value: value$1
  }, parent);
  for (const entry of entries2) {
    const value$2 = entry[1];
    if (seen.includes(value$2)) continue;
    seen.push(value$2);
    if (typeof entry[1] === `object`) fromPlainObject(value$2, entry[0], parent, seen);
    else addValue$1({
      label: entry[0],
      value: value$2
    }, parent);
  }
  return parent;
};
var rootWrapped = (value$1) => {
  return wrap3(createNode(value$1));
};
var createNode = (value$1, parent) => {
  const n6 = {
    childrenStore: [],
    parent,
    value: value$1
  };
  if (parent !== void 0) parent.childrenStore = [...parent.childrenStore, n6];
  return n6;
};
var childrenLength$1 = (node) => {
  return node.childrenStore.length;
};
var value = (node) => {
  return node.value;
};
var asDynamicTraversable$1 = (node) => {
  const t6 = {
    *children() {
      for (const c5 of node.childrenStore) yield asDynamicTraversable$1(c5);
    },
    getParent() {
      if (node.parent === void 0) return;
      return asDynamicTraversable$1(node.parent);
    },
    getValue() {
      return node.value;
    },
    getIdentity() {
      return node;
    }
  };
  return t6;
};
var throwAttemptedChild = (c5, parent) => {
  if (parent === c5) throw new Error(`Cannot add self as child`);
  if (c5.parent === parent) return;
  if (hasAnyParent$1(parent, c5)) throw new Error(`Child contains parent (1)`, { cause: c5 });
  if (hasAnyParent$1(c5, parent)) throw new Error(`Parent already contains child`, { cause: c5 });
  if (hasAnyChild$1(parent, c5)) throw new Error(`Child contains parent (2)`, { cause: c5 });
};
var setChildren = (parent, children$2) => {
  for (const c5 of children$2) throwAttemptedChild(c5, parent);
  parent.childrenStore = [...children$2];
  for (const c5 of children$2) c5.parent = parent;
};
var toStringDeep$2 = (node, indent = 0) => {
  const t6 = `${`  `.repeat(indent)} + ${node.value ? JSON.stringify(node.value) : `-`}`;
  return node.childrenStore.length > 0 ? t6 + `
` + node.childrenStore.map((d3) => toStringDeep$2(d3, indent + 1)).join(`
`) : t6;
};
function* followValue$1(root$1, continuePredicate, depth = 1) {
  for (const c5 of root$1.childrenStore) {
    const value$1 = c5.value;
    if (value$1 === void 0) continue;
    if (continuePredicate(value$1, depth)) {
      yield c5.value;
      yield* followValue$1(c5, continuePredicate, depth + 1);
    }
  }
}
var traverse_object_exports = {};
__export(traverse_object_exports, {
  asDynamicTraversable: () => asDynamicTraversable,
  children: () => children,
  create: () => create$2,
  createSimplified: () => createSimplified,
  createWrapped: () => createWrapped,
  depthFirst: () => depthFirst$1,
  getByPath: () => getByPath,
  prettyPrint: () => prettyPrint,
  prettyPrintEntries: () => prettyPrintEntries,
  toStringDeep: () => toStringDeep$1,
  traceByPath: () => traceByPath
});
function prettyPrintEntries(entries2) {
  if (entries2.length === 0) return `(empty)`;
  let t6 = ``;
  for (const [index, entry] of entries2.entries()) {
    t6 += `  `.repeat(index);
    t6 += entry.name + ` = ` + JSON.stringify(entry.leafValue) + `
`;
  }
  return t6;
}
var prettyPrint = (node, indent = 0, options = {}) => {
  resultThrow(nullUndefTest(node, `node`));
  const defaultName = options.name ?? `node`;
  const entry = getNamedEntry(node, defaultName);
  const t6 = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.leafValue)}`;
  const childrenAsArray = [...children(node, options)];
  return childrenAsArray.length > 0 ? t6 + `
` + childrenAsArray.map((d3) => prettyPrint(d3.leafValue, indent + 1, {
    ...options,
    name: d3.name
  })).join(`
`) : t6;
};
var toStringDeep$1 = (node, indent = 0) => {
  let t6 = ` `.repeat(indent) + ` ${node.value?.name}`;
  if (node.value !== void 0) {
    if (`sourceValue` in node.value && `leafValue` in node.value) {
      let sourceValue = toStringAbbreviate(node.value.sourceValue, 20);
      const leafValue = toStringAbbreviate(node.value.leafValue, 20);
      sourceValue = sourceValue === leafValue ? `` : `source: ` + sourceValue;
      t6 += ` = ${leafValue} ${sourceValue}`;
    } else if (`sourceValue` in node.value && node.value.sourceValue !== void 0) t6 += ` = ${node.value.sourceValue}`;
    if (`ancestors` in node.value) t6 += ` (ancestors: ${node.value.ancestors.join(`, `)})`;
  }
  t6 += `
`;
  for (const c5 of node.childrenStore) t6 += toStringDeep$1(c5, indent + 1);
  return t6;
};
function* children(node, options = {}) {
  resultThrow(nullUndefTest(node, `node`));
  const filteringOption = options.filter ?? `none`;
  const filterByValue = (v3) => {
    if (filteringOption === `none`) return [true, isPrimitive(v3)];
    else if (filteringOption === `leaves` && isPrimitive(v3)) return [true, true];
    else if (filteringOption === `branches` && !isPrimitive(v3)) return [true, false];
    return [false, isPrimitive(v3)];
  };
  if (Array.isArray(node)) for (const [index, element] of node.entries()) {
    const f5 = filterByValue(element);
    if (f5[0]) yield {
      name: index.toString(),
      _kind: `entry`,
      sourceValue: element,
      leafValue: f5[1] ? element : void 0
    };
  }
  else if (typeof node === `object`) {
    const entriesIter = `entries` in node ? node.entries() : Object.entries(node);
    for (const [name, value$1] of entriesIter) {
      const [filter2, isPrimitive$1] = filterByValue(value$1);
      if (filter2) yield {
        name,
        _kind: `entry`,
        sourceValue: value$1,
        leafValue: isPrimitive$1 ? value$1 : void 0
      };
    }
  }
}
function* depthFirst$1(node, options = {}, ancestors = []) {
  for (const c5 of children(node, options)) {
    yield {
      ...c5,
      ancestors: [...ancestors],
      _kind: `entry-ancestors`
    };
    yield* depthFirst$1(c5.sourceValue, options, [...ancestors, c5.name]);
  }
}
function childByName(name, node) {
  for (const d3 of children(node)) if (d3.name === name) return d3;
}
function getByPath(path3, node, options = {}) {
  const v3 = last$2(traceByPath(path3, node, options));
  if (!v3) throw new Error(`Could not trace path: ${path3} `);
  return v3;
}
function* traceByPath(path3, node, options = {}) {
  resultThrow(nullUndefTest(path3, `path`), nullUndefTest(node, `node`));
  const separator = options.separator ?? `.`;
  const pathSplit = path3.split(separator);
  const ancestors = [];
  for (const p3 of pathSplit) {
    const entry = childByName(p3, node);
    if (!entry) {
      yield {
        name: p3,
        sourceValue: void 0,
        leafValue: void 0,
        ancestors,
        _kind: `entry-ancestors`
      };
      return;
    }
    node = entry.sourceValue;
    yield {
      ...entry,
      ancestors: [...ancestors],
      _kind: `entry-ancestors`
    };
    ancestors.push(p3);
  }
}
var asDynamicTraversable = (node, options = {}, ancestors = [], parent) => {
  const name = options.name ?? `object`;
  const t6 = {
    *children() {
      for (const { name: childName, sourceValue, leafValue } of children(node, options)) yield asDynamicTraversable(sourceValue, {
        ...options,
        name: childName
      }, [...ancestors, name], t6);
    },
    getParent() {
      return parent;
    },
    getValue() {
      return {
        name,
        sourceValue: node,
        ancestors,
        _kind: `entry-static`
      };
    },
    getIdentity() {
      return node;
    }
  };
  return t6;
};
var createWrapped = (node, options) => {
  return wrap3(create$2(node, options));
};
var create$2 = (node, options = {}) => {
  const valuesAtLeaves = options.valuesAtLeaves ?? false;
  const valueFor = valuesAtLeaves ? (v3) => {
    if (isPrimitive(v3)) return v3;
  } : (v3) => v3;
  return createImpl(node, valueFor(node), options, []);
};
var createImpl = (sourceValue, leafValue, options = {}, ancestors) => {
  const defaultName = options.name ?? `object_ci`;
  const r5 = root({
    name: defaultName,
    sourceValue: leafValue,
    ancestors: [...ancestors],
    _kind: `entry-static`
  });
  ancestors = [...ancestors, defaultName];
  for (const c5 of children(sourceValue, options)) {
    const v3 = options.valuesAtLeaves ? c5.leafValue : c5.sourceValue;
    add$1(createImpl(c5.sourceValue, v3, {
      ...options,
      name: c5.name
    }, ancestors), r5);
  }
  return r5;
};
var createSimplified = (node, options = {}) => {
  return stripParentage(create$2(node, options));
};
function getNamedEntry(node, defaultName = ``) {
  if (`name` in node && `leafValue` in node && `sourceValue` in node) return {
    name: node.name,
    _kind: `entry`,
    leafValue: node.leafValue,
    sourceValue: node.sourceValue
  };
  if (`name` in node) return {
    name: node.name,
    leafValue: node,
    sourceValue: node,
    _kind: `entry`
  };
  return {
    name: defaultName,
    leafValue: node,
    sourceValue: node,
    _kind: `entry`
  };
}
var pathed_exports = {};
__export(pathed_exports, {
  addValueByPath: () => addValueByPath,
  childrenLengthByPath: () => childrenLengthByPath,
  clearValuesByPath: () => clearValuesByPath,
  create: () => create$1,
  removeByPath: () => removeByPath,
  valueByPath: () => valueByPath,
  valuesByPath: () => valuesByPath
});
var create$1 = (pathOpts = {}) => {
  let root$1;
  const add$2 = (value$1, path3) => {
    const n6 = addValueByPath(value$1, path3, root$1, pathOpts);
    if (root$1 === void 0) root$1 = getRoot(n6);
  };
  const prettyPrint$1 = () => {
    if (root$1 === void 0) return `(empty)`;
    return toStringDeep$2(root$1);
  };
  const getValue = (path3) => {
    if (root$1 === void 0) return;
    return valueByPath(path3, root$1, pathOpts);
  };
  const remove$1 = (path3) => {
    if (root$1 === void 0) return false;
    return removeByPath(path3, root$1, pathOpts);
  };
  const hasPath = (path3) => {
    if (root$1 === void 0) return false;
    const c5 = findChildByPath(path3, root$1, pathOpts);
    return c5 !== void 0;
  };
  const getNode = (path3) => {
    if (root$1 === void 0) return;
    const c5 = findChildByPath(path3, root$1, pathOpts);
    return c5;
  };
  const childrenLength$2 = (path3) => {
    if (root$1 === void 0) return 0;
    const c5 = findChildByPath(path3, root$1, pathOpts);
    if (c5 === void 0) return 0;
    return c5.childrenStore.length;
  };
  const getValues = (path3) => {
    if (root$1 === void 0) return [];
    return valuesByPath(path3, root$1, pathOpts);
  };
  const getRoot$1 = () => {
    return root$1;
  };
  const clearValues = (path3) => {
    if (root$1 === void 0) return false;
    return clearValuesByPath(path3, root$1, pathOpts);
  };
  return {
    getRoot: getRoot$1,
    add: add$2,
    prettyPrint: prettyPrint$1,
    remove: remove$1,
    getValue,
    getValues,
    hasPath,
    childrenLength: childrenLength$2,
    getNode,
    clearValues
  };
};
var addValueByPath = (value$1, path3, node, pathOpts = {}) => {
  const separator = pathOpts.separator ?? `.`;
  const duplicatePath = pathOpts.duplicates ?? `overwrite`;
  const split = path3.split(separator);
  let count3 = 0;
  for (const p3 of split) {
    const lastEntry = count3 === split.length - 1;
    const found = findChildByLabel(p3, node);
    if (found === void 0) {
      const labelled = {
        value: lastEntry ? value$1 : void 0,
        label: p3
      };
      node = createNode(labelled, node);
    } else {
      node = found;
      if (lastEntry) switch (duplicatePath) {
        case `ignore`:
          break;
        case `allow`: {
          const existing = getValuesFromNode(node);
          node.value = {
            values: [...existing, value$1],
            label: p3
          };
          break;
        }
        case `overwrite`: {
          node.value = {
            value: value$1,
            label: p3
          };
          break;
        }
      }
      else node = found;
    }
    count3++;
  }
  if (node === void 0) throw new Error(`Could not create tree`);
  return node;
};
var removeByPath = (path3, root$1, pathOpts = {}) => {
  if (root$1 === void 0) return false;
  const c5 = findChildByPath(path3, root$1, pathOpts);
  if (c5 === void 0) return false;
  remove2(c5);
  return true;
};
var clearValuesByPath = (path3, root$1, pathOpts = {}) => {
  if (root$1 === void 0) return false;
  const c5 = findChildByPath(path3, root$1, pathOpts);
  if (c5 === void 0) return false;
  c5.value = {
    label: c5.value?.label ?? ``,
    value: void 0
  };
  return true;
};
var childrenLengthByPath = (path3, node, pathOpts = {}) => {
  if (node === void 0) return 0;
  const c5 = findChildByPath(path3, node, pathOpts);
  if (c5 === void 0) return 0;
  return c5.childrenStore.length;
};
var findChildByLabel = (label, node) => {
  if (node === void 0) return void 0;
  if (label === void 0) throw new Error(`Parameter 'label' cannot be undefined`);
  if (node.value?.label === label) return node;
  for (const c5 of node.childrenStore) if (c5.value?.label === label) return c5;
};
var valueByPath = (path3, node, pathOpts = {}) => {
  const values3 = valuesByPath(path3, node, pathOpts);
  if (values3.length === 0) return void 0;
  if (values3.length > 1) throw new Error(`Multiple values at path. Use getValues instead`);
  return values3[0];
};
var getValuesFromNode = (c5) => {
  if (c5.value === void 0) return [];
  if (`values` in c5.value) return c5.value.values;
  if (`value` in c5.value) {
    if (c5.value.value === void 0) return [];
    return [c5.value.value];
  }
  return [];
};
var findChildByPath = (path3, node, pathOpts = {}) => {
  const separator = pathOpts.separator ?? `.`;
  const split = path3.split(separator);
  let c5 = node;
  for (const p3 of split) {
    c5 = findChildByLabel(p3, c5);
    if (c5 === void 0) return;
  }
  return c5;
};
var valuesByPath = (path3, node, pathOpts = {}) => {
  const separator = pathOpts.separator ?? `.`;
  const split = path3.split(separator);
  let c5 = node;
  for (const p3 of split) {
    c5 = findChildByLabel(p3, c5);
    if (c5 === void 0) return [];
  }
  return getValuesFromNode(c5);
};
var traversable_tree_exports = {};
__export(traversable_tree_exports, {
  breadthFirst: () => breadthFirst,
  childrenLength: () => childrenLength,
  couldAddChild: () => couldAddChild,
  depthFirst: () => depthFirst,
  find: () => find2,
  findAnyChildByValue: () => findAnyChildByValue,
  findAnyParentByValue: () => findAnyParentByValue,
  findByValue: () => findByValue,
  findChildByValue: () => findChildByValue,
  findParentByValue: () => findParentByValue,
  followValue: () => followValue,
  hasAnyChild: () => hasAnyChild,
  hasAnyChildValue: () => hasAnyChildValue,
  hasAnyParent: () => hasAnyParent,
  hasAnyParentValue: () => hasAnyParentValue,
  hasChild: () => hasChild,
  hasChildValue: () => hasChildValue,
  hasParent: () => hasParent,
  hasParentValue: () => hasParentValue,
  parents: () => parents,
  siblings: () => siblings,
  toString: () => toString,
  toStringDeep: () => toStringDeep
});
var childrenLength = (tree) => {
  return [...tree.children()].length;
};
var hasAnyParent = (child, possibleParent, eq) => {
  return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);
};
var hasAnyParentValue = (child, possibleParentValue, eq) => {
  if (typeof child === `undefined`) throw new TypeError(`Param 'child' is undefined`);
  return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);
};
var findAnyParentByValue = (child, possibleParentValue, eq) => {
  return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);
};
var hasParent = (child, possibleParent, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return false;
  const isChildTrav = isTraversable(child);
  const isParentTrav = isTraversable(possibleParent);
  const p3 = isChildTrav ? child.getParent() : child.parent;
  if (typeof p3 === `undefined`) return false;
  if (eq(p3, possibleParent)) return true;
  const pId = isChildTrav ? p3.getIdentity() : p3.value;
  const ppId = isParentTrav ? possibleParent.getIdentity() : possibleParent.value;
  if (eq(pId, ppId)) return true;
  return hasParent(p3, possibleParent, eq, maxDepth - 1);
};
var hasParentValue = (child, possibleParentValue, eq = isEqualDefault, maxDepth = 0) => {
  if (child === void 0) throw new Error(`Param 'child' is undefined`);
  if (maxDepth < 0) return false;
  const p3 = `getParent` in child ? child.getParent() : child.parent;
  if (p3 === void 0) return false;
  const value$1 = `getValue` in p3 ? p3.getValue() : p3.value;
  if (eq(value$1, possibleParentValue)) return true;
  return hasParentValue(p3, possibleParentValue, eq, maxDepth - 1);
};
var findParentByValue = (child, possibleParentValue, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return;
  const p3 = `getParent` in child ? child.getParent() : child.parent;
  if (p3 === void 0) return;
  const value$1 = `getValue` in p3 ? p3.getValue() : p3.value;
  if (eq(value$1, possibleParentValue)) return p3;
  return findParentByValue(p3, possibleParentValue, eq, maxDepth - 1);
};
var couldAddChild = (parent, prospectiveChild, eq = isEqualDefault) => {
  if (eq(parent, prospectiveChild)) throw new Error(`Child equals parent`);
  if (hasAnyChild(parent, prospectiveChild, eq)) throw new Error(`Circular. Parent already has child`);
  if (hasAnyChild(prospectiveChild, parent, eq)) throw new Error(`Prospective child has parent as child relation`);
};
var hasAnyChild = (parent, possibleChild, eq = isEqualDefault) => {
  return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);
};
var hasAnyChildValue = (parent, possibleChildValue, eq = isEqualDefault) => {
  return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);
};
var hasChild = (parent, possibleChild, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return false;
  if (eq(parent, possibleChild)) return true;
  const pId = `getIdentity` in parent ? parent.getIdentity() : parent.value;
  const pcId = `getIdentity` in possibleChild ? possibleChild.getIdentity() : possibleChild.value;
  if (eq(pId, pcId)) return true;
  for (const c5 of breadthFirst(parent, maxDepth)) {
    const cId = `getIdentity` in c5 ? c5.getIdentity() : c5.value;
    if (eq(c5, possibleChild)) return true;
    if (eq(cId, pcId)) return true;
  }
  return false;
};
var hasChildValue = (parent, possibleValue, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return false;
  if (eq(parent.getValue(), possibleValue)) return true;
  for (const c5 of breadthFirst(parent, maxDepth)) {
    const v3 = c5.getValue();
    if (eq(v3, possibleValue)) return true;
  }
  return false;
};
function* siblings(node) {
  const p3 = node.getParent();
  if (p3 === void 0) return;
  for (const s3 of p3.children()) {
    if (s3 === node) continue;
    yield s3;
  }
}
function* parents(node) {
  if (isTraversable(node)) {
    let p3 = node.getParent();
    while (p3 !== void 0) {
      yield p3;
      p3 = p3.getParent();
    }
  } else {
    let p3 = node.parent;
    while (p3 !== void 0) {
      yield p3;
      p3 = p3.parent;
    }
  }
}
function findAnyChildByValue(parent, possibleValue, eq = isEqualDefault) {
  return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);
}
function findChildByValue(parent, possibleValue, eq = isEqualDefault, maxDepth = 0) {
  if (maxDepth < 0) return;
  const isTraver = isTraversable(parent);
  if (isTraver) {
    if (eq(parent.getValue(), possibleValue)) return parent;
  } else if (eq(parent.value, possibleValue)) return parent;
  for (const d3 of breadthFirst(parent, maxDepth)) if (isTraver) {
    if (eq(d3.getValue(), possibleValue)) return d3;
  } else if (eq(d3.value, possibleValue)) return d3;
  return;
}
function* depthFirst(root$1) {
  if (!root$1) return;
  const stack = new StackMutable();
  let entry = root$1;
  while (entry) {
    const entries2 = isTraversable(entry) ? [...entry.children()] : [...entry.childrenStore];
    stack.push(...entries2);
    if (stack.isEmpty) break;
    entry = stack.pop();
    if (entry) yield entry;
  }
}
function* breadthFirst(root$1, depth = Number.MAX_SAFE_INTEGER) {
  if (!root$1) return;
  const isTrav = isTraversable(root$1);
  const queue = isTrav ? new QueueMutable2() : new QueueMutable2();
  let entry = root$1;
  while (entry) {
    if (depth < 0) return;
    if (entry !== void 0) {
      const kids = `childrenStore` in entry ? entry.childrenStore : entry.children();
      for (const c5 of kids) {
        yield c5;
        queue.enqueue(c5);
      }
    }
    entry = queue.dequeue();
    depth--;
  }
}
function find2(root$1, predicate, order = `breadth`) {
  if (predicate(root$1)) return root$1;
  const iter = order === `breadth` ? breadthFirst : depthFirst;
  for (const c5 of iter(root$1)) if (predicate(c5)) return c5;
}
function findByValue(root$1, predicate, order = `breadth`) {
  if (predicate(root$1.getValue())) return root$1;
  const iter = order === `breadth` ? breadthFirst : depthFirst;
  for (const c5 of iter(root$1)) if (predicate(c5.getValue())) return c5;
}
function* followValue(root$1, continuePredicate, depth = 1) {
  for (const c5 of root$1.children()) if (continuePredicate(c5.getValue(), depth)) {
    yield c5.getValue();
    yield* followValue(c5, continuePredicate, depth + 1);
  }
}
function toStringDeep(node, depth = 0) {
  if (node === void 0) return `(undefined)`;
  if (node === null) return `(null)`;
  const v3 = node.getValue();
  let type = typeof v3;
  if (Array.isArray(v3)) type = `array`;
  let t6 = `  `.repeat(depth) + `value: ${JSON.stringify(v3)} (${type})
`;
  for (const n6 of node.children()) t6 += toStringDeep(n6, depth + 1);
  return t6;
}
function toString(...nodes) {
  let t6 = ``;
  for (const node of nodes) {
    const v3 = node.getValue();
    const vString = toStringAbbreviate(v3);
    const children$2 = [...node.children()];
    const parent = node.getParent();
    let type = typeof v3;
    if (Array.isArray(v3)) type = `array`;
    t6 += `value: ${vString} (${type}) kids: ${children$2.length} parented: ${parent ? `y` : `n`}
`;
  }
  return t6;
}
var tree_exports = {};
__export(tree_exports, {
  FromObject: () => traverse_object_exports,
  Mutable: () => tree_mutable_exports,
  Pathed: () => pathed_exports,
  Traverse: () => traversable_tree_exports,
  compare: () => compare,
  isTraversable: () => isTraversable,
  isTreeNode: () => isTreeNode,
  toTraversable: () => toTraversable
});
var toTraversable = (node) => {
  if (isTraversable(node)) return node;
  if (isTreeNode(node)) return asDynamicTraversable$1(node);
  if (typeof node === `object`) return asDynamicTraversable(node);
  throw new Error(`Parameter 'node' not convertible`);
};
var isTreeNode = (node) => {
  if (`parent` in node && `childrenStore` in node && `value` in node) {
    if (Array.isArray(node.childrenStore)) return true;
  }
  return false;
};
var isTraversable = (node) => {
  return `children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node;
};
var StackImmutable = class StackImmutable2 {
  opts;
  data;
  constructor(opts = {}, data = []) {
    this.opts = opts;
    this.data = data;
  }
  push(...toAdd) {
    return new StackImmutable2(this.opts, push(this.opts, this.data, ...toAdd));
  }
  pop() {
    return new StackImmutable2(this.opts, pop(this.opts, this.data));
  }
  forEach(fn2) {
    this.data.forEach(fn2);
  }
  forEachFromTop(fn2) {
    [...this.data].reverse().forEach(fn2);
  }
  get isEmpty() {
    return isEmpty$1(this.opts, this.data);
  }
  get isFull() {
    return isFull$1(this.opts, this.data);
  }
  get peek() {
    return peek$1(this.opts, this.data);
  }
  get length() {
    return this.data.length;
  }
};
var immutable$3 = (options = {}, ...startingItems) => new StackImmutable({ ...options }, [...startingItems]);
var stack_exports = {};
__export(stack_exports, {
  StackImmutable: () => StackImmutable,
  StackMutable: () => StackMutable,
  immutable: () => immutable$3,
  isEmpty: () => isEmpty$1,
  isFull: () => isFull$1,
  mutable: () => mutable$3,
  peek: () => peek$1,
  pop: () => pop,
  push: () => push,
  trimStack: () => trimStack
});
var mutable$2 = (keyString) => new SetStringMutable(keyString);
var SetStringMutable = class extends SimpleEventEmitter {
  store = /* @__PURE__ */ new Map();
  keyString;
  /**
  * Constructor
  * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`
  */
  constructor(keyString) {
    super();
    this.keyString = keyString ?? defaultKeyer;
  }
  /**
  * Number of items stored in set
  */
  get size() {
    return this.store.size;
  }
  /**
  * Adds one or more items to set. `add` event is fired for each item
  * @param values items to add
  */
  add(...values3) {
    let somethingAdded = false;
    for (const value$1 of values3) {
      const isUpdated = this.has(value$1);
      this.store.set(this.keyString(value$1), value$1);
      super.fireEvent(`add`, {
        value: value$1,
        updated: isUpdated
      });
      if (!isUpdated) somethingAdded = true;
    }
    return somethingAdded;
  }
  /**
  * Returns values from set as an iterable
  * @returns
  */
  values() {
    return this.store.values();
  }
  /**
  * Clear items from set
  */
  clear() {
    this.store.clear();
    super.fireEvent(`clear`, true);
  }
  /**
  * Delete value from set.
  * @param v Value to delete
  * @returns _True_ if item was found and removed
  */
  delete(v3) {
    const isDeleted = this.store.delete(this.keyString(v3));
    if (isDeleted) super.fireEvent(`delete`, v3);
    return isDeleted;
  }
  /**
  * Returns _true_ if item exists in set
  * @param v
  * @returns
  */
  has(v3) {
    return this.store.has(this.keyString(v3));
  }
  /**
  * Returns array copy of set
  * @returns Array copy of set
  */
  toArray() {
    return [...this.store.values()];
  }
};
var SetStringImmutable = class SetStringImmutable2 {
  store;
  keyString;
  constructor(keyString, map$12) {
    this.store = map$12 ?? /* @__PURE__ */ new Map();
    this.keyString = keyString ?? defaultKeyer;
  }
  get size() {
    return this.store.size;
  }
  add(...values3) {
    const s3 = new Map(this.store);
    for (const v3 of values3) {
      const key = this.keyString(v3);
      s3.set(key, v3);
    }
    return new SetStringImmutable2(this.keyString, s3);
  }
  delete(v3) {
    const s3 = new Map(this.store);
    const key = this.keyString(v3);
    if (s3.delete(key)) return new SetStringImmutable2(this.keyString, s3);
    return this;
  }
  has(v3) {
    const key = this.keyString(v3);
    return this.store.has(key);
  }
  toArray() {
    return [...this.store.values()];
  }
  *values() {
    yield* this.store.values();
  }
};
var immutable$2 = (keyString = toStringDefault) => new SetStringImmutable(keyString);
var MassiveSet = class MassiveSet2 {
  #depth;
  #maxDepth;
  children = /* @__PURE__ */ new Map();
  values = [];
  constructor(maxDepth = 1, depth = 0) {
    this.#depth = depth;
    this.#maxDepth = maxDepth;
  }
  /**
  * Returns the number of values stored in just this level of the set
  * @returns 
  */
  sizeLocal() {
    return this.values.length;
  }
  /**
  * Returns the number of branches at this node
  * Use {@link sizeChildrenDeep} to count all branches recursively
  * @returns 
  */
  sizeChildren() {
    return [...this.children.values()].length;
  }
  sizeChildrenDeep() {
    let t6 = this.sizeChildren();
    for (const c5 of this.children.values()) t6 += c5.sizeChildrenDeep();
    return t6;
  }
  /**
  * Returns the total number of values stored in the set
  */
  size() {
    let x3 = this.values.length;
    for (const set$13 of this.children.values()) x3 += set$13.size();
    return x3;
  }
  add(value$1) {
    if (typeof value$1 !== `string`) throw new Error(`Param 'value' must be a string. Got: ${typeof value$1}`);
    if (value$1.length === 0) throw new Error(`Param 'value' is empty`);
    const destination = this.#getChild(value$1, true);
    if (destination === this) {
      if (!this.hasLocal(value$1)) this.values.push(value$1);
      return;
    }
    if (!destination) throw new Error(`Could not create child set for: ${value$1}`);
    destination.add(value$1);
  }
  remove(value$1) {
    if (typeof value$1 !== `string`) throw new Error(`Param 'value' must be a string. Got: ${typeof value$1}`);
    if (value$1.length === 0) throw new Error(`Param 'value' is empty`);
    const destination = this.#getChild(value$1, false);
    if (destination === void 0) return false;
    if (destination === this) {
      if (this.hasLocal(value$1)) {
        this.values = this.values.filter((v3) => v3 !== value$1);
        return true;
      }
      return false;
    }
    return destination.remove(value$1);
  }
  debugDump() {
    const r5 = this.#dumpToArray();
    for (const rr2 of r5) console.log(rr2);
  }
  #dumpToArray(depth = 0) {
    const r5 = [];
    r5.push(`Depth: ${this.#depth} Max: ${this.#maxDepth}`);
    for (const [key, value$1] of this.children.entries()) {
      const dumped = value$1.#dumpToArray(depth + 1);
      r5.push(` key: ${key}`);
      for (const d3 of dumped) r5.push(` `.repeat(depth + 1) + d3);
    }
    r5.push(`Values: (${this.values.length})`);
    for (const v3 of this.values) r5.push(` ${v3}`);
    return r5.map((line3) => ` `.repeat(depth) + line3);
  }
  #getChild(value$1, create$32) {
    if (value$1 === void 0) throw new Error(`Param 'value' undefined`);
    if (this.#depth === this.#maxDepth) return this;
    if (value$1.length <= this.#depth) return this;
    const k3 = value$1[this.#depth];
    if (k3 === void 0) throw new Error(`Logic error. Depth: ${this.#depth} Len: ${value$1.length}`);
    let child = this.children.get(k3);
    if (child === void 0 && create$32) {
      child = new MassiveSet2(this.#maxDepth, this.#depth + 1);
      this.children.set(k3, child);
    }
    return child;
  }
  /**
  * Returns _true_ if `value` stored on this node
  * @param value 
  * @returns 
  */
  hasLocal(value$1) {
    for (const v3 of this.values) if (v3 === value$1) return true;
    return false;
  }
  has(value$1) {
    if (typeof value$1 !== `string`) return false;
    const destination = this.#getChild(value$1, false);
    if (destination === void 0) return false;
    if (destination === this) return this.hasLocal(value$1);
    return destination.has(value$1);
  }
};
var set_exports = {};
__export(set_exports, {
  MassiveSet: () => MassiveSet,
  SetStringImmutable: () => SetStringImmutable,
  SetStringMutable: () => SetStringMutable,
  immutable: () => immutable$2,
  mutable: () => mutable$2
});
var PriorityMutable = class extends QueueMutable2 {
  constructor(opts = {}) {
    if (opts.eq === void 0) opts = {
      ...opts,
      eq: (a3, b3) => {
        return isEqualDefault(a3.item, b3.item);
      }
    };
    super(opts);
  }
  /**
  * Adds an item with a given priority
  * @param item Item
  * @param priority Priority (higher numeric value means higher priority)
  */
  enqueueWithPriority(item, priority$1) {
    resultThrow(numberTest(priority$1, `positive`));
    super.enqueue({
      item,
      priority: priority$1
    });
  }
  changePriority(item, priority$1, addIfMissing = false, eq) {
    if (item === void 0) throw new Error(`Item cannot be undefined`);
    let toDelete;
    for (const d3 of this.data) if (eq) {
      if (eq(d3.item, item)) {
        toDelete = d3;
        break;
      }
    } else if (this.eq(d3, {
      item,
      priority: 0
    })) {
      toDelete = d3;
      break;
    }
    if (toDelete === void 0 && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(item)}`);
    if (toDelete !== void 0) this.removeWhere((item$1) => toDelete === item$1);
    this.enqueueWithPriority(item, priority$1);
  }
  dequeueMax() {
    const m4 = last(max$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    this.removeWhere((item) => item === m4);
    return m4.item;
  }
  dequeueMin() {
    const m4 = last(max$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    this.removeWhere((item) => item.item === m4);
    return m4.item;
  }
  peekMax() {
    const m4 = last(max$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    return m4.item;
  }
  peekMin() {
    const m4 = last(min$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    return m4.item;
  }
};
function priority(opts = {}) {
  return new PriorityMutable(opts);
}
var QueueImmutable = class QueueImmutable2 {
  opts;
  #data;
  /**
  * Creates an instance of Queue.
  * @param {QueueOpts} opts Options foor queue
  * @param {V[]} data Initial data. Index 0 is front of queue
  */
  constructor(opts = {}, data = []) {
    if (opts === void 0) throw new Error(`opts parameter undefined`);
    this.opts = opts;
    this.#data = data;
  }
  forEach(fn2) {
    for (let index = this.#data.length - 1; index >= 0; index--) fn2(this.#data[index]);
  }
  forEachFromFront(fn2) {
    this.#data.forEach((item) => {
      fn2(item);
    });
  }
  enqueue(...toAdd) {
    return new QueueImmutable2(this.opts, enqueue(this.opts, this.#data, ...toAdd));
  }
  dequeue() {
    return new QueueImmutable2(this.opts, dequeue(this.opts, this.#data));
  }
  get isEmpty() {
    return isEmpty(this.opts, this.#data);
  }
  get isFull() {
    return isFull(this.opts, this.#data);
  }
  get length() {
    return this.#data.length;
  }
  get peek() {
    return peek(this.opts, this.#data);
  }
  toArray() {
    return [...this.#data];
  }
};
var immutable$1 = (options = {}, ...startingItems) => {
  options = { ...options };
  return new QueueImmutable(options, [...startingItems]);
};
var queue_exports = {};
__export(queue_exports, {
  PriorityMutable: () => PriorityMutable,
  QueueImmutable: () => QueueImmutable,
  QueueMutable: () => QueueMutable2,
  debug: () => debug,
  dequeue: () => dequeue,
  enqueue: () => enqueue,
  immutable: () => immutable$1,
  isEmpty: () => isEmpty,
  isFull: () => isFull,
  mutable: () => mutable$1,
  peek: () => peek,
  priority: () => priority,
  trimQueue: () => trimQueue
});
var create = (options = {}) => new ExpiringMap(options);
var ExpiringMap = class extends SimpleEventEmitter {
  capacity;
  store;
  evictPolicy;
  autoDeleteElapsedMs;
  autoDeletePolicy;
  autoDeleteTimer;
  disposed = false;
  constructor(opts = {}) {
    super();
    this.capacity = opts.capacity ?? -1;
    resultThrow(integerTest(this.capacity, `nonZero`, `capacity`));
    this.store = /* @__PURE__ */ new Map();
    if (opts.evictPolicy && this.capacity <= 0) throw new Error(`evictPolicy is set, but no capacity limit is set`);
    this.evictPolicy = opts.evictPolicy ?? `none`;
    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;
    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;
    if (this.autoDeleteElapsedMs > 0) this.autoDeleteTimer = setInterval(() => {
      this.#maintain();
    }, Math.max(1e3, this.autoDeleteElapsedMs * 2));
  }
  dispose() {
    if (this.disposed) return;
    this.disposed = true;
    if (this.autoDeleteTimer) {
      clearInterval(this.autoDeleteTimer);
      this.autoDeleteTimer = void 0;
    }
  }
  /**
  * Returns the number of keys being stored.
  */
  get keyLength() {
    return this.store.size;
  }
  *entries() {
    for (const entry of this.store.entries()) yield [entry[0], entry[1].value];
  }
  *values() {
    for (const v3 of this.store.values()) yield v3.value;
  }
  *keys() {
    yield* this.store.keys();
  }
  /**
  * Returns the elapsed time since `key`
  * was set. Returns _undefined_ if `key`
  * does not exist
  */
  elapsedSet(key) {
    const v3 = this.store.get(key);
    if (typeof v3 === `undefined`) return;
    return Date.now() - v3.lastSet;
  }
  /**
  * Returns the elapsed time since `key`
  * was accessed. Returns _undefined_ if `key`
  * does not exist
  */
  elapsedGet(key) {
    const v3 = this.store.get(key);
    if (typeof v3 === `undefined`) return;
    return Date.now() - v3.lastGet;
  }
  /**
  * Returns true if `key` is stored.
  * Does not affect the key's last access time.
  * @param key
  * @returns
  */
  has(key) {
    return this.store.has(key);
  }
  /**
  * Gets an item from the map by key, returning
  * undefined if not present
  * @param key Key
  * @returns Value, or undefined
  */
  get(key) {
    const v3 = this.store.get(key);
    if (v3) {
      if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) this.store.set(key, {
        ...v3,
        lastGet: performance.now()
      });
      return v3.value;
    }
  }
  /**
  * Deletes the value under `key`, if present.
  *
  * Returns _true_ if something was removed.
  * @param key
  * @returns
  */
  delete(key) {
    const value$1 = this.store.get(key);
    if (!value$1) return false;
    const d3 = this.store.delete(key);
    this.fireEvent(`removed`, {
      key,
      value: value$1.value
    });
    return d3;
  }
  /**
  * Clears the contents of the map.
  * Note: does not fire `removed` event
  */
  clear() {
    this.store.clear();
  }
  /**
  * Updates the lastSet/lastGet time for a value
  * under `k`.
  *
  * Returns false if key was not found
  * @param key
  * @returns
  */
  touch(key) {
    const v3 = this.store.get(key);
    if (!v3) return false;
    this.store.set(key, {
      ...v3,
      lastSet: Date.now(),
      lastGet: Date.now()
    });
    return true;
  }
  findEvicteeKey() {
    if (this.evictPolicy === `none`) return;
    let sortBy = ``;
    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;
    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;
    else throw new Error(`Unknown eviction policy ${this.evictPolicy}`);
    const sorted = sortByValueProperty(this.store, sortBy);
    return sorted[0][0];
  }
  #maintain() {
    if (this.autoDeletePolicy === `none`) return;
    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);
  }
  /**
  * Deletes all values where elapsed time has past
  * for get/set or either.
  * ```js
  * // Delete all keys (and associated values) not accessed for a minute
  * em.deleteWithElapsed({mins:1}, `get`);
  * // Delete things that were set 1s ago
  * em.deleteWithElapsed(1000, `set`);
  * ```
  * 
  * @param interval Interval
  * @param property Basis for deletion 'get','set' or 'either'
  * @returns Items removed
  */
  deleteWithElapsed(interval2, property) {
    const entries2 = [...this.store.entries()];
    const prune = [];
    const intervalMs = intervalToMs(interval2, 1e3);
    const now = performance.now();
    for (const entry of entries2) {
      const elapsedGet = now - entry[1].lastGet;
      const elapsedSet = now - entry[1].lastSet;
      const elapsed2 = property === `get` ? elapsedGet : property === `set` ? elapsedSet : Math.max(elapsedGet, elapsedSet);
      if (elapsed2 >= intervalMs) prune.push([entry[0], entry[1].value]);
    }
    for (const entry of prune) {
      this.store.delete(entry[0]);
      const eventArguments = {
        key: entry[0],
        value: entry[1]
      };
      this.fireEvent(`expired`, eventArguments);
      this.fireEvent(`removed`, eventArguments);
    }
    return prune;
  }
  /**
  * Sets the `key` to be `value`.
  *
  * If the key already exists, it is updated.
  *
  * If the map is full, according to its capacity,
  * another value is selected for removal.
  * @param key
  * @param value
  * @returns
  */
  set(key, value$1) {
    const existing = this.store.get(key);
    if (existing) {
      this.store.set(key, {
        ...existing,
        lastSet: performance.now()
      });
      return;
    }
    if (this.keyLength === this.capacity && this.capacity > 0) {
      const key$1 = this.findEvicteeKey();
      if (!key$1) throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);
      const existing$1 = this.store.get(key$1);
      this.store.delete(key$1);
      if (existing$1) {
        const eventArguments = {
          key: key$1,
          value: existing$1.value
        };
        this.fireEvent(`expired`, eventArguments);
        this.fireEvent(`removed`, eventArguments);
      }
    }
    this.store.set(key, {
      lastGet: 0,
      lastSet: performance.now(),
      value: value$1
    });
    this.fireEvent(`newKey`, {
      key,
      value: value$1
    });
  }
};
var firstEntry = (map$12, predicate) => {
  for (const e5 of map$12.entries()) {
    const value$1 = e5[1];
    for (const subValue of value$1) if (predicate(subValue, e5[0])) return e5;
  }
};
var lengthMax = (map$12) => {
  let largest = ["", 0];
  for (const e5 of map$12.keysAndCounts()) if (e5[1] > largest[1]) largest = e5;
  return largest[1];
};
var firstEntryByValue = (map$12, value$1, isEqual4 = isEqualDefault) => {
  for (const e5 of map$12.entries()) {
    const value_ = e5[1];
    for (const subValue of value_) if (isEqual4(subValue, value$1)) return e5;
  }
};
var MapOfSimpleBase = class {
  map;
  groupBy;
  valueEq;
  /**
  * Constructor
  * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify
  * @param valueEq Compare values. By default uses JS logic for equality
  */
  constructor(groupBy2 = defaultKeyer, valueEq = isEqualDefault, initial = []) {
    this.groupBy = groupBy2;
    this.valueEq = valueEq;
    this.map = new Map(initial);
  }
  /**
  * Returns _true_ if `key` exists
  * @param key
  * @returns
  */
  has(key) {
    return this.map.has(key);
  }
  /**
  * Returns _true_ if `value` exists under `key`.
  * @param key Key
  * @param value Value to seek under `key`
  * @returns _True_ if `value` exists under `key`.
  */
  hasKeyValue(key, value$1) {
    const values3 = this.map.get(key);
    if (!values3) return false;
    for (const v3 of values3) if (this.valueEq(v3, value$1)) return true;
    return false;
  }
  /**
  * Debug dump of contents
  * @returns
  */
  debugString() {
    let r5 = ``;
    const keys = [...this.map.keys()];
    keys.every((k3) => {
      const v3 = this.map.get(k3);
      if (v3 === void 0) return;
      r5 += k3 + ` (${v3.length}) = ${JSON.stringify(v3)}\r
`;
    });
    return r5;
  }
  /**
  * Return number of values stored under `key`.
  * Returns 0 if `key` is not found.
  * @param key
  * @returns
  */
  count(key) {
    const values3 = this.map.get(key);
    if (!values3) return 0;
    return values3.length;
  }
  /**
  * Returns first key that contains `value`
  * @param value 
  * @param eq 
  * @returns 
  */
  firstKeyByValue(value$1, eq = isEqualDefault) {
    const entry = firstEntryByValue(this, value$1, eq);
    if (entry) return entry[0];
  }
  /**
  * Iterate over all entries
  */
  *entriesFlat() {
    for (const key of this.map.keys()) for (const value$1 of this.map.get(key)) yield [key, value$1];
  }
  /**
  * Iterate over keys and array of values for that key
  */
  *entries() {
    for (const [k3, v3] of this.map.entries()) yield [k3, [...v3]];
  }
  /**
  * Get all values under `key`
  * @param key
  * @returns
  */
  *get(key) {
    const m4 = this.map.get(key);
    if (!m4) return;
    yield* m4.values();
  }
  /**
  * Iterate over all keys
  */
  *keys() {
    yield* this.map.keys();
  }
  /**
  * Iterate over all values (regardless of key).
  * Use {@link values} to iterate over a set of values per key
  */
  *valuesFlat() {
    for (const entries2 of this.map) yield* entries2[1];
  }
  /**
  * Yields the values for each key in sequence, returning an array.
  * Use {@link valuesFlat} to iterate over all keys regardless of key.
  */
  *values() {
    for (const entries2 of this.map) yield entries2[1];
  }
  /**
  * Iterate over keys and length of values stored under keys
  */
  *keysAndCounts() {
    for (const entries2 of this.map) yield [entries2[0], entries2[1].length];
  }
  /**
  * Returns the count of keys.
  */
  get lengthKeys() {
    return this.map.size;
  }
  /**
  * _True_ if empty
  */
  get isEmpty() {
    return this.map.size === 0;
  }
};
var MapOfSimpleMutable = class extends MapOfSimpleBase {
  addKeyedValues(key, ...values3) {
    const existing = this.map.get(key);
    if (existing === void 0) this.map.set(key, values3);
    else this.map.set(key, [...existing, ...values3]);
  }
  /**
  * Set `values` to `key`.
  * Previous data stored under `key` is thrown away.
  * @param key 
  * @param values 
  */
  setValues(key, values3) {
    this.map.set(key, values3);
  }
  /**
  * Adds a value, automatically extracting a key via the
  * `groupBy` function assigned in the constructor options.
  * @param values Adds several values
  */
  addValue(...values3) {
    for (const v3 of values3) {
      const key = this.groupBy(v3);
      this.addKeyedValues(key, v3);
    }
  }
  /**
  * Delete `value` under a particular `key`
  * @param key
  * @param value
  * @returns _True_ if `value` was found under `key`
  */
  deleteKeyValue(key, value$1) {
    const existing = this.map.get(key);
    if (existing === void 0) return false;
    const without$1 = existing.filter((existingValue) => !this.valueEq(existingValue, value$1));
    this.map.set(key, without$1);
    return without$1.length < existing.length;
  }
  /**
  * Deletes `value` regardless of key.
  *
  * Uses the constructor-defined equality function.
  * @param value Value to delete
  * @returns
  */
  deleteByValue(value$1) {
    let del$1 = false;
    const entries2 = [...this.map.entries()];
    for (const keyEntries of entries2) for (const values3 of keyEntries[1]) if (this.valueEq(values3, value$1)) {
      del$1 = true;
      this.deleteKeyValue(keyEntries[0], value$1);
    }
    return del$1;
  }
  /**
  * Deletes all values under `key`,
  * @param key
  * @returns _True_ if `key` was found and values stored
  */
  delete(key) {
    const values3 = this.map.get(key);
    if (!values3) return false;
    if (values3.length === 0) return false;
    this.map.delete(key);
    return true;
  }
  /**
  * Clear contents
  */
  clear() {
    this.map.clear();
  }
};
var ofSimpleMutable = (groupBy2 = defaultKeyer, valueEq = isEqualDefault) => new MapOfSimpleMutable(groupBy2, valueEq);
var addArray = (map$12, data) => {
  const x3 = new Map(map$12.entries());
  for (const d3 of data) {
    if (d3[0] === void 0) throw new Error(`key cannot be undefined`);
    if (d3[1] === void 0) throw new Error(`value cannot be undefined`);
    x3.set(d3[0], d3[1]);
  }
  return x3;
};
var addObjects = (map$12, data) => {
  const x3 = new Map(map$12.entries());
  for (const d3 of data) {
    if (d3.key === void 0) throw new Error(`key cannot be undefined`);
    if (d3.value === void 0) throw new Error(`value cannot be undefined`);
    x3.set(d3.key, d3.value);
  }
  return x3;
};
var has = (map$12, key) => map$12.has(key);
var add = (map$12, ...data) => {
  if (map$12 === void 0) throw new Error(`map parameter is undefined`);
  if (data === void 0) throw new Error(`data parameter i.s undefined`);
  if (data.length === 0) return map$12;
  const firstRecord = data[0];
  const isObject = typeof firstRecord.key !== `undefined` && typeof firstRecord.value !== `undefined`;
  return isObject ? addObjects(map$12, data) : addArray(map$12, data);
};
var set = (map$12, key, value$1) => {
  const x3 = new Map(map$12.entries());
  x3.set(key, value$1);
  return x3;
};
var del = (map$12, key) => {
  const x3 = new Map(map$12.entries());
  x3.delete(key);
  return x3;
};
var immutable2 = (dataOrMap) => {
  if (dataOrMap === void 0) return immutable2([]);
  if (Array.isArray(dataOrMap)) return immutable2(add(/* @__PURE__ */ new Map(), ...dataOrMap));
  const data = dataOrMap;
  return {
    add: (...itemsToAdd) => {
      const s3 = add(data, ...itemsToAdd);
      return immutable2(s3);
    },
    set: (key, value$1) => {
      const s3 = set(data, key, value$1);
      return immutable2(s3);
    },
    get: (key) => data.get(key),
    delete: (key) => immutable2(del(data, key)),
    clear: () => immutable2(),
    has: (key) => data.has(key),
    entries: () => data.entries(),
    values: () => data.values(),
    isEmpty: () => data.size === 0
  };
};
var mutable = (...data) => {
  let m4 = add(/* @__PURE__ */ new Map(), ...data);
  return {
    add: (...data$1) => {
      m4 = add(m4, ...data$1);
    },
    delete: (key) => {
      m4 = del(m4, key);
    },
    clear: () => {
      m4 = add(/* @__PURE__ */ new Map());
    },
    set: (key, value$1) => {
      m4 = set(m4, key, value$1);
    },
    get: (key) => m4.get(key),
    entries: () => m4.entries(),
    values: () => m4.values(),
    isEmpty: () => m4.size === 0,
    has: (key) => has(m4, key)
  };
};
var MapOfMutableImpl = class extends SimpleEventEmitter {
  #map = /* @__PURE__ */ new Map();
  groupBy;
  type;
  constructor(type, opts = {}) {
    super();
    this.type = type;
    this.groupBy = opts.groupBy ?? toStringDefault;
  }
  /**
  * Returns the type name. For in-built implementations, it will be one of: array, set or circular
  */
  get typeName() {
    return this.type.name;
  }
  /**
  * Returns the number of keys
  */
  get lengthKeys() {
    return this.#map.size;
  }
  /**
  * Returns the length of the longest child list
  */
  get lengthMax() {
    let m4 = 0;
    for (const v3 of this.#map.values()) m4 = Math.max(m4, this.type.count(v3));
    return m4;
  }
  debugString() {
    const keys = [...this.#map.keys()];
    let r5 = `Keys: ${keys.join(`, `)}\r
`;
    for (const k3 of keys) {
      const v3 = this.#map.get(k3);
      if (v3 === void 0) r5 += ` - ${k3} (undefined)\r
`;
      else {
        const asArray2 = this.type.toArray(v3);
        if (asArray2 !== void 0) r5 += ` - ${k3} (${this.type.count(v3)}) = ${JSON.stringify(asArray2)}\r
`;
      }
    }
    return r5;
  }
  get isEmpty() {
    return this.#map.size === 0;
  }
  clear() {
    this.#map.clear();
    super.fireEvent(`clear`, true);
  }
  addKeyedValues(key, ...values3) {
    const set$13 = this.#map.get(key);
    if (set$13 === void 0) {
      this.#map.set(key, this.type.addKeyedValues(void 0, values3));
      super.fireEvent(`addedKey`, { key });
      super.fireEvent(`addedValues`, { values: values3 });
    } else {
      this.#map.set(key, this.type.addKeyedValues(set$13, values3));
      super.fireEvent(`addedValues`, { values: values3 });
    }
  }
  set(key, values3) {
    this.addKeyedValues(key, ...values3);
    return this;
  }
  addValue(...values3) {
    for (const v3 of values3) this.addKeyedValues(this.groupBy(v3), v3);
  }
  hasKeyValue(key, value$1, eq) {
    const m4 = this.#map.get(key);
    if (m4 === void 0) return false;
    return this.type.has(m4, value$1, eq);
  }
  has(key) {
    return this.#map.has(key);
  }
  deleteKeyValue(key, value$1) {
    const a3 = this.#map.get(key);
    if (a3 === void 0) return false;
    return this.deleteKeyValueFromMap(a3, key, value$1);
  }
  deleteKeyValueFromMap(map$12, key, value$1) {
    const preCount = this.type.count(map$12);
    const filtered = this.type.without(map$12, value$1);
    const postCount = filtered.length;
    this.#map.set(key, this.type.addKeyedValues(void 0, filtered));
    return preCount > postCount;
  }
  deleteByValue(value$1) {
    let something = false;
    [...this.#map.keys()].filter((key) => {
      const a3 = this.#map.get(key);
      if (!a3) throw new Error(`Bug: map could not be accessed`);
      if (this.deleteKeyValueFromMap(a3, key, value$1)) {
        something = true;
        if (this.count(key) === 0) this.delete(key);
      }
    });
    return something;
  }
  delete(key) {
    const a3 = this.#map.get(key);
    if (a3 === void 0) return false;
    this.#map.delete(key);
    this.fireEvent(`deleteKey`, { key });
    return true;
  }
  firstKeyByValue(value$1, eq = isEqualDefault) {
    const keys = [...this.#map.keys()];
    const found = keys.find((key) => {
      const a3 = this.#map.get(key);
      if (a3 === void 0) throw new Error(`Bug: map could not be accessed`);
      const r5 = this.type.has(a3, value$1, eq);
      return r5;
    });
    return found;
  }
  count(key) {
    const entry = this.#map.get(key);
    if (entry === void 0) return 0;
    return this.type.count(entry);
  }
  /**
  * Iterates over values stored under `key`
  * An empty array is returned if there are no values
  */
  *get(key) {
    const m4 = this.#map.get(key);
    if (m4 === void 0) return;
    yield* this.type.iterable(m4);
  }
  /**
  * Iterate over the values stored under `key`.
  * If key does not exist, iteration is essentially a no-op
  * @param key
  * @returns
  */
  *valuesFor(key) {
    const m4 = this.#map.get(key);
    if (m4 === void 0) return;
    yield* this.type.iterable(m4);
  }
  getSource(key) {
    return this.#map.get(key);
  }
  *keys() {
    yield* this.#map.keys();
  }
  *entriesFlat() {
    for (const entry of this.#map.entries()) for (const v3 of this.type.iterable(entry[1])) yield [entry[0], v3];
  }
  *valuesFlat() {
    for (const entry of this.#map.entries()) yield* this.type.iterable(entry[1]);
  }
  *entries() {
    for (const [k3, v3] of this.#map.entries()) {
      const temporary = [...this.type.iterable(v3)];
      yield [k3, temporary];
    }
  }
  *keysAndCounts() {
    for (const key of this.keys()) yield [key, this.count(key)];
  }
  merge(other) {
    for (const key of other.keys()) {
      const data = other.get(key);
      this.addKeyedValues(key, ...data);
    }
  }
  get size() {
    return this.#map.size;
  }
  get [Symbol.toStringTag]() {
    return this.#map[Symbol.toStringTag];
  }
};
var ofSetMutable = (options) => {
  const hash = options?.hash ?? toStringDefault;
  const comparer = (a3, b3) => hash(a3) === hash(b3);
  const t6 = {
    get name() {
      return `set`;
    },
    iterable: (source) => source.values(),
    addKeyedValues: (dest, values3) => addValue(dest, hash, `skip`, ...values3),
    count: (source) => source.size,
    find: (source, predicate) => findValue(source, predicate),
    filter: (source, predicate) => filterValues(source, predicate),
    toArray: (source) => toArray(source),
    has: (source, value$1) => hasAnyValue(source, value$1, comparer),
    without: (source, value$1) => without(toArray(source), value$1, comparer)
  };
  const m4 = new MapOfMutableImpl(t6, options);
  return m4;
};
var ofCircularMutable = (options) => {
  const comparer = isEqualDefault;
  const t6 = {
    get name() {
      return `circular`;
    },
    addKeyedValues: (destination, values3) => {
      let ca2 = destination ?? new CircularArray(options.capacity);
      for (const v3 of values3) ca2 = ca2.add(v3);
      return ca2;
    },
    count: (source) => source.length,
    find: (source, predicate) => source.find(predicate),
    filter: (source, predicate) => source.filter(predicate),
    toArray: (source) => source,
    iterable: (source) => source.values(),
    has: (source, value$1) => source.find((v3) => comparer(v3, value$1)) !== void 0,
    without: (source, value$1) => source.filter((v3) => !comparer(v3, value$1))
  };
  return new MapOfMutableImpl(t6, options);
};
var NumberMap = class extends Map {
  defaultValue;
  constructor(defaultValue = 0) {
    super();
    this.defaultValue = defaultValue;
  }
  get(key) {
    const v3 = super.get(key);
    if (v3 === void 0) return this.defaultValue;
    return v3;
  }
  reset(key) {
    super.set(key, this.defaultValue);
    return this.defaultValue;
  }
  multiply(key, amount) {
    const v3 = super.get(key);
    let value$1 = v3 ?? this.defaultValue;
    value$1 *= amount;
    super.set(key, value$1);
    return value$1;
  }
  add(key, amount = 1) {
    const v3 = super.get(key);
    let value$1 = v3 ?? this.defaultValue;
    value$1 += amount;
    super.set(key, value$1);
    return value$1;
  }
  subtract(key, amount = 1) {
    const v3 = super.get(key);
    let value$1 = v3 ?? this.defaultValue;
    value$1 -= amount;
    super.set(key, value$1);
    return value$1;
  }
};
var ofArrayMutable = (options = {}) => {
  const convertToString3 = options.convertToString;
  const toStringFunction = typeof convertToString3 === `undefined` ? isEqualDefault : (a3, b3) => convertToString3(a3) === convertToString3(b3);
  const comparer = options.comparer ?? toStringFunction;
  const t6 = {
    get name() {
      return `array`;
    },
    addKeyedValues: (destination, values3) => {
      if (destination === void 0) return [...values3];
      return [...destination, ...values3];
    },
    iterable: (source) => source.values(),
    count: (source) => source.length,
    find: (source, predicate) => source.find((f5) => predicate(f5)),
    filter: (source, predicate) => source.filter((f5) => predicate(f5)),
    toArray: (source) => source,
    has: (source, value$1) => source.some((v3) => comparer(v3, value$1)),
    without: (source, value$1) => source.filter((v3) => !comparer(v3, value$1))
  };
  const m4 = new MapOfMutableImpl(t6, options);
  return m4;
};
var MapOfSimple2 = class MapOfSimple3 extends MapOfSimpleBase {
  addKeyedValues(key, ...values3) {
    return this.addBatch([[key, values3]]);
  }
  addValue(...values3) {
    const asEntries = values3.map((v3) => [this.groupBy(v3), v3]);
    return this.addBatch(asEntries);
  }
  addBatch(entries2) {
    const temporary = new Map([...this.map.entries()].map((e5) => [e5[0], [...e5[1]]]));
    for (const [key, list] of entries2) {
      const existingList = temporary.get(key);
      if (typeof existingList === `undefined`) temporary.set(key, list);
      else existingList.push(...list);
    }
    return new MapOfSimple3(this.groupBy, this.valueEq, [...temporary.entries()]);
  }
  clear() {
    return new MapOfSimple3(this.groupBy, this.valueEq);
  }
  deleteKeyValue(_key, _value) {
    throw new Error(`Method not implemented.`);
  }
  deleteByValue(value$1, eq) {
    const entries2 = [...this.map.entries()];
    const eqFunction = eq ?? this.valueEq;
    const x3 = entries2.map((entry) => {
      const key = entry[0];
      const values3 = entry[1].filter((vv) => !eqFunction(vv, value$1));
      return [key, values3];
    });
    return new MapOfSimple3(this.groupBy, this.valueEq, x3);
  }
  delete(key) {
    const entries2 = [...this.map.entries()].filter((e5) => e5[0] !== key);
    return new MapOfSimple3(this.groupBy, this.valueEq, entries2);
  }
};
var ofSimple = (groupBy2 = defaultKeyer, valueEq = isEqualDefault) => new MapOfSimple2(groupBy2, valueEq);
var map_exports = {};
__export(map_exports, {
  ExpiringMap: () => ExpiringMap,
  MapOfMutableImpl: () => MapOfMutableImpl,
  MapOfSimple: () => MapOfSimple2,
  MapOfSimpleMutable: () => MapOfSimpleMutable,
  NumberMap: () => NumberMap,
  addObjectEntriesMutate: () => addObjectEntriesMutate,
  addValue: () => addValue,
  addValueMutate: () => addValueMutate,
  addValueMutator: () => addValueMutator,
  deleteByValueCompareMutate: () => deleteByValueCompareMutate,
  expiringMap: () => create,
  filterValues: () => filterValues,
  findBySomeKey: () => findBySomeKey,
  findEntryByPredicate: () => findEntryByPredicate,
  findEntryByValue: () => findEntryByValue,
  findValue: () => findValue,
  firstEntry: () => firstEntry,
  firstEntryByValue: () => firstEntryByValue,
  fromIterable: () => fromIterable,
  fromObject: () => fromObject,
  getClosestIntegerKey: () => getClosestIntegerKey,
  getOrGenerate: () => getOrGenerate,
  getOrGenerateSync: () => getOrGenerateSync,
  hasAnyValue: () => hasAnyValue,
  hasKeyValue: () => hasKeyValue,
  immutable: () => immutable2,
  lengthMax: () => lengthMax,
  mapOfSimpleMutable: () => ofSimpleMutable,
  mapToArray: () => mapToArray,
  mapToObjectTransform: () => mapToObjectTransform,
  mergeByKey: () => mergeByKey,
  mutable: () => mutable,
  ofArrayMutable: () => ofArrayMutable,
  ofCircularMutable: () => ofCircularMutable,
  ofSetMutable: () => ofSetMutable,
  ofSimple: () => ofSimple,
  ofSimpleMutable: () => ofSimpleMutable,
  some: () => some,
  sortByValue: () => sortByValue,
  sortByValueProperty: () => sortByValueProperty,
  toArray: () => toArray,
  toObject: () => toObject,
  transformMap: () => transformMap,
  zipKeyValue: () => zipKeyValue
});
var Table = class {
  rows = [];
  rowLabels = [];
  colLabels = [];
  /**
  * Keep track of widest row
  */
  columnMaxLength = 0;
  /**
  * Gets the label for a given column index,
  * returning _undefined_ if not found.
  * 
  * Case-sensitive
  * @param label Label to seek
  * @returns Index of column, or _undefined_ if not found
  */
  getColumnLabelIndex(label) {
    for (const [index, l3] of this.colLabels.entries()) if (l3 === label) return index;
  }
  /**
  * Gets the label for a given row index,
  * returning _undefined_ if not found.
  * 
  * Case-sensitive
  * @param label Label to seek
  * @returns Index of row, or _undefined_ if not found
  */
  getRowLabelIndex(label) {
    for (const [index, l3] of this.rowLabels.entries()) if (l3 === label) return index;
  }
  /**
  * Dumps the values of the table to the console
  */
  print() {
    console.table([...this.rowsWithLabelsObject()]);
  }
  /**
  * Return a copy of table as nested array
  * 
  * ```js
  * const t = new Table();
  * // add stuff
  * // ...
  * const m = t.asArray();
  * for (const row of m) {
  *  for (const colValue of row) {
  *    // iterate over all column values for this row
  *  }
  * }
  * ```
  * 
  * Alternative: get value at row Y and column X
  * ```js
  * const value = m[y][x];
  * ```
  * @returns 
  */
  asArray() {
    const r5 = [];
    for (const row of this.rows) if (row === void 0) r5.push([]);
    else r5.push([...row]);
    return r5;
  }
  /**
  * Return the number of rows
  */
  get rowCount() {
    return this.rows.length;
  }
  /**
  * Return the maximum number of columns in any row
  */
  get columnCount() {
    return this.columnMaxLength;
  }
  /**
  * Iterates over the table row-wise, in object format.
  * @see {@link rowsWithLabelsArray} to get rows in array format
  */
  *rowsWithLabelsObject() {
    for (let index = 0; index < this.rows.length; index++) {
      const labelledRow = this.getRowWithLabelsObject(index);
      yield labelledRow;
    }
  }
  /**
  * Iterates over each row, including the labels if available
  * @see {@link rowsWithLabelsObject} to get rows in object format
  */
  *rowsWithLabelsArray() {
    for (let index = 0; index < this.rows.length; index++) {
      const labelledRow = this.getRowWithLabelsArray(index);
      yield labelledRow;
    }
  }
  /**
  * Assign labels to columns
  * @param labels 
  */
  labelColumns(...labels) {
    this.colLabels = labels;
  }
  /**
  * Assign label to a specific column
  * First column has an index of 0
  * @param columnIndex 
  * @param label 
  */
  labelColumn(columnIndex, label) {
    this.colLabels[columnIndex] = label;
  }
  /**
  * Label rows
  * @param labels Labels 
  */
  labelRows(...labels) {
    this.rowLabels = labels;
  }
  /**
  * Assign label to a specific row
  * First row has an index of 0
  * @param rowIndex 
  * @param label 
  */
  labelRow(rowIndex, label) {
    this.rowLabels[rowIndex] = label;
  }
  /**
  * Adds a new row
  * @param data Columns
  */
  appendRow(...data) {
    this.columnMaxLength = Math.max(this.columnMaxLength, data.length);
    this.rows.push(data);
    return data;
  }
  /**
  * Gets a row along with labels, as an array
  * @param rowIndex 
  * @returns 
  */
  getRowWithLabelsArray(rowIndex) {
    const row = this.rows.at(rowIndex);
    if (row === void 0) return void 0;
    return row.map((value$1, index) => [this.colLabels.at(index), value$1]);
  }
  /**
  * Return a row of objects. Keys use the column labels.
  * 
  * ```js
  * const row = table.getRowWithLabelsObject(10);
  * // eg:
  * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]
  * ```
  * @param rowIndex 
  * @returns 
  */
  getRowWithLabelsObject(rowIndex) {
    const row = this.rows.at(rowIndex);
    if (row === void 0) return void 0;
    const object = {};
    for (let index = 0; index < this.colLabels.length; index++) {
      const label = this.colLabels.at(index) ?? index.toString();
      object[label] = row[index];
    }
    return object;
  }
  /**
  * Gets or creates a row at given position
  * @param row Index or label of row 
  * @returns 
  */
  #getOrCreateRawRow(row) {
    const index = typeof row === `number` ? row : this.getRowLabelIndex(row);
    if (index === void 0) return {
      success: false,
      error: `row-label-notfound`
    };
    if (index < 0) return {
      success: false,
      error: `row-index-invalid`
    };
    if (index < this.rows.length) return {
      success: true,
      value: this.rows[index]
    };
    const newRow = [];
    this.rows[index] = newRow;
    return {
      success: true,
      value: newRow
    };
  }
  /**
  * Gets a copy of values at given row, specified by index or label
  * @param row 
  * @returns Returns row or throws an error if label or index not found 
  */
  row(row) {
    const r5 = this.#getRowRaw(row);
    if (resultIsError(r5)) throw new Error(r5.error);
    return [...r5.value];
  }
  /**
  * Set the value of row,columm.
  * Row is created if it doesn't exist, with the other column values being _undefined_
  * @param row Index or label 
  * @param column Column 
  * @param value Value to set at row,column
  */
  set(row, column, value$1) {
    const result = this.#getOrCreateRawRow(row);
    if (resultIsError(result)) throw new Error(result.error);
    const r5 = result.value;
    const columnIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);
    if (typeof columnIndex === `undefined`) throw new Error(`Column label '${column}' not found or is invalid`);
    if (columnIndex < 0) throw new Error(`Column index invalid (less than zero)`);
    r5[columnIndex] = value$1;
  }
  /**
  * Gets the value at a specified row and column.
  * Throws an error if coordinates are out of range or missing.
  * @param row Row index or label
  * @param column Column index or label
  * @returns 
  */
  get(row, column) {
    const rowR = this.#getRowRaw(row);
    if (resultIsError(rowR)) throw new Error(rowR.error);
    const colR = this.#getColumnRaw(rowR.value, column);
    if (resultIsError(colR)) throw new Error(colR.error);
    return colR.value.value;
  }
  #getRowRaw(row) {
    let index = 0;
    if (typeof row === `number`) index = row;
    else {
      index = this.getRowLabelIndex(row);
      if (typeof index !== `number`) return {
        error: `row-label-notfound`,
        success: false
      };
    }
    if (typeof index !== `number`) return {
      error: `row-invalid`,
      success: false
    };
    if (index < 0 || index >= this.rows.length) return {
      error: `row-index-out-of-range`,
      success: false
    };
    return {
      success: true,
      value: this.rows[index]
    };
  }
  #getColumnRaw(row, column) {
    const colIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);
    if (typeof colIndex !== `number`) return {
      success: false,
      error: `col-label-notfound`
    };
    if (colIndex < 0 || colIndex >= row.length) return {
      success: false,
      error: `col-index-out-of-range`
    };
    return {
      success: true,
      value: {
        index: colIndex,
        value: row[colIndex]
      }
    };
  }
  /**
  * Set all the columns of a row to a specified value.
  *
  * By default, sets the number of columns corresponding to
  * the table's maximum column length. To set an arbitrary
  * length of the row, use `length`
  * @param row Index or label of row
  * @param length How wide the row is. If unset, uses the current maximum width of rows.
  * @param value Value to set
  */
  setRow(row, value$1, length3) {
    const rowResult = this.#getOrCreateRawRow(row);
    if (resultIsError(rowResult)) throw new Error(rowResult.error);
    const r5 = rowResult.value;
    const width = typeof length3 === `number` ? length3 : this.columnMaxLength;
    for (let columnNumber = 0; columnNumber < width; columnNumber++) r5[columnNumber] = value$1;
    return r5;
  }
};
var directed_graph_exports = {};
__export(directed_graph_exports, {
  adjacentVertices: () => adjacentVertices$1,
  areAdjacent: () => areAdjacent,
  bfs: () => bfs,
  clone: () => clone,
  connect: () => connect$1,
  connectTo: () => connectTo$1,
  connectWithEdges: () => connectWithEdges$1,
  createVertex: () => createVertex$1,
  dfs: () => dfs,
  disconnect: () => disconnect,
  distance: () => distance,
  distanceDefault: () => distanceDefault,
  dumpGraph: () => dumpGraph$1,
  edges: () => edges,
  get: () => get,
  getCycles: () => getCycles,
  getOrCreate: () => getOrCreate$1,
  getOrFail: () => getOrFail,
  graph: () => graph$1,
  graphFromVertices: () => graphFromVertices,
  hasKey: () => hasKey,
  hasNoOuts: () => hasNoOuts,
  hasOnlyOuts: () => hasOnlyOuts,
  hasOut: () => hasOut,
  isAcyclic: () => isAcyclic,
  pathDijkstra: () => pathDijkstra,
  toAdjacencyMatrix: () => toAdjacencyMatrix$1,
  topologicalSort: () => topologicalSort,
  transitiveReduction: () => transitiveReduction,
  updateGraphVertex: () => updateGraphVertex$1,
  vertexHasOut: () => vertexHasOut,
  vertices: () => vertices
});
var createVertex$1 = (id) => {
  return {
    id,
    out: []
  };
};
function hasKey(graph$2, key) {
  resultThrow(graphTest(graph$2));
  return graph$2.vertices.has(key);
}
function get(graph$2, key) {
  resultThrow(graphTest(graph$2));
  resultThrow(stringTest(key, `non-empty`, `key`));
  return graph$2.vertices.get(key);
}
function toAdjacencyMatrix$1(graph$2) {
  resultThrow(graphTest(graph$2));
  const v3 = [...graph$2.vertices.values()];
  const table = new Table();
  table.labelColumns(...v3.map((vv) => vv.id));
  table.labelRows(...v3.map((vv) => vv.id));
  for (let i4 = 0; i4 < v3.length; i4++) {
    table.setRow(i4, false, v3.length);
    const ii3 = v3[i4];
    for (const [j3, jj] of v3.entries()) if (ii3.out.some((o5) => o5.id === jj.id)) table.set(i4, j3, true);
  }
  return table;
}
var dumpGraph$1 = (graph$2) => {
  const lines = debugGraphToArray$1(graph$2);
  return lines.join(`
`);
};
var debugGraphToArray$1 = (graph$2) => {
  const r5 = [];
  const vertices$1 = `vertices` in graph$2 ? graph$2.vertices.values() : graph$2;
  for (const v3 of vertices$1) {
    const str = debugDumpVertex(v3);
    r5.push(...str.map((line3) => ` ${line3}`));
  }
  return r5;
};
var distance = (graph$2, edge) => {
  if (edge.weight !== void 0) return edge.weight;
  return 1;
};
function* edges(graph$2) {
  resultThrow(graphTest(graph$2));
  const vertices$1 = [...graph$2.vertices.values()];
  for (const vertex of vertices$1) for (const edge of vertex.out) yield edge;
}
function* vertices(graph$2) {
  resultThrow(graphTest(graph$2));
  const vertices$1 = [...graph$2.vertices.values()];
  for (const vertex of vertices$1) yield vertex;
}
function graphTest(g4, parameterName = `graph`) {
  if (g4 === void 0) return {
    success: false,
    error: `Param '${parameterName}' is undefined. Expected Graph`
  };
  if (g4 === null) return {
    success: false,
    error: `Param '${parameterName}' is null. Expected Graph`
  };
  if (typeof g4 === `object`) {
    if (!(`vertices` in g4)) return {
      success: false,
      error: `Param '${parameterName}.vertices' does not exist. Is it a Graph type?`
    };
  } else return {
    success: false,
    error: `Param '${parameterName} is type '${typeof g4}'. Expected an object Graph`
  };
  return {
    success: true,
    value: g4
  };
}
function* adjacentVertices$1(graph$2, context) {
  resultThrow(graphTest(graph$2));
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph$2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of vertex.out) {
    const edgeV = graph$2.vertices.get(edge.id);
    if (edgeV === void 0) throw new Error(`Could not find vertex: ${edge.id}`);
    yield edgeV;
  }
}
var vertexHasOut = (vertex, outIdOrVertex) => {
  if (vertex === void 0) return false;
  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;
  return vertex.out.some((edge) => edge.id === outId);
};
var hasNoOuts = (graph$2, vertex) => {
  resultThrow(graphTest(graph$2));
  const context = typeof vertex === `string` ? graph$2.vertices.get(vertex) : vertex;
  if (context === void 0) return false;
  return context.out.length === 0;
};
var hasOnlyOuts = (graph$2, vertex, ...outIdOrVertex) => {
  resultThrow(graphTest(graph$2));
  const context = resolveVertex$1(graph$2, vertex);
  const outs = outIdOrVertex.map((o5) => resolveVertex$1(graph$2, o5));
  if (outs.length !== context.out.length) return false;
  for (const out of outs) if (!hasOut(graph$2, context, out)) return false;
  return true;
};
var hasOut = (graph$2, vertex, outIdOrVertex) => {
  resultThrow(graphTest(graph$2));
  const context = resolveVertex$1(graph$2, vertex);
  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;
  return context.out.some((edge) => edge.id === outId);
};
var getOrCreate$1 = (graph$2, id) => {
  resultThrow(graphTest(graph$2));
  const v3 = graph$2.vertices.get(id);
  if (v3 !== void 0) return {
    graph: graph$2,
    vertex: v3
  };
  const vv = createVertex$1(id);
  const gg = updateGraphVertex$1(graph$2, vv);
  return {
    graph: gg,
    vertex: vv
  };
};
var getOrFail = (graph$2, id) => {
  resultThrow(graphTest(graph$2));
  const v3 = graph$2.vertices.get(id);
  if (v3 === void 0) throw new Error(`Vertex '${id}' not found in graph`);
  return v3;
};
var updateGraphVertex$1 = (graph$2, vertex) => {
  resultThrow(graphTest(graph$2));
  const gr2 = {
    ...graph$2,
    vertices: graph$2.vertices.set(vertex.id, vertex)
  };
  return gr2;
};
var distanceDefault = (graph$2, edge) => {
  if (edge.weight !== void 0) return edge.weight;
  return 1;
};
function disconnect(graph$2, from3, to3) {
  resultThrow(graphTest(graph$2));
  const fromV = resolveVertex$1(graph$2, from3);
  const toV = resolveVertex$1(graph$2, to3);
  return hasOut(graph$2, fromV, toV) ? updateGraphVertex$1(graph$2, {
    ...fromV,
    out: fromV.out.filter((t6) => t6.id !== toV.id)
  }) : graph$2;
}
function connectTo$1(graph$2, from3, to3, weight2) {
  resultThrow(graphTest(graph$2));
  const fromResult = getOrCreate$1(graph$2, from3);
  graph$2 = fromResult.graph;
  const toResult = getOrCreate$1(graph$2, to3);
  graph$2 = toResult.graph;
  const edge = {
    id: to3,
    weight: weight2
  };
  if (!hasOut(graph$2, fromResult.vertex, toResult.vertex)) graph$2 = updateGraphVertex$1(graph$2, {
    ...fromResult.vertex,
    out: [...fromResult.vertex.out, edge]
  });
  return {
    graph: graph$2,
    edge
  };
}
function connect$1(graph$2, options) {
  if (typeof graph$2 !== `object`) throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof graph$2}`);
  if (typeof options !== `object`) throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof options}`);
  const result = connectWithEdges$1(graph$2, options);
  return result.graph;
}
function connectWithEdges$1(graph$2, options) {
  resultThrow(graphTest(graph$2));
  const { to: to3, weight: weight2, from: from3 } = options;
  const bidi = options.bidi ?? false;
  const toList = Array.isArray(to3) ? to3 : [to3];
  const edges$13 = [];
  for (const toSingle of toList) {
    const result = connectTo$1(graph$2, from3, toSingle, weight2);
    graph$2 = result.graph;
    edges$13.push(result.edge);
  }
  if (!bidi) return {
    graph: graph$2,
    edges: edges$13
  };
  for (const toSingle of toList) {
    const result = connectTo$1(graph$2, toSingle, from3, weight2);
    graph$2 = result.graph;
    edges$13.push(result.edge);
  }
  return {
    graph: graph$2,
    edges: edges$13
  };
}
var debugDumpVertex = (v3) => {
  const r5 = [v3.id];
  const stringForEdge$1 = (edge) => edge.weight === void 0 ? edge.id : `${edge.id} (${edge.weight})`;
  for (const edge of v3.out) r5.push(` -> ${stringForEdge$1(edge)}`);
  if (v3.out.length === 0) r5[0] += ` (terminal)`;
  return r5;
};
function areAdjacent(graph$2, a3, b3) {
  resultThrow(graphTest(graph$2));
  if (hasOut(graph$2, a3, b3.id)) return true;
  if (hasOut(graph$2, b3, a3.id)) return true;
}
function resolveVertex$1(graph$2, idOrVertex) {
  resultThrow(graphTest(graph$2));
  if (idOrVertex === void 0) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);
  const v3 = typeof idOrVertex === `string` ? graph$2.vertices.get(idOrVertex) : idOrVertex;
  if (v3 === void 0) throw new Error(`Id not found ${idOrVertex}`);
  return v3;
}
function* bfs(graph$2, startIdOrVertex, targetIdOrVertex) {
  resultThrow(graphTest(graph$2));
  const start = resolveVertex$1(graph$2, startIdOrVertex);
  const target = targetIdOrVertex === void 0 ? void 0 : resolveVertex$1(graph$2, targetIdOrVertex);
  const queue = new QueueMutable2();
  const seen = /* @__PURE__ */ new Set();
  queue.enqueue(start);
  while (!queue.isEmpty) {
    const v3 = queue.dequeue();
    yield v3;
    if (target !== void 0 && target === v3) return;
    for (const edge of adjacentVertices$1(graph$2, v3)) if (!seen.has(edge.id)) {
      seen.add(edge.id);
      queue.enqueue(resolveVertex$1(graph$2, edge.id));
    }
  }
}
function* dfs(graph$2, startIdOrVertex) {
  resultThrow(graphTest(graph$2));
  const source = resolveVertex$1(graph$2, startIdOrVertex);
  const s3 = new StackMutable();
  const seen = /* @__PURE__ */ new Set();
  s3.push(source);
  while (!s3.isEmpty) {
    const v3 = s3.pop();
    if (v3 === void 0) continue;
    if (!seen.has(v3.id)) {
      seen.add(v3.id);
      yield v3;
      for (const edge of v3.out) {
        const destination = graph$2.vertices.get(edge.id);
        if (destination) s3.push(destination);
      }
    }
  }
}
var pathDijkstra = (graph$2, sourceOrId) => {
  resultThrow(graphTest(graph$2));
  const source = typeof sourceOrId === `string` ? graph$2.vertices.get(sourceOrId) : sourceOrId;
  if (source === void 0) throw new Error(`source vertex not found`);
  const distances = /* @__PURE__ */ new Map();
  const previous = /* @__PURE__ */ new Map();
  distances.set(source.id, 0);
  const pq = new PriorityMutable();
  const vertices$1 = [...graph$2.vertices.values()];
  for (const v3 of vertices$1) {
    if (v3.id !== source.id) {
      distances.set(v3.id, Number.MAX_SAFE_INTEGER);
      previous.set(v3.id, null);
    }
    pq.enqueueWithPriority(v3.id, Number.MAX_SAFE_INTEGER);
  }
  while (!pq.isEmpty) {
    const u3 = pq.dequeueMin();
    if (u3 === void 0) throw new Error(`Bug. Queue unexpectedly empty`);
    const vertexU = graph$2.vertices.get(u3);
    for (const neighbour of vertexU.out) {
      const alt = distances.get(u3) + distance(graph$2, neighbour);
      if (alt < distances.get(neighbour.id)) {
        distances.set(neighbour.id, alt);
        previous.set(neighbour.id, vertexU);
        pq.changePriority(neighbour.id, alt, true);
      }
    }
  }
  const pathTo = (id) => {
    const path3 = [];
    while (true) {
      if (id === source.id) break;
      const v3 = previous.get(id);
      if (v3 === void 0 || v3 === null) throw new Error(`Id not present: ${id}`);
      path3.push({
        id,
        weight: distances.get(id)
      });
      id = v3.id;
    }
    return path3;
  };
  return {
    distances,
    previous,
    pathTo
  };
};
var clone = (graph$2) => {
  resultThrow(graphTest(graph$2));
  const g4 = { vertices: immutable2([...graph$2.vertices.entries()]) };
  return g4;
};
var graph$1 = (...initialConnections) => {
  let g4 = { vertices: immutable2() };
  for (const ic2 of initialConnections) g4 = connect$1(g4, ic2);
  return g4;
};
function isAcyclic(graph$2) {
  resultThrow(graphTest(graph$2));
  const cycles = getCycles(graph$2);
  return cycles.length === 0;
}
function topologicalSort(graph$2) {
  resultThrow(graphTest(graph$2));
  const indegrees = new NumberMap(0);
  for (const edge of edges(graph$2)) indegrees.add(edge.id, 1);
  const queue = new QueueMutable2();
  let vertexCount = 0;
  for (const vertex of vertices(graph$2)) {
    if (indegrees.get(vertex.id) === 0) queue.enqueue(vertex);
    vertexCount++;
  }
  const topOrder = [];
  while (!queue.isEmpty) {
    const u3 = queue.dequeue();
    topOrder.push(u3);
    for (const neighbour of u3.out) {
      const result = indegrees.subtract(neighbour.id, 1);
      if (result === 0) queue.enqueue(graph$2.vertices.get(neighbour.id));
    }
  }
  if (topOrder.length !== vertexCount) throw new Error(`Graph contains cycles`);
  return graphFromVertices(topOrder);
}
function graphFromVertices(vertices$1) {
  const keyValues = map$2(vertices$1, (f5) => {
    return [f5.id, f5];
  });
  const m4 = immutable2([...keyValues]);
  return { vertices: m4 };
}
function getCycles(graph$2) {
  resultThrow(graphTest(graph$2));
  let index = 0;
  const stack = new StackMutable();
  const vertices$1 = /* @__PURE__ */ new Map();
  const scc = [];
  for (const v3 of graph$2.vertices.values()) vertices$1.set(v3.id, {
    ...v3,
    lowlink: NaN,
    index: NaN,
    onStack: false
  });
  const strongConnect = (vertex) => {
    vertex.index = index;
    vertex.lowlink = index;
    index++;
    stack.push(vertex);
    vertex.onStack = true;
    for (const edge of vertex.out) {
      const edgeV = vertices$1.get(edge.id);
      if (Number.isNaN(edgeV.index)) {
        strongConnect(edgeV);
        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);
      } else if (edgeV.onStack) vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);
    }
    if (vertex.lowlink === vertex.index) {
      const stronglyConnected = [];
      let w3;
      while (vertex !== w3) {
        w3 = stack.pop();
        w3.onStack = false;
        stronglyConnected.push({
          id: w3.id,
          out: w3.out
        });
      }
      if (stronglyConnected.length > 1) scc.push(stronglyConnected);
    }
  };
  for (const v3 of vertices$1.values()) if (Number.isNaN(v3.index)) strongConnect(v3);
  return scc;
}
function transitiveReduction(graph$2) {
  resultThrow(graphTest(graph$2));
  for (const u3 of vertices(graph$2)) for (const v3 of adjacentVertices$1(graph$2, u3)) for (const v1 of dfs(graph$2, v3)) {
    if (v3.id === v1.id) continue;
    if (hasOut(graph$2, u3, v1)) {
      const g4 = disconnect(graph$2, u3, v1);
      return transitiveReduction(g4);
    }
  }
  return graph$2;
}
var undirected_graph_exports = {};
__export(undirected_graph_exports, {
  adjacentVertices: () => adjacentVertices,
  connect: () => connect,
  connectTo: () => connectTo,
  connectWithEdges: () => connectWithEdges,
  createVertex: () => createVertex,
  dumpGraph: () => dumpGraph,
  edgesForVertex: () => edgesForVertex,
  getConnection: () => getConnection,
  getOrCreate: () => getOrCreate,
  graph: () => graph,
  hasConnection: () => hasConnection,
  toAdjacencyMatrix: () => toAdjacencyMatrix,
  updateGraphVertex: () => updateGraphVertex
});
var createVertex = (id) => {
  return { id };
};
var updateGraphVertex = (graph$2, vertex) => {
  const gr2 = {
    ...graph$2,
    vertices: graph$2.vertices.set(vertex.id, vertex)
  };
  return gr2;
};
var getOrCreate = (graph$2, id) => {
  const v3 = graph$2.vertices.get(id);
  if (v3 !== void 0) return {
    graph: graph$2,
    vertex: v3
  };
  const vv = createVertex(id);
  const gg = updateGraphVertex(graph$2, vv);
  return {
    graph: gg,
    vertex: vv
  };
};
function resolveVertex(graph$2, idOrVertex) {
  if (idOrVertex === void 0) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);
  if (graph$2 === void 0) throw new Error(`Param 'graph' is undefined. Expected Graph`);
  const v3 = typeof idOrVertex === `string` ? graph$2.vertices.get(idOrVertex) : idOrVertex;
  if (v3 === void 0) throw new Error(`Id not found ${idOrVertex}`);
  return v3;
}
var hasConnection = (graph$2, a3, b3) => {
  const edge = getConnection(graph$2, a3, b3);
  return edge !== void 0;
};
var getConnection = (graph$2, a3, b3) => {
  if (a3 === void 0) throw new Error(`Param 'a' is undefined. Expected string or Vertex`);
  if (b3 === void 0) throw new Error(`Param 'b' is undefined. Expected string or Vertex`);
  if (graph$2 === void 0) throw new Error(`Param 'graph' is undefined. Expected Graph`);
  const aa2 = resolveVertex(graph$2, a3);
  const bb = resolveVertex(graph$2, b3);
  for (const edge of graph$2.edges) {
    if (edge.a == aa2.id && edge.b === bb.id) return edge;
    if (edge.a == bb.id && edge.b === aa2.id) return edge;
  }
  return;
};
function connectTo(graph$2, a3, b3, weight2) {
  const aResult = getOrCreate(graph$2, a3);
  graph$2 = aResult.graph;
  const bResult = getOrCreate(graph$2, b3);
  graph$2 = bResult.graph;
  let edge = getConnection(graph$2, a3, b3);
  if (edge !== void 0) return {
    graph: graph$2,
    edge
  };
  edge = {
    a: a3,
    b: b3,
    weight: weight2
  };
  const graphChanged = {
    ...graph$2,
    edges: [...graph$2.edges, edge]
  };
  return {
    graph: graphChanged,
    edge
  };
}
function connect(graph$2, options) {
  const result = connectWithEdges(graph$2, options);
  return result.graph;
}
function connectWithEdges(graph$2, options) {
  const { a: a3, weight: weight2, b: b3 } = options;
  const destinations = Array.isArray(b3) ? b3 : [b3];
  const edges$13 = [];
  for (const destination of destinations) {
    const result = connectTo(graph$2, a3, destination, weight2);
    graph$2 = result.graph;
    edges$13.push(result.edge);
  }
  return {
    graph: graph$2,
    edges: edges$13
  };
}
var graph = (...initialConnections) => {
  let g4 = {
    vertices: immutable2(),
    edges: []
  };
  for (const ic2 of initialConnections) g4 = connect(g4, ic2);
  return g4;
};
function toAdjacencyMatrix(graph$2) {
  const v3 = [...graph$2.vertices.values()];
  const table = new Table();
  table.labelColumns(...v3.map((vv) => vv.id));
  table.labelRows(...v3.map((vv) => vv.id));
  for (let i4 = 0; i4 < v3.length; i4++) {
    table.setRow(i4, false, v3.length);
    const ii3 = v3[i4];
    for (const [j3, jj] of v3.entries()) {
      const connected = hasConnection(graph$2, ii3, jj);
      if (connected) table.set(i4, j3, true);
    }
  }
  return table;
}
var dumpGraph = (graph$2) => {
  const lines = debugGraphToArray(graph$2);
  return lines.join(`
`);
};
var debugGraphToArray = (graph$2) => {
  const r5 = [];
  r5.push(`Vertices: ${[...graph$2.vertices.values()].map((v3) => v3.id).join(`, `)}`);
  r5.push(`Edges:`);
  for (const edge of graph$2.edges) r5.push(stringForEdge(edge));
  return r5;
};
var stringForEdge = (edge) => {
  const weight2 = edge.weight ? ` (${edge.weight})` : ``;
  return `${edge.a} <-> ${edge.b}${weight2}`;
};
function* adjacentVertices(graph$2, context) {
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph$2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of graph$2.edges) if (edge.a === context) yield resolveVertex(graph$2, edge.b);
  else if (edge.b === context) yield resolveVertex(graph$2, edge.a);
}
function* edgesForVertex(graph$2, context) {
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph$2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of graph$2.edges) if (edge.a === context) yield edge;
  else if (edge.b === context) yield edge;
}
var graph_exports = {};
__export(graph_exports, {
  Directed: () => directed_graph_exports,
  Undirected: () => undirected_graph_exports
});

// node_modules/ixfx/bundle/records-Cei7yF1D.js
var mapObjectKeys = (object, mapFunction) => {
  const destinationObject = {};
  for (const entries2 of Object.entries(object)) {
    const key = mapFunction(entries2[0]);
    destinationObject[key] = entries2[1];
  }
  return destinationObject;
};
var compareObjectKeys = (a3, b3) => {
  const c5 = compareIterableValuesShallow(Object.keys(a3), Object.keys(b3));
  return c5;
};
var changedObjectDataFields = (a3, b3) => {
  const r5 = compareObjectData(a3, b3, true);
  if (Object.entries(r5.added).length > 0) throw new Error(`Shape of data has changed`);
  if (Object.entries(r5.removed).length > 0) throw new Error(`Shape of data has changed`);
  const output = compareResultToObject(r5, b3);
  return output;
};
var compareResultToObject = (r5, b3) => {
  const output = {};
  if (r5.isArray) return b3;
  for (const entry of Object.entries(r5.changed)) output[entry[0]] = entry[1];
  for (const entry of Object.entries(r5.added)) output[entry[0]] = entry[1];
  for (const childEntry of Object.entries(r5.children)) {
    const childResult = childEntry[1];
    if (childResult.hasChanged) output[childEntry[0]] = compareResultToObject(childResult, b3[childEntry[0]]);
  }
  return output;
};
var compareArrays = (a3, b3, eq = isEqualDefault) => {
  if (!Array.isArray(a3)) throw new Error(`Param 'a' is not an array`);
  if (!Array.isArray(b3)) throw new Error(`Param 'b' is not an array`);
  const c5 = compareObjectData(a3, b3, false, eq);
  if (!c5.isArray) throw new Error(`Change set does not have arrays as parameters`);
  const convert2 = (key) => {
    if (key.startsWith(`_`)) return Number.parseInt(key.slice(1));
    else throw new Error(`Unexpected key '${key}'`);
  };
  const cc = {
    ...c5,
    added: mapObjectKeys(c5.added, convert2),
    changed: mapObjectKeys(c5.changed, convert2),
    removed: c5.removed.map((v3) => convert2(v3)),
    summary: c5.summary.map((value3) => {
      return [
        value3[0],
        convert2(value3[1]),
        value3[2]
      ];
    })
  };
  return cc;
};
var compareObjectData = (a3, b3, assumeSameShape = false, eq = isEqualDefault) => {
  a3 ??= {};
  b3 ??= {};
  const entriesA = Object.entries(a3);
  const entriesB = Object.entries(b3);
  const scannedKeys = /* @__PURE__ */ new Set();
  const changed = {};
  const added = {};
  const children3 = {};
  const removed = [];
  const isArray = Array.isArray(a3);
  const summary = new Array();
  let hasChanged = false;
  for (const entry of entriesA) {
    const outputKey = isArray ? `_${entry[0]}` : entry[0];
    const aValue = entry[1];
    const bValue = b3[entry[0]];
    scannedKeys.add(entry[0]);
    if (bValue === void 0) {
      hasChanged = true;
      if (assumeSameShape && !isArray) {
        changed[outputKey] = bValue;
        summary.push([
          `mutate`,
          outputKey,
          bValue
        ]);
      } else {
        removed.push(outputKey);
        summary.push([
          `del`,
          outputKey,
          aValue
        ]);
      }
      continue;
    }
    if (typeof aValue === `object`) {
      const r5 = compareObjectData(aValue, bValue, assumeSameShape, eq);
      if (r5.hasChanged) hasChanged = true;
      children3[outputKey] = r5;
      const childSummary = r5.summary.map((sum4) => {
        return [
          sum4[0],
          outputKey + `.` + sum4[1],
          sum4[2]
        ];
      });
      summary.push(...childSummary);
    } else if (!eq(aValue, bValue)) {
      changed[outputKey] = bValue;
      hasChanged = true;
      summary.push([
        `mutate`,
        outputKey,
        bValue
      ]);
    }
  }
  if (!assumeSameShape || isArray) for (const entry of entriesB) {
    const key = isArray ? `_${entry[0]}` : entry[0];
    if (scannedKeys.has(entry[0])) continue;
    added[key] = entry[1];
    hasChanged = true;
    summary.push([
      `add`,
      key,
      entry[1]
    ]);
  }
  return {
    changed,
    added,
    removed,
    children: children3,
    hasChanged,
    isArray,
    summary
  };
};
var cloneFromFields = (source) => {
  const entries2 = [];
  for (const field in source) {
    const value3 = source[field];
    if (testPlainObjectOrPrimitive(value3)) entries2.push([field, value3]);
  }
  return Object.fromEntries(entries2);
};
var mapObjectShallow = (object, mapFunction) => {
  const entries2 = Object.entries(object);
  const mapped = entries2.map(([sourceField, sourceFieldValue], index) => [sourceField, mapFunction({
    value: sourceFieldValue,
    field: sourceField,
    index,
    path: sourceField
  })]);
  return Object.fromEntries(mapped);
};
function mapObjectByObject(data, mapper) {
  const entries2 = Object.entries(data);
  for (const entry of entries2) if (entry[0] in mapper) {
    const m4 = mapper[entry[0]];
    entry[1] = typeof m4 === `object` ? mapObjectByObject(entry[1], m4) : m4(entry[1], data);
  }
  return Object.fromEntries(entries2);
}
function prettyPrintEntries2(entries2) {
  if (entries2.length === 0) return `(empty)`;
  let t6 = ``;
  for (const [index, entry] of entries2.entries()) {
    t6 += `  `.repeat(index);
    t6 += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `
`;
  }
  return t6;
}
var recordEntryPrettyPrint = (node, indent = 0, options = {}) => {
  resultThrow(nullUndefTest(node, `node`));
  const defaultName = options.name ?? `node`;
  const entry = getNamedRecordEntry(node, defaultName);
  const t6 = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.nodeValue)}`;
  const childrenAsArray = [...recordChildren(node, options)];
  return childrenAsArray.length > 0 ? t6 + `
` + childrenAsArray.map((d3) => recordEntryPrettyPrint(d3.nodeValue, indent + 1, {
    ...options,
    name: d3.name
  })).join(`
`) : t6;
};
function* recordChildren(node, options = {}) {
  resultThrow(nullUndefTest(node, `node`));
  const filter2 = options.filter ?? `none`;
  const filterByValue = (v3) => {
    if (filter2 === `none`) return [true, isPrimitive(v3)];
    else if (filter2 === `leaves` && isPrimitive(v3)) return [true, true];
    else if (filter2 === `branches` && !isPrimitive(v3)) return [true, false];
    return [false, isPrimitive(v3)];
  };
  if (Array.isArray(node)) for (const [index, element] of node.entries()) {
    const f5 = filterByValue(element);
    if (f5[0]) yield {
      name: index.toString(),
      sourceValue: element,
      nodeValue: f5[1] ? element : void 0
    };
  }
  else if (typeof node === `object`) {
    const entriesIter = `entries` in node ? node.entries() : Object.entries(node);
    for (const [name, value3] of entriesIter) {
      const f5 = filterByValue(value3);
      if (f5[0]) yield {
        name,
        sourceValue: value3,
        nodeValue: f5[1] ? value3 : void 0
      };
    }
  }
}
function* recordEntriesDepthFirst(node, options = {}, ancestors = []) {
  for (const c5 of recordChildren(node, options)) {
    yield {
      ...c5,
      ancestors: [...ancestors]
    };
    yield* recordEntriesDepthFirst(c5.sourceValue, options, [...ancestors, c5.name]);
  }
}
function recordEntryChildByName(name, node) {
  for (const d3 of recordChildren(node)) if (d3.name === name) return d3;
}
function getRecordEntryByPath(path3, node, options = {}) {
  const paths3 = [...traceRecordEntryByPath(path3, node, options)];
  if (paths3.length === 0) throw new Error(`Could not trace path: ${path3} `);
  return paths3.at(-1);
}
function* traceRecordEntryByPath(path3, node, options = {}) {
  resultThrow(nullUndefTest(path3, `path`), nullUndefTest(node, `node`));
  const separator = options.separator ?? `.`;
  const pathSplit = path3.split(separator);
  const ancestors = [];
  for (const p3 of pathSplit) {
    const entry = recordEntryChildByName(p3, node);
    if (!entry) {
      yield {
        name: p3,
        sourceValue: void 0,
        nodeValue: void 0,
        ancestors
      };
      return;
    }
    node = entry.sourceValue;
    yield {
      ...entry,
      ancestors: [...ancestors]
    };
    ancestors.push(p3);
  }
}
function getNamedRecordEntry(node, defaultName = ``) {
  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node;
  if (`name` in node) return {
    name: node.name,
    nodeValue: node,
    sourceValue: node
  };
  return {
    name: defaultName,
    nodeValue: node,
    sourceValue: node
  };
}
function mergeObjects(...a3) {
  return Object.assign({}, ...a3);
}
var keysToNumbers = (object, onInvalidKey = `throw`) => {
  const returnObject = {};
  for (const entry of Object.entries(object)) {
    const asNumber = Number.parseInt(entry[0]);
    if (Number.isNaN(asNumber)) switch (onInvalidKey) {
      case `throw`:
        throw new TypeError(`Cannot convert key '${entry[0]}' to an integer`);
      case `ignore`:
        continue;
      case `keep`: {
        returnObject[entry[0]] = entry[1];
        continue;
      }
      default:
        throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);
    }
    returnObject[asNumber] = entry[1];
  }
  return returnObject;
};
var records_exports = {};
__export(records_exports, {
  changedObjectDataFields: () => changedObjectDataFields,
  cloneFromFields: () => cloneFromFields,
  compareArrays: () => compareArrays,
  compareObjectData: () => compareObjectData,
  compareObjectKeys: () => compareObjectKeys,
  getRecordEntryByPath: () => getRecordEntryByPath,
  keysToNumbers: () => keysToNumbers,
  mapObjectByObject: () => mapObjectByObject,
  mapObjectKeys: () => mapObjectKeys,
  mapObjectShallow: () => mapObjectShallow,
  mergeObjects: () => mergeObjects,
  prettyPrintEntries: () => prettyPrintEntries2,
  recordChildren: () => recordChildren,
  recordEntriesDepthFirst: () => recordEntriesDepthFirst,
  recordEntryPrettyPrint: () => recordEntryPrettyPrint,
  traceRecordEntryByPath: () => traceRecordEntryByPath
});

// node_modules/ixfx/bundle/key-value-JSby0EXT.js
var sorterByValueIndex = (index, reverse3 = false) => {
  return (values3) => {
    const s3 = values3.toSorted((a3, b3) => {
      return defaultComparer(a3[index], b3[index]);
    });
    if (reverse3) return s3.reverse();
    return s3;
  };
};
var keyValueSorter = (sortStyle) => {
  switch (sortStyle) {
    case `value`:
      return sorterByValueIndex(1, false);
    case `value-reverse`:
      return sorterByValueIndex(1, true);
    case `key`:
      return sorterByValueIndex(0, false);
    case `key-reverse`:
      return sorterByValueIndex(0, true);
    default:
      throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, value-reverse, key or key-reverse`);
  }
};

// node_modules/ixfx/bundle/dist-DE4H3J9W.js
var uniqueInstances = () => {
  const set5 = /* @__PURE__ */ new Set();
  return (value3) => {
    if (value3 === null) throw new TypeError(`Param 'value' cannot be null`);
    if (value3 === void 0) throw new TypeError(`Param 'value' cannot be undefined`);
    if (set5.has(value3)) return false;
    set5.add(value3);
    return true;
  };
};
var require_dist = __commonJS({ "../../node_modules/.pnpm/json5@2.2.3/node_modules/json5/dist/index.js"(exports, module) {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.JSON5 = factory();
  })(exports, function() {
    "use strict";
    function createCommonjsModule(fn2, module$1) {
      return module$1 = { exports: {} }, fn2(module$1, module$1.exports), module$1.exports;
    }
    var _global = createCommonjsModule(function(module$1) {
      var global = module$1.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
      if (typeof __g == "number") __g = global;
    });
    var _core = createCommonjsModule(function(module$1) {
      var core = module$1.exports = { version: "2.6.5" };
      if (typeof __e == "number") __e = core;
    });
    var _core_1 = _core.version;
    var _isObject = function(it2) {
      return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
    };
    var _anObject = function(it2) {
      if (!_isObject(it2)) throw TypeError(it2 + " is not an object!");
      return it2;
    };
    var _fails = function(exec) {
      try {
        return !!exec();
      } catch (e5) {
        return true;
      }
    };
    var _descriptors = !_fails(function() {
      return Object.defineProperty({}, "a", { get: function() {
        return 7;
      } }).a != 7;
    });
    var document2 = _global.document;
    var is2 = _isObject(document2) && _isObject(document2.createElement);
    var _domCreate = function(it2) {
      return is2 ? document2.createElement(it2) : {};
    };
    var _ie8DomDefine = !_descriptors && !_fails(function() {
      return Object.defineProperty(_domCreate("div"), "a", { get: function() {
        return 7;
      } }).a != 7;
    });
    var _toPrimitive = function(it2, S4) {
      if (!_isObject(it2)) return it2;
      var fn2, val;
      if (S4 && typeof (fn2 = it2.toString) == "function" && !_isObject(val = fn2.call(it2))) return val;
      if (typeof (fn2 = it2.valueOf) == "function" && !_isObject(val = fn2.call(it2))) return val;
      if (!S4 && typeof (fn2 = it2.toString) == "function" && !_isObject(val = fn2.call(it2))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
    var dP = Object.defineProperty;
    var f5 = _descriptors ? Object.defineProperty : function defineProperty(O3, P3, Attributes) {
      _anObject(O3);
      P3 = _toPrimitive(P3, true);
      _anObject(Attributes);
      if (_ie8DomDefine) try {
        return dP(O3, P3, Attributes);
      } catch (e5) {
      }
      if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
      if ("value" in Attributes) O3[P3] = Attributes.value;
      return O3;
    };
    var _objectDp = { f: f5 };
    var _propertyDesc = function(bitmap, value3) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value3
      };
    };
    var _hide = _descriptors ? function(object, key$1, value3) {
      return _objectDp.f(object, key$1, _propertyDesc(1, value3));
    } : function(object, key$1, value3) {
      object[key$1] = value3;
      return object;
    };
    var hasOwnProperty = {}.hasOwnProperty;
    var _has = function(it2, key$1) {
      return hasOwnProperty.call(it2, key$1);
    };
    var id = 0;
    var px = Math.random();
    var _uid = function(key$1) {
      return "Symbol(".concat(key$1 === void 0 ? "" : key$1, ")_", (++id + px).toString(36));
    };
    var _library = false;
    var _shared = createCommonjsModule(function(module$1) {
      var SHARED = "__core-js_shared__";
      var store = _global[SHARED] || (_global[SHARED] = {});
      (module$1.exports = function(key$1, value3) {
        return store[key$1] || (store[key$1] = value3 !== void 0 ? value3 : {});
      })("versions", []).push({
        version: _core.version,
        mode: _library ? "pure" : "global",
        copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
      });
    });
    var _functionToString = _shared("native-function-to-string", Function.toString);
    var _redefine = createCommonjsModule(function(module$1) {
      var SRC = _uid("src");
      var TO_STRING = "toString";
      var TPL = ("" + _functionToString).split(TO_STRING);
      _core.inspectSource = function(it2) {
        return _functionToString.call(it2);
      };
      (module$1.exports = function(O3, key$1, val, safe) {
        var isFunction2 = typeof val == "function";
        if (isFunction2) _has(val, "name") || _hide(val, "name", key$1);
        if (O3[key$1] === val) return;
        if (isFunction2) _has(val, SRC) || _hide(val, SRC, O3[key$1] ? "" + O3[key$1] : TPL.join(String(key$1)));
        if (O3 === _global) O3[key$1] = val;
        else if (!safe) {
          delete O3[key$1];
          _hide(O3, key$1, val);
        } else if (O3[key$1]) O3[key$1] = val;
        else _hide(O3, key$1, val);
      })(Function.prototype, TO_STRING, function toString5() {
        return typeof this == "function" && this[SRC] || _functionToString.call(this);
      });
    });
    var _aFunction = function(it2) {
      if (typeof it2 != "function") throw TypeError(it2 + " is not a function!");
      return it2;
    };
    var _ctx = function(fn2, that, length3) {
      _aFunction(fn2);
      if (that === void 0) return fn2;
      switch (length3) {
        case 1:
          return function(a3) {
            return fn2.call(that, a3);
          };
        case 2:
          return function(a3, b3) {
            return fn2.call(that, a3, b3);
          };
        case 3:
          return function(a3, b3, c$1) {
            return fn2.call(that, a3, b3, c$1);
          };
      }
      return function() {
        return fn2.apply(that, arguments);
      };
    };
    var PROTOTYPE = "prototype";
    var $export = function(type, name, source$1) {
      var IS_FORCED = type & $export.F;
      var IS_GLOBAL = type & $export.G;
      var IS_STATIC = type & $export.S;
      var IS_PROTO = type & $export.P;
      var IS_BIND = type & $export.B;
      var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
      var exports$1 = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
      var expProto = exports$1[PROTOTYPE] || (exports$1[PROTOTYPE] = {});
      var key$1, own, out, exp;
      if (IS_GLOBAL) source$1 = name;
      for (key$1 in source$1) {
        own = !IS_FORCED && target && target[key$1] !== void 0;
        out = (own ? target : source$1)[key$1];
        exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == "function" ? _ctx(Function.call, out) : out;
        if (target) _redefine(target, key$1, out, type & $export.U);
        if (exports$1[key$1] != out) _hide(exports$1, key$1, exp);
        if (IS_PROTO && expProto[key$1] != out) expProto[key$1] = out;
      }
    };
    _global.core = _core;
    $export.F = 1;
    $export.G = 2;
    $export.S = 4;
    $export.P = 8;
    $export.B = 16;
    $export.W = 32;
    $export.U = 64;
    $export.R = 128;
    var _export = $export;
    var ceil = Math.ceil;
    var floor = Math.floor;
    var _toInteger = function(it2) {
      return isNaN(it2 = +it2) ? 0 : (it2 > 0 ? floor : ceil)(it2);
    };
    var _defined = function(it2) {
      if (it2 == void 0) throw TypeError("Can't call method on  " + it2);
      return it2;
    };
    var _stringAt = function(TO_STRING) {
      return function(that, pos$1) {
        var s3 = String(_defined(that));
        var i4 = _toInteger(pos$1);
        var l3 = s3.length;
        var a3, b3;
        if (i4 < 0 || i4 >= l3) return TO_STRING ? "" : void 0;
        a3 = s3.charCodeAt(i4);
        return a3 < 55296 || a3 > 56319 || i4 + 1 === l3 || (b3 = s3.charCodeAt(i4 + 1)) < 56320 || b3 > 57343 ? TO_STRING ? s3.charAt(i4) : a3 : TO_STRING ? s3.slice(i4, i4 + 2) : (a3 - 55296 << 10) + (b3 - 56320) + 65536;
      };
    };
    var $at = _stringAt(false);
    _export(_export.P, "String", { codePointAt: function codePointAt$1(pos$1) {
      return $at(this, pos$1);
    } });
    var codePointAt = _core.String.codePointAt;
    var max4 = Math.max;
    var min4 = Math.min;
    var _toAbsoluteIndex = function(index, length3) {
      index = _toInteger(index);
      return index < 0 ? max4(index + length3, 0) : min4(index, length3);
    };
    var fromCharCode = String.fromCharCode;
    var $fromCodePoint = String.fromCodePoint;
    _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), "String", { fromCodePoint: function fromCodePoint$1(x3) {
      var arguments$1 = arguments;
      var res = [];
      var aLen = arguments.length;
      var i4 = 0;
      var code;
      while (aLen > i4) {
        code = +arguments$1[i4++];
        if (_toAbsoluteIndex(code, 1114111) !== code) throw RangeError(code + " is not a valid code point");
        res.push(code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320));
      }
      return res.join("");
    } });
    var fromCodePoint = _core.String.fromCodePoint;
    var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
    var unicode = {
      Space_Separator,
      ID_Start,
      ID_Continue
    };
    var util = {
      isSpaceSeparator: function isSpaceSeparator(c$1) {
        return typeof c$1 === "string" && unicode.Space_Separator.test(c$1);
      },
      isIdStartChar: function isIdStartChar(c$1) {
        return typeof c$1 === "string" && (c$1 >= "a" && c$1 <= "z" || c$1 >= "A" && c$1 <= "Z" || c$1 === "$" || c$1 === "_" || unicode.ID_Start.test(c$1));
      },
      isIdContinueChar: function isIdContinueChar(c$1) {
        return typeof c$1 === "string" && (c$1 >= "a" && c$1 <= "z" || c$1 >= "A" && c$1 <= "Z" || c$1 >= "0" && c$1 <= "9" || c$1 === "$" || c$1 === "_" || c$1 === "\u200C" || c$1 === "\u200D" || unicode.ID_Continue.test(c$1));
      },
      isDigit: function isDigit(c$1) {
        return typeof c$1 === "string" && /[0-9]/.test(c$1);
      },
      isHexDigit: function isHexDigit(c$1) {
        return typeof c$1 === "string" && /[0-9A-Fa-f]/.test(c$1);
      }
    };
    var source;
    var parseState;
    var stack;
    var pos;
    var line3;
    var column;
    var token;
    var key;
    var root3;
    var parse = function parse$1(text3, reviver) {
      source = String(text3);
      parseState = "start";
      stack = [];
      pos = 0;
      line3 = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root3 = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") return internalize({ "": root3 }, "", reviver);
      return root3;
    };
    function internalize(holder, name, reviver) {
      var value3 = holder[name];
      if (value3 != null && typeof value3 === "object") if (Array.isArray(value3)) for (var i4 = 0; i4 < value3.length; i4++) {
        var key$1 = String(i4);
        var replacement = internalize(value3, key$1, reviver);
        if (replacement === void 0) delete value3[key$1];
        else Object.defineProperty(value3, key$1, {
          value: replacement,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
      else for (var key$1$1 in value3) {
        var replacement$1 = internalize(value3, key$1$1, reviver);
        if (replacement$1 === void 0) delete value3[key$1$1];
        else Object.defineProperty(value3, key$1$1, {
          value: replacement$1,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
      return reviver.call(holder, name, value3);
    }
    var lexState;
    var buffer;
    var doubleQuote;
    var sign2;
    var c5;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote = false;
      sign2 = 1;
      for (; ; ) {
        c5 = peek3();
        var token$1 = lexStates[lexState]();
        if (token$1) return token$1;
      }
    }
    function peek3() {
      if (source[pos]) return String.fromCodePoint(source.codePointAt(pos));
    }
    function read() {
      var c$1 = peek3();
      if (c$1 === "\n") {
        line3++;
        column = 0;
      } else if (c$1) column += c$1.length;
      else column++;
      if (c$1) pos += c$1.length;
      return c$1;
    }
    var lexStates = {
      default: function default$1() {
        switch (c5) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            return;
          case "/":
            read();
            lexState = "comment";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        if (util.isSpaceSeparator(c5)) {
          read();
          return;
        }
        return lexStates[parseState]();
      },
      comment: function comment() {
        switch (c5) {
          case "*":
            read();
            lexState = "multiLineComment";
            return;
          case "/":
            read();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read());
      },
      multiLineComment: function multiLineComment() {
        switch (c5) {
          case "*":
            read();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
      },
      multiLineCommentAsterisk: function multiLineCommentAsterisk() {
        switch (c5) {
          case "*":
            read();
            return;
          case "/":
            read();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read());
        }
        read();
        lexState = "multiLineComment";
      },
      singleLineComment: function singleLineComment() {
        switch (c5) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read();
            lexState = "default";
            return;
          case void 0:
            read();
            return newToken("eof");
        }
        read();
      },
      value: function value3() {
        switch (c5) {
          case "{":
          case "[":
            return newToken("punctuator", read());
          case "n":
            read();
            literal("ull");
            return newToken("null", null);
          case "t":
            read();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read() === "-") sign2 = -1;
            lexState = "sign";
            return;
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote = read() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read());
      },
      identifierNameStartEscape: function identifierNameStartEscape() {
        if (c5 !== "u") throw invalidChar(read());
        read();
        var u3 = unicodeEscape();
        switch (u3) {
          case "$":
          case "_":
            break;
          default:
            if (!util.isIdStartChar(u3)) throw invalidIdentifier();
            break;
        }
        buffer += u3;
        lexState = "identifierName";
      },
      identifierName: function identifierName() {
        switch (c5) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read();
            return;
          case "\\":
            read();
            lexState = "identifierNameEscape";
            return;
        }
        if (util.isIdContinueChar(c5)) {
          buffer += read();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape: function identifierNameEscape() {
        if (c5 !== "u") throw invalidChar(read());
        read();
        var u3 = unicodeEscape();
        switch (u3) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util.isIdContinueChar(u3)) throw invalidIdentifier();
            break;
        }
        buffer += u3;
        lexState = "identifierName";
      },
      sign: function sign$1() {
        switch (c5) {
          case ".":
            buffer = read();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read();
            lexState = "decimalInteger";
            return;
          case "I":
            read();
            literal("nfinity");
            return newToken("numeric", sign2 * Infinity);
          case "N":
            read();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read());
      },
      zero: function zero() {
        switch (c5) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign2 * 0);
      },
      decimalInteger: function decimalInteger() {
        switch (c5) {
          case ".":
            buffer += read();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c5)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign2 * Number(buffer));
      },
      decimalPointLeading: function decimalPointLeading() {
        if (util.isDigit(c5)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read());
      },
      decimalPoint: function decimalPoint() {
        switch (c5) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c5)) {
          buffer += read();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign2 * Number(buffer));
      },
      decimalFraction: function decimalFraction() {
        switch (c5) {
          case "e":
          case "E":
            buffer += read();
            lexState = "decimalExponent";
            return;
        }
        if (util.isDigit(c5)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign2 * Number(buffer));
      },
      decimalExponent: function decimalExponent() {
        switch (c5) {
          case "+":
          case "-":
            buffer += read();
            lexState = "decimalExponentSign";
            return;
        }
        if (util.isDigit(c5)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentSign: function decimalExponentSign() {
        if (util.isDigit(c5)) {
          buffer += read();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read());
      },
      decimalExponentInteger: function decimalExponentInteger() {
        if (util.isDigit(c5)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign2 * Number(buffer));
      },
      hexadecimal: function hexadecimal() {
        if (util.isHexDigit(c5)) {
          buffer += read();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read());
      },
      hexadecimalInteger: function hexadecimalInteger() {
        if (util.isHexDigit(c5)) {
          buffer += read();
          return;
        }
        return newToken("numeric", sign2 * Number(buffer));
      },
      string: function string2() {
        switch (c5) {
          case "\\":
            read();
            buffer += escape();
            return;
          case '"':
            if (doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "'":
            if (!doubleQuote) {
              read();
              return newToken("string", buffer);
            }
            buffer += read();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read());
          case "\u2028":
          case "\u2029":
            separatorChar(c5);
            break;
          case void 0:
            throw invalidChar(read());
        }
        buffer += read();
      },
      start: function start() {
        switch (c5) {
          case "{":
          case "[":
            return newToken("punctuator", read());
        }
        lexState = "value";
      },
      beforePropertyName: function beforePropertyName() {
        switch (c5) {
          case "$":
          case "_":
            buffer = read();
            lexState = "identifierName";
            return;
          case "\\":
            read();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read());
          case '"':
          case "'":
            doubleQuote = read() === '"';
            lexState = "string";
            return;
        }
        if (util.isIdStartChar(c5)) {
          buffer += read();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read());
      },
      afterPropertyName: function afterPropertyName() {
        if (c5 === ":") return newToken("punctuator", read());
        throw invalidChar(read());
      },
      beforePropertyValue: function beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue: function afterPropertyValue() {
        switch (c5) {
          case ",":
          case "}":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      beforeArrayValue: function beforeArrayValue() {
        if (c5 === "]") return newToken("punctuator", read());
        lexState = "value";
      },
      afterArrayValue: function afterArrayValue() {
        switch (c5) {
          case ",":
          case "]":
            return newToken("punctuator", read());
        }
        throw invalidChar(read());
      },
      end: function end() {
        throw invalidChar(read());
      }
    };
    function newToken(type, value3) {
      return {
        type,
        value: value3,
        line: line3,
        column
      };
    }
    function literal(s3) {
      for (var i4 = 0, list = s3; i4 < list.length; i4 += 1) {
        var c$1 = list[i4];
        var p3 = peek3();
        if (p3 !== c$1) throw invalidChar(read());
        read();
      }
    }
    function escape() {
      var c$1 = peek3();
      switch (c$1) {
        case "b":
          read();
          return "\b";
        case "f":
          read();
          return "\f";
        case "n":
          read();
          return "\n";
        case "r":
          read();
          return "\r";
        case "t":
          read();
          return "	";
        case "v":
          read();
          return "\v";
        case "0":
          read();
          if (util.isDigit(peek3())) throw invalidChar(read());
          return "\0";
        case "x":
          read();
          return hexEscape();
        case "u":
          read();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read();
          return "";
        case "\r":
          read();
          if (peek3() === "\n") read();
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read());
        case void 0:
          throw invalidChar(read());
      }
      return read();
    }
    function hexEscape() {
      var buffer$1 = "";
      var c$1 = peek3();
      if (!util.isHexDigit(c$1)) throw invalidChar(read());
      buffer$1 += read();
      c$1 = peek3();
      if (!util.isHexDigit(c$1)) throw invalidChar(read());
      buffer$1 += read();
      return String.fromCodePoint(parseInt(buffer$1, 16));
    }
    function unicodeEscape() {
      var buffer$1 = "";
      var count3 = 4;
      while (count3-- > 0) {
        var c$1 = peek3();
        if (!util.isHexDigit(c$1)) throw invalidChar(read());
        buffer$1 += read();
      }
      return String.fromCodePoint(parseInt(buffer$1, 16));
    }
    var parseStates = {
      start: function start() {
        if (token.type === "eof") throw invalidEOF();
        push3();
      },
      beforePropertyName: function beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop3();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName: function afterPropertyName() {
        if (token.type === "eof") throw invalidEOF();
        parseState = "beforePropertyValue";
      },
      beforePropertyValue: function beforePropertyValue() {
        if (token.type === "eof") throw invalidEOF();
        push3();
      },
      beforeArrayValue: function beforeArrayValue() {
        if (token.type === "eof") throw invalidEOF();
        if (token.type === "punctuator" && token.value === "]") {
          pop3();
          return;
        }
        push3();
      },
      afterPropertyValue: function afterPropertyValue() {
        if (token.type === "eof") throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop3();
        }
      },
      afterArrayValue: function afterArrayValue() {
        if (token.type === "eof") throw invalidEOF();
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop3();
        }
      },
      end: function end() {
      }
    };
    function push3() {
      var value3;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value3 = {};
              break;
            case "[":
              value3 = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value3 = token.value;
          break;
      }
      if (root3 === void 0) root3 = value3;
      else {
        var parent = stack[stack.length - 1];
        if (Array.isArray(parent)) parent.push(value3);
        else Object.defineProperty(parent, key, {
          value: value3,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
      if (value3 !== null && typeof value3 === "object") {
        stack.push(value3);
        if (Array.isArray(value3)) parseState = "beforeArrayValue";
        else parseState = "beforePropertyName";
      } else {
        var current = stack[stack.length - 1];
        if (current == null) parseState = "end";
        else if (Array.isArray(current)) parseState = "afterArrayValue";
        else parseState = "afterPropertyValue";
      }
    }
    function pop3() {
      stack.pop();
      var current = stack[stack.length - 1];
      if (current == null) parseState = "end";
      else if (Array.isArray(current)) parseState = "afterArrayValue";
      else parseState = "afterPropertyValue";
    }
    function invalidChar(c$1) {
      if (c$1 === void 0) return syntaxError("JSON5: invalid end of input at " + line3 + ":" + column);
      return syntaxError("JSON5: invalid character '" + formatChar(c$1) + "' at " + line3 + ":" + column);
    }
    function invalidEOF() {
      return syntaxError("JSON5: invalid end of input at " + line3 + ":" + column);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError("JSON5: invalid identifier character at " + line3 + ":" + column);
    }
    function separatorChar(c$1) {
      console.warn("JSON5: '" + formatChar(c$1) + "' in strings is not valid ECMAScript; consider escaping");
    }
    function formatChar(c$1) {
      var replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c$1]) return replacements[c$1];
      if (c$1 < " ") {
        var hexString = c$1.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c$1;
    }
    function syntaxError(message) {
      var err = new SyntaxError(message);
      err.lineNumber = line3;
      err.columnNumber = column;
      return err;
    }
    var stringify = function stringify$1(value3, replacer, space) {
      var stack$1 = [];
      var indent = "";
      var propertyList;
      var replacerFunc;
      var gap = "";
      var quote;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") replacerFunc = replacer;
      else if (Array.isArray(replacer)) {
        propertyList = [];
        for (var i4 = 0, list = replacer; i4 < list.length; i4 += 1) {
          var v3 = list[i4];
          var item = void 0;
          if (typeof v3 === "string") item = v3;
          else if (typeof v3 === "number" || v3 instanceof String || v3 instanceof Number) item = String(v3);
          if (item !== void 0 && propertyList.indexOf(item) < 0) propertyList.push(item);
        }
      }
      if (space instanceof Number) space = Number(space);
      else if (space instanceof String) space = String(space);
      if (typeof space === "number") {
        if (space > 0) {
          space = Math.min(10, Math.floor(space));
          gap = "          ".substr(0, space);
        }
      } else if (typeof space === "string") gap = space.substr(0, 10);
      return serializeProperty("", { "": value3 });
      function serializeProperty(key$1, holder) {
        var value$1 = holder[key$1];
        if (value$1 != null) {
          if (typeof value$1.toJSON5 === "function") value$1 = value$1.toJSON5(key$1);
          else if (typeof value$1.toJSON === "function") value$1 = value$1.toJSON(key$1);
        }
        if (replacerFunc) value$1 = replacerFunc.call(holder, key$1, value$1);
        if (value$1 instanceof Number) value$1 = Number(value$1);
        else if (value$1 instanceof String) value$1 = String(value$1);
        else if (value$1 instanceof Boolean) value$1 = value$1.valueOf();
        switch (value$1) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value$1 === "string") return quoteString(value$1, false);
        if (typeof value$1 === "number") return String(value$1);
        if (typeof value$1 === "object") return Array.isArray(value$1) ? serializeArray(value$1) : serializeObject(value$1);
        return void 0;
      }
      function quoteString(value$1) {
        var quotes = {
          "'": 0.1,
          '"': 0.2
        };
        var replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        var product = "";
        for (var i$1 = 0; i$1 < value$1.length; i$1++) {
          var c$1 = value$1[i$1];
          switch (c$1) {
            case "'":
            case '"':
              quotes[c$1]++;
              product += c$1;
              continue;
            case "\0":
              if (util.isDigit(value$1[i$1 + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c$1]) {
            product += replacements[c$1];
            continue;
          }
          if (c$1 < " ") {
            var hexString = c$1.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c$1;
        }
        var quoteChar = quote || Object.keys(quotes).reduce(function(a3, b3) {
          return quotes[a3] < quotes[b3] ? a3 : b3;
        });
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value$1) {
        if (stack$1.indexOf(value$1) >= 0) throw TypeError("Converting circular structure to JSON5");
        stack$1.push(value$1);
        var stepback = indent;
        indent = indent + gap;
        var keys = propertyList || Object.keys(value$1);
        var partial = [];
        for (var i$1 = 0, list$1 = keys; i$1 < list$1.length; i$1 += 1) {
          var key$1 = list$1[i$1];
          var propertyString = serializeProperty(key$1, value$1);
          if (propertyString !== void 0) {
            var member = serializeKey(key$1) + ":";
            if (gap !== "") member += " ";
            member += propertyString;
            partial.push(member);
          }
        }
        var final;
        if (partial.length === 0) final = "{}";
        else {
          var properties;
          if (gap === "") {
            properties = partial.join(",");
            final = "{" + properties + "}";
          } else {
            var separator = ",\n" + indent;
            properties = partial.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack$1.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key$1) {
        if (key$1.length === 0) return quoteString(key$1, true);
        var firstChar = String.fromCodePoint(key$1.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) return quoteString(key$1, true);
        for (var i$1 = firstChar.length; i$1 < key$1.length; i$1++) if (!util.isIdContinueChar(String.fromCodePoint(key$1.codePointAt(i$1)))) return quoteString(key$1, true);
        return key$1;
      }
      function serializeArray(value$1) {
        if (stack$1.indexOf(value$1) >= 0) throw TypeError("Converting circular structure to JSON5");
        stack$1.push(value$1);
        var stepback = indent;
        indent = indent + gap;
        var partial = [];
        for (var i$1 = 0; i$1 < value$1.length; i$1++) {
          var propertyString = serializeProperty(String(i$1), value$1);
          partial.push(propertyString !== void 0 ? propertyString : "null");
        }
        var final;
        if (partial.length === 0) final = "[]";
        else if (gap === "") {
          var properties = partial.join(",");
          final = "[" + properties + "]";
        } else {
          var separator = ",\n" + indent;
          var properties$1 = partial.join(separator);
          final = "[\n" + indent + properties$1 + ",\n" + stepback + "]";
        }
        stack$1.pop();
        indent = stepback;
        return final;
      }
    };
    var JSON5 = {
      parse,
      stringify
    };
    var lib = JSON5;
    var es5 = lib;
    return es5;
  });
} });

// node_modules/ixfx/bundle/resolve-core-CZPH91No.js
var isReactive = (rx) => {
  if (typeof rx !== `object`) return false;
  if (rx === null) return false;
  return `on` in rx && `onValue` in rx;
};
var hasLast = (rx) => {
  if (!isReactive(rx)) return false;
  if (`last` in rx) {
    const v3 = rx.last();
    if (v3 !== void 0) return true;
  }
  return false;
};
var getOrGenerateSync2 = (map2, fn2) => (key, args) => {
  let value3 = map2.get(key);
  if (value3 !== void 0) return value3;
  value3 = fn2(key, args);
  map2.set(key, value3);
  return value3;
};
var logger = (prefix, kind = `log`, colourKey) => (m4) => {
  if (m4 === void 0) m4 = `(undefined)`;
  else if (typeof m4 === `object`) m4 = JSON.stringify(m4);
  const colour = colourKey ?? prefix;
  switch (kind) {
    case `log`: {
      console.log(`%c${prefix} ${m4}`, `color: ${logColours(colour)}`);
      break;
    }
    case `warn`: {
      console.warn(prefix, m4);
      break;
    }
    case `error`: {
      console.error(prefix, m4);
      break;
    }
  }
};
var logSet = (prefix, verbose = true, colourKey) => {
  if (verbose) return {
    log: logger(prefix, `log`, colourKey),
    warn: logger(prefix, `warn`, colourKey),
    error: logger(prefix, `error`, colourKey)
  };
  return {
    log: (_3) => {
    },
    warn: logger(prefix, `warn`, colourKey),
    error: logger(prefix, `error`, colourKey)
  };
};
var resolveLogOption = (l3, defaults2 = {}) => {
  if (l3 === void 0 || typeof l3 === `boolean` && !l3) return (_3) => {
  };
  const defaultCat = defaults2.category ?? ``;
  const defaultKind = defaults2.kind ?? void 0;
  if (typeof l3 === `boolean`) return (messageOrString) => {
    const m4 = typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;
    const kind = m4.kind ?? defaultKind;
    const category = m4.category ?? defaultCat;
    let message = m4.msg;
    if (category) message = `[${category}] ${message}`;
    switch (kind) {
      case `error`: {
        console.error(message);
        break;
      }
      case `warn`: {
        console.warn(message);
        break;
      }
      case `info`: {
        console.info(message);
        break;
      }
      default:
        console.log(message);
    }
  };
  return l3;
};
var logColourCount = 0;
var logColours = getOrGenerateSync2(/* @__PURE__ */ new Map(), () => {
  const hue = ++logColourCount * 137.508;
  return `hsl(${hue},50%,75%)`;
});
var fpsCounter = (autoDisplay = true, computeAfterFrames = 500) => {
  let count3 = 0;
  let lastFps = 0;
  let countStart = performance.now();
  return () => {
    if (count3++ >= computeAfterFrames) {
      const elapsed2 = performance.now() - countStart;
      countStart = performance.now();
      count3 = 0;
      lastFps = Math.floor(computeAfterFrames / elapsed2 * 1e3);
      if (autoDisplay) console.log(`fps: ${lastFps}`);
    }
    return lastFps;
  };
};
var getErrorMessage2 = (ex) => {
  if (typeof ex === `string`) return ex;
  if (ex instanceof Error) return ex.message;
  return ex;
};
var src_exports4 = {};
__export(src_exports4, {
  fpsCounter: () => fpsCounter,
  getErrorMessage: () => getErrorMessage2,
  logColours: () => logColours,
  logSet: () => logSet,
  logger: () => logger,
  resolveLogOption: () => resolveLogOption
});
async function resolve(resolvable, ...args) {
  if (typeof resolvable === `object`) if (`next` in resolvable) {
    const tag = resolvable[Symbol.toStringTag];
    if (tag === `Generator` || tag == `Array Iterator`) {
      const v3 = resolvable.next();
      if (`done` in v3 && `value` in v3) return v3.value;
      return v3;
    } else if (tag === `AsyncGenerator`) {
      const v3 = await resolvable.next();
      if (`done` in v3 && `value` in v3) return v3.value;
      return v3;
    } else throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);
  } else if (isReactive(resolvable)) {
    if (hasLast(resolvable)) return resolvable.last();
    throw new Error(`Reactive does not have last value`);
  } else return resolvable;
  else if (typeof resolvable === `function`) {
    const v3 = await resolvable(...args);
    return v3;
  } else return resolvable;
}
function resolveSync(resolvable, ...args) {
  if (typeof resolvable === `object`) if (`next` in resolvable) {
    const tag = resolvable[Symbol.toStringTag];
    if (tag === `Generator` || tag == `Array Iterator`) {
      const v3 = resolvable.next();
      if (`done` in v3 && `value` in v3) return v3.value;
      return v3;
    } else if (tag === `AsyncGenerator`) throw new Error(`resolveSync cannot work with an async generator`);
    else throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);
  } else if (isReactive(resolvable)) {
    if (hasLast(resolvable)) return resolvable.last();
    throw new Error(`Reactive does not have last value`);
  } else return resolvable;
  else if (typeof resolvable === `function`) return resolvable(...args);
  else return resolvable;
}

// node_modules/ixfx/bundle/src-BP8ZzJBi.js
var CircularArray3 = class CircularArray4 extends Array {
  #capacity;
  #pointer;
  constructor(capacity = 0) {
    super();
    resultThrow(integerTest(capacity, `positive`, `capacity`));
    this.#capacity = capacity;
    this.#pointer = 0;
  }
  /**
  * Add to array
  * @param value Thing to add
  * @returns
  */
  add(value$1) {
    const ca2 = CircularArray4.from(this);
    ca2[this.#pointer] = value$1;
    ca2.#capacity = this.#capacity;
    if (this.#capacity > 0) ca2.#pointer = this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;
    else ca2.#pointer = this.#pointer + 1;
    return ca2;
  }
  get pointer() {
    return this.#pointer;
  }
  get isFull() {
    if (this.#capacity === 0) return false;
    return this.length === this.#capacity;
  }
};
var debug2 = (opts, message) => {
  opts.debug && console.log(`queue:${message}`);
};
var trimQueue2 = (opts, queue, toAdd) => {
  const potentialLength = queue.length + toAdd.length;
  const capacity = opts.capacity ?? potentialLength;
  const toRemove = potentialLength - capacity;
  const policy = opts.discardPolicy ?? `additions`;
  switch (policy) {
    case `additions`: {
      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);
      if (queue.length === opts.capacity) return queue;
      else return [...queue, ...toAdd.slice(0, toRemove - 1)];
    }
    case `newer`:
      if (toRemove >= queue.length) {
        if (queue.length === 0) return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];
        return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);
      } else {
        const countToAdd = Math.max(1, toAdd.length - queue.length);
        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);
        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1));
        const t6 = [...toKeep, ...toAddFinal];
        return t6;
      }
    case `older`:
      return [...queue, ...toAdd].slice(toRemove);
    default:
      throw new Error(`Unknown overflow policy ${policy}`);
  }
};
var enqueue2 = (opts, queue, ...toAdd) => {
  if (opts === void 0) throw new Error(`opts parameter undefined`);
  const potentialLength = queue.length + toAdd.length;
  const overSize = opts.capacity && potentialLength > opts.capacity;
  const toReturn = overSize ? trimQueue2(opts, queue, toAdd) : [...queue, ...toAdd];
  if (opts.capacity && toReturn.length !== opts.capacity && overSize) throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);
  if (!opts.capacity && toReturn.length !== potentialLength) throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);
  return toReturn;
};
var dequeue2 = (opts, queue) => {
  if (queue.length === 0) throw new Error(`Queue is empty`);
  return queue.slice(1);
};
var peek2 = (opts, queue) => queue[0];
var isEmpty2 = (opts, queue) => queue.length === 0;
var isFull2 = (opts, queue) => {
  if (opts.capacity) return queue.length >= opts.capacity;
  return false;
};
var QueueMutable3 = class extends SimpleEventEmitter {
  options;
  data;
  eq;
  constructor(opts = {}, data = []) {
    super();
    if (opts === void 0) throw new Error(`opts parameter undefined`);
    this.options = opts;
    this.data = data;
    this.eq = opts.eq ?? isEqualDefault;
  }
  clear() {
    const copy = [...this.data];
    this.data = [];
    this.fireEvent(`removed`, {
      finalData: this.data,
      removed: copy
    });
    this.onClear();
  }
  /**
  * Called when all data is cleared
  */
  onClear() {
  }
  at(index) {
    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);
    const v3 = this.data.at(index);
    if (v3 === void 0) throw new Error(`Index appears to be outside range of queue`);
    return v3;
  }
  enqueue(...toAdd) {
    this.data = enqueue2(this.options, this.data, ...toAdd);
    const length3 = this.data.length;
    this.onEnqueue(this.data, toAdd);
    return length3;
  }
  onEnqueue(result, attemptedToAdd) {
    this.fireEvent(`enqueue`, {
      added: attemptedToAdd,
      finalData: result
    });
  }
  dequeue() {
    const v3 = peek2(this.options, this.data);
    if (v3 === void 0) return;
    this.data = dequeue2(this.options, this.data);
    this.fireEvent(`dequeue`, {
      removed: v3,
      finalData: this.data
    });
    this.onRemoved([v3], this.data);
    return v3;
  }
  onRemoved(removed, finalData) {
    this.fireEvent(`removed`, {
      removed,
      finalData
    });
  }
  /**
  * Removes values that match `predicate`.
  * @param predicate
  * @returns Returns number of items removed.
  */
  removeWhere(predicate) {
    const countPre = this.data.length;
    const toRemove = this.data.filter((v3) => predicate(v3));
    if (toRemove.length === 0) return 0;
    this.data = this.data.filter((element) => !predicate(element));
    this.onRemoved(toRemove, this.data);
    return countPre - this.data.length;
  }
  /**
  * Return a copy of the array
  * @returns
  */
  toArray() {
    return [...this.data];
  }
  get isEmpty() {
    return isEmpty2(this.options, this.data);
  }
  get isFull() {
    return isFull2(this.options, this.data);
  }
  get length() {
    return this.data.length;
  }
  get peek() {
    return peek2(this.options, this.data);
  }
};
function mutable$12(options = {}, ...startingItems) {
  return new QueueMutable3({ ...options }, [...startingItems]);
}
var trimStack2 = (opts, stack, toAdd) => {
  const potentialLength = stack.length + toAdd.length;
  const policy = opts.discardPolicy ?? `additions`;
  const capacity = opts.capacity ?? potentialLength;
  const toRemove = potentialLength - capacity;
  if (opts.debug) console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);
  switch (policy) {
    case `additions`: {
      if (opts.debug) console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`);
      if (stack.length === opts.capacity) return stack;
      else return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];
    }
    case `newer`:
      if (toRemove >= stack.length) return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);
      else {
        if (opts.debug) console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);
        return [...stack.slice(0, stack.length - toRemove), ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1))];
      }
    case `older`:
      return [...stack, ...toAdd].slice(toRemove);
    default:
      throw new Error(`Unknown discard policy ${policy}`);
  }
};
var push2 = (opts, stack, ...toAdd) => {
  const potentialLength = stack.length + toAdd.length;
  const overSize = opts.capacity && potentialLength > opts.capacity;
  const toReturn = overSize ? trimStack2(opts, stack, toAdd) : [...stack, ...toAdd];
  return toReturn;
};
var pop2 = (opts, stack) => {
  if (stack.length === 0) throw new Error(`Stack is empty`);
  return stack.slice(0, -1);
};
var peek$12 = (opts, stack) => stack.at(-1);
var isEmpty$12 = (opts, stack) => stack.length === 0;
var isFull$12 = (opts, stack) => {
  if (opts.capacity) return stack.length >= opts.capacity;
  return false;
};
var StackMutable2 = class {
  opts;
  data;
  constructor(opts = {}, data = []) {
    this.opts = opts;
    this.data = data;
  }
  /**
  * Push data onto the stack.
  * If `toAdd` is empty, nothing happens
  * @param toAdd Data to add
  * @returns Length of stack
  */
  push(...toAdd) {
    if (toAdd.length === 0) return this.data.length;
    this.data = push2(this.opts, this.data, ...toAdd);
    return this.data.length;
  }
  forEach(fn2) {
    this.data.forEach(fn2);
  }
  forEachFromTop(fn2) {
    [...this.data].reverse().forEach(fn2);
  }
  pop() {
    const v3 = peek$12(this.opts, this.data);
    this.data = pop2(this.opts, this.data);
    return v3;
  }
  get isEmpty() {
    return isEmpty$12(this.opts, this.data);
  }
  get isFull() {
    return isFull$12(this.opts, this.data);
  }
  get peek() {
    return peek$12(this.opts, this.data);
  }
  get length() {
    return this.data.length;
  }
};
var mutable$32 = (opts = {}, ...startingItems) => new StackMutable2({ ...opts }, [...startingItems]);
var compare2 = (a3, b3, eq = isEqualValueIgnoreOrder, parent) => {
  const valueEqual = valueOrIdentityEqual2(a3, b3, eq);
  const childrenCompare = compareChildren2(a3, b3, eq);
  const diff = {
    valueChanged: !valueEqual,
    a: a3,
    b: b3,
    added: childrenCompare.added,
    removed: childrenCompare.removed,
    childChanged: false
  };
  const diffNode = {
    value: diff,
    childrenStore: [],
    parent
  };
  const childrenDiff = childrenCompare.identical.map((c5) => compare2(c5[0], c5[1], eq, diffNode));
  const someChildChange = hasChange2(diff) || childrenDiff.some((v3) => hasChange2(v3.value));
  setChildren2(diffNode, childrenDiff);
  diffNode.toString = () => toString$12(diffNode, 0);
  diffNode.value.childChanged = someChildChange;
  throwTreeTest2(diffNode);
  return diffNode;
};
var hasChange2 = (vv) => {
  if (vv === void 0) return false;
  if (vv.valueChanged) return true;
  if (vv.childChanged) return true;
  if (vv.added.length > 0) return true;
  if (vv.removed.length > 0) return true;
  return false;
};
var compareChildren2 = (a3, b3, eq = isEqualValueIgnoreOrder) => {
  const childrenOfA = [...a3.children()];
  const childrenOfB = [...b3.children()];
  const identical = [];
  const removed = [];
  for (const childA of childrenOfA) {
    let foundIndex = -1;
    for (const [index, childOfB] of childrenOfB.entries()) {
      const d3 = valueOrIdentityEqual2(childA, childOfB, eq);
      if (d3) {
        identical.push([childA, childOfB]);
        foundIndex = index;
        break;
      }
    }
    if (foundIndex === -1) removed.push(childA);
    else childrenOfB.splice(foundIndex, 1);
  }
  const added = [...childrenOfB];
  return {
    added,
    identical,
    removed
  };
};
var valueOrIdentityEqual2 = (a3, b3, eq) => {
  if (a3.getIdentity() === b3.getIdentity()) return true;
  if (eq(a3.getValue(), b3.getValue())) return true;
  return false;
};
var toStringSingle2 = (n6) => {
  return JSON.stringify(n6.getValue());
};
var toString$12 = (n6, indent = 0) => {
  if (n6 === void 0) return `(undefined)`;
  let t6 = toStringDiff2(n6.value, indent);
  for (const c5 of n6.childrenStore) t6 += toString$12(c5, indent + 2);
  return t6;
};
var toStringDiff2 = (n6, indent) => {
  const spaces = ` `.repeat(indent);
  if (n6 === void 0) return `${spaces}(undefined)`;
  const t6 = [];
  t6.push(`a: ${toStringSingle2(n6.a)} b: ${toStringSingle2(n6.b)}`);
  if (n6.valueChanged) t6.push(`Value changed. Child changed: ${n6.childChanged}`);
  else t6.push(`Value unchanged. Child changed: ${n6.childChanged}`);
  if (n6.added.length > 0) {
    t6.push(`Added:`);
    for (const c5 of n6.added) t6.push(` - ` + toStringSingle2(c5));
  }
  if (n6.removed.length > 0) {
    t6.push(`Removed: ${n6.removed.length}`);
    for (const c5 of n6.removed) t6.push(` - ` + toStringSingle2(c5));
  }
  t6.push(`----
`);
  return t6.map((line3) => spaces + line3).join(`
`);
};
var tree_mutable_exports2 = {};
__export(tree_mutable_exports2, {
  add: () => add$12,
  addValue: () => addValue$12,
  asDynamicTraversable: () => asDynamicTraversable$12,
  breadthFirst: () => breadthFirst$12,
  children: () => children$12,
  childrenLength: () => childrenLength$12,
  childrenValues: () => childrenValues2,
  compare: () => compare$12,
  computeMaxDepth: () => computeMaxDepth2,
  createNode: () => createNode2,
  depthFirst: () => depthFirst$22,
  findAnyChildByValue: () => findAnyChildByValue$12,
  findChildByValue: () => findChildByValue$12,
  findParentsValue: () => findParentsValue2,
  followValue: () => followValue$12,
  fromPlainObject: () => fromPlainObject2,
  getRoot: () => getRoot2,
  hasAnyChild: () => hasAnyChild$12,
  hasAnyParent: () => hasAnyParent$12,
  hasChild: () => hasChild$12,
  hasParent: () => hasParent$12,
  nodeDepth: () => nodeDepth2,
  parents: () => parents$12,
  parentsValues: () => parentsValues2,
  queryByValue: () => queryByValue2,
  queryParentsValue: () => queryParentsValue2,
  remove: () => remove3,
  root: () => root2,
  rootWrapped: () => rootWrapped2,
  setChildren: () => setChildren2,
  stripParentage: () => stripParentage2,
  throwTreeTest: () => throwTreeTest2,
  toStringDeep: () => toStringDeep$22,
  treeTest: () => treeTest2,
  value: () => value2,
  wrap: () => wrap4
});
var compare$12 = (a3, b3, eq) => {
  return compare2(asDynamicTraversable$12(a3), asDynamicTraversable$12(b3), eq);
};
var stripParentage2 = (node) => {
  const n6 = {
    value: node.value,
    childrenStore: node.childrenStore.map((c5) => stripParentage2(c5))
  };
  return n6;
};
var unwrapped2 = (node) => `wraps` in node ? node.wraps : node;
var wrapped2 = (node) => `wraps` in node ? node : wrap4(node);
var wrap4 = (n6) => {
  return {
    *children() {
      for (const c5 of n6.childrenStore) yield wrap4(c5);
    },
    getValue: () => n6.value,
    getIdentity: () => n6,
    *queryValue(value$1) {
      for (const v3 of queryByValue2(value$1, unwrapped2(n6))) yield wrap4(v3);
    },
    *queryParentsValue(child, value$1, eq) {
      for (const v3 of queryParentsValue2(unwrapped2(child), value$1, eq)) yield wrap4(v3);
    },
    *parentsValues(child) {
      yield* parentsValues2(unwrapped2(child));
    },
    findParentsValue(child, value$1, eq) {
      const n$1 = findParentsValue2(child, value$1, eq);
      if (n$1 !== void 0) return wrap4(n$1);
    },
    getParent: () => n6.parent === void 0 ? void 0 : wrap4(n6.parent),
    hasParent: (parent) => {
      return hasParent$12(n6, unwrapped2(parent));
    },
    hasAnyParent: (parent) => {
      return hasAnyParent$12(n6, unwrapped2(parent));
    },
    hasChild: (child) => {
      return hasChild$12(unwrapped2(child), n6);
    },
    hasAnyChild: (child) => {
      return hasAnyChild$12(unwrapped2(child), n6);
    },
    remove: () => {
      remove3(n6);
    },
    addValue: (value$1) => {
      const nodeValue = addValue$12(value$1, n6);
      return wrap4(nodeValue);
    },
    add: (child) => {
      add$12(unwrapped2(child), n6);
      return wrapped2(child);
    },
    wraps: n6
  };
};
var remove3 = (child) => {
  const p3 = child.parent;
  if (p3 === void 0) return;
  child.parent = void 0;
  p3.childrenStore = without(p3.childrenStore, child);
};
function* depthFirst$22(node) {
  if (!root2) return;
  const stack = new StackMutable2();
  stack.push(...node.childrenStore);
  let entry = stack.pop();
  while (entry) {
    yield entry;
    if (entry) stack.push(...entry.childrenStore);
    if (stack.isEmpty) break;
    entry = stack.pop();
  }
}
function* breadthFirst$12(node) {
  if (!node) return;
  const queue = new QueueMutable3();
  queue.enqueue(...node.childrenStore);
  let entry = queue.dequeue();
  while (entry) {
    yield entry;
    if (entry) queue.enqueue(...entry.childrenStore);
    if (queue.isEmpty) break;
    entry = queue.dequeue();
  }
}
function treeTest2(root$1, seen = []) {
  if (root$1.parent === root$1) return [
    false,
    `Root has itself as parent`,
    root$1
  ];
  if (seen.includes(root$1)) return [
    false,
    `Same node instance is appearing further in tree`,
    root$1
  ];
  seen.push(root$1);
  if (containsDuplicateInstances(root$1.childrenStore)) return [
    false,
    `Children list contains duplicates`,
    root$1
  ];
  for (const c5 of root$1.childrenStore) {
    if (c5.parent !== root$1) return [
      false,
      `Member of childrenStore does not have .parent set`,
      c5
    ];
    if (hasAnyChild$12(root$1, c5)) return [
      false,
      `Child has parent as its own child`,
      c5
    ];
    const v3 = treeTest2(c5, seen);
    if (!v3[0]) return v3;
  }
  return [
    true,
    ``,
    root$1
  ];
}
function throwTreeTest2(root$1) {
  const v3 = treeTest2(root$1);
  if (v3[0]) return;
  throw new Error(`${v3[1]} Node: ${toStringAbbreviate(v3[2].value, 30)}`, { cause: v3[2] });
}
function* children$12(root$1) {
  for (const c5 of root$1.childrenStore) yield c5;
}
function* childrenValues2(root$1) {
  for (const c5 of root$1.childrenStore) if (typeof c5.value !== `undefined`) yield c5.value;
}
function* parents$12(root$1) {
  let p3 = root$1.parent;
  while (p3) {
    yield p3;
    p3 = p3.parent;
  }
}
function nodeDepth2(node) {
  const p3 = [...parents$12(node)];
  return p3.length;
}
var hasChild$12 = (child, parent) => {
  for (const c5 of parent.childrenStore) if (c5 === child) return true;
  return false;
};
var findChildByValue$12 = (value$1, parent, eq = isEqualDefault) => {
  for (const c5 of parent.childrenStore) if (eq(value$1, c5.value)) return c5;
};
function* queryByValue2(value$1, parent, eq = isEqualDefault) {
  for (const c5 of parent.childrenStore) if (eq(value$1, c5.value)) yield c5;
}
var hasAnyChild$12 = (prospectiveChild, parent) => {
  for (const c5 of breadthFirst$12(parent)) if (c5 === prospectiveChild) return true;
  return false;
};
var findAnyChildByValue$12 = (value$1, parent, eq = isEqualDefault) => {
  for (const c5 of breadthFirst$12(parent)) if (eq(c5.value, value$1)) return c5;
};
var getRoot2 = (node) => {
  if (node.parent) return getRoot2(node.parent);
  return node;
};
var hasAnyParent$12 = (child, prospectiveParent) => {
  for (const p3 of parents$12(child)) if (p3 === prospectiveParent) return true;
  return false;
};
function* parentsValues2(child) {
  for (const p3 of parents$12(child)) if (typeof p3.value !== `undefined`) yield p3.value;
  return false;
}
function* queryParentsValue2(child, value$1, eq = isEqualDefault) {
  for (const p3 of parents$12(child)) if (typeof p3.value !== `undefined`) {
    if (eq(p3.value, value$1)) yield p3;
  }
  return false;
}
function findParentsValue2(child, value$1, eq = isEqualDefault) {
  for (const p3 of queryParentsValue2(child, value$1, eq)) return p3;
}
var hasParent$12 = (child, prospectiveParent) => {
  return child.parent === prospectiveParent;
};
var computeMaxDepth2 = (node) => {
  return computeMaxDepthImpl2(node, 0);
};
var computeMaxDepthImpl2 = (node, startingDepth = 0) => {
  let depth = startingDepth;
  for (const c5 of node.childrenStore) depth = Math.max(depth, computeMaxDepthImpl2(c5, startingDepth + 1));
  return depth;
};
var add$12 = (child, parent) => {
  throwAttemptedChild2(child, parent);
  const p3 = child.parent;
  parent.childrenStore = [...parent.childrenStore, child];
  child.parent = parent;
  if (p3) p3.childrenStore = without(p3.childrenStore, child);
};
var addValue$12 = (value$1, parent) => {
  return createNode2(value$1, parent);
};
var root2 = (value$1) => {
  return createNode2(value$1);
};
var fromPlainObject2 = (value$1, label = ``, parent, seen = []) => {
  const entries$1 = Object.entries(value$1);
  parent = parent === void 0 ? root2() : addValue$12({
    label,
    value: value$1
  }, parent);
  for (const entry of entries$1) {
    const value$2 = entry[1];
    if (seen.includes(value$2)) continue;
    seen.push(value$2);
    if (typeof entry[1] === `object`) fromPlainObject2(value$2, entry[0], parent, seen);
    else addValue$12({
      label: entry[0],
      value: value$2
    }, parent);
  }
  return parent;
};
var rootWrapped2 = (value$1) => {
  return wrap4(createNode2(value$1));
};
var createNode2 = (value$1, parent) => {
  const n6 = {
    childrenStore: [],
    parent,
    value: value$1
  };
  if (parent !== void 0) parent.childrenStore = [...parent.childrenStore, n6];
  return n6;
};
var childrenLength$12 = (node) => {
  return node.childrenStore.length;
};
var value2 = (node) => {
  return node.value;
};
var asDynamicTraversable$12 = (node) => {
  const t6 = {
    *children() {
      for (const c5 of node.childrenStore) yield asDynamicTraversable$12(c5);
    },
    getParent() {
      if (node.parent === void 0) return;
      return asDynamicTraversable$12(node.parent);
    },
    getValue() {
      return node.value;
    },
    getIdentity() {
      return node;
    }
  };
  return t6;
};
var throwAttemptedChild2 = (c5, parent) => {
  if (parent === c5) throw new Error(`Cannot add self as child`);
  if (c5.parent === parent) return;
  if (hasAnyParent$12(parent, c5)) throw new Error(`Child contains parent (1)`, { cause: c5 });
  if (hasAnyParent$12(c5, parent)) throw new Error(`Parent already contains child`, { cause: c5 });
  if (hasAnyChild$12(parent, c5)) throw new Error(`Child contains parent (2)`, { cause: c5 });
};
var setChildren2 = (parent, children$2) => {
  for (const c5 of children$2) throwAttemptedChild2(c5, parent);
  parent.childrenStore = [...children$2];
  for (const c5 of children$2) c5.parent = parent;
};
var toStringDeep$22 = (node, indent = 0) => {
  const t6 = `${`  `.repeat(indent)} + ${node.value ? JSON.stringify(node.value) : `-`}`;
  return node.childrenStore.length > 0 ? t6 + `
` + node.childrenStore.map((d3) => toStringDeep$22(d3, indent + 1)).join(`
`) : t6;
};
function* followValue$12(root$1, continuePredicate, depth = 1) {
  for (const c5 of root$1.childrenStore) {
    const value$1 = c5.value;
    if (value$1 === void 0) continue;
    if (continuePredicate(value$1, depth)) {
      yield c5.value;
      yield* followValue$12(c5, continuePredicate, depth + 1);
    }
  }
}
var traverse_object_exports2 = {};
__export(traverse_object_exports2, {
  asDynamicTraversable: () => asDynamicTraversable2,
  children: () => children2,
  create: () => create$3,
  createSimplified: () => createSimplified2,
  createWrapped: () => createWrapped2,
  depthFirst: () => depthFirst$12,
  getByPath: () => getByPath2,
  prettyPrint: () => prettyPrint2,
  prettyPrintEntries: () => prettyPrintEntries3,
  toStringDeep: () => toStringDeep$12,
  traceByPath: () => traceByPath2
});
function prettyPrintEntries3(entries$1) {
  if (entries$1.length === 0) return `(empty)`;
  let t6 = ``;
  for (const [index, entry] of entries$1.entries()) {
    t6 += `  `.repeat(index);
    t6 += entry.name + ` = ` + JSON.stringify(entry.leafValue) + `
`;
  }
  return t6;
}
var prettyPrint2 = (node, indent = 0, options = {}) => {
  resultThrow(nullUndefTest(node, `node`));
  const defaultName = options.name ?? `node`;
  const entry = getNamedEntry2(node, defaultName);
  const t6 = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.leafValue)}`;
  const childrenAsArray = [...children2(node, options)];
  return childrenAsArray.length > 0 ? t6 + `
` + childrenAsArray.map((d3) => prettyPrint2(d3.leafValue, indent + 1, {
    ...options,
    name: d3.name
  })).join(`
`) : t6;
};
var toStringDeep$12 = (node, indent = 0) => {
  let t6 = ` `.repeat(indent) + ` ${node.value?.name}`;
  if (node.value !== void 0) {
    if (`sourceValue` in node.value && `leafValue` in node.value) {
      let sourceValue = toStringAbbreviate(node.value.sourceValue, 20);
      const leafValue = toStringAbbreviate(node.value.leafValue, 20);
      sourceValue = sourceValue === leafValue ? `` : `source: ` + sourceValue;
      t6 += ` = ${leafValue} ${sourceValue}`;
    } else if (`sourceValue` in node.value && node.value.sourceValue !== void 0) t6 += ` = ${node.value.sourceValue}`;
    if (`ancestors` in node.value) t6 += ` (ancestors: ${node.value.ancestors.join(`, `)})`;
  }
  t6 += `
`;
  for (const c5 of node.childrenStore) t6 += toStringDeep$12(c5, indent + 1);
  return t6;
};
function* children2(node, options = {}) {
  resultThrow(nullUndefTest(node, `node`));
  const filteringOption = options.filter ?? `none`;
  const filterByValue = (v3) => {
    if (filteringOption === `none`) return [true, isPrimitive(v3)];
    else if (filteringOption === `leaves` && isPrimitive(v3)) return [true, true];
    else if (filteringOption === `branches` && !isPrimitive(v3)) return [true, false];
    return [false, isPrimitive(v3)];
  };
  if (Array.isArray(node)) for (const [index, element] of node.entries()) {
    const f5 = filterByValue(element);
    if (f5[0]) yield {
      name: index.toString(),
      _kind: `entry`,
      sourceValue: element,
      leafValue: f5[1] ? element : void 0
    };
  }
  else if (typeof node === `object`) {
    const entriesIter = `entries` in node ? node.entries() : Object.entries(node);
    for (const [name, value$1] of entriesIter) {
      const [filter2, isPrimitive$1] = filterByValue(value$1);
      if (filter2) yield {
        name,
        _kind: `entry`,
        sourceValue: value$1,
        leafValue: isPrimitive$1 ? value$1 : void 0
      };
    }
  }
}
function* depthFirst$12(node, options = {}, ancestors = []) {
  for (const c5 of children2(node, options)) {
    yield {
      ...c5,
      ancestors: [...ancestors],
      _kind: `entry-ancestors`
    };
    yield* depthFirst$12(c5.sourceValue, options, [...ancestors, c5.name]);
  }
}
function childByName2(name, node) {
  for (const d3 of children2(node)) if (d3.name === name) return d3;
}
function getByPath2(path3, node, options = {}) {
  const v3 = last$2(traceByPath2(path3, node, options));
  if (!v3) throw new Error(`Could not trace path: ${path3} `);
  return v3;
}
function* traceByPath2(path3, node, options = {}) {
  resultThrow(nullUndefTest(path3, `path`), nullUndefTest(node, `node`));
  const separator = options.separator ?? `.`;
  const pathSplit = path3.split(separator);
  const ancestors = [];
  for (const p3 of pathSplit) {
    const entry = childByName2(p3, node);
    if (!entry) {
      yield {
        name: p3,
        sourceValue: void 0,
        leafValue: void 0,
        ancestors,
        _kind: `entry-ancestors`
      };
      return;
    }
    node = entry.sourceValue;
    yield {
      ...entry,
      ancestors: [...ancestors],
      _kind: `entry-ancestors`
    };
    ancestors.push(p3);
  }
}
var asDynamicTraversable2 = (node, options = {}, ancestors = [], parent) => {
  const name = options.name ?? `object`;
  const t6 = {
    *children() {
      for (const { name: childName, sourceValue, leafValue } of children2(node, options)) yield asDynamicTraversable2(sourceValue, {
        ...options,
        name: childName
      }, [...ancestors, name], t6);
    },
    getParent() {
      return parent;
    },
    getValue() {
      return {
        name,
        sourceValue: node,
        ancestors,
        _kind: `entry-static`
      };
    },
    getIdentity() {
      return node;
    }
  };
  return t6;
};
var createWrapped2 = (node, options) => {
  return wrap4(create$3(node, options));
};
var create$3 = (node, options = {}) => {
  const valuesAtLeaves = options.valuesAtLeaves ?? false;
  const valueFor = valuesAtLeaves ? (v3) => {
    if (isPrimitive(v3)) return v3;
  } : (v3) => v3;
  return createImpl2(node, valueFor(node), options, []);
};
var createImpl2 = (sourceValue, leafValue, options = {}, ancestors) => {
  const defaultName = options.name ?? `object_ci`;
  const r5 = root2({
    name: defaultName,
    sourceValue: leafValue,
    ancestors: [...ancestors],
    _kind: `entry-static`
  });
  ancestors = [...ancestors, defaultName];
  for (const c5 of children2(sourceValue, options)) {
    const v3 = options.valuesAtLeaves ? c5.leafValue : c5.sourceValue;
    add$12(createImpl2(c5.sourceValue, v3, {
      ...options,
      name: c5.name
    }, ancestors), r5);
  }
  return r5;
};
var createSimplified2 = (node, options = {}) => {
  return stripParentage2(create$3(node, options));
};
function getNamedEntry2(node, defaultName = ``) {
  if (`name` in node && `leafValue` in node && `sourceValue` in node) return {
    name: node.name,
    _kind: `entry`,
    leafValue: node.leafValue,
    sourceValue: node.sourceValue
  };
  if (`name` in node) return {
    name: node.name,
    leafValue: node,
    sourceValue: node,
    _kind: `entry`
  };
  return {
    name: defaultName,
    leafValue: node,
    sourceValue: node,
    _kind: `entry`
  };
}
var pathed_exports2 = {};
__export(pathed_exports2, {
  addValueByPath: () => addValueByPath2,
  childrenLengthByPath: () => childrenLengthByPath2,
  clearValuesByPath: () => clearValuesByPath2,
  create: () => create$22,
  removeByPath: () => removeByPath2,
  valueByPath: () => valueByPath2,
  valuesByPath: () => valuesByPath2
});
var create$22 = (pathOpts = {}) => {
  let root$1;
  const add$2 = (value$1, path3) => {
    const n6 = addValueByPath2(value$1, path3, root$1, pathOpts);
    if (root$1 === void 0) root$1 = getRoot2(n6);
  };
  const prettyPrint$1 = () => {
    if (root$1 === void 0) return `(empty)`;
    return toStringDeep$22(root$1);
  };
  const getValue = (path3) => {
    if (root$1 === void 0) return;
    return valueByPath2(path3, root$1, pathOpts);
  };
  const remove$1 = (path3) => {
    if (root$1 === void 0) return false;
    return removeByPath2(path3, root$1, pathOpts);
  };
  const hasPath = (path3) => {
    if (root$1 === void 0) return false;
    const c5 = findChildByPath2(path3, root$1, pathOpts);
    return c5 !== void 0;
  };
  const getNode = (path3) => {
    if (root$1 === void 0) return;
    const c5 = findChildByPath2(path3, root$1, pathOpts);
    return c5;
  };
  const childrenLength$2 = (path3) => {
    if (root$1 === void 0) return 0;
    const c5 = findChildByPath2(path3, root$1, pathOpts);
    if (c5 === void 0) return 0;
    return c5.childrenStore.length;
  };
  const getValues = (path3) => {
    if (root$1 === void 0) return [];
    return valuesByPath2(path3, root$1, pathOpts);
  };
  const getRoot$1 = () => {
    return root$1;
  };
  const clearValues = (path3) => {
    if (root$1 === void 0) return false;
    return clearValuesByPath2(path3, root$1, pathOpts);
  };
  return {
    getRoot: getRoot$1,
    add: add$2,
    prettyPrint: prettyPrint$1,
    remove: remove$1,
    getValue,
    getValues,
    hasPath,
    childrenLength: childrenLength$2,
    getNode,
    clearValues
  };
};
var addValueByPath2 = (value$1, path3, node, pathOpts = {}) => {
  const separator = pathOpts.separator ?? `.`;
  const duplicatePath = pathOpts.duplicates ?? `overwrite`;
  const split = path3.split(separator);
  let count3 = 0;
  for (const p3 of split) {
    const lastEntry = count3 === split.length - 1;
    const found = findChildByLabel2(p3, node);
    if (found === void 0) {
      const labelled = {
        value: lastEntry ? value$1 : void 0,
        label: p3
      };
      node = createNode2(labelled, node);
    } else {
      node = found;
      if (lastEntry) switch (duplicatePath) {
        case `ignore`:
          break;
        case `allow`: {
          const existing = getValuesFromNode2(node);
          node.value = {
            values: [...existing, value$1],
            label: p3
          };
          break;
        }
        case `overwrite`: {
          node.value = {
            value: value$1,
            label: p3
          };
          break;
        }
      }
      else node = found;
    }
    count3++;
  }
  if (node === void 0) throw new Error(`Could not create tree`);
  return node;
};
var removeByPath2 = (path3, root$1, pathOpts = {}) => {
  if (root$1 === void 0) return false;
  const c5 = findChildByPath2(path3, root$1, pathOpts);
  if (c5 === void 0) return false;
  remove3(c5);
  return true;
};
var clearValuesByPath2 = (path3, root$1, pathOpts = {}) => {
  if (root$1 === void 0) return false;
  const c5 = findChildByPath2(path3, root$1, pathOpts);
  if (c5 === void 0) return false;
  c5.value = {
    label: c5.value?.label ?? ``,
    value: void 0
  };
  return true;
};
var childrenLengthByPath2 = (path3, node, pathOpts = {}) => {
  if (node === void 0) return 0;
  const c5 = findChildByPath2(path3, node, pathOpts);
  if (c5 === void 0) return 0;
  return c5.childrenStore.length;
};
var findChildByLabel2 = (label, node) => {
  if (node === void 0) return void 0;
  if (label === void 0) throw new Error(`Parameter 'label' cannot be undefined`);
  if (node.value?.label === label) return node;
  for (const c5 of node.childrenStore) if (c5.value?.label === label) return c5;
};
var valueByPath2 = (path3, node, pathOpts = {}) => {
  const values3 = valuesByPath2(path3, node, pathOpts);
  if (values3.length === 0) return void 0;
  if (values3.length > 1) throw new Error(`Multiple values at path. Use getValues instead`);
  return values3[0];
};
var getValuesFromNode2 = (c5) => {
  if (c5.value === void 0) return [];
  if (`values` in c5.value) return c5.value.values;
  if (`value` in c5.value) {
    if (c5.value.value === void 0) return [];
    return [c5.value.value];
  }
  return [];
};
var findChildByPath2 = (path3, node, pathOpts = {}) => {
  const separator = pathOpts.separator ?? `.`;
  const split = path3.split(separator);
  let c5 = node;
  for (const p3 of split) {
    c5 = findChildByLabel2(p3, c5);
    if (c5 === void 0) return;
  }
  return c5;
};
var valuesByPath2 = (path3, node, pathOpts = {}) => {
  const separator = pathOpts.separator ?? `.`;
  const split = path3.split(separator);
  let c5 = node;
  for (const p3 of split) {
    c5 = findChildByLabel2(p3, c5);
    if (c5 === void 0) return [];
  }
  return getValuesFromNode2(c5);
};
var traversable_tree_exports2 = {};
__export(traversable_tree_exports2, {
  breadthFirst: () => breadthFirst2,
  childrenLength: () => childrenLength2,
  couldAddChild: () => couldAddChild2,
  depthFirst: () => depthFirst2,
  find: () => find3,
  findAnyChildByValue: () => findAnyChildByValue2,
  findAnyParentByValue: () => findAnyParentByValue2,
  findByValue: () => findByValue2,
  findChildByValue: () => findChildByValue2,
  findParentByValue: () => findParentByValue2,
  followValue: () => followValue2,
  hasAnyChild: () => hasAnyChild2,
  hasAnyChildValue: () => hasAnyChildValue2,
  hasAnyParent: () => hasAnyParent2,
  hasAnyParentValue: () => hasAnyParentValue2,
  hasChild: () => hasChild2,
  hasChildValue: () => hasChildValue2,
  hasParent: () => hasParent2,
  hasParentValue: () => hasParentValue2,
  parents: () => parents2,
  siblings: () => siblings2,
  toString: () => toString2,
  toStringDeep: () => toStringDeep2
});
var childrenLength2 = (tree) => {
  return [...tree.children()].length;
};
var hasAnyParent2 = (child, possibleParent, eq) => {
  return hasParent2(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);
};
var hasAnyParentValue2 = (child, possibleParentValue, eq) => {
  if (typeof child === `undefined`) throw new TypeError(`Param 'child' is undefined`);
  return hasParentValue2(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);
};
var findAnyParentByValue2 = (child, possibleParentValue, eq) => {
  return findParentByValue2(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);
};
var hasParent2 = (child, possibleParent, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return false;
  const isChildTrav = isTraversable2(child);
  const isParentTrav = isTraversable2(possibleParent);
  const p3 = isChildTrav ? child.getParent() : child.parent;
  if (typeof p3 === `undefined`) return false;
  if (eq(p3, possibleParent)) return true;
  const pId = isChildTrav ? p3.getIdentity() : p3.value;
  const ppId = isParentTrav ? possibleParent.getIdentity() : possibleParent.value;
  if (eq(pId, ppId)) return true;
  return hasParent2(p3, possibleParent, eq, maxDepth - 1);
};
var hasParentValue2 = (child, possibleParentValue, eq = isEqualDefault, maxDepth = 0) => {
  if (child === void 0) throw new Error(`Param 'child' is undefined`);
  if (maxDepth < 0) return false;
  const p3 = `getParent` in child ? child.getParent() : child.parent;
  if (p3 === void 0) return false;
  const value$1 = `getValue` in p3 ? p3.getValue() : p3.value;
  if (eq(value$1, possibleParentValue)) return true;
  return hasParentValue2(p3, possibleParentValue, eq, maxDepth - 1);
};
var findParentByValue2 = (child, possibleParentValue, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return;
  const p3 = `getParent` in child ? child.getParent() : child.parent;
  if (p3 === void 0) return;
  const value$1 = `getValue` in p3 ? p3.getValue() : p3.value;
  if (eq(value$1, possibleParentValue)) return p3;
  return findParentByValue2(p3, possibleParentValue, eq, maxDepth - 1);
};
var couldAddChild2 = (parent, prospectiveChild, eq = isEqualDefault) => {
  if (eq(parent, prospectiveChild)) throw new Error(`Child equals parent`);
  if (hasAnyChild2(parent, prospectiveChild, eq)) throw new Error(`Circular. Parent already has child`);
  if (hasAnyChild2(prospectiveChild, parent, eq)) throw new Error(`Prospective child has parent as child relation`);
};
var hasAnyChild2 = (parent, possibleChild, eq = isEqualDefault) => {
  return hasChild2(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);
};
var hasAnyChildValue2 = (parent, possibleChildValue, eq = isEqualDefault) => {
  return hasChildValue2(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);
};
var hasChild2 = (parent, possibleChild, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return false;
  if (eq(parent, possibleChild)) return true;
  const pId = `getIdentity` in parent ? parent.getIdentity() : parent.value;
  const pcId = `getIdentity` in possibleChild ? possibleChild.getIdentity() : possibleChild.value;
  if (eq(pId, pcId)) return true;
  for (const c5 of breadthFirst2(parent, maxDepth)) {
    const cId = `getIdentity` in c5 ? c5.getIdentity() : c5.value;
    if (eq(c5, possibleChild)) return true;
    if (eq(cId, pcId)) return true;
  }
  return false;
};
var hasChildValue2 = (parent, possibleValue, eq = isEqualDefault, maxDepth = 0) => {
  if (maxDepth < 0) return false;
  if (eq(parent.getValue(), possibleValue)) return true;
  for (const c5 of breadthFirst2(parent, maxDepth)) {
    const v3 = c5.getValue();
    if (eq(v3, possibleValue)) return true;
  }
  return false;
};
function* siblings2(node) {
  const p3 = node.getParent();
  if (p3 === void 0) return;
  for (const s3 of p3.children()) {
    if (s3 === node) continue;
    yield s3;
  }
}
function* parents2(node) {
  if (isTraversable2(node)) {
    let p3 = node.getParent();
    while (p3 !== void 0) {
      yield p3;
      p3 = p3.getParent();
    }
  } else {
    let p3 = node.parent;
    while (p3 !== void 0) {
      yield p3;
      p3 = p3.parent;
    }
  }
}
function findAnyChildByValue2(parent, possibleValue, eq = isEqualDefault) {
  return findChildByValue2(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);
}
function findChildByValue2(parent, possibleValue, eq = isEqualDefault, maxDepth = 0) {
  if (maxDepth < 0) return;
  const isTraver = isTraversable2(parent);
  if (isTraver) {
    if (eq(parent.getValue(), possibleValue)) return parent;
  } else if (eq(parent.value, possibleValue)) return parent;
  for (const d3 of breadthFirst2(parent, maxDepth)) if (isTraver) {
    if (eq(d3.getValue(), possibleValue)) return d3;
  } else if (eq(d3.value, possibleValue)) return d3;
  return;
}
function* depthFirst2(root$1) {
  if (!root$1) return;
  const stack = new StackMutable2();
  let entry = root$1;
  while (entry) {
    const entries$1 = isTraversable2(entry) ? [...entry.children()] : [...entry.childrenStore];
    stack.push(...entries$1);
    if (stack.isEmpty) break;
    entry = stack.pop();
    if (entry) yield entry;
  }
}
function* breadthFirst2(root$1, depth = Number.MAX_SAFE_INTEGER) {
  if (!root$1) return;
  const isTrav = isTraversable2(root$1);
  const queue = isTrav ? new QueueMutable3() : new QueueMutable3();
  let entry = root$1;
  while (entry) {
    if (depth < 0) return;
    if (entry !== void 0) {
      const kids = `childrenStore` in entry ? entry.childrenStore : entry.children();
      for (const c5 of kids) {
        yield c5;
        queue.enqueue(c5);
      }
    }
    entry = queue.dequeue();
    depth--;
  }
}
function find3(root$1, predicate, order = `breadth`) {
  if (predicate(root$1)) return root$1;
  const iter = order === `breadth` ? breadthFirst2 : depthFirst2;
  for (const c5 of iter(root$1)) if (predicate(c5)) return c5;
}
function findByValue2(root$1, predicate, order = `breadth`) {
  if (predicate(root$1.getValue())) return root$1;
  const iter = order === `breadth` ? breadthFirst2 : depthFirst2;
  for (const c5 of iter(root$1)) if (predicate(c5.getValue())) return c5;
}
function* followValue2(root$1, continuePredicate, depth = 1) {
  for (const c5 of root$1.children()) if (continuePredicate(c5.getValue(), depth)) {
    yield c5.getValue();
    yield* followValue2(c5, continuePredicate, depth + 1);
  }
}
function toStringDeep2(node, depth = 0) {
  if (node === void 0) return `(undefined)`;
  if (node === null) return `(null)`;
  const v3 = node.getValue();
  let type = typeof v3;
  if (Array.isArray(v3)) type = `array`;
  let t6 = `  `.repeat(depth) + `value: ${JSON.stringify(v3)} (${type})
`;
  for (const n6 of node.children()) t6 += toStringDeep2(n6, depth + 1);
  return t6;
}
function toString2(...nodes) {
  let t6 = ``;
  for (const node of nodes) {
    const v3 = node.getValue();
    const vString = toStringAbbreviate(v3);
    const children$2 = [...node.children()];
    const parent = node.getParent();
    let type = typeof v3;
    if (Array.isArray(v3)) type = `array`;
    t6 += `value: ${vString} (${type}) kids: ${children$2.length} parented: ${parent ? `y` : `n`}
`;
  }
  return t6;
}
var tree_exports2 = {};
__export(tree_exports2, {
  FromObject: () => traverse_object_exports2,
  Mutable: () => tree_mutable_exports2,
  Pathed: () => pathed_exports2,
  Traverse: () => traversable_tree_exports2,
  compare: () => compare2,
  isTraversable: () => isTraversable2,
  isTreeNode: () => isTreeNode2,
  toTraversable: () => toTraversable2
});
var toTraversable2 = (node) => {
  if (isTraversable2(node)) return node;
  if (isTreeNode2(node)) return asDynamicTraversable$12(node);
  if (typeof node === `object`) return asDynamicTraversable2(node);
  throw new Error(`Parameter 'node' not convertible`);
};
var isTreeNode2 = (node) => {
  if (`parent` in node && `childrenStore` in node && `value` in node) {
    if (Array.isArray(node.childrenStore)) return true;
  }
  return false;
};
var isTraversable2 = (node) => {
  return `children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node;
};
var StackImmutable3 = class StackImmutable4 {
  opts;
  data;
  constructor(opts = {}, data = []) {
    this.opts = opts;
    this.data = data;
  }
  push(...toAdd) {
    return new StackImmutable4(this.opts, push2(this.opts, this.data, ...toAdd));
  }
  pop() {
    return new StackImmutable4(this.opts, pop2(this.opts, this.data));
  }
  forEach(fn2) {
    this.data.forEach(fn2);
  }
  forEachFromTop(fn2) {
    [...this.data].reverse().forEach(fn2);
  }
  get isEmpty() {
    return isEmpty$12(this.opts, this.data);
  }
  get isFull() {
    return isFull$12(this.opts, this.data);
  }
  get peek() {
    return peek$12(this.opts, this.data);
  }
  get length() {
    return this.data.length;
  }
};
var immutable$32 = (options = {}, ...startingItems) => new StackImmutable3({ ...options }, [...startingItems]);
var stack_exports2 = {};
__export(stack_exports2, {
  StackImmutable: () => StackImmutable3,
  StackMutable: () => StackMutable2,
  immutable: () => immutable$32,
  isEmpty: () => isEmpty$12,
  isFull: () => isFull$12,
  mutable: () => mutable$32,
  peek: () => peek$12,
  pop: () => pop2,
  push: () => push2,
  trimStack: () => trimStack2
});
var mutable$22 = (keyString) => new SetStringMutable2(keyString);
var SetStringMutable2 = class extends SimpleEventEmitter {
  store = /* @__PURE__ */ new Map();
  keyString;
  /**
  * Constructor
  * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`
  */
  constructor(keyString) {
    super();
    this.keyString = keyString ?? defaultKeyer;
  }
  /**
  * Number of items stored in set
  */
  get size() {
    return this.store.size;
  }
  /**
  * Adds one or more items to set. `add` event is fired for each item
  * @param values items to add
  */
  add(...values3) {
    let somethingAdded = false;
    for (const value$1 of values3) {
      const isUpdated = this.has(value$1);
      this.store.set(this.keyString(value$1), value$1);
      super.fireEvent(`add`, {
        value: value$1,
        updated: isUpdated
      });
      if (!isUpdated) somethingAdded = true;
    }
    return somethingAdded;
  }
  /**
  * Returns values from set as an iterable
  * @returns
  */
  values() {
    return this.store.values();
  }
  /**
  * Clear items from set
  */
  clear() {
    this.store.clear();
    super.fireEvent(`clear`, true);
  }
  /**
  * Delete value from set.
  * @param v Value to delete
  * @returns _True_ if item was found and removed
  */
  delete(v3) {
    const isDeleted = this.store.delete(this.keyString(v3));
    if (isDeleted) super.fireEvent(`delete`, v3);
    return isDeleted;
  }
  /**
  * Returns _true_ if item exists in set
  * @param v
  * @returns
  */
  has(v3) {
    return this.store.has(this.keyString(v3));
  }
  /**
  * Returns array copy of set
  * @returns Array copy of set
  */
  toArray() {
    return [...this.store.values()];
  }
};
var SetStringImmutable3 = class SetStringImmutable4 {
  store;
  keyString;
  constructor(keyString, map$12) {
    this.store = map$12 ?? /* @__PURE__ */ new Map();
    this.keyString = keyString ?? defaultKeyer;
  }
  get size() {
    return this.store.size;
  }
  add(...values3) {
    const s3 = new Map(this.store);
    for (const v3 of values3) {
      const key = this.keyString(v3);
      s3.set(key, v3);
    }
    return new SetStringImmutable4(this.keyString, s3);
  }
  delete(v3) {
    const s3 = new Map(this.store);
    const key = this.keyString(v3);
    if (s3.delete(key)) return new SetStringImmutable4(this.keyString, s3);
    return this;
  }
  has(v3) {
    const key = this.keyString(v3);
    return this.store.has(key);
  }
  toArray() {
    return [...this.store.values()];
  }
  *values() {
    yield* this.store.values();
  }
};
var immutable$22 = (keyString = toStringDefault) => new SetStringImmutable3(keyString);
var MassiveSet3 = class MassiveSet4 {
  #depth;
  #maxDepth;
  children = /* @__PURE__ */ new Map();
  values = [];
  constructor(maxDepth = 1, depth = 0) {
    this.#depth = depth;
    this.#maxDepth = maxDepth;
  }
  /**
  * Returns the number of values stored in just this level of the set
  * @returns
  */
  sizeLocal() {
    return this.values.length;
  }
  /**
  * Returns the number of branches at this node
  * Use {@link sizeChildrenDeep} to count all branches recursively
  * @returns
  */
  sizeChildren() {
    return [...this.children.values()].length;
  }
  sizeChildrenDeep() {
    let t6 = this.sizeChildren();
    for (const c5 of this.children.values()) t6 += c5.sizeChildrenDeep();
    return t6;
  }
  /**
  * Returns the total number of values stored in the set
  */
  size() {
    let x3 = this.values.length;
    for (const set$13 of this.children.values()) x3 += set$13.size();
    return x3;
  }
  add(value$1) {
    if (typeof value$1 !== `string`) throw new Error(`Param 'value' must be a string. Got: ${typeof value$1}`);
    if (value$1.length === 0) throw new Error(`Param 'value' is empty`);
    const destination = this.#getChild(value$1, true);
    if (destination === this) {
      if (!this.hasLocal(value$1)) this.values.push(value$1);
      return;
    }
    if (!destination) throw new Error(`Could not create child set for: ${value$1}`);
    destination.add(value$1);
  }
  remove(value$1) {
    if (typeof value$1 !== `string`) throw new Error(`Param 'value' must be a string. Got: ${typeof value$1}`);
    if (value$1.length === 0) throw new Error(`Param 'value' is empty`);
    const destination = this.#getChild(value$1, false);
    if (destination === void 0) return false;
    if (destination === this) {
      if (this.hasLocal(value$1)) {
        this.values = this.values.filter((v3) => v3 !== value$1);
        return true;
      }
      return false;
    }
    return destination.remove(value$1);
  }
  debugDump() {
    const r5 = this.#dumpToArray();
    for (const rr2 of r5) console.log(rr2);
  }
  #dumpToArray(depth = 0) {
    const r5 = [];
    r5.push(`Depth: ${this.#depth} Max: ${this.#maxDepth}`);
    for (const [key, value$1] of this.children.entries()) {
      const dumped = value$1.#dumpToArray(depth + 1);
      r5.push(` key: ${key}`);
      for (const d3 of dumped) r5.push(` `.repeat(depth + 1) + d3);
    }
    r5.push(`Values: (${this.values.length})`);
    for (const v3 of this.values) r5.push(` ${v3}`);
    return r5.map((line3) => ` `.repeat(depth) + line3);
  }
  #getChild(value$1, create$4) {
    if (value$1 === void 0) throw new Error(`Param 'value' undefined`);
    if (this.#depth === this.#maxDepth) return this;
    if (value$1.length <= this.#depth) return this;
    const k3 = value$1[this.#depth];
    if (k3 === void 0) throw new Error(`Logic error. Depth: ${this.#depth} Len: ${value$1.length}`);
    let child = this.children.get(k3);
    if (child === void 0 && create$4) {
      child = new MassiveSet4(this.#maxDepth, this.#depth + 1);
      this.children.set(k3, child);
    }
    return child;
  }
  /**
  * Returns _true_ if `value` stored on this node
  * @param value
  * @returns
  */
  hasLocal(value$1) {
    for (const v3 of this.values) if (v3 === value$1) return true;
    return false;
  }
  has(value$1) {
    if (typeof value$1 !== `string`) return false;
    const destination = this.#getChild(value$1, false);
    if (destination === void 0) return false;
    if (destination === this) return this.hasLocal(value$1);
    return destination.has(value$1);
  }
};
var set_exports2 = {};
__export(set_exports2, {
  MassiveSet: () => MassiveSet3,
  SetStringImmutable: () => SetStringImmutable3,
  SetStringMutable: () => SetStringMutable2,
  immutable: () => immutable$22,
  mutable: () => mutable$22
});
var PriorityMutable2 = class extends QueueMutable3 {
  constructor(opts = {}) {
    if (opts.eq === void 0) opts = {
      ...opts,
      eq: (a3, b3) => {
        return isEqualDefault(a3.item, b3.item);
      }
    };
    super(opts);
  }
  /**
  * Adds an item with a given priority
  * @param item Item
  * @param priority Priority (higher numeric value means higher priority)
  */
  enqueueWithPriority(item, priority$1) {
    resultThrow(numberTest(priority$1, `positive`));
    super.enqueue({
      item,
      priority: priority$1
    });
  }
  changePriority(item, priority$1, addIfMissing = false, eq) {
    if (item === void 0) throw new Error(`Item cannot be undefined`);
    let toDelete;
    for (const d3 of this.data) if (eq) {
      if (eq(d3.item, item)) {
        toDelete = d3;
        break;
      }
    } else if (this.eq(d3, {
      item,
      priority: 0
    })) {
      toDelete = d3;
      break;
    }
    if (toDelete === void 0 && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(item)}`);
    if (toDelete !== void 0) this.removeWhere((item$1) => toDelete === item$1);
    this.enqueueWithPriority(item, priority$1);
  }
  dequeueMax() {
    const m4 = last(max$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    this.removeWhere((item) => item === m4);
    return m4.item;
  }
  dequeueMin() {
    const m4 = last(max$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    this.removeWhere((item) => item.item === m4);
    return m4.item;
  }
  peekMax() {
    const m4 = last(max$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    return m4.item;
  }
  peekMin() {
    const m4 = last(min$1(this.data, (a3, b3) => a3.priority >= b3.priority));
    if (m4 === void 0) return;
    return m4.item;
  }
};
function priority2(opts = {}) {
  return new PriorityMutable2(opts);
}
var QueueImmutable3 = class QueueImmutable4 {
  opts;
  #data;
  /**
  * Creates an instance of Queue.
  * @param {QueueOpts} opts Options foor queue
  * @param {V[]} data Initial data. Index 0 is front of queue
  */
  constructor(opts = {}, data = []) {
    if (opts === void 0) throw new Error(`opts parameter undefined`);
    this.opts = opts;
    this.#data = data;
  }
  forEach(fn2) {
    for (let index = this.#data.length - 1; index >= 0; index--) fn2(this.#data[index]);
  }
  forEachFromFront(fn2) {
    this.#data.forEach((item) => {
      fn2(item);
    });
  }
  enqueue(...toAdd) {
    return new QueueImmutable4(this.opts, enqueue2(this.opts, this.#data, ...toAdd));
  }
  dequeue() {
    return new QueueImmutable4(this.opts, dequeue2(this.opts, this.#data));
  }
  get isEmpty() {
    return isEmpty2(this.opts, this.#data);
  }
  get isFull() {
    return isFull2(this.opts, this.#data);
  }
  get length() {
    return this.#data.length;
  }
  get peek() {
    return peek2(this.opts, this.#data);
  }
  toArray() {
    return [...this.#data];
  }
};
var immutable$12 = (options = {}, ...startingItems) => {
  options = { ...options };
  return new QueueImmutable3(options, [...startingItems]);
};
var queue_exports2 = {};
__export(queue_exports2, {
  PriorityMutable: () => PriorityMutable2,
  QueueImmutable: () => QueueImmutable3,
  QueueMutable: () => QueueMutable3,
  debug: () => debug2,
  dequeue: () => dequeue2,
  enqueue: () => enqueue2,
  immutable: () => immutable$12,
  isEmpty: () => isEmpty2,
  isFull: () => isFull2,
  mutable: () => mutable$12,
  peek: () => peek2,
  priority: () => priority2,
  trimQueue: () => trimQueue2
});
var create$12 = (options = {}) => new ExpiringMap2(options);
var ExpiringMap2 = class extends SimpleEventEmitter {
  capacity;
  store;
  evictPolicy;
  autoDeleteElapsedMs;
  autoDeletePolicy;
  autoDeleteTimer;
  disposed = false;
  constructor(opts = {}) {
    super();
    this.capacity = opts.capacity ?? -1;
    resultThrow(integerTest(this.capacity, `nonZero`, `capacity`));
    this.store = /* @__PURE__ */ new Map();
    if (opts.evictPolicy && this.capacity <= 0) throw new Error(`evictPolicy is set, but no capacity limit is set`);
    this.evictPolicy = opts.evictPolicy ?? `none`;
    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;
    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;
    if (this.autoDeleteElapsedMs > 0) this.autoDeleteTimer = setInterval(() => {
      this.#maintain();
    }, Math.max(1e3, this.autoDeleteElapsedMs * 2));
  }
  dispose() {
    if (this.disposed) return;
    this.disposed = true;
    if (this.autoDeleteTimer) {
      clearInterval(this.autoDeleteTimer);
      this.autoDeleteTimer = void 0;
    }
  }
  /**
  * Returns the number of keys being stored.
  */
  get keyLength() {
    return this.store.size;
  }
  *entries() {
    for (const entry of this.store.entries()) yield [entry[0], entry[1].value];
  }
  *values() {
    for (const v3 of this.store.values()) yield v3.value;
  }
  *keys() {
    yield* this.store.keys();
  }
  /**
  * Returns the elapsed time since `key`
  * was set. Returns _undefined_ if `key`
  * does not exist
  */
  elapsedSet(key) {
    const v3 = this.store.get(key);
    if (typeof v3 === `undefined`) return;
    return Date.now() - v3.lastSet;
  }
  /**
  * Returns the elapsed time since `key`
  * was accessed. Returns _undefined_ if `key`
  * does not exist
  */
  elapsedGet(key) {
    const v3 = this.store.get(key);
    if (typeof v3 === `undefined`) return;
    return Date.now() - v3.lastGet;
  }
  /**
  * Returns true if `key` is stored.
  * Does not affect the key's last access time.
  * @param key
  * @returns
  */
  has(key) {
    return this.store.has(key);
  }
  /**
  * Gets an item from the map by key, returning
  * undefined if not present
  * @param key Key
  * @returns Value, or undefined
  */
  get(key) {
    const v3 = this.store.get(key);
    if (v3) {
      if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) this.store.set(key, {
        ...v3,
        lastGet: performance.now()
      });
      return v3.value;
    }
  }
  /**
  * Deletes the value under `key`, if present.
  *
  * Returns _true_ if something was removed.
  * @param key
  * @returns
  */
  delete(key) {
    const value$1 = this.store.get(key);
    if (!value$1) return false;
    const d3 = this.store.delete(key);
    this.fireEvent(`removed`, {
      key,
      value: value$1.value
    });
    return d3;
  }
  /**
  * Clears the contents of the map.
  * Note: does not fire `removed` event
  */
  clear() {
    this.store.clear();
  }
  /**
  * Updates the lastSet/lastGet time for a value
  * under `k`.
  *
  * Returns false if key was not found
  * @param key
  * @returns
  */
  touch(key) {
    const v3 = this.store.get(key);
    if (!v3) return false;
    this.store.set(key, {
      ...v3,
      lastSet: Date.now(),
      lastGet: Date.now()
    });
    return true;
  }
  findEvicteeKey() {
    if (this.evictPolicy === `none`) return;
    let sortBy = ``;
    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;
    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;
    else throw new Error(`Unknown eviction policy ${this.evictPolicy}`);
    const sorted = sortByValueProperty(this.store, sortBy);
    return sorted[0][0];
  }
  #maintain() {
    if (this.autoDeletePolicy === `none`) return;
    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);
  }
  /**
  * Deletes all values where elapsed time has past
  * for get/set or either.
  * ```js
  * // Delete all keys (and associated values) not accessed for a minute
  * em.deleteWithElapsed({mins:1}, `get`);
  * // Delete things that were set 1s ago
  * em.deleteWithElapsed(1000, `set`);
  * ```
  *
  * @param interval Interval
  * @param property Basis for deletion 'get','set' or 'either'
  * @returns Items removed
  */
  deleteWithElapsed(interval2, property) {
    const entries$1 = [...this.store.entries()];
    const prune = [];
    const intervalMs = intervalToMs(interval2, 1e3);
    const now = performance.now();
    for (const entry of entries$1) {
      const elapsedGet = now - entry[1].lastGet;
      const elapsedSet = now - entry[1].lastSet;
      const elapsed2 = property === `get` ? elapsedGet : property === `set` ? elapsedSet : Math.max(elapsedGet, elapsedSet);
      if (elapsed2 >= intervalMs) prune.push([entry[0], entry[1].value]);
    }
    for (const entry of prune) {
      this.store.delete(entry[0]);
      const eventArguments = {
        key: entry[0],
        value: entry[1]
      };
      this.fireEvent(`expired`, eventArguments);
      this.fireEvent(`removed`, eventArguments);
    }
    return prune;
  }
  /**
  * Sets the `key` to be `value`.
  *
  * If the key already exists, it is updated.
  *
  * If the map is full, according to its capacity,
  * another value is selected for removal.
  * @param key
  * @param value
  * @returns
  */
  set(key, value$1) {
    const existing = this.store.get(key);
    if (existing) {
      this.store.set(key, {
        ...existing,
        lastSet: performance.now()
      });
      return;
    }
    if (this.keyLength === this.capacity && this.capacity > 0) {
      const key$1 = this.findEvicteeKey();
      if (!key$1) throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);
      const existing$1 = this.store.get(key$1);
      this.store.delete(key$1);
      if (existing$1) {
        const eventArguments = {
          key: key$1,
          value: existing$1.value
        };
        this.fireEvent(`expired`, eventArguments);
        this.fireEvent(`removed`, eventArguments);
      }
    }
    this.store.set(key, {
      lastGet: 0,
      lastSet: performance.now(),
      value: value$1
    });
    this.fireEvent(`newKey`, {
      key,
      value: value$1
    });
  }
};
var firstEntry2 = (map$12, predicate) => {
  for (const e5 of map$12.entries()) {
    const value$1 = e5[1];
    for (const subValue of value$1) if (predicate(subValue, e5[0])) return e5;
  }
};
var lengthMax2 = (map$12) => {
  let largest = ["", 0];
  for (const e5 of map$12.keysAndCounts()) if (e5[1] > largest[1]) largest = e5;
  return largest[1];
};
var firstEntryByValue2 = (map$12, value$1, isEqual4 = isEqualDefault) => {
  for (const e5 of map$12.entries()) {
    const value_ = e5[1];
    for (const subValue of value_) if (isEqual4(subValue, value$1)) return e5;
  }
};
var MapOfSimpleBase2 = class {
  map;
  groupBy;
  valueEq;
  /**
  * Constructor
  * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify
  * @param valueEq Compare values. By default uses JS logic for equality
  */
  constructor(groupBy2 = defaultKeyer, valueEq = isEqualDefault, initial = []) {
    this.groupBy = groupBy2;
    this.valueEq = valueEq;
    this.map = new Map(initial);
  }
  /**
  * Returns _true_ if `key` exists
  * @param key
  * @returns
  */
  has(key) {
    return this.map.has(key);
  }
  /**
  * Returns _true_ if `value` exists under `key`.
  * @param key Key
  * @param value Value to seek under `key`
  * @returns _True_ if `value` exists under `key`.
  */
  hasKeyValue(key, value$1) {
    const values3 = this.map.get(key);
    if (!values3) return false;
    for (const v3 of values3) if (this.valueEq(v3, value$1)) return true;
    return false;
  }
  /**
  * Debug dump of contents
  * @returns
  */
  debugString() {
    let r5 = ``;
    const keys = [...this.map.keys()];
    keys.every((k3) => {
      const v3 = this.map.get(k3);
      if (v3 === void 0) return;
      r5 += k3 + ` (${v3.length}) = ${JSON.stringify(v3)}\r
`;
    });
    return r5;
  }
  /**
  * Return number of values stored under `key`.
  * Returns 0 if `key` is not found.
  * @param key
  * @returns
  */
  count(key) {
    const values3 = this.map.get(key);
    if (!values3) return 0;
    return values3.length;
  }
  /**
  * Returns first key that contains `value`
  * @param value
  * @param eq
  * @returns
  */
  firstKeyByValue(value$1, eq = isEqualDefault) {
    const entry = firstEntryByValue2(this, value$1, eq);
    if (entry) return entry[0];
  }
  /**
  * Iterate over all entries
  */
  *entriesFlat() {
    for (const key of this.map.keys()) for (const value$1 of this.map.get(key)) yield [key, value$1];
  }
  /**
  * Iterate over keys and array of values for that key
  */
  *entries() {
    for (const [k3, v3] of this.map.entries()) yield [k3, [...v3]];
  }
  /**
  * Get all values under `key`
  * @param key
  * @returns
  */
  *get(key) {
    const m4 = this.map.get(key);
    if (!m4) return;
    yield* m4.values();
  }
  /**
  * Iterate over all keys
  */
  *keys() {
    yield* this.map.keys();
  }
  /**
  * Iterate over all values (regardless of key).
  * Use {@link values} to iterate over a set of values per key
  */
  *valuesFlat() {
    for (const entries$1 of this.map) yield* entries$1[1];
  }
  /**
  * Yields the values for each key in sequence, returning an array.
  * Use {@link valuesFlat} to iterate over all keys regardless of key.
  */
  *values() {
    for (const entries$1 of this.map) yield entries$1[1];
  }
  /**
  * Iterate over keys and length of values stored under keys
  */
  *keysAndCounts() {
    for (const entries$1 of this.map) yield [entries$1[0], entries$1[1].length];
  }
  /**
  * Returns the count of keys.
  */
  get lengthKeys() {
    return this.map.size;
  }
  /**
  * _True_ if empty
  */
  get isEmpty() {
    return this.map.size === 0;
  }
};
var MapOfSimpleMutable2 = class extends MapOfSimpleBase2 {
  addKeyedValues(key, ...values3) {
    const existing = this.map.get(key);
    if (existing === void 0) this.map.set(key, values3);
    else this.map.set(key, [...existing, ...values3]);
  }
  /**
  * Set `values` to `key`.
  * Previous data stored under `key` is thrown away.
  * @param key
  * @param values
  */
  setValues(key, values3) {
    this.map.set(key, values3);
  }
  /**
  * Adds a value, automatically extracting a key via the
  * `groupBy` function assigned in the constructor options.
  * @param values Adds several values
  */
  addValue(...values3) {
    for (const v3 of values3) {
      const key = this.groupBy(v3);
      this.addKeyedValues(key, v3);
    }
  }
  /**
  * Delete `value` under a particular `key`
  * @param key
  * @param value
  * @returns _True_ if `value` was found under `key`
  */
  deleteKeyValue(key, value$1) {
    const existing = this.map.get(key);
    if (existing === void 0) return false;
    const without$1 = existing.filter((existingValue) => !this.valueEq(existingValue, value$1));
    this.map.set(key, without$1);
    return without$1.length < existing.length;
  }
  /**
  * Deletes `value` regardless of key.
  *
  * Uses the constructor-defined equality function.
  * @param value Value to delete
  * @returns
  */
  deleteByValue(value$1) {
    let del$1 = false;
    const entries$1 = [...this.map.entries()];
    for (const keyEntries of entries$1) for (const values3 of keyEntries[1]) if (this.valueEq(values3, value$1)) {
      del$1 = true;
      this.deleteKeyValue(keyEntries[0], value$1);
    }
    return del$1;
  }
  /**
  * Deletes all values under `key`,
  * @param key
  * @returns _True_ if `key` was found and values stored
  */
  delete(key) {
    const values3 = this.map.get(key);
    if (!values3) return false;
    if (values3.length === 0) return false;
    this.map.delete(key);
    return true;
  }
  /**
  * Clear contents
  */
  clear() {
    this.map.clear();
  }
};
var ofSimpleMutable2 = (groupBy2 = defaultKeyer, valueEq = isEqualDefault) => new MapOfSimpleMutable2(groupBy2, valueEq);
var addArray2 = (map$12, data) => {
  const x3 = new Map(map$12.entries());
  for (const d3 of data) {
    if (d3[0] === void 0) throw new Error(`key cannot be undefined`);
    if (d3[1] === void 0) throw new Error(`value cannot be undefined`);
    x3.set(d3[0], d3[1]);
  }
  return x3;
};
var addObjects2 = (map$12, data) => {
  const x3 = new Map(map$12.entries());
  for (const d3 of data) {
    if (d3.key === void 0) throw new Error(`key cannot be undefined`);
    if (d3.value === void 0) throw new Error(`value cannot be undefined`);
    x3.set(d3.key, d3.value);
  }
  return x3;
};
var has2 = (map$12, key) => map$12.has(key);
var add2 = (map$12, ...data) => {
  if (map$12 === void 0) throw new Error(`map parameter is undefined`);
  if (data === void 0) throw new Error(`data parameter i.s undefined`);
  if (data.length === 0) return map$12;
  const firstRecord = data[0];
  const isObject = typeof firstRecord.key !== `undefined` && typeof firstRecord.value !== `undefined`;
  return isObject ? addObjects2(map$12, data) : addArray2(map$12, data);
};
var set2 = (map$12, key, value$1) => {
  const x3 = new Map(map$12.entries());
  x3.set(key, value$1);
  return x3;
};
var del2 = (map$12, key) => {
  const x3 = new Map(map$12.entries());
  x3.delete(key);
  return x3;
};
var immutable3 = (dataOrMap) => {
  if (dataOrMap === void 0) return immutable3([]);
  if (Array.isArray(dataOrMap)) return immutable3(add2(/* @__PURE__ */ new Map(), ...dataOrMap));
  const data = dataOrMap;
  return {
    add: (...itemsToAdd) => {
      const s3 = add2(data, ...itemsToAdd);
      return immutable3(s3);
    },
    set: (key, value$1) => {
      const s3 = set2(data, key, value$1);
      return immutable3(s3);
    },
    get: (key) => data.get(key),
    delete: (key) => immutable3(del2(data, key)),
    clear: () => immutable3(),
    has: (key) => data.has(key),
    entries: () => data.entries(),
    values: () => data.values(),
    isEmpty: () => data.size === 0
  };
};
var mutable2 = (...data) => {
  let m4 = add2(/* @__PURE__ */ new Map(), ...data);
  return {
    add: (...data$1) => {
      m4 = add2(m4, ...data$1);
    },
    delete: (key) => {
      m4 = del2(m4, key);
    },
    clear: () => {
      m4 = add2(/* @__PURE__ */ new Map());
    },
    set: (key, value$1) => {
      m4 = set2(m4, key, value$1);
    },
    get: (key) => m4.get(key),
    entries: () => m4.entries(),
    values: () => m4.values(),
    isEmpty: () => m4.size === 0,
    has: (key) => has2(m4, key)
  };
};
var MapOfMutableImpl2 = class extends SimpleEventEmitter {
  #map = /* @__PURE__ */ new Map();
  groupBy;
  type;
  constructor(type, opts = {}) {
    super();
    this.type = type;
    this.groupBy = opts.groupBy ?? toStringDefault;
  }
  /**
  * Returns the type name. For in-built implementations, it will be one of: array, set or circular
  */
  get typeName() {
    return this.type.name;
  }
  /**
  * Returns the number of keys
  */
  get lengthKeys() {
    return this.#map.size;
  }
  /**
  * Returns the length of the longest child list
  */
  get lengthMax() {
    let m4 = 0;
    for (const v3 of this.#map.values()) m4 = Math.max(m4, this.type.count(v3));
    return m4;
  }
  debugString() {
    const keys = [...this.#map.keys()];
    let r5 = `Keys: ${keys.join(`, `)}\r
`;
    for (const k3 of keys) {
      const v3 = this.#map.get(k3);
      if (v3 === void 0) r5 += ` - ${k3} (undefined)\r
`;
      else {
        const asArray2 = this.type.toArray(v3);
        if (asArray2 !== void 0) r5 += ` - ${k3} (${this.type.count(v3)}) = ${JSON.stringify(asArray2)}\r
`;
      }
    }
    return r5;
  }
  get isEmpty() {
    return this.#map.size === 0;
  }
  clear() {
    this.#map.clear();
    super.fireEvent(`clear`, true);
  }
  addKeyedValues(key, ...values3) {
    const set$13 = this.#map.get(key);
    if (set$13 === void 0) {
      this.#map.set(key, this.type.addKeyedValues(void 0, values3));
      super.fireEvent(`addedKey`, { key });
      super.fireEvent(`addedValues`, { values: values3 });
    } else {
      this.#map.set(key, this.type.addKeyedValues(set$13, values3));
      super.fireEvent(`addedValues`, { values: values3 });
    }
  }
  set(key, values3) {
    this.addKeyedValues(key, ...values3);
    return this;
  }
  addValue(...values3) {
    for (const v3 of values3) this.addKeyedValues(this.groupBy(v3), v3);
  }
  hasKeyValue(key, value$1, eq) {
    const m4 = this.#map.get(key);
    if (m4 === void 0) return false;
    return this.type.has(m4, value$1, eq);
  }
  has(key) {
    return this.#map.has(key);
  }
  deleteKeyValue(key, value$1) {
    const a3 = this.#map.get(key);
    if (a3 === void 0) return false;
    return this.deleteKeyValueFromMap(a3, key, value$1);
  }
  deleteKeyValueFromMap(map$12, key, value$1) {
    const preCount = this.type.count(map$12);
    const filtered = this.type.without(map$12, value$1);
    const postCount = filtered.length;
    this.#map.set(key, this.type.addKeyedValues(void 0, filtered));
    return preCount > postCount;
  }
  deleteByValue(value$1) {
    let something = false;
    [...this.#map.keys()].filter((key) => {
      const a3 = this.#map.get(key);
      if (!a3) throw new Error(`Bug: map could not be accessed`);
      if (this.deleteKeyValueFromMap(a3, key, value$1)) {
        something = true;
        if (this.count(key) === 0) this.delete(key);
      }
    });
    return something;
  }
  delete(key) {
    const a3 = this.#map.get(key);
    if (a3 === void 0) return false;
    this.#map.delete(key);
    this.fireEvent(`deleteKey`, { key });
    return true;
  }
  firstKeyByValue(value$1, eq = isEqualDefault) {
    const keys = [...this.#map.keys()];
    const found = keys.find((key) => {
      const a3 = this.#map.get(key);
      if (a3 === void 0) throw new Error(`Bug: map could not be accessed`);
      const r5 = this.type.has(a3, value$1, eq);
      return r5;
    });
    return found;
  }
  count(key) {
    const entry = this.#map.get(key);
    if (entry === void 0) return 0;
    return this.type.count(entry);
  }
  /**
  * Iterates over values stored under `key`
  * An empty array is returned if there are no values
  */
  *get(key) {
    const m4 = this.#map.get(key);
    if (m4 === void 0) return;
    yield* this.type.iterable(m4);
  }
  /**
  * Iterate over the values stored under `key`.
  * If key does not exist, iteration is essentially a no-op
  * @param key
  * @returns
  */
  *valuesFor(key) {
    const m4 = this.#map.get(key);
    if (m4 === void 0) return;
    yield* this.type.iterable(m4);
  }
  getSource(key) {
    return this.#map.get(key);
  }
  *keys() {
    yield* this.#map.keys();
  }
  *entriesFlat() {
    for (const entry of this.#map.entries()) for (const v3 of this.type.iterable(entry[1])) yield [entry[0], v3];
  }
  *valuesFlat() {
    for (const entry of this.#map.entries()) yield* this.type.iterable(entry[1]);
  }
  *entries() {
    for (const [k3, v3] of this.#map.entries()) {
      const temporary = [...this.type.iterable(v3)];
      yield [k3, temporary];
    }
  }
  *keysAndCounts() {
    for (const key of this.keys()) yield [key, this.count(key)];
  }
  merge(other) {
    for (const key of other.keys()) {
      const data = other.get(key);
      this.addKeyedValues(key, ...data);
    }
  }
  get size() {
    return this.#map.size;
  }
  get [Symbol.toStringTag]() {
    return this.#map[Symbol.toStringTag];
  }
};
var ofSetMutable2 = (options) => {
  const hash = options?.hash ?? toStringDefault;
  const comparer = (a3, b3) => hash(a3) === hash(b3);
  const t6 = {
    get name() {
      return `set`;
    },
    iterable: (source) => source.values(),
    addKeyedValues: (dest, values3) => addValue(dest, hash, `skip`, ...values3),
    count: (source) => source.size,
    find: (source, predicate) => findValue(source, predicate),
    filter: (source, predicate) => filterValues(source, predicate),
    toArray: (source) => toArray(source),
    has: (source, value$1) => hasAnyValue(source, value$1, comparer),
    without: (source, value$1) => without(toArray(source), value$1, comparer)
  };
  const m4 = new MapOfMutableImpl2(t6, options);
  return m4;
};
var ofCircularMutable2 = (options) => {
  const comparer = isEqualDefault;
  const t6 = {
    get name() {
      return `circular`;
    },
    addKeyedValues: (destination, values3) => {
      let ca2 = destination ?? new CircularArray3(options.capacity);
      for (const v3 of values3) ca2 = ca2.add(v3);
      return ca2;
    },
    count: (source) => source.length,
    find: (source, predicate) => source.find(predicate),
    filter: (source, predicate) => source.filter(predicate),
    toArray: (source) => source,
    iterable: (source) => source.values(),
    has: (source, value$1) => source.find((v3) => comparer(v3, value$1)) !== void 0,
    without: (source, value$1) => source.filter((v3) => !comparer(v3, value$1))
  };
  return new MapOfMutableImpl2(t6, options);
};
var NumberMap2 = class extends Map {
  defaultValue;
  constructor(defaultValue = 0) {
    super();
    this.defaultValue = defaultValue;
  }
  get(key) {
    const v3 = super.get(key);
    if (v3 === void 0) return this.defaultValue;
    return v3;
  }
  reset(key) {
    super.set(key, this.defaultValue);
    return this.defaultValue;
  }
  multiply(key, amount) {
    const v3 = super.get(key);
    let value$1 = v3 ?? this.defaultValue;
    value$1 *= amount;
    super.set(key, value$1);
    return value$1;
  }
  add(key, amount = 1) {
    const v3 = super.get(key);
    let value$1 = v3 ?? this.defaultValue;
    value$1 += amount;
    super.set(key, value$1);
    return value$1;
  }
  subtract(key, amount = 1) {
    const v3 = super.get(key);
    let value$1 = v3 ?? this.defaultValue;
    value$1 -= amount;
    super.set(key, value$1);
    return value$1;
  }
};
var ofArrayMutable2 = (options = {}) => {
  const convertToString3 = options.convertToString;
  const toStringFunction = typeof convertToString3 === `undefined` ? isEqualDefault : (a3, b3) => convertToString3(a3) === convertToString3(b3);
  const comparer = options.comparer ?? toStringFunction;
  const t6 = {
    get name() {
      return `array`;
    },
    addKeyedValues: (destination, values3) => {
      if (destination === void 0) return [...values3];
      return [...destination, ...values3];
    },
    iterable: (source) => source.values(),
    count: (source) => source.length,
    find: (source, predicate) => source.find((f5) => predicate(f5)),
    filter: (source, predicate) => source.filter((f5) => predicate(f5)),
    toArray: (source) => source,
    has: (source, value$1) => source.some((v3) => comparer(v3, value$1)),
    without: (source, value$1) => source.filter((v3) => !comparer(v3, value$1))
  };
  const m4 = new MapOfMutableImpl2(t6, options);
  return m4;
};
var MapOfSimple4 = class MapOfSimple5 extends MapOfSimpleBase2 {
  addKeyedValues(key, ...values3) {
    return this.addBatch([[key, values3]]);
  }
  addValue(...values3) {
    const asEntries = values3.map((v3) => [this.groupBy(v3), v3]);
    return this.addBatch(asEntries);
  }
  addBatch(entries$1) {
    const temporary = new Map([...this.map.entries()].map((e5) => [e5[0], [...e5[1]]]));
    for (const [key, list] of entries$1) {
      const existingList = temporary.get(key);
      if (typeof existingList === `undefined`) temporary.set(key, list);
      else existingList.push(...list);
    }
    return new MapOfSimple5(this.groupBy, this.valueEq, [...temporary.entries()]);
  }
  clear() {
    return new MapOfSimple5(this.groupBy, this.valueEq);
  }
  deleteKeyValue(_key, _value) {
    throw new Error(`Method not implemented.`);
  }
  deleteByValue(value$1, eq) {
    const entries$1 = [...this.map.entries()];
    const eqFunction = eq ?? this.valueEq;
    const x3 = entries$1.map((entry) => {
      const key = entry[0];
      const values3 = entry[1].filter((vv) => !eqFunction(vv, value$1));
      return [key, values3];
    });
    return new MapOfSimple5(this.groupBy, this.valueEq, x3);
  }
  delete(key) {
    const entries$1 = [...this.map.entries()].filter((e5) => e5[0] !== key);
    return new MapOfSimple5(this.groupBy, this.valueEq, entries$1);
  }
};
var ofSimple2 = (groupBy2 = defaultKeyer, valueEq = isEqualDefault) => new MapOfSimple4(groupBy2, valueEq);
var map_exports2 = {};
__export(map_exports2, {
  ExpiringMap: () => ExpiringMap2,
  MapOfMutableImpl: () => MapOfMutableImpl2,
  MapOfSimple: () => MapOfSimple4,
  MapOfSimpleMutable: () => MapOfSimpleMutable2,
  NumberMap: () => NumberMap2,
  addObjectEntriesMutate: () => addObjectEntriesMutate,
  addValue: () => addValue,
  addValueMutate: () => addValueMutate,
  addValueMutator: () => addValueMutator,
  deleteByValueCompareMutate: () => deleteByValueCompareMutate,
  expiringMap: () => create$12,
  filterValues: () => filterValues,
  findBySomeKey: () => findBySomeKey,
  findEntryByPredicate: () => findEntryByPredicate,
  findEntryByValue: () => findEntryByValue,
  findValue: () => findValue,
  firstEntry: () => firstEntry2,
  firstEntryByValue: () => firstEntryByValue2,
  fromIterable: () => fromIterable,
  fromObject: () => fromObject,
  getClosestIntegerKey: () => getClosestIntegerKey,
  getOrGenerate: () => getOrGenerate,
  getOrGenerateSync: () => getOrGenerateSync,
  hasAnyValue: () => hasAnyValue,
  hasKeyValue: () => hasKeyValue,
  immutable: () => immutable3,
  lengthMax: () => lengthMax2,
  mapOfSimpleMutable: () => ofSimpleMutable2,
  mapToArray: () => mapToArray,
  mapToObjectTransform: () => mapToObjectTransform,
  mergeByKey: () => mergeByKey,
  mutable: () => mutable2,
  ofArrayMutable: () => ofArrayMutable2,
  ofCircularMutable: () => ofCircularMutable2,
  ofSetMutable: () => ofSetMutable2,
  ofSimple: () => ofSimple2,
  ofSimpleMutable: () => ofSimpleMutable2,
  some: () => some,
  sortByValue: () => sortByValue,
  sortByValueProperty: () => sortByValueProperty,
  toArray: () => toArray,
  toObject: () => toObject,
  transformMap: () => transformMap,
  zipKeyValue: () => zipKeyValue
});
var Table2 = class {
  rows = [];
  rowLabels = [];
  colLabels = [];
  /**
  * Keep track of widest row
  */
  columnMaxLength = 0;
  /**
  * Gets the label for a given column index,
  * returning _undefined_ if not found.
  *
  * Case-sensitive
  * @param label Label to seek
  * @returns Index of column, or _undefined_ if not found
  */
  getColumnLabelIndex(label) {
    for (const [index, l3] of this.colLabels.entries()) if (l3 === label) return index;
  }
  /**
  * Gets the label for a given row index,
  * returning _undefined_ if not found.
  *
  * Case-sensitive
  * @param label Label to seek
  * @returns Index of row, or _undefined_ if not found
  */
  getRowLabelIndex(label) {
    for (const [index, l3] of this.rowLabels.entries()) if (l3 === label) return index;
  }
  /**
  * Dumps the values of the table to the console
  */
  print() {
    console.table([...this.rowsWithLabelsObject()]);
  }
  /**
  * Return a copy of table as nested array
  *
  * ```js
  * const t = new Table();
  * // add stuff
  * // ...
  * const m = t.asArray();
  * for (const row of m) {
  *  for (const colValue of row) {
  *    // iterate over all column values for this row
  *  }
  * }
  * ```
  *
  * Alternative: get value at row Y and column X
  * ```js
  * const value = m[y][x];
  * ```
  * @returns
  */
  asArray() {
    const r5 = [];
    for (const row of this.rows) if (row === void 0) r5.push([]);
    else r5.push([...row]);
    return r5;
  }
  /**
  * Return the number of rows
  */
  get rowCount() {
    return this.rows.length;
  }
  /**
  * Return the maximum number of columns in any row
  */
  get columnCount() {
    return this.columnMaxLength;
  }
  /**
  * Iterates over the table row-wise, in object format.
  * @see {@link rowsWithLabelsArray} to get rows in array format
  */
  *rowsWithLabelsObject() {
    for (let index = 0; index < this.rows.length; index++) {
      const labelledRow = this.getRowWithLabelsObject(index);
      yield labelledRow;
    }
  }
  /**
  * Iterates over each row, including the labels if available
  * @see {@link rowsWithLabelsObject} to get rows in object format
  */
  *rowsWithLabelsArray() {
    for (let index = 0; index < this.rows.length; index++) {
      const labelledRow = this.getRowWithLabelsArray(index);
      yield labelledRow;
    }
  }
  /**
  * Assign labels to columns
  * @param labels
  */
  labelColumns(...labels) {
    this.colLabels = labels;
  }
  /**
  * Assign label to a specific column
  * First column has an index of 0
  * @param columnIndex
  * @param label
  */
  labelColumn(columnIndex, label) {
    this.colLabels[columnIndex] = label;
  }
  /**
  * Label rows
  * @param labels Labels
  */
  labelRows(...labels) {
    this.rowLabels = labels;
  }
  /**
  * Assign label to a specific row
  * First row has an index of 0
  * @param rowIndex
  * @param label
  */
  labelRow(rowIndex, label) {
    this.rowLabels[rowIndex] = label;
  }
  /**
  * Adds a new row
  * @param data Columns
  */
  appendRow(...data) {
    this.columnMaxLength = Math.max(this.columnMaxLength, data.length);
    this.rows.push(data);
    return data;
  }
  /**
  * Gets a row along with labels, as an array
  * @param rowIndex
  * @returns
  */
  getRowWithLabelsArray(rowIndex) {
    const row = this.rows.at(rowIndex);
    if (row === void 0) return void 0;
    return row.map((value$1, index) => [this.colLabels.at(index), value$1]);
  }
  /**
  * Return a row of objects. Keys use the column labels.
  *
  * ```js
  * const row = table.getRowWithLabelsObject(10);
  * // eg:
  * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]
  * ```
  * @param rowIndex
  * @returns
  */
  getRowWithLabelsObject(rowIndex) {
    const row = this.rows.at(rowIndex);
    if (row === void 0) return void 0;
    const object = {};
    for (let index = 0; index < this.colLabels.length; index++) {
      const label = this.colLabels.at(index) ?? index.toString();
      object[label] = row[index];
    }
    return object;
  }
  /**
  * Gets or creates a row at given position
  * @param row Index or label of row
  * @returns
  */
  #getOrCreateRawRow(row) {
    const index = typeof row === `number` ? row : this.getRowLabelIndex(row);
    if (index === void 0) return {
      success: false,
      error: `row-label-notfound`
    };
    if (index < 0) return {
      success: false,
      error: `row-index-invalid`
    };
    if (index < this.rows.length) return {
      success: true,
      value: this.rows[index]
    };
    const newRow = [];
    this.rows[index] = newRow;
    return {
      success: true,
      value: newRow
    };
  }
  /**
  * Gets a copy of values at given row, specified by index or label
  * @param row
  * @returns Returns row or throws an error if label or index not found
  */
  row(row) {
    const r5 = this.#getRowRaw(row);
    if (resultIsError(r5)) throw new Error(r5.error);
    return [...r5.value];
  }
  /**
  * Set the value of row,columm.
  * Row is created if it doesn't exist, with the other column values being _undefined_
  * @param row Index or label
  * @param column Column
  * @param value Value to set at row,column
  */
  set(row, column, value$1) {
    const result = this.#getOrCreateRawRow(row);
    if (resultIsError(result)) throw new Error(result.error);
    const r5 = result.value;
    const columnIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);
    if (typeof columnIndex === `undefined`) throw new Error(`Column label '${column}' not found or is invalid`);
    if (columnIndex < 0) throw new Error(`Column index invalid (less than zero)`);
    r5[columnIndex] = value$1;
  }
  /**
  * Gets the value at a specified row and column.
  * Throws an error if coordinates are out of range or missing.
  * @param row Row index or label
  * @param column Column index or label
  * @returns
  */
  get(row, column) {
    const rowR = this.#getRowRaw(row);
    if (resultIsError(rowR)) throw new Error(rowR.error);
    const colR = this.#getColumnRaw(rowR.value, column);
    if (resultIsError(colR)) throw new Error(colR.error);
    return colR.value.value;
  }
  #getRowRaw(row) {
    let index = 0;
    if (typeof row === `number`) index = row;
    else {
      index = this.getRowLabelIndex(row);
      if (typeof index !== `number`) return {
        error: `row-label-notfound`,
        success: false
      };
    }
    if (typeof index !== `number`) return {
      error: `row-invalid`,
      success: false
    };
    if (index < 0 || index >= this.rows.length) return {
      error: `row-index-out-of-range`,
      success: false
    };
    return {
      success: true,
      value: this.rows[index]
    };
  }
  #getColumnRaw(row, column) {
    const colIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);
    if (typeof colIndex !== `number`) return {
      success: false,
      error: `col-label-notfound`
    };
    if (colIndex < 0 || colIndex >= row.length) return {
      success: false,
      error: `col-index-out-of-range`
    };
    return {
      success: true,
      value: {
        index: colIndex,
        value: row[colIndex]
      }
    };
  }
  /**
  * Set all the columns of a row to a specified value.
  *
  * By default, sets the number of columns corresponding to
  * the table's maximum column length. To set an arbitrary
  * length of the row, use `length`
  * @param row Index or label of row
  * @param length How wide the row is. If unset, uses the current maximum width of rows.
  * @param value Value to set
  */
  setRow(row, value$1, length3) {
    const rowResult = this.#getOrCreateRawRow(row);
    if (resultIsError(rowResult)) throw new Error(rowResult.error);
    const r5 = rowResult.value;
    const width = typeof length3 === `number` ? length3 : this.columnMaxLength;
    for (let columnNumber = 0; columnNumber < width; columnNumber++) r5[columnNumber] = value$1;
    return r5;
  }
};
var directed_graph_exports2 = {};
__export(directed_graph_exports2, {
  adjacentVertices: () => adjacentVertices$12,
  areAdjacent: () => areAdjacent2,
  bfs: () => bfs2,
  clone: () => clone2,
  connect: () => connect$12,
  connectTo: () => connectTo$12,
  connectWithEdges: () => connectWithEdges$12,
  createVertex: () => createVertex$12,
  dfs: () => dfs2,
  disconnect: () => disconnect2,
  distance: () => distance2,
  distanceDefault: () => distanceDefault2,
  dumpGraph: () => dumpGraph$12,
  edges: () => edges2,
  get: () => get2,
  getCycles: () => getCycles2,
  getOrCreate: () => getOrCreate$12,
  getOrFail: () => getOrFail2,
  graph: () => graph$12,
  graphFromVertices: () => graphFromVertices2,
  hasKey: () => hasKey2,
  hasNoOuts: () => hasNoOuts2,
  hasOnlyOuts: () => hasOnlyOuts2,
  hasOut: () => hasOut2,
  isAcyclic: () => isAcyclic2,
  pathDijkstra: () => pathDijkstra2,
  toAdjacencyMatrix: () => toAdjacencyMatrix$12,
  topologicalSort: () => topologicalSort2,
  transitiveReduction: () => transitiveReduction2,
  updateGraphVertex: () => updateGraphVertex$12,
  vertexHasOut: () => vertexHasOut2,
  vertices: () => vertices2
});
var createVertex$12 = (id) => {
  return {
    id,
    out: []
  };
};
function hasKey2(graph$2, key) {
  resultThrow(graphTest2(graph$2));
  return graph$2.vertices.has(key);
}
function get2(graph$2, key) {
  resultThrow(graphTest2(graph$2));
  resultThrow(stringTest(key, `non-empty`, `key`));
  return graph$2.vertices.get(key);
}
function toAdjacencyMatrix$12(graph$2) {
  resultThrow(graphTest2(graph$2));
  const v3 = [...graph$2.vertices.values()];
  const table = new Table2();
  table.labelColumns(...v3.map((vv) => vv.id));
  table.labelRows(...v3.map((vv) => vv.id));
  for (let i4 = 0; i4 < v3.length; i4++) {
    table.setRow(i4, false, v3.length);
    const ii3 = v3[i4];
    for (const [j3, jj] of v3.entries()) if (ii3.out.some((o5) => o5.id === jj.id)) table.set(i4, j3, true);
  }
  return table;
}
var dumpGraph$12 = (graph$2) => {
  const lines = debugGraphToArray$12(graph$2);
  return lines.join(`
`);
};
var debugGraphToArray$12 = (graph$2) => {
  const r5 = [];
  const vertices$1 = `vertices` in graph$2 ? graph$2.vertices.values() : graph$2;
  for (const v3 of vertices$1) {
    const str = debugDumpVertex2(v3);
    r5.push(...str.map((line3) => ` ${line3}`));
  }
  return r5;
};
var distance2 = (graph$2, edge) => {
  if (edge.weight !== void 0) return edge.weight;
  return 1;
};
function* edges2(graph$2) {
  resultThrow(graphTest2(graph$2));
  const vertices$1 = [...graph$2.vertices.values()];
  for (const vertex of vertices$1) for (const edge of vertex.out) yield edge;
}
function* vertices2(graph$2) {
  resultThrow(graphTest2(graph$2));
  const vertices$1 = [...graph$2.vertices.values()];
  for (const vertex of vertices$1) yield vertex;
}
function graphTest2(g4, parameterName = `graph`) {
  if (g4 === void 0) return {
    success: false,
    error: `Param '${parameterName}' is undefined. Expected Graph`
  };
  if (g4 === null) return {
    success: false,
    error: `Param '${parameterName}' is null. Expected Graph`
  };
  if (typeof g4 === `object`) {
    if (!(`vertices` in g4)) return {
      success: false,
      error: `Param '${parameterName}.vertices' does not exist. Is it a Graph type?`
    };
  } else return {
    success: false,
    error: `Param '${parameterName} is type '${typeof g4}'. Expected an object Graph`
  };
  return {
    success: true,
    value: g4
  };
}
function* adjacentVertices$12(graph$2, context) {
  resultThrow(graphTest2(graph$2));
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph$2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of vertex.out) {
    const edgeV = graph$2.vertices.get(edge.id);
    if (edgeV === void 0) throw new Error(`Could not find vertex: ${edge.id}`);
    yield edgeV;
  }
}
var vertexHasOut2 = (vertex, outIdOrVertex) => {
  if (vertex === void 0) return false;
  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;
  return vertex.out.some((edge) => edge.id === outId);
};
var hasNoOuts2 = (graph$2, vertex) => {
  resultThrow(graphTest2(graph$2));
  const context = typeof vertex === `string` ? graph$2.vertices.get(vertex) : vertex;
  if (context === void 0) return false;
  return context.out.length === 0;
};
var hasOnlyOuts2 = (graph$2, vertex, ...outIdOrVertex) => {
  resultThrow(graphTest2(graph$2));
  const context = resolveVertex$12(graph$2, vertex);
  const outs = outIdOrVertex.map((o5) => resolveVertex$12(graph$2, o5));
  if (outs.length !== context.out.length) return false;
  for (const out of outs) if (!hasOut2(graph$2, context, out)) return false;
  return true;
};
var hasOut2 = (graph$2, vertex, outIdOrVertex) => {
  resultThrow(graphTest2(graph$2));
  const context = resolveVertex$12(graph$2, vertex);
  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;
  return context.out.some((edge) => edge.id === outId);
};
var getOrCreate$12 = (graph$2, id) => {
  resultThrow(graphTest2(graph$2));
  const v3 = graph$2.vertices.get(id);
  if (v3 !== void 0) return {
    graph: graph$2,
    vertex: v3
  };
  const vv = createVertex$12(id);
  const gg = updateGraphVertex$12(graph$2, vv);
  return {
    graph: gg,
    vertex: vv
  };
};
var getOrFail2 = (graph$2, id) => {
  resultThrow(graphTest2(graph$2));
  const v3 = graph$2.vertices.get(id);
  if (v3 === void 0) throw new Error(`Vertex '${id}' not found in graph`);
  return v3;
};
var updateGraphVertex$12 = (graph$2, vertex) => {
  resultThrow(graphTest2(graph$2));
  const gr2 = {
    ...graph$2,
    vertices: graph$2.vertices.set(vertex.id, vertex)
  };
  return gr2;
};
var distanceDefault2 = (graph$2, edge) => {
  if (edge.weight !== void 0) return edge.weight;
  return 1;
};
function disconnect2(graph$2, from3, to$1) {
  resultThrow(graphTest2(graph$2));
  const fromV = resolveVertex$12(graph$2, from3);
  const toV = resolveVertex$12(graph$2, to$1);
  return hasOut2(graph$2, fromV, toV) ? updateGraphVertex$12(graph$2, {
    ...fromV,
    out: fromV.out.filter((t6) => t6.id !== toV.id)
  }) : graph$2;
}
function connectTo$12(graph$2, from3, to$1, weight2) {
  resultThrow(graphTest2(graph$2));
  const fromResult = getOrCreate$12(graph$2, from3);
  graph$2 = fromResult.graph;
  const toResult = getOrCreate$12(graph$2, to$1);
  graph$2 = toResult.graph;
  const edge = {
    id: to$1,
    weight: weight2
  };
  if (!hasOut2(graph$2, fromResult.vertex, toResult.vertex)) graph$2 = updateGraphVertex$12(graph$2, {
    ...fromResult.vertex,
    out: [...fromResult.vertex.out, edge]
  });
  return {
    graph: graph$2,
    edge
  };
}
function connect$12(graph$2, options) {
  if (typeof graph$2 !== `object`) throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof graph$2}`);
  if (typeof options !== `object`) throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof options}`);
  const result = connectWithEdges$12(graph$2, options);
  return result.graph;
}
function connectWithEdges$12(graph$2, options) {
  resultThrow(graphTest2(graph$2));
  const { to: to$1, weight: weight2, from: from3 } = options;
  const bidi = options.bidi ?? false;
  const toList = Array.isArray(to$1) ? to$1 : [to$1];
  const edges$13 = [];
  for (const toSingle of toList) {
    const result = connectTo$12(graph$2, from3, toSingle, weight2);
    graph$2 = result.graph;
    edges$13.push(result.edge);
  }
  if (!bidi) return {
    graph: graph$2,
    edges: edges$13
  };
  for (const toSingle of toList) {
    const result = connectTo$12(graph$2, toSingle, from3, weight2);
    graph$2 = result.graph;
    edges$13.push(result.edge);
  }
  return {
    graph: graph$2,
    edges: edges$13
  };
}
var debugDumpVertex2 = (v3) => {
  const r5 = [v3.id];
  const stringForEdge$1 = (edge) => edge.weight === void 0 ? edge.id : `${edge.id} (${edge.weight})`;
  for (const edge of v3.out) r5.push(` -> ${stringForEdge$1(edge)}`);
  if (v3.out.length === 0) r5[0] += ` (terminal)`;
  return r5;
};
function areAdjacent2(graph$2, a3, b3) {
  resultThrow(graphTest2(graph$2));
  if (hasOut2(graph$2, a3, b3.id)) return true;
  if (hasOut2(graph$2, b3, a3.id)) return true;
}
function resolveVertex$12(graph$2, idOrVertex) {
  resultThrow(graphTest2(graph$2));
  if (idOrVertex === void 0) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);
  const v3 = typeof idOrVertex === `string` ? graph$2.vertices.get(idOrVertex) : idOrVertex;
  if (v3 === void 0) throw new Error(`Id not found ${idOrVertex}`);
  return v3;
}
function* bfs2(graph$2, startIdOrVertex, targetIdOrVertex) {
  resultThrow(graphTest2(graph$2));
  const start = resolveVertex$12(graph$2, startIdOrVertex);
  const target = targetIdOrVertex === void 0 ? void 0 : resolveVertex$12(graph$2, targetIdOrVertex);
  const queue = new QueueMutable3();
  const seen = /* @__PURE__ */ new Set();
  queue.enqueue(start);
  while (!queue.isEmpty) {
    const v3 = queue.dequeue();
    yield v3;
    if (target !== void 0 && target === v3) return;
    for (const edge of adjacentVertices$12(graph$2, v3)) if (!seen.has(edge.id)) {
      seen.add(edge.id);
      queue.enqueue(resolveVertex$12(graph$2, edge.id));
    }
  }
}
function* dfs2(graph$2, startIdOrVertex) {
  resultThrow(graphTest2(graph$2));
  const source = resolveVertex$12(graph$2, startIdOrVertex);
  const s3 = new StackMutable2();
  const seen = /* @__PURE__ */ new Set();
  s3.push(source);
  while (!s3.isEmpty) {
    const v3 = s3.pop();
    if (v3 === void 0) continue;
    if (!seen.has(v3.id)) {
      seen.add(v3.id);
      yield v3;
      for (const edge of v3.out) {
        const destination = graph$2.vertices.get(edge.id);
        if (destination) s3.push(destination);
      }
    }
  }
}
var pathDijkstra2 = (graph$2, sourceOrId) => {
  resultThrow(graphTest2(graph$2));
  const source = typeof sourceOrId === `string` ? graph$2.vertices.get(sourceOrId) : sourceOrId;
  if (source === void 0) throw new Error(`source vertex not found`);
  const distances = /* @__PURE__ */ new Map();
  const previous = /* @__PURE__ */ new Map();
  distances.set(source.id, 0);
  const pq = new PriorityMutable2();
  const vertices$1 = [...graph$2.vertices.values()];
  for (const v3 of vertices$1) {
    if (v3.id !== source.id) {
      distances.set(v3.id, Number.MAX_SAFE_INTEGER);
      previous.set(v3.id, null);
    }
    pq.enqueueWithPriority(v3.id, Number.MAX_SAFE_INTEGER);
  }
  while (!pq.isEmpty) {
    const u3 = pq.dequeueMin();
    if (u3 === void 0) throw new Error(`Bug. Queue unexpectedly empty`);
    const vertexU = graph$2.vertices.get(u3);
    for (const neighbour of vertexU.out) {
      const alt = distances.get(u3) + distance2(graph$2, neighbour);
      if (alt < distances.get(neighbour.id)) {
        distances.set(neighbour.id, alt);
        previous.set(neighbour.id, vertexU);
        pq.changePriority(neighbour.id, alt, true);
      }
    }
  }
  const pathTo = (id) => {
    const path3 = [];
    while (true) {
      if (id === source.id) break;
      const v3 = previous.get(id);
      if (v3 === void 0 || v3 === null) throw new Error(`Id not present: ${id}`);
      path3.push({
        id,
        weight: distances.get(id)
      });
      id = v3.id;
    }
    return path3;
  };
  return {
    distances,
    previous,
    pathTo
  };
};
var clone2 = (graph$2) => {
  resultThrow(graphTest2(graph$2));
  const g4 = { vertices: immutable3([...graph$2.vertices.entries()]) };
  return g4;
};
var graph$12 = (...initialConnections) => {
  let g4 = { vertices: immutable3() };
  for (const ic2 of initialConnections) g4 = connect$12(g4, ic2);
  return g4;
};
function isAcyclic2(graph$2) {
  resultThrow(graphTest2(graph$2));
  const cycles = getCycles2(graph$2);
  return cycles.length === 0;
}
function topologicalSort2(graph$2) {
  resultThrow(graphTest2(graph$2));
  const indegrees = new NumberMap2(0);
  for (const edge of edges2(graph$2)) indegrees.add(edge.id, 1);
  const queue = new QueueMutable3();
  let vertexCount = 0;
  for (const vertex of vertices2(graph$2)) {
    if (indegrees.get(vertex.id) === 0) queue.enqueue(vertex);
    vertexCount++;
  }
  const topOrder = [];
  while (!queue.isEmpty) {
    const u3 = queue.dequeue();
    topOrder.push(u3);
    for (const neighbour of u3.out) {
      const result = indegrees.subtract(neighbour.id, 1);
      if (result === 0) queue.enqueue(graph$2.vertices.get(neighbour.id));
    }
  }
  if (topOrder.length !== vertexCount) throw new Error(`Graph contains cycles`);
  return graphFromVertices2(topOrder);
}
function graphFromVertices2(vertices$1) {
  const keyValues = map$2(vertices$1, (f5) => {
    return [f5.id, f5];
  });
  const m4 = immutable3([...keyValues]);
  return { vertices: m4 };
}
function getCycles2(graph$2) {
  resultThrow(graphTest2(graph$2));
  let index = 0;
  const stack = new StackMutable2();
  const vertices$1 = /* @__PURE__ */ new Map();
  const scc = [];
  for (const v3 of graph$2.vertices.values()) vertices$1.set(v3.id, {
    ...v3,
    lowlink: NaN,
    index: NaN,
    onStack: false
  });
  const strongConnect = (vertex) => {
    vertex.index = index;
    vertex.lowlink = index;
    index++;
    stack.push(vertex);
    vertex.onStack = true;
    for (const edge of vertex.out) {
      const edgeV = vertices$1.get(edge.id);
      if (Number.isNaN(edgeV.index)) {
        strongConnect(edgeV);
        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);
      } else if (edgeV.onStack) vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);
    }
    if (vertex.lowlink === vertex.index) {
      const stronglyConnected = [];
      let w3;
      while (vertex !== w3) {
        w3 = stack.pop();
        w3.onStack = false;
        stronglyConnected.push({
          id: w3.id,
          out: w3.out
        });
      }
      if (stronglyConnected.length > 1) scc.push(stronglyConnected);
    }
  };
  for (const v3 of vertices$1.values()) if (Number.isNaN(v3.index)) strongConnect(v3);
  return scc;
}
function transitiveReduction2(graph$2) {
  resultThrow(graphTest2(graph$2));
  for (const u3 of vertices2(graph$2)) for (const v3 of adjacentVertices$12(graph$2, u3)) for (const v1 of dfs2(graph$2, v3)) {
    if (v3.id === v1.id) continue;
    if (hasOut2(graph$2, u3, v1)) {
      const g4 = disconnect2(graph$2, u3, v1);
      return transitiveReduction2(g4);
    }
  }
  return graph$2;
}
var undirected_graph_exports2 = {};
__export(undirected_graph_exports2, {
  adjacentVertices: () => adjacentVertices2,
  connect: () => connect2,
  connectTo: () => connectTo2,
  connectWithEdges: () => connectWithEdges2,
  createVertex: () => createVertex2,
  dumpGraph: () => dumpGraph2,
  edgesForVertex: () => edgesForVertex2,
  getConnection: () => getConnection2,
  getOrCreate: () => getOrCreate2,
  graph: () => graph2,
  hasConnection: () => hasConnection2,
  toAdjacencyMatrix: () => toAdjacencyMatrix2,
  updateGraphVertex: () => updateGraphVertex2
});
var createVertex2 = (id) => {
  return { id };
};
var updateGraphVertex2 = (graph$2, vertex) => {
  const gr2 = {
    ...graph$2,
    vertices: graph$2.vertices.set(vertex.id, vertex)
  };
  return gr2;
};
var getOrCreate2 = (graph$2, id) => {
  const v3 = graph$2.vertices.get(id);
  if (v3 !== void 0) return {
    graph: graph$2,
    vertex: v3
  };
  const vv = createVertex2(id);
  const gg = updateGraphVertex2(graph$2, vv);
  return {
    graph: gg,
    vertex: vv
  };
};
function resolveVertex2(graph$2, idOrVertex) {
  if (idOrVertex === void 0) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);
  if (graph$2 === void 0) throw new Error(`Param 'graph' is undefined. Expected Graph`);
  const v3 = typeof idOrVertex === `string` ? graph$2.vertices.get(idOrVertex) : idOrVertex;
  if (v3 === void 0) throw new Error(`Id not found ${idOrVertex}`);
  return v3;
}
var hasConnection2 = (graph$2, a3, b3) => {
  const edge = getConnection2(graph$2, a3, b3);
  return edge !== void 0;
};
var getConnection2 = (graph$2, a3, b3) => {
  if (a3 === void 0) throw new Error(`Param 'a' is undefined. Expected string or Vertex`);
  if (b3 === void 0) throw new Error(`Param 'b' is undefined. Expected string or Vertex`);
  if (graph$2 === void 0) throw new Error(`Param 'graph' is undefined. Expected Graph`);
  const aa2 = resolveVertex2(graph$2, a3);
  const bb = resolveVertex2(graph$2, b3);
  for (const edge of graph$2.edges) {
    if (edge.a == aa2.id && edge.b === bb.id) return edge;
    if (edge.a == bb.id && edge.b === aa2.id) return edge;
  }
  return;
};
function connectTo2(graph$2, a3, b3, weight2) {
  const aResult = getOrCreate2(graph$2, a3);
  graph$2 = aResult.graph;
  const bResult = getOrCreate2(graph$2, b3);
  graph$2 = bResult.graph;
  let edge = getConnection2(graph$2, a3, b3);
  if (edge !== void 0) return {
    graph: graph$2,
    edge
  };
  edge = {
    a: a3,
    b: b3,
    weight: weight2
  };
  const graphChanged = {
    ...graph$2,
    edges: [...graph$2.edges, edge]
  };
  return {
    graph: graphChanged,
    edge
  };
}
function connect2(graph$2, options) {
  const result = connectWithEdges2(graph$2, options);
  return result.graph;
}
function connectWithEdges2(graph$2, options) {
  const { a: a3, weight: weight2, b: b3 } = options;
  const destinations = Array.isArray(b3) ? b3 : [b3];
  const edges$13 = [];
  for (const destination of destinations) {
    const result = connectTo2(graph$2, a3, destination, weight2);
    graph$2 = result.graph;
    edges$13.push(result.edge);
  }
  return {
    graph: graph$2,
    edges: edges$13
  };
}
var graph2 = (...initialConnections) => {
  let g4 = {
    vertices: immutable3(),
    edges: []
  };
  for (const ic2 of initialConnections) g4 = connect2(g4, ic2);
  return g4;
};
function toAdjacencyMatrix2(graph$2) {
  const v3 = [...graph$2.vertices.values()];
  const table = new Table2();
  table.labelColumns(...v3.map((vv) => vv.id));
  table.labelRows(...v3.map((vv) => vv.id));
  for (let i4 = 0; i4 < v3.length; i4++) {
    table.setRow(i4, false, v3.length);
    const ii3 = v3[i4];
    for (const [j3, jj] of v3.entries()) {
      const connected = hasConnection2(graph$2, ii3, jj);
      if (connected) table.set(i4, j3, true);
    }
  }
  return table;
}
var dumpGraph2 = (graph$2) => {
  const lines = debugGraphToArray2(graph$2);
  return lines.join(`
`);
};
var debugGraphToArray2 = (graph$2) => {
  const r5 = [];
  r5.push(`Vertices: ${[...graph$2.vertices.values()].map((v3) => v3.id).join(`, `)}`);
  r5.push(`Edges:`);
  for (const edge of graph$2.edges) r5.push(stringForEdge2(edge));
  return r5;
};
var stringForEdge2 = (edge) => {
  const weight2 = edge.weight ? ` (${edge.weight})` : ``;
  return `${edge.a} <-> ${edge.b}${weight2}`;
};
function* adjacentVertices2(graph$2, context) {
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph$2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of graph$2.edges) if (edge.a === context) yield resolveVertex2(graph$2, edge.b);
  else if (edge.b === context) yield resolveVertex2(graph$2, edge.a);
}
function* edgesForVertex2(graph$2, context) {
  if (context === void 0) return;
  const vertex = typeof context === `string` ? graph$2.vertices.get(context) : context;
  if (vertex === void 0) throw new Error(`Vertex not found ${JSON.stringify(context)}`);
  for (const edge of graph$2.edges) if (edge.a === context) yield edge;
  else if (edge.b === context) yield edge;
}
var graph_exports2 = {};
__export(graph_exports2, {
  Directed: () => directed_graph_exports2,
  Undirected: () => undirected_graph_exports2
});
var src_exports$2 = {};
__export(src_exports$2, {
  CircularArray: () => CircularArray3,
  ExpiringMap: () => ExpiringMap2,
  Graphs: () => graph_exports2,
  MapOfSimpleMutable: () => MapOfSimpleMutable2,
  Maps: () => map_exports2,
  QueueImmutable: () => QueueImmutable3,
  QueueMutable: () => QueueMutable3,
  Queues: () => queue_exports2,
  SetStringImmutable: () => SetStringImmutable3,
  SetStringMutable: () => SetStringMutable2,
  Sets: () => set_exports2,
  StackImmutable: () => StackImmutable3,
  StackMutable: () => StackMutable2,
  Stacks: () => stack_exports2,
  Table: () => Table2,
  Trees: () => tree_exports2
});
var getName = (t6, defaultValue = ``) => {
  if (typeof t6 === `object` && `name` in t6 && t6.name !== void 0) return t6.name;
  return defaultValue;
};
function* iterateBreadth(t6, pathPrefix) {
  if (typeof pathPrefix === `undefined`) pathPrefix = getName(t6);
  for (const [index, n6] of entries(t6)) yield [n6, pathPrefix];
  for (const [index, n6] of entries(t6)) {
    const name = getName(n6, `?`);
    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;
    yield* iterateBreadth(n6, prefix);
  }
}
function* iterateDepth(t6, pathPrefix) {
  if (typeof pathPrefix === `undefined`) pathPrefix = getName(t6);
  for (const [index, n6] of entries(t6)) {
    yield [n6, pathPrefix];
    const name = getName(n6, `?`);
    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;
    yield* iterateBreadth(n6, prefix);
  }
}
function isSeqNode(n6) {
  return n6.seq !== void 0;
}
function isSelNode(n6) {
  return n6.sel !== void 0;
}
function* entries(n6) {
  if (isSeqNode(n6)) yield* n6.seq.entries();
  else if (isSelNode(n6)) yield* n6.sel.entries();
  else if (typeof n6 === `string`) {
  } else throw new TypeError(`Unexpected shape of node. seq/sel missing`);
}
var delay2 = async (callback, optsOrMillis) => {
  const opts = typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;
  const delayWhen = opts.delay ?? `before`;
  if (delayWhen === `before` || delayWhen === `both`) await sleep(opts);
  const r5 = Promise.resolve(await callback());
  if (delayWhen === `after` || delayWhen === `both`) await sleep(opts);
  return r5;
};
async function* delayAnimationLoop() {
  let resolve$1;
  let p3 = new Promise((r5) => resolve$1 = r5);
  let timer = 0;
  const callback = () => {
    if (resolve$1) resolve$1();
    p3 = new Promise((r5) => resolve$1 = r5);
  };
  try {
    while (true) {
      timer = globalThis.requestAnimationFrame(callback);
      const _3 = await p3;
      yield _3;
    }
  } finally {
    if (resolve$1) resolve$1();
    globalThis.cancelAnimationFrame(timer);
  }
}
async function* delayLoop(timeout$1) {
  const timeoutMs = intervalToMs(timeout$1);
  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);
  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);
  if (timeoutMs === 0) return yield* delayAnimationLoop();
  let resolve$1;
  let p3 = new Promise((r5) => resolve$1 = r5);
  let timer;
  const callback = () => {
    if (resolve$1) resolve$1();
    p3 = new Promise((r5) => resolve$1 = r5);
  };
  try {
    while (true) {
      timer = globalThis.setTimeout(callback, timeoutMs);
      const _3 = await p3;
      yield _3;
    }
  } finally {
    if (resolve$1) resolve$1();
    if (timer !== void 0) globalThis.clearTimeout(timer);
    timer = void 0;
  }
}
var timeout = (callback, interval2) => {
  if (callback === void 0) throw new Error(`callback parameter is undefined`);
  const intervalMs = intervalToMs(interval2);
  resultThrow(integerTest(intervalMs, `aboveZero`, `interval`));
  let timer;
  let startedAt = 0;
  let startCount = 0;
  let startCountTotal = 0;
  let state = `idle`;
  const clear4 = () => {
    startedAt = 0;
    globalThis.clearTimeout(timer);
    state = `idle`;
  };
  const start = async (altInterval = interval2, args) => {
    const p3 = new Promise((resolve$1, reject) => {
      startedAt = performance.now();
      const altTimeoutMs = intervalToMs(altInterval);
      const it2 = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);
      if (resultIsError(it2)) {
        reject(resultToError(it2));
        return;
      }
      switch (state) {
        case `scheduled`: {
          cancel();
          break;
        }
        case `running`:
          break;
      }
      state = `scheduled`;
      timer = globalThis.setTimeout(async () => {
        if (state !== `scheduled`) {
          console.warn(`Timeout skipping execution since state is not 'scheduled'`);
          clear4();
          return;
        }
        const args_ = args ?? [];
        startCount++;
        startCountTotal++;
        state = `running`;
        await callback(performance.now() - startedAt, ...args_);
        state = `idle`;
        clear4();
        resolve$1();
      }, altTimeoutMs);
    });
    return p3;
  };
  const cancel = () => {
    if (state === `idle`) return;
    clear4();
  };
  return {
    start,
    cancel,
    get runState() {
      return state;
    },
    get startCount() {
      return startCount;
    },
    get startCountTotal() {
      return startCountTotal;
    }
  };
};
var debounce2 = (callback, interval2) => {
  const t6 = timeout(callback, interval2);
  return (...args) => {
    t6.start(void 0, args);
  };
};
var DispatchList = class {
  #handlers;
  #counter = 0;
  #id = Math.floor(Math.random() * 100);
  constructor() {
    this.#handlers = [];
  }
  /**
  * Returns _true_ if list is empty
  * @returns
  */
  isEmpty() {
    return this.#handlers.length === 0;
  }
  /**
  * Adds a handler. You get back an id which can be used
  * to remove the handler later.
  *
  * Handlers can be added with 'once' flag set to _true_. This will
  * automatically remove them after the first value is sent to them.
  * @param handler
  * @param options
  * @returns
  */
  add(handler, options = {}) {
    this.#counter++;
    const once = options.once ?? false;
    const wrap$13 = {
      id: `${this.#id} - ${this.#counter}`,
      handler,
      once
    };
    this.#handlers.push(wrap$13);
    return wrap$13.id;
  }
  /**
  * Remove a handler by its id.
  * @param id
  * @returns _True_ if handler was removed, _false_ if not found.
  */
  remove(id) {
    const length3 = this.#handlers.length;
    this.#handlers = this.#handlers.filter((handler) => handler.id !== id);
    return this.#handlers.length !== length3;
  }
  /**
  * Emit a value to all handlers
  * @param value
  */
  notify(value$1) {
    for (const handler of this.#handlers) {
      handler.handler(value$1);
      if (handler.once) this.remove(handler.id);
    }
  }
  /**
  * Remove all handlers
  */
  clear() {
    this.#handlers = [];
  }
};
var everyNth = (nth, callback) => {
  resultThrow(integerTest(nth, `positive`, `nth`));
  let counter = 0;
  return (data) => {
    counter++;
    if (counter === nth) {
      counter = 0;
      if (callback) callback(data);
      return true;
    }
    return false;
  };
};
var run2 = async (expressions, opts = {}, args) => {
  const results = [];
  const compareFunction = opts.rank ?? defaultComparer;
  let expressionsArray = Array.isArray(expressions) ? expressions : [expressions];
  if (opts.shuffle) expressionsArray = shuffle(expressionsArray);
  for (let index = 0; index < expressionsArray.length; index++) {
    const exp = expressionsArray[index];
    let r5;
    if (typeof exp === "function") r5 = await exp(args);
    else r5 = exp;
    if (r5 !== void 0) {
      results.push(r5);
      results.sort(compareFunction);
    }
    if (typeof opts.stop !== "undefined") {
      if (opts.stop(r5, results)) break;
    }
  }
  if (opts.filter) return results.filter(opts.filter);
  return results;
};
var runSingle = async (expressions, opts = {}, args) => {
  const results = await run2(expressions, opts, args);
  if (!results) return;
  if (results.length === 0) return;
  const at2 = opts.at ?? -1;
  return results.at(at2);
};
var eventRace = (target, eventNames, options = {}) => {
  const intervalMs = options.timeoutMs ?? 601e3;
  const signal = options.signal;
  let triggered = false;
  let disposed = false;
  let timeout$1;
  const promise = new Promise((resolve$1, reject) => {
    const onEvent = (event2) => {
      if (`type` in event2) if (eventNames.includes(event2.type)) {
        triggered = true;
        resolve$1(event2);
        dispose();
      } else console.warn(`eventRace: Got event '${event2.type}' that is not in race list`);
      else {
        console.warn(`eventRace: Event data does not have expected 'type' field`);
        console.log(event2);
      }
    };
    for (const name of eventNames) target.addEventListener(name, onEvent);
    const dispose = () => {
      if (disposed) return;
      if (timeout$1 !== void 0) clearTimeout(timeout$1);
      timeout$1 = void 0;
      disposed = true;
      for (const name of eventNames) target.removeEventListener(name, onEvent);
    };
    timeout$1 = setTimeout(() => {
      if (triggered || disposed) return;
      dispose();
      reject(/* @__PURE__ */ new Error(`eventRace: Events not fired within interval. Events: ${JSON.stringify(eventNames)} Interval: ${intervalMs}`));
    }, intervalMs);
    signal?.addEventListener(`abort`, () => {
      if (triggered || disposed) return;
      dispose();
      reject(/* @__PURE__ */ new Error(`Abort signal received ${signal.reason}`));
    });
  });
  return promise;
};
var movingAverageTimed = (options) => {
  const average3 = movingAverageLight();
  const rm = rateMinimum({
    ...options,
    whatToCall: (distance$13) => {
      average3(distance$13);
    },
    fallback() {
      return options.default ?? 0;
    }
  });
  return (v3) => {
    rm(v3);
    return average3();
  };
};
var PoolUser = class extends SimpleEventEmitter {
  key;
  resource;
  _lastUpdate;
  _pool;
  _state;
  _userExpireAfterMs;
  /**
  * Constructor
  * @param key User key
  * @param resource Resource being used
  */
  constructor(key, resource) {
    super();
    this.key = key;
    this.resource = resource;
    this._lastUpdate = performance.now();
    this._pool = resource.pool;
    this._userExpireAfterMs = this._pool.userExpireAfterMs;
    this._state = `idle`;
    this._pool.log.log(`PoolUser ctor key: ${this.key}`);
  }
  /**
  * Returns a human readable debug string
  * @returns
  */
  toString() {
    if (this.isDisposed) return `PoolUser. State: disposed`;
    return `PoolUser. State: ${this._state} Elapsed: ${performance.now() - this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`;
  }
  /**
  * Resets countdown for instance expiry.
  * Throws an error if instance is disposed.
  */
  keepAlive() {
    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);
    this._lastUpdate = performance.now();
  }
  /**
  * @internal
  * @param reason
  * @returns
  */
  _dispose(reason, data) {
    if (this._state === `disposed`) return;
    const resource = this.resource;
    this._state = `disposed`;
    resource._release(this);
    this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${reason}`);
    this.fireEvent(`disposed`, {
      data,
      reason
    });
    super.clearEventListeners();
  }
  /**
  * Release this instance
  * @param reason
  */
  release(reason) {
    if (this.isDisposed) throw new Error(`User disposed`);
    const resource = this.resource;
    const data = resource.data;
    this._pool.log.log(`PoolUser release key: ${this.key} reason: ${reason}`);
    this.fireEvent(`released`, {
      data,
      reason
    });
    this._dispose(`release-${reason}`, data);
  }
  get data() {
    if (this.isDisposed) throw new Error(`User disposed`);
    return this.resource.data;
  }
  /**
  * Returns true if this instance has expired.
  * Expiry counts if elapsed time is greater than `userExpireAfterMs`
  */
  get isExpired() {
    if (this._userExpireAfterMs > 0) return performance.now() > this._lastUpdate + this._userExpireAfterMs;
    return false;
  }
  /**
  * Returns elapsed time since last 'update'
  */
  get elapsed() {
    return performance.now() - this._lastUpdate;
  }
  /**
  * Returns true if instance is disposed
  */
  get isDisposed() {
    return this._state === `disposed`;
  }
  /**
  * Returns true if instance is neither disposed nor expired
  */
  get isValid() {
    if (this.isDisposed || this.isExpired) return false;
    if (this.resource.isDisposed) return false;
    return true;
  }
};
var Resource = class {
  pool;
  #state;
  #data;
  #users;
  #capacityPerResource;
  #resourcesWithoutUserExpireAfterMs;
  #lastUsersChange;
  /**
  * Constructor.
  * @param pool Pool
  * @param data Data
  */
  constructor(pool, data) {
    this.pool = pool;
    if (data === void 0) throw new Error(`Parameter 'data' is undefined`);
    if (pool === void 0) throw new Error(`Parameter 'pool' is undefined`);
    this.#data = data;
    this.#lastUsersChange = 0;
    this.#resourcesWithoutUserExpireAfterMs = pool.resourcesWithoutUserExpireAfterMs;
    this.#capacityPerResource = pool.capacityPerResource;
    this.#users = [];
    this.#state = `idle`;
  }
  /**
  * Gets data associated with resource.
  * Throws an error if disposed
  */
  get data() {
    if (this.#state === `disposed`) throw new Error(`Resource disposed`);
    return this.#data;
  }
  /**
  * Changes the data associated with this resource.
  * Throws an error if disposed or `data` is undefined.
  * @param data
  */
  updateData(data) {
    if (this.#state === `disposed`) throw new Error(`Resource disposed`);
    if (data === void 0) throw new Error(`Parameter 'data' is undefined`);
    this.#data = data;
  }
  /**
  * Returns a human-readable debug string for resource
  * @returns
  */
  toString() {
    return `Resource (expired: ${this.isExpiredFromUsers} users: ${this.#users.length}, state: ${this.#state}) data: ${JSON.stringify(this.data)}`;
  }
  /**
  * Assigns a user to this resource.
  * @internal
  * @param user
  */
  _assign(user) {
    const existing = this.#users.find((u3) => u3 === user || u3.key === user.key);
    if (existing) throw new Error(`User instance already assigned to resource`);
    this.#users.push(user);
    this.#lastUsersChange = performance.now();
  }
  /**
  * Releases a user from this resource
  * @internal
  * @param user
  */
  _release(user) {
    this.#users = this.#users.filter((u3) => u3 !== user);
    this.pool._release(user);
    this.#lastUsersChange = performance.now();
  }
  /**
  * Returns true if resource can have additional users allocated
  */
  get hasUserCapacity() {
    return this.usersCount < this.#capacityPerResource;
  }
  /**
  * Returns number of uses of the resource
  */
  get usersCount() {
    return this.#users.length;
  }
  /**
  * Returns true if automatic expiry is enabled, and that interval
  * has elapsed since the users list has changed for this resource
  */
  get isExpiredFromUsers() {
    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;
    if (this.#users.length > 0) return false;
    return performance.now() > this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange;
  }
  /**
  * Returns true if instance is disposed
  */
  get isDisposed() {
    return this.#state === `disposed`;
  }
  /**
  * Disposes the resource.
  * If it is already disposed, it does nothing.
  * @param reason
  * @returns
  */
  dispose(reason) {
    if (this.#state === `disposed`) return;
    const data = this.#data;
    this.#state = `disposed`;
    this.pool.log.log(`Resource disposed (${reason})`);
    for (const u3 of this.#users) u3._dispose(`resource-${reason}`, data);
    this.#users = [];
    this.#lastUsersChange = performance.now();
    this.pool._releaseResource(this, reason);
    if (this.pool.freeResource) this.pool.freeResource(data);
  }
};
var Pool = class {
  _resources;
  _users;
  capacity;
  userExpireAfterMs;
  resourcesWithoutUserExpireAfterMs;
  capacityPerResource;
  fullPolicy;
  generateResource;
  freeResource;
  log = logSet(`Pool`);
  /**
  * Constructor.
  *
  * By default, no capacity limit, one user per resource
  * @param options Pool options
  */
  constructor(options = {}) {
    this.capacity = options.capacity ?? -1;
    this.fullPolicy = options.fullPolicy ?? `error`;
    this.capacityPerResource = options.capacityPerResource ?? 1;
    this.userExpireAfterMs = options.userExpireAfterMs ?? -1;
    this.resourcesWithoutUserExpireAfterMs = options.resourcesWithoutUserExpireAfterMs ?? -1;
    this.generateResource = options.generate;
    this.freeResource = options.free;
    this._users = /* @__PURE__ */ new Map();
    this._resources = [];
    this.log = logSet(`Pool`, options.debug ?? false);
    const timer = Math.max(this.userExpireAfterMs, this.resourcesWithoutUserExpireAfterMs);
    if (timer > 0) setInterval(() => {
      this.maintain();
    }, timer * 1.1);
  }
  /**
  * Returns a debug string of Pool state
  * @returns
  */
  dumpToString() {
    let r5 = `Pool
    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}
    resources count: ${this._resources.length}`;
    const resource = this._resources.map((r$1) => r$1.toString()).join(`\r
	`);
    r5 += `\r
Resources:\r
	` + resource;
    r5 += `\r
Users: \r
`;
    for (const [k3, v3] of this._users.entries()) r5 += `	k: ${k3} v: ${v3.toString()}\r
`;
    return r5;
  }
  /**
  * Sorts users by longest elapsed time since update
  * @returns
  */
  getUsersByLongestElapsed() {
    return [...this._users.values()].sort((a3, b3) => {
      const aa2 = a3.elapsed;
      const bb = b3.elapsed;
      if (aa2 === bb) return 0;
      if (aa2 < bb) return 1;
      return -1;
    });
  }
  /**
  * Returns resources sorted with least used first
  * @returns
  */
  getResourcesSortedByUse() {
    return [...this._resources].sort((a3, b3) => {
      if (a3.usersCount === b3.usersCount) return 0;
      if (a3.usersCount < b3.usersCount) return -1;
      return 1;
    });
  }
  /**
  * Adds a shared resource to the pool
  * @throws Error if the capacity limit is reached or resource is null
  * @param resource
  * @returns
  */
  addResource(resource) {
    if (resource === void 0) throw new Error(`Cannot add undefined resource`);
    if (resource === null) throw new TypeError(`Cannot add null resource`);
    if (this.capacity > 0 && this._resources.length === this.capacity) throw new Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);
    this.log.log(`Adding resource: ${JSON.stringify(resource)}`);
    const pi5 = new Resource(this, resource);
    this._resources.push(pi5);
    return pi5;
  }
  /**
  * Performs maintenance, removing disposed/expired resources & users.
  * This is called automatically when using a resource.
  */
  maintain() {
    let changed = false;
    const nuke = [];
    for (const p3 of this._resources) if (p3.isDisposed) {
      this.log.log(`Maintain, disposed resource: ${JSON.stringify(p3.data)}`);
      nuke.push(p3);
    } else if (p3.isExpiredFromUsers) {
      this.log.log(`Maintain, expired resource: ${JSON.stringify(p3.data)}`);
      nuke.push(p3);
    }
    if (nuke.length > 0) {
      for (const resource of nuke) resource.dispose(`diposed/expired`);
      changed = true;
    }
    const userKeysToRemove = [];
    for (const [key, user] of this._users.entries()) if (!user.isValid) {
      this.log.log(`Maintain. Invalid user: ${user.key} (Disposed: ${user.isDisposed} Expired: ${user.isExpired} Resource disposed: ${user.resource.isDisposed})`);
      userKeysToRemove.push(key);
      user._dispose(`invalid`, user.data);
    }
    for (const userKey of userKeysToRemove) {
      this._users.delete(userKey);
      changed = true;
    }
    if (changed) this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`);
  }
  /**
  * Iterate over resources in the pool.
  * To iterate over the data associated with each resource, use
  * `values`.
  */
  *resources() {
    const resource = [...this._resources];
    for (const r5 of resource) yield r5;
  }
  /**
  * Iterate over resource values in the pool.
  * to iterate over the resources, use `resources`.
  *
  * Note that values may be returned even though there is no
  * active user.
  */
  *values() {
    const resource = [...this._resources];
    for (const r5 of resource) yield r5.data;
  }
  /**
  * Unassociate a key with a pool item
  * @param userKey
  */
  release(userKey, reason) {
    const pi5 = this._users.get(userKey);
    if (!pi5) return;
    pi5.release(reason ?? `Pool.release`);
  }
  /**
  * @internal
  * @param user
  */
  _release(user) {
    this._users.delete(user.key);
  }
  /**
  * @internal
  * @param resource
  * @param _
  */
  _releaseResource(resource, _3) {
    this._resources = this._resources.filter((v3) => v3 !== resource);
  }
  /**
  * Returns true if `v` has an associted resource in the pool
  * @param resource
  * @returns
  */
  hasResource(resource) {
    const found = this._resources.find((v3) => v3.data === resource);
    return found !== void 0;
  }
  /**
  * Returns true if a given `userKey` is in use.
  * @param userKey
  * @returns
  */
  hasUser(userKey) {
    return this._users.has(userKey);
  }
  /**
  * @internal
  * @param key
  * @param resource
  * @returns
  */
  _assign(key, resource) {
    const u3 = new PoolUser(key, resource);
    this._users.set(key, u3);
    resource._assign(u3);
    return u3;
  }
  /**
  * Allocates a resource for `userKey`
  * @internal
  * @param userKey
  * @returns
  */
  #allocateResource(userKey) {
    const sorted = this.getResourcesSortedByUse();
    if (sorted.length > 0 && sorted[0].hasUserCapacity) {
      const u3 = this._assign(userKey, sorted[0]);
      return u3;
    }
    if (this.generateResource && (this.capacity < 0 || this._resources.length < this.capacity)) {
      this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);
      const resourceGenerated = this.addResource(this.generateResource());
      const u3 = this._assign(userKey, resourceGenerated);
      return u3;
    }
  }
  /**
  * Return the number of users
  */
  get usersLength() {
    return [...this._users.values()].length;
  }
  /**
  * 'Uses' a resource, returning the value
  * @param userKey
  * @returns
  */
  useValue(userKey) {
    const resource = this.use(userKey);
    return resource.resource.data;
  }
  /**
  * Gets a pool item based on a 'user' key.
  *
  * The same key should return the same pool item,
  * for as long as it still exists.
  *
  * If a 'user' already has a resource, it will 'keep alive' their use.
  * If a 'user' does not already have resource
  *  - if there is capacity, a resource is allocated to user
  *  - if pool is full
  *    - fullPolicy = 'error': an error is thrown
  *    - fullPolicy = 'evictOldestUser': evicts an older user
  *    - Throw error
  * @param userKey
  * @throws Error If all resources are used and fullPolicy = 'error'
  * @returns
  */
  use(userKey) {
    const pi5 = this._users.get(userKey);
    if (pi5) {
      pi5.keepAlive();
      return pi5;
    }
    this.maintain();
    const match = this.#allocateResource(userKey);
    if (match) return match;
    if (this.fullPolicy === `error`) throw new Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);
    if (this.fullPolicy === `evictOldestUser`) {
      const users = this.getUsersByLongestElapsed();
      if (users.length > 0) {
        this.release(users[0].key, `evictedOldestUser`);
        const match2 = this.#allocateResource(userKey);
        if (match2) return match2;
      }
    }
    throw new Error(`Pool is fully used (${this.fullPolicy})`);
  }
};
var create2 = (options = {}) => new Pool(options);
function promiseWithResolvers() {
  let resolve$1;
  let reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve$1 = _resolve;
    reject = _reject;
  });
  return {
    promise,
    resolve: resolve$1,
    reject
  };
}
var rateMinimum = (options) => {
  let disposed = false;
  const t6 = timeout(() => {
    if (disposed) return;
    t6.start();
    options.whatToCall(options.fallback());
  }, options.interval);
  if (options.abort) options.abort.addEventListener(`abort`, (_3) => {
    disposed = true;
    t6.cancel();
  });
  t6.start();
  return (args) => {
    if (disposed) throw new Error(`AbortSignal has been fired`);
    t6.start();
    options.whatToCall(args);
  };
};
async function* repeat2(produce, opts) {
  const signal = opts.signal ?? void 0;
  const delayWhen = opts.delayWhen ?? `before`;
  const count3 = opts.count ?? void 0;
  const allowUndefined = opts.allowUndefined ?? false;
  const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : void 0;
  const whileFunction = opts.while;
  let cancelled = false;
  let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));
  let started = performance.now();
  const doDelay = async () => {
    const elapsed2 = performance.now() - started;
    if (typeof minIntervalMs !== `undefined`) sleepMs = Math.max(0, minIntervalMs - elapsed2);
    if (sleepMs) await sleep({
      millis: sleepMs,
      signal
    });
    started = performance.now();
    if (signal?.aborted) throw new Error(`Signal aborted ${signal.reason}`);
  };
  if (Array.isArray(produce)) produce = produce.values();
  if (opts.onStart) opts.onStart();
  let errored = true;
  let loopedTimes = 0;
  try {
    while (!cancelled) {
      loopedTimes++;
      if (delayWhen === `before` || delayWhen === `both`) await doDelay();
      const result = await resolve(produce);
      if (typeof result === `undefined` && !allowUndefined) cancelled = true;
      else {
        yield result;
        if (delayWhen === `after` || delayWhen === `both`) await doDelay();
        if (count3 !== void 0 && loopedTimes >= count3) cancelled = true;
      }
      if (whileFunction) {
        if (!whileFunction(loopedTimes)) cancelled = true;
      }
    }
    errored = false;
  } finally {
    cancelled = true;
    if (opts.onComplete) opts.onComplete(errored);
  }
}
function* repeatSync(produce, opts) {
  const signal = opts.signal ?? void 0;
  const count3 = opts.count ?? void 0;
  const allowUndefined = opts.allowUndefined ?? false;
  let cancelled = false;
  if (Array.isArray(produce)) produce = produce.values();
  if (opts.onStart) opts.onStart();
  let errored = true;
  let loopedTimes = 0;
  try {
    while (!cancelled) {
      loopedTimes++;
      const result = resolveSync(produce);
      if (typeof result === `undefined` && !allowUndefined) cancelled = true;
      else {
        yield result;
        if (count3 !== void 0 && loopedTimes >= count3) cancelled = true;
        if (signal?.aborted) cancelled = true;
      }
    }
    errored = false;
  } finally {
    cancelled = true;
    if (opts.onComplete) opts.onComplete(errored);
  }
}
var RequestResponseMatch = class extends SimpleEventEmitter {
  timeoutMs;
  whenUnmatchedResponse;
  keyRequest;
  keyResponse;
  #outgoing = /* @__PURE__ */ new Map();
  #maintainLoop;
  constructor(options = {}) {
    super();
    if (typeof window === `undefined`) globalThis.window = {
      setTimeout,
      clearTimeout
    };
    this.timeoutMs = options.timeoutMs ?? 1e3;
    this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;
    this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);
    if (options.key) {
      if (options.keyRequest) throw new Error(`Cannot set 'keyRequest' when 'key' is set `);
      if (options.keyResponse) throw new Error(`Cannot set 'keyResponse' when 'key' is set `);
      this.keyRequest = options.key;
      this.keyResponse = options.key;
    } else {
      if (!options.keyRequest || !options.keyResponse) throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);
      this.keyRequest = options.keyRequest;
      this.keyResponse = options.keyResponse;
    }
  }
  #maintain() {
    const values3 = [...this.#outgoing.values()];
    const now = Date.now();
    for (const v3 of values3) if (v3.expiresAt <= now) {
      if (v3.promiseReject) v3.promiseReject(`Request timeout`);
      const callback = v3.callback;
      if (callback) setTimeout(() => {
        callback(true, `Request timeout`);
      }, 1);
      this.fireEvent(`completed`, {
        request: v3.req,
        response: `Request timeout`,
        success: false
      });
      this.#outgoing.delete(v3.id);
    }
    this.debugDump();
    return this.#outgoing.size > 0;
  }
  debugDump() {
    const values3 = [...this.#outgoing.values()];
    const now = Date.now();
    for (const v3 of values3) {
      const expire = now - v3.expiresAt;
      console.log(`${v3.id} Expires in: ${Math.floor(expire / 1e3).toString()}s`);
    }
  }
  /**
  * Makes a request.
  * If `callback` is set, it's equivalent to calling `requestCallback`.
  * If `callback` is not set, a promise is returned
  * @param request
  * @param callback
  * @returns
  */
  request(request, callback) {
    if (callback !== void 0) {
      this.#requestCallback(request, callback);
      return;
    }
    return this.#requestAwait(request);
  }
  /**
  * Make a request and don't wait for the outcome.
  * @param request
  */
  requestAndForget(request) {
    const id = this.keyRequest(request);
    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${id}'`);
    const r5 = {
      expiresAt: Date.now() + this.timeoutMs,
      id,
      req: request
    };
    this.#outgoing.set(id, r5);
    this.#maintainLoop.start();
  }
  /**
  * Make a request, returning a Promise for the outcome.
  * Errors will throw an exception.
  * @param request
  * @returns
  */
  #requestAwait(request) {
    const id = this.keyRequest(request);
    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${id}'`);
    const p3 = new Promise((resolve$1, reject) => {
      const r5 = {
        expiresAt: Date.now() + this.timeoutMs,
        id,
        req: request,
        promiseResolve: resolve$1,
        promiseReject: reject
      };
      this.#outgoing.set(id, r5);
      this.#maintainLoop.start();
    });
    return p3;
  }
  /**
  * Make a request, and get notified of outcome with a callback
  * @param request
  * @param callback
  */
  #requestCallback(request, callback) {
    const id = this.keyRequest(request);
    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${id}'`);
    const r5 = {
      expiresAt: Date.now() + this.timeoutMs,
      id,
      req: request,
      callback
    };
    this.#outgoing.set(id, r5);
    this.#maintainLoop.start();
  }
  /**
  * Response has been received
  * @param response Response
  * @returns _True_ if response matched a request
  */
  response(response, keepAlive) {
    const id = this.keyResponse(response);
    const request = this.#outgoing.get(id);
    if (!request) {
      if (this.whenUnmatchedResponse === `throw`) throw new Error(`Unmatched response with id: '${id}'`, { cause: response });
      return false;
    }
    if (keepAlive) request.expiresAt = Date.now() + this.timeoutMs;
    else this.#outgoing.delete(id);
    if (request.promiseResolve) request.promiseResolve(response);
    if (request.callback) request.callback(false, response);
    this.fireEvent(`match`, {
      request: request.req,
      response
    });
    if (!keepAlive) this.fireEvent(`completed`, {
      request: request.req,
      response,
      success: true
    });
    return true;
  }
};
function* backoffGenerator(options = {}) {
  const startAt = options.startAt ?? 1;
  let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;
  const limitValue = options.limitValue;
  const power = options.power ?? 1.1;
  let value$1 = startAt;
  resultThrow(integerTest(limitAttempts, `aboveZero`, `limitAttempts`), numberTest(startAt, ``, `startAt`), numberTest(limitAttempts, ``, `limitAttempts`), () => limitValue !== void 0 ? numberTest(limitValue, ``, `limitValue`) : void 0, numberTest(power, ``, `power`));
  while (limitAttempts > 0) {
    if (limitValue && value$1 >= limitValue) return;
    limitAttempts--;
    yield value$1;
    value$1 += Math.pow(value$1, power);
  }
}
var retryFunction = (callback, options = {}) => {
  const task = { async probe() {
    try {
      const v3 = await callback();
      if (v3 === void 0) return {
        value: options.taskValueFallback,
        error: `Fallback`,
        success: false
      };
      return {
        value: v3,
        success: true
      };
    } catch (error) {
      return {
        success: false,
        error
      };
    }
  } };
  return retryTask(task, options);
};
var retryTask = async (task, opts = {}) => {
  const signal = opts.abort;
  const log2 = resolveLogOption(opts.log);
  const predelayMs = opts.predelayMs ?? 0;
  const startedAt = elapsedSince();
  let attempts = 0;
  const initialValue = opts.startAt ?? 1e3;
  const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;
  const backoffGen = backoffGenerator({
    ...opts,
    startAt: initialValue,
    limitAttempts
  });
  if (initialValue <= 0) throw new Error(`Param 'initialValue' must be above zero`);
  if (predelayMs > 0) try {
    await sleep({
      millis: predelayMs,
      signal
    });
  } catch (error) {
    return {
      success: false,
      attempts,
      value: opts.taskValueFallback,
      elapsed: startedAt(),
      message: getErrorMessage2(error)
    };
  }
  for (const t6 of backoffGen) {
    attempts++;
    const result = await task.probe(attempts);
    if (result.success) return {
      success: result.success,
      value: result.value,
      attempts,
      elapsed: startedAt()
    };
    log2({ msg: `retry attempts: ${attempts.toString()} t: ${elapsedToHumanString(t6)}` });
    if (attempts >= limitAttempts) break;
    try {
      await sleep({
        millis: t6,
        signal
      });
    } catch (error) {
      return {
        success: false,
        attempts,
        value: opts.taskValueFallback,
        message: getErrorMessage2(error),
        elapsed: startedAt()
      };
    }
  }
  return {
    message: `Giving up after ${attempts.toString()} attempts.`,
    success: false,
    attempts,
    value: opts.taskValueFallback,
    elapsed: startedAt()
  };
};
var runOnce = (onRun) => {
  let run$1 = false;
  let success = false;
  return () => {
    if (run$1) return success;
    run$1 = true;
    success = onRun();
    return success;
  };
};
var SyncWait = class {
  #resolve;
  #reject;
  #promise;
  signal() {
    if (this.#resolve) {
      this.#resolve();
      this.#resolve = void 0;
    }
    this.#promise = Promise.resolve();
  }
  /**
  * Throw away any previous signalled state.
  * This will cause any currently waiters to throw
  */
  flush() {
    if (this.#reject) {
      this.#reject(`Flushed`);
      this.#reject = void 0;
    }
    this.#resolve = void 0;
    this.#promise = void 0;
  }
  #initPromise() {
    const p3 = new Promise((resolve$1, reject) => {
      this.#resolve = resolve$1;
      this.#reject = reject;
    });
    this.#promise = p3;
    return p3;
  }
  /**
  * Call with `await` to wait until .signal() happens.
  * If a wait period is specified, an exception is thrown if signal does not happen within this time.
  * @param maximumWaitMs
  */
  async forSignal(maximumWaitMs) {
    let p3 = this.#promise;
    p3 ??= this.#initPromise();
    if (maximumWaitMs) {
      const reject = this.#reject;
      setTimeout(() => {
        if (reject) reject(`Timeout elapsed ${maximumWaitMs.toString()}`);
      }, maximumWaitMs);
    }
    await p3;
    this.#promise = void 0;
    this.#resolve = void 0;
    this.#reject = void 0;
  }
  /**
  * An alternative to {@link forSignal}, returning _true_
  * if signalled, or _false_ if wait period was exceeded
  *
  * ```js
  * const s = await sw.didSignal(5000);
  * ```
  * @param maximumWaitMs
  * @returns
  */
  async didSignal(maximumWaitMs) {
    try {
      await this.forSignal(maximumWaitMs);
      return true;
    } catch {
      return false;
    }
  }
};
var TaskQueueMutable = class TaskQueueMutable2 extends SimpleEventEmitter {
  static shared = new TaskQueueMutable2();
  _loop;
  _queue;
  constructor() {
    super();
    this._queue = mutable$12();
    this._loop = continuously(() => {
      return this.processQueue();
    }, 100);
  }
  /**
  * Adds a task. This triggers processing loop if not already started.
  *
  * ```js
  * queue.add(async () => {
  *  await sleep(1000);
  * });
  * ```
  * @param task Task to run
  */
  enqueue(task) {
    const length3 = this._queue.enqueue(task);
    if (this._loop.runState === `idle`) {
      this.fireEvent(`started`, {});
      this._loop.start();
    }
    return length3;
  }
  dequeue() {
    return this._queue.dequeue();
  }
  async processQueue() {
    const task = this._queue.dequeue();
    if (task === void 0) {
      this.fireEvent(`empty`, {});
      return false;
    }
    try {
      await task();
    } catch (error) {
      console.error(error);
    }
  }
  /**
  * Clears all tasks, and stops any scheduled processing.
  * Currently running tasks will continue.
  * @returns
  */
  clear() {
    if (this._queue.length === 0) return;
    this._queue.clear();
    this._loop.cancel();
    this.fireEvent(`empty`, {});
  }
  /**
  * Returns true if queue is empty
  */
  get isEmpty() {
    return this._queue.isEmpty;
  }
  /**
  * Number of items in queue
  */
  get length() {
    return this._queue.length;
  }
};
var throttle = (callback, intervalMinMs) => {
  let trigger = 0;
  return async (...args) => {
    const elapsed2 = performance.now() - trigger;
    if (elapsed2 >= intervalMinMs) {
      const r5 = callback(elapsed2, ...args);
      if (typeof r5 === `object`) await r5;
      trigger = performance.now();
    }
  };
};
function hasElapsed(elapsed2) {
  const t6 = relative(intervalToMs(elapsed2, 0), {
    timer: elapsedMillisecondsAbsolute(),
    clampValue: true
  });
  return () => t6.isDone;
}
function ofTotal(duration2, opts = {}) {
  const totalMs = intervalToMs(duration2);
  if (!totalMs) throw new Error(`Param 'duration' not valid`);
  const timerOpts = {
    ...opts,
    timer: elapsedMillisecondsAbsolute()
  };
  let t6;
  return () => {
    t6 ??= relative(totalMs, timerOpts);
    return t6.elapsed;
  };
}
function ofTotalTicks(totalTicks, opts = {}) {
  const timerOpts = {
    ...opts,
    timer: elapsedTicksAbsolute()
  };
  let t6;
  return () => {
    t6 ??= relative(totalTicks, timerOpts);
    return t6.elapsed;
  };
}
var timerAlwaysDone = () => ({
  elapsed: 1,
  isDone: true,
  reset() {
  },
  mod(amt) {
  }
});
var timerNeverDone = () => ({
  elapsed: 0,
  isDone: false,
  reset() {
  },
  mod() {
  }
});
var relative = (total2, options = {}) => {
  if (!Number.isFinite(total2)) return timerAlwaysDone();
  else if (Number.isNaN(total2)) return timerNeverDone();
  const clampValue = options.clampValue ?? false;
  const wrapValue = options.wrapValue ?? false;
  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);
  let modulationAmount = 1;
  const timer = options.timer ?? elapsedMillisecondsAbsolute();
  let lastValue = 0;
  const computeElapsed = (value$1) => {
    lastValue = value$1;
    let v3 = value$1 / (total2 * modulationAmount);
    if (clampValue) v3 = clamp(v3);
    else if (wrapValue && v3 >= 1) v3 = v3 % 1;
    return v3;
  };
  return {
    mod(amt) {
      modulationAmount = amt;
    },
    get isDone() {
      return computeElapsed(lastValue) >= 1;
    },
    get elapsed() {
      return computeElapsed(timer.elapsed);
    },
    reset: () => {
      timer.reset();
    }
  };
};
var frequencyTimer = (frequency2, options = {}) => {
  const timer = options.timer ?? elapsedMillisecondsAbsolute();
  const cyclesPerSecond = frequency2 / 1e3;
  let modulationAmount = 1;
  const computeElapsed = () => {
    const v3 = timer.elapsed * (cyclesPerSecond * modulationAmount);
    const f5 = v3 - Math.floor(v3);
    if (f5 < 0) throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v3} f: ${f5}`);
    if (f5 > 1) throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v3} f: ${f5}`);
    return f5;
  };
  return {
    mod: (amt) => {
      modulationAmount = amt;
    },
    reset: () => {
      timer.reset();
    },
    get isDone() {
      return computeElapsed() >= 1;
    },
    get elapsed() {
      return computeElapsed();
    }
  };
};
var elapsedMillisecondsAbsolute = () => {
  let start = performance.now();
  return {
    reset: () => {
      start = performance.now();
    },
    get elapsed() {
      return performance.now() - start;
    }
  };
};
var elapsedTicksAbsolute = () => {
  let start = 0;
  return {
    reset: () => {
      start = 0;
    },
    get peek() {
      return start;
    },
    get elapsed() {
      return ++start;
    }
  };
};
var timerWithFunction = (fn2, timer) => {
  if (typeof fn2 !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${typeof fn2}`);
  let startCount = 1;
  return {
    get elapsed() {
      return timer.elapsed;
    },
    get isDone() {
      return timer.isDone;
    },
    get runState() {
      if (timer.isDone) return `idle`;
      return `scheduled`;
    },
    get startCount() {
      return startCount;
    },
    get startCountTotal() {
      return startCount;
    },
    compute: () => {
      const elapsed2 = timer.elapsed;
      return fn2(elapsed2);
    },
    reset: () => {
      timer.reset();
      startCount++;
    }
  };
};
var updateOutdated = (fn2, interval2, updateFail = `slow`) => {
  let lastRun = 0;
  let lastValue;
  let intervalMsCurrent = intervalToMs(interval2, 1e3);
  return () => new Promise(async (resolve$1, reject) => {
    const elapsed2 = performance.now() - lastRun;
    if (lastValue === void 0 || elapsed2 > intervalMsCurrent) try {
      lastRun = performance.now();
      lastValue = await fn2(elapsed2);
      intervalMsCurrent = intervalToMs(interval2, 1e3);
    } catch (error) {
      if (updateFail === `fast`) {
        lastValue = void 0;
        lastRun = 0;
      } else if (updateFail === `backoff`) intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);
      reject(error);
      return;
    }
    resolve$1(lastValue);
  });
};
var WaitForValue = class {
  #promise;
  #resolve;
  #written = false;
  constructor() {
    const { promise, resolve: resolve$1 } = promiseWithResolvers();
    this.#promise = promise;
    this.#resolve = resolve$1;
  }
  /**
  * Gets the promise
  * ```js
  * const wv = new WaitForValue();
  *
  * await wv.get();
  * ```
  * @returns
  */
  get() {
    return this.#promise;
  }
  /**
  * Adds a value, triggering promise resolution.
  *
  * Throws an exception if queue has already been used. Use {@link isUsed} to check.
  * @param value
  */
  add(value$1) {
    if (this.#written) throw new Error(`QueueSingleUse has already been used`);
    this.#written = true;
    this.#resolve(value$1);
  }
  /**
  * Returns _true_ if a value has been added
  * and therefore no more values can be written
  */
  get isUsed() {
    return this.#written;
  }
};
var singleItem = () => new WaitForValue();
var waitFor = (timeoutMs, onAborted, onComplete) => {
  let t6;
  let success = false;
  const done = (error) => {
    if (t6 !== void 0) {
      window.clearTimeout(t6);
      t6 = void 0;
    }
    if (error) onAborted(error);
    else success = true;
    if (onComplete !== void 0) onComplete(success);
  };
  t6 = globalThis.setTimeout(() => {
    t6 = void 0;
    try {
      onAborted(`Timeout after ${timeoutMs}ms`);
    } finally {
      if (onComplete !== void 0) onComplete(success);
    }
  }, timeoutMs);
  return done;
};
var cloneState = (toClone) => {
  return Object.freeze({
    value: toClone.value,
    visited: [...toClone.visited],
    machine: toClone.machine
  });
};
var init = (stateMachine, initialState) => {
  const [machine, machineValidationError] = validateMachine(stateMachine);
  if (!machine) throw new Error(machineValidationError);
  const state = initialState ?? Object.keys(machine.states)[0];
  if (typeof machine.states[state] === `undefined`) throw new TypeError(`Initial state ('${state}') not found`);
  const transitions = validateAndNormaliseTransitions(machine.states);
  if (transitions === void 0) throw new Error(`Could not normalise transitions`);
  return Object.freeze({
    value: state,
    visited: [],
    machine: Object.freeze(Object.fromEntries(transitions))
  });
};
var reset = (sm) => {
  return init(sm.machine);
};
var validateMachine = (smOrTransitions) => {
  if (typeof smOrTransitions === `undefined`) return [void 0, `Parameter undefined`];
  if (smOrTransitions === null) return [void 0, `Parameter null`];
  if (`states` in smOrTransitions) return [smOrTransitions, ``];
  if (typeof smOrTransitions === `object`) return [{ states: smOrTransitions }, ``];
  return [void 0, `Unexpected type: ${typeof smOrTransitions}. Expected object`];
};
var isDone = (sm) => {
  return possible(sm).length === 0;
};
var possibleTargets = (sm) => {
  validateMachineState(sm);
  const fromS = sm.machine[sm.value];
  if (fromS.length === 1 && fromS[0].state === null) return [];
  return fromS;
};
var possible = (sm) => {
  const targets = possibleTargets(sm);
  return targets.map((v3) => v3.state);
};
var normaliseTargets = (targets) => {
  const normaliseSingleTarget = (target) => {
    if (target === null) return { state: null };
    if (typeof target === `string`) return { state: target };
    else if (typeof target === `object` && `state` in target) {
      const targetState = target.state;
      if (typeof targetState !== `string`) throw new TypeError(`Target 'state' field is not a string. Got: ${typeof targetState}`);
      if (`preconditions` in target) return {
        state: targetState,
        preconditions: target.preconditions
      };
      return { state: targetState };
    } else throw new Error(`Unexpected type: ${typeof target}. Expected string or object with 'state' field.`);
  };
  if (Array.isArray(targets)) {
    let containsNull = false;
    const mapResults = targets.map((t6) => {
      const r5 = normaliseSingleTarget(t6);
      if (!r5) throw new Error(`Invalid target`);
      containsNull = containsNull || r5.state === null;
      return r5;
    });
    if (containsNull && mapResults.length > 1) throw new Error(`Cannot have null as an possible state`);
    return mapResults;
  } else {
    const target = normaliseSingleTarget(targets);
    if (!target) return;
    return [target];
  }
};
var validateAndNormaliseTransitions = (d3) => {
  const returnMap = /* @__PURE__ */ new Map();
  for (const [topLevelState, topLevelTargets] of Object.entries(d3)) {
    if (typeof topLevelState === `undefined`) throw new TypeError(`Top-level undefined state`);
    if (typeof topLevelTargets === `undefined`) throw new TypeError(`Undefined target state for ${topLevelState}`);
    if (returnMap.has(topLevelState)) throw new Error(`State defined twice: ${topLevelState}`);
    if (topLevelState.includes(` `)) throw new Error(`State names cannot contain spaces`);
    returnMap.set(topLevelState, []);
  }
  for (const [topLevelState, topLevelTargets] of Object.entries(d3)) {
    const targets = normaliseTargets(topLevelTargets);
    if (targets === void 0) throw new Error(`Could not normalise target`);
    if (targets !== null) {
      const seenStates = /* @__PURE__ */ new Set();
      for (const target of targets) {
        if (seenStates.has(target.state)) throw new Error(`Target state '${target.state}' already exists for '${topLevelState}'`);
        seenStates.add(target.state);
        if (target.state === null) continue;
        if (!returnMap.has(target.state)) throw new Error(`Target state '${target.state}' is not defined as a top-level state. Defined under: '${topLevelState}'`);
      }
      returnMap.set(topLevelState, targets);
    }
  }
  return returnMap;
};
var validateMachineState = (state) => {
  if (typeof state === `undefined`) throw new TypeError(`Param 'state' is undefined`);
  if (typeof state.value !== `string`) throw new TypeError(`Existing state is not a string`);
};
var to2 = (sm, toState) => {
  validateMachineState(sm);
  validateTransition(sm, toState);
  return Object.freeze({
    value: toState,
    machine: sm.machine,
    visited: unique([sm.visited, [sm.value]])
  });
};
var next2 = (sm) => {
  const first2 = possibleTargets(sm).at(0);
  if (!first2 || first2.state === null) throw new Error(`Not possible to move to a next state from '${sm.value}`);
  return to2(sm, first2.state);
};
var isValidTransition = (sm, toState) => {
  try {
    validateTransition(sm, toState);
    return true;
  } catch {
    return false;
  }
};
var validateTransition = (sm, toState) => {
  if (toState === null) throw new Error(`Cannot transition to null state`);
  if (typeof toState === `undefined`) throw new Error(`Cannot transition to undefined state`);
  if (typeof toState !== `string`) throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof toState}`);
  const p3 = possible(sm);
  if (p3.length === 0) throw new Error(`Machine is in terminal state`);
  if (!p3.includes(toState)) throw new Error(`Target state '${toState}' not available at current state '${sm.value}'. Possible states: ${p3.join(`, `)}`);
};
var fromList = (...states) => {
  const t6 = {};
  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);
  if (states.length <= 2) throw new Error(`Expects at least two states`);
  for (let index = 0; index < states.length; index++) {
    const s3 = states[index];
    if (typeof s3 !== `string`) throw new TypeError(`Expected array of strings. Got type '${typeof s3}' at index ${index.toString()}`);
    t6[s3] = index === states.length - 1 ? null : states[index + 1];
  }
  return t6;
};
var fromListBidirectional = (...states) => {
  const t6 = {};
  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);
  if (states.length < 2) throw new Error(`Expects at least two states`);
  for (const [index, s3] of states.entries()) {
    if (typeof s3 !== `string`) throw new TypeError(`Expected array of strings. Got type '${typeof s3}' at index ${index.toString()}`);
    t6[s3] = [];
  }
  for (let index = 0; index < states.length; index++) {
    const v3 = t6[states[index]];
    if (index === states.length - 1) if (states.length > 1) v3.push(states[index - 1]);
    else t6[states[index]] = null;
    else {
      v3.push(states[index + 1]);
      if (index > 0) v3.push(states[index - 1]);
    }
  }
  return t6;
};
async function driver(machine, handlersOrOpts) {
  const opts = Array.isArray(handlersOrOpts) ? { handlers: handlersOrOpts } : handlersOrOpts;
  const debug$1 = resolveLogOption(opts.debug, { category: `StateMachineDriver` });
  const byState = /* @__PURE__ */ new Map();
  for (const h5 of opts.handlers) {
    const ifBlock = Array.isArray(h5.if) ? h5.if : [h5.if];
    for (const state of ifBlock) {
      if (typeof state !== `string`) throw new TypeError(`Expected single or array of strings for the 'if' field. Got: '${typeof state}'.`);
      if (byState.has(state)) throw new Error(`Multiple handlers defined for state '${state}'. There should be at most one.`);
      byState.set(state, h5);
    }
  }
  const runOpts = {
    rank: (a3, b3) => {
      return defaultComparer(a3.score ?? 0, b3.score ?? 0);
    },
    shuffle: opts.shuffleHandlers ?? false
  };
  let sm = init(machine);
  for (const [ifState] of byState) if (typeof sm.machine[ifState] === `undefined` && ifState !== `__fallback`) throw new Error(`StateMachineDriver handler references a state ('${ifState}') which is not defined on the machine. Therefore this handler will never run.'`);
  const run$1 = async () => {
    debug$1(`Run. State: ${sm.value}`);
    const state = sm.value;
    let handler = byState.get(state);
    if (handler === void 0) {
      debug$1(`  No handler for state '${state}', trying __fallback`);
      handler = byState.get(`__fallback`);
    }
    if (handler === void 0) {
      debug$1(`  No __fallback handler`);
      return;
    }
    const runOptionsForHandler = handler.resultChoice === `first` ? {
      ...runOpts,
      stop: (latest) => {
        if (!latest) return false;
        if (`reset` in latest) return true;
        if (`next` in latest && latest.next !== void 0) return true;
        return false;
      }
    } : runOpts;
    const results = await run2(handler.then, runOptionsForHandler, sm);
    debug$1(`  In state '${sm.value}' results: ${results.length}. Choice: ${handler.resultChoice}`);
    let r5;
    switch (handler.resultChoice ?? `highest`) {
      case `highest`: {
        r5 = results.at(-1);
        break;
      }
      case `first`: {
        r5 = results[0];
        break;
      }
      case `lowest`: {
        r5 = results.at(0);
        break;
      }
      case `random`: {
        r5 = randomElement(results);
        break;
      }
      default:
        throw new Error(`Unknown 'resultChoice' option: ${handler.resultChoice}. Expected highest, first, lowest or random`);
    }
    debug$1(`  Chosen result: ${JSON.stringify(r5)}`);
    if (r5?.reset) sm = reset(sm);
    else if (r5 && r5.next) if (typeof r5.next === `boolean`) sm = next2(sm);
    else {
      debug$1(JSON.stringify(results));
      sm = to2(sm, r5.next);
    }
    return sm;
  };
  return {
    reset: () => {
      sm = reset(sm);
    },
    getValue: () => sm.value,
    run: run$1,
    to: (state) => {
      sm = to2(sm, state);
      return sm;
    }
  };
}
var StateMachineWithEvents = class extends SimpleEventEmitter {
  #sm;
  #smInitial;
  #debug;
  #isDoneNeedsFiring = false;
  #isDone = false;
  #changedAt = elapsedInfinity();
  /**
  * Create a state machine with initial state, description and options
  * @param m Machine description
  * @param opts Options for machine (defaults to `{debug:false}`)
  */
  constructor(m4, opts = {}) {
    super();
    this.#debug = opts.debug ?? false;
    this.#sm = init(m4, opts.initial);
    this.#smInitial = cloneState(this.#sm);
  }
  #setIsDone(v3) {
    if (this.#isDone === v3) return;
    this.#isDone = v3;
    if (v3) {
      this.#isDoneNeedsFiring = true;
      setTimeout(() => {
        if (!this.#isDoneNeedsFiring) return;
        this.#isDoneNeedsFiring = false;
        this.fireEvent(`stop`, { state: this.#sm.value });
      }, 2);
    } else this.#isDoneNeedsFiring = false;
  }
  /**
  * Return a list of possible states from current state.
  *
  * If list is empty, no states are possible. Otherwise lists
  * possible states, including 'null' for terminal
  */
  get statesPossible() {
    return possible(this.#sm);
  }
  /**
  * Return a list of all defined states
  */
  get statesDefined() {
    return Object.keys(this.#sm.machine);
  }
  /**
  * Moves to the next state if possible. If multiple states are possible, it will use the first.
  * If machine is finalised, no error is thrown and null is returned.
  *
  * @returns {(string|null)} Returns new state, or null if machine is finalised
  */
  next() {
    const p3 = possible(this.#sm);
    if (p3.length === 0) return null;
    this.state = p3[0];
    return p3[0];
  }
  /**
  * Returns _true_ if state machine is in its final state
  *
  * @returns
  */
  get isDone() {
    return isDone(this.#sm);
  }
  /**
  * Resets machine to initial state
  */
  reset() {
    this.#setIsDone(false);
    this.#sm = cloneState(this.#smInitial);
    this.#changedAt = elapsedSince();
  }
  /**
  * Throws if it's not valid to transition to `newState`
  * @param newState
  * @returns
  */
  validateTransition(newState) {
    validateTransition(this.#sm, newState);
  }
  /**
  * Returns _true_ if `newState` is valid transition from current state.
  * Use {@link validateTransition} if you want an explanation for the _false_ results.
  * @param newState
  * @returns
  */
  isValid(newState) {
    return isValidTransition(this.#sm, newState);
  }
  /**
  * Gets or sets state. Throws an error if an invalid transition is attempted.
  * Use `isValid()` to check validity without changing.
  *
  * If `newState` is the same as current state, the request is ignored silently.
  */
  set state(newState) {
    const priorState = this.#sm.value;
    if (newState === this.#sm.value) return;
    this.#sm = to2(this.#sm, newState);
    if (this.#debug) console.log(`StateMachine: ${priorState} -> ${newState}`);
    this.#changedAt = elapsedSince();
    setTimeout(() => {
      this.fireEvent(`change`, {
        newState,
        priorState
      });
    }, 1);
    if (isDone(this.#sm)) this.#setIsDone(true);
  }
  get state() {
    return this.#sm.value;
  }
  /**
  * Returns timestamp when state was last changed.
  * See also `elapsed`
  */
  get changedAt() {
    return this.#changedAt();
  }
  /**
  * Returns milliseconds elapsed since last state change.
  * See also `changedAt`
  */
  get elapsed() {
    return this.#changedAt();
  }
};
var state_machine_exports = {};
__export(state_machine_exports, {
  StateMachineWithEvents: () => StateMachineWithEvents,
  cloneState: () => cloneState,
  driver: () => driver,
  fromList: () => fromList,
  fromListBidirectional: () => fromListBidirectional,
  init: () => init,
  isDone: () => isDone,
  isValidTransition: () => isValidTransition,
  next: () => next2,
  normaliseTargets: () => normaliseTargets,
  possible: () => possible,
  possibleTargets: () => possibleTargets,
  reset: () => reset,
  to: () => to2,
  validateMachine: () => validateMachine,
  validateTransition: () => validateTransition
});
var src_exports5 = {};
__export(src_exports5, {
  DispatchList: () => DispatchList,
  Pool: () => Pool,
  PoolUser: () => PoolUser,
  RequestResponseMatch: () => RequestResponseMatch,
  Resource: () => Resource,
  StateMachine: () => state_machine_exports,
  SyncWait: () => SyncWait,
  TaskQueueMutable: () => TaskQueueMutable,
  WaitForValue: () => WaitForValue,
  backoffGenerator: () => backoffGenerator,
  continuously: () => continuously,
  create: () => create2,
  debounce: () => debounce2,
  delay: () => delay2,
  delayLoop: () => delayLoop,
  elapsedMillisecondsAbsolute: () => elapsedMillisecondsAbsolute,
  elapsedTicksAbsolute: () => elapsedTicksAbsolute,
  eventRace: () => eventRace,
  everyNth: () => everyNth,
  frequencyTimer: () => frequencyTimer,
  hasElapsed: () => hasElapsed,
  iterateBreadth: () => iterateBreadth,
  iterateDepth: () => iterateDepth,
  movingAverageTimed: () => movingAverageTimed,
  ofTotal: () => ofTotal,
  ofTotalTicks: () => ofTotalTicks,
  promiseWithResolvers: () => promiseWithResolvers,
  rateMinimum: () => rateMinimum,
  relative: () => relative,
  repeat: () => repeat2,
  repeatSync: () => repeatSync,
  retryFunction: () => retryFunction,
  retryTask: () => retryTask,
  run: () => run2,
  runOnce: () => runOnce,
  runSingle: () => runSingle,
  singleItem: () => singleItem,
  sleep: () => sleep,
  throttle: () => throttle,
  timeout: () => timeout,
  timerAlwaysDone: () => timerAlwaysDone,
  timerNeverDone: () => timerNeverDone,
  timerWithFunction: () => timerWithFunction,
  updateOutdated: () => updateOutdated,
  waitFor: () => waitFor
});

// node_modules/ixfx/bundle/bezier-DxzJ_wRN.js
var weightedIndex = (weightings, rand = Math.random) => {
  const precompute = [];
  let total2 = 0;
  for (let index = 0; index < weightings.length; index++) {
    total2 += weightings[index];
    precompute[index] = total2;
  }
  if (total2 !== 1) throw new Error(`Weightings should add up to 1. Got: ${total2}`);
  return () => {
    const v3 = rand();
    for (let index = 0; index < precompute.length; index++) if (v3 <= precompute[index]) return index;
    throw new Error(`Bug: weightedIndex could not select index`);
  };
};
var randomIndex2 = (array3, rand = Math.random) => Math.floor(rand() * array3.length);
function randomPluck(array3, options = {}) {
  if (typeof array3 === `undefined`) throw new Error(`Param 'array' is undefined`);
  if (!Array.isArray(array3)) throw new Error(`Param 'array' is not an array`);
  const mutate = options.mutate ?? false;
  const rand = options.source ?? Math.random;
  if (array3.length === 0) {
    if (mutate) return void 0;
    return {
      value: void 0,
      remainder: []
    };
  }
  const index = randomIndex2(array3, rand);
  if (mutate) {
    const v3 = array3[index];
    array3.splice(index, 1);
    return v3;
  } else {
    const inputCopy = [...array3];
    inputCopy.splice(index, 1);
    return {
      value: array3[index],
      remainder: inputCopy
    };
  }
}
var randomElement2 = (array3, rand = Math.random) => {
  resultThrow(arrayTest(array3, `array`));
  return array3[Math.floor(rand() * array3.length)];
};
var randomElementWeightedSource = (array3, weightings, randomSource = Math.random) => {
  if (array3.length !== weightings.length) throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);
  const r5 = weightedIndex(weightings, randomSource);
  return () => {
    const index = r5();
    return array3[index];
  };
};
var shuffle2 = (dataToShuffle, rand = Math.random) => {
  const array3 = [...dataToShuffle];
  for (let index = array3.length - 1; index > 0; index--) {
    const index_ = Math.floor(rand() * (index + 1));
    [array3[index], array3[index_]] = [array3[index_], array3[index]];
  }
  return array3;
};
var chance = (p3, a3, b3, randomSource) => {
  const source = randomSource ?? Math.random;
  const resolve2 = (x3) => {
    if (typeof x3 === `function`) return x3();
    return x3;
  };
  const pp = resolve2(p3);
  resultThrow(numberTest(pp, `percentage`, `p`));
  if (source() <= pp) return resolve2(b3);
  else return resolve2(a3);
};
var bipolarSource = (maxOrOptions) => {
  const source = floatSource(maxOrOptions);
  return () => source() * 2 - 1;
};
var bipolar = (maxOrOptions) => {
  const source = bipolarSource(maxOrOptions);
  return source();
};
var floatSource = (maxOrOptions = 1) => {
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  let max$12 = options.max ?? 1;
  let min$12 = options.min ?? 0;
  const source = options.source ?? Math.random;
  resultThrow(numberTest(min$12, ``, `min`), numberTest(max$12, ``, `max`));
  if (!options.min && max$12 < 0) {
    min$12 = max$12;
    max$12 = 0;
  }
  if (min$12 > max$12) throw new Error(`Min is greater than max. Min: ${min$12.toString()} max: ${max$12.toString()}`);
  return () => source() * (max$12 - min$12) + min$12;
};
var float = (maxOrOptions = 1) => floatSource(maxOrOptions)();
var calculateNonZero = (source = Math.random) => {
  let v3 = 0;
  while (v3 === 0) v3 = source();
  return v3;
};
var gaussian = (skew = 1) => gaussianSource(skew)();
var gaussianSource = (skew = 1) => {
  const min$12 = 0;
  const max$12 = 1;
  const compute = () => {
    const u3 = calculateNonZero();
    const v3 = calculateNonZero();
    let result = Math.sqrt(-2 * Math.log(u3)) * Math.cos(2 * Math.PI * v3);
    result = result / 10 + 0.5;
    if (result > 1 || result < 0) result = compute();
    else {
      result = Math.pow(result, skew);
      result *= max$12 - min$12;
      result += min$12;
    }
    return result;
  };
  return compute;
};
var shortGuid = (options = {}) => {
  const source = options.source ?? Math.random;
  const firstPart = Math.trunc(source() * 46656);
  const secondPart = Math.trunc(source() * 46656);
  const firstPartString = `000${firstPart.toString(36)}`.slice(-3);
  const secondPartString = `000${secondPart.toString(36)}`.slice(-3);
  return firstPartString + secondPartString;
};
function* count2(amount, offset3 = 0) {
  resultThrow(integerTest(amount, ``, `amount`), integerTest(offset3, ``, `offset`));
  if (amount === 0) return;
  let index = 0;
  do
    yield amount < 0 ? -index + offset3 : index + offset3;
  while (index++ < Math.abs(amount) - 1);
}
var integerSource = (maxOrOptions) => {
  if (typeof maxOrOptions === `undefined`) throw new TypeError(`maxOrOptions is undefined`);
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  let max$12 = Math.floor(options.max ?? 100);
  let min$12 = Math.floor(options.min ?? 0);
  if (!options.min && max$12 < 0) {
    max$12 = 1;
    min$12 = options.max ?? 0;
  }
  const randomSource = options.source ?? Math.random;
  if (min$12 > max$12) throw new Error(`Min value is greater than max (min: ${min$12.toString()} max: ${max$12.toString()})`);
  resultThrow(numberTest(min$12, ``, `min`), numberTest(max$12, ``, `max`));
  if (max$12 === min$12) throw new Error(`Max and min values cannot be the same (${max$12.toString()})`);
  const amt = Math.abs(max$12 - min$12);
  return () => Math.floor(randomSource() * amt) + min$12;
};
var integer = (maxOrOptions) => integerSource(maxOrOptions)();
function* integerUniqueGen(maxOrOptions) {
  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;
  const min$12 = options.min ?? 0;
  const max$12 = options.max ?? 100;
  const source = options.source ?? Math.random;
  const loop = options.loop ?? false;
  resultThrow(integerTest(min$12, ``, `min`), integerTest(max$12, ``, `max`));
  if (min$12 > max$12) throw new Error(`Min value is greater than max. Min: ${min$12.toString()} Max: ${max$12.toString()}`);
  const origRange = [...count2(max$12 - min$12, min$12)];
  let numberRange = shuffle2(origRange);
  let index = 0;
  while (true) {
    if (index === numberRange.length) if (loop) numberRange = shuffle2(origRange, source);
    else return;
    yield numberRange[index++];
  }
}
function mersenneTwister(seed) {
  if (!seed) seed = Math.random() * 4294967295;
  let mt3 = new Array(624);
  mt3[0] = seed >>> 0;
  const n1 = 1812433253;
  for (let mti$1 = 1; mti$1 < 624; mti$1++) {
    const n22 = mt3[mti$1 - 1] ^ mt3[mti$1 - 1] >>> 30;
    mt3[mti$1] = ((n1 & 4294901760) * n22 >>> 0) + ((n1 & 65535) * n22 >>> 0) + mti$1 >>> 0;
  }
  let mti = 624;
  const randomUint32 = () => {
    let y3;
    if (mti >= 624) {
      for (let i4 = 0; i4 < 227; i4++) {
        y3 = (mt3[i4] & 2147483648 | mt3[i4 + 1] & 2147483647) >>> 0;
        mt3[i4] = (mt3[i4 + 397] ^ y3 >>> 1 ^ (y3 & 1 ? 2567483615 : 0)) >>> 0;
      }
      for (let i4 = 227; i4 < 623; i4++) {
        y3 = (mt3[i4] & 2147483648 | mt3[i4 + 1] & 2147483647) >>> 0;
        mt3[i4] = (mt3[i4 - 227] ^ y3 >>> 1 ^ (y3 & 1 ? 2567483615 : 0)) >>> 0;
      }
      y3 = (mt3[623] & 2147483648 | mt3[0] & 2147483647) >>> 0;
      mt3[623] = (mt3[396] ^ y3 >>> 1 ^ (y3 & 1 ? 2567483615 : 0)) >>> 0;
      mti = 0;
    }
    y3 = mt3[mti++];
    y3 = (y3 ^ y3 >>> 11) >>> 0;
    y3 = (y3 ^ y3 << 7 & 2636928640) >>> 0;
    y3 = (y3 ^ y3 << 15 & 4022730752) >>> 0;
    y3 = (y3 ^ y3 >>> 18) >>> 0;
    return y3;
  };
  const float$1 = () => randomUint32() / 4294967296;
  const integer$1 = (maxExclusive, minInclusive = 0) => {
    if (maxExclusive < 1) throw new Error("Upper bound must be greater than or equal to 1");
    if (maxExclusive > 4294967296) throw new Error("Upper bound must not be greater than 4294967296");
    if (maxExclusive === 1) return 0;
    let range = maxExclusive - minInclusive;
    const bitsNeeded = Math.ceil(Math.log2(range)), bitMask = (1 << bitsNeeded) - 1;
    while (true) {
      const int = randomUint32() & bitMask;
      if (int < range) return minInclusive + int;
    }
  };
  return {
    integer: integer$1,
    float: float$1
  };
}
var string = (lengthOrOptions = 5) => {
  const options = typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;
  const calculate = options.source ?? Math.random;
  const length3 = options.length ?? 5;
  let returnValue = ``;
  while (returnValue.length < length3) returnValue += calculate().toString(36).slice(2);
  return returnValue.substring(0, length3);
};
var minutesMsSource = (maxMinutesOrOptions) => {
  const options = typeof maxMinutesOrOptions === `number` ? { max: maxMinutesOrOptions } : maxMinutesOrOptions;
  const min$12 = (options.min ?? 0) * 60 * 1e3;
  const max$12 = (options.max ?? 5) * 60 * 1e3;
  return integerSource({
    ...options,
    max: max$12,
    min: min$12
  });
};
var minutesMs = (maxMinutesOrOptions) => minutesMsSource(maxMinutesOrOptions)();
var secondsMsSource = (maxSecondsOrOptions) => {
  const options = typeof maxSecondsOrOptions === `number` ? { max: maxSecondsOrOptions } : maxSecondsOrOptions;
  const min$12 = (options.min ?? 0) * 1e3;
  const max$12 = (options.max ?? 5) * 1e3;
  return () => integer({
    ...options,
    max: max$12,
    min: min$12
  });
};
var secondsMs = (maxSecondsOrOptions) => secondsMsSource(maxSecondsOrOptions)();
function clamp2(v3, min$12 = 0, max$12 = 1) {
  if (v3 < min$12) return min$12;
  if (v3 > max$12) return max$12;
  return v3;
}
var weightedIntegerSource = (options) => {
  const source = options.source ?? Math.random;
  if (typeof options.easingFunction === `undefined`) throw new Error(`Param 'easingFunction' is undefined`);
  const max$12 = options.max ?? 1;
  const min$12 = options.min ?? 0;
  if (max$12 === min$12) throw new Error(`Param 'max' is the same as  'min'`);
  if (max$12 < min$12) throw new Error(`Param 'max' should be greater than  'min'`);
  const compute = () => {
    const r5 = clamp2(options.easingFunction(source()));
    return Math.floor(r5 * (max$12 - min$12)) + min$12;
  };
  return compute;
};
var weightedInteger = (options) => weightedIntegerSource(options)();
var weighted = (options) => weightedSource(options)();
var weightedSource = (options) => {
  const source = options.source ?? Math.random;
  if (typeof options.easing !== `undefined`) throw new Error(`Param 'easingName' unavailable. Use @ixfx/modulation.weighted instead.`);
  if (typeof options.easingFunction === `undefined`) throw new Error(`Param 'easingFunction' is undefined`);
  return () => options.easingFunction(source());
};
var src_exports$13 = {};
__export(src_exports$13, {
  bipolar: () => bipolar,
  bipolarSource: () => bipolarSource,
  calculateNonZero: () => calculateNonZero,
  chance: () => chance,
  float: () => float,
  floatSource: () => floatSource,
  gaussian: () => gaussian,
  gaussianSource: () => gaussianSource,
  integer: () => integer,
  integerSource: () => integerSource,
  integerUniqueGen: () => integerUniqueGen,
  mersenneTwister: () => mersenneTwister,
  minutesMs: () => minutesMs,
  minutesMsSource: () => minutesMsSource,
  randomElement: () => randomElement2,
  randomElementWeightedSource: () => randomElementWeightedSource,
  randomIndex: () => randomIndex2,
  randomPluck: () => randomPluck,
  secondsMs: () => secondsMs,
  secondsMsSource: () => secondsMsSource,
  shortGuid: () => shortGuid,
  shuffle: () => shuffle2,
  string: () => string,
  weighted: () => weighted,
  weightedIndex: () => weightedIndex,
  weightedInteger: () => weightedInteger,
  weightedIntegerSource: () => weightedIntegerSource,
  weightedSource: () => weightedSource
});
function handleChangeResult(monitor, onChanged, onNotChanged) {
  return (v3) => {
    const r5 = monitor(v3);
    if (r5.changed) onChanged(v3, r5.changes, r5.total);
    else if (typeof onNotChanged !== `undefined`) onNotChanged(v3, r5.identicalRun, r5.total);
  };
}
function trackNumberChange(options = {}) {
  const nanHandling = options.nanHandling ?? `error`;
  const includeFirstValueInCount = options.includeFirstValueInCount ?? false;
  let lastValue = options.initial;
  let changes = 0;
  let total2 = 0;
  let identicalRun = 0;
  return (v3) => {
    if (typeof v3 !== `number`) throw new TypeError(`Parameter should be number. Got type: ${typeof v3}`);
    if (Number.isNaN(v3)) switch (nanHandling) {
      case `error`:
        throw new Error(`Parameter is NaN`);
      case `skip`:
        return {
          changed: false,
          changes,
          total: total2,
          identicalRun
        };
    }
    total2++;
    let eq = lastValue === v3;
    if (Number.isNaN(lastValue) && Number.isNaN(v3)) eq = true;
    if (!eq) {
      identicalRun = 0;
      if (lastValue !== void 0 || includeFirstValueInCount) changes++;
      lastValue = v3;
      return {
        changed: true,
        changes,
        total: total2,
        identicalRun
      };
    } else identicalRun++;
    return {
      changed: false,
      changes,
      total: total2,
      identicalRun
    };
  };
}
function trackBooleanChange(options = {}) {
  const includeFirstValueInCount = options.includeFirstValueInCount ?? false;
  let lastValue = options.initial;
  let changes = 0;
  let total2 = 0;
  let identicalRun = 0;
  return (v3) => {
    if (typeof v3 !== `boolean`) throw new TypeError(`Parameter should be boolean. Got type: ${typeof v3}`);
    total2++;
    if (lastValue !== v3) {
      identicalRun = 0;
      if (lastValue !== void 0 || includeFirstValueInCount) changes++;
      lastValue = v3;
      return {
        changed: true,
        changes,
        total: total2,
        identicalRun
      };
    } else identicalRun++;
    return {
      changed: false,
      changes,
      total: total2,
      identicalRun
    };
  };
}
var FrequencyTracker = class extends SimpleEventEmitter {
  #store;
  #keyString;
  /**
  * Constructor
  * @param keyString Function to key items. Uses JSON.stringify by default
  */
  constructor(keyString) {
    super();
    this.#store = /* @__PURE__ */ new Map();
    if (typeof keyString === `undefined`) keyString = (a3) => {
      if (a3 === void 0) throw new Error(`Cannot create key for undefined`);
      return typeof a3 === `string` ? a3 : JSON.stringify(a3);
    };
    this.#keyString = keyString;
  }
  /**
  * Clear data. Fires `change` event
  */
  clear() {
    this.#store.clear();
    this.fireEvent(`change`, { context: this });
  }
  /**
  * @returns Iterator over keys (ie. groups)
  */
  keys() {
    return this.#store.keys();
  }
  /**
  * @returns Iterator over frequency counts
  */
  values() {
    return this.#store.values();
  }
  /**
  * @returns Copy of entries as an array of `[key, count]`
  */
  toArray() {
    return [...this.#store.entries()];
  }
  /**
  * Returns a string with keys and counts, useful for debugging.
  * @returns
  */
  debugString() {
    let t$1 = ``;
    for (const [key, count$1] of this.#store.entries()) t$1 += `${key}: ${count$1.toString()}, `;
    if (t$1.endsWith(`, `)) return t$1.slice(0, Math.max(0, t$1.length - 2));
    return t$1;
  }
  /**
  *
  * @param value Value to count
  * @returns Frequency of value, or _undefined_ if it does not exist
  */
  frequencyOf(value3) {
    if (typeof value3 === `string`) return this.#store.get(value3);
    const key = this.#keyString(value3);
    return this.#store.get(key);
  }
  /**
  *
  * @param value Value to count
  * @returns Relative frequency of `value`, or _undefined_ if it does not exist
  */
  relativeFrequencyOf(value3) {
    let freq;
    if (typeof value3 === `string`) freq = this.#store.get(value3);
    else {
      const key = this.#keyString(value3);
      freq = this.#store.get(key);
    }
    if (freq === void 0) return;
    const mma = this.computeValues();
    return freq / mma.total;
  }
  /**
  * Returns copy of entries as an array
  * @returns Copy of entries as an array
  */
  entries() {
    return [...this.#store.entries()];
  }
  /**
  * Calculate min,max,avg,total & count from values
  * @returns Returns `{min,max,avg,total}`
  */
  computeValues() {
    const valuesAsNumbers = [...this.values()];
    return numberArrayCompute(valuesAsNumbers);
  }
  /**
  * Return entries sorted
  * @param sortStyle Sorting style (default: _value_, ie. count)
  * @returns Sorted array of [key,frequency]
  */
  entriesSorted(sortStyle = `value`) {
    const s3 = keyValueSorter(sortStyle);
    return s3(this.entries());
  }
  /**
  * Add one or more values, firing _change_ event.
  * @param values Values to add. Fires _change_ event after adding item(s)
  */
  add(...values3) {
    if (typeof values3 === `undefined`) throw new Error(`Param 'values' undefined`);
    const keys = values3.map((v3) => this.#keyString(v3));
    for (const key of keys) {
      const score = this.#store.get(key) ?? 0;
      this.#store.set(key, score + 1);
    }
    this.fireEvent(`change`, { context: this });
  }
};
var frequency = (keyString) => new FrequencyTracker(keyString);
var TrackerBase = class {
  /**
  * @ignore
  */
  seenCount;
  /**
  * @ignore
  */
  storeIntermediate;
  /**
  * @ignore
  */
  resetAfterSamples;
  /**
  * @ignore
  */
  sampleLimit;
  id;
  debug;
  constructor(opts = {}) {
    this.id = opts.id ?? `tracker`;
    this.debug = opts.debug ?? false;
    this.sampleLimit = opts.sampleLimit ?? -1;
    this.resetAfterSamples = opts.resetAfterSamples ?? -1;
    this.storeIntermediate = opts.storeIntermediate ?? (this.sampleLimit > -1 || this.resetAfterSamples > -1);
    this.seenCount = 0;
    if (this.debug) console.log(`TrackerBase: sampleLimit: ${this.sampleLimit} resetAfter: ${this.resetAfterSamples} store: ${this.storeIntermediate}`);
  }
  /**
  * Reset tracker
  */
  reset() {
    this.seenCount = 0;
    this.onReset();
  }
  /**
  * Adds a value, returning computed result.
  *
  * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.
  * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is
  * called to take it down to sample limit, and `onTrimmed()` is called.
  * @param p
  * @returns
  */
  seen(...p3) {
    if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) this.reset();
    else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {
      this.seenCount = this.trimStore(this.sampleLimit);
      this.onTrimmed(`resize`);
    }
    this.seenCount += p3.length;
    const t$1 = this.filterData(p3);
    return this.computeResults(t$1);
  }
};
var PrimitiveTracker = class extends TrackerBase {
  values;
  timestamps;
  constructor(opts) {
    super(opts);
    this.values = [];
    this.timestamps = [];
  }
  /**
  * Reduces size of value store to `limit`. Returns
  * number of remaining items
  * @param limit
  */
  trimStore(limit2) {
    if (limit2 >= this.values.length) return this.values.length;
    this.values = this.values.slice(-limit2);
    this.timestamps = this.timestamps.slice(-limit2);
    return this.values.length;
  }
  onTrimmed(reason) {
  }
  get last() {
    return this.values.at(-1);
  }
  get initial() {
    return this.values.at(0);
  }
  /**
  * Returns number of recorded values (this can include the initial value)
  */
  get size() {
    return this.values.length;
  }
  /**
  * Returns the elapsed time, in milliseconds since the instance was created
  */
  get elapsed() {
    if (this.values.length < 0) throw new Error(`No values seen yet`);
    return Date.now() - this.timestamps[0];
  }
  /**
  * Returns the time, in milliseconds, covering the initial and last values.
  * Returns NaN if either of these is missing.
  */
  get timespan() {
    const oldest = this.timestamps.at(0);
    const newest = this.timestamps.at(-1);
    if (oldest === void 0) return NaN;
    if (newest === void 0) return NaN;
    return newest - oldest;
  }
  onReset() {
    this.values = [];
    this.timestamps = [];
  }
  /**
  * Tracks a value
  */
  filterData(rawValues) {
    const lastValue = rawValues.at(-1);
    const last2 = {
      value: lastValue,
      at: performance.now()
    };
    const values3 = rawValues.map((value3) => ({
      at: performance.now(),
      value: value3
    }));
    if (this.storeIntermediate) {
      this.values.push(...rawValues);
      this.timestamps.push(...values3.map((v3) => v3.at));
    } else switch (this.values.length) {
      case 0: {
        this.values.push(last2.value);
        this.timestamps.push(last2.at);
        break;
      }
      case 2: {
        this.values[1] = last2.value;
        this.timestamps[1] = last2.at;
        break;
      }
      case 1: {
        this.values.push(last2.value);
        this.timestamps.push(last2.at);
        break;
      }
    }
    return values3;
  }
};
var NumberTracker = class extends PrimitiveTracker {
  #total = 0;
  #min = Number.MAX_SAFE_INTEGER;
  #max = Number.MIN_SAFE_INTEGER;
  /**
  * Difference between last value and initial.
  * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)
  * If either of those is missing, undefined is returned
  */
  difference() {
    if (this.last === void 0) return;
    if (this.initial === void 0) return;
    return this.last - this.initial;
  }
  /**
  * Relative difference between last value and initial.
  * Eg if last value was 10 and initial value was 5, 2 is returned (200%)
  */
  relativeDifference() {
    if (this.last === void 0) return;
    if (this.initial === void 0) return;
    return this.last / this.initial;
  }
  onReset() {
    this.#min = Number.MAX_SAFE_INTEGER;
    this.#max = Number.MIN_SAFE_INTEGER;
    this.#total = 0;
    super.onReset();
  }
  /**
  * When trimmed, recomputes to set total/min/max to be based on
  * current values.
  * @param reason
  */
  onTrimmed(reason) {
    this.#min = minFast(this.values);
    this.#max = maxFast(this.values);
    this.#total = totalFast(this.values);
  }
  computeResults(values3) {
    if (values3.some((v3) => Number.isNaN(v3))) throw new Error(`Cannot add NaN`);
    const numbers = values3.map((value3) => value3.value);
    this.#total = numbers.reduce((accumulator, v3) => accumulator + v3, this.#total);
    this.#min = Math.min(...numbers, this.#min);
    this.#max = Math.max(...numbers, this.#max);
    return {
      max: this.#max,
      min: this.#min,
      total: this.#total,
      avg: this.avg
    };
  }
  getMinMaxAvg() {
    return {
      min: this.#min,
      max: this.#max,
      avg: this.avg
    };
  }
  get max() {
    return this.#max;
  }
  get total() {
    return this.#total;
  }
  get min() {
    return this.#min;
  }
  get avg() {
    return this.#total / this.seenCount;
  }
};
var number = (opts = {}) => new NumberTracker(opts);
var IntervalTracker = class extends NumberTracker {
  lastMark = 0;
  mark() {
    if (this.lastMark > 0) this.seen(performance.now() - this.lastMark);
    this.lastMark = performance.now();
  }
};
var interval = (options) => new IntervalTracker(options);
var RateTracker = class {
  #events = [];
  #fromTime;
  #resetAfterSamples;
  #sampleLimit;
  #resetTimer;
  constructor(opts = {}) {
    this.#resetAfterSamples = opts.resetAfterSamples ?? Number.MAX_SAFE_INTEGER;
    this.#sampleLimit = opts.sampleLimit ?? Number.MAX_SAFE_INTEGER;
    if (opts.timeoutInterval) this.#resetTimer = timeout(() => {
      this.reset();
    }, opts.timeoutInterval);
    this.#fromTime = performance.now();
  }
  /**
  * Mark that an event has happened
  */
  mark() {
    if (this.#events.length >= this.#resetAfterSamples) this.reset();
    else if (this.#events.length >= this.#sampleLimit) {
      this.#events = this.#events.slice(1);
      this.#fromTime = this.#events[0];
    }
    this.#events.push(performance.now());
    if (this.#resetTimer) this.#resetTimer.start();
  }
  /**
  * Compute {min,max,avg} for the interval _between_ events.
  * @returns
  */
  computeIntervals() {
    const intervals = [];
    let min$12 = Number.MAX_SAFE_INTEGER;
    let max$12 = Number.MIN_SAFE_INTEGER;
    let total2 = 0;
    let count$1 = 0;
    let start = 0;
    for (const event2 of this.#events) {
      if (count$1 > 0) {
        const index = event2 - start;
        min$12 = Math.min(index, min$12);
        max$12 = Math.max(index, max$12);
        total2 += index;
        intervals.push(index);
      }
      start = event2;
      count$1++;
    }
    const avg = total2 / count$1;
    return {
      min: min$12,
      max: max$12,
      avg
    };
  }
  /**
  * Returns the time period (in milliseconds) that encompasses
  * the data set. Eg, a result of 1000 means there's data that
  * covers a one second period.
  */
  get elapsed() {
    return performance.now() - this.#fromTime;
  }
  /**
  * Resets the tracker.
  */
  reset() {
    this.#events = [];
    this.#fromTime = performance.now();
  }
  /**
  * Get the number of events per second
  */
  get perSecond() {
    return this.#events.length / (this.elapsed / 1e3);
  }
  /**
  * Get the number of events per minute
  */
  get perMinute() {
    return this.#events.length / (this.elapsed / 1e3 / 60);
  }
};
var rate = (opts = {}) => new RateTracker(opts);
var ObjectTracker = class extends TrackerBase {
  values;
  constructor(opts = {}) {
    super(opts);
    this.values = [];
  }
  onTrimmed(reason) {
  }
  /**
  * Reduces size of value store to `limit`.
  * Returns number of remaining items
  * @param limit
  */
  trimStore(limit2) {
    if (limit2 >= this.values.length) return this.values.length;
    this.values = this.values.slice(-limit2);
    return this.values.length;
  }
  /**
  * Allows sub-classes to be notified when a reset happens
  * @ignore
  */
  onReset() {
    this.values = [];
  }
  /**
  * Tracks a value
  * @ignore
  */
  filterData(p3) {
    const ts2 = p3.map((v3) => `at` in v3 ? v3 : {
      ...v3,
      at: Date.now()
    });
    const last2 = ts2.at(-1);
    if (this.storeIntermediate) this.values.push(...ts2);
    else switch (this.values.length) {
      case 0: {
        this.values.push(last2);
        break;
      }
      case 1: {
        this.values.push(last2);
        break;
      }
      case 2: {
        this.values[1] = last2;
        break;
      }
    }
    return ts2;
  }
  /**
  * Last seen value. If no values have been added, it will return the initial value
  */
  get last() {
    if (this.values.length === 1) return this.values[0];
    return this.values.at(-1);
  }
  /**
  * Returns the oldest value in the buffer
  */
  get initial() {
    return this.values.at(0);
  }
  /**
  * Returns number of recorded values (includes the initial value in the count)
  */
  get size() {
    return this.values.length;
  }
  /**
  * Returns the elapsed time, in milliseconds since the initial value
  */
  get elapsed() {
    return Date.now() - this.values[0].at;
  }
  /**
  * Returns the time, in milliseconds, covering the initial and last values.
  * Returns NaN if either of these is missing.
  */
  get timespan() {
    const oldest = this.initial;
    const newest = this.last;
    if (!oldest) return NaN;
    if (!newest) return NaN;
    return newest.at - oldest.at;
  }
};
var TrackedValueMap = class {
  store;
  gog;
  constructor(creator) {
    this.store = /* @__PURE__ */ new Map();
    this.gog = getOrGenerateSync(this.store, creator);
  }
  /**
  * Number of named values being tracked
  */
  get size() {
    return this.store.size;
  }
  /**
  * Returns _true_ if `id` is stored
  * @param id
  * @returns
  */
  has(id) {
    return this.store.has(id);
  }
  /**
  * For a given id, note that we have seen one or more values.
  * @param id Id
  * @param values Values(s)
  * @returns Information about start to last value
  */
  seen(id, ...values3) {
    const trackedValue = this.getTrackedValue(id, ...values3);
    const result = trackedValue.seen(...values3);
    return result;
  }
  /**
  * Creates or returns a TrackedValue instance for `id`.
  * @param id
  * @param values
  * @returns
  */
  getTrackedValue(id, ...values3) {
    if (id === null) throw new Error(`id parameter cannot be null`);
    if (id === void 0) throw new Error(`id parameter cannot be undefined`);
    const trackedValue = this.gog(id, values3[0]);
    return trackedValue;
  }
  /**
  * Remove a tracked value by id.
  * Use {@link reset} to clear them all.
  * @param id
  */
  delete(id) {
    this.store.delete(id);
  }
  /**
  * Remove all tracked values.
  * Use {@link delete} to remove a single value by id.
  */
  reset() {
    this.store = /* @__PURE__ */ new Map();
  }
  /**
  * Enumerate ids
  */
  *ids() {
    yield* this.store.keys();
  }
  /**
  * Enumerate tracked values
  */
  *tracked() {
    yield* this.store.values();
  }
  /**
  * Iterates TrackedValues ordered with oldest first
  * @returns
  */
  *trackedByAge() {
    const tp = [...this.store.values()];
    tp.sort((a3, b3) => {
      const aa2 = a3.elapsed;
      const bb = b3.elapsed;
      if (aa2 === bb) return 0;
      if (aa2 > bb) return -1;
      return 1;
    });
    for (const t$1 of tp) yield t$1;
  }
  /**
  * Iterates underlying values, ordered by age (oldest first)
  * First the named values are sorted by their `elapsed` value, and then
  * we return the last value for that group.
  */
  *valuesByAge() {
    for (const tb of this.trackedByAge()) yield tb.last;
  }
  /**
  * Enumerate last received values
  *
  * @example Calculate centroid of latest-received values
  * ```js
  * const pointers = pointTracker();
  * const c = Points.centroid(...Array.from(pointers.lastPoints()));
  * ```
  */
  *last() {
    for (const p3 of this.store.values()) yield p3.last;
  }
  /**
  * Enumerate starting values
  */
  *initialValues() {
    for (const p3 of this.store.values()) yield p3.initial;
  }
  /**
  * Returns a tracked value by id, or undefined if not found
  * @param id
  * @returns
  */
  get(id) {
    return this.store.get(id);
  }
};
var src_exports6 = {};
__export(src_exports6, {
  FrequencyTracker: () => FrequencyTracker,
  IntervalTracker: () => IntervalTracker,
  NumberTracker: () => NumberTracker,
  ObjectTracker: () => ObjectTracker,
  PrimitiveTracker: () => PrimitiveTracker,
  RateTracker: () => RateTracker,
  TrackedValueMap: () => TrackedValueMap,
  TrackerBase: () => TrackerBase,
  frequency: () => frequency,
  handleChangeResult: () => handleChangeResult,
  interval: () => interval,
  number: () => number,
  rate: () => rate,
  trackBooleanChange: () => trackBooleanChange,
  trackNumberChange: () => trackNumberChange
});
var { abs: abs$1, cos: cos$1, sin: sin$1, acos: acos$1, atan2, sqrt: sqrt$1, pow } = Math;
function crt(v3) {
  return v3 < 0 ? -pow(-v3, 1 / 3) : pow(v3, 1 / 3);
}
var pi$1 = Math.PI;
var tau = 2 * pi$1;
var quart = pi$1 / 2;
var epsilon = 1e-6;
var nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;
var nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;
var ZERO = {
  x: 0,
  y: 0,
  z: 0
};
var utils = {
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(t$1, derivativeFn) {
    const d3 = derivativeFn(t$1);
    let l3 = d3.x * d3.x + d3.y * d3.y;
    if (typeof d3.z !== "undefined") l3 += d3.z * d3.z;
    return sqrt$1(l3);
  },
  compute: function(t$1, points, _3d) {
    if (t$1 === 0) {
      points[0].t = 0;
      return points[0];
    }
    const order = points.length - 1;
    if (t$1 === 1) {
      points[order].t = 1;
      return points[order];
    }
    const mt3 = 1 - t$1;
    let p3 = points;
    if (order === 0) {
      points[0].t = t$1;
      return points[0];
    }
    if (order === 1) {
      const ret = {
        x: mt3 * p3[0].x + t$1 * p3[1].x,
        y: mt3 * p3[0].y + t$1 * p3[1].y,
        t: t$1
      };
      if (_3d) ret.z = mt3 * p3[0].z + t$1 * p3[1].z;
      return ret;
    }
    if (order < 4) {
      let mt22 = mt3 * mt3, t22 = t$1 * t$1, a3, b3, c5, d3 = 0;
      if (order === 2) {
        p3 = [
          p3[0],
          p3[1],
          p3[2],
          ZERO
        ];
        a3 = mt22;
        b3 = mt3 * t$1 * 2;
        c5 = t22;
      } else if (order === 3) {
        a3 = mt22 * mt3;
        b3 = mt22 * t$1 * 3;
        c5 = mt3 * t22 * 3;
        d3 = t$1 * t22;
      }
      const ret = {
        x: a3 * p3[0].x + b3 * p3[1].x + c5 * p3[2].x + d3 * p3[3].x,
        y: a3 * p3[0].y + b3 * p3[1].y + c5 * p3[2].y + d3 * p3[3].y,
        t: t$1
      };
      if (_3d) ret.z = a3 * p3[0].z + b3 * p3[1].z + c5 * p3[2].z + d3 * p3[3].z;
      return ret;
    }
    const dCpts = JSON.parse(JSON.stringify(points));
    while (dCpts.length > 1) {
      for (let i4 = 0; i4 < dCpts.length - 1; i4++) {
        dCpts[i4] = {
          x: dCpts[i4].x + (dCpts[i4 + 1].x - dCpts[i4].x) * t$1,
          y: dCpts[i4].y + (dCpts[i4 + 1].y - dCpts[i4].y) * t$1
        };
        if (typeof dCpts[i4].z !== "undefined") dCpts[i4].z = dCpts[i4].z + (dCpts[i4 + 1].z - dCpts[i4].z) * t$1;
      }
      dCpts.splice(dCpts.length - 1, 1);
    }
    dCpts[0].t = t$1;
    return dCpts[0];
  },
  computeWithRatios: function(t$1, points, ratios, _3d) {
    const mt3 = 1 - t$1, r5 = ratios, p3 = points;
    let f1 = r5[0], f22 = r5[1], f32 = r5[2], f42 = r5[3], d3;
    f1 *= mt3;
    f22 *= t$1;
    if (p3.length === 2) {
      d3 = f1 + f22;
      return {
        x: (f1 * p3[0].x + f22 * p3[1].x) / d3,
        y: (f1 * p3[0].y + f22 * p3[1].y) / d3,
        z: !_3d ? false : (f1 * p3[0].z + f22 * p3[1].z) / d3,
        t: t$1
      };
    }
    f1 *= mt3;
    f22 *= 2 * mt3;
    f32 *= t$1 * t$1;
    if (p3.length === 3) {
      d3 = f1 + f22 + f32;
      return {
        x: (f1 * p3[0].x + f22 * p3[1].x + f32 * p3[2].x) / d3,
        y: (f1 * p3[0].y + f22 * p3[1].y + f32 * p3[2].y) / d3,
        z: !_3d ? false : (f1 * p3[0].z + f22 * p3[1].z + f32 * p3[2].z) / d3,
        t: t$1
      };
    }
    f1 *= mt3;
    f22 *= 1.5 * mt3;
    f32 *= 3 * mt3;
    f42 *= t$1 * t$1 * t$1;
    if (p3.length === 4) {
      d3 = f1 + f22 + f32 + f42;
      return {
        x: (f1 * p3[0].x + f22 * p3[1].x + f32 * p3[2].x + f42 * p3[3].x) / d3,
        y: (f1 * p3[0].y + f22 * p3[1].y + f32 * p3[2].y + f42 * p3[3].y) / d3,
        z: !_3d ? false : (f1 * p3[0].z + f22 * p3[1].z + f32 * p3[2].z + f42 * p3[3].z) / d3,
        t: t$1
      };
    }
  },
  derive: function(points, _3d) {
    const dpoints = [];
    for (let p3 = points, d3 = p3.length, c5 = d3 - 1; d3 > 1; d3--, c5--) {
      const list = [];
      for (let j3 = 0, dpt; j3 < c5; j3++) {
        dpt = {
          x: c5 * (p3[j3 + 1].x - p3[j3].x),
          y: c5 * (p3[j3 + 1].y - p3[j3].y)
        };
        if (_3d) dpt.z = c5 * (p3[j3 + 1].z - p3[j3].z);
        list.push(dpt);
      }
      dpoints.push(list);
      p3 = list;
    }
    return dpoints;
  },
  between: function(v3, m4, M3) {
    return m4 <= v3 && v3 <= M3 || utils.approximately(v3, m4) || utils.approximately(v3, M3);
  },
  approximately: function(a3, b3, precision) {
    return abs$1(a3 - b3) <= (precision || epsilon);
  },
  length: function(derivativeFn) {
    const z3 = 0.5, len = utils.Tvalues.length;
    let sum4 = 0;
    for (let i4 = 0, t$1; i4 < len; i4++) {
      t$1 = z3 * utils.Tvalues[i4] + z3;
      sum4 += utils.Cvalues[i4] * utils.arcfn(t$1, derivativeFn);
    }
    return z3 * sum4;
  },
  map: function(v3, ds2, de2, ts2, te2) {
    const d1 = de2 - ds2, d22 = te2 - ts2, v22 = v3 - ds2, r5 = v22 / d1;
    return ts2 + d22 * r5;
  },
  lerp: function(r5, v1, v22) {
    const ret = {
      x: v1.x + r5 * (v22.x - v1.x),
      y: v1.y + r5 * (v22.y - v1.y)
    };
    if (v1.z !== void 0 && v22.z !== void 0) ret.z = v1.z + r5 * (v22.z - v1.z);
    return ret;
  },
  pointToString: function(p3) {
    let s3 = p3.x + "/" + p3.y;
    if (typeof p3.z !== "undefined") s3 += "/" + p3.z;
    return s3;
  },
  pointsToString: function(points) {
    return "[" + points.map(utils.pointToString).join(", ") + "]";
  },
  copy: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  angle: function(o5, v1, v22) {
    const dx1 = v1.x - o5.x, dy1 = v1.y - o5.y, dx2 = v22.x - o5.x, dy2 = v22.y - o5.y, cross = dx1 * dy2 - dy1 * dx2, dot3 = dx1 * dx2 + dy1 * dy2;
    return atan2(cross, dot3);
  },
  round: function(v3, d3) {
    const s3 = "" + v3;
    const pos = s3.indexOf(".");
    return parseFloat(s3.substring(0, pos + 1 + d3));
  },
  dist: function(p1, p22) {
    const dx = p1.x - p22.x, dy = p1.y - p22.y;
    return sqrt$1(dx * dx + dy * dy);
  },
  closest: function(LUT, point3) {
    let mdist = pow(2, 63), mpos, d3;
    LUT.forEach(function(p3, idx) {
      d3 = utils.dist(point3, p3);
      if (d3 < mdist) {
        mdist = d3;
        mpos = idx;
      }
    });
    return {
      mdist,
      mpos
    };
  },
  abcratio: function(t$1, n6) {
    if (n6 !== 2 && n6 !== 3) return false;
    if (typeof t$1 === "undefined") t$1 = 0.5;
    else if (t$1 === 0 || t$1 === 1) return t$1;
    const bottom = pow(t$1, n6) + pow(1 - t$1, n6), top = bottom - 1;
    return abs$1(top / bottom);
  },
  projectionratio: function(t$1, n6) {
    if (n6 !== 2 && n6 !== 3) return false;
    if (typeof t$1 === "undefined") t$1 = 0.5;
    else if (t$1 === 0 || t$1 === 1) return t$1;
    const top = pow(1 - t$1, n6), bottom = pow(t$1, n6) + top;
    return top / bottom;
  },
  lli8: function(x1, y1, x22, y22, x3, y3, x4, y4) {
    const nx = (x1 * y22 - y1 * x22) * (x3 - x4) - (x1 - x22) * (x3 * y4 - y3 * x4), ny = (x1 * y22 - y1 * x22) * (y3 - y4) - (y1 - y22) * (x3 * y4 - y3 * x4), d3 = (x1 - x22) * (y3 - y4) - (y1 - y22) * (x3 - x4);
    if (d3 == 0) return false;
    return {
      x: nx / d3,
      y: ny / d3
    };
  },
  lli4: function(p1, p22, p3, p4) {
    const x1 = p1.x, y1 = p1.y, x22 = p22.x, y22 = p22.y, x3 = p3.x, y3 = p3.y, x4 = p4.x, y4 = p4.y;
    return utils.lli8(x1, y1, x22, y22, x3, y3, x4, y4);
  },
  lli: function(v1, v22) {
    return utils.lli4(v1, v1.c, v22, v22.c);
  },
  makeline: function(p1, p22) {
    return new Bezier(p1.x, p1.y, (p1.x + p22.x) / 2, (p1.y + p22.y) / 2, p22.x, p22.y);
  },
  findbbox: function(sections) {
    let mx = nMax, my = nMax, MX = nMin, MY = nMin;
    sections.forEach(function(s3) {
      const bbox3 = s3.bbox();
      if (mx > bbox3.x.min) mx = bbox3.x.min;
      if (my > bbox3.y.min) my = bbox3.y.min;
      if (MX < bbox3.x.max) MX = bbox3.x.max;
      if (MY < bbox3.y.max) MY = bbox3.y.max;
    });
    return {
      x: {
        min: mx,
        mid: (mx + MX) / 2,
        max: MX,
        size: MX - mx
      },
      y: {
        min: my,
        mid: (my + MY) / 2,
        max: MY,
        size: MY - my
      }
    };
  },
  shapeintersections: function(s1, bbox1, s22, bbox22, curveIntersectionThreshold) {
    if (!utils.bboxoverlap(bbox1, bbox22)) return [];
    const intersections3 = [];
    const a1 = [
      s1.startcap,
      s1.forward,
      s1.back,
      s1.endcap
    ];
    const a22 = [
      s22.startcap,
      s22.forward,
      s22.back,
      s22.endcap
    ];
    a1.forEach(function(l1) {
      if (l1.virtual) return;
      a22.forEach(function(l22) {
        if (l22.virtual) return;
        const iss = l1.intersects(l22, curveIntersectionThreshold);
        if (iss.length > 0) {
          iss.c1 = l1;
          iss.c2 = l22;
          iss.s1 = s1;
          iss.s2 = s22;
          intersections3.push(iss);
        }
      });
    });
    return intersections3;
  },
  makeshape: function(forward, back, curveIntersectionThreshold) {
    const bpl = back.points.length;
    const fpl = forward.points.length;
    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);
    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);
    const shape = {
      startcap: start,
      forward,
      back,
      endcap: end,
      bbox: utils.findbbox([
        start,
        forward,
        back,
        end
      ])
    };
    shape.intersections = function(s22) {
      return utils.shapeintersections(shape, shape.bbox, s22, s22.bbox, curveIntersectionThreshold);
    };
    return shape;
  },
  getminmax: function(curve, d3, list) {
    if (!list) return {
      min: 0,
      max: 0
    };
    let min$12 = nMax, max$12 = nMin, t$1, c5;
    if (list.indexOf(0) === -1) list = [0].concat(list);
    if (list.indexOf(1) === -1) list.push(1);
    for (let i4 = 0, len = list.length; i4 < len; i4++) {
      t$1 = list[i4];
      c5 = curve.get(t$1);
      if (c5[d3] < min$12) min$12 = c5[d3];
      if (c5[d3] > max$12) max$12 = c5[d3];
    }
    return {
      min: min$12,
      mid: (min$12 + max$12) / 2,
      max: max$12,
      size: max$12 - min$12
    };
  },
  align: function(points, line3) {
    const tx = line3.p1.x, ty = line3.p1.y, a3 = -atan2(line3.p2.y - ty, line3.p2.x - tx), d3 = function(v3) {
      return {
        x: (v3.x - tx) * cos$1(a3) - (v3.y - ty) * sin$1(a3),
        y: (v3.x - tx) * sin$1(a3) + (v3.y - ty) * cos$1(a3)
      };
    };
    return points.map(d3);
  },
  roots: function(points, line3) {
    line3 = line3 || {
      p1: {
        x: 0,
        y: 0
      },
      p2: {
        x: 1,
        y: 0
      }
    };
    const order = points.length - 1;
    const aligned = utils.align(points, line3);
    const reduce4 = function(t$1) {
      return 0 <= t$1 && t$1 <= 1;
    };
    if (order === 2) {
      const a$1 = aligned[0].y, b$1 = aligned[1].y, c$1 = aligned[2].y, d$1 = a$1 - 2 * b$1 + c$1;
      if (d$1 !== 0) {
        const m1 = -sqrt$1(b$1 * b$1 - a$1 * c$1), m22 = -a$1 + b$1, v1$1 = -(m1 + m22) / d$1, v22 = -(-m1 + m22) / d$1;
        return [v1$1, v22].filter(reduce4);
      } else if (b$1 !== c$1 && d$1 === 0) return [(2 * b$1 - c$1) / (2 * b$1 - 2 * c$1)].filter(reduce4);
      return [];
    }
    const pa2 = aligned[0].y, pb = aligned[1].y, pc = aligned[2].y, pd = aligned[3].y;
    let d3 = -pa2 + 3 * pb - 3 * pc + pd, a3 = 3 * pa2 - 6 * pb + 3 * pc, b3 = -3 * pa2 + 3 * pb, c5 = pa2;
    if (utils.approximately(d3, 0)) {
      if (utils.approximately(a3, 0)) {
        if (utils.approximately(b3, 0)) return [];
        return [-c5 / b3].filter(reduce4);
      }
      const q$1 = sqrt$1(b3 * b3 - 4 * a3 * c5), a22 = 2 * a3;
      return [(q$1 - b3) / a22, (-b3 - q$1) / a22].filter(reduce4);
    }
    a3 /= d3;
    b3 /= d3;
    c5 /= d3;
    const p3 = (3 * b3 - a3 * a3) / 3, p32 = p3 / 3, q3 = (2 * a3 * a3 * a3 - 9 * a3 * b3 + 27 * c5) / 27, q22 = q3 / 2, discriminant = q22 * q22 + p32 * p32 * p32;
    let u1, v1, x1, x22, x3;
    if (discriminant < 0) {
      const mp3 = -p3 / 3, mp33 = mp3 * mp3 * mp3, r5 = sqrt$1(mp33), t$1 = -q3 / (2 * r5), cosphi = t$1 < -1 ? -1 : t$1 > 1 ? 1 : t$1, phi = acos$1(cosphi), crtr = crt(r5), t1 = 2 * crtr;
      x1 = t1 * cos$1(phi / 3) - a3 / 3;
      x22 = t1 * cos$1((phi + tau) / 3) - a3 / 3;
      x3 = t1 * cos$1((phi + 2 * tau) / 3) - a3 / 3;
      return [
        x1,
        x22,
        x3
      ].filter(reduce4);
    } else if (discriminant === 0) {
      u1 = q22 < 0 ? crt(-q22) : -crt(q22);
      x1 = 2 * u1 - a3 / 3;
      x22 = -u1 - a3 / 3;
      return [x1, x22].filter(reduce4);
    } else {
      const sd = sqrt$1(discriminant);
      u1 = crt(-q22 + sd);
      v1 = crt(q22 + sd);
      return [u1 - v1 - a3 / 3].filter(reduce4);
    }
  },
  droots: function(p3) {
    if (p3.length === 3) {
      const a3 = p3[0], b3 = p3[1], c5 = p3[2], d3 = a3 - 2 * b3 + c5;
      if (d3 !== 0) {
        const m1 = -sqrt$1(b3 * b3 - a3 * c5), m22 = -a3 + b3, v1 = -(m1 + m22) / d3, v22 = -(-m1 + m22) / d3;
        return [v1, v22];
      } else if (b3 !== c5 && d3 === 0) return [(2 * b3 - c5) / (2 * (b3 - c5))];
      return [];
    }
    if (p3.length === 2) {
      const a3 = p3[0], b3 = p3[1];
      if (a3 !== b3) return [a3 / (a3 - b3)];
      return [];
    }
    return [];
  },
  curvature: function(t$1, d1, d22, _3d, kOnly) {
    let num, dnm, adk, dk, k3 = 0, r5 = 0;
    const d3 = utils.compute(t$1, d1);
    const dd = utils.compute(t$1, d22);
    const qdsum = d3.x * d3.x + d3.y * d3.y;
    if (_3d) {
      num = sqrt$1(pow(d3.y * dd.z - dd.y * d3.z, 2) + pow(d3.z * dd.x - dd.z * d3.x, 2) + pow(d3.x * dd.y - dd.x * d3.y, 2));
      dnm = pow(qdsum + d3.z * d3.z, 3 / 2);
    } else {
      num = d3.x * dd.y - d3.y * dd.x;
      dnm = pow(qdsum, 3 / 2);
    }
    if (num === 0 || dnm === 0) return {
      k: 0,
      r: 0
    };
    k3 = num / dnm;
    r5 = dnm / num;
    if (!kOnly) {
      const pk = utils.curvature(t$1 - 1e-3, d1, d22, _3d, true).k;
      const nk = utils.curvature(t$1 + 1e-3, d1, d22, _3d, true).k;
      dk = (nk - k3 + (k3 - pk)) / 2;
      adk = (abs$1(nk - k3) + abs$1(k3 - pk)) / 2;
    }
    return {
      k: k3,
      r: r5,
      dk,
      adk
    };
  },
  inflections: function(points) {
    if (points.length < 4) return [];
    const p3 = utils.align(points, {
      p1: points[0],
      p2: points.slice(-1)[0]
    }), a3 = p3[2].x * p3[1].y, b3 = p3[3].x * p3[1].y, c5 = p3[1].x * p3[2].y, d3 = p3[3].x * p3[2].y, v1 = 18 * (-3 * a3 + 2 * b3 + 3 * c5 - d3), v22 = 18 * (3 * a3 - b3 - 3 * c5), v3 = 18 * (c5 - a3);
    if (utils.approximately(v1, 0)) {
      if (!utils.approximately(v22, 0)) {
        let t$1 = -v3 / v22;
        if (0 <= t$1 && t$1 <= 1) return [t$1];
      }
      return [];
    }
    const d22 = 2 * v1;
    if (utils.approximately(d22, 0)) return [];
    const trm = v22 * v22 - 4 * v1 * v3;
    if (trm < 0) return [];
    const sq = Math.sqrt(trm);
    return [(sq - v22) / d22, -(v22 + sq) / d22].filter(function(r5) {
      return 0 <= r5 && r5 <= 1;
    });
  },
  bboxoverlap: function(b1, b22) {
    const dims = ["x", "y"], len = dims.length;
    for (let i4 = 0, dim, l3, t$1, d3; i4 < len; i4++) {
      dim = dims[i4];
      l3 = b1[dim].mid;
      t$1 = b22[dim].mid;
      d3 = (b1[dim].size + b22[dim].size) / 2;
      if (abs$1(l3 - t$1) >= d3) return false;
    }
    return true;
  },
  expandbox: function(bbox3, _bbox) {
    if (_bbox.x.min < bbox3.x.min) bbox3.x.min = _bbox.x.min;
    if (_bbox.y.min < bbox3.y.min) bbox3.y.min = _bbox.y.min;
    if (_bbox.z && _bbox.z.min < bbox3.z.min) bbox3.z.min = _bbox.z.min;
    if (_bbox.x.max > bbox3.x.max) bbox3.x.max = _bbox.x.max;
    if (_bbox.y.max > bbox3.y.max) bbox3.y.max = _bbox.y.max;
    if (_bbox.z && _bbox.z.max > bbox3.z.max) bbox3.z.max = _bbox.z.max;
    bbox3.x.mid = (bbox3.x.min + bbox3.x.max) / 2;
    bbox3.y.mid = (bbox3.y.min + bbox3.y.max) / 2;
    if (bbox3.z) bbox3.z.mid = (bbox3.z.min + bbox3.z.max) / 2;
    bbox3.x.size = bbox3.x.max - bbox3.x.min;
    bbox3.y.size = bbox3.y.max - bbox3.y.min;
    if (bbox3.z) bbox3.z.size = bbox3.z.max - bbox3.z.min;
  },
  pairiteration: function(c1, c22, curveIntersectionThreshold) {
    const c1b = c1.bbox(), c2b = c22.bbox(), r5 = 1e5, threshold = curveIntersectionThreshold || 0.5;
    if (c1b.x.size + c1b.y.size < threshold && c2b.x.size + c2b.y.size < threshold) return [(r5 * (c1._t1 + c1._t2) / 2 | 0) / r5 + "/" + (r5 * (c22._t1 + c22._t2) / 2 | 0) / r5];
    let cc1 = c1.split(0.5), cc2 = c22.split(0.5), pairs = [
      {
        left: cc1.left,
        right: cc2.left
      },
      {
        left: cc1.left,
        right: cc2.right
      },
      {
        left: cc1.right,
        right: cc2.right
      },
      {
        left: cc1.right,
        right: cc2.left
      }
    ];
    pairs = pairs.filter(function(pair) {
      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());
    });
    let results = [];
    if (pairs.length === 0) return results;
    pairs.forEach(function(pair) {
      results = results.concat(utils.pairiteration(pair.left, pair.right, threshold));
    });
    results = results.filter(function(v3, i4) {
      return results.indexOf(v3) === i4;
    });
    return results;
  },
  getccenter: function(p1, p22, p3) {
    const dx1 = p22.x - p1.x, dy1 = p22.y - p1.y, dx2 = p3.x - p22.x, dy2 = p3.y - p22.y, dx1p = dx1 * cos$1(quart) - dy1 * sin$1(quart), dy1p = dx1 * sin$1(quart) + dy1 * cos$1(quart), dx2p = dx2 * cos$1(quart) - dy2 * sin$1(quart), dy2p = dx2 * sin$1(quart) + dy2 * cos$1(quart), mx1 = (p1.x + p22.x) / 2, my1 = (p1.y + p22.y) / 2, mx2 = (p22.x + p3.x) / 2, my2 = (p22.y + p3.y) / 2, mx1n = mx1 + dx1p, my1n = my1 + dy1p, mx2n = mx2 + dx2p, my2n = my2 + dy2p, arc3 = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n), r5 = utils.dist(arc3, p1);
    let s3 = atan2(p1.y - arc3.y, p1.x - arc3.x), m4 = atan2(p22.y - arc3.y, p22.x - arc3.x), e5 = atan2(p3.y - arc3.y, p3.x - arc3.x), _3;
    if (s3 < e5) {
      if (s3 > m4 || m4 > e5) s3 += tau;
      if (s3 > e5) {
        _3 = e5;
        e5 = s3;
        s3 = _3;
      }
    } else if (e5 < m4 && m4 < s3) {
      _3 = e5;
      e5 = s3;
      s3 = _3;
    } else e5 += tau;
    arc3.s = s3;
    arc3.e = e5;
    arc3.r = r5;
    return arc3;
  },
  numberSort: function(a3, b3) {
    return a3 - b3;
  }
};
var PolyBezier = class PolyBezier2 {
  constructor(curves) {
    this.curves = [];
    this._3d = false;
    if (!!curves) {
      this.curves = curves;
      this._3d = this.curves[0]._3d;
    }
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(curve) {
      return utils.pointsToString(curve.points);
    }).join(", ") + "]";
  }
  addCurve(curve) {
    this.curves.push(curve);
    this._3d = this._3d || curve._3d;
  }
  length() {
    return this.curves.map(function(v3) {
      return v3.length();
    }).reduce(function(a3, b3) {
      return a3 + b3;
    });
  }
  curve(idx) {
    return this.curves[idx];
  }
  bbox() {
    const c5 = this.curves;
    var bbox3 = c5[0].bbox();
    for (var i4 = 1; i4 < c5.length; i4++) utils.expandbox(bbox3, c5[i4].bbox());
    return bbox3;
  }
  offset(d3) {
    const offset3 = [];
    this.curves.forEach(function(v3) {
      offset3.push(...v3.offset(d3));
    });
    return new PolyBezier2(offset3);
  }
};
var { abs, min: min3, max: max3, cos, sin, acos, sqrt } = Math;
var pi2 = Math.PI;
var Bezier = class Bezier2 {
  constructor(coords) {
    let args = coords && coords.forEach ? coords : Array.from(arguments).slice();
    let coordlen = false;
    if (typeof args[0] === "object") {
      coordlen = args.length;
      const newargs = [];
      args.forEach(function(point$1) {
        [
          "x",
          "y",
          "z"
        ].forEach(function(d3) {
          if (typeof point$1[d3] !== "undefined") newargs.push(point$1[d3]);
        });
      });
      args = newargs;
    }
    let higher = false;
    const len = args.length;
    if (coordlen) {
      if (coordlen > 4) {
        if (arguments.length !== 1) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        higher = true;
      }
    } else if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {
      if (arguments.length !== 1) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
    }
    const _3d = this._3d = !higher && (len === 9 || len === 12) || coords && coords[0] && typeof coords[0].z !== "undefined";
    const points = this.points = [];
    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {
      var point3 = {
        x: args[idx],
        y: args[idx + 1]
      };
      if (_3d) point3.z = args[idx + 2];
      points.push(point3);
    }
    const order = this.order = points.length - 1;
    const dims = this.dims = ["x", "y"];
    if (_3d) dims.push("z");
    this.dimlen = dims.length;
    const aligned = utils.align(points, {
      p1: points[0],
      p2: points[order]
    });
    const baselength = utils.dist(points[0], points[order]);
    this._linear = aligned.reduce((t$1, p3) => t$1 + abs(p3.y), 0) < baselength / 50;
    this._lut = [];
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  }
  static quadraticFromPoints(p1, p22, p3, t$1) {
    if (typeof t$1 === "undefined") t$1 = 0.5;
    if (t$1 === 0) return new Bezier2(p22, p22, p3);
    if (t$1 === 1) return new Bezier2(p1, p22, p22);
    const abc = Bezier2.getABC(2, p1, p22, p3, t$1);
    return new Bezier2(p1, abc.A, p3);
  }
  static cubicFromPoints(S4, B3, E3, t$1, d1) {
    if (typeof t$1 === "undefined") t$1 = 0.5;
    const abc = Bezier2.getABC(3, S4, B3, E3, t$1);
    if (typeof d1 === "undefined") d1 = utils.dist(B3, abc.C);
    const d22 = d1 * (1 - t$1) / t$1;
    const selen = utils.dist(S4, E3), lx = (E3.x - S4.x) / selen, ly = (E3.y - S4.y) / selen, bx1 = d1 * lx, by1 = d1 * ly, bx2 = d22 * lx, by2 = d22 * ly;
    const e1 = {
      x: B3.x - bx1,
      y: B3.y - by1
    }, e22 = {
      x: B3.x + bx2,
      y: B3.y + by2
    }, A2 = abc.A, v1 = {
      x: A2.x + (e1.x - A2.x) / (1 - t$1),
      y: A2.y + (e1.y - A2.y) / (1 - t$1)
    }, v22 = {
      x: A2.x + (e22.x - A2.x) / t$1,
      y: A2.y + (e22.y - A2.y) / t$1
    }, nc1 = {
      x: S4.x + (v1.x - S4.x) / t$1,
      y: S4.y + (v1.y - S4.y) / t$1
    }, nc2 = {
      x: E3.x + (v22.x - E3.x) / (1 - t$1),
      y: E3.y + (v22.y - E3.y) / (1 - t$1)
    };
    return new Bezier2(S4, nc1, nc2, E3);
  }
  static getUtils() {
    return utils;
  }
  getUtils() {
    return Bezier2.getUtils();
  }
  static get PolyBezier() {
    return PolyBezier;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return utils.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return false;
    const p3 = this.points, x3 = p3[0].x, y3 = p3[0].y, s3 = [
      "M",
      x3,
      y3,
      this.order === 2 ? "Q" : "C"
    ];
    for (let i4 = 1, last2 = p3.length; i4 < last2; i4++) {
      s3.push(p3[i4].x);
      s3.push(p3[i4].y);
    }
    return s3.join(" ");
  }
  setRatios(ratios) {
    if (ratios.length !== this.points.length) throw new Error("incorrect number of ratio values");
    this.ratios = ratios;
    this._lut = [];
  }
  verify() {
    const print = this.coordDigest();
    if (print !== this._print) {
      this._print = print;
      this.update();
    }
  }
  coordDigest() {
    return this.points.map(function(c5, pos) {
      return "" + pos + c5.x + c5.y + (c5.z ? c5.z : 0);
    }).join("");
  }
  update() {
    this._lut = [];
    this.dpoints = utils.derive(this.points, this._3d);
    this.computedirection();
  }
  computedirection() {
    const points = this.points;
    const angle = utils.angle(points[0], points[this.order], points[1]);
    this.clockwise = angle > 0;
  }
  length() {
    return utils.length(this.derivative.bind(this));
  }
  static getABC(order = 2, S4, B3, E3, t$1 = 0.5) {
    const u3 = utils.projectionratio(t$1, order), um = 1 - u3, C2 = {
      x: u3 * S4.x + um * E3.x,
      y: u3 * S4.y + um * E3.y
    }, s3 = utils.abcratio(t$1, order), A2 = {
      x: B3.x + (B3.x - C2.x) / s3,
      y: B3.y + (B3.y - C2.y) / s3
    };
    return {
      A: A2,
      B: B3,
      C: C2,
      S: S4,
      E: E3
    };
  }
  getABC(t$1, B3) {
    B3 = B3 || this.get(t$1);
    let S4 = this.points[0];
    let E3 = this.points[this.order];
    return Bezier2.getABC(this.order, S4, B3, E3, t$1);
  }
  getLUT(steps) {
    this.verify();
    steps = steps || 100;
    if (this._lut.length === steps + 1) return this._lut;
    this._lut = [];
    steps++;
    this._lut = [];
    for (let i4 = 0, p3, t$1; i4 < steps; i4++) {
      t$1 = i4 / (steps - 1);
      p3 = this.compute(t$1);
      p3.t = t$1;
      this._lut.push(p3);
    }
    return this._lut;
  }
  on(point3, error) {
    error = error || 5;
    const lut = this.getLUT(), hits = [];
    for (let i4 = 0, c5, t$1 = 0; i4 < lut.length; i4++) {
      c5 = lut[i4];
      if (utils.dist(c5, point3) < error) {
        hits.push(c5);
        t$1 += i4 / lut.length;
      }
    }
    if (!hits.length) return false;
    return t /= hits.length;
  }
  project(point3) {
    const LUT = this.getLUT(), l3 = LUT.length - 1, closest = utils.closest(LUT, point3), mpos = closest.mpos, t1 = (mpos - 1) / l3, t22 = (mpos + 1) / l3, step = 0.1 / l3;
    let mdist = closest.mdist, t$1 = t1, ft2 = t$1, p3;
    mdist += 1;
    for (let d3; t$1 < t22 + step; t$1 += step) {
      p3 = this.compute(t$1);
      d3 = utils.dist(point3, p3);
      if (d3 < mdist) {
        mdist = d3;
        ft2 = t$1;
      }
    }
    ft2 = ft2 < 0 ? 0 : ft2 > 1 ? 1 : ft2;
    p3 = this.compute(ft2);
    p3.t = ft2;
    p3.d = mdist;
    return p3;
  }
  get(t$1) {
    return this.compute(t$1);
  }
  point(idx) {
    return this.points[idx];
  }
  compute(t$1) {
    if (this.ratios) return utils.computeWithRatios(t$1, this.points, this.ratios, this._3d);
    return utils.compute(t$1, this.points, this._3d, this.ratios);
  }
  raise() {
    const p3 = this.points, np = [p3[0]], k3 = p3.length;
    for (let i4 = 1, pi$2, pim; i4 < k3; i4++) {
      pi$2 = p3[i4];
      pim = p3[i4 - 1];
      np[i4] = {
        x: (k3 - i4) / k3 * pi$2.x + i4 / k3 * pim.x,
        y: (k3 - i4) / k3 * pi$2.y + i4 / k3 * pim.y
      };
    }
    np[k3] = p3[k3 - 1];
    return new Bezier2(np);
  }
  derivative(t$1) {
    return utils.compute(t$1, this.dpoints[0], this._3d);
  }
  dderivative(t$1) {
    return utils.compute(t$1, this.dpoints[1], this._3d);
  }
  align() {
    let p3 = this.points;
    return new Bezier2(utils.align(p3, {
      p1: p3[0],
      p2: p3[p3.length - 1]
    }));
  }
  curvature(t$1) {
    return utils.curvature(t$1, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return utils.inflections(this.points);
  }
  normal(t$1) {
    return this._3d ? this.__normal3(t$1) : this.__normal2(t$1);
  }
  __normal2(t$1) {
    const d3 = this.derivative(t$1);
    const q3 = sqrt(d3.x * d3.x + d3.y * d3.y);
    return {
      t: t$1,
      x: -d3.y / q3,
      y: d3.x / q3
    };
  }
  __normal3(t$1) {
    const r1 = this.derivative(t$1), r22 = this.derivative(t$1 + 0.01), q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z), q22 = sqrt(r22.x * r22.x + r22.y * r22.y + r22.z * r22.z);
    r1.x /= q1;
    r1.y /= q1;
    r1.z /= q1;
    r22.x /= q22;
    r22.y /= q22;
    r22.z /= q22;
    const c5 = {
      x: r22.y * r1.z - r22.z * r1.y,
      y: r22.z * r1.x - r22.x * r1.z,
      z: r22.x * r1.y - r22.y * r1.x
    };
    const m4 = sqrt(c5.x * c5.x + c5.y * c5.y + c5.z * c5.z);
    c5.x /= m4;
    c5.y /= m4;
    c5.z /= m4;
    const R3 = [
      c5.x * c5.x,
      c5.x * c5.y - c5.z,
      c5.x * c5.z + c5.y,
      c5.x * c5.y + c5.z,
      c5.y * c5.y,
      c5.y * c5.z - c5.x,
      c5.x * c5.z - c5.y,
      c5.y * c5.z + c5.x,
      c5.z * c5.z
    ];
    const n6 = {
      t: t$1,
      x: R3[0] * r1.x + R3[1] * r1.y + R3[2] * r1.z,
      y: R3[3] * r1.x + R3[4] * r1.y + R3[5] * r1.z,
      z: R3[6] * r1.x + R3[7] * r1.y + R3[8] * r1.z
    };
    return n6;
  }
  hull(t$1) {
    let p3 = this.points, _p = [], q3 = [], idx = 0;
    q3[idx++] = p3[0];
    q3[idx++] = p3[1];
    q3[idx++] = p3[2];
    if (this.order === 3) q3[idx++] = p3[3];
    while (p3.length > 1) {
      _p = [];
      for (let i4 = 0, pt2, l3 = p3.length - 1; i4 < l3; i4++) {
        pt2 = utils.lerp(t$1, p3[i4], p3[i4 + 1]);
        q3[idx++] = pt2;
        _p.push(pt2);
      }
      p3 = _p;
    }
    return q3;
  }
  split(t1, t22) {
    if (t1 === 0 && !!t22) return this.split(t22).left;
    if (t22 === 1) return this.split(t1).right;
    const q3 = this.hull(t1);
    const result = {
      left: this.order === 2 ? new Bezier2([
        q3[0],
        q3[3],
        q3[5]
      ]) : new Bezier2([
        q3[0],
        q3[4],
        q3[7],
        q3[9]
      ]),
      right: this.order === 2 ? new Bezier2([
        q3[5],
        q3[4],
        q3[2]
      ]) : new Bezier2([
        q3[9],
        q3[8],
        q3[6],
        q3[3]
      ]),
      span: q3
    };
    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);
    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);
    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);
    if (!t22) return result;
    t22 = utils.map(t22, t1, 1, 0, 1);
    return result.right.split(t22).left;
  }
  extrema() {
    const result = {};
    let roots = [];
    this.dims.forEach(function(dim) {
      let mfn = function(v3) {
        return v3[dim];
      };
      let p3 = this.dpoints[0].map(mfn);
      result[dim] = utils.droots(p3);
      if (this.order === 3) {
        p3 = this.dpoints[1].map(mfn);
        result[dim] = result[dim].concat(utils.droots(p3));
      }
      result[dim] = result[dim].filter(function(t$1) {
        return t$1 >= 0 && t$1 <= 1;
      });
      roots = roots.concat(result[dim].sort(utils.numberSort));
    }.bind(this));
    result.values = roots.sort(utils.numberSort).filter(function(v3, idx) {
      return roots.indexOf(v3) === idx;
    });
    return result;
  }
  bbox() {
    const extrema = this.extrema(), result = {};
    this.dims.forEach(function(d3) {
      result[d3] = utils.getminmax(this, d3, extrema[d3]);
    }.bind(this));
    return result;
  }
  overlaps(curve) {
    const lbbox = this.bbox(), tbbox = curve.bbox();
    return utils.bboxoverlap(lbbox, tbbox);
  }
  offset(t$1, d3) {
    if (typeof d3 !== "undefined") {
      const c5 = this.get(t$1), n6 = this.normal(t$1);
      const ret = {
        c: c5,
        n: n6,
        x: c5.x + n6.x * d3,
        y: c5.y + n6.y * d3
      };
      if (this._3d) ret.z = c5.z + n6.z * d3;
      return ret;
    }
    if (this._linear) {
      const nv = this.normal(0), coords = this.points.map(function(p3) {
        const ret = {
          x: p3.x + t$1 * nv.x,
          y: p3.y + t$1 * nv.y
        };
        if (p3.z && nv.z) ret.z = p3.z + t$1 * nv.z;
        return ret;
      });
      return [new Bezier2(coords)];
    }
    return this.reduce().map(function(s3) {
      if (s3._linear) return s3.offset(t$1)[0];
      return s3.scale(t$1);
    });
  }
  simple() {
    if (this.order === 3) {
      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);
      const a22 = utils.angle(this.points[0], this.points[3], this.points[2]);
      if (a1 > 0 && a22 < 0 || a1 < 0 && a22 > 0) return false;
    }
    const n1 = this.normal(0);
    const n22 = this.normal(1);
    let s3 = n1.x * n22.x + n1.y * n22.y;
    if (this._3d) s3 += n1.z * n22.z;
    return abs(acos(s3)) < pi2 / 3;
  }
  reduce() {
    let i4, t1 = 0, t22 = 0, step = 0.01, segment, pass1 = [], pass2 = [];
    let extrema = this.extrema().values;
    if (extrema.indexOf(0) === -1) extrema = [0].concat(extrema);
    if (extrema.indexOf(1) === -1) extrema.push(1);
    for (t1 = extrema[0], i4 = 1; i4 < extrema.length; i4++) {
      t22 = extrema[i4];
      segment = this.split(t1, t22);
      segment._t1 = t1;
      segment._t2 = t22;
      pass1.push(segment);
      t1 = t22;
    }
    pass1.forEach(function(p1) {
      t1 = 0;
      t22 = 0;
      while (t22 <= 1) for (t22 = t1 + step; t22 <= 1 + step; t22 += step) {
        segment = p1.split(t1, t22);
        if (!segment.simple()) {
          t22 -= step;
          if (abs(t1 - t22) < step) return [];
          segment = p1.split(t1, t22);
          segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
          segment._t2 = utils.map(t22, 0, 1, p1._t1, p1._t2);
          pass2.push(segment);
          t1 = t22;
          break;
        }
      }
      if (t1 < 1) {
        segment = p1.split(t1, 1);
        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);
        segment._t2 = p1._t2;
        pass2.push(segment);
      }
    });
    return pass2;
  }
  translate(v3, d1, d22) {
    d22 = typeof d22 === "number" ? d22 : d1;
    const o5 = this.order;
    let d3 = this.points.map((_3, i4) => (1 - i4 / o5) * d1 + i4 / o5 * d22);
    return new Bezier2(this.points.map((p3, i4) => ({
      x: p3.x + v3.x * d3[i4],
      y: p3.y + v3.y * d3[i4]
    })));
  }
  scale(d3) {
    const order = this.order;
    let distanceFn = false;
    if (typeof d3 === "function") distanceFn = d3;
    if (distanceFn && order === 2) return this.raise().scale(distanceFn);
    const clockwise = this.clockwise;
    const points = this.points;
    if (this._linear) return this.translate(this.normal(0), distanceFn ? distanceFn(0) : d3, distanceFn ? distanceFn(1) : d3);
    const r1 = distanceFn ? distanceFn(0) : d3;
    const r22 = distanceFn ? distanceFn(1) : d3;
    const v3 = [this.offset(0, 10), this.offset(1, 10)];
    const np = [];
    const o5 = utils.lli4(v3[0], v3[0].c, v3[1], v3[1].c);
    if (!o5) throw new Error("cannot scale this curve. Try reducing it first.");
    [0, 1].forEach(function(t$1) {
      const p3 = np[t$1 * order] = utils.copy(points[t$1 * order]);
      p3.x += (t$1 ? r22 : r1) * v3[t$1].n.x;
      p3.y += (t$1 ? r22 : r1) * v3[t$1].n.y;
    });
    if (!distanceFn) {
      [0, 1].forEach((t$1) => {
        if (order === 2 && !!t$1) return;
        const p3 = np[t$1 * order];
        const d$1 = this.derivative(t$1);
        const p22 = {
          x: p3.x + d$1.x,
          y: p3.y + d$1.y
        };
        np[t$1 + 1] = utils.lli4(p3, p22, o5, points[t$1 + 1]);
      });
      return new Bezier2(np);
    }
    [0, 1].forEach(function(t$1) {
      if (order === 2 && !!t$1) return;
      var p3 = points[t$1 + 1];
      var ov = {
        x: p3.x - o5.x,
        y: p3.y - o5.y
      };
      var rc2 = distanceFn ? distanceFn((t$1 + 1) / order) : d3;
      if (distanceFn && !clockwise) rc2 = -rc2;
      var m4 = sqrt(ov.x * ov.x + ov.y * ov.y);
      ov.x /= m4;
      ov.y /= m4;
      np[t$1 + 1] = {
        x: p3.x + rc2 * ov.x,
        y: p3.y + rc2 * ov.y
      };
    });
    return new Bezier2(np);
  }
  outline(d1, d22, d3, d4) {
    d22 = d22 === void 0 ? d1 : d22;
    if (this._linear) {
      const n6 = this.normal(0);
      const start = this.points[0];
      const end = this.points[this.points.length - 1];
      let s3, mid, e5;
      if (d3 === void 0) {
        d3 = d1;
        d4 = d22;
      }
      s3 = {
        x: start.x + n6.x * d1,
        y: start.y + n6.y * d1
      };
      e5 = {
        x: end.x + n6.x * d3,
        y: end.y + n6.y * d3
      };
      mid = {
        x: (s3.x + e5.x) / 2,
        y: (s3.y + e5.y) / 2
      };
      const fline = [
        s3,
        mid,
        e5
      ];
      s3 = {
        x: start.x - n6.x * d22,
        y: start.y - n6.y * d22
      };
      e5 = {
        x: end.x - n6.x * d4,
        y: end.y - n6.y * d4
      };
      mid = {
        x: (s3.x + e5.x) / 2,
        y: (s3.y + e5.y) / 2
      };
      const bline = [
        e5,
        mid,
        s3
      ];
      const ls$1 = utils.makeline(bline[2], fline[0]);
      const le$1 = utils.makeline(fline[2], bline[0]);
      const segments$1 = [
        ls$1,
        new Bezier2(fline),
        le$1,
        new Bezier2(bline)
      ];
      return new PolyBezier(segments$1);
    }
    const reduced = this.reduce(), len = reduced.length, fcurves = [];
    let bcurves = [], p3, alen = 0, tlen = this.length();
    const graduated = typeof d3 !== "undefined" && typeof d4 !== "undefined";
    function linearDistanceFunction(s3, e5, tlen$1, alen$1, slen) {
      return function(v3) {
        const f1 = alen$1 / tlen$1, f22 = (alen$1 + slen) / tlen$1, d5 = e5 - s3;
        return utils.map(v3, 0, 1, s3 + f1 * d5, s3 + f22 * d5);
      };
    }
    reduced.forEach(function(segment) {
      const slen = segment.length();
      if (graduated) {
        fcurves.push(segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen)));
        bcurves.push(segment.scale(linearDistanceFunction(-d22, -d4, tlen, alen, slen)));
      } else {
        fcurves.push(segment.scale(d1));
        bcurves.push(segment.scale(-d22));
      }
      alen += slen;
    });
    bcurves = bcurves.map(function(s3) {
      p3 = s3.points;
      if (p3[3]) s3.points = [
        p3[3],
        p3[2],
        p3[1],
        p3[0]
      ];
      else s3.points = [
        p3[2],
        p3[1],
        p3[0]
      ];
      return s3;
    }).reverse();
    const fs2 = fcurves[0].points[0], fe2 = fcurves[len - 1].points[fcurves[len - 1].points.length - 1], bs2 = bcurves[len - 1].points[bcurves[len - 1].points.length - 1], be2 = bcurves[0].points[0], ls2 = utils.makeline(bs2, fs2), le2 = utils.makeline(fe2, be2), segments = [ls2].concat(fcurves).concat([le2]).concat(bcurves);
    return new PolyBezier(segments);
  }
  outlineshapes(d1, d22, curveIntersectionThreshold) {
    d22 = d22 || d1;
    const outline = this.outline(d1, d22).curves;
    const shapes = [];
    for (let i4 = 1, len = outline.length; i4 < len / 2; i4++) {
      const shape = utils.makeshape(outline[i4], outline[len - i4], curveIntersectionThreshold);
      shape.startcap.virtual = i4 > 1;
      shape.endcap.virtual = i4 < len / 2 - 1;
      shapes.push(shape);
    }
    return shapes;
  }
  intersects(curve, curveIntersectionThreshold) {
    if (!curve) return this.selfintersects(curveIntersectionThreshold);
    if (curve.p1 && curve.p2) return this.lineIntersects(curve);
    if (curve instanceof Bezier2) curve = curve.reduce();
    return this.curveintersects(this.reduce(), curve, curveIntersectionThreshold);
  }
  lineIntersects(line3) {
    const mx = min3(line3.p1.x, line3.p2.x), my = min3(line3.p1.y, line3.p2.y), MX = max3(line3.p1.x, line3.p2.x), MY = max3(line3.p1.y, line3.p2.y);
    return utils.roots(this.points, line3).filter((t$1) => {
      var p3 = this.get(t$1);
      return utils.between(p3.x, mx, MX) && utils.between(p3.y, my, MY);
    });
  }
  selfintersects(curveIntersectionThreshold) {
    const reduced = this.reduce(), len = reduced.length - 2, results = [];
    for (let i4 = 0, result, left, right; i4 < len; i4++) {
      left = reduced.slice(i4, i4 + 1);
      right = reduced.slice(i4 + 2);
      result = this.curveintersects(left, right, curveIntersectionThreshold);
      results.push(...result);
    }
    return results;
  }
  curveintersects(c1, c22, curveIntersectionThreshold) {
    const pairs = [];
    c1.forEach(function(l3) {
      c22.forEach(function(r5) {
        if (l3.overlaps(r5)) pairs.push({
          left: l3,
          right: r5
        });
      });
    });
    let intersections3 = [];
    pairs.forEach(function(pair) {
      const result = utils.pairiteration(pair.left, pair.right, curveIntersectionThreshold);
      if (result.length > 0) intersections3 = intersections3.concat(result);
    });
    return intersections3;
  }
  arcs(errorThreshold) {
    errorThreshold = errorThreshold || 0.5;
    return this._iterate(errorThreshold, []);
  }
  _error(pc, np1, s3, e5) {
    const q3 = (e5 - s3) / 4, c1 = this.get(s3 + q3), c22 = this.get(e5 - q3), ref = utils.dist(pc, np1), d1 = utils.dist(pc, c1), d22 = utils.dist(pc, c22);
    return abs(d1 - ref) + abs(d22 - ref);
  }
  _iterate(errorThreshold, circles) {
    let t_s = 0, t_e = 1, safety;
    do {
      safety = 0;
      t_e = 1;
      let np1 = this.get(t_s), np2, np3, arc3, prev_arc;
      let curr_good = false, prev_good = false, done;
      let t_m = t_e, prev_e = 1, step = 0;
      do {
        prev_good = curr_good;
        prev_arc = arc3;
        t_m = (t_s + t_e) / 2;
        step++;
        np2 = this.get(t_m);
        np3 = this.get(t_e);
        arc3 = utils.getccenter(np1, np2, np3);
        arc3.interval = {
          start: t_s,
          end: t_e
        };
        let error = this._error(arc3, np1, t_s, t_e);
        curr_good = error <= errorThreshold;
        done = prev_good && !curr_good;
        if (!done) prev_e = t_e;
        if (curr_good) {
          if (t_e >= 1) {
            arc3.interval.end = prev_e = 1;
            prev_arc = arc3;
            if (t_e > 1) {
              let d3 = {
                x: arc3.x + arc3.r * cos(arc3.e),
                y: arc3.y + arc3.r * sin(arc3.e)
              };
              arc3.e += utils.angle({
                x: arc3.x,
                y: arc3.y
              }, d3, this.get(1));
            }
            break;
          }
          t_e = t_e + (t_e - t_s) / 2;
        } else t_e = t_m;
      } while (!done && safety++ < 100);
      if (safety >= 100) break;
      prev_arc = prev_arc ? prev_arc : arc3;
      circles.push(prev_arc);
      t_s = prev_e;
    } while (t_e < 1);
    return circles;
  }
};

// node_modules/ixfx/bundle/src-DQ65dkP-.js
var isNull = (p3) => {
  if (isPoint3d(p3)) {
    if (p3.z !== null) return false;
  }
  return p3.x === null && p3.y === null;
};
var isNaN$1 = (p3) => {
  if (isPoint3d(p3)) {
    if (!Number.isNaN(p3.z)) return false;
  }
  return Number.isNaN(p3.x) || Number.isNaN(p3.y);
};
function test(p3, name = `Point`, extraInfo = ``) {
  if (p3 === void 0) return errorResult(`'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (p3 === null) return errorResult(`'${name}' is null. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (typeof p3 !== `object`) return errorResult(`'${name}' is type '${typeof p3}'. Expected object.`, extraInfo);
  if (p3.x === void 0) return errorResult(`'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (p3.y === void 0) return errorResult(`'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (typeof p3.x !== `number`) return errorResult(`'${name}.x' must be a number. Got ${typeof p3.x}`, extraInfo);
  if (typeof p3.y !== `number`) return errorResult(`'${name}.y' must be a number. Got ${typeof p3.y}`, extraInfo);
  if (p3.z !== void 0) {
    if (typeof p3.z !== `number`) return errorResult(`${name}.z must be a number. Got: ${typeof p3.z}`, extraInfo);
    if (Number.isNaN(p3.z)) return errorResult(`'${name}.z' is NaN. Got: ${JSON.stringify(p3)}`, extraInfo);
  }
  if (p3.x === null) return errorResult(`'${name}.x' is null`, extraInfo);
  if (p3.y === null) return errorResult(`'${name}.y' is null`, extraInfo);
  if (Number.isNaN(p3.x)) return errorResult(`'${name}.x' is NaN`, extraInfo);
  if (Number.isNaN(p3.y)) return errorResult(`'${name}.y' is NaN`, extraInfo);
  return {
    success: true,
    value: p3
  };
}
function guard$1(p3, name = `Point`, info) {
  resultThrow(test(p3, name, info));
}
var guardNonZeroPoint = (pt2, name = `pt`) => {
  guard$1(pt2, name);
  resultThrow(numberTest(pt2.x, `nonZero`, `${name}.x`), numberTest(pt2.y, `nonZero`, `${name}.y`), () => {
    if (typeof pt2.z !== `undefined`) return numberTest(pt2.z, `nonZero`, `${name}.z`);
  });
  return true;
};
function isPoint(p3) {
  if (p3 === void 0) return false;
  if (p3 === null) return false;
  if (p3.x === void 0) return false;
  if (p3.y === void 0) return false;
  return true;
}
var isPoint3d = (p3) => {
  if (p3 === void 0) return false;
  if (p3 === null) return false;
  if (p3.x === void 0) return false;
  if (p3.y === void 0) return false;
  if (p3.z === void 0) return false;
  return true;
};
var isEmpty3 = (p3) => {
  if (isPoint3d(p3)) {
    if (p3.z !== 0) return false;
  }
  return p3.x === 0 && p3.y === 0;
};
var isPlaceholder = (p3) => {
  if (isPoint3d(p3)) {
    if (!Number.isNaN(p3.z)) return false;
  }
  return Number.isNaN(p3.x) && Number.isNaN(p3.y);
};
var guardDim = (d3, name = `Dimension`) => {
  if (d3 === void 0) throw new Error(`${name} is undefined`);
  if (Number.isNaN(d3)) throw new Error(`${name} is NaN`);
  if (d3 < 0) throw new Error(`${name} cannot be negative`);
};
var guard$6 = (rect3, name = `rect`) => {
  if (rect3 === void 0) throw new Error(`{$name} undefined`);
  if (isPositioned$1(rect3)) guard$1(rect3, name);
  guardDim(rect3.width, name + `.width`);
  guardDim(rect3.height, name + `.height`);
};
var getRectPositioned = (rect3, origin) => {
  guard$6(rect3);
  if (isPositioned$1(rect3) && origin === void 0) return rect3;
  if (origin === void 0) throw new Error(`Unpositioned rect needs origin parameter`);
  return Object.freeze({
    ...rect3,
    ...origin
  });
};
var guardPositioned$1 = (rect3, name = `rect`) => {
  if (!isPositioned$1(rect3)) throw new Error(`Expected ${name} to have x,y`);
  guard$6(rect3, name);
};
var isEmpty$3 = (rect3) => rect3.width === 0 && rect3.height === 0;
var isPlaceholder$3 = (rect3) => Number.isNaN(rect3.width) && Number.isNaN(rect3.height);
var isPositioned$1 = (rect3) => rect3.x !== void 0 && rect3.y !== void 0;
var isRect = (rect3) => {
  if (rect3 === void 0) return false;
  if (rect3.width === void 0) return false;
  if (rect3.height === void 0) return false;
  return true;
};
var isRectPositioned = (rect3) => isRect(rect3) && isPositioned$1(rect3);
var area$5 = (rect3) => {
  guard$6(rect3);
  return rect3.height * rect3.width;
};
function applyFields(op, rectOrWidth, heightValue) {
  let width = typeof rectOrWidth === `number` ? rectOrWidth : rectOrWidth.width;
  let height$3 = typeof rectOrWidth === `number` ? heightValue : rectOrWidth.height;
  if (width === void 0) throw new Error(`Param 'width' undefined`);
  if (height$3 === void 0) throw new Error(`Param 'height' undefined`);
  width = op(width, `width`);
  height$3 = op(height$3, `height`);
  if (typeof rectOrWidth === `object`) if (isPositioned$1(rectOrWidth)) {
    const x3 = op(rectOrWidth.x, `x`);
    const y3 = op(rectOrWidth.y, `y`);
    return {
      ...rectOrWidth,
      width,
      height: height$3,
      x: x3,
      y: y3
    };
  } else return {
    ...rectOrWidth,
    width,
    height: height$3
  };
  return {
    width,
    height: height$3
  };
}
function applyMerge(op, a3, b3, c5) {
  guard$6(a3, `a`);
  if (isRect(b3)) return isRectPositioned(a3) ? Object.freeze({
    ...a3,
    x: op(a3.x, b3.width),
    y: op(a3.y, b3.height),
    width: op(a3.width, b3.width),
    height: op(a3.height, b3.height)
  }) : Object.freeze({
    ...a3,
    width: op(a3.width, b3.width),
    height: op(a3.height, b3.height)
  });
  else {
    if (typeof b3 !== `number`) throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(b3)}`);
    if (typeof c5 !== `number`) throw new Error(`Expected third param as height. Got ${JSON.stringify(c5)}`);
    return isRectPositioned(a3) ? Object.freeze({
      ...a3,
      x: op(a3.x, b3),
      y: op(a3.y, c5),
      width: op(a3.width, b3),
      height: op(a3.height, c5)
    }) : Object.freeze({
      ...a3,
      width: op(a3.width, b3),
      height: op(a3.height, c5)
    });
  }
}
function applyScalar(op, rect3, parameter) {
  return isPositioned$1(rect3) ? Object.freeze({
    ...rect3,
    x: op(rect3.x, parameter),
    y: op(rect3.y, parameter),
    width: op(rect3.width, parameter),
    height: op(rect3.height, parameter)
  }) : Object.freeze({
    ...rect3,
    width: op(rect3.width, parameter),
    height: op(rect3.height, parameter)
  });
}
function applyDim(op, rect3, parameter) {
  return Object.freeze({
    ...rect3,
    width: op(rect3.width, parameter),
    height: op(rect3.height, parameter)
  });
}
var cardinal = (rect3, card) => {
  const { x: x3, y: y3, width, height: height$3 } = rect3;
  switch (card) {
    case `nw`:
      return Object.freeze({
        x: x3,
        y: y3
      });
    case `n`:
      return Object.freeze({
        x: x3 + width / 2,
        y: y3
      });
    case `ne`:
      return Object.freeze({
        x: x3 + width,
        y: y3
      });
    case `sw`:
      return Object.freeze({
        x: x3,
        y: y3 + height$3
      });
    case `s`:
      return Object.freeze({
        x: x3 + width / 2,
        y: y3 + height$3
      });
    case `se`:
      return Object.freeze({
        x: x3 + width,
        y: y3 + height$3
      });
    case `w`:
      return Object.freeze({
        x: x3,
        y: y3 + height$3 / 2
      });
    case `e`:
      return Object.freeze({
        x: x3 + width,
        y: y3 + height$3 / 2
      });
    case `center`:
      return Object.freeze({
        x: x3 + width / 2,
        y: y3 + height$3 / 2
      });
    default:
      throw new Error(`Unknown direction: ${card}`);
  }
};
var center$1 = (rect3, origin) => {
  guard$6(rect3);
  if (origin === void 0 && isPoint(rect3)) origin = rect3;
  else if (origin === void 0) origin = {
    x: 0,
    y: 0
  };
  const r5 = getRectPositioned(rect3, origin);
  return Object.freeze({
    x: origin.x + rect3.width / 2,
    y: origin.y + rect3.height / 2
  });
};
var centerOrigin = (rectAbsolute) => {
  const c5 = center$1(rectAbsolute);
  const w3 = rectAbsolute.width / 2;
  const h5 = rectAbsolute.height / 2;
  const relativeToAbsolute = (point$1) => {
    return {
      ...point$1,
      x: point$1.x * w3 + c5.x,
      y: point$1.y * h5 + c5.y
    };
  };
  const absoluteToRelative = (point$1) => {
    return {
      ...point$1,
      x: (point$1.x - rectAbsolute.x) / w3 - 1,
      y: (point$1.y - rectAbsolute.y) / h5 - 1
    };
  };
  return {
    relativeToAbsolute,
    absoluteToRelative
  };
};
var Placeholder$2 = Object.freeze({
  x: NaN,
  y: NaN
});
var Placeholder3d = Object.freeze({
  x: NaN,
  y: NaN,
  z: NaN
});
var corners$1 = (rect3, origin) => {
  const r5 = getRectPositioned(rect3, origin);
  return [
    {
      x: r5.x,
      y: r5.y
    },
    {
      x: r5.x + r5.width,
      y: r5.y
    },
    {
      x: r5.x + r5.width,
      y: r5.y + r5.height
    },
    {
      x: r5.x,
      y: r5.y + r5.height
    }
  ];
};
var guard$2 = (circle3, parameterName = `circle`) => {
  if (isCirclePositioned(circle3)) guard$1(circle3, `circle`);
  if (Number.isNaN(circle3.radius)) throw new Error(`${parameterName}.radius is NaN`);
  if (circle3.radius <= 0) throw new Error(`${parameterName}.radius must be greater than zero`);
};
var guardPositioned = (circle3, parameterName = `circle`) => {
  if (!isCirclePositioned(circle3)) throw new Error(`Expected a positioned circle with x,y`);
  guard$2(circle3, parameterName);
};
var isNaN2 = (a3) => {
  if (Number.isNaN(a3.radius)) return true;
  if (isCirclePositioned(a3)) {
    if (Number.isNaN(a3.x)) return true;
    if (Number.isNaN(a3.y)) return true;
  }
  return false;
};
var isPositioned$2 = (p3) => p3.x !== void 0 && p3.y !== void 0;
var isCircle = (p3) => p3.radius !== void 0;
var isCirclePositioned = (p3) => isCircle(p3) && isPositioned$2(p3);
var isEqual$6 = (a3, b3) => {
  if (a3.radius !== b3.radius) return false;
  if (isCirclePositioned(a3) && isCirclePositioned(b3)) {
    if (a3.x !== b3.x) return false;
    if (a3.y !== b3.y) return false;
    if (a3.z !== b3.z) return false;
    return true;
  } else if (!isCirclePositioned(a3) && !isCirclePositioned(b3)) {
  } else return false;
  return false;
};
function getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6) {
  if (isPoint3d(a1) && isPoint3d(ab2)) return [a1, ab2];
  if (isPoint(a1) && isPoint(ab2)) return [a1, ab2];
  if (isPoint3d(a1)) {
    const b$1 = {
      x: ab2,
      y: ab3,
      z: ab4
    };
    if (!isPoint3d(b$1)) throw new Error(`Expected x, y & z parameters`);
    return [a1, b$1];
  }
  if (isPoint(a1)) {
    const b$1 = {
      x: ab2,
      y: ab3
    };
    if (!isPoint(b$1)) throw new Error(`Expected x & y parameters`);
    return [a1, b$1];
  }
  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {
    const a$1 = {
      x: a1,
      y: ab2,
      z: ab3
    };
    const b$1 = {
      x: ab4,
      y: ab5,
      z: ab6
    };
    if (!isPoint3d(a$1)) throw new Error(`Expected x,y,z for first point`);
    if (!isPoint3d(b$1)) throw new Error(`Expected x,y,z for second point`);
    return [a$1, b$1];
  }
  const a3 = {
    x: a1,
    y: ab2
  };
  const b3 = {
    x: ab3,
    y: ab4
  };
  if (!isPoint(a3)) throw new Error(`Expected x,y for first point`);
  if (!isPoint(b3)) throw new Error(`Expected x,y for second point`);
  return [a3, b3];
}
function getPointParameter(a3, b3, c5) {
  if (a3 === void 0) return {
    x: 0,
    y: 0
  };
  if (Array.isArray(a3)) {
    if (a3.length === 0) return Object.freeze({
      x: 0,
      y: 0
    });
    if (a3.length === 1) return Object.freeze({
      x: a3[0],
      y: 0
    });
    if (a3.length === 2) return Object.freeze({
      x: a3[0],
      y: a3[1]
    });
    if (a3.length === 3) return Object.freeze({
      x: a3[0],
      y: a3[1],
      z: a3[2]
    });
    throw new Error(`Expected array to be 1-3 elements in length. Got ${a3.length}.`);
  }
  if (isPoint(a3)) return a3;
  else if (typeof a3 !== `number` || typeof b3 !== `number`) throw new TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(a3)} b: ${JSON.stringify(b3)}`);
  if (typeof c5 === `number`) return Object.freeze({
    x: a3,
    y: b3,
    z: c5
  });
  return Object.freeze({
    x: a3,
    y: b3
  });
}
function sum2(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);
  guard$1(ptA, `a`);
  guard$1(ptB, `b`);
  const pt2 = {
    x: ptA.x + ptB.x,
    y: ptA.y + ptB.y
  };
  if (isPoint3d(ptA) || isPoint3d(ptB)) pt2.z = (ptA.z ?? 0) + (ptB.z ?? 0);
  return Object.freeze(pt2);
}
function subtract(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);
  guard$1(ptA, `a`);
  guard$1(ptB, `b`);
  const pt2 = {
    x: ptA.x - ptB.x,
    y: ptA.y - ptB.y
  };
  if (isPoint3d(ptA) || isPoint3d(ptB)) pt2.z = (ptA.z ?? 0) - (ptB.z ?? 0);
  return Object.freeze(pt2);
}
var intersectionLine = (circle3, line3) => {
  const v1 = {
    x: line3.b.x - line3.a.x,
    y: line3.b.y - line3.a.y
  };
  const v22 = {
    x: line3.a.x - circle3.x,
    y: line3.a.y - circle3.y
  };
  const b3 = (v1.x * v22.x + v1.y * v22.y) * -2;
  const c5 = 2 * (v1.x * v1.x + v1.y * v1.y);
  const d3 = Math.sqrt(b3 * b3 - 2 * c5 * (v22.x * v22.x + v22.y * v22.y - circle3.radius * circle3.radius));
  if (Number.isNaN(d3)) return [];
  const u1 = (b3 - d3) / c5;
  const u22 = (b3 + d3) / c5;
  const returnValue = [];
  if (u1 <= 1 && u1 >= 0) returnValue.push({
    x: line3.a.x + v1.x * u1,
    y: line3.a.y + v1.y * u1
  });
  if (u22 <= 1 && u22 >= 0) returnValue.push({
    x: line3.a.x + v1.x * u22,
    y: line3.a.y + v1.y * u22
  });
  return returnValue;
};
var intersections = (a3, b3) => {
  const vector = subtract(b3, a3);
  const centerD = Math.hypot(vector.y, vector.x);
  if (centerD > a3.radius + b3.radius) return [];
  if (centerD < Math.abs(a3.radius - b3.radius)) return [];
  if (isEqual$6(a3, b3)) return [];
  const centroidD = (a3.radius * a3.radius - b3.radius * b3.radius + centerD * centerD) / (2 * centerD);
  const centroid$2 = {
    x: a3.x + vector.x * centroidD / centerD,
    y: a3.y + vector.y * centroidD / centerD
  };
  const centroidIntersectionD = Math.sqrt(a3.radius * a3.radius - centroidD * centroidD);
  const intersection2 = {
    x: -vector.y * (centroidIntersectionD / centerD),
    y: vector.x * (centroidIntersectionD / centerD)
  };
  return [sum2(centroid$2, intersection2), subtract(centroid$2, intersection2)];
};
var circleRect = (a3, b3) => {
  const deltaX = a3.x - Math.max(b3.x, Math.min(a3.x, b3.x + b3.width));
  const deltaY = a3.y - Math.max(b3.y, Math.min(a3.y, b3.y + b3.height));
  return deltaX * deltaX + deltaY * deltaY < a3.radius * a3.radius;
};
var circleCircle = (a3, b3) => intersections(a3, b3).length === 2;
function intersectsPoint(rect3, a3, b3) {
  guard$6(rect3, `rect`);
  let x3 = 0;
  let y3 = 0;
  if (typeof a3 === `number`) {
    if (b3 === void 0) throw new Error(`x and y coordinate needed`);
    x3 = a3;
    y3 = b3;
  } else {
    x3 = a3.x;
    y3 = a3.y;
  }
  if (isPositioned$1(rect3)) {
    if (x3 - rect3.x > rect3.width || x3 < rect3.x) return false;
    if (y3 - rect3.y > rect3.height || y3 < rect3.y) return false;
  } else {
    if (x3 > rect3.width || x3 < 0) return false;
    if (y3 > rect3.height || y3 < 0) return false;
  }
  return true;
}
var isIntersecting$1 = (a3, b3) => {
  if (!isRectPositioned(a3)) throw new Error(`a parameter should be RectPositioned`);
  if (isCirclePositioned(b3)) return circleRect(b3, a3);
  else if (isPoint(b3)) return intersectsPoint(a3, b3);
  throw new Error(`Unknown shape for b: ${JSON.stringify(b3)}`);
};
function distance3(a3, xOrB, y3, z3) {
  const pt2 = getPointParameter(xOrB, y3, z3);
  guard$1(pt2, `b`);
  guard$1(a3, `a`);
  return isPoint3d(pt2) && isPoint3d(a3) ? Math.hypot(pt2.x - a3.x, pt2.y - a3.y, pt2.z - a3.z) : Math.hypot(pt2.x - a3.x, pt2.y - a3.y);
}
var distanceFromExterior = (rect3, pt2) => {
  guardPositioned$1(rect3, `rect`);
  guard$1(pt2, `pt`);
  if (intersectsPoint(rect3, pt2)) return 0;
  const dx = Math.max(rect3.x - pt2.x, 0, pt2.x - rect3.x + rect3.width);
  const dy = Math.max(rect3.y - pt2.y, 0, pt2.y - rect3.y + rect3.height);
  return Math.hypot(dx, dy);
};
var distanceFromCenter = (rect3, pt2) => distance3(center$1(rect3), pt2);
var divideOp = (a3, b3) => a3 / b3;
function divide$4(a3, b3, c5) {
  return applyMerge(divideOp, a3, b3, c5);
}
function divideScalar(rect3, amount) {
  return applyScalar(divideOp, rect3, amount);
}
function divideDim(rect3, amount) {
  return applyDim(divideOp, rect3, amount);
}
var fromPoints$2 = (a3, b3) => {
  guard$1(a3, `a`);
  guard$1(b3, `b`);
  a3 = Object.freeze({ ...a3 });
  b3 = Object.freeze({ ...b3 });
  return Object.freeze({
    a: a3,
    b: b3
  });
};
var joinPointsToLines = (...points) => {
  const lines = [];
  let start = points[0];
  for (let index = 1; index < points.length; index++) {
    lines.push(fromPoints$2(start, points[index]));
    start = points[index];
  }
  return lines;
};
var edges$1 = (rect3, origin) => {
  const c5 = corners$1(rect3, origin);
  return joinPointsToLines(...c5, c5[0]);
};
var getEdgeX = (rect3, edge) => {
  guard$6(rect3);
  switch (edge) {
    case `top`:
      return isPoint(rect3) ? rect3.x : 0;
    case `bottom`:
      return isPoint(rect3) ? rect3.x : 0;
    case `left`:
      return isPoint(rect3) ? rect3.y : 0;
    case `right`:
      return isPoint(rect3) ? rect3.x + rect3.width : rect3.width;
  }
};
var getEdgeY = (rect3, edge) => {
  guard$6(rect3);
  switch (edge) {
    case `top`:
      return isPoint(rect3) ? rect3.y : 0;
    case `bottom`:
      return isPoint(rect3) ? rect3.y + rect3.height : rect3.height;
    case `left`:
      return isPoint(rect3) ? rect3.y : 0;
    case `right`:
      return isPoint(rect3) ? rect3.y : 0;
  }
};
var Empty$3 = Object.freeze({
  width: 0,
  height: 0
});
var EmptyPositioned = Object.freeze({
  x: 0,
  y: 0,
  width: 0,
  height: 0
});
var encompass = (rect3, ...points) => {
  const x3 = points.map((p3) => p3.x);
  const y3 = points.map((p3) => p3.y);
  let minX = Math.min(...x3, rect3.x);
  let minY = Math.min(...y3, rect3.y);
  let maxX = Math.max(...x3, rect3.x + rect3.width);
  let maxY = Math.max(...y3, rect3.y + rect3.height);
  let rectW = Math.max(rect3.width, maxX - minX);
  let rectH = Math.max(rect3.height, maxY - minY);
  return Object.freeze({
    ...rect3,
    x: minX,
    y: minY,
    width: rectW,
    height: rectH
  });
};
var fromCenter$2 = (origin, width, height$3) => {
  guard$1(origin, `origin`);
  guardDim(width, `width`);
  guardDim(height$3, `height`);
  const halfW = width / 2;
  const halfH = height$3 / 2;
  return {
    x: origin.x - halfW,
    y: origin.y - halfH,
    width,
    height: height$3
  };
};
var fromElement = (el2) => ({
  width: el2.clientWidth,
  height: el2.clientHeight
});
function fromNumbers$2(xOrWidth, yOrHeight, width, height$3) {
  if (width === void 0 || height$3 === void 0) {
    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);
    if (typeof yOrHeight !== `number`) throw new TypeError(`height is not an number`);
    return Object.freeze({
      width: xOrWidth,
      height: yOrHeight
    });
  }
  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);
  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);
  if (typeof width !== `number`) throw new Error(`width is not an number`);
  if (typeof height$3 !== `number`) throw new Error(`height is not an number`);
  return Object.freeze({
    x: xOrWidth,
    y: yOrHeight,
    width,
    height: height$3
  });
}
var fromTopLeft = (origin, width, height$3) => {
  guardDim(width, `width`);
  guardDim(height$3, `height`);
  guard$1(origin, `origin`);
  return {
    x: origin.x,
    y: origin.y,
    width,
    height: height$3
  };
};
function getRectPositionedParameter(a3, b3, c5, d3) {
  if (typeof a3 === `number`) if (typeof b3 === `number`) if (typeof c5 === `number` && typeof d3 === `number`) return {
    x: a3,
    y: b3,
    width: c5,
    height: d3
  };
  else if (isRect(c5)) return {
    x: a3,
    y: b3,
    width: c5.width,
    height: c5.height
  };
  else throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);
  else throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);
  else if (isRectPositioned(a3)) return a3;
  else if (isRect(a3)) if (typeof b3 === `number` && typeof c5 === `number`) return {
    width: a3.width,
    height: a3.height,
    x: b3,
    y: c5
  };
  else if (isPoint(b3)) return {
    width: a3.width,
    height: a3.height,
    x: b3.x,
    y: b3.y
  };
  else throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);
  else if (isPoint(a3)) if (typeof b3 === `number` && typeof c5 === `number`) return {
    x: a3.x,
    y: a3.y,
    width: b3,
    height: c5
  };
  else if (isRect(b3)) return {
    x: a3.x,
    y: a3.y,
    width: b3.width,
    height: b3.height
  };
  else throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);
  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);
}
var isEqual2 = (...p3) => {
  if (p3 === void 0) throw new Error(`parameter 'p' is undefined`);
  if (p3.length < 2) return true;
  for (let index = 1; index < p3.length; index++) {
    if (p3[index].x !== p3[0].x) return false;
    if (p3[index].y !== p3[0].y) return false;
  }
  return true;
};
var isEqualSize = (a3, b3) => {
  if (a3 === void 0) throw new Error(`a undefined`);
  if (b3 === void 0) throw new Error(`b undefined`);
  return a3.width === b3.width && a3.height === b3.height;
};
var isEqual$5 = (a3, b3) => {
  if (isPositioned$1(a3) && isPositioned$1(b3)) {
    if (!isEqual2(a3, b3)) return false;
    return a3.width === b3.width && a3.height === b3.height;
  } else if (!isPositioned$1(a3) && !isPositioned$1(b3)) return a3.width === b3.width && a3.height === b3.height;
  else return false;
};
var isLine = (p3) => {
  if (p3 === void 0) return false;
  if (p3.a === void 0) return false;
  if (p3.b === void 0) return false;
  if (!isPoint(p3.a)) return false;
  if (!isPoint(p3.b)) return false;
  return true;
};
var isPolyLine = (p3) => {
  if (!Array.isArray(p3)) return false;
  const valid = !p3.some((v3) => !isLine(v3));
  return valid;
};
var guard$4 = (line3, name = `line`) => {
  if (line3 === void 0) throw new Error(`${name} undefined`);
  if (line3.a === void 0) throw new Error(`${name}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(line3)}`);
  if (line3.b === void 0) throw new Error(`${name}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(line3)}`);
};
var getPointParameter$1 = (aOrLine, b3) => {
  let a3;
  if (isLine(aOrLine)) {
    b3 = aOrLine.b;
    a3 = aOrLine.a;
  } else {
    a3 = aOrLine;
    if (b3 === void 0) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(a3)} b: ${JSON.stringify(b3)}`);
  }
  guard$1(a3, `a`);
  guard$1(a3, `b`);
  return [a3, b3];
};
function length(aOrLine, pointB) {
  if (isPolyLine(aOrLine)) {
    const sum$4 = aOrLine.reduce((accumulator, v3) => length(v3) + accumulator, 0);
    return sum$4;
  }
  if (aOrLine === void 0) throw new TypeError(`Parameter 'aOrLine' is undefined`);
  const [a3, b3] = getPointParameter$1(aOrLine, pointB);
  const x3 = b3.x - a3.x;
  const y3 = b3.y - a3.y;
  if (a3.z !== void 0 && b3.z !== void 0) {
    const z3 = b3.z - a3.z;
    return Math.hypot(x3, y3, z3);
  } else return Math.hypot(x3, y3);
}
var lengths$1 = (rect3) => {
  guardPositioned$1(rect3, `rect`);
  return edges$1(rect3).map((l3) => length(l3));
};
var maxFromCorners = (topLeft, topRight, bottomRight, bottomLeft) => {
  if (topLeft.y > bottomRight.y) throw new Error(`topLeft.y greater than bottomRight.y`);
  if (topLeft.y > bottomLeft.y) throw new Error(`topLeft.y greater than bottomLeft.y`);
  const w1 = topRight.x - topLeft.x;
  const w22 = bottomRight.x - bottomLeft.x;
  const h1 = Math.abs(bottomLeft.y - topLeft.y);
  const h22 = Math.abs(bottomRight.y - topRight.y);
  return {
    x: Math.min(topLeft.x, bottomLeft.x),
    y: Math.min(topRight.y, topLeft.y),
    width: Math.max(w1, w22),
    height: Math.max(h1, h22)
  };
};
var multiplyOp = (a3, b3) => a3 * b3;
function multiply$4(a3, b3, c5) {
  return applyMerge(multiplyOp, a3, b3, c5);
}
function multiplyScalar$2(rect3, amount) {
  return applyScalar(multiplyOp, rect3, amount);
}
function multiplyDim(rect3, amount) {
  return applyDim(multiplyOp, rect3, amount);
}
var nearestInternal = (rect3, p3) => {
  let { x: x3, y: y3 } = p3;
  if (x3 < rect3.x) x3 = rect3.x;
  else if (x3 > rect3.x + rect3.width) x3 = rect3.x + rect3.width;
  if (y3 < rect3.y) y3 = rect3.y;
  else if (y3 > rect3.y + rect3.height) y3 = rect3.y + rect3.height;
  return Object.freeze({
    ...p3,
    x: x3,
    y: y3
  });
};
var Placeholder = Object.freeze({
  width: NaN,
  height: NaN
});
var PlaceholderPositioned = Object.freeze({
  x: NaN,
  y: NaN,
  width: NaN,
  height: NaN
});
var perimeter$4 = (rect3) => {
  guard$6(rect3);
  return rect3.height + rect3.height + rect3.width + rect3.width;
};
var dividerByLargestDimension = (rect3) => {
  const largest = Math.max(rect3.width, rect3.height);
  return (value3) => {
    if (typeof value3 === `number`) return value3 / largest;
    else if (isPoint3d(value3)) return Object.freeze({
      ...value3,
      x: value3.x / largest,
      y: value3.y / largest,
      z: value3.x / largest
    });
    else if (isPoint(value3)) return Object.freeze({
      ...value3,
      x: value3.x / largest,
      y: value3.y / largest
    });
    else throw new Error(`Param 'value' is neither number nor Point`);
  };
};
var random$2 = (rando) => {
  rando ??= Math.random;
  return Object.freeze({
    x: rando(),
    y: rando(),
    width: rando(),
    height: rando()
  });
};
var randomPoint$2 = (within, options = {}) => {
  const rand = options.randomSource ?? Math.random;
  const margin = options.margin ?? {
    x: 0,
    y: 0
  };
  const x3 = rand() * (within.width - margin.x - margin.x);
  const y3 = rand() * (within.height - margin.y - margin.y);
  const pos = {
    x: x3 + margin.x,
    y: y3 + margin.y
  };
  return isPositioned$1(within) ? sum2(pos, within) : Object.freeze(pos);
};
var subtractOp = (a3, b3) => a3 - b3;
function subtract$3(a3, b3, c5) {
  return applyMerge(subtractOp, a3, b3, c5);
}
function subtractSize(a3, b3, c5) {
  const w3 = typeof b3 === `number` ? b3 : b3.width;
  const h5 = typeof b3 === `number` ? c5 : b3.height;
  if (h5 === void 0) throw new Error(`Expected height as third parameter`);
  const r5 = {
    ...a3,
    width: a3.width - w3,
    height: a3.height - h5
  };
  return r5;
}
function subtractOffset(a3, b3) {
  let x3 = 0;
  let y3 = 0;
  if (isPositioned$1(a3)) {
    x3 = a3.x;
    y3 = a3.y;
  }
  let xB = 0;
  let yB = 0;
  if (isPositioned$1(b3)) {
    xB = b3.x;
    yB = b3.y;
  }
  return Object.freeze({
    ...a3,
    x: x3 - xB,
    y: y3 - yB,
    width: a3.width - b3.width,
    height: a3.height - b3.height
  });
}
var sumOp = (a3, b3) => a3 + b3;
function sum$3(a3, b3, c5) {
  return applyMerge(sumOp, a3, b3, c5);
}
function sumOffset(a3, b3) {
  let x3 = 0;
  let y3 = 0;
  if (isPositioned$1(a3)) {
    x3 = a3.x;
    y3 = a3.y;
  }
  let xB = 0;
  let yB = 0;
  if (isPositioned$1(b3)) {
    xB = b3.x;
    yB = b3.y;
  }
  return Object.freeze({
    ...a3,
    x: x3 + xB,
    y: y3 + yB,
    width: a3.width + b3.width,
    height: a3.height + b3.height
  });
}
function toArray$12(rect3) {
  if (isPositioned$1(rect3)) return [
    rect3.x,
    rect3.y,
    rect3.width,
    rect3.height
  ];
  else if (isRect(rect3)) return [rect3.width, rect3.height];
  else throw new Error(`Param 'rect' is not a rectangle. Got: ${JSON.stringify(rect3)}`);
}
var rect_exports = {};
__export(rect_exports, {
  Empty: () => Empty$3,
  EmptyPositioned: () => EmptyPositioned,
  Placeholder: () => Placeholder,
  PlaceholderPositioned: () => PlaceholderPositioned,
  applyDim: () => applyDim,
  applyFields: () => applyFields,
  applyMerge: () => applyMerge,
  applyScalar: () => applyScalar,
  area: () => area$5,
  cardinal: () => cardinal,
  center: () => center$1,
  centerOrigin: () => centerOrigin,
  corners: () => corners$1,
  distanceFromCenter: () => distanceFromCenter,
  distanceFromExterior: () => distanceFromExterior,
  divide: () => divide$4,
  divideDim: () => divideDim,
  divideScalar: () => divideScalar,
  dividerByLargestDimension: () => dividerByLargestDimension,
  edges: () => edges$1,
  encompass: () => encompass,
  fromCenter: () => fromCenter$2,
  fromElement: () => fromElement,
  fromNumbers: () => fromNumbers$2,
  fromTopLeft: () => fromTopLeft,
  getEdgeX: () => getEdgeX,
  getEdgeY: () => getEdgeY,
  getRectPositioned: () => getRectPositioned,
  getRectPositionedParameter: () => getRectPositionedParameter,
  guard: () => guard$6,
  guardDim: () => guardDim,
  guardPositioned: () => guardPositioned$1,
  intersectsPoint: () => intersectsPoint,
  isEmpty: () => isEmpty$3,
  isEqual: () => isEqual$5,
  isEqualSize: () => isEqualSize,
  isIntersecting: () => isIntersecting$1,
  isPlaceholder: () => isPlaceholder$3,
  isPositioned: () => isPositioned$1,
  isRect: () => isRect,
  isRectPositioned: () => isRectPositioned,
  lengths: () => lengths$1,
  maxFromCorners: () => maxFromCorners,
  multiply: () => multiply$4,
  multiplyDim: () => multiplyDim,
  multiplyScalar: () => multiplyScalar$2,
  nearestInternal: () => nearestInternal,
  perimeter: () => perimeter$4,
  random: () => random$2,
  randomPoint: () => randomPoint$2,
  subtract: () => subtract$3,
  subtractOffset: () => subtractOffset,
  subtractSize: () => subtractSize,
  sum: () => sum$3,
  sumOffset: () => sumOffset,
  toArray: () => toArray$12
});
function abs2(pt2) {
  if (isPoint3d(pt2)) return Object.freeze({
    ...pt2,
    x: Math.abs(pt2.x),
    y: Math.abs(pt2.y),
    z: Math.abs(pt2.z)
  });
  else if (isPoint(pt2)) return Object.freeze({
    ...pt2,
    x: Math.abs(pt2.x),
    y: Math.abs(pt2.y)
  });
  else throw new TypeError(`Param 'pt' is not a point`);
}
var piPi2 = Math.PI * 2;
var angleRadian = (a3, b3, c5) => {
  guard$1(a3, `a`);
  if (b3 === void 0) return Math.atan2(a3.y, a3.x);
  guard$1(b3, `b`);
  if (c5 === void 0) return Math.atan2(b3.y - a3.y, b3.x - a3.x);
  guard$1(c5, `c`);
  return Math.atan2(b3.y - a3.y, b3.x - a3.x) - Math.atan2(c5.y - a3.y, c5.x - a3.x);
};
var angleRadianCircle = (a3, b3, c5) => {
  const angle = angleRadian(a3, b3, c5);
  if (angle < 0) return angle + piPi2;
  return angle;
};
function apply$2(pt2, fn2) {
  guard$1(pt2, `pt`);
  if (isPoint3d(pt2)) return Object.freeze({
    ...pt2,
    x: fn2(pt2.x, `x`),
    y: fn2(pt2.y, `y`),
    z: fn2(pt2.z, `z`)
  });
  return Object.freeze({
    ...pt2,
    x: fn2(pt2.x, `x`),
    y: fn2(pt2.y, `y`)
  });
}
function averager(kind, opts = {}) {
  let x3;
  let y3;
  let z3;
  switch (kind) {
    case `moving-average-light`: {
      const scaling = opts.scaling ?? 3;
      x3 = movingAverageLight(scaling);
      y3 = movingAverageLight(scaling);
      z3 = movingAverageLight(scaling);
      break;
    }
    default:
      throw new Error(`Unknown averaging kind '${kind}'. Expected: 'moving-average-light'`);
  }
  return (point$1) => {
    const ax = x3(point$1.x);
    const ay = y3(point$1.y);
    if (isPoint3d(point$1)) {
      const az = z3(point$1.z);
      return Object.freeze({
        x: ax,
        y: ay,
        z: az
      });
    } else return Object.freeze({
      x: ax,
      y: ay
    });
  };
}
function findMinimum(comparer, ...points) {
  if (points.length === 0) throw new Error(`No points provided`);
  let min4 = points[0];
  for (const p3 of points) if (isPoint3d(min4) && isPoint3d(p3)) min4 = comparer(min4, p3);
  else min4 = comparer(min4, p3);
  return min4;
}
var bbox$1 = (...points) => {
  const leftMost = findMinimum((a3, b3) => {
    return a3.x < b3.x ? a3 : b3;
  }, ...points);
  const rightMost = findMinimum((a3, b3) => {
    return a3.x > b3.x ? a3 : b3;
  }, ...points);
  const topMost = findMinimum((a3, b3) => {
    return a3.y < b3.y ? a3 : b3;
  }, ...points);
  const bottomMost = findMinimum((a3, b3) => {
    return a3.y > b3.y ? a3 : b3;
  }, ...points);
  const topLeft = {
    x: leftMost.x,
    y: topMost.y
  };
  const topRight = {
    x: rightMost.x,
    y: topMost.y
  };
  const bottomRight = {
    x: rightMost.x,
    y: bottomMost.y
  };
  const bottomLeft = {
    x: leftMost.x,
    y: bottomMost.y
  };
  return maxFromCorners(topLeft, topRight, bottomRight, bottomLeft);
};
var bbox3d = (...points) => {
  const box = bbox$1(...points);
  const zMin = findMinimum((a3, b3) => {
    return a3.z < b3.z ? a3 : b3;
  }, ...points);
  const zMax = findMinimum((a3, b3) => {
    return a3.z > b3.z ? a3 : b3;
  }, ...points);
  return {
    ...box,
    z: zMin.z,
    depth: zMax.z - zMin.z
  };
};
var centroid$1 = (...points) => {
  if (!Array.isArray(points)) throw new Error(`Expected list of points`);
  const sum$4 = points.reduce((previous, p3) => {
    if (p3 === void 0) return previous;
    if (Array.isArray(p3)) throw new TypeError(`'points' list contains an array. Did you mean: centroid(...myPoints)?`);
    if (!isPoint(p3)) throw new Error(`'points' contains something which is not a point: ${JSON.stringify(p3)}`);
    return {
      x: previous.x + p3.x,
      y: previous.y + p3.y
    };
  }, {
    x: 0,
    y: 0
  });
  return Object.freeze({
    x: sum$4.x / points.length,
    y: sum$4.y / points.length
  });
};
function clamp$12(a3, min4 = 0, max4 = 1) {
  if (isPoint3d(a3)) return Object.freeze({
    x: clamp(a3.x, min4, max4),
    y: clamp(a3.y, min4, max4),
    z: clamp(a3.z, min4, max4)
  });
  else return Object.freeze({
    x: clamp(a3.x, min4, max4),
    y: clamp(a3.y, min4, max4)
  });
}
var compare3 = (a3, b3) => {
  if (a3.x < b3.x && a3.y < b3.y) return -2;
  if (a3.x > b3.x && a3.y > b3.y) return 2;
  if (a3.x < b3.x || a3.y < b3.y) return -1;
  if (a3.x > b3.x || a3.y > b3.y) return 1;
  if (a3.x === b3.x && a3.x === b3.y) return 0;
  return NaN;
};
var compareByX = (a3, b3) => {
  if (a3.x === b3.x) return 0;
  if (a3.x < b3.x) return -1;
  return 1;
};
var compareByY = (a3, b3) => {
  if (a3.y === b3.y) return 0;
  if (a3.y < b3.y) return -1;
  return 1;
};
var compareByZ = (a3, b3) => {
  if (a3.z === b3.z) return 0;
  if (a3.z < b3.z) return -1;
  return 1;
};
var convexHull = (...pts) => {
  const sorted = [...pts].sort(compareByX);
  if (sorted.length === 1) return sorted;
  const x3 = (points) => {
    const v3 = [];
    for (const p3 of points) {
      while (v3.length >= 2) {
        const q3 = v3.at(-1);
        const r5 = v3.at(-2);
        if ((q3.x - r5.x) * (p3.y - r5.y) >= (q3.y - r5.y) * (p3.x - r5.x)) v3.pop();
        else break;
      }
      v3.push(p3);
    }
    v3.pop();
    return v3;
  };
  const upper = x3(sorted);
  const lower = x3(sorted.reverse());
  if (upper.length === 1 && lower.length === 1 && isEqual2(lower[0], upper[0])) return upper;
  return [...upper, ...lower];
};
var distanceCenter = (a3, b3) => {
  guardPositioned(a3, `a`);
  if (isCirclePositioned(b3)) guardPositioned(b3, `b`);
  return distance3(a3, b3);
};
var distanceFromExterior$1 = (a3, b3) => {
  guardPositioned(a3, `a`);
  if (isCirclePositioned(b3)) return Math.max(0, distanceCenter(a3, b3) - a3.radius - b3.radius);
  else if (isPoint(b3)) {
    const distribution = distance3(a3, b3);
    if (distribution < a3.radius) return 0;
    return distribution;
  } else throw new Error(`Second parameter invalid type`);
};
var distanceToCenter = (a3, shape) => {
  if (isRectPositioned(shape)) return distanceFromExterior(shape, a3);
  if (isCirclePositioned(shape)) return distanceFromExterior$1(shape, a3);
  if (isPoint(shape)) return distance3(a3, shape);
  throw new Error(`Unknown shape`);
};
var distanceToExterior = (a3, shape) => {
  if (isRectPositioned(shape)) return distanceFromExterior(shape, a3);
  if (isCirclePositioned(shape)) return distanceFromExterior$1(shape, a3);
  if (isPoint(shape)) return distance3(a3, shape);
  throw new Error(`Unknown shape`);
};
function divide$1(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);
  guard$1(ptA, `a`);
  guard$1(ptB, `b`);
  if (ptB.x === 0) throw new TypeError("Cannot divide by zero (b.x is 0)");
  if (ptB.y === 0) throw new TypeError("Cannot divide by zero (b.y is 0)");
  const pt2 = {
    x: ptA.x / ptB.x,
    y: ptA.y / ptB.y
  };
  if (isPoint3d(ptA) || isPoint3d(ptB)) {
    if (ptB.z === 0) throw new TypeError("Cannot divide by zero (b.z is 0)");
    pt2.z = (ptA.z ?? 0) / (ptB.z ?? 0);
  }
  return Object.freeze(pt2);
}
function divider(a3, b3, c5) {
  const divisor = getPointParameter(a3, b3, c5);
  guardNonZeroPoint(divisor, `divisor`);
  return (aa2, bb, cc) => {
    const dividend = getPointParameter(aa2, bb, cc);
    return typeof dividend.z === `undefined` ? Object.freeze({
      x: dividend.x / divisor.x,
      y: dividend.y / divisor.y
    }) : Object.freeze({
      x: dividend.x / divisor.x,
      y: dividend.y / divisor.y,
      z: dividend.z / (divisor.z ?? 1)
    });
  };
}
var toArray3 = (p3) => [p3.x, p3.y];
var dotProduct$1 = (...pts) => {
  const a3 = pts.map((p3) => toArray3(p3));
  return dotProduct(a3);
};
var Empty = {
  x: 0,
  y: 0
};
var Unit = {
  x: 1,
  y: 1
};
var Empty3d = {
  x: 0,
  y: 0,
  z: 0
};
var Unit3d = {
  x: 1,
  y: 1,
  z: 1
};
function from(xOrArray, y3, z3) {
  if (Array.isArray(xOrArray)) if (xOrArray.length === 3) return Object.freeze({
    x: xOrArray[0],
    y: xOrArray[1],
    z: xOrArray[2]
  });
  else if (xOrArray.length === 2) return Object.freeze({
    x: xOrArray[0],
    y: xOrArray[1]
  });
  else throw new Error(`Expected array of length two or three, got ${xOrArray.length}`);
  else {
    if (xOrArray === void 0) throw new Error(`Requires an array of [x,y] or x,y parameters at least`);
    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);
    if (y3 === void 0) throw new Error(`Param 'y' is missing`);
    else if (Number.isNaN(y3)) throw new Error(`y is NaN`);
    if (z3 === void 0) return Object.freeze({
      x: xOrArray,
      y: y3
    });
    else return Object.freeze({
      x: xOrArray,
      y: y3,
      z: z3
    });
  }
}
var fromString = (string_) => {
  if (typeof string_ !== `string`) throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof string_}`);
  const comma = string_.indexOf(`,`);
  const x3 = Number.parseFloat(string_.substring(0, comma));
  const nextComma = string_.indexOf(",", comma + 1);
  if (nextComma > 0) {
    const y3 = Number.parseFloat(string_.substring(comma + 1, nextComma - comma + 2));
    const z3 = Number.parseFloat(string_.substring(nextComma + 1));
    return {
      x: x3,
      y: y3,
      z: z3
    };
  } else {
    const y3 = Number.parseFloat(string_.substring(comma + 1));
    return {
      x: x3,
      y: y3
    };
  }
};
var fromNumbers = (...coords) => {
  const pts = [];
  if (Array.isArray(coords[0])) for (const coord of coords) {
    if (!(coord.length % 2 === 0)) throw new Error(`coords array should be even-numbered`);
    pts.push(Object.freeze({
      x: coord[0],
      y: coord[1]
    }));
  }
  else {
    if (coords.length % 2 !== 0) throw new Error(`Expected even number of elements: [x,y,x,y...]`);
    for (let index = 0; index < coords.length; index += 2) pts.push(Object.freeze({
      x: coords[index],
      y: coords[index + 1]
    }));
  }
  return pts;
};
function reverse(line3) {
  guard$4(line3, `line`);
  return {
    a: line3.b,
    b: line3.a
  };
}
function interpolate$2(amount, aOrLine, pointBOrAllowOverflow, allowOverflow) {
  if (typeof pointBOrAllowOverflow === `boolean`) {
    allowOverflow = pointBOrAllowOverflow;
    pointBOrAllowOverflow = void 0;
  }
  if (!allowOverflow) resultThrow(percentTest(amount, `amount`));
  else resultThrow(numberTest(amount, ``, `amount`));
  const [a3, b3] = getPointParameter$1(aOrLine, pointBOrAllowOverflow);
  const d3 = length(a3, b3);
  const d22 = d3 * (1 - amount);
  if (d3 === 0 && d22 === 0) return Object.freeze({ ...b3 });
  const x3 = b3.x - d22 * (b3.x - a3.x) / d3;
  const y3 = b3.y - d22 * (b3.y - a3.y) / d3;
  return Object.freeze({
    ...b3,
    x: x3,
    y: y3
  });
}
function pointAtDistance(line3, distance$2, fromA$2 = true) {
  if (!fromA$2) line3 = reverse(line3);
  const dx = line3.b.x - line3.a.x;
  const dy = line3.b.y - line3.a.y;
  const theta = Math.atan2(dy, dx);
  const xp = distance$2 * Math.cos(theta);
  const yp = distance$2 * Math.sin(theta);
  return {
    x: xp + line3.a.x,
    y: yp + line3.a.y
  };
}
var interpolate$4 = (amount, a3, b3, allowOverflow = false) => interpolate$2(amount, a3, b3, allowOverflow);
var invert$1 = (pt2, what = `both`) => {
  switch (what) {
    case `both`:
      return isPoint3d(pt2) ? Object.freeze({
        ...pt2,
        x: pt2.x * -1,
        y: pt2.y * -1,
        z: pt2.z * -1
      }) : Object.freeze({
        ...pt2,
        x: pt2.x * -1,
        y: pt2.y * -1
      });
    case `x`:
      return Object.freeze({
        ...pt2,
        x: pt2.x * -1
      });
    case `y`:
      return Object.freeze({
        ...pt2,
        y: pt2.y * -1
      });
    case `z`:
      if (isPoint3d(pt2)) return Object.freeze({
        ...pt2,
        z: pt2.z * -1
      });
      else throw new Error(`pt parameter is missing z`);
    default:
      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);
  }
};
function multiply$1(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);
  guard$1(ptA, `a`);
  guard$1(ptB, `b`);
  const pt2 = {
    x: ptA.x * ptB.x,
    y: ptA.y * ptB.y
  };
  if (isPoint3d(ptA) || isPoint3d(ptB)) pt2.z = (ptA.z ?? 0) * (ptB.z ?? 0);
  return Object.freeze(pt2);
}
var multiplyScalar = (pt2, v3) => {
  return isPoint3d(pt2) ? Object.freeze({
    ...pt2,
    x: pt2.x * v3,
    y: pt2.y * v3,
    z: pt2.z * v3
  }) : Object.freeze({
    ...pt2,
    x: pt2.x * v3,
    y: pt2.y * v3
  });
};
var clampMagnitude = (pt2, max4 = 1, min4 = 0) => {
  const length$4 = distance3(pt2);
  let ratio = 1;
  if (length$4 > max4) ratio = max4 / length$4;
  else if (length$4 < min4) ratio = min4 / length$4;
  return ratio === 1 ? pt2 : multiply$1(pt2, ratio, ratio);
};
var leftmost = (...points) => findMinimum((a3, b3) => a3.x <= b3.x ? a3 : b3, ...points);
var rightmost = (...points) => findMinimum((a3, b3) => a3.x >= b3.x ? a3 : b3, ...points);
var length$3 = (ptOrX, y3) => {
  if (isPoint(ptOrX)) {
    y3 = ptOrX.y;
    ptOrX = ptOrX.x;
  }
  if (y3 === void 0) throw new Error(`Expected y`);
  return Math.hypot(ptOrX, y3);
};
var normalise = (ptOrX, y3) => {
  const pt2 = getPointParameter(ptOrX, y3);
  const l3 = length$3(pt2);
  if (l3 === 0) return Empty;
  return Object.freeze({
    ...pt2,
    x: pt2.x / l3,
    y: pt2.y / l3
  });
};
function normaliseByRect(a3, b3, c5, d3) {
  if (isPoint(a3)) {
    if (typeof b3 === `number` && c5 !== void 0) resultThrow(numberTest(b3, `positive`, `width`), numberTest(c5, `positive`, `height`));
    else {
      if (!isRect(b3)) throw new Error(`Expected second parameter to be a rect`);
      c5 = b3.height;
      b3 = b3.width;
    }
    return Object.freeze({
      x: a3.x / b3,
      y: a3.y / c5
    });
  } else {
    resultThrow(numberTest(a3, `positive`, `x`));
    if (typeof b3 !== `number`) throw new TypeError(`Expecting second parameter to be a number (width)`);
    if (typeof c5 !== `number`) throw new TypeError(`Expecting third parameter to be a number (height)`);
    resultThrow(numberTest(b3, `positive`, `y`));
    resultThrow(numberTest(c5, `positive`, `width`));
    if (d3 === void 0) throw new Error(`Expected height parameter`);
    resultThrow(numberTest(d3, `positive`, `height`));
    return Object.freeze({
      x: a3 / c5,
      y: b3 / d3
    });
  }
}
var pipelineApply = (point$1, ...pipelineFns) => pipeline(...pipelineFns)(point$1);
var pipeline = (...pipeline$1) => (pt2) => pipeline$1.reduce((previous, current) => current(previous), pt2);
var isPolarCoord = (p3) => {
  if (p3.distance === void 0) return false;
  if (p3.angleRadian === void 0) return false;
  return true;
};
var guard$5 = (p3, name = `Point`) => {
  if (p3 === void 0) throw new Error(`'${name}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (p3 === null) throw new Error(`'${name}' is null. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (p3.angleRadian === void 0) throw new Error(`'${name}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (p3.distance === void 0) throw new Error(`'${name}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (typeof p3.angleRadian !== `number`) throw new TypeError(`'${name}.angleRadian' must be a number. Got ${p3.angleRadian}`);
  if (typeof p3.distance !== `number`) throw new TypeError(`'${name}.distance' must be a number. Got ${p3.distance}`);
  if (p3.angleRadian === null) throw new Error(`'${name}.angleRadian' is null`);
  if (p3.distance === null) throw new Error(`'${name}.distance' is null`);
  if (Number.isNaN(p3.angleRadian)) throw new TypeError(`'${name}.angleRadian' is NaN`);
  if (Number.isNaN(p3.distance)) throw new Error(`'${name}.distance' is NaN`);
};
function degreeToRadian(angleInDegrees) {
  return Array.isArray(angleInDegrees) ? angleInDegrees.map((v3) => v3 * (Math.PI / 180)) : angleInDegrees * (Math.PI / 180);
}
function radianInvert(angleInRadians) {
  return (angleInRadians + Math.PI) % (2 * Math.PI);
}
function degreeToGradian(angleInDegrees) {
  return angleInDegrees * 1.111111;
}
function gradianToDegree(angleInGradians, wrap$4 = true) {
  if (wrap$4) return angleInGradians * 0.9 % 360;
  return angleInGradians * 0.9;
}
function radianToGradian(angleInRadians) {
  return angleInRadians * 63.6619772368;
}
function gradianToRadian(angleInGradian) {
  return angleInGradian * 0.0157079633;
}
function radianToDegree(angleInRadians) {
  return Array.isArray(angleInRadians) ? angleInRadians.map((v3) => v3 * 180 / Math.PI) : angleInRadians * 180 / Math.PI;
}
var radiansFromAxisX = (point$1) => Math.atan2(point$1.x, point$1.y);
var radiansSum = (start, amount, clockwise = true) => {
  if (clockwise) {
    let x3 = start + amount;
    if (x3 >= piPi2) x3 = x3 % piPi2;
    return x3;
  } else {
    const x3 = start - amount;
    if (x3 < 0) return piPi2 + x3;
    return x3;
  }
};
var degreesSum = (start, amount, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));
var radianArc = (start, end, clockwise = true) => {
  let s3 = start;
  if (end < s3) {
    s3 = 0;
    end = piPi2 - start + end;
  }
  let d3 = end - s3;
  if (clockwise) d3 = piPi2 - d3;
  if (d3 >= piPi2) return d3 % piPi2;
  return d3;
};
var degreeArc = (start, end, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));
var angleParse = (value3) => {
  if (isAngle(value3)) return value3;
  if (typeof value3 === `number`) return {
    value: value3,
    unit: `deg`
  };
  value3 = value3.toLowerCase();
  let unit = `deg`;
  let numberValue = NaN;
  if (value3.endsWith(`grad`)) {
    numberValue = Number.parseFloat(value3.substring(0, value3.length - 4));
    unit = `grad`;
  } else if (value3.endsWith(`rad`)) {
    numberValue = Number.parseFloat(value3.substring(0, value3.length - 3));
    unit = `rad`;
  } else if (value3.endsWith(`turn`)) {
    numberValue = Number.parseFloat(value3.substring(0, value3.length - 4));
    unit = `turn`;
  } else if (value3.endsWith(`deg`)) {
    numberValue = Number.parseFloat(value3.substring(0, value3.length - 3));
    unit = `deg`;
  } else numberValue = Number.parseFloat(value3);
  if (Number.isNaN(numberValue)) throw new Error(`Invalid angle (bad value?)`);
  if (unit.length === 0) throw new Error(`Invalid angle (no unit)`);
  return {
    value: numberValue,
    unit
  };
};
var isAngle = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (`unit` in v3 && `value` in v3) {
    if (typeof v3.unit !== `string`) return false;
    if (typeof v3.value !== `number`) return false;
    return true;
  }
  return false;
};
var angleConvert = (angleOrDegrees, destination) => {
  const angle = typeof angleOrDegrees === `object` ? angleOrDegrees : angleParse(angleOrDegrees);
  switch (destination) {
    case `deg`:
      if (angle.unit === `deg`) return angle;
      if (angle.unit === `rad`) return {
        value: radianToDegree(angle.value),
        unit: `deg`
      };
      if (angle.unit === `grad`) return {
        value: gradianToDegree(angle.value),
        unit: `deg`
      };
      if (angle.unit === `turn`) return {
        value: turnToDegree(angle.value),
        unit: `deg`
      };
      throw new Error(`Unknown unit: ${angle.unit}`);
    case `grad`:
      if (angle.unit === `deg`) return {
        value: degreeToGradian(angle.value),
        unit: `grad`
      };
      if (angle.unit === `rad`) return {
        value: radianToGradian(angle.value),
        unit: `grad`
      };
      if (angle.unit === `grad`) return angle;
      if (angle.unit === `turn`) return {
        value: radianToGradian(turnToRadian(angle.value)),
        unit: `grad`
      };
      throw new Error(`Unknown unit: ${angle.unit}`);
    case `rad`:
      if (angle.unit === `deg`) return {
        value: degreeToRadian(angle.value),
        unit: `rad`
      };
      if (angle.unit === `rad`) return angle;
      if (angle.unit === `grad`) return {
        value: gradianToRadian(angle.value),
        unit: `rad`
      };
      if (angle.unit === `turn`) return {
        value: radianToGradian(turnToRadian(angle.value)),
        unit: `grad`
      };
      throw new Error(`Unknown unit: ${angle.unit}`);
    case `turn`:
      if (angle.unit === `deg`) return {
        value: degreeToTurn(angle.value),
        unit: `turn`
      };
      if (angle.unit === `rad`) return {
        value: radianToTurn(angle.value),
        unit: `turn`
      };
      if (angle.unit === `grad`) return {
        value: radianToTurn(gradianToRadian(angle.value)),
        unit: `turn`
      };
      if (angle.unit === `turn`) return angle;
      throw new Error(`Unknown unit: ${angle.unit}`);
    default:
      throw new Error(`Destination unit unknown ('${destination}). Expects: deg, grad, rad or turn`);
  }
};
var turnToDegree = (turns, wrap$4 = true) => {
  if (wrap$4) return turns * 360 % 360;
  return turns * 360;
};
var turnToRadian = (turns) => turns * piPi2;
var degreeToTurn = (degrees) => degrees / 360;
var radianToTurn = (radians) => radians / piPi2;
var rotate$2 = (c5, amountRadian) => Object.freeze({
  ...c5,
  angleRadian: c5.angleRadian + amountRadian
});
var invert = (p3) => {
  guard$5(p3, `c`);
  return Object.freeze({
    ...p3,
    angleRadian: p3.angleRadian - Math.PI
  });
};
var isOpposite = (a3, b3) => {
  guard$5(a3, `a`);
  guard$5(b3, `b`);
  if (a3.distance !== b3.distance) return false;
  return a3.angleRadian === -b3.angleRadian;
};
var isParallel = (a3, b3) => {
  guard$5(a3, `a`);
  guard$5(b3, `b`);
  return a3.angleRadian === b3.angleRadian;
};
var isAntiParallel = (a3, b3) => {
  guard$5(a3, `a`);
  guard$5(b3, `b`);
  return a3.angleRadian === -b3.angleRadian;
};
var rotateDegrees = (c5, amountDeg) => Object.freeze({
  ...c5,
  angleRadian: c5.angleRadian + degreeToRadian(amountDeg)
});
var toLine$1 = (c5, start) => {
  const b3 = toCartesian(c5, start);
  return {
    a: start,
    b: b3
  };
};
var toCartesian = (a3, b3, c5) => {
  if (isPolarCoord(a3)) {
    if (typeof b3 === `undefined`) b3 = Empty;
    if (isPoint(b3)) return polarToCartesian(a3.distance, a3.angleRadian, b3);
    throw new Error(`Expecting (Coord, Point). Second parameter is not a point`);
  } else if (typeof a3 === `object`) throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(a3)}`);
  else if (typeof a3 === `number` && typeof b3 === `number`) {
    if (typeof c5 === `undefined`) c5 = Empty;
    if (!isPoint(c5)) throw new Error(`Expecting (number, number, Point). Point param wrong type`);
    return polarToCartesian(a3, b3, c5);
  } else throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof a3}, ${typeof b3}, ${typeof c5}). a: ${JSON.stringify(a3)}`);
};
var fromCartesian = (point$1, origin) => {
  if (typeof point$1 === `undefined`) throw new Error(`Param 'point' missing. Expecting a Point`);
  if (typeof origin === `undefined`) throw new Error(`Param 'origin' missing. Expecting a Point`);
  point$1 = subtract(point$1, origin);
  const angle = Math.atan2(point$1.y, point$1.x);
  const distance$2 = Math.hypot(point$1.x, point$1.y);
  const polar = {
    ...point$1,
    angleRadian: angle,
    distance: distance$2
  };
  delete polar.x;
  delete polar.y;
  return Object.freeze(polar);
};
var polarToCartesian = (distance$2, angleRadians, origin = Empty) => {
  guard$1(origin);
  return Object.freeze({
    x: origin.x + distance$2 * Math.cos(angleRadians),
    y: origin.y + distance$2 * Math.sin(angleRadians)
  });
};
var toString$5 = (p3, digits) => {
  if (p3 === void 0) return `(undefined)`;
  if (p3 === null) return `(null)`;
  const angleDeg = radianToDegree(p3.angleRadian);
  const d3 = digits ? p3.distance.toFixed(digits) : p3.distance;
  const a3 = digits ? angleDeg.toFixed(digits) : angleDeg;
  return `(${d3},${a3})`;
};
var toPoint = (v3, origin = Empty) => {
  guard$5(v3, `v`);
  return Object.freeze({
    x: origin.x + v3.distance * Math.cos(v3.angleRadian),
    y: origin.y + v3.distance * Math.sin(v3.angleRadian)
  });
};
var normalise$2 = (c5) => {
  if (c5.distance === 0) throw new Error(`Cannot normalise vector of length 0`);
  return Object.freeze({
    ...c5,
    distance: 1
  });
};
var clampMagnitude$2 = (v3, max4 = 1, min4 = 0) => {
  let mag = v3.distance;
  if (mag > max4) mag = max4;
  if (mag < min4) mag = min4;
  return Object.freeze({
    ...v3,
    distance: mag
  });
};
var dotProduct$3 = (a3, b3) => {
  guard$5(a3, `a`);
  guard$5(b3, `b`);
  return a3.distance * b3.distance * Math.cos(b3.angleRadian - a3.angleRadian);
};
var multiply$3 = (v3, amt) => {
  guard$5(v3);
  resultThrow(numberTest(amt, ``, `amt`));
  return Object.freeze({
    ...v3,
    distance: v3.distance * amt
  });
};
var divide$3 = (v3, amt) => {
  guard$5(v3);
  resultThrow(numberTest(amt, ``, `amt`));
  return Object.freeze({
    ...v3,
    distance: v3.distance / amt
  });
};
var toIntegerValues = (pt2, rounder = Math.round) => {
  guard$1(pt2, `pt`);
  return Object.freeze({
    x: rounder(pt2.x),
    y: rounder(pt2.y)
  });
};
var to2d = (pt2) => {
  guard$1(pt2, `pt`);
  let copy = { ...pt2 };
  delete copy.z;
  return Object.freeze(copy);
};
var to3d = (pt2, z3 = 0) => {
  guard$1(pt2, `pt`);
  return Object.freeze({
    ...pt2,
    z: z3
  });
};
function toString$2(p3, digits) {
  if (p3 === void 0) return `(undefined)`;
  if (p3 === null) return `(null)`;
  guard$1(p3, `pt`);
  const x3 = digits ? p3.x.toFixed(digits) : p3.x;
  const y3 = digits ? p3.y.toFixed(digits) : p3.y;
  if (p3.z === void 0) return `(${x3},${y3})`;
  else {
    const z3 = digits ? p3.z.toFixed(digits) : p3.z;
    return `(${x3},${y3},${z3})`;
  }
}
var ray_exports = {};
__export(ray_exports, {
  fromLine: () => fromLine,
  toCartesian: () => toCartesian$2,
  toString: () => toString$4
});
var toCartesian$2 = (ray, origin) => {
  const o5 = getOrigin(ray, origin);
  const a3 = toCartesian(ray.offset, ray.angleRadian, o5);
  const b3 = toCartesian(ray.offset + ray.length, ray.angleRadian, o5);
  return {
    a: a3,
    b: b3
  };
};
var getOrigin = (ray, origin) => {
  if (origin !== void 0) return origin;
  if (ray.origin !== void 0) return ray.origin;
  return {
    x: 0,
    y: 0
  };
};
var toString$4 = (ray) => {
  let basic = `PolarRay(angle: ${ray.angleRadian} offset: ${ray.offset} len: ${ray.length}`;
  if (ray.origin) basic += ` origin: ${toString$2(ray.origin)}`;
  basic += `)`;
  return basic;
};
var fromLine = (line3, origin) => {
  const o5 = origin ?? line3.a;
  return {
    angleRadian: angleRadian(line3.b, o5),
    offset: distance3(line3.a, o5),
    length: distance3(line3.b, line3.a),
    origin: o5
  };
};
function* spiral(smoothness, zoom) {
  let step = 0;
  while (true) {
    const a3 = smoothness * step++;
    yield {
      distance: zoom * a3,
      angleRadian: a3,
      step
    };
  }
}
var spiralRaw = (step, smoothness, zoom) => {
  const a3 = smoothness * step;
  return Object.freeze({
    distance: zoom * a3,
    angleRadian: a3
  });
};
var polar_exports = {};
__export(polar_exports, {
  Ray: () => ray_exports,
  clampMagnitude: () => clampMagnitude$2,
  divide: () => divide$3,
  dotProduct: () => dotProduct$3,
  fromCartesian: () => fromCartesian,
  guard: () => guard$5,
  invert: () => invert,
  isAntiParallel: () => isAntiParallel,
  isOpposite: () => isOpposite,
  isParallel: () => isParallel,
  isPolarCoord: () => isPolarCoord,
  multiply: () => multiply$3,
  normalise: () => normalise$2,
  rotate: () => rotate$2,
  rotateDegrees: () => rotateDegrees,
  spiral: () => spiral,
  spiralRaw: () => spiralRaw,
  toCartesian: () => toCartesian,
  toLine: () => toLine$1,
  toPoint: () => toPoint,
  toString: () => toString$5
});
var vector_exports = {};
__export(vector_exports, {
  clampMagnitude: () => clampMagnitude$1,
  divide: () => divide$2,
  dotProduct: () => dotProduct$2,
  fromLineCartesian: () => fromLineCartesian,
  fromLinePolar: () => fromLinePolar,
  fromPointPolar: () => fromPointPolar,
  fromRadians: () => fromRadians,
  multiply: () => multiply$2,
  normalise: () => normalise$1,
  quadrantOffsetAngle: () => quadrantOffsetAngle,
  subtract: () => subtract$2,
  sum: () => sum$2,
  toCartesian: () => toCartesian$1,
  toPolar: () => toPolar,
  toRadians: () => toRadians,
  toString: () => toString$3
});
var EmptyCartesian = Object.freeze({
  x: 0,
  y: 0
});
var piPi$5 = Math.PI * 2;
var pi$12 = Math.PI;
var fromRadians = (radians) => {
  return Object.freeze({
    x: Math.cos(radians),
    y: Math.sin(radians)
  });
};
var toRadians = (point$1) => {
  return Math.atan2(point$1.y, point$1.x);
};
var fromPointPolar = (pt2, angleNormalisation = ``, origin = EmptyCartesian) => {
  pt2 = subtract(pt2, origin);
  let direction = Math.atan2(pt2.y, pt2.x);
  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi$5;
  else if (angleNormalisation === `bipolar`) {
    if (direction > pi$12) direction -= piPi$5;
    else if (direction <= -pi$12) direction += piPi$5;
  }
  return Object.freeze({
    distance: distance3(pt2),
    angleRadian: direction
  });
};
var fromLineCartesian = (line3) => subtract(line3.b, line3.a);
var fromLinePolar = (line3) => {
  guard$4(line3, `line`);
  const pt2 = subtract(line3.b, line3.a);
  return fromPointPolar(pt2);
};
var isPolar = (v3) => {
  if (isPolarCoord(v3)) return true;
  return false;
};
var isCartesian = (v3) => {
  if (isPoint(v3)) return true;
  return false;
};
var normalise$1 = (v3) => {
  if (isPolar(v3)) return normalise$2(v3);
  else if (isCartesian(v3)) return normalise(v3);
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var quadrantOffsetAngle = (p3) => {
  if (p3.x >= 0 && p3.y >= 0) return 0;
  if (p3.x < 0 && p3.y >= 0) return pi$12;
  if (p3.x < 0 && p3.y < 0) return pi$12;
  return piPi$5;
};
var toPolar = (v3, origin = Empty) => {
  if (isPolar(v3)) return v3;
  else if (isCartesian(v3)) return fromCartesian(v3, origin);
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var toCartesian$1 = (v3) => {
  if (isPolar(v3)) return toPoint(v3);
  else if (isCartesian(v3)) return v3;
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var toString$3 = (v3, digits) => {
  if (isPolar(v3)) return toString$5(v3, digits);
  else if (isCartesian(v3)) return toString$2(v3, digits);
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var dotProduct$2 = (a3, b3) => {
  if (isPolar(a3) && isPolar(b3)) return dotProduct$3(a3, b3);
  else if (isCartesian(a3) && isCartesian(b3)) return dotProduct$1(a3, b3);
  throw new Error(`Expected two polar/Cartesian vectors.`);
};
var clampMagnitude$1 = (v3, max4 = 1, min4 = 0) => {
  if (isPolar(v3)) return clampMagnitude$2(v3, max4, min4);
  else if (isCartesian(v3)) return clampMagnitude(v3, max4, min4);
  throw new Error(`Expected either polar or Cartesian vector`);
};
var sum$2 = (a3, b3) => {
  const polar = isPolar(a3);
  a3 = toCartesian$1(a3);
  b3 = toCartesian$1(b3);
  const c5 = sum2(a3, b3);
  return polar ? toPolar(c5) : c5;
};
var subtract$2 = (a3, b3) => {
  const polar = isPolar(a3);
  a3 = toCartesian$1(a3);
  b3 = toCartesian$1(b3);
  const c5 = subtract(a3, b3);
  return polar ? toPolar(c5) : c5;
};
var multiply$2 = (a3, b3) => {
  const polar = isPolar(a3);
  a3 = toCartesian$1(a3);
  b3 = toCartesian$1(b3);
  const c5 = multiply$1(a3, b3);
  return polar ? toPolar(c5) : c5;
};
var divide$2 = (a3, b3) => {
  const polar = isPolar(a3);
  a3 = toCartesian$1(a3);
  b3 = toCartesian$1(b3);
  const c5 = divide$1(a3, b3);
  return polar ? toPolar(c5) : c5;
};
var nearest$1 = (line3, point$1) => {
  const n6 = (line$13) => {
    const { a: a3, b: b3 } = line$13;
    const atob2 = {
      x: b3.x - a3.x,
      y: b3.y - a3.y
    };
    const atop = {
      x: point$1.x - a3.x,
      y: point$1.y - a3.y
    };
    const length$4 = atob2.x * atob2.x + atob2.y * atob2.y;
    let dot3 = atop.x * atob2.x + atop.y * atob2.y;
    const t6 = Math.min(1, Math.max(0, dot3 / length$4));
    dot3 = (b3.x - a3.x) * (point$1.y - a3.y) - (b3.y - a3.y) * (point$1.x - a3.x);
    return {
      x: a3.x + atob2.x * t6,
      y: a3.y + atob2.y * t6
    };
  };
  if (Array.isArray(line3)) {
    const pts = line3.map((l3) => n6(l3));
    const dists = pts.map((p3) => distance3(p3, point$1));
    return Object.freeze(pts[minIndex(...dists)]);
  } else return Object.freeze(n6(line3));
};
var distanceSingleLine = (line3, point$1) => {
  guard$4(line3, `line`);
  guard$1(point$1, `point`);
  if (length(line3) === 0) return length(line3.a, point$1);
  const near = nearest$1(line3, point$1);
  return length(near, point$1);
};
var directionVector = (line3) => ({
  x: line3.b.x - line3.a.x,
  y: line3.b.y - line3.a.y
});
var directionVectorNormalised = (line3) => {
  const l3 = length(line3);
  const v3 = directionVector(line3);
  return {
    x: v3.x / l3,
    y: v3.y / l3
  };
};
var parallel = (line3, distance$2) => {
  const dv = directionVector(line3);
  const dvn = directionVectorNormalised(line3);
  const a3 = {
    x: line3.a.x - dvn.y * distance$2,
    y: line3.a.y + dvn.x * distance$2
  };
  return {
    a: a3,
    b: {
      x: a3.x + dv.x,
      y: a3.y + dv.y
    }
  };
};
var perpendicularPoint = (line3, distance$2, amount = 0) => {
  const origin = interpolate$2(amount, line3);
  const dvn = directionVectorNormalised(line3);
  return {
    x: origin.x - dvn.y * distance$2,
    y: origin.y + dvn.x * distance$2
  };
};
var bbox$5 = (line3) => bbox$1(line3.a, line3.b);
var divide = (line3, point$1) => Object.freeze({
  ...line3,
  a: divide$1(line3.a, point$1),
  b: divide$1(line3.b, point$1)
});
var fromNumbers$1 = (x1, y1, x22, y22) => {
  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);
  if (Number.isNaN(x22)) throw new Error(`x2 is NaN`);
  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);
  if (Number.isNaN(y22)) throw new Error(`y2 is NaN`);
  const a3 = {
    x: x1,
    y: y1
  };
  const b3 = {
    x: x22,
    y: y22
  };
  return fromPoints$2(a3, b3);
};
var fromFlatArray$1 = (array3) => {
  if (!Array.isArray(array3)) throw new Error(`arr parameter is not an array`);
  if (array3.length !== 4) throw new Error(`array is expected to have length four`);
  return fromNumbers$1(array3[0], array3[1], array3[2], array3[3]);
};
var fromPivot = (origin = {
  x: 0.5,
  y: 0.5
}, length$4 = 1, angleRadian$2 = 0, balance = 0.5) => {
  const left = length$4 * balance;
  const right = length$4 * (1 - balance);
  const a3 = toCartesian(left, radianInvert(angleRadian$2), origin);
  const b3 = toCartesian(right, angleRadian$2, origin);
  return Object.freeze({
    a: a3,
    b: b3
  });
};
var midpoint = (aOrLine, pointB) => {
  const [a3, b3] = getPointParameter$1(aOrLine, pointB);
  return interpolate$2(0.5, a3, b3);
};
var relativePosition$1 = (line3, pt2) => {
  const fromStart = distance3(line3.a, pt2);
  const total2 = length(line3);
  return fromStart / total2;
};
var sum$12 = (line3, point$1) => Object.freeze({
  ...line3,
  a: sum2(line3.a, point$1),
  b: sum2(line3.b, point$1)
});
var rotate$3 = (line3, amountRadian, origin) => {
  if (typeof amountRadian === `undefined` || amountRadian === 0) return line3;
  if (typeof origin === `undefined`) origin = 0.5;
  if (typeof origin === `number`) origin = interpolate$2(origin, line3.a, line3.b);
  return Object.freeze({
    ...line3,
    a: rotate(line3.a, amountRadian, origin),
    b: rotate(line3.b, amountRadian, origin)
  });
};
var isEqual$4 = (a3, b3) => isEqual2(a3.a, b3.a) && isEqual2(a3.b, b3.b);
var multiply = (line3, point$1) => Object.freeze({
  ...line3,
  a: multiply$1(line3.a, point$1),
  b: multiply$1(line3.b, point$1)
});
var subtract$1 = (line3, point$1) => Object.freeze({
  ...line3,
  a: subtract(line3.a, point$1),
  b: subtract(line3.b, point$1)
});
function toString$13(a3, b3) {
  if (isLine(a3)) {
    guard$4(a3, `a`);
    b3 = a3.b;
    a3 = a3.a;
  } else if (b3 === void 0) throw new Error(`Expect second point if first is a point`);
  return toString$2(a3) + `-` + toString$2(b3);
}
var toPath = (line3) => {
  const { a: a3, b: b3 } = line3;
  return Object.freeze({
    ...line3,
    length: () => length(a3, b3),
    interpolate: (amount) => interpolate$2(amount, a3, b3),
    relativePosition: (point$1) => relativePosition$1(line3, point$1),
    bbox: () => bbox$5(line3),
    toString: () => toString$13(a3, b3),
    toFlatArray: () => toFlatArray$1(a3, b3),
    toSvgString: () => toSvgString$1(a3, b3),
    toPoints: () => [a3, b3],
    rotate: (amountRadian, origin) => toPath(rotate$3(line3, amountRadian, origin)),
    nearest: (point$1) => nearest$1(line3, point$1),
    sum: (point$1) => toPath(sum$12(line3, point$1)),
    divide: (point$1) => toPath(divide(line3, point$1)),
    multiply: (point$1) => toPath(multiply(line3, point$1)),
    subtract: (point$1) => toPath(subtract$1(line3, point$1)),
    midpoint: () => midpoint(a3, b3),
    distanceToPoint: (point$1) => distanceSingleLine(line3, point$1),
    parallel: (distance$2) => parallel(line3, distance$2),
    perpendicularPoint: (distance$2, amount) => perpendicularPoint(line3, distance$2, amount),
    slope: () => slope(line3),
    withinRange: (point$1, maxRange) => withinRange$1(line3, point$1, maxRange),
    isEqual: (otherLine) => isEqual$4(line3, otherLine),
    apply: (fn2) => toPath(apply$1(line3, fn2)),
    kind: `line`
  });
};
var fromPointsToPath = (a3, b3) => toPath(fromPoints$2(a3, b3));
var line_exports = {};
__export(line_exports, {
  Empty: () => Empty$2,
  Placeholder: () => Placeholder$3,
  angleRadian: () => angleRadian$1,
  apply: () => apply$1,
  asPoints: () => asPoints,
  bbox: () => bbox$5,
  distance: () => distance$1,
  distanceSingleLine: () => distanceSingleLine,
  divide: () => divide,
  extendFromA: () => extendFromA,
  fromFlatArray: () => fromFlatArray$1,
  fromNumbers: () => fromNumbers$1,
  fromPivot: () => fromPivot,
  fromPoints: () => fromPoints$2,
  fromPointsToPath: () => fromPointsToPath,
  getPointParameter: () => getPointParameter$1,
  guard: () => guard$4,
  interpolate: () => interpolate$2,
  isEmpty: () => isEmpty$2,
  isEqual: () => isEqual$4,
  isLine: () => isLine,
  isPlaceholder: () => isPlaceholder$2,
  isPolyLine: () => isPolyLine,
  joinPointsToLines: () => joinPointsToLines,
  length: () => length,
  midpoint: () => midpoint,
  multiply: () => multiply,
  nearest: () => nearest$1,
  normaliseByRect: () => normaliseByRect$1,
  parallel: () => parallel,
  perpendicularPoint: () => perpendicularPoint,
  pointAtDistance: () => pointAtDistance,
  pointAtX: () => pointAtX,
  pointsOf: () => pointsOf,
  relativePosition: () => relativePosition$1,
  reverse: () => reverse,
  rotate: () => rotate$3,
  scaleFromMidpoint: () => scaleFromMidpoint,
  slope: () => slope,
  subtract: () => subtract$1,
  sum: () => sum$12,
  toFlatArray: () => toFlatArray$1,
  toPath: () => toPath,
  toString: () => toString$13,
  toSvgString: () => toSvgString$1,
  withinRange: () => withinRange$1
});
var Empty$2 = Object.freeze({
  a: Object.freeze({
    x: 0,
    y: 0
  }),
  b: Object.freeze({
    x: 0,
    y: 0
  })
});
var Placeholder$3 = Object.freeze({
  a: Object.freeze({
    x: NaN,
    y: NaN
  }),
  b: Object.freeze({
    x: NaN,
    y: NaN
  })
});
var isEmpty$2 = (l3) => isEmpty3(l3.a) && isEmpty3(l3.b);
var isPlaceholder$2 = (l3) => isPlaceholder(l3.a) && isPlaceholder(l3.b);
var apply$1 = (line3, fn2) => Object.freeze({
  ...line3,
  a: fn2(line3.a),
  b: fn2(line3.b)
});
var angleRadian$1 = (lineOrPoint, b3) => {
  let a3;
  if (isLine(lineOrPoint)) {
    a3 = lineOrPoint.a;
    b3 = lineOrPoint.b;
  } else {
    a3 = lineOrPoint;
    if (b3 === void 0) throw new Error(`b point must be provided`);
  }
  return Math.atan2(b3.y - a3.y, b3.x - a3.x);
};
var normaliseByRect$1 = (line3, width, height$3) => Object.freeze({
  ...line3,
  a: normaliseByRect(line3.a, width, height$3),
  b: normaliseByRect(line3.b, width, height$3)
});
var withinRange$1 = (line3, point$1, maxRange) => {
  const calculatedDistance = distance$1(line3, point$1);
  return calculatedDistance <= maxRange;
};
var slope = (lineOrPoint, b3) => {
  let a3;
  if (isLine(lineOrPoint)) {
    a3 = lineOrPoint.a;
    b3 = lineOrPoint.b;
  } else {
    a3 = lineOrPoint;
    if (b3 === void 0) throw new Error(`b parameter required`);
  }
  if (b3 === void 0) throw new TypeError(`Second point missing`);
  else return (b3.y - a3.y) / (b3.x - a3.x);
};
var scaleFromMidpoint = (line3, factor) => {
  const a3 = interpolate$2(factor / 2, line3);
  const b3 = interpolate$2(0.5 + factor / 2, line3);
  return {
    a: a3,
    b: b3
  };
};
var pointAtX = (line3, x3) => {
  const y3 = line3.a.y + (x3 - line3.a.x) * slope(line3);
  return Object.freeze({
    x: x3,
    y: y3
  });
};
var extendFromA = (line3, distance$2) => {
  const calculatedLength = length(line3);
  return Object.freeze({
    ...line3,
    a: line3.a,
    b: Object.freeze({
      x: line3.b.x + (line3.b.x - line3.a.x) / calculatedLength * distance$2,
      y: line3.b.y + (line3.b.y - line3.a.y) / calculatedLength * distance$2
    })
  });
};
function* pointsOf(line3) {
  const { a: a3, b: b3 } = line3;
  let x0 = Math.floor(a3.x);
  let y0 = Math.floor(a3.y);
  const x1 = Math.floor(b3.x);
  const y1 = Math.floor(b3.y);
  const dx = Math.abs(x1 - x0);
  const dy = -Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while (true) {
    yield {
      x: x0,
      y: y0
    };
    if (x0 === x1 && y0 === y1) break;
    const e22 = 2 * err;
    if (e22 >= dy) {
      err += dy;
      x0 += sx;
    }
    if (e22 <= dx) {
      err += dx;
      y0 += sy;
    }
  }
}
var distance$1 = (line3, point$1) => {
  if (Array.isArray(line3)) {
    const distances = line3.map((l3) => distanceSingleLine(l3, point$1));
    return minFast(distances);
  } else return distanceSingleLine(line3, point$1);
};
var toFlatArray$1 = (a3, b3) => {
  if (isLine(a3)) return [
    a3.a.x,
    a3.a.y,
    a3.b.x,
    a3.b.y
  ];
  else if (isPoint(a3) && isPoint(b3)) return [
    a3.x,
    a3.y,
    b3.x,
    b3.y
  ];
  else throw new Error(`Expected single line parameter, or a and b points`);
};
function* asPoints(lines) {
  for (const l3 of lines) {
    yield l3.a;
    yield l3.b;
  }
}
var toSvgString$1 = (a3, b3) => [`M${a3.x} ${a3.y} L ${b3.x} ${b3.y}`];
var relation = (a3, b3) => {
  const start = getPointParameter(a3, b3);
  let totalX = 0;
  let totalY = 0;
  let count3 = 0;
  let lastUpdate = performance.now();
  let lastPoint = start;
  const update = (aa2, bb) => {
    const p3 = getPointParameter(aa2, bb);
    totalX += p3.x;
    totalY += p3.y;
    count3++;
    const distanceFromStart = distance3(p3, start);
    const distanceFromLast = distance3(p3, lastPoint);
    const now = performance.now();
    const speed = distanceFromLast / (now - lastUpdate);
    lastUpdate = now;
    lastPoint = p3;
    return Object.freeze({
      angle: angleRadian(p3, start),
      distanceFromStart,
      distanceFromLast,
      speed,
      centroid: centroid$1(p3, start),
      average: {
        x: totalX / count3,
        y: totalY / count3
      }
    });
  };
  return update;
};
var PointTracker = class extends ObjectTracker {
  initialRelation;
  markRelation;
  lastResult;
  constructor(opts = {}) {
    super(opts);
  }
  /**
  * Notification that buffer has been knocked down to `sampleLimit`.
  *
  * This will reset the `initialRelation`, which will use the new oldest value.
  */
  onTrimmed(_reason) {
    this.initialRelation = void 0;
  }
  /**
  * @ignore
  */
  onReset() {
    super.onReset();
    this.lastResult = void 0;
    this.initialRelation = void 0;
    this.markRelation = void 0;
  }
  /**
  * Makes a 'mark' in the tracker, allowing you to compare values
  * to this point.
  */
  mark() {
    this.markRelation = relation(this.last);
  }
  /**
  * Tracks a point, returning data on its relation to the
  * initial point and the last received point.
  *
  * Use {@link seenEvent} to track a raw `PointerEvent`.
  *
  * @param _p Point
  */
  computeResults(_p) {
    const currentLast = this.last;
    const previousLast = this.values.at(-2);
    if (this.initialRelation === void 0 && this.initial) this.initialRelation = relation(this.initial);
    else if (this.initialRelation === void 0) throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);
    const lastRelation = previousLast === void 0 ? relation(currentLast) : relation(previousLast);
    const initialRel = this.initialRelation(currentLast);
    const markRel = this.markRelation !== void 0 ? this.markRelation(currentLast) : void 0;
    const speed = previousLast === void 0 ? 0 : length(previousLast, currentLast) / (currentLast.at - previousLast.at);
    const lastRel = {
      ...lastRelation(currentLast),
      speed
    };
    const r5 = {
      fromInitial: initialRel,
      fromLast: lastRel,
      fromMark: markRel,
      values: [...this.values]
    };
    this.lastResult = r5;
    return r5;
  }
  /**
  * Returns a polyline representation of stored points.
  * Returns an empty array if points were not saved, or there's only one.
  */
  get line() {
    if (this.values.length === 1) return [];
    return joinPointsToLines(...this.values);
  }
  /**
  * Returns a vector of the initial/last points of the tracker.
  * Returns as a polar coordinate
  */
  get vectorPolar() {
    return fromLinePolar(this.lineStartEnd);
  }
  /**
  * Returns a vector of the initial/last points of the tracker.
  * Returns as a Cartesian coordinate
  */
  get vectorCartesian() {
    return fromLineCartesian(this.lineStartEnd);
  }
  /**
  * Returns a line from initial point to last point.
  *
  * If there are less than two points, Lines.Empty is returned
  */
  get lineStartEnd() {
    const initial = this.initial;
    if (this.values.length < 2 || !initial) return Empty$2;
    return {
      a: initial,
      b: this.last
    };
  }
  /**
  * Returns distance from latest point to initial point.
  * If there are less than two points, zero is returned.
  *
  * This is the direct distance from initial to last,
  * not the accumulated length. Use {@link length} for that.
  * @returns Distance
  */
  distanceFromStart() {
    const initial = this.initial;
    return this.values.length >= 2 && initial !== void 0 ? distance3(initial, this.last) : 0;
  }
  /**
  * Returns the speed (over milliseconds) based on accumulated travel distance.
  *
  * If there's no initial point, 0 is returned.
  * @returns
  */
  speedFromStart() {
    const d3 = this.length;
    const t6 = this.timespan;
    if (Number.isNaN(t6)) return 0;
    if (d3 === 0) return 0;
    return Math.abs(d3) / t6;
  }
  /**
  * Difference between last point and the initial point, calculated
  * as a simple subtraction of x,y & z.
  *
  * `Points.Placeholder` is returned if there's only one point so far.
  */
  difference() {
    const initial = this.initial;
    return this.values.length >= 2 && initial !== void 0 ? subtract(this.last, initial) : Placeholder$2;
  }
  /**
  * Returns angle (in radians) from latest point to the initial point
  * If there are less than two points, undefined is return.
  * @returns Angle in radians
  */
  angleFromStart() {
    const initial = this.initial;
    if (initial !== void 0 && this.values.length > 2) return angleRadian(initial, this.last);
  }
  /**
  * Returns the total distance from accumulated points.
  * Returns 0 if points were not saved, or there's only one
  */
  get length() {
    if (this.values.length === 1) return 0;
    const l3 = this.line;
    return length(l3);
  }
  /**
  * Returns the last x coord
  */
  get x() {
    return this.last.x;
  }
  /**
  * Returns the last y coord
  */
  get y() {
    return this.last.y;
  }
  /**
  * Returns the last z coord (or _undefined_ if not available)
  */
  get z() {
    return this.last.z;
  }
};
var PointsTracker = class extends TrackedValueMap {
  constructor(opts = {}) {
    super((key, start) => {
      if (start === void 0) throw new Error(`Requires start point`);
      const p3 = new PointTracker({
        ...opts,
        id: key
      });
      p3.seen(start);
      return p3;
    });
  }
  get(id) {
    const v3 = super.get(id);
    return v3;
  }
};
var UserPointerTracker = class extends PointTracker {
  /**
  * Adds a PointerEvent along with its
  * coalesced events, if available.
  * @param p
  * @returns
  */
  seenEvent(p3) {
    if (`getCoalescedEvents` in p3) {
      const events = p3.getCoalescedEvents();
      const asPoints$1 = events.map((event2) => ({
        x: event2.clientX,
        y: event2.clientY
      }));
      return this.seen(...asPoints$1);
    } else return this.seen({
      x: p3.clientX,
      y: p3.clientY
    });
  }
};
var UserPointersTracker = class extends TrackedValueMap {
  constructor(opts = {}) {
    super((key, start) => {
      if (start === void 0) throw new Error(`Requires start point`);
      const p3 = new UserPointerTracker({
        ...opts,
        id: key
      });
      p3.seen(start);
      return p3;
    });
  }
  get(id) {
    const v3 = super.get(id);
    return v3;
  }
  /**
  * Track a PointerEvent
  * @param event
  */
  seenEvent(event2) {
    if (`getCoalescedEvents` in event2) {
      const events = event2.getCoalescedEvents();
      const seens = events.map((subEvent) => super.seen(subEvent.pointerId.toString(), subEvent));
      return Promise.all(seens);
    } else return Promise.all([super.seen(event2.pointerId.toString(), event2)]);
  }
};
var progressBetween = (position, waypointA, waypointB) => {
  const a3 = subtract(position, waypointA);
  const b3 = subtract(waypointB, waypointA);
  return isPoint3d(a3) && isPoint3d(b3) ? (a3.x * b3.x + a3.y * b3.y + a3.z * b3.z) / (b3.x * b3.x + b3.y * b3.y + b3.z * b3.z) : (a3.x * b3.x + a3.y * b3.y) / (b3.x * b3.x + b3.y * b3.y);
};
var project = (origin, distance$2, angle) => {
  const x3 = Math.cos(angle) * distance$2 + origin.x;
  const y3 = Math.sin(angle) * distance$2 + origin.y;
  return {
    x: x3,
    y: y3
  };
};
function quantiseEvery$1(pt2, snap, middleRoundsUp = true) {
  guard$1(pt2, `pt`);
  guard$1(snap, `snap`);
  if (isPoint3d(pt2)) {
    if (!isPoint3d(snap)) throw new TypeError(`Param 'snap' is missing 'z' field`);
    return Object.freeze({
      x: quantiseEvery(pt2.x, snap.x, middleRoundsUp),
      y: quantiseEvery(pt2.y, snap.y, middleRoundsUp),
      z: quantiseEvery(pt2.z, snap.z, middleRoundsUp)
    });
  }
  return Object.freeze({
    x: quantiseEvery(pt2.x, snap.x, middleRoundsUp),
    y: quantiseEvery(pt2.y, snap.y, middleRoundsUp)
  });
}
var random$1 = (rando) => {
  if (typeof rando === `undefined`) rando = Math.random;
  return Object.freeze({
    x: rando(),
    y: rando()
  });
};
var random3d = (rando) => {
  if (typeof rando === `undefined`) rando = Math.random;
  return Object.freeze({
    x: rando(),
    y: rando(),
    z: rando()
  });
};
var reduce2 = (pts, fn2, initial) => {
  if (initial === void 0) initial = {
    x: 0,
    y: 0
  };
  let accumulator = initial;
  for (const p3 of pts) accumulator = fn2(p3, accumulator);
  return accumulator;
};
function rotate(pt2, amountRadian, origin) {
  if (typeof origin === `undefined`) origin = {
    x: 0,
    y: 0
  };
  guard$1(origin, `origin`);
  resultThrow(numberTest(amountRadian, ``, `amountRadian`));
  const arrayInput = Array.isArray(pt2);
  if (amountRadian === 0) return pt2;
  if (!arrayInput) pt2 = [pt2];
  const ptAr = pt2;
  for (const [index, p3] of ptAr.entries()) guard$1(p3, `pt[${index}]`);
  const asPolar = ptAr.map((p3) => fromCartesian(p3, origin));
  const rotated = asPolar.map((p3) => rotate$2(p3, amountRadian));
  const asCartesisan = rotated.map((p3) => toCartesian(p3, origin));
  return arrayInput ? asCartesisan : asCartesisan[0];
}
var rotatePointArray = (v3, amountRadian) => {
  const mat = [[Math.cos(amountRadian), -Math.sin(amountRadian)], [Math.sin(amountRadian), Math.cos(amountRadian)]];
  const result = [];
  for (const [index, element] of v3.entries()) result[index] = [mat[0][0] * element[0] + mat[0][1] * element[1], mat[1][0] * element[0] + mat[1][1] * element[1]];
  return result;
};
var round$1 = (ptOrX, yOrDigits, digits) => {
  const pt2 = getPointParameter(ptOrX, yOrDigits);
  digits = digits ?? yOrDigits;
  digits = digits ?? 2;
  return Object.freeze({
    ...pt2,
    x: round2(digits, pt2.x),
    y: round2(digits, pt2.y)
  });
};
var withinRange = (a3, b3, maxRange) => {
  guard$1(a3, `a`);
  guard$1(b3, `b`);
  if (typeof maxRange === `number`) {
    resultThrow(numberTest(maxRange, `positive`, `maxRange`));
    maxRange = {
      x: maxRange,
      y: maxRange
    };
  } else guard$1(maxRange, `maxRange`);
  const x3 = Math.abs(b3.x - a3.x);
  const y3 = Math.abs(b3.y - a3.y);
  return x3 <= maxRange.x && y3 <= maxRange.y;
};
var wrap$3 = (pt2, ptMax, ptMin) => {
  if (ptMax === void 0) ptMax = {
    x: 1,
    y: 1
  };
  if (ptMin === void 0) ptMin = {
    x: 0,
    y: 0
  };
  guard$1(pt2, `pt`);
  guard$1(ptMax, `ptMax`);
  guard$1(ptMin, `ptMin`);
  return Object.freeze({
    x: wrap2(pt2.x, ptMin.x, ptMax.x),
    y: wrap2(pt2.y, ptMin.y, ptMax.y)
  });
};
var point_exports = {};
__export(point_exports, {
  Empty: () => Empty,
  Empty3d: () => Empty3d,
  Placeholder: () => Placeholder$2,
  Placeholder3d: () => Placeholder3d,
  PointTracker: () => PointTracker,
  PointsTracker: () => PointsTracker,
  Unit: () => Unit,
  Unit3d: () => Unit3d,
  UserPointerTracker: () => UserPointerTracker,
  UserPointersTracker: () => UserPointersTracker,
  abs: () => abs2,
  angleRadian: () => angleRadian,
  angleRadianCircle: () => angleRadianCircle,
  apply: () => apply$2,
  averager: () => averager,
  bbox: () => bbox$1,
  bbox3d: () => bbox3d,
  centroid: () => centroid$1,
  clamp: () => clamp$12,
  clampMagnitude: () => clampMagnitude,
  compare: () => compare3,
  compareByX: () => compareByX,
  compareByY: () => compareByY,
  compareByZ: () => compareByZ,
  convexHull: () => convexHull,
  distance: () => distance3,
  distanceToCenter: () => distanceToCenter,
  distanceToExterior: () => distanceToExterior,
  divide: () => divide$1,
  divider: () => divider,
  dotProduct: () => dotProduct$1,
  findMinimum: () => findMinimum,
  from: () => from,
  fromNumbers: () => fromNumbers,
  fromString: () => fromString,
  getPointParameter: () => getPointParameter,
  getTwoPointParameters: () => getTwoPointParameters,
  guard: () => guard$1,
  guardNonZeroPoint: () => guardNonZeroPoint,
  interpolate: () => interpolate$4,
  invert: () => invert$1,
  isEmpty: () => isEmpty3,
  isEqual: () => isEqual2,
  isNaN: () => isNaN$1,
  isNull: () => isNull,
  isPlaceholder: () => isPlaceholder,
  isPoint: () => isPoint,
  isPoint3d: () => isPoint3d,
  leftmost: () => leftmost,
  multiply: () => multiply$1,
  multiplyScalar: () => multiplyScalar,
  normalise: () => normalise,
  normaliseByRect: () => normaliseByRect,
  pipeline: () => pipeline,
  pipelineApply: () => pipelineApply,
  progressBetween: () => progressBetween,
  project: () => project,
  quantiseEvery: () => quantiseEvery$1,
  random: () => random$1,
  random3d: () => random3d,
  reduce: () => reduce2,
  relation: () => relation,
  rightmost: () => rightmost,
  rotate: () => rotate,
  rotatePointArray: () => rotatePointArray,
  round: () => round$1,
  subtract: () => subtract,
  sum: () => sum2,
  test: () => test,
  to2d: () => to2d,
  to3d: () => to3d,
  toArray: () => toArray3,
  toIntegerValues: () => toIntegerValues,
  toString: () => toString$2,
  withinRange: () => withinRange,
  wrap: () => wrap$3
});
var arc_exports = {};
__export(arc_exports, {
  angularSize: () => angularSize,
  bbox: () => bbox$4,
  distanceCenter: () => distanceCenter$1,
  fromCircle: () => fromCircle,
  fromCircleAmount: () => fromCircleAmount,
  fromDegrees: () => fromDegrees$1,
  getStartEnd: () => getStartEnd,
  guard: () => guard$3,
  interpolate: () => interpolate$3,
  isArc: () => isArc,
  isEqual: () => isEqual$3,
  isPositioned: () => isPositioned,
  length: () => length$2,
  point: () => point,
  toLine: () => toLine,
  toPath: () => toPath$3,
  toSvg: () => toSvg$1
});
var isArc = (p3) => typeof p3.startRadian !== `undefined` && typeof p3.endRadian !== `undefined` && typeof p3.clockwise !== `undefined`;
var isPositioned = (p3) => typeof p3.x !== `undefined` && typeof p3.y !== `undefined`;
function fromDegrees$1(radius, startDegrees, endDegrees, clockwise, origin) {
  const a3 = {
    radius,
    startRadian: degreeToRadian(startDegrees),
    endRadian: degreeToRadian(endDegrees),
    clockwise
  };
  if (isPoint(origin)) {
    guard$1(origin);
    const ap = {
      ...a3,
      x: origin.x,
      y: origin.y
    };
    return Object.freeze(ap);
  } else return Object.freeze(a3);
}
var toLine = (arc3) => fromPoints$2(point(arc3, arc3.startRadian), point(arc3, arc3.endRadian));
var getStartEnd = (arc3, origin) => {
  guard$3(arc3);
  const start = point(arc3, arc3.startRadian, origin);
  const end = point(arc3, arc3.endRadian, origin);
  return [start, end];
};
var point = (arc3, angleRadian$2, origin) => {
  if (typeof origin === `undefined`) origin = isPositioned(arc3) ? arc3 : {
    x: 0,
    y: 0
  };
  return {
    x: Math.cos(angleRadian$2) * arc3.radius + origin.x,
    y: Math.sin(angleRadian$2) * arc3.radius + origin.y
  };
};
var guard$3 = (arc3) => {
  if (typeof arc3 === `undefined`) throw new TypeError(`Arc is undefined`);
  if (isPositioned(arc3)) guard$1(arc3, `arc`);
  if (typeof arc3.radius === `undefined`) throw new TypeError(`Arc radius is undefined (${JSON.stringify(arc3)})`);
  if (typeof arc3.radius !== `number`) throw new TypeError(`Radius must be a number`);
  if (Number.isNaN(arc3.radius)) throw new TypeError(`Radius is NaN`);
  if (arc3.radius <= 0) throw new TypeError(`Radius must be greater than zero`);
  if (typeof arc3.startRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);
  if (typeof arc3.endRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);
  if (Number.isNaN(arc3.endRadian)) throw new TypeError(`Arc endRadian is NaN`);
  if (Number.isNaN(arc3.startRadian)) throw new TypeError(`Arc endRadian is NaN`);
  if (typeof arc3.clockwise === `undefined`) throw new TypeError(`Arc is missing 'clockwise field`);
  if (arc3.startRadian >= arc3.endRadian) throw new TypeError(`startRadian is expected to be les than endRadian`);
};
var interpolate$3 = (amount, arc3, allowOverflow, origin) => {
  guard$3(arc3);
  const overflowOk = allowOverflow ?? false;
  if (!overflowOk) {
    if (amount < 0) throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);
    if (amount > 1) throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);
  }
  const span = angularSize(arc3);
  const rel = span * amount;
  const angle = radiansSum(arc3.startRadian, rel, arc3.clockwise);
  return point(arc3, angle, origin);
};
var angularSize = (arc3) => radianArc(arc3.startRadian, arc3.endRadian, arc3.clockwise);
var toPath$3 = (arc3) => {
  guard$3(arc3);
  return Object.freeze({
    ...arc3,
    nearest: (_point) => {
      throw new Error(`not implemented`);
    },
    interpolate: (amount) => interpolate$3(amount, arc3),
    bbox: () => bbox$4(arc3),
    length: () => length$2(arc3),
    toSvgString: () => toSvg$1(arc3),
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    kind: `arc`
  });
};
var fromCircle = (circle3, startRadian, endRadian, clockwise = true) => {
  const a3 = Object.freeze({
    ...circle3,
    endRadian,
    startRadian,
    clockwise
  });
  return a3;
};
var fromCircleAmount = (circle3, startRadian, sizeRadian, clockwise = true) => {
  const endRadian = radiansSum(startRadian, sizeRadian, clockwise);
  return fromCircle(circle3, startRadian, endRadian);
};
var length$2 = (arc3) => piPi2 * arc3.radius * ((arc3.startRadian - arc3.endRadian) / piPi2);
var bbox$4 = (arc3) => {
  if (isPositioned(arc3)) {
    const middle = interpolate$3(0.5, arc3);
    const asLine = toLine(arc3);
    return bbox$1(middle, asLine.a, asLine.b);
  } else return {
    width: arc3.radius * 2,
    height: arc3.radius * 2
  };
};
var toSvg$1 = (a3, b3, c5, d3, e5) => {
  if (isArc(a3)) if (isPositioned(a3)) if (isPoint(b3)) return toSvgFull$1(b3, a3.radius, a3.startRadian, a3.endRadian, c5);
  else return toSvgFull$1(a3, a3.radius, a3.startRadian, a3.endRadian, b3);
  else return isPoint(b3) ? toSvgFull$1(b3, a3.radius, a3.startRadian, a3.endRadian, c5) : toSvgFull$1({
    x: 0,
    y: 0
  }, a3.radius, a3.startRadian, a3.endRadian);
  else {
    if (c5 === void 0) throw new Error(`startAngle undefined`);
    if (d3 === void 0) throw new Error(`endAngle undefined`);
    if (isPoint(a3)) if (typeof b3 === `number` && typeof c5 === `number` && typeof d3 === `number`) return toSvgFull$1(a3, b3, c5, d3, e5);
    else throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);
    else throw new Error(`Expected (point, number, number, number). Missing first point.`);
  }
};
var toSvgFull$1 = (origin, radius, startRadian, endRadian, opts) => {
  if (opts === void 0 || typeof opts !== `object`) opts = {};
  const isFullCircle = endRadian - startRadian === 360;
  const start = toCartesian(radius, endRadian - 0.01, origin);
  const end = toCartesian(radius, startRadian, origin);
  const { largeArc = false, sweep = false } = opts;
  const d3 = [`
    M ${start.x} ${start.y}
    A ${radius} ${radius} 0 ${largeArc ? `1` : `0`} ${sweep ? `1` : `0`} ${end.x} ${end.y},
  `];
  if (isFullCircle) d3.push(`z`);
  return d3;
};
var distanceCenter$1 = (a3, b3) => distance3(a3, b3);
var isEqual$3 = (a3, b3) => {
  if (a3.radius !== b3.radius) return false;
  if (a3.endRadian !== b3.endRadian) return false;
  if (a3.startRadian !== b3.startRadian) return false;
  if (a3.clockwise !== b3.clockwise) return false;
  if (isPositioned(a3) && isPositioned(b3)) {
    if (a3.x !== b3.x) return false;
    if (a3.y !== b3.y) return false;
    if (a3.z !== b3.z) return false;
  } else if (!isPositioned(a3) && !isPositioned(b3)) {
  } else return false;
  return true;
};
var isQuadraticBezier = (path3) => path3.quadratic !== void 0;
var isCubicBezier = (path3) => path3.cubic1 !== void 0 && path3.cubic2 !== void 0;
var bezier_exports = {};
__export(bezier_exports, {
  cubic: () => cubic,
  interpolator: () => interpolator,
  isCubicBezier: () => isCubicBezier,
  isQuadraticBezier: () => isQuadraticBezier,
  quadratic: () => quadratic,
  quadraticSimple: () => quadraticSimple,
  quadraticToSvgString: () => quadraticToSvgString,
  toPath: () => toPath$2
});
var quadraticSimple = (start, end, bend = 0) => {
  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);
  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);
  const middle = interpolate$2(0.5, start, end);
  let target = middle;
  if (end.y < start.y) target = bend > 0 ? {
    x: Math.min(start.x, end.x),
    y: Math.min(start.y, end.y)
  } : {
    x: Math.max(start.x, end.x),
    y: Math.max(start.y, end.y)
  };
  else target = bend > 0 ? {
    x: Math.max(start.x, end.x),
    y: Math.min(start.y, end.y)
  } : {
    x: Math.min(start.x, end.x),
    y: Math.max(start.y, end.y)
  };
  const handle = interpolate$2(Math.abs(bend), middle, target);
  return quadratic(start, end, handle);
};
var interpolator = (q3) => {
  const bzr = isCubicBezier(q3) ? new Bezier(q3.a.x, q3.a.y, q3.cubic1.x, q3.cubic1.y, q3.cubic2.x, q3.cubic2.y, q3.b.x, q3.b.y) : new Bezier(q3.a, q3.quadratic, q3.b);
  return (amount) => bzr.compute(amount);
};
var quadraticToSvgString = (start, end, handle) => [`M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`];
var toPath$2 = (cubicOrQuadratic) => {
  if (isCubicBezier(cubicOrQuadratic)) return cubicToPath(cubicOrQuadratic);
  else if (isQuadraticBezier(cubicOrQuadratic)) return quadratictoPath(cubicOrQuadratic);
  else throw new Error(`Unknown bezier type`);
};
var cubic = (start, end, cubic1, cubic22) => ({
  a: Object.freeze(start),
  b: Object.freeze(end),
  cubic1: Object.freeze(cubic1),
  cubic2: Object.freeze(cubic22)
});
var cubicToPath = (cubic$1) => {
  const { a: a3, cubic1, cubic2: cubic22, b: b3 } = cubic$1;
  const bzr = new Bezier(a3, cubic1, cubic22, b3);
  return Object.freeze({
    ...cubic$1,
    length: () => bzr.length(),
    interpolate: (t6) => bzr.compute(t6),
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    bbox: () => {
      const { x: x3, y: y3 } = bzr.bbox();
      const xSize = x3.size;
      const ySize = y3.size;
      if (xSize === void 0) throw new Error(`x.size not present on calculated bbox`);
      if (ySize === void 0) throw new Error(`x.size not present on calculated bbox`);
      return fromTopLeft({
        x: x3.min,
        y: y3.min
      }, xSize, ySize);
    },
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    toSvgString: () => [`brrup`],
    kind: `bezier/cubic`
  });
};
var quadratic = (start, end, handle) => ({
  a: Object.freeze(start),
  b: Object.freeze(end),
  quadratic: Object.freeze(handle)
});
var quadratictoPath = (quadraticBezier3) => {
  const { a: a3, b: b3, quadratic: quadratic$1 } = quadraticBezier3;
  const bzr = new Bezier(a3, quadratic$1, b3);
  return Object.freeze({
    ...quadraticBezier3,
    length: () => bzr.length(),
    interpolate: (t6) => bzr.compute(t6),
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    bbox: () => {
      const { x: x3, y: y3 } = bzr.bbox();
      const xSize = x3.size;
      const ySize = y3.size;
      if (xSize === void 0) throw new Error(`x.size not present on calculated bbox`);
      if (ySize === void 0) throw new Error(`x.size not present on calculated bbox`);
      return fromTopLeft({
        x: x3.min,
        y: y3.min
      }, xSize, ySize);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    toString: () => bzr.toString(),
    toSvgString: () => quadraticToSvgString(a3, b3, quadratic$1),
    kind: `bezier/quadratic`
  });
};
var area$4 = (circle3) => {
  guard$2(circle3);
  return Math.PI * circle3.radius * circle3.radius;
};
var bbox$3 = (circle3) => {
  return isCirclePositioned(circle3) ? fromCenter$2(circle3, circle3.radius * 2, circle3.radius * 2) : {
    width: circle3.radius * 2,
    height: circle3.radius * 2,
    x: 0,
    y: 0
  };
};
var center = (circle3) => {
  return isCirclePositioned(circle3) ? Object.freeze({
    x: circle3.x,
    y: circle3.y
  }) : Object.freeze({
    x: circle3.radius,
    y: circle3.radius
  });
};
function* exteriorIntegerPoints(circle3) {
  const { x: x3, y: y3, radius } = circle3;
  let xx = radius;
  let yy = 0;
  let radiusError = 1 - x3;
  while (xx >= yy) {
    yield {
      x: xx + x3,
      y: yy + y3
    };
    yield {
      x: yy + x3,
      y: xx + y3
    };
    yield {
      x: -xx + x3,
      y: yy + y3
    };
    yield {
      x: -yy + x3,
      y: xx + y3
    };
    yield {
      x: -xx + x3,
      y: -yy + y3
    };
    yield {
      x: -yy + x3,
      y: -xx + y3
    };
    yield {
      x: xx + x3,
      y: -yy + y3
    };
    yield {
      x: yy + x3,
      y: -xx + y3
    };
    yy++;
    if (radiusError < 0) radiusError += 2 * yy + 1;
    else {
      xx--;
      radiusError += 2 * (yy - xx + 1);
    }
  }
}
function* interiorIntegerPoints(circle3) {
  const xMin = circle3.x - circle3.radius;
  const xMax = circle3.x + circle3.radius;
  const yMin = circle3.y - circle3.radius;
  const yMax = circle3.y + circle3.radius;
  for (let x3 = xMin; x3 < xMax; x3++) for (let y3 = yMin; y3 < yMax; y3++) {
    const r5 = Math.abs(distance3(circle3, x3, y3));
    if (r5 <= circle3.radius) yield {
      x: x3,
      y: y3
    };
  }
}
var piPi$4 = Math.PI * 2;
var nearest = (circle3, point$1) => {
  const n6 = (a3) => {
    const l3 = Math.sqrt(Math.pow(point$1.x - a3.x, 2) + Math.pow(point$1.y - a3.y, 2));
    const x3 = a3.x + a3.radius * ((point$1.x - a3.x) / l3);
    const y3 = a3.y + a3.radius * ((point$1.y - a3.y) / l3);
    return {
      x: x3,
      y: y3
    };
  };
  if (Array.isArray(circle3)) {
    const pts = circle3.map((l3) => n6(l3));
    const dists = pts.map((p3) => distance3(p3, point$1));
    return Object.freeze(pts[minIndex(...dists)]);
  } else return Object.freeze(n6(circle3));
};
var pointOnPerimeter = (circle3, angleRadian$2, origin) => {
  if (origin === void 0) origin = isCirclePositioned(circle3) ? circle3 : {
    x: 0,
    y: 0
  };
  return {
    x: Math.cos(-angleRadian$2) * circle3.radius + origin.x,
    y: Math.sin(-angleRadian$2) * circle3.radius + origin.y
  };
};
var circumference = (circle3) => {
  guard$2(circle3);
  return piPi$4 * circle3.radius;
};
var length$1 = (circle3) => circumference(circle3);
var piPi$3 = Math.PI * 2;
var interpolate$1 = (circle3, t6) => pointOnPerimeter(circle3, t6 * piPi$3);
var isContainedBy = (a3, b3, c5) => {
  const d3 = distanceCenter(a3, b3);
  if (isCircle(b3)) return d3 < Math.abs(a3.radius - b3.radius);
  else if (isPoint(b3)) if (c5 === void 0) return d3 <= a3.radius;
  else return d3 < Math.abs(a3.radius - c5);
  else throw new Error(`b parameter is expected to be CirclePositioned or Point`);
};
var isIntersecting = (a3, b3, c5) => {
  if (isEqual2(a3, b3)) return true;
  if (isContainedBy(a3, b3, c5)) return true;
  if (isCircle(b3)) return circleCircle(a3, b3);
  else if (isRectPositioned(b3)) return circleRect(a3, b3);
  else if (isPoint(b3) && c5 !== void 0) return circleCircle(a3, {
    ...b3,
    radius: c5
  });
  return false;
};
function multiplyScalar$1(a3, value3) {
  if (isCirclePositioned(a3)) {
    const pt2 = multiplyScalar(a3, value3);
    return Object.freeze({
      ...a3,
      ...pt2,
      radius: a3.radius * value3
    });
  } else return Object.freeze({
    ...a3,
    radius: a3.radius * value3
  });
}
var piPi$2 = Math.PI * 2;
var randomPoint$1 = (within, opts = {}) => {
  const offset$1 = isCirclePositioned(within) ? within : {
    x: 0,
    y: 0
  };
  const strategy = opts.strategy ?? `uniform`;
  const margin = opts.margin ?? 0;
  const radius = within.radius - margin;
  const rand = opts.randomSource ?? Math.random;
  switch (strategy) {
    case `naive`:
      return sum2(offset$1, toCartesian(rand() * radius, rand() * piPi$2));
    case `uniform`:
      return sum2(offset$1, toCartesian(Math.sqrt(rand()) * radius, rand() * piPi$2));
    default:
      throw new Error(`Unknown strategy '${strategy}'. Expects 'uniform' or 'naive'`);
  }
};
var toSvg = (a3, sweep, origin) => {
  if (isCircle(a3)) {
    if (origin !== void 0) return toSvgFull(a3.radius, origin, sweep);
    if (isCirclePositioned(a3)) return toSvgFull(a3.radius, a3, sweep);
    else throw new Error(`origin parameter needed for non-positioned circle`);
  } else if (origin === void 0) throw new Error(`origin parameter needed`);
  else return toSvgFull(a3, origin, sweep);
};
var toSvgFull = (radius, origin, sweep) => {
  const { x: x3, y: y3 } = origin;
  const s3 = sweep ? `1` : `0`;
  return `
    M ${x3}, ${y3}
    m -${radius}, 0
    a ${radius},${radius} 0 1,${s3} ${radius * 2},0
    a ${radius},${radius} 0 1,${s3} -${radius * 2},0
  `.split(`
`);
};
var toPath$1 = (circle3) => {
  guard$2(circle3);
  return {
    ...circle3,
    nearest: (point$1) => nearest(circle3, point$1),
    interpolate: (t6) => interpolate$1(circle3, t6),
    bbox: () => bbox$3(circle3),
    length: () => circumference(circle3),
    toSvgString: (sweep = true) => toSvg(circle3, sweep),
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    kind: `circular`
  };
};
var toPositioned = (circle3, defaultPositionOrX, y3) => {
  if (isCirclePositioned(circle3)) return circle3;
  const pt2 = getPointParameter(defaultPositionOrX, y3);
  return Object.freeze({
    ...circle3,
    ...pt2
  });
};
var circle_exports = {};
__export(circle_exports, {
  area: () => area$4,
  bbox: () => bbox$3,
  center: () => center,
  circumference: () => circumference,
  distanceCenter: () => distanceCenter,
  distanceFromExterior: () => distanceFromExterior$1,
  exteriorIntegerPoints: () => exteriorIntegerPoints,
  guard: () => guard$2,
  guardPositioned: () => guardPositioned,
  interiorIntegerPoints: () => interiorIntegerPoints,
  interpolate: () => interpolate$1,
  intersectionLine: () => intersectionLine,
  intersections: () => intersections,
  isCircle: () => isCircle,
  isCirclePositioned: () => isCirclePositioned,
  isContainedBy: () => isContainedBy,
  isEqual: () => isEqual$6,
  isIntersecting: () => isIntersecting,
  isNaN: () => isNaN2,
  isPositioned: () => isPositioned$2,
  length: () => length$1,
  multiplyScalar: () => multiplyScalar$1,
  nearest: () => nearest,
  pointOnPerimeter: () => pointOnPerimeter,
  randomPoint: () => randomPoint$1,
  toPath: () => toPath$1,
  toPositioned: () => toPositioned,
  toSvg: () => toSvg
});
var inside = (grid3, cell) => {
  if (cell.x < 0 || cell.y < 0) return false;
  if (cell.x >= grid3.cols || cell.y >= grid3.rows) return false;
  return true;
};
var isCell = (cell) => {
  if (cell === void 0) return false;
  return `x` in cell && `y` in cell;
};
var guardCell = (cell, parameterName = `Param`, grid3) => {
  if (cell === void 0) throw new Error(parameterName + ` is undefined. Expecting {x,y}`);
  if (cell.x === void 0) throw new Error(parameterName + `.x is undefined`);
  if (cell.y === void 0) throw new Error(parameterName + `.y is undefined`);
  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);
  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);
  if (!Number.isInteger(cell.x)) throw new TypeError(parameterName + `.x is non-integer`);
  if (!Number.isInteger(cell.y)) throw new TypeError(parameterName + `.y is non-integer`);
  if (grid3 !== void 0 && !inside(grid3, cell)) throw new Error(`${parameterName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid3.cols}, ${grid3.rows}`);
};
var guardGrid = (grid3, parameterName = `Param`) => {
  if (grid3 === void 0) throw new Error(`${parameterName} is undefined. Expecting grid.`);
  if (!(`rows` in grid3)) throw new Error(`${parameterName}.rows is undefined`);
  if (!(`cols` in grid3)) throw new Error(`${parameterName}.cols is undefined`);
  if (!Number.isInteger(grid3.rows)) throw new TypeError(`${parameterName}.rows is not an integer`);
  if (!Number.isInteger(grid3.cols)) throw new TypeError(`${parameterName}.cols is not an integer`);
};
var applyBounds = function(grid3, cell, wrap$4 = `undefined`) {
  guardGrid(grid3, `grid`);
  guardCell(cell, `cell`);
  let x3 = cell.x;
  let y3 = cell.y;
  switch (wrap$4) {
    case `wrap`: {
      x3 = x3 % grid3.cols;
      y3 = y3 % grid3.rows;
      if (x3 < 0) x3 = grid3.cols + x3;
      else if (x3 >= grid3.cols) x3 -= grid3.cols;
      if (y3 < 0) y3 = grid3.rows + y3;
      else if (y3 >= grid3.rows) y3 -= grid3.rows;
      x3 = Math.abs(x3);
      y3 = Math.abs(y3);
      break;
    }
    case `stop`: {
      x3 = clampIndex(x3, grid3.cols);
      y3 = clampIndex(y3, grid3.rows);
      break;
    }
    case `undefined`: {
      if (x3 < 0 || y3 < 0) return;
      if (x3 >= grid3.cols || y3 >= grid3.rows) return;
      break;
    }
    case `unbounded`:
      break;
    default:
      throw new Error(`Unknown BoundsLogic '${wrap$4}'. Expected: wrap, stop, undefined or unbounded`);
  }
  return Object.freeze({
    x: x3,
    y: y3
  });
};
var array_1d_exports = {};
__export(array_1d_exports, {
  access: () => access$1,
  createArray: () => createArray,
  createMutable: () => createMutable,
  set: () => set$1,
  setMutate: () => setMutate$1,
  wrap: () => wrap$2,
  wrapMutable: () => wrapMutable$1
});
var access$1 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions(array3, cols);
  const fn2 = (cell, wrap$4 = `undefined`) => accessWithGrid$1(grid3, array3, cell, wrap$4);
  return fn2;
};
var accessWithGrid$1 = (grid3, array3, cell, wrap$4) => {
  const index = indexFromCell(grid3, cell, wrap$4);
  if (index === void 0) return void 0;
  return array3[index];
};
var setMutate$1 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions(array3, cols);
  return (value3, cell, wrap$4 = `undefined`) => setMutateWithGrid$1(grid3, array3, value3, cell, wrap$4);
};
var setMutateWithGrid$1 = (grid3, array3, value3, cell, wrap$4) => {
  const index = indexFromCell(grid3, cell, wrap$4);
  if (index === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  array3[index] = value3;
  return array3;
};
var set$1 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions(array3, cols);
  return (value3, cell, wrap$4) => setWithGrid$1(grid3, array3, value3, cell, wrap$4);
};
var setWithGrid$1 = (grid3, array3, value3, cell, wrap$4) => {
  const index = indexFromCell(grid3, cell, wrap$4);
  if (index === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  const copy = [...array3];
  copy[index] = value3;
  array3 = copy;
  return copy;
};
var gridFromArrayDimensions = (array3, cols) => {
  const grid3 = {
    cols,
    rows: Math.ceil(array3.length / cols)
  };
  return grid3;
};
var wrapMutable$1 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions(array3, cols);
  return {
    ...grid3,
    get: access$1(array3, cols),
    set: setMutate$1(array3, cols),
    get array() {
      return array3;
    }
  };
};
var wrap$2 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions(array3, cols);
  return {
    ...grid3,
    get: (cell, boundsLogic = `undefined`) => accessWithGrid$1(grid3, array3, cell, boundsLogic),
    set: (value3, cell, boundsLogic = `undefined`) => {
      array3 = setWithGrid$1(grid3, array3, value3, cell, boundsLogic);
      return wrap$2(array3, cols);
    },
    get array() {
      return array3;
    }
  };
};
var createArray = (initialValue, rowsOrGrid, columns$1) => {
  const rows$1 = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;
  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns$1;
  if (!cols) throw new Error(`Parameter 'columns' missing`);
  resultThrow(integerTest(rows$1, `aboveZero`, `rows`), integerTest(cols, `aboveZero`, `cols`));
  const t6 = [];
  const total2 = rows$1 * cols;
  for (let index = 0; index < total2; index++) t6[index] = initialValue;
  return t6;
};
var createMutable = (initialValue, rowsOrGrid, columns$1) => {
  const rows$1 = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;
  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns$1;
  if (!cols) throw new Error(`Parameter 'columns' missing`);
  const array3 = createArray(initialValue, rows$1, cols);
  return wrapMutable$1(array3, cols);
};
var array_2d_exports = {};
__export(array_2d_exports, {
  access: () => access,
  create: () => create$13,
  set: () => set3,
  setMutate: () => setMutate,
  wrap: () => wrap$1,
  wrapMutable: () => wrapMutable
});
var create$13 = (array3) => {
  let colLen = NaN;
  for (const row of array3) if (Number.isNaN(colLen)) colLen = row.length;
  else if (colLen !== row.length) throw new Error(`Array does not have uniform column length`);
  return {
    rows: array3.length,
    cols: colLen
  };
};
var setMutate = (array3) => {
  const grid3 = create$13(array3);
  return (value3, cell, wrap$4 = `undefined`) => setMutateWithGrid(grid3, array3, value3, cell, wrap$4);
};
var setMutateWithGrid = (grid3, array3, value3, cell, bounds) => {
  let boundCell = applyBounds(grid3, cell, bounds);
  if (boundCell === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  array3[boundCell.y][boundCell.x] = value3;
  return array3;
};
var access = (array3) => {
  const grid3 = create$13(array3);
  const fn2 = (cell, wrap$4 = `undefined`) => accessWithGrid(grid3, array3, cell, wrap$4);
  return fn2;
};
var accessWithGrid = (grid3, array3, cell, wrap$4) => {
  let boundCell = applyBounds(grid3, cell, wrap$4);
  if (boundCell === void 0) return void 0;
  return array3[boundCell.y][boundCell.x];
};
var wrapMutable = (array3) => {
  const grid3 = create$13(array3);
  return {
    ...grid3,
    get: access(array3),
    set: setMutate(array3),
    get array() {
      return array3;
    }
  };
};
var set3 = (array3) => {
  const grid3 = create$13(array3);
  return (value3, cell, wrap$4) => setWithGrid(grid3, array3, value3, cell, wrap$4);
};
var setWithGrid = (grid3, array3, value3, cell, wrap$4) => {
  let boundCell = applyBounds(grid3, cell, wrap$4);
  if (boundCell === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  let copyWhole = [...array3];
  let copyRow = [...copyWhole[boundCell.y]];
  copyRow[boundCell.x] = value3;
  copyWhole[boundCell.y] = copyRow;
  array3 = copyWhole;
  return copyWhole;
};
var wrap$1 = (array3) => {
  const grid3 = create$13(array3);
  return {
    ...grid3,
    get: (cell, boundsLogic = `undefined`) => accessWithGrid(grid3, array3, cell, boundsLogic),
    set: (value3, cell, boundsLogic = `undefined`) => {
      array3 = setWithGrid(grid3, array3, value3, cell, boundsLogic);
      return wrap$1(array3);
    },
    get array() {
      return array3;
    }
  };
};
function* values(grid3, iter) {
  for (const d3 of iter) if (Array.isArray(d3)) yield d3.map((v3) => grid3.get(v3, `undefined`));
  else yield grid3.get(d3, `undefined`);
}
function* cells(grid3, start, wrap$4 = true) {
  if (!start) start = {
    x: 0,
    y: 0
  };
  guardGrid(grid3, `grid`);
  guardCell(start, `start`, grid3);
  let { x: x3, y: y3 } = start;
  let canMove = true;
  do {
    yield {
      x: x3,
      y: y3
    };
    x3++;
    if (x3 === grid3.cols) {
      y3++;
      x3 = 0;
    }
    if (y3 === grid3.rows) if (wrap$4) {
      y3 = 0;
      x3 = 0;
    } else canMove = false;
    if (x3 === start.x && y3 === start.y) canMove = false;
  } while (canMove);
}
function* cellValues(grid3, start, wrap$4 = true) {
  yield* values(grid3, cells(grid3, start, wrap$4));
}
function* cellsAndValues(grid3, start, wrap$4 = true) {
  for (const cell of cells(grid3, start, wrap$4)) yield {
    cell,
    value: grid3.get(cell)
  };
}
var as_exports = {};
__export(as_exports, {
  columns: () => columns,
  rows: () => rows
});
var rows = function* (grid3, start) {
  if (!start) start = {
    x: 0,
    y: 0
  };
  let row = start.y;
  let rowCells = [];
  for (const c5 of cells(grid3, start)) if (c5.y === row) rowCells.push(c5);
  else {
    yield rowCells;
    rowCells = [c5];
    row = c5.y;
  }
  if (rowCells.length > 0) yield rowCells;
};
function* columns(grid3, start) {
  if (!start) start = {
    x: 0,
    y: 0
  };
  for (let x3 = start.x; x3 < grid3.cols; x3++) {
    let colCells = [];
    for (let y3 = start.y; y3 < grid3.rows; y3++) colCells.push({
      x: x3,
      y: y3
    });
    yield colCells;
  }
}
var offset = function(grid3, start, vector, bounds = `undefined`) {
  return applyBounds(grid3, {
    x: start.x + vector.x,
    y: start.y + vector.y
  }, bounds);
};
var allDirections = Object.freeze([
  `n`,
  `ne`,
  `nw`,
  `e`,
  `s`,
  `se`,
  `sw`,
  `w`
]);
var crossDirections = Object.freeze([
  `n`,
  `e`,
  `s`,
  `w`
]);
var offsetCardinals = (grid3, start, steps, bounds = `stop`) => {
  guardGrid(grid3, `grid`);
  guardCell(start, `start`);
  resultThrow(integerTest(steps, `aboveZero`, `steps`));
  const directions = allDirections;
  const vectors = directions.map((d3) => getVectorFromCardinal(d3, steps));
  const cells$1 = directions.map((d3, index) => offset(grid3, start, vectors[index], bounds));
  return zipKeyValue(directions, cells$1);
};
var getVectorFromCardinal = (cardinal$1, multiplier = 1) => {
  let v3;
  switch (cardinal$1) {
    case `n`: {
      v3 = {
        x: 0,
        y: -1 * multiplier
      };
      break;
    }
    case `ne`: {
      v3 = {
        x: 1 * multiplier,
        y: -1 * multiplier
      };
      break;
    }
    case `e`: {
      v3 = {
        x: 1 * multiplier,
        y: 0
      };
      break;
    }
    case `se`: {
      v3 = {
        x: 1 * multiplier,
        y: 1 * multiplier
      };
      break;
    }
    case `s`: {
      v3 = {
        x: 0,
        y: 1 * multiplier
      };
      break;
    }
    case `sw`: {
      v3 = {
        x: -1 * multiplier,
        y: 1 * multiplier
      };
      break;
    }
    case `w`: {
      v3 = {
        x: -1 * multiplier,
        y: 0
      };
      break;
    }
    case `nw`: {
      v3 = {
        x: -1 * multiplier,
        y: -1 * multiplier
      };
      break;
    }
    default:
      v3 = {
        x: 0,
        y: 0
      };
  }
  return Object.freeze(v3);
};
var enumerators_exports = {};
__export(enumerators_exports, {
  cellValues: () => cellValues,
  cells: () => cells,
  cellsAndValues: () => cellsAndValues
});
var getLine = (start, end) => {
  guardCell(start);
  guardCell(end);
  let startX = start.x;
  let startY = start.y;
  const dx = Math.abs(end.x - startX);
  const dy = Math.abs(end.y - startY);
  const sx = startX < end.x ? 1 : -1;
  const sy = startY < end.y ? 1 : -1;
  let error = dx - dy;
  const cells$1 = [];
  while (true) {
    cells$1.push(Object.freeze({
      x: startX,
      y: startY
    }));
    if (startX === end.x && startY === end.y) break;
    const error2 = 2 * error;
    if (error2 > -dy) {
      error -= dy;
      startX += sx;
    }
    if (error2 < dx) {
      error += dx;
      startY += sy;
    }
  }
  return cells$1;
};
var simpleLine = function(start, end, endInclusive = false) {
  const cells$1 = [];
  if (start.x === end.x) {
    const lastY = endInclusive ? end.y + 1 : end.y;
    for (let y3 = start.y; y3 < lastY; y3++) cells$1.push({
      x: start.x,
      y: y3
    });
  } else if (start.y === end.y) {
    const lastX = endInclusive ? end.x + 1 : end.x;
    for (let x3 = start.x; x3 < lastX; x3++) cells$1.push({
      x: x3,
      y: start.y
    });
  } else throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);
  return cells$1;
};
var indexFromCell = (grid3, cell, wrap$4) => {
  guardGrid(grid3, `grid`);
  if (cell.x < 0) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        x: 0
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = offset(grid3, {
        x: 0,
        y: cell.y
      }, {
        x: cell.x,
        y: 0
      }, `wrap`);
      break;
    }
  }
  if (cell.y < 0) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        y: 0
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = {
        ...cell,
        y: grid3.rows + cell.y
      };
      break;
    }
  }
  if (cell.x >= grid3.cols) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        x: grid3.cols - 1
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = {
        ...cell,
        x: cell.x % grid3.cols
      };
      break;
    }
  }
  if (cell.y >= grid3.rows) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        y: grid3.rows - 1
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = {
        ...cell,
        y: cell.y % grid3.rows
      };
      break;
    }
  }
  const index = cell.y * grid3.cols + cell.x;
  return index;
};
var cellFromIndex = (colsOrGrid, index) => {
  let cols = 0;
  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;
  resultThrow(integerTest(cols, `aboveZero`, `colsOrGrid`));
  return {
    x: index % cols,
    y: Math.floor(index / cols)
  };
};
var isEqual$2 = (a3, b3) => {
  if (b3 === void 0) return false;
  if (a3 === void 0) return false;
  if (`rows` in a3 && `cols` in a3) if (`rows` in b3 && `cols` in b3) {
    if (a3.rows !== b3.rows || a3.cols !== b3.cols) return false;
  } else return false;
  if (`size` in a3) if (`size` in b3) {
    if (a3.size !== b3.size) return false;
  } else return false;
  return true;
};
var cellEquals = (a3, b3) => {
  if (b3 === void 0) return false;
  if (a3 === void 0) return false;
  return a3.x === b3.x && a3.y === b3.y;
};
var randomNeighbour = (nbos) => randomElement2(nbos);
var isNeighbour = (n6) => {
  if (n6 === void 0) return false;
  if (n6[1] === void 0) return false;
  return true;
};
var neighbourList = (grid3, cell, directions, bounds) => {
  const cellNeighbours = neighbours(grid3, cell, bounds, directions);
  const entries2 = Object.entries(cellNeighbours);
  return entries2.filter((n6) => isNeighbour(n6));
};
var neighbours = (grid3, cell, bounds = `undefined`, directions) => {
  const directories = directions ?? allDirections;
  const points = directories.map((c5) => offset(grid3, cell, getVectorFromCardinal(c5), bounds));
  return zipKeyValue(directories, points);
};
var toArray2d = (grid3, initialValue) => {
  const returnValue = [];
  for (let row = 0; row < grid3.rows; row++) {
    returnValue[row] = Array.from({ length: grid3.cols });
    if (initialValue) for (let col = 0; col < grid3.cols; col++) returnValue[row][col] = initialValue;
  }
  return returnValue;
};
var cellKeyString = (v3) => `Cell{${v3.x},${v3.y}}`;
function* asRectangles(grid3) {
  for (const c5 of cells(grid3)) yield rectangleForCell(grid3, c5);
}
var cellAtPoint = (grid3, position) => {
  const size = grid3.size;
  resultThrow(numberTest(size, `positive`, `grid.size`));
  if (position.x < 0 || position.y < 0) return;
  const x3 = Math.floor(position.x / size);
  const y3 = Math.floor(position.y / size);
  if (x3 >= grid3.cols) return;
  if (y3 >= grid3.rows) return;
  return {
    x: x3,
    y: y3
  };
};
var rectangleForCell = (grid3, cell) => {
  guardCell(cell);
  const size = grid3.size;
  const x3 = cell.x * size;
  const y3 = cell.y * size;
  const r5 = fromTopLeft({
    x: x3,
    y: y3
  }, size, size);
  return r5;
};
var cellMiddle = (grid3, cell) => {
  guardCell(cell);
  const size = grid3.size;
  const x3 = cell.x * size;
  const y3 = cell.y * size;
  return Object.freeze({
    x: x3 + size / 2,
    y: y3 + size / 2
  });
};
var breadthLogic = () => {
  return { select: (nbos) => nbos[0] };
};
var neighboursLogic = () => {
  return {
    select: (neighbours$1) => {
      return neighbours$1.at(0);
    },
    getNeighbours: (grid3, cell) => {
      return neighbourList(grid3, cell, allDirections, `undefined`);
    }
  };
};
var columnLogic = (opts = {}) => {
  const reversed = opts.reversed ?? false;
  return {
    select: (nbos) => nbos.find((n6) => n6[0] === (reversed ? `n` : `s`)),
    getNeighbours: (grid3, cell) => {
      if (reversed) if (cell.y > 0) cell = {
        x: cell.x,
        y: cell.y - 1
      };
      else if (cell.x === 0) cell = {
        x: grid3.cols - 1,
        y: grid3.rows - 1
      };
      else cell = {
        x: cell.x - 1,
        y: grid3.rows - 1
      };
      else if (cell.y < grid3.rows - 1) cell = {
        x: cell.x,
        y: cell.y + 1
      };
      else if (cell.x < grid3.cols - 1) cell = {
        x: cell.x + 1,
        y: 0
      };
      else cell = {
        x: 0,
        y: 0
      };
      return [[reversed ? `n` : `s`, cell]];
    }
  };
};
var depthLogic = () => {
  return { select: (nbos) => nbos.at(-1) };
};
var randomLogic = () => {
  return {
    getNeighbours: (grid3, cell) => {
      const t6 = [];
      for (const c5 of cells(grid3, cell)) t6.push([`n`, c5]);
      return t6;
    },
    select: randomNeighbour
  };
};
var randomContiguousLogic = () => {
  return { select: randomNeighbour };
};
var rowLogic = (opts = {}) => {
  const reversed = opts.reversed ?? false;
  return {
    select: (nbos) => nbos.find((n6) => n6[0] === (reversed ? `w` : `e`)),
    getNeighbours: (grid3, cell) => {
      if (reversed) if (cell.x > 0) cell = {
        x: cell.x - 1,
        y: cell.y
      };
      else if (cell.y > 0) cell = {
        x: grid3.cols - 1,
        y: cell.y - 1
      };
      else cell = {
        x: grid3.cols - 1,
        y: grid3.rows - 1
      };
      else if (cell.x < grid3.rows - 1) cell = {
        x: cell.x + 1,
        y: cell.y
      };
      else if (cell.y < grid3.rows - 1) cell = {
        x: 0,
        y: cell.y + 1
      };
      else cell = {
        x: 0,
        y: 0
      };
      return [[reversed ? `w` : `e`, cell]];
    }
  };
};
function* visitByNeighbours(logic, grid3, opts = {}) {
  guardGrid(grid3, `grid`);
  const start = opts.start ?? {
    x: 0,
    y: 0
  };
  guardCell(start, `opts.start`, grid3);
  const v3 = opts.visited ?? mutable$22(cellKeyString);
  const possibleNeighbours = logic.getNeighbours ?? ((g4, c5) => neighbourList(g4, c5, crossDirections, `undefined`));
  let cellQueue = [start];
  let moveQueue = [];
  let current = void 0;
  while (cellQueue.length > 0) {
    if (current === void 0) {
      const nv = cellQueue.pop();
      if (nv === void 0) break;
      current = nv;
    }
    if (!v3.has(current)) {
      v3.add(current);
      yield current;
      const nextSteps = possibleNeighbours(grid3, current).filter((step) => {
        if (step[1] === void 0) return false;
        return !v3.has(step[1]);
      });
      if (nextSteps.length === 0) {
        if (current !== void 0) cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));
      } else for (const n6 of nextSteps) {
        if (n6 === void 0) continue;
        if (n6[1] === void 0) continue;
        moveQueue.push(n6);
      }
    }
    moveQueue = moveQueue.filter((step) => !v3.has(step[1]));
    if (moveQueue.length === 0) current = void 0;
    else {
      const potential = logic.select(moveQueue);
      if (potential !== void 0) {
        cellQueue.push(potential[1]);
        current = potential[1];
      }
    }
  }
}
var stepper = (grid3, createVisitor, start = {
  x: 0,
  y: 0
}, resolution = 1) => {
  guardGrid(grid3, `grid`);
  guardCell(start, `start`);
  resultThrow(integerTest(resolution, ``, `resolution`));
  const steps = [];
  let count3 = 0;
  let position = 0;
  for (const c5 of createVisitor(grid3, {
    start,
    boundsWrap: `undefined`
  })) {
    count3++;
    if (count3 % resolution !== 0) continue;
    steps.push(c5);
  }
  return (step, fromStart = false) => {
    resultThrow(integerTest(step, ``, `step`));
    if (fromStart) position = step;
    else position += step;
    return steps.at(position % steps.length);
  };
};
var visitors_exports = {};
__export(visitors_exports, {
  breadthLogic: () => breadthLogic,
  columnLogic: () => columnLogic,
  create: () => create3,
  depthLogic: () => depthLogic,
  neighboursLogic: () => neighboursLogic,
  randomContiguousLogic: () => randomContiguousLogic,
  randomLogic: () => randomLogic,
  rowLogic: () => rowLogic,
  stepper: () => stepper,
  visitByNeighbours: () => visitByNeighbours,
  withLogic: () => withLogic
});
var create3 = (type, opts = {}) => {
  switch (type) {
    case `random-contiguous`:
      return withLogic(randomContiguousLogic(), opts);
    case `random`:
      return withLogic(randomLogic(), opts);
    case `depth`:
      return withLogic(depthLogic(), opts);
    case `breadth`:
      return withLogic(breadthLogic(), opts);
    case `neighbours`:
      return withLogic(neighboursLogic(), opts);
    case `row`:
      return withLogic(rowLogic(opts), opts);
    case `column`:
      return withLogic(columnLogic(opts), opts);
    default:
      throw new TypeError(`Param 'type' unknown. Value: ${type}`);
  }
};
var withLogic = (logic, options = {}) => {
  return (grid3, optionsOverride = {}) => {
    return visitByNeighbours(logic, grid3, {
      ...options,
      ...optionsOverride
    });
  };
};
var grid_exports = {};
__export(grid_exports, {
  Array1d: () => array_1d_exports,
  Array2d: () => array_2d_exports,
  As: () => as_exports,
  By: () => enumerators_exports,
  Visit: () => visitors_exports,
  allDirections: () => allDirections,
  applyBounds: () => applyBounds,
  asRectangles: () => asRectangles,
  cellAtPoint: () => cellAtPoint,
  cellEquals: () => cellEquals,
  cellFromIndex: () => cellFromIndex,
  cellKeyString: () => cellKeyString,
  cellMiddle: () => cellMiddle,
  crossDirections: () => crossDirections,
  getLine: () => getLine,
  getVectorFromCardinal: () => getVectorFromCardinal,
  guardCell: () => guardCell,
  guardGrid: () => guardGrid,
  indexFromCell: () => indexFromCell,
  inside: () => inside,
  isCell: () => isCell,
  isEqual: () => isEqual$2,
  neighbourList: () => neighbourList,
  neighbours: () => neighbours,
  offset: () => offset,
  offsetCardinals: () => offsetCardinals,
  randomNeighbour: () => randomNeighbour,
  rectangleForCell: () => rectangleForCell,
  simpleLine: () => simpleLine,
  toArray2d: () => toArray2d,
  values: () => values
});
var getStart = function(path3) {
  if (isQuadraticBezier(path3)) return path3.a;
  else if (isLine(path3)) return path3.a;
  else throw new Error(`Unknown path type ${JSON.stringify(path3)}`);
};
var getEnd = function(path3) {
  if (isQuadraticBezier(path3)) return path3.b;
  else if (isLine(path3)) return path3.b;
  else throw new Error(`Unknown path type ${JSON.stringify(path3)}`);
};
var compound_path_exports = {};
__export(compound_path_exports, {
  bbox: () => bbox$2,
  computeDimensions: () => computeDimensions,
  distanceToPoint: () => distanceToPoint,
  fromPaths: () => fromPaths,
  guardContinuous: () => guardContinuous,
  interpolate: () => interpolate2,
  relativePosition: () => relativePosition,
  setSegment: () => setSegment,
  toString: () => toString3,
  toSvgString: () => toSvgString
});
var setSegment = (compoundPath, index, path3) => {
  const existing = [...compoundPath.segments];
  existing[index] = path3;
  return fromPaths(...existing);
};
var interpolate2 = (paths3, t6, useWidth, dimensions) => {
  if (dimensions === void 0) dimensions = computeDimensions(paths3);
  const expected = t6 * (useWidth ? dimensions.totalWidth : dimensions.totalLength);
  let soFar = 0;
  const l3 = useWidth ? dimensions.widths : dimensions.lengths;
  for (const [index, element] of l3.entries()) if (soFar + element >= expected) {
    const relative2 = expected - soFar;
    let amt = relative2 / element;
    if (amt > 1) amt = 1;
    return paths3[index].interpolate(amt);
  } else soFar += element;
  return {
    x: 0,
    y: 0
  };
};
var distanceToPoint = (paths3, point$1) => {
  if (paths3.length === 0) return 0;
  let distances = paths3.map((p3, index) => ({
    path: p3,
    index,
    distance: p3.distanceToPoint(point$1)
  }));
  distances = sortByNumericProperty(distances, `distance`);
  if (distances.length === 0) throw new Error(`Could not look up distances`);
  return distances[0].distance;
};
var relativePosition = (paths3, point$1, intersectionThreshold, dimensions) => {
  if (dimensions === void 0) dimensions = computeDimensions(paths3);
  let distances = paths3.map((p3, index) => ({
    path: p3,
    index,
    distance: p3.distanceToPoint(point$1)
  }));
  distances = sortByNumericProperty(distances, `distance`);
  if (distances.length < 0) throw new Error(`Point does not intersect with path`);
  const d3 = distances[0];
  if (d3.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${d3.distance}, threshold: ${intersectionThreshold}`);
  const relativePositionOnPath = d3.path.relativePosition(point$1, intersectionThreshold);
  let accumulated = 0;
  for (let index = 0; index < d3.index; index++) accumulated += dimensions.lengths[index];
  accumulated += dimensions.lengths[d3.index] * relativePositionOnPath;
  const accumulatedRel = accumulated / dimensions.totalLength;
  console.log(`acc: ${accumulated} rel: ${accumulatedRel} on path: ${relativePositionOnPath} path: ${d3.index}`);
  return accumulatedRel;
};
var computeDimensions = (paths3) => {
  const widths = paths3.map((l3) => l3.bbox().width);
  const lengths$2 = paths3.map((l3) => l3.length());
  let totalLength = 0;
  let totalWidth = 0;
  for (const length$4 of lengths$2) totalLength += length$4;
  for (const width of widths) totalWidth += width;
  return {
    totalLength,
    totalWidth,
    widths,
    lengths: lengths$2
  };
};
var bbox$2 = (paths3) => {
  const boxes = paths3.map((p3) => p3.bbox());
  const corners$2 = boxes.flatMap((b3) => corners$1(b3));
  return bbox$1(...corners$2);
};
var toString3 = (paths3) => paths3.map((p3) => p3.toString()).join(`, `);
var guardContinuous = (paths3) => {
  let lastPos = getEnd(paths3[0]);
  for (let index = 1; index < paths3.length; index++) {
    const start = getStart(paths3[index]);
    if (!isEqual2(start, lastPos)) throw new Error(`Path index ${index} does not start at prior path end. Start: ${start.x},${start.y} expected: ${lastPos.x},${lastPos.y}`);
    lastPos = getEnd(paths3[index]);
  }
};
var toSvgString = (paths3) => paths3.flatMap((p3) => p3.toSvgString());
var fromPaths = (...paths3) => {
  guardContinuous(paths3);
  const dims = computeDimensions(paths3);
  return Object.freeze({
    segments: paths3,
    length: () => dims.totalLength,
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    interpolate: (t6, useWidth = false) => interpolate2(paths3, t6, useWidth, dims),
    relativePosition: (point$1, intersectionThreshold) => relativePosition(paths3, point$1, intersectionThreshold, dims),
    distanceToPoint: (point$1) => distanceToPoint(paths3, point$1),
    bbox: () => bbox$2(paths3),
    toString: () => toString3(paths3),
    toSvgString: () => toSvgString(paths3),
    kind: `compound`
  });
};
var path_exports = {};
__export(path_exports, {
  bbox: () => bbox$2,
  computeDimensions: () => computeDimensions,
  distanceToPoint: () => distanceToPoint,
  fromPaths: () => fromPaths,
  getEnd: () => getEnd,
  getStart: () => getStart,
  guardContinuous: () => guardContinuous,
  interpolate: () => interpolate2,
  relativePosition: () => relativePosition,
  setSegment: () => setSegment,
  toString: () => toString3,
  toSvgString: () => toSvgString
});
var Empty$1 = Object.freeze({
  a: {
    x: 0,
    y: 0
  },
  b: {
    x: 0,
    y: 0
  },
  c: {
    x: 0,
    y: 0
  }
});
var Placeholder$1 = Object.freeze({
  a: {
    x: NaN,
    y: NaN
  },
  b: {
    x: NaN,
    y: NaN
  },
  c: {
    x: NaN,
    y: NaN
  }
});
var equilateralFromVertex = (origin, length$4 = 10, angleRadian$2 = Math.PI / 2) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const a3 = project(origin, length$4, Math.PI - -angleRadian$2 / 2);
  const c5 = project(origin, length$4, Math.PI - angleRadian$2 / 2);
  return {
    a: a3,
    b: origin,
    c: c5
  };
};
var arrow = (origin, from$1, opts = {}) => {
  const tailLength = opts.tailLength ?? 10;
  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);
  const angleRadian$2 = opts.angleRadian ?? 0;
  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);
  const triAngle = Math.PI / 2;
  let tri;
  let tailPoints;
  if (from$1 === `tip`) {
    tri = equilateralFromVertex(origin, arrowSize, triAngle);
    tailPoints = corners$1(fromTopLeft({
      x: tri.a.x - tailLength,
      y: origin.y - tailThickness / 2
    }, tailLength, tailThickness));
  } else if (from$1 === `middle`) {
    const midX = tailLength + arrowSize / 2;
    const midY = tailThickness / 2;
    tri = equilateralFromVertex({
      x: origin.x + arrowSize * 1.2,
      y: origin.y
    }, arrowSize, triAngle);
    tailPoints = corners$1(fromTopLeft({
      x: origin.x - midX,
      y: origin.y - midY
    }, tailLength + arrowSize, tailThickness));
  } else {
    tailPoints = corners$1(fromTopLeft({
      x: origin.x,
      y: origin.y - tailThickness / 2
    }, tailLength, tailThickness));
    tri = equilateralFromVertex({
      x: origin.x + tailLength + arrowSize * 0.7,
      y: origin.y
    }, arrowSize, triAngle);
  }
  const arrow$1 = rotate([
    tailPoints[0],
    tailPoints[1],
    tri.a,
    tri.b,
    tri.c,
    tailPoints[2],
    tailPoints[3]
  ], angleRadian$2, origin);
  return arrow$1;
};
var guard = (t6, name = `t`) => {
  if (t6 === void 0) throw new Error(`{$name} undefined`);
  guard$1(t6.a, name + `.a`);
  guard$1(t6.b, name + `.b`);
  guard$1(t6.c, name + `.c`);
};
var isTriangle = (p3) => {
  if (p3 === void 0) return false;
  const tri = p3;
  if (!isPoint(tri.a)) return false;
  if (!isPoint(tri.b)) return false;
  if (!isPoint(tri.c)) return false;
  return true;
};
var isEmpty$13 = (t6) => isEmpty3(t6.a) && isEmpty3(t6.b) && isEmpty3(t6.c);
var isPlaceholder$1 = (t6) => isPlaceholder(t6.a) && isPlaceholder(t6.b) && isPlaceholder(t6.c);
var isEqual$1 = (a3, b3) => isEqual2(a3.a, b3.a) && isEqual2(a3.b, b3.b) && isEqual2(a3.c, b3.c);
var centroid = (t6) => {
  guard(t6);
  const total2 = reduce2([
    t6.a,
    t6.b,
    t6.c
  ], (p3, accumulator) => ({
    x: p3.x + accumulator.x,
    y: p3.y + accumulator.y
  }));
  const div = {
    x: total2.x / 3,
    y: total2.y / 3
  };
  return div;
};
var randomPoint = (shape, opts = {}) => {
  if (isCirclePositioned(shape)) return randomPoint$1(shape, opts);
  else if (isRectPositioned(shape)) return randomPoint$2(shape, opts);
  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);
};
var center$2 = (shape) => {
  if (shape === void 0) return Object.freeze({
    x: 0.5,
    y: 0.5
  });
  else if (isRect(shape)) return center$1(shape);
  else if (isTriangle(shape)) return centroid(shape);
  else if (isCircle(shape)) return center(shape);
  else throw new Error(`Unknown shape: ${JSON.stringify(shape)}`);
};
var isIntersecting$2 = (a3, b3) => {
  if (isCirclePositioned(a3)) return isIntersecting(a3, b3);
  else if (isRectPositioned(a3)) return isIntersecting$1(a3, b3);
  throw new Error(`a or b are unknown shapes. a: ${JSON.stringify(a3)} b: ${JSON.stringify(b3)}`);
};
var starburst = (outerRadius, points = 5, innerRadius, origin = Empty, opts) => {
  resultThrow(integerTest(points, `positive`, `points`));
  const angle = Math.PI * 2 / points;
  const angleHalf = angle / 2;
  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;
  if (innerRadius === void 0) innerRadius = outerRadius / 2;
  let a3 = initialAngle;
  const pts = [];
  for (let index = 0; index < points; index++) {
    const peak = toCartesian(outerRadius, a3, origin);
    const left = toCartesian(innerRadius, a3 - angleHalf, origin);
    const right = toCartesian(innerRadius, a3 + angleHalf, origin);
    pts.push(left, peak);
    if (index + 1 < points) pts.push(right);
    a3 += angle;
  }
  return pts;
};
var shape_exports = {};
__export(shape_exports, {
  arrow: () => arrow,
  center: () => center$2,
  isIntersecting: () => isIntersecting$2,
  randomPoint: () => randomPoint,
  starburst: () => starburst
});
var waypoint_exports = {};
__export(waypoint_exports, {
  fromPoints: () => fromPoints$1,
  init: () => init2
});
var fromPoints$1 = (waypoints, opts = {}) => {
  const lines = joinPointsToLines(...waypoints);
  return init2(lines.map((l3) => toPath(l3)), opts);
};
var init2 = (paths3, opts = {}) => {
  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;
  const checkUnordered = (pt2) => {
    const results = paths3.map((p3, index) => {
      const nearest$2 = p3.nearest(pt2);
      const distance$2 = distance3(pt2, nearest$2);
      const positionRelative2 = p3.relativePosition(nearest$2, maxDistanceFromLine);
      return {
        positionRelative: positionRelative2,
        path: p3,
        index,
        nearest: nearest$2,
        distance: distance$2,
        rank: Number.MAX_SAFE_INTEGER
      };
    });
    const filtered = results.filter((v3) => v3.distance <= maxDistanceFromLine);
    const sorted = sortByNumericProperty(filtered, `distance`);
    for (let rank2 = 0; rank2 < sorted.length; rank2++) sorted[rank2].rank = rank2;
    return sorted;
  };
  return checkUnordered;
};
var circle_packing_exports = {};
__export(circle_packing_exports, { random: () => random });
var random = (circles, container, opts = {}) => {
  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);
  const attempts = opts.attempts ?? 2e3;
  const sorted = sortByNumericProperty(circles, `radius`);
  const positionedCircles = [];
  const willHit = (b3, radius) => positionedCircles.some((v3) => isIntersecting(v3, b3, radius));
  while (sorted.length > 0) {
    const circle3 = sorted.pop();
    if (!circle3) break;
    const randomPointOpts = {
      ...opts,
      margin: {
        x: circle3.radius,
        y: circle3.radius
      }
    };
    for (let index = 0; index < attempts; index++) {
      const position = randomPoint(container, randomPointOpts);
      if (!willHit(position, circle3.radius)) {
        positionedCircles.push(Object.freeze({
          ...circle3,
          ...position
        }));
        break;
      }
    }
  }
  return positionedCircles;
};
var layout_exports = {};
__export(layout_exports, { CirclePacking: () => circle_packing_exports });
var ellipse_exports = {};
__export(ellipse_exports, { fromDegrees: () => fromDegrees });
var fromDegrees = (radiusX, radiusY, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360) => ({
  radiusX,
  radiusY,
  rotation: degreeToRadian(rotationDeg),
  startAngle: degreeToRadian(startAngleDeg),
  endAngle: degreeToRadian(endAngleDeg)
});
var curve_simplification_exports = {};
__export(curve_simplification_exports, {
  rdpPerpendicularDistance: () => rdpPerpendicularDistance,
  rdpShortestDistance: () => rdpShortestDistance
});
var rdpShortestDistance = (points, epsilon2 = 0.1) => {
  const firstPoint = points[0];
  const lastPoint = points.at(-1);
  if (points.length < 3) return points;
  let index = -1;
  let distribution = 0;
  for (let index_ = 1; index_ < points.length - 1; index_++) {
    const cDistribution = distanceFromPointToLine(points[index_], firstPoint, lastPoint);
    if (cDistribution > distribution) {
      distribution = cDistribution;
      index = index_;
    }
  }
  if (distribution > epsilon2) {
    const l1 = points.slice(0, index + 1);
    const l22 = points.slice(index);
    const r1 = rdpShortestDistance(l1, epsilon2);
    const r22 = rdpShortestDistance(l22, epsilon2);
    const rs2 = [...r1.slice(0, -1), ...r22];
    return rs2;
  } else return [firstPoint, lastPoint];
};
var rdpPerpendicularDistance = (points, epsilon2 = 0.1) => {
  const firstPoint = points[0];
  const lastPoint = points.at(-1);
  if (points.length < 3) return points;
  let index = -1;
  let distribution = 0;
  for (let index_ = 1; index_ < points.length - 1; index_++) {
    const cDistribution = findPerpendicularDistance(points[index_], firstPoint, lastPoint);
    if (cDistribution > distribution) {
      distribution = cDistribution;
      index = index_;
    }
  }
  if (distribution > epsilon2) {
    const l1 = points.slice(0, index + 1);
    const l22 = points.slice(index);
    const r1 = rdpPerpendicularDistance(l1, epsilon2);
    const r22 = rdpPerpendicularDistance(l22, epsilon2);
    const rs2 = [...r1.slice(0, -1), ...r22];
    return rs2;
  } else return [firstPoint, lastPoint];
};
function findPerpendicularDistance(p3, p1, p22) {
  let result;
  let slope$1;
  let intercept;
  if (p1.x == p22.x) result = Math.abs(p3.x - p1.x);
  else {
    slope$1 = (p22.y - p1.y) / (p22.x - p1.x);
    intercept = p1.y - slope$1 * p1.x;
    result = Math.abs(slope$1 * p3.x - p3.y + intercept) / Math.sqrt(Math.pow(slope$1, 2) + 1);
  }
  return result;
}
var distanceFromPointToLine = (p3, index, index_) => {
  const lineLength = distance3(index, index_);
  if (lineLength == 0) return distance3(p3, index);
  const t6 = ((p3.x - index.x) * (index_.x - index.x) + (p3.y - index.y) * (index_.y - index.y)) / lineLength;
  if (t6 < 0) return distance3(p3, index);
  if (t6 > 1) return distance3(p3, index_);
  return distance3(p3, {
    x: index.x + t6 * (index_.x - index.x),
    y: index.y + t6 * (index_.y - index.y)
  });
};
var quad_tree_exports = {};
__export(quad_tree_exports, {
  Direction: () => Direction,
  QuadTreeNode: () => QuadTreeNode,
  quadTree: () => quadTree
});
var Direction;
(function(Direction$1) {
  Direction$1[Direction$1["Nw"] = 0] = "Nw";
  Direction$1[Direction$1["Ne"] = 1] = "Ne";
  Direction$1[Direction$1["Sw"] = 2] = "Sw";
  Direction$1[Direction$1["Se"] = 3] = "Se";
})(Direction || (Direction = {}));
var quadTree = (bounds, initialData = [], opts = {}) => {
  const o5 = {
    maxItems: opts.maxItems ?? 4,
    maxLevels: opts.maxLevels ?? 4
  };
  const n6 = new QuadTreeNode(void 0, bounds, 0, o5);
  for (const d3 of initialData) n6.add(d3);
  return n6;
};
var QuadTreeNode = class QuadTreeNode2 {
  boundary;
  level;
  opts;
  #items = [];
  #children = [];
  #parent;
  /**
  * Constructor
  * @param boundary
  * @param level
  * @param opts
  */
  constructor(parent, boundary, level, opts) {
    this.boundary = boundary;
    this.level = level;
    this.opts = opts;
    this.#parent = parent;
  }
  getLengthChildren() {
    return this.#children.length;
  }
  *parents() {
    let n6 = this;
    while (n6.#parent !== void 0) {
      yield n6.#parent;
      n6 = n6.#parent;
    }
  }
  getParent() {
    return this.#parent;
  }
  /**
  * Iterates over immediate children
  */
  *children() {
    for (const c5 of this.#children) yield c5;
  }
  /**
  * Array of QuadTreeItem
  * @returns
  */
  getValue() {
    return this.#items;
  }
  getIdentity() {
    return this;
  }
  /**
  * Get a descendant node in a given direction
  * @param d
  * @returns
  */
  direction(d3) {
    return this.#children[d3];
  }
  /**
  * Add an item to the quadtree
  * @param p
  * @returns False if item is outside of boundary, True if item was added
  */
  add(p3) {
    if (!isIntersecting$2(this.boundary, p3)) return false;
    if (this.#children.length > 0) {
      for (const d3 of this.#children) d3.add(p3);
      return true;
    }
    this.#items.push(p3);
    if (this.#items.length > this.opts.maxItems && this.level < this.opts.maxLevels) {
      if (this.#children.length === 0) this.#subdivide();
      for (const item of this.#items) for (const d3 of this.#children) d3.add(item);
      this.#items = [];
    }
    return true;
  }
  /**
  * Returns true if point is inside node's boundary
  * @param p
  * @returns
  */
  couldHold(p3) {
    return intersectsPoint(this.boundary, p3);
  }
  #subdivide() {
    const w3 = this.boundary.width / 2;
    const h5 = this.boundary.height / 2;
    const x3 = this.boundary.x;
    const y3 = this.boundary.y;
    const coords = fromNumbers(x3 + w3, y3, x3, y3, x3, y3 + h5, x3 + w3, y3 + h5);
    const rects = coords.map((p3) => fromTopLeft(p3, w3, h5));
    this.#children = rects.map((r5) => new QuadTreeNode2(this, r5, this.level + 1, this.opts));
  }
};
var scaler2 = (scaleBy = `both`, defaultRect) => {
  const defaultBounds = defaultRect ?? Placeholder;
  let sw = 1;
  let sh2 = 1;
  let s3 = {
    x: 1,
    y: 1
  };
  const computeScale = () => {
    switch (scaleBy) {
      case `height`:
        return {
          x: sh2,
          y: sh2
        };
      case `width`:
        return {
          x: sw,
          y: sw
        };
      case `min`:
        return {
          x: Math.min(sw, sh2),
          y: Math.min(sw, sh2)
        };
      case `max`:
        return {
          x: Math.max(sw, sh2),
          y: Math.max(sw, sh2)
        };
      default:
        return {
          x: sw,
          y: sh2
        };
    }
  };
  const normalise$3 = (a3, b3, c5, d3) => {
    let inX = NaN;
    let inY = NaN;
    let outW = defaultBounds.width;
    let outH = defaultBounds.height;
    if (typeof a3 === `number`) {
      inX = a3;
      if (typeof b3 === `number`) {
        inY = b3;
        if (c5 === void 0) return [
          inX,
          inY,
          outW,
          outH
        ];
        if (isRect(c5)) {
          outW = c5.width;
          outH = c5.height;
        } else if (typeof c5 === `number`) {
          outW = c5;
          if (typeof d3 === `number`) outH = d3;
          else throw new TypeError(`Missing final height value`);
        } else throw new Error(`Missing valid output range`);
      } else if (isRect(b3)) {
        outW = b3.width;
        outH = b3.height;
      } else throw new Error(`Expected input y or output Rect to follow first number parameter`);
    } else if (isPoint(a3)) {
      inX = a3.x;
      inY = a3.y;
      if (b3 === void 0) return [
        inX,
        inY,
        outW,
        outH
      ];
      if (isRect(b3)) {
        outW = b3.width;
        outH = b3.height;
      } else if (typeof b3 === `number`) {
        outW = b3;
        if (typeof c5 === `number`) outH = c5;
        else throw new TypeError(`Expected height as third parameter after Point and output width`);
      } else throw new TypeError(`Expected Rect or width as second parameter when first parameter is a Point`);
    } else throw new Error(`Expected input Point or x value as first parameter`);
    return [
      inX,
      inY,
      outW,
      outH
    ];
  };
  const scaleAbs = (a3, b3, c5, d3) => {
    const n6 = normalise$3(a3, b3, c5, d3);
    return scaleNormalised(true, ...n6);
  };
  const scaleRel = (a3, b3, c5, d3) => {
    const n6 = normalise$3(a3, b3, c5, d3);
    return scaleNormalised(false, ...n6);
  };
  const scaleNormalised = (abs$12, x3, y3, w3, h5) => {
    if (Number.isNaN(w3)) throw new Error(`Output width range missing`);
    if (Number.isNaN(h5)) throw new Error(`Output height range missing`);
    if (w3 !== sw || h5 !== sh2) {
      sw = w3;
      sh2 = h5;
      s3 = computeScale();
    }
    return abs$12 ? {
      x: x3 * s3.x,
      y: y3 * s3.y
    } : {
      x: x3 / s3.x,
      y: y3 / s3.y
    };
  };
  return {
    computeScale,
    rel: scaleRel,
    abs: scaleAbs,
    width: defaultBounds.width,
    height: defaultBounds.height
  };
};
var surface_points_exports = {};
__export(surface_points_exports, {
  circleRings: () => circleRings,
  circleVogelSpiral: () => circleVogelSpiral,
  sphereFibonacci: () => sphereFibonacci
});
var cos2 = Math.cos;
var sin2 = Math.sin;
var asin = Math.asin;
var sqrt2 = Math.sqrt;
var pow2 = Math.pow;
var pi3 = Math.PI;
var piPi$1 = Math.PI * 2;
var goldenAngle = pi3 * (3 - sqrt2(5));
var goldenSection = (1 + sqrt2(5)) / 2;
function* circleVogelSpiral(circle3, opts = {}) {
  const maxPoints = opts.maxPoints ?? 5e3;
  const density = opts.density ?? 0.95;
  const rotationOffset = opts.rotation ?? 0;
  const c5 = toPositioned(circle3 ?? {
    radius: 1,
    x: 0,
    y: 0
  });
  const max4 = c5.radius;
  let spacing = c5.radius * scale(density, 0, 1, 0.3, 0.01);
  if (opts.spacing) spacing = opts.spacing;
  let radius = 0;
  let count3 = 0;
  let angle = 0;
  while (count3 < maxPoints && radius < max4) {
    radius = spacing * count3 ** 0.5;
    angle = rotationOffset + count3 * 2 * pi3 / goldenSection;
    yield Object.freeze({
      x: c5.x + radius * cos2(angle),
      y: c5.y + radius * sin2(angle)
    });
    count3++;
  }
}
function* circleRings(circle3, opts = {}) {
  const rings = opts.rings ?? 5;
  const c5 = toPositioned(circle3 ?? {
    radius: 1,
    x: 0,
    y: 0
  });
  const ringR = 1 / rings;
  const rotationOffset = opts.rotation ?? 0;
  let ringCount = 1;
  yield Object.freeze({
    x: c5.x,
    y: c5.y
  });
  for (let r5 = ringR; r5 <= 1; r5 += ringR) {
    const n6 = Math.round(pi3 / asin(1 / (2 * ringCount)));
    for (const theta of linearSpace(0, piPi$1, n6 + 1)) yield Object.freeze({
      x: c5.x + r5 * cos2(theta + rotationOffset) * c5.radius,
      y: c5.y + r5 * sin2(theta + rotationOffset) * c5.radius
    });
    ringCount++;
  }
}
function* sphereFibonacci(samples = 100, rotationRadians = 0, sphere) {
  const offset$1 = 2 / samples;
  const s3 = sphere ?? {
    x: 0,
    y: 0,
    z: 0,
    radius: 1
  };
  for (let index = 0; index < samples; index++) {
    const y3 = index * offset$1 - 1 + offset$1 / 2;
    const r5 = sqrt2(1 - pow2(y3, 2));
    const a3 = (index + 1) % samples * goldenAngle + rotationRadians;
    const x3 = cos2(a3) * r5;
    const z3 = sin2(a3) * r5;
    yield Object.freeze({
      x: s3.x + x3 * s3.radius,
      y: s3.y + y3 * s3.radius,
      z: s3.z + z3 * s3.radius
    });
  }
}
var angles = (t6) => {
  guard(t6);
  return [
    angleRadian(t6.a, t6.b),
    angleRadian(t6.b, t6.c),
    angleRadian(t6.c, t6.a)
  ];
};
var anglesDegrees = (t6) => {
  guard(t6);
  return radianToDegree(angles(t6));
};
var edges3 = (t6) => {
  guard(t6);
  return joinPointsToLines(t6.a, t6.b, t6.c, t6.a);
};
var area$3 = (t6) => {
  guard(t6, `t`);
  const lengths$2 = edges3(t6).map((l3) => length(l3));
  const p3 = (lengths$2[0] + lengths$2[1] + lengths$2[2]) / 2;
  return Math.sqrt(p3 * (p3 - lengths$2[0]) * (p3 - lengths$2[1]) * (p3 - lengths$2[2]));
};
var barycentricCoord = (t6, a3, b3) => {
  const pt2 = getPointParameter(a3, b3);
  const ab = (x3, y3, pa2, pb) => (pa2.y - pb.y) * x3 + (pb.x - pa2.x) * y3 + pa2.x * pb.y - pb.x * pa2.y;
  const alpha = ab(pt2.x, pt2.y, t6.b, t6.c) / ab(t6.a.x, t6.a.y, t6.b, t6.c);
  const theta = ab(pt2.x, pt2.y, t6.c, t6.a) / ab(t6.b.x, t6.b.y, t6.c, t6.a);
  const gamma = ab(pt2.x, pt2.y, t6.a, t6.b) / ab(t6.c.x, t6.c.y, t6.a, t6.b);
  return {
    a: alpha,
    b: theta,
    c: gamma
  };
};
var barycentricToCartestian = (t6, bc) => {
  guard(t6);
  const { a: a3, b: b3, c: c5 } = t6;
  const x3 = a3.x * bc.a + b3.x * bc.b + c5.x * bc.c;
  const y3 = a3.y * bc.a + b3.y * bc.b + c5.y * bc.c;
  if (a3.z && b3.z && c5.z) {
    const z3 = a3.z * bc.a + b3.z * bc.b + c5.z * bc.c;
    return Object.freeze({
      x: x3,
      y: y3,
      z: z3
    });
  } else return Object.freeze({
    x: x3,
    y: y3
  });
};
var bbox = (t6, inflation = 0) => {
  const { a: a3, b: b3, c: c5 } = t6;
  const xMin = Math.min(a3.x, b3.x, c5.x) - inflation;
  const xMax = Math.max(a3.x, b3.x, c5.x) + inflation;
  const yMin = Math.min(a3.y, b3.y, c5.y) - inflation;
  const yMax = Math.max(a3.y, b3.y, c5.y) + inflation;
  const r5 = {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
  return r5;
};
var corners = (t6) => {
  guard(t6);
  return [
    t6.a,
    t6.b,
    t6.c
  ];
};
var fromRadius = (origin, radius, opts = {}) => {
  resultThrow(numberTest(radius, `positive`, `radius`));
  guard$1(origin, `origin`);
  const initialAngleRadian = opts.initialAngleRadian ?? 0;
  const angles$1 = [
    initialAngleRadian,
    initialAngleRadian + piPi2 * 1 / 3,
    initialAngleRadian + piPi2 * 2 / 3
  ];
  const points = angles$1.map((a3) => toCartesian(radius, a3, origin));
  return fromPoints(points);
};
var fromFlatArray = (coords) => {
  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);
  if (coords.length !== 6) throw new Error(`coords array expected with 6 elements. Got ${coords.length}`);
  return fromPoints(fromNumbers(...coords));
};
var fromPoints = (points) => {
  if (!Array.isArray(points)) throw new Error(`points expected as array`);
  if (points.length !== 3) throw new Error(`points array expected with 3 elements. Got ${points.length}`);
  const t6 = {
    a: points[0],
    b: points[1],
    c: points[2]
  };
  return t6;
};
var perimeter$3 = (t6) => {
  guard(t6);
  return edges3(t6).reduce((accumulator, v3) => accumulator + length(v3), 0);
};
var innerCircle = (t6) => {
  const c5 = centroid(t6);
  const p3 = perimeter$3(t6) / 2;
  const a3 = area$3(t6);
  const radius = a3 / p3;
  return {
    radius,
    ...c5
  };
};
var intersectsPoint$1 = (t6, a3, b3) => {
  const box = bbox(t6);
  const pt2 = getPointParameter(a3, b3);
  if (!intersectsPoint(box, pt2)) return false;
  const bc = barycentricCoord(t6, pt2);
  return 0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1;
};
var lengths = (t6) => {
  guard(t6);
  return [
    distance3(t6.a, t6.b),
    distance3(t6.b, t6.c),
    distance3(t6.c, t6.a)
  ];
};
var isEquilateral = (t6) => {
  guard(t6);
  const [a3, b3, c5] = lengths(t6);
  return a3 === b3 && b3 === c5;
};
var isIsosceles = (t6) => {
  const [a3, b3, c5] = lengths(t6);
  if (a3 === b3) return true;
  if (b3 === c5) return true;
  if (c5 === a3) return true;
  return false;
};
var isRightAngle = (t6) => angles(t6).includes(Math.PI / 2);
var isOblique = (t6) => !isRightAngle(t6);
var isAcute = (t6) => !angles(t6).some((v3) => v3 >= Math.PI / 2);
var isObtuse = (t6) => angles(t6).some((v3) => v3 > Math.PI / 2);
var apply = (t6, fn2) => Object.freeze({
  ...t6,
  a: fn2(t6.a, `a`),
  b: fn2(t6.b, `b`),
  c: fn2(t6.c, `c`)
});
var outerCircle = (t6) => {
  const [a3, b3, c5] = edges3(t6).map((l3) => length(l3));
  const cent = centroid(t6);
  const radius = a3 * b3 * c5 / Math.sqrt((a3 + b3 + c5) * (-a3 + b3 + c5) * (a3 - b3 + c5) * (a3 + b3 - c5));
  return {
    radius,
    ...cent
  };
};
var rotate$1 = (triangle3, amountRadian, origin) => {
  if (amountRadian === void 0 || amountRadian === 0) return triangle3;
  if (origin === void 0) origin = centroid(triangle3);
  return Object.freeze({
    ...triangle3,
    a: rotate(triangle3.a, amountRadian, origin),
    b: rotate(triangle3.b, amountRadian, origin),
    c: rotate(triangle3.c, amountRadian, origin)
  });
};
var rotateByVertex = (triangle3, amountRadian, vertex = `b`) => {
  const origin = vertex === `a` ? triangle3.a : vertex === `b` ? triangle3.b : triangle3.c;
  return Object.freeze({
    a: rotate(triangle3.a, amountRadian, origin),
    b: rotate(triangle3.b, amountRadian, origin),
    c: rotate(triangle3.c, amountRadian, origin)
  });
};
var toFlatArray = (t6) => {
  guard(t6);
  return [
    t6.a.x,
    t6.a.y,
    t6.b.x,
    t6.b.y,
    t6.c.x,
    t6.c.y
  ];
};
var equilateral_exports = {};
__export(equilateral_exports, {
  area: () => area$2,
  centerFromA: () => centerFromA,
  centerFromB: () => centerFromB,
  centerFromC: () => centerFromC,
  circumcircle: () => circumcircle$2,
  fromCenter: () => fromCenter$1,
  height: () => height$2,
  incircle: () => incircle$2,
  perimeter: () => perimeter$2
});
var pi4over3 = Math.PI * 4 / 3;
var pi2over3 = Math.PI * 2 / 3;
var resolveLength = (t6) => {
  if (typeof t6 === `number`) return t6;
  return t6.length;
};
var fromCenter$1 = (t6, origin, rotationRad) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const r5 = resolveLength(t6) / Math.sqrt(3);
  const rot = rotationRad ?? Math.PI * 1.5;
  const b3 = {
    x: r5 * Math.cos(rot) + origin.x,
    y: r5 * Math.sin(rot) + origin.y
  };
  const a3 = {
    x: r5 * Math.cos(rot + pi4over3) + origin.x,
    y: r5 * Math.sin(rot + pi4over3) + origin.y
  };
  const c5 = {
    x: r5 * Math.cos(rot + pi2over3) + origin.x,
    y: r5 * Math.sin(rot + pi2over3) + origin.y
  };
  return Object.freeze({
    a: a3,
    b: b3,
    c: c5
  });
};
var centerFromA = (t6, ptA) => {
  if (!ptA) ptA = Object.freeze({
    x: 0,
    y: 0
  });
  const r5 = resolveLength(t6);
  const { radius } = incircle$2(t6);
  return {
    x: ptA.x + r5 / 2,
    y: ptA.y - radius
  };
};
var centerFromB = (t6, ptB) => {
  if (!ptB) ptB = Object.freeze({
    x: 0,
    y: 0
  });
  const { radius } = incircle$2(t6);
  return {
    x: ptB.x,
    y: ptB.y + radius * 2
  };
};
var centerFromC = (t6, ptC) => {
  if (!ptC) ptC = Object.freeze({
    x: 0,
    y: 0
  });
  const r5 = resolveLength(t6);
  const { radius } = incircle$2(t6);
  return {
    x: ptC.x - r5 / 2,
    y: ptC.y - radius
  };
};
var height$2 = (t6) => Math.sqrt(3) / 2 * resolveLength(t6);
var perimeter$2 = (t6) => resolveLength(t6) * 3;
var area$2 = (t6) => Math.pow(resolveLength(t6), 2) * Math.sqrt(3) / 4;
var circumcircle$2 = (t6) => ({ radius: Math.sqrt(3) / 3 * resolveLength(t6) });
var incircle$2 = (t6) => ({ radius: Math.sqrt(3) / 6 * resolveLength(t6) });
var right_exports = {};
__export(right_exports, {
  adjacentFromHypotenuse: () => adjacentFromHypotenuse,
  adjacentFromOpposite: () => adjacentFromOpposite,
  angleAtPointA: () => angleAtPointA,
  angleAtPointB: () => angleAtPointB,
  area: () => area$1,
  circumcircle: () => circumcircle$1,
  fromA: () => fromA$1,
  fromB: () => fromB$1,
  fromC: () => fromC$1,
  height: () => height$1,
  hypotenuseFromAdjacent: () => hypotenuseFromAdjacent,
  hypotenuseFromOpposite: () => hypotenuseFromOpposite,
  hypotenuseSegments: () => hypotenuseSegments,
  incircle: () => incircle$1,
  medians: () => medians$1,
  oppositeFromAdjacent: () => oppositeFromAdjacent,
  oppositeFromHypotenuse: () => oppositeFromHypotenuse,
  perimeter: () => perimeter$1,
  resolveLengths: () => resolveLengths
});
var fromA$1 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const tt2 = resolveLengths(t6);
  const seg = hypotenuseSegments(t6);
  const h5 = height$1(t6);
  const a3 = {
    x: origin.x,
    y: origin.y
  };
  const b3 = {
    x: origin.x + tt2.hypotenuse,
    y: origin.y
  };
  const c5 = {
    x: origin.x + seg[1],
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromB$1 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const tt2 = resolveLengths(t6);
  const seg = hypotenuseSegments(t6);
  const h5 = height$1(t6);
  const b3 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - tt2.hypotenuse,
    y: origin.y
  };
  const c5 = {
    x: origin.x - seg[0],
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromC$1 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const seg = hypotenuseSegments(t6);
  const h5 = height$1(t6);
  const c5 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - seg[1],
    y: origin.y + h5
  };
  const b3 = {
    x: origin.x + seg[0],
    y: origin.y + h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var resolveLengths = (t6) => {
  const a3 = t6.adjacent;
  const o5 = t6.opposite;
  const h5 = t6.hypotenuse;
  if (a3 !== void 0 && o5 !== void 0) return {
    ...t6,
    adjacent: a3,
    opposite: o5,
    hypotenuse: Math.hypot(a3, o5)
  };
  else if (a3 && h5) return {
    ...t6,
    adjacent: a3,
    hypotenuse: h5,
    opposite: h5 * h5 - a3 * a3
  };
  else if (o5 && h5) return {
    ...t6,
    hypotenuse: h5,
    opposite: o5,
    adjacent: h5 * h5 - o5 * o5
  };
  else if (t6.opposite && t6.hypotenuse && t6.adjacent) return t6;
  throw new Error(`Missing at least two edges`);
};
var height$1 = (t6) => {
  const tt2 = resolveLengths(t6);
  const p3 = tt2.opposite * tt2.opposite / tt2.hypotenuse;
  const q3 = tt2.adjacent * tt2.adjacent / tt2.hypotenuse;
  return Math.sqrt(p3 * q3);
};
var hypotenuseSegments = (t6) => {
  const tt2 = resolveLengths(t6);
  const p3 = tt2.opposite * tt2.opposite / tt2.hypotenuse;
  const q3 = tt2.adjacent * tt2.adjacent / tt2.hypotenuse;
  return [p3, q3];
};
var perimeter$1 = (t6) => {
  const tt2 = resolveLengths(t6);
  return tt2.adjacent + tt2.hypotenuse + tt2.opposite;
};
var area$1 = (t6) => {
  const tt2 = resolveLengths(t6);
  return tt2.opposite * tt2.adjacent / 2;
};
var angleAtPointA = (t6) => {
  const tt2 = resolveLengths(t6);
  return Math.acos((tt2.adjacent * tt2.adjacent + tt2.hypotenuse * tt2.hypotenuse - tt2.opposite * tt2.opposite) / (2 * tt2.adjacent * tt2.hypotenuse));
};
var angleAtPointB = (t6) => {
  const tt2 = resolveLengths(t6);
  return Math.acos((tt2.opposite * tt2.opposite + tt2.hypotenuse * tt2.hypotenuse - tt2.adjacent * tt2.adjacent) / (2 * tt2.opposite * tt2.hypotenuse));
};
var medians$1 = (t6) => {
  const tt2 = resolveLengths(t6);
  const b3 = tt2.adjacent * tt2.adjacent;
  const c5 = tt2.hypotenuse * tt2.hypotenuse;
  const a3 = tt2.opposite * tt2.opposite;
  return [
    Math.sqrt(2 * (b3 + c5) - a3) / 2,
    Math.sqrt(2 * (c5 + a3) - b3) / 2,
    Math.sqrt(2 * (a3 + b3) - c5) / 2
  ];
};
var circumcircle$1 = (t6) => {
  const tt2 = resolveLengths(t6);
  return { radius: tt2.hypotenuse / 2 };
};
var incircle$1 = (t6) => {
  const tt2 = resolveLengths(t6);
  return { radius: (tt2.adjacent + tt2.opposite - tt2.hypotenuse) / 2 };
};
var oppositeFromAdjacent = (angleRad, adjacent) => Math.tan(angleRad) * adjacent;
var oppositeFromHypotenuse = (angleRad, hypotenuse) => Math.sin(angleRad) * hypotenuse;
var adjacentFromHypotenuse = (angleRadian$2, hypotenuse) => Math.cos(angleRadian$2) * hypotenuse;
var adjacentFromOpposite = (angleRadian$2, opposite) => opposite / Math.tan(angleRadian$2);
var hypotenuseFromOpposite = (angleRadian$2, opposite) => opposite / Math.sin(angleRadian$2);
var hypotenuseFromAdjacent = (angleRadian$2, adjacent) => adjacent / Math.cos(angleRadian$2);
var isosceles_exports = {};
__export(isosceles_exports, {
  apexAngle: () => apexAngle,
  area: () => area,
  baseAngle: () => baseAngle,
  circumcircle: () => circumcircle,
  fromA: () => fromA,
  fromB: () => fromB,
  fromC: () => fromC,
  fromCenter: () => fromCenter,
  height: () => height,
  incircle: () => incircle,
  legHeights: () => legHeights,
  medians: () => medians,
  perimeter: () => perimeter
});
var baseAngle = (t6) => Math.acos(t6.base / (2 * t6.legs));
var apexAngle = (t6) => {
  const aa2 = t6.legs * t6.legs;
  const cc = t6.base * t6.base;
  return Math.acos((2 * aa2 - cc) / (2 * aa2));
};
var height = (t6) => {
  const aa2 = t6.legs * t6.legs;
  const cc = t6.base * t6.base;
  return Math.sqrt((4 * aa2 - cc) / 4);
};
var legHeights = (t6) => {
  const b3 = baseAngle(t6);
  return t6.base * Math.sin(b3);
};
var perimeter = (t6) => 2 * t6.legs + t6.base;
var area = (t6) => {
  const h5 = height(t6);
  return h5 * t6.base / 2;
};
var circumcircle = (t6) => {
  const h5 = height(t6);
  const hh2 = h5 * h5;
  const cc = t6.base * t6.base;
  return { radius: (4 * hh2 + cc) / (8 * h5) };
};
var incircle = (t6) => {
  const h5 = height(t6);
  return { radius: t6.base * h5 / (2 * t6.legs + t6.base) };
};
var medians = (t6) => {
  const aa2 = t6.legs * t6.legs;
  const cc = t6.base * t6.base;
  const medianAB = Math.sqrt(aa2 + 2 * cc) / 2;
  const medianC = Math.sqrt(4 * aa2 - cc) / 2;
  return [
    medianAB,
    medianAB,
    medianC
  ];
};
var fromCenter = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height(t6);
  const incircleR = incircle(t6).radius;
  const verticalToApex = h5 - incircleR;
  const a3 = {
    x: origin.x - t6.base / 2,
    y: origin.y + incircleR
  };
  const b3 = {
    x: origin.x + t6.base / 2,
    y: origin.y + incircleR
  };
  const c5 = {
    x: origin.x,
    y: origin.y - verticalToApex
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromA = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height(t6);
  const a3 = {
    x: origin.x,
    y: origin.y
  };
  const b3 = {
    x: origin.x + t6.base,
    y: origin.y
  };
  const c5 = {
    x: origin.x + t6.base / 2,
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromB = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height(t6);
  const b3 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - t6.base,
    y: origin.y
  };
  const c5 = {
    x: origin.x - t6.base / 2,
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromC = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height(t6);
  const c5 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - t6.base / 2,
    y: origin.y + h5
  };
  const b3 = {
    x: origin.x + t6.base / 2,
    y: origin.y + h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var triangle_exports = {};
__export(triangle_exports, {
  Empty: () => Empty$1,
  Equilateral: () => equilateral_exports,
  Isosceles: () => isosceles_exports,
  Placeholder: () => Placeholder$1,
  Right: () => right_exports,
  angles: () => angles,
  anglesDegrees: () => anglesDegrees,
  apply: () => apply,
  area: () => area$3,
  barycentricCoord: () => barycentricCoord,
  barycentricToCartestian: () => barycentricToCartestian,
  bbox: () => bbox,
  centroid: () => centroid,
  corners: () => corners,
  edges: () => edges3,
  equilateralFromVertex: () => equilateralFromVertex,
  fromFlatArray: () => fromFlatArray,
  fromPoints: () => fromPoints,
  fromRadius: () => fromRadius,
  guard: () => guard,
  innerCircle: () => innerCircle,
  intersectsPoint: () => intersectsPoint$1,
  isAcute: () => isAcute,
  isEmpty: () => isEmpty$13,
  isEqual: () => isEqual$1,
  isEquilateral: () => isEquilateral,
  isIsosceles: () => isIsosceles,
  isOblique: () => isOblique,
  isObtuse: () => isObtuse,
  isPlaceholder: () => isPlaceholder$1,
  isRightAngle: () => isRightAngle,
  isTriangle: () => isTriangle,
  lengths: () => lengths,
  outerCircle: () => outerCircle,
  perimeter: () => perimeter$3,
  rotate: () => rotate$1,
  rotateByVertex: () => rotateByVertex,
  toFlatArray: () => toFlatArray
});
var src_exports7 = {};
__export(src_exports7, {
  Arcs: () => arc_exports,
  Beziers: () => bezier_exports,
  Circles: () => circle_exports,
  Compound: () => compound_path_exports,
  CurveSimplification: () => curve_simplification_exports,
  Ellipses: () => ellipse_exports,
  Grids: () => grid_exports,
  Layouts: () => layout_exports,
  Lines: () => line_exports,
  Paths: () => path_exports,
  PointTracker: () => PointTracker,
  Points: () => point_exports,
  PointsTracker: () => PointsTracker,
  Polar: () => polar_exports,
  QuadTree: () => quad_tree_exports,
  Rects: () => rect_exports,
  Shapes: () => shape_exports,
  SurfacePoints: () => surface_points_exports,
  Triangles: () => triangle_exports,
  UserPointerTracker: () => UserPointerTracker,
  UserPointersTracker: () => UserPointersTracker,
  Vectors: () => vector_exports,
  Waypoints: () => waypoint_exports,
  angleConvert: () => angleConvert,
  angleParse: () => angleParse,
  degreeArc: () => degreeArc,
  degreeToGradian: () => degreeToGradian,
  degreeToRadian: () => degreeToRadian,
  degreeToTurn: () => degreeToTurn,
  degreesSum: () => degreesSum,
  gradianToDegree: () => gradianToDegree,
  gradianToRadian: () => gradianToRadian,
  radianArc: () => radianArc,
  radianInvert: () => radianInvert,
  radianToDegree: () => radianToDegree,
  radianToGradian: () => radianToGradian,
  radianToTurn: () => radianToTurn,
  radiansFromAxisX: () => radiansFromAxisX,
  radiansSum: () => radiansSum,
  scaler: () => scaler2,
  turnToDegree: () => turnToDegree,
  turnToRadian: () => turnToRadian
});

// node_modules/ixfx/bundle/src-BnEw_MoE.js
var resolveEl2 = (domQueryOrEl) => {
  const r5 = resolveElementTry(domQueryOrEl);
  if (r5.success) return r5.value;
  throw resultToError(r5);
};
var resolveElementTry = (domQueryOrEl) => {
  if (typeof domQueryOrEl === `string`) {
    const d3 = document.querySelector(domQueryOrEl);
    if (d3 === null) {
      const error = domQueryOrEl.startsWith(`#`) ? `Query '${domQueryOrEl}' did not match anything. Try '#id', 'div', or '.class'` : `Query '${domQueryOrEl}' did not match anything. Did you mean '#${domQueryOrEl}?`;
      return {
        success: false,
        error
      };
    }
    domQueryOrEl = d3;
  } else if (domQueryOrEl === null) return {
    success: false,
    error: `Param 'domQueryOrEl' is null, cannot resolve.`
  };
  else if (domQueryOrEl === void 0) return {
    success: false,
    error: `Param 'domQueryOrEl' is undefined`
  };
  const el$1 = domQueryOrEl;
  return {
    success: true,
    value: el$1
  };
};
var resolveEls = (selectors) => {
  if (selectors === void 0) return [];
  if (selectors === null) return [];
  if (Array.isArray(selectors)) return selectors;
  if (typeof selectors === `string`) {
    const elements = [...document.querySelectorAll(selectors)];
    return elements;
  }
  return [selectors];
};
var data_table_exports = {};
__export(data_table_exports, {
  fromList: () => fromList2,
  fromObject: () => fromObject2
});
var import_dist$1 = __toESM(require_dist(), 1);
var padding = (v3, options) => {
  if (options.leftPadding) {
    if (v3.length < options.leftPadding) return "&nbsp;".repeat(options.leftPadding - v3.length) + v3;
  }
  return v3;
};
var convertNumber = (v3, o5) => {
  v3 = o5.roundNumbers !== void 0 ? round2(o5.roundNumbers, v3) : v3;
  let asString = o5.precision !== void 0 ? v3.toFixed(o5.precision) : v3.toString();
  asString = padding(asString.toString(), o5);
  return asString;
};
var toHtmlSimple = (v3, options) => {
  if (v3 === null) return `(null)`;
  if (v3 === void 0) return `(undefined)`;
  if (typeof v3 === `boolean`) return v3 ? `true` : `false`;
  if (typeof v3 === `string`) return `"${v3}"`;
  if (typeof v3 === `number`) return convertNumber(v3, options.numbers);
  if (typeof v3 === `object`) return toTableSimple(v3, options);
  return import_dist$1.default.stringify(v3);
};
var toTableSimple = (v3, options) => {
  let html = `<div style="display:grid; grid-template-columns: repeat(2, 1fr)">`;
  for (const entry of Object.entries(v3)) {
    const value3 = toHtmlSimple(entry[1], options);
    html += `<div class="label" style="display:table-cell">${entry[0]}</div>
      <div class="data" style="display:table-cell">${value3}</div>`;
  }
  html += `</div>`;
  return html;
};
var fromList2 = (parentOrQuery, data) => {
  const parent = resolveEl2(parentOrQuery);
  let container = document.createElement(`DIV`);
  parent.append(container);
  const options = {
    numbers: {},
    objectsAsTables: true
  };
  const remove6 = () => {
    if (!container) return false;
    container.remove();
    container = void 0;
    return true;
  };
  const update = (data$1) => {
    const seenTables = /* @__PURE__ */ new Set();
    for (const [key, value3] of data$1) {
      const tKey = `table-${key}`;
      seenTables.add(tKey);
      let t6 = parent.querySelector(`#${tKey}`);
      if (t6 === null) {
        t6 = document.createElement(`table`);
        if (!t6) throw new Error(`Could not create table element`);
        t6.id = tKey;
        parent.append(t6);
      }
      updateElement(t6, value3, options);
    }
    const tables = Array.from(parent.querySelectorAll(`table`));
    for (const t6 of tables) if (!seenTables.has(t6.id)) t6.remove();
  };
  if (data) update(data);
  return {
    update,
    remove: remove6
  };
};
var updateElement = (t6, data, options) => {
  const numberFormatting = options.numbers ?? {};
  const idPrefix = options.idPrefix ?? ``;
  const objectsAsTables = options.objectsAsTables ?? false;
  if (data === void 0) {
    t6.innerHTML = ``;
    return;
  }
  const seenRows = /* @__PURE__ */ new Set();
  for (const [key, value3] of Object.entries(data)) {
    const domKey = `${idPrefix}-row-${key}`;
    seenRows.add(domKey);
    let rowEl = t6.querySelector(`tr[data-key='${domKey}']`);
    if (rowEl === null) {
      rowEl = document.createElement(`tr`);
      t6.append(rowEl);
      rowEl.setAttribute(`data-key`, domKey);
      const keyEl = document.createElement(`td`);
      keyEl.textContent = key;
      keyEl.classList.add(`label`);
      rowEl.append(keyEl);
    }
    let valEl = rowEl.querySelector(`td[data-key='${domKey}-val']`);
    if (valEl === null) {
      valEl = document.createElement(`td`);
      valEl.classList.add(`data`);
      valEl.setAttribute(`data-key`, `${domKey}-val`);
      rowEl.append(valEl);
    }
    let valueHTML;
    if (options.formatter) valueHTML = options.formatter(value3, key);
    if (valueHTML === void 0) if (typeof value3 === `object`) valueHTML = objectsAsTables ? toTableSimple(value3, options) : import_dist$1.default.stringify(value3);
    else if (typeof value3 === `number`) valueHTML = convertNumber(value3, numberFormatting);
    else if (typeof value3 === `boolean`) valueHTML = value3 ? `true` : `false`;
    else if (typeof value3 === `string`) valueHTML = `"${value3}"`;
    else valueHTML = JSON.stringify(value3);
    valEl.innerHTML = valueHTML;
  }
  const rows3 = Array.from(t6.querySelectorAll(`tr`));
  for (const r5 of rows3) {
    const key = r5.getAttribute(`data-key`);
    if (!seenRows.has(key)) r5.remove();
  }
};
var fromObject2 = (parentOrQuery, data, opts = {}) => {
  const parent = resolveEl2(parentOrQuery);
  const idPrefix = opts.idPrefix ?? Math.floor(Math.random() * 1e3).toString();
  const options = {
    numbers: {},
    objectsAsTables: true,
    idPrefix: ``,
    ...opts
  };
  let t6 = document.createElement(`table`);
  parent.append(t6);
  const remove6 = () => {
    if (!t6) return false;
    t6.remove();
    t6 = void 0;
    return true;
  };
  if (data) updateElement(t6, data, options);
  const update = (d3) => {
    if (!t6) throw new Error(`Table disposed`);
    updateElement(t6, d3, {
      ...options,
      idPrefix
    });
  };
  return {
    remove: remove6,
    update
  };
};
var drag_drop_exports = {};
__export(drag_drop_exports, { draggable: () => draggable });
var draggable = (elemOrQuery, listener, options = {}) => {
  const elem = resolveEl2(elemOrQuery);
  let initialPointerPosition = Placeholder$2;
  let token;
  const autoTranslate = options.autoTranslate ?? false;
  const quickDrag = options.quickDrag ?? false;
  const fence = options.fence ? resolveEl2(options.fence) : void 0;
  const fenceViewport = options.fenceViewport;
  let fenceOffset = PlaceholderPositioned;
  const relativePosition3 = window.getComputedStyle(elem).position === `relative`;
  const onParentClick = () => {
    const selected = elem.classList.contains(`drag-sel`);
    if (selected) elem.classList.remove(`drag-sel`);
  };
  const onElementClick = (event2) => {
    const selected = elem.classList.contains(`drag-sel`);
    if (selected) elem.classList.remove(`drag-sel`);
    else elem.classList.add(`drag-sel`);
    event2.stopPropagation();
  };
  elem.ownerDocument.addEventListener(`click`, onParentClick);
  elem.addEventListener(`click`, onElementClick);
  const dragCleanup = () => {
    elem.classList.remove(`drag-progress`);
    elem.ownerDocument.removeEventListener(`pointermove`, onPointerMove);
    elem.ownerDocument.removeEventListener(`pointerup`, onPointerUp);
    elem.ownerDocument.removeEventListener(`pointercancel`, onDragCancel);
  };
  const dispose = () => {
    if (elem.classList.contains(`drag-progress`)) onDragCancel(void 0, `dispose`);
    else dragCleanup();
    elem.ownerDocument.removeEventListener(`click`, onParentClick);
    elem.removeEventListener(`click`, onElementClick);
  };
  const validateOffsetAndPoint = (offset3, x3, y3) => {
    if (!isPlaceholder$3(fenceOffset)) {
      offset3 = {
        x: clamp(offset3.x, fenceOffset.x, fenceOffset.width),
        y: clamp(offset3.y, fenceOffset.y, fenceOffset.height)
      };
      if (fenceViewport) {
        x3 = clamp(x3, fenceViewport.x, fenceViewport.x + fenceViewport.width);
        y3 = clamp(y3, fenceViewport.y, fenceViewport.y + fenceViewport.height);
      }
    }
    return [offset3, {
      x: x3,
      y: y3
    }];
  };
  let lastMoveOffset = Empty;
  const onPointerMove = (moveEvent) => {
    moveEvent.preventDefault();
    moveEvent.stopPropagation();
    const { x: x3, y: y3 } = moveEvent;
    let offset3 = isPlaceholder(initialPointerPosition) ? {
      x: moveEvent.offsetX,
      y: moveEvent.offsetY
    } : {
      x: x3 - initialPointerPosition.x,
      y: y3 - initialPointerPosition.y
    };
    const r5 = validateOffsetAndPoint(offset3, x3, y3);
    offset3 = r5[0];
    const state = {
      delta: offset3,
      initial: initialPointerPosition,
      token,
      viewport: r5[1]
    };
    if (typeof listener.progress !== `undefined`) {
      const p3 = listener.progress(state);
      if (p3.abort) {
        onDragCancel(void 0, `discontinued`);
        return;
      }
      if (p3.viewport) offset3 = {
        x: p3.viewport.x - initialPointerPosition.x,
        y: p3.viewport.y - initialPointerPosition.y
      };
    }
    lastMoveOffset = offset3;
    if (autoTranslate) {
      const offsetX = offset3.x;
      const offsetY = offset3.y;
      elem.style.translate = `${offsetX}px ${offsetY}px`;
    }
  };
  const onPointerUp = (upEvent) => {
    const bounds = elem.getBoundingClientRect();
    dragCleanup();
    const { x: x3, y: y3 } = upEvent;
    const r5 = validateOffsetAndPoint(lastMoveOffset, x3, y3);
    const state = {
      initial: initialPointerPosition,
      token,
      delta: r5[0],
      viewport: r5[1]
    };
    if (autoTranslate) {
      elem.style.translate = `none`;
      if (relativePosition3) {
        const parent = elem.parentElement?.getBoundingClientRect();
        elem.style.left = `${bounds.x - parent.left}px`;
        elem.style.top = `${bounds.y - parent.top}px`;
      } else {
        elem.style.left = `${bounds.x}px`;
        elem.style.top = `${bounds.y}px`;
      }
    }
    if (typeof listener.success !== `undefined`) listener.success(state);
  };
  const onDragCancel = (event2, reason = `pointercancel`) => {
    dragCleanup();
    let viewport = Placeholder$2;
    if (event2 && `x` in event2 && `y` in event2) viewport = {
      x: event2.x,
      y: event2.y
    };
    const state = {
      token,
      initial: initialPointerPosition,
      delta: {
        x: -1,
        y: -1
      },
      viewport
    };
    if (typeof listener.abort !== `undefined`) listener.abort(reason, state);
  };
  elem.addEventListener(`pointerdown`, (event2) => {
    const selected = elem.classList.contains(`drag-sel`);
    if (!selected && !quickDrag) return;
    const event_ = event2;
    initialPointerPosition = {
      x: event_.x,
      y: event_.y
    };
    const s3 = typeof listener.start === `undefined` ? {
      allow: true,
      token
    } : listener.start();
    if (!s3.allow) return;
    token = s3.token;
    if (fence) {
      const fenceBounds = fence.getBoundingClientRect();
      fenceOffset = {
        x: fenceBounds.x - initialPointerPosition.x,
        y: fenceBounds.y - initialPointerPosition.y,
        width: fenceBounds.x + fenceBounds.width - initialPointerPosition.x,
        height: fenceBounds.y + fenceBounds.height - initialPointerPosition.y
      };
    } else if (fenceViewport) fenceOffset = {
      x: fenceViewport.x - initialPointerPosition.x,
      y: fenceViewport.y - initialPointerPosition.y,
      width: fenceViewport.width + fenceViewport.x - initialPointerPosition.x,
      height: fenceViewport.height + fenceViewport.y - initialPointerPosition.y
    };
    elem.classList.add(`drag-progress`);
    elem.ownerDocument.addEventListener(`pointermove`, onPointerMove);
    elem.ownerDocument.addEventListener(`pointerup`, onPointerUp);
    elem.ownerDocument.addEventListener(`pointercancel`, onDragCancel);
  });
  return dispose;
};
var forms_exports = {};
__export(forms_exports, {
  button: () => button,
  buttonCreate: () => buttonCreate,
  checkbox: () => checkbox,
  numeric: () => numeric,
  select: () => select,
  textAreaKeyboard: () => textAreaKeyboard
});
var textAreaKeyboard = (el$1) => {
  el$1.addEventListener(`keydown`, (event2) => {
    const elementValue = el$1.value;
    const start = el$1.selectionStart;
    const end = el$1.selectionEnd;
    if (event2.key === `Tab` && event2.shiftKey) {
      if (el$1.value.substring(start - 2, start) === `  `) el$1.value = elementValue.slice(0, Math.max(0, start - 2)) + elementValue.slice(Math.max(0, end));
      el$1.selectionStart = el$1.selectionEnd = start - 2;
      event2.preventDefault();
      return false;
    } else if (event2.key === `Tab`) {
      el$1.value = elementValue.slice(0, Math.max(0, start)) + `  ` + elementValue.slice(Math.max(0, end));
      el$1.selectionStart = el$1.selectionEnd = start + 2;
      event2.preventDefault();
      return false;
    }
  });
};
var checkbox = (domIdOrEl, onChanged) => {
  const el$1 = resolveEl2(domIdOrEl);
  if (onChanged) el$1.addEventListener(`change`, () => {
    onChanged(el$1.checked);
  });
  return {
    get checked() {
      return el$1.checked;
    },
    set checked(value3) {
      el$1.checked = value3;
    }
  };
};
var numeric = (domIdOrEl, onChanged, live) => {
  const el$1 = resolveEl2(domIdOrEl);
  const eventName = live ? `change` : `input`;
  if (onChanged) el$1.addEventListener(eventName, () => {
    onChanged(Number.parseInt(el$1.value));
  });
  return {
    get value() {
      return Number.parseInt(el$1.value);
    },
    set value(value3) {
      el$1.value = value3.toString();
    }
  };
};
var button = (domQueryOrEl, onClickHandler) => {
  const el$1 = resolveEl2(domQueryOrEl);
  const addEvent = () => {
    if (onClickHandler) el$1.addEventListener(`click`, onClickHandler);
  };
  const removeEvent = () => {
    if (onClickHandler) el$1.removeEventListener(`click`, onClickHandler);
  };
  addEvent();
  return {
    get title() {
      return el$1.textContent;
    },
    set title(value3) {
      el$1.textContent = value3;
    },
    dispose(deleteElement = false) {
      removeEvent();
      if (deleteElement) el$1.remove();
    },
    onClick(handler) {
      removeEvent();
      onClickHandler = handler;
      addEvent();
    },
    click() {
      if (onClickHandler) onClickHandler();
    },
    set disabled(value3) {
      el$1.disabled = value3;
    },
    get el() {
      return el$1;
    }
  };
};
var buttonCreate = (title, onClick) => {
  const el$1 = document.createElement(`button`);
  const w3 = button(el$1, onClick);
  w3.title = title;
  return w3;
};
var select = (domQueryOrEl, onChanged, options = {}) => {
  const el$1 = resolveEl2(domQueryOrEl);
  const { placeholderOpt, shouldAddChoosePlaceholder = false, autoSelectAfterChoice = -1 } = options;
  const change = () => {
    if (onChanged !== void 0) onChanged(el$1.value);
    if (autoSelectAfterChoice >= 0) el$1.selectedIndex = autoSelectAfterChoice;
  };
  if (onChanged) el$1.addEventListener(`change`, (_event) => {
    change();
  });
  return {
    set disabled(value3) {
      el$1.disabled = value3;
    },
    get value() {
      return el$1.value;
    },
    get index() {
      return el$1.selectedIndex;
    },
    get isSelectedPlaceholder() {
      return (shouldAddChoosePlaceholder || options.placeholderOpt !== void 0) && el$1.selectedIndex === 0;
    },
    setOpts(opts, preSelect) {
      el$1.options.length = 0;
      if (shouldAddChoosePlaceholder) opts = [`-- Choose --`, ...opts];
      else if (placeholderOpt !== void 0) opts = [placeholderOpt, ...opts];
      let toSelect = 0;
      for (const [index, o5] of opts.entries()) {
        const optEl = document.createElement(`option`);
        optEl.value = o5;
        optEl.innerHTML = o5;
        if (preSelect !== void 0 && o5 === preSelect) toSelect = index;
        el$1.options.add(optEl);
      }
      el$1.selectedIndex = toSelect;
    },
    select(index = 0, trigger = false) {
      el$1.selectedIndex = index;
      if (trigger && onChanged) change();
    }
  };
};
function isHtmlElement(o5) {
  return typeof HTMLElement === "object" ? o5 instanceof HTMLElement : o5 && typeof o5 === "object" && o5 !== null && o5.nodeType === 1 && typeof o5.nodeName === "string";
}
var parseCssVariablesAsAttributes = (options) => {
  return options.map((opt) => {
    let defaultValue;
    if (Array.isArray(opt)) {
      defaultValue = opt[1];
      opt = opt[0];
    }
    const dash = opt.indexOf(`-`);
    if (dash < 0) throw new Error(`Simple expression expects form of: 'elementid-attribute'`);
    return {
      variable: opt,
      attribute: opt.slice(dash + 1),
      id: opt.slice(0, dash),
      defaultValue
    };
  });
};
var setFromCssVariables = (context, ...options) => {
  const contextEl = resolveEl2(context);
  const style = window.getComputedStyle(contextEl);
  for (const opt of options) {
    const variable = afterMatch(opt.variable, `--`);
    let v3 = style.getPropertyValue(`--${variable}`);
    if (v3 === null || v3.length === 0) if (opt.defaultValue === void 0) continue;
    else v3 = opt.defaultValue;
    let query$1;
    let els;
    if (`query` in opt && opt.query !== void 0) query$1 = opt.query;
    else if (`id` in opt && opt.id !== void 0) query$1 = `#${opt.id}`;
    else if (`object` in opt && opt.object !== void 0) els = Array.isArray(opt.object) ? opt.object : [opt.object];
    if (query$1 === void 0) {
      if (els === void 0) throw new Error(`Missing 'query', 'id' or 'object' fields`);
    } else els = [...contextEl.querySelectorAll(query$1)];
    if (els === null) continue;
    if (els === void 0) continue;
    if (opt.attribute) for (const el$1 of els) if (isHtmlElement(el$1)) el$1.setAttribute(opt.attribute, v3);
    else throw new Error(`Trying to set an attribute on something not a HTML element`, { cause: el$1 });
    else if (opt.field) for (const el$1 of els) if (typeof el$1 === `object`) el$1[opt.field] = v3;
    else throw new Error(`Trying to set field on something that is not an object (${typeof el$1})`, { cause: el$1 });
    else throw new Error(`Neither 'attribute' or 'field' to set is defined in option (${JSON.stringify(opt)})`);
  }
};
function getCssVariablesWithFallback(fallback, elt) {
  const styles = getComputedStyle(elt ?? document.body);
  const entries2 = Object.entries(fallback);
  const filledEntries = entries2.map((entry) => {
    return [entry[0], getCssVariablesFromStyles(styles, entry[0], entry[1])];
  });
  return Object.fromEntries(filledEntries);
}
function getCssVariable(cssVariable, fallbackValue) {
  if (!cssVariable.startsWith(`--`)) cssVariable = `--${cssVariable}`;
  const fromCss3 = getComputedStyle(document.body).getPropertyValue(cssVariable).trim();
  if (fromCss3.length === 0) return fallbackValue;
  return fromCss3;
}
function setCssVariables(variables, stylesOrEl) {
  const styles = stylesOrEl === void 0 ? document.body.style : isHtmlElement(stylesOrEl) ? stylesOrEl.style : stylesOrEl;
  for (const [key, value3] of Object.entries(variables)) {
    let variableName = key.replaceAll("_", "-");
    if (!variableName.startsWith(`--`)) variableName = `--` + variableName;
    styles.setProperty(variableName, value3.toString());
  }
}
function getCssVariablesFromStyles(styles, name, fallback) {
  if (!name.startsWith(`--`)) name = `--` + name;
  name = name.replaceAll(`_`, `-`);
  const v3 = styles.getPropertyValue(name);
  if (v3.length === 0) return fallback;
  if (typeof fallback === `number`) return parseFloat(v3);
  if (typeof fallback === `boolean`) {
    if (v3 === `true`) return true;
    else if (v3 === `false`) return false;
  }
  return v3;
}
var getBoundingClientRectWithBorder = (elOrQuery) => {
  let el$1 = resolveEl2(elOrQuery);
  const size = el$1.getBoundingClientRect();
  if (el$1 instanceof SVGElement) el$1 = el$1.parentElement;
  const border = getComputedPixels(el$1, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);
  return {
    x: size.x,
    y: size.y,
    width: size.width + border.borderLeftWidth + border.borderRightWidth,
    height: size.height + border.borderTopWidth + border.borderBottomWidth
  };
};
var getComputedPixels = (elOrQuery, ...properties) => {
  const s3 = getComputedStyle(resolveEl2(elOrQuery));
  const returnValue = {};
  for (const property of properties) {
    const v3 = s3[property];
    if (typeof v3 === `string`) if (v3.endsWith(`px`)) returnValue[property] = Number.parseFloat(v3.substring(0, v3.length - 2));
    else throw new Error(`Property '${String(property)}' does not end in 'px'. Value: ${v3}`);
    else throw new Error(`Property '${String(property)}' is not type string. Got: ${typeof v3} Value: ${v3}`);
  }
  return returnValue;
};
var setCssClass = (selectors, value3, cssClass) => {
  const elements = resolveEls(selectors);
  if (elements.length === 0) return;
  for (const element of elements) if (value3) element.classList.add(cssClass);
  else element.classList.remove(cssClass);
};
var setCssToggle = (selectors, cssClass) => {
  const elements = resolveEls(selectors);
  if (elements.length === 0) return;
  for (const element of elements) element.classList.toggle(cssClass);
};
var setCssDisplay = (selectors, value3) => {
  const elements = resolveEls(selectors);
  if (elements.length === 0) return;
  for (const element of elements) element.style.display = value3;
};
var DataDisplay = class {
  dataTable;
  /**
  * Constructor
  * @param options Options
  */
  constructor(options = {}) {
    const theme = options.theme ?? `dark`;
    const existing = document.querySelector(`#ixfx-data-display`);
    if (existing !== null) throw new Error(`DataDisplay already loaded on this page`);
    const container = document.createElement(`div`);
    container.id = `ixfx-data-display`;
    container.classList.add(`theme-${theme}`);
    const css = document.createElement(`style`);
    css.textContent = `
    #ixfx-data-display {
      background: white;
      color: black;
      border: 2px solid hsl(0deg 0.61% 90%);
      border-radius: 4px;
      z-index: 1000;
      opacity: 40%;
      padding: 1em;
      font-family: monospace;
      position: fixed;
      right: 1em;
      top: 1em;
    }
    #ixfx-data-display.theme-dark {
      background: black;
      color: white;
      border: 2px solid hsl(0deg 0.61% 10%);
    }
    #ixfx-data-display:hover {
      opacity: 100%;
    }
    #ixfx-data-display table {
      border-collapse: collapse;
    }
    #ixfx-data-display tr:not(:last-child) {
      border-bottom: 2px solid hsl(0deg 0.61% 90%);
    }
    #ixfx-data-display.dark tr:not(:last-child) {
      border-bottom: 2px solid hsl(0deg 0.61% 10%);
    }
    #ixfx-data-display td {
      padding-bottom: 0.4em;
      padding-top: 0.4em;
    }
    #ixfx-data-display .label {
      color: hsl(0deg 0.61% 60%);
      text-align: right;
      padding-right: 0.5em;
    }
    #ixfx-data-display.theme-dark .label {
      color: gray;
    }
    `;
    container.style.display = `inline-block`;
    document.body.append(css);
    document.body.append(container);
    this.dataTable = fromObject2(container, void 0, {
      objectsAsTables: true,
      ...options
    });
  }
  update(data) {
    this.dataTable.update(data);
  }
};
function setText(selectors, value3) {
  return setProperty(`textContent`, selectors, value3);
}
function setHtml(selectors, value3) {
  return setProperty(`innerHTML`, selectors, value3);
}
function setProperty(property, selectors, value3) {
  let elements = [];
  const set5 = (v3) => {
    const typ = typeof v3;
    const vv = typ === `string` || typ === `number` || typ === `boolean` ? v3 : JSON.stringify(v3);
    if (elements.length === 0) elements = resolveEls(selectors);
    for (const element of elements) element[property] = vv;
    return vv;
  };
  return value3 === void 0 ? set5 : set5(value3);
}
var el = (selectors) => {
  const elements = resolveEls(selectors);
  const text3 = setText(elements);
  const html = setHtml(elements);
  return {
    text: text3,
    html,
    cssDisplay: (value3) => {
      setCssDisplay(elements, value3);
    },
    cssClass: (value3, cssClass) => {
      setCssClass(elements, value3, cssClass);
    },
    cssToggle: (cssClass) => {
      setCssToggle(elements, cssClass);
    },
    el: () => elements[0],
    els: () => elements
  };
};
var elRequery = (selectors) => ({
  text: (value3) => setText(selectors, value3),
  html: (value3) => setHtml(selectors, value3),
  cssDisplay: (value3) => {
    setCssDisplay(selectors, value3);
  },
  cssClass: (value3, cssClass) => {
    setCssClass(selectors, value3, cssClass);
  },
  cssToggle: (cssClass) => {
    setCssToggle(selectors, cssClass);
  },
  el: () => resolveEl2(selectors),
  els: () => resolveEls(selectors)
});
var debounce3 = (callback, interval2) => {
  let timer;
  const ms2 = intervalToMs(interval2, 100);
  return () => {
    if (timer) clearTimeout(timer);
    timer = setTimeout(callback, ms2);
  };
};
var ElementSizer = class ElementSizer2 {
  #stretch;
  #size;
  #naturalSize;
  #naturalRatio;
  #viewport;
  #onSizeChanging = (size, el$1) => {
  };
  #el;
  #containerEl;
  #disposed = false;
  #resizeObservable;
  #sizeDebounce = () => ({});
  constructor(elOrQuery, options) {
    this.#el = resolveEl2(elOrQuery);
    const container = options.containerEl;
    if (container === null || typeof container === `undefined`) {
      const pe2 = this.#el.parentElement;
      if (pe2 !== null) this.#containerEl = pe2;
      else {
        const pn2 = this.#el.parentNode;
        if (pn2 !== null) this.#containerEl = pn2;
      }
    } else if (typeof container === `string` || typeof container === `object`) this.#containerEl = resolveEl2(container);
    this.#stretch = options.stretch ?? `none`;
    this.#onSizeChanging = options.onSizeChanging;
    this.#size = Empty$3;
    const onSizeDone = options.onSizeDone;
    if (typeof onSizeDone !== `undefined`) this.#sizeDebounce = debounce3(() => {
      onSizeDone(this.size, this.#el);
    }, options.debounceTimeout);
    let naturalSize = options.naturalSize;
    naturalSize ??= this.#el.getBoundingClientRect();
    this.#naturalRatio = 1;
    this.#naturalSize = naturalSize;
    this.setNaturalSize(naturalSize);
    this.#viewport = EmptyPositioned;
    if (this.#containerEl === document.body) this.#byViewport();
    else this.#byContainer();
  }
  dispose(reason) {
    if (this.#disposed) return;
    this.#disposed = true;
    if (this.#resizeObservable) {
      this.#resizeObservable.disconnect();
      this.#resizeObservable = void 0;
    }
  }
  static canvasParent(canvasElementOrQuery, options) {
    const el$1 = resolveEl2(canvasElementOrQuery);
    const er2 = new ElementSizer2(el$1, {
      ...options,
      onSizeChanging(size, el$2) {
        el$2.width = size.width;
        el$2.height = size.height;
        if (options.onSizeChanging) options.onSizeChanging(size, el$2);
      }
    });
    return er2;
  }
  static canvasViewport(canvasElementOrQuery, options) {
    const el$1 = resolveEl2(canvasElementOrQuery);
    el$1.style.position = `absolute`;
    el$1.style.zIndex = (options.zIndex ?? 0).toString();
    el$1.style.left = `0px`;
    el$1.style.top = `0px`;
    const opts = {
      ...options,
      containerEl: document.body
    };
    return this.canvasParent(canvasElementOrQuery, opts);
  }
  /**
  * Size an SVG element to match viewport
  * @param svg
  * @returns
  */
  static svgViewport(svg, onSizeSet) {
    const er2 = new ElementSizer2(svg, {
      containerEl: document.body,
      stretch: `both`,
      onSizeChanging(size) {
        svg.setAttribute(`width`, size.width.toString());
        svg.setAttribute(`height`, size.height.toString());
        if (onSizeSet) onSizeSet(size);
      }
    });
    return er2;
  }
  #byContainer() {
    const c5 = this.#containerEl;
    if (!c5) throw new Error(`No container element`);
    const r5 = new ResizeObserver((entries2) => {
      this.#onParentResize(entries2);
    });
    r5.observe(c5);
    const current = this.#computeSizeBasedOnParent(c5.getBoundingClientRect());
    this.size = current;
    this.#resizeObservable = r5;
  }
  #byViewport() {
    const r5 = new ResizeObserver((entries2) => {
      this.#onViewportResize();
    });
    r5.observe(document.documentElement);
    this.#resizeObservable = r5;
    this.#onViewportResize();
  }
  #onViewportResize() {
    this.size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    this.#viewport = {
      x: 0,
      y: 0,
      ...this.size
    };
  }
  /**
  * Sets the 'natural' size of an element.
  * This can also be specified when creating ElementSizer.
  * @param size
  */
  setNaturalSize(size) {
    this.#naturalSize = size;
    this.#naturalRatio = size.width / size.height;
  }
  get naturalSize() {
    return this.#naturalSize;
  }
  get viewport() {
    return this.#viewport;
  }
  #computeSizeBasedOnParent(parentSize) {
    let { width, height: height3 } = parentSize;
    let stretch = this.#stretch;
    if (stretch === `min`) stretch = width < height3 ? `width` : `height`;
    else if (stretch === `max`) stretch = width > height3 ? `width` : `height`;
    if (stretch === `width`) height3 = width / this.#naturalRatio;
    else if (stretch === `height`) width = height3 * this.#naturalRatio;
    if (this.#el instanceof HTMLElement) {
      const b3 = getComputedPixels(this.#el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);
      width -= b3.borderLeftWidth + b3.borderRightWidth;
      height3 -= b3.borderTopWidth + b3.borderBottomWidth;
    }
    return {
      width,
      height: height3
    };
  }
  #onParentResize(args) {
    const box = args[0].contentBoxSize[0];
    const parentSize = {
      width: box.inlineSize,
      height: box.blockSize
    };
    this.size = this.#computeSizeBasedOnParent(parentSize);
    this.#viewport = {
      x: 0,
      y: 0,
      width: parentSize.width,
      height: parentSize.height
    };
  }
  set size(size) {
    guard$6(size, `size`);
    this.#size = size;
    if (this.#onSizeChanging) this.#onSizeChanging(size, this.#el);
    this.#sizeDebounce();
  }
  get size() {
    return this.#size;
  }
};
var defaultErrorHandler = () => {
  let enabled = true;
  const container = document.createElement(`div`);
  container.style.color = `black`;
  container.style.border = `2px solid red`;
  container.style.backgroundColor = `hsl(0, 80%, 90%)`;
  container.style.padding = `1em`;
  container.style.display = `none`;
  container.style.top = `1em`;
  container.style.left = `1em`;
  container.style.position = `absolute`;
  container.style.fontFamily = `monospace`;
  const messageElement = document.createElement(`div`);
  messageElement.style.maxWidth = `50vw`;
  messageElement.style.maxHeight = `50vh`;
  messageElement.style.overflowY = `scroll`;
  container.innerHTML = `<h1>Error</h1>`;
  container.append(messageElement);
  const styleButton = (b3) => {
    b3.style.padding = `0.3em`;
    b3.style.marginTop = `1em`;
  };
  const buttonClose = document.createElement(`button`);
  buttonClose.textContent = `Close`;
  buttonClose.addEventListener(`click`, () => {
    hide();
  });
  const buttonStop = document.createElement(`button`);
  buttonStop.textContent = `Stop displaying errors`;
  buttonStop.addEventListener(`click`, () => {
    enabled = false;
    hide();
  });
  styleButton(buttonClose);
  styleButton(buttonStop);
  container.append(buttonClose);
  container.append(buttonStop);
  document.body.append(container);
  const show = (ex) => {
    container.style.display = `inline`;
    messageElement.innerHTML += ex.stack ? `<pre>${ex.stack}</pre>` : `<p>${getErrorMessage2(ex)}</p>`;
  };
  const hide = () => {
    container.style.display = `none`;
  };
  window.onerror = (message, url, lineNo, colNo, error) => {
    if (enabled) if (error) {
      console.log(error);
      show(error);
    } else {
      console.log(message);
      show(message);
    }
  };
  window.addEventListener(`unhandledrejection`, (event2) => {
    console.log(event2.reason);
    if (enabled) show(event2.reason);
  });
  return {
    show,
    hide
  };
};
var addShadowCss = (parentEl, styles) => {
  const styleEl = document.createElement(`style`);
  styleEl.textContent = styles;
  let shadowRoot;
  if (parentEl.shadowRoot) {
    shadowRoot = parentEl.shadowRoot;
    shadowRoot.innerHTML = ``;
  } else shadowRoot = parentEl.attachShadow({ mode: `open` });
  shadowRoot.append(styleEl);
  return shadowRoot;
};
var log = (domQueryOrElement, opts = {}) => {
  const { capacity = 0, monospaced = true, timestamp: timestamp2 = false, collapseDuplicates = true, css = `` } = opts;
  let added = 0;
  let lastLog;
  let lastLogRepeats = 0;
  const parentElement = resolveEl2(domQueryOrElement);
  const fontFamily = monospaced ? `Consolas, "Andale Mono WT", "Andale Mono", "Lucida Console", "Lucida Sans Typewriter", "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Liberation Mono", Monaco, "Courier New", Courier, monospace` : `normal`;
  const shadowRoot = addShadowCss(parentElement, `
  .log {
    font-family: ${fontFamily};
    background-color: var(--code-background-color);
    padding: var(--padding1, 0.2em);
    overflow-y: auto;
    height:100%;
  }
  .timestamp {
    margin-right: 0.5em;
    opacity: 0.5;
    font-size: 70%;
    align-self: center;
  }
  .line {
    display: flex;
    padding-bottom: 0.1em;
    padding-top: 0.1em;
  }
  .line:hover {
  
  }
  .error {
    color: red;
  }
  .badge {
    border: 1px solid currentColor;
    align-self: center;
    font-size: 70%;
    padding-left: 0.2em;
    padding-right: 0.2em;
    border-radius: 1em;
    margin-left: 0.5em;
    margin-right: 0.5em;
  }
  .msg {
    flex: 1;
    word-break: break-word;
  }
  ${css}
  `);
  const el$1 = document.createElement(`div`);
  el$1.className = `log`;
  shadowRoot.append(el$1);
  const error = (messageOrError) => {
    const line3 = document.createElement(`div`);
    if (typeof messageOrError === `string`) line3.innerHTML = messageOrError;
    else if (messageOrError instanceof Error) {
      const stack = messageOrError.stack;
      line3.innerHTML = stack === void 0 ? messageOrError.toString() : stack.toString();
    } else line3.innerHTML = messageOrError;
    line3.classList.add(`error`);
    append(line3);
    lastLog = void 0;
    lastLogRepeats = 0;
  };
  let lastLogTime = 0;
  const warn = (whatToLog = ``) => {
    const element = log$1(whatToLog);
    if (!element) return element;
    element.classList.add(`warning`);
    return element;
  };
  const log$1 = (whatToLog = ``) => {
    let message;
    const interval2 = window.performance.now() - lastLogTime;
    if (opts.minIntervalMs && interval2 < opts.minIntervalMs) return;
    lastLogTime = window.performance.now();
    if (typeof whatToLog === `object`) message = JSON.stringify(whatToLog);
    else if (whatToLog === void 0) message = `(undefined)`;
    else if (whatToLog === null) message = `(null)`;
    else if (typeof whatToLog === `number`) {
      if (Number.isNaN(message)) message = `(NaN)`;
      message = whatToLog.toString();
    } else message = whatToLog;
    if (message.length === 0) {
      const rule = document.createElement(`hr`);
      lastLog = void 0;
      append(rule);
    } else if (message === lastLog && collapseDuplicates) {
      const lastElement = el$1.firstElementChild;
      let lastBadge = lastElement.querySelector(`.badge`);
      if (lastBadge === null) {
        lastBadge = document.createElement(`div`);
        lastBadge.className = `badge`;
        lastElement.insertAdjacentElement(`beforeend`, lastBadge);
      }
      if (lastElement !== null) lastBadge.textContent = (++lastLogRepeats).toString();
      return lastElement;
    } else {
      const line3 = document.createElement(`div`);
      line3.textContent = message;
      append(line3);
      lastLog = message;
      return line3;
    }
  };
  const append = (line3) => {
    if (timestamp2) {
      const wrapper = document.createElement(`div`);
      const timestamp$1 = document.createElement(`div`);
      timestamp$1.className = `timestamp`;
      timestamp$1.textContent = (/* @__PURE__ */ new Date()).toLocaleTimeString();
      wrapper.append(timestamp$1, line3);
      line3.classList.add(`msg`);
      wrapper.classList.add(`line`);
      line3 = wrapper;
    } else line3.classList.add(`line`, `msg`);
    if (opts.reverse) el$1.append(line3);
    else el$1.insertBefore(line3, el$1.firstChild);
    if (capacity > 0 && ++added > capacity * 2) while (added > capacity) {
      el$1.lastChild?.remove();
      added--;
    }
    if (opts.reverse) el$1.scrollTop = el$1.scrollHeight;
    lastLogRepeats = 0;
  };
  const clear$1 = () => {
    el$1.innerHTML = ``;
    lastLog = void 0;
    lastLogRepeats = 0;
    added = 0;
  };
  const dispose = () => {
    el$1.remove();
  };
  return {
    error,
    log: log$1,
    warn,
    append,
    clear: clear$1,
    dispose,
    get isEmpty() {
      return added === 0;
    }
  };
};
var inlineConsole = (options = {}) => {
  const original = {
    log: console.log,
    error: console.error,
    warn: console.warn
  };
  const witholdCss = options.witholdCss ?? false;
  const insertIntoEl = options.insertIntoEl;
  let logElement;
  if (insertIntoEl) logElement = resolveEl2(insertIntoEl);
  else {
    logElement = document.createElement(`DIV`);
    logElement.id = `ixfx-log`;
    document.body.prepend(logElement);
  }
  if (!witholdCss) {
    logElement.style.position = `fixed`;
    logElement.style.left = `0px`;
    logElement.style.top = `0px`;
    logElement.style.pointerEvents = `none`;
    logElement.style.display = `none`;
  }
  const logger2 = log(logElement, options);
  const visibility = (show) => {
    logElement.style.display = show ? `block` : `none`;
  };
  console.error = (message, ...optionalParameters) => {
    logger2.error(message);
    if (optionalParameters.length > 0) logger2.error(optionalParameters);
    original.error(message, ...optionalParameters);
    visibility(true);
  };
  console.warn = (message, ...optionalParameters) => {
    logger2.warn(message);
    if (optionalParameters.length > 0) logger2.warn(optionalParameters);
    visibility(true);
  };
  console.log = (message, ...optionalParameters) => {
    logger2.log(message);
    if (optionalParameters.length > 0) logger2.log(optionalParameters);
    original.log(message, ...optionalParameters);
    visibility(true);
  };
  window.onerror = (event2, source, lineno, _colno, error) => {
    const abbreviatedSource = source === void 0 ? `` : afterMatch(source, `/`, { fromEnd: true });
    const eventString = getErrorMessage2(error);
    logger2.error(eventString + ` (${abbreviatedSource}:${lineno})`);
    visibility(true);
  };
  window.addEventListener("unhandledrejection", function(e5) {
    logger2.error(e5.reason);
    visibility(true);
  });
};
async function* query2(queryOrElement, options = {}) {
  if (typeof queryOrElement === `string`) return query2([queryOrElement], options);
  else if (typeof queryOrElement === `object` && `nodeName` in queryOrElement) return query2([queryOrElement], options);
  const ensureUnique = options ?? false;
  const isUnique = ensureUnique ? uniqueInstances() : (_3) => true;
  if (Array.isArray(queryOrElement)) {
    for (const item of queryOrElement) if (typeof item === `string`) for (const element of document.querySelectorAll(item)) {
      const elementProper = element;
      if (isUnique(elementProper)) yield elementProper;
    }
    else if (isUnique(item)) yield item;
  } else for await (const item of queryOrElement) if (typeof item === `string`) {
    for (const element of document.querySelectorAll(item)) if (isUnique(element)) yield element;
  } else if (isUnique(item)) yield item;
}
var tabSet = (options) => {
  const panels = options.panels;
  const preselectId = options.preselectId ?? panels[0].id;
  const guid = `tabset-${shortGuid()}`;
  const parentEl = resolveEl2(options.parent);
  const switcher = `
  <div class="ixfx-tabset" id="${guid}">
    <fieldset class="ixfx-tabset-controls">
    ${panels.map((p3) => {
    const panelId = `${guid}-${p3.id}-select`;
    return `<input type="radio" name="${guid}-tabs" id="${panelId}" data-tabset="${p3.id}"><label for="${panelId}">${p3.label}</label>`;
  }).join(``)}
    </fieldset>
    <div class="ixfx-tabset-host" id="${guid}-host"></div>
  </div>
  `;
  parentEl.innerHTML = switcher;
  const hostEl = document.getElementById(`${guid}-host`);
  const tabSetEl = document.getElementById(guid);
  tabSetEl.querySelector(`fieldset`)?.addEventListener(`change`, (event2) => {
    const el$1 = event2.target;
    select$1(el$1.getAttribute(`data-tabset`));
  });
  let currentPanel;
  const select$1 = (id) => {
    const newPanel = panels.find((p3) => p3.id === id);
    const priorPanel = currentPanel;
    if (options.onPanelChanging) {
      const allow = options.onPanelChanging(priorPanel, newPanel);
      if (typeof allow === `boolean` && !allow) return;
    }
    if (priorPanel) priorPanel.dismount();
    currentPanel = newPanel;
    if (newPanel) {
      newPanel.mount(hostEl);
      const domId = `#${guid}-${id}-select`;
      const inputEl = tabSetEl.querySelector(domId);
      if (inputEl) inputEl.checked = true;
      else console.warn(`Could not find INPUT element for panel id: ${id} (${domId})`);
    }
    if (options.onPanelChange) options.onPanelChange(priorPanel, newPanel);
  };
  select$1(preselectId);
  let warned = false;
  const notify = (name, args) => {
    if (!currentPanel) return;
    if (currentPanel.notify) currentPanel.notify(name, args);
    else if (!warned) {
      warned = true;
      console.warn(`TabbedPanel.notify dropping notification '${name}'. Panel implementation is missing 'notify' function`);
    }
  };
  return {
    select: select$1,
    panels,
    hostEl,
    tabSetEl,
    notify
  };
};
var import_dist = __toESM(require_dist(), 1);
var pointScaler = (reference = `viewport`) => {
  switch (reference) {
    case `viewport`:
      return (a3, b3) => {
        const pt2 = getPointParameter(a3, b3);
        return Object.freeze({
          x: pt2.x / window.innerWidth,
          y: pt2.y / window.innerHeight
        });
      };
    case `screen`:
      return (a3, b3) => {
        const pt2 = getPointParameter(a3, b3);
        return Object.freeze({
          x: pt2.x / screen.width,
          y: pt2.y / screen.height
        });
      };
    case `document`:
      return (a3, b3) => {
        const pt2 = getPointParameter(a3, b3);
        return Object.freeze({
          x: pt2.x / document.body.scrollWidth,
          y: pt2.y / document.body.scrollHeight
        });
      };
    default:
      throw new Error(`Unknown 'reference' parameter: ${JSON.stringify(reference)}`);
  }
};
var positionFn = (domQueryOrEl, options = {}) => {
  const targetSpace = options.target ?? `viewport`;
  const relative2 = options.relative ?? false;
  const anchor = options.anchor ?? `nw`;
  const el$1 = resolveEl2(domQueryOrEl);
  const vpToSpace = viewportToSpace(targetSpace);
  if (relative2) {
    const s3 = pointScaler(targetSpace);
    return () => s3(vpToSpace(cardinal(el$1.getBoundingClientRect(), anchor)));
  } else return () => vpToSpace(cardinal(el$1.getBoundingClientRect(), anchor));
};
var cardinalPosition = (domQueryOrEl, anchor = `nw`) => {
  const el$1 = resolveEl2(domQueryOrEl);
  return cardinal(el$1.getBoundingClientRect(), anchor);
};
var positionRelative = (domQueryOrEl, target = `viewport`) => {
  const f5 = positionFn(domQueryOrEl, {
    relative: true,
    target
  });
  return f5();
};
var viewportToSpace = (targetSpace = `viewport`) => {
  switch (targetSpace) {
    case `screen`:
      return (a3, b3) => {
        const pt2 = getPointParameter(a3, b3);
        return Object.freeze({
          x: pt2.x + window.screenX,
          y: pt2.y + window.screenY
        });
      };
    case `document`:
      return (a3, b3) => {
        const pt2 = getPointParameter(a3, b3);
        return Object.freeze({
          x: pt2.x + window.scrollX,
          y: pt2.y + window.scrollY
        });
      };
    case `viewport`:
      return (a3, b3) => {
        const pt2 = getPointParameter(a3, b3);
        return Object.freeze({
          x: pt2.x,
          y: pt2.y
        });
      };
    default:
      throw new Error(`Unexpected target coordinate space: ${targetSpace}. Expected: viewport, document or screen`);
  }
};
var positionFromMiddle = (domQueryOrEl, relativePos, relativeTo = `window`) => {
  if (!domQueryOrEl) throw new Error(`domQueryOrEl is null or undefined`);
  const el$1 = resolveEl2(domQueryOrEl);
  const absPosition = multiply$1(relativePos, window.innerWidth, window.innerHeight);
  const thingRect = el$1.getBoundingClientRect();
  const offsetPos = subtract(absPosition, thingRect.width / 2, thingRect.height / 2);
  el$1.style.transform = `translate(${offsetPos.x}px, ${offsetPos.y}px)`;
};
var cycleCssClass = (el$1, list) => {
  if (el$1 === null || !el$1) return;
  if (!Array.isArray(list)) throw new TypeError(`List should be an array of strings`);
  for (let index = 0; index < list.length; index++) if (el$1.classList.contains(list[index])) {
    el$1.classList.remove(list[index]);
    if (index + 1 < list.length) el$1.classList.add(list[index + 1]);
    else el$1.classList.add(list[0]);
    return;
  }
  el$1.classList.add(list[0]);
};
var getTranslation = (domQueryOrEl) => {
  const el$1 = resolveEl2(domQueryOrEl);
  const style = window.getComputedStyle(el$1);
  const matrix = style.transform;
  if (matrix === `none` || typeof matrix === `undefined`) return {
    x: 0,
    y: 0,
    z: 0
  };
  const matrixType = matrix.includes(`3d`) ? `3d` : `2d`;
  const matrixValues = /matrix.*\((.+)\)/.exec(matrix)[1].split(`, `);
  if (matrixType === `2d`) return {
    x: Number.parseFloat(matrixValues[4]),
    y: Number.parseFloat(matrixValues[5]),
    z: 0
  };
  if (matrixType === `3d`) return {
    x: Number.parseFloat(matrixValues[12]),
    y: Number.parseFloat(matrixValues[13]),
    z: Number.parseFloat(matrixValues[14])
  };
  return {
    x: 0,
    y: 0,
    z: 0
  };
};
var createAfter = (sibling, tagName) => {
  const el$1 = document.createElement(tagName);
  sibling.parentElement?.insertBefore(el$1, sibling.nextSibling);
  return el$1;
};
var createIn = (parent, tagName) => {
  const el$1 = document.createElement(tagName);
  parent.append(el$1);
  return el$1;
};
var clear = (parent) => {
  let c5 = parent.lastElementChild;
  while (c5) {
    c5.remove();
    c5 = parent.lastElementChild;
  }
};
var copyToClipboard = (object) => {
  const p3 = new Promise((resolve2, reject) => {
    const string_ = import_dist.default.stringify(object);
    navigator.clipboard.writeText(JSON.stringify(string_)).then(() => {
      resolve2(true);
    }, (error) => {
      console.warn(`Could not copy to clipboard`);
      console.log(string_);
      reject(new Error(error));
    });
  });
  return p3;
};
var insertSorted = (parent, element) => {
  const elSort = element.getAttribute(`data-sort`) ?? ``;
  let elAfter;
  let elBefore;
  for (const c5 of parent.children) {
    const sort = c5.getAttribute(`data-sort`) ?? ``;
    if (elSort >= sort) elAfter = c5;
    if (elSort <= sort) elBefore = c5;
    if (elAfter !== void 0 && elBefore !== void 0) break;
  }
  if (elAfter !== void 0) elAfter.insertAdjacentElement(`afterend`, element);
  else if (elBefore === void 0) parent.append(element);
  else elBefore.insertAdjacentElement(`beforebegin`, element);
};
var reconcileChildren = (parentEl, list, createUpdate) => {
  if (typeof parentEl === `undefined`) throw new Error(`Param 'parentEl' is undefined`);
  if (parentEl === null) throw new Error(`Param 'parentEl' is null`);
  const seen = /* @__PURE__ */ new Set();
  for (const [key, value3] of list) {
    const id = `c-${key}`;
    const el$1 = parentEl.querySelector(`#${id}`);
    const finalEl = createUpdate(value3, el$1);
    if (el$1 !== finalEl) {
      finalEl.id = id;
      parentEl.append(finalEl);
    }
    seen.add(id);
  }
  const prune = [];
  for (const child of parentEl.children) if (!seen.has(child.id)) prune.push(child);
  for (const p3 of prune) p3.remove();
};
var byId = (id) => {
  const element = document.getElementById(id);
  if (element === null) throw new Error(`HTML element with id '${id}' not found`);
  return element;
};
var src_exports8 = {};
__export(src_exports8, {
  DataDisplay: () => DataDisplay,
  DataTable: () => data_table_exports,
  DragDrop: () => drag_drop_exports,
  ElementSizer: () => ElementSizer,
  Forms: () => forms_exports,
  addShadowCss: () => addShadowCss,
  byId: () => byId,
  cardinalPosition: () => cardinalPosition,
  clear: () => clear,
  copyToClipboard: () => copyToClipboard,
  createAfter: () => createAfter,
  createIn: () => createIn,
  cycleCssClass: () => cycleCssClass,
  defaultErrorHandler: () => defaultErrorHandler,
  el: () => el,
  elRequery: () => elRequery,
  getBoundingClientRectWithBorder: () => getBoundingClientRectWithBorder,
  getComputedPixels: () => getComputedPixels,
  getCssVariable: () => getCssVariable,
  getCssVariablesFromStyles: () => getCssVariablesFromStyles,
  getCssVariablesWithFallback: () => getCssVariablesWithFallback,
  getTranslation: () => getTranslation,
  inlineConsole: () => inlineConsole,
  insertSorted: () => insertSorted,
  log: () => log,
  parseCssVariablesAsAttributes: () => parseCssVariablesAsAttributes,
  pointScaler: () => pointScaler,
  positionFn: () => positionFn,
  positionFromMiddle: () => positionFromMiddle,
  positionRelative: () => positionRelative,
  query: () => query2,
  reconcileChildren: () => reconcileChildren,
  resolveEl: () => resolveEl2,
  resolveElementTry: () => resolveElementTry,
  resolveEls: () => resolveEls,
  setCssClass: () => setCssClass,
  setCssDisplay: () => setCssDisplay,
  setCssToggle: () => setCssToggle,
  setCssVariables: () => setCssVariables,
  setFromCssVariables: () => setFromCssVariables,
  setHtml: () => setHtml,
  setProperty: () => setProperty,
  setText: () => setText,
  tabSet: () => tabSet,
  viewportToSpace: () => viewportToSpace
});

// node_modules/ixfx/bundle/src-DM61xwXd.js
var drawing_exports = {};
__export(drawing_exports, {
  arc: () => arc,
  bezier: () => bezier,
  circle: () => circle$1,
  connectedPoints: () => connectedPoints,
  copyToImg: () => copyToImg,
  dot: () => dot,
  drawingStack: () => drawingStack,
  ellipse: () => ellipse,
  getContext: () => getContext,
  line: () => line$1,
  lineThroughPoints: () => lineThroughPoints,
  makeHelper: () => makeHelper$1,
  paths: () => paths,
  pointLabels: () => pointLabels,
  rect: () => rect,
  textBlock: () => textBlock,
  textBlockAligned: () => textBlockAligned,
  textHeight: () => textHeight,
  textRect: () => textRect,
  textWidth: () => textWidth,
  translatePoint: () => translatePoint,
  triangle: () => triangle
});
var PIPI = Math.PI * 2;
var getContext = (canvasElementContextOrQuery) => {
  if (canvasElementContextOrQuery === null) throw new Error(`canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`);
  if (canvasElementContextOrQuery === void 0) throw new Error(`canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`);
  const ctx = canvasElementContextOrQuery instanceof CanvasRenderingContext2D ? canvasElementContextOrQuery : canvasElementContextOrQuery instanceof HTMLCanvasElement ? canvasElementContextOrQuery.getContext(`2d`) : typeof canvasElementContextOrQuery === `string` ? resolveEl2(canvasElementContextOrQuery).getContext(`2d`) : canvasElementContextOrQuery;
  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);
  return ctx;
};
var makeHelper$1 = (ctxOrCanvasEl, canvasBounds) => {
  const ctx = getContext(ctxOrCanvasEl);
  return {
    ctx,
    paths(pathsToDraw, opts) {
      paths(ctx, pathsToDraw, opts);
    },
    line(lineToDraw, opts) {
      line$1(ctx, lineToDraw, opts);
    },
    rect(rectsToDraw, opts) {
      rect(ctx, rectsToDraw, opts);
    },
    bezier(bezierToDraw, opts) {
      bezier(ctx, bezierToDraw, opts);
    },
    connectedPoints(pointsToDraw, opts) {
      connectedPoints(ctx, pointsToDraw, opts);
    },
    pointLabels(pointsToDraw, opts) {
      pointLabels(ctx, pointsToDraw, opts);
    },
    dot(dotPosition, opts) {
      dot(ctx, dotPosition, opts);
    },
    circle(circlesToDraw, opts) {
      circle$1(ctx, circlesToDraw, opts);
    },
    arc(arcsToDraw, opts) {
      arc(ctx, arcsToDraw, opts);
    },
    textBlock(lines, opts) {
      if (opts.bounds === void 0 && canvasBounds !== void 0) opts = {
        ...opts,
        bounds: {
          ...canvasBounds,
          x: 0,
          y: 0
        }
      };
      textBlock(ctx, lines, opts);
    }
  };
};
var optsOp = (opts) => coloringOp(opts.strokeStyle, opts.fillStyle);
var applyOpts$1 = (ctx, opts = {}, ...additionalOps) => {
  if (ctx === void 0) throw new Error(`ctx undefined`);
  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);
  stack.apply();
  return stack;
};
var arc = (ctx, arcs, opts = {}) => {
  applyOpts$1(ctx, opts);
  const draw = (arc$1) => {
    ctx.beginPath();
    ctx.arc(arc$1.x, arc$1.y, arc$1.radius, arc$1.startRadian, arc$1.endRadian);
    ctx.stroke();
  };
  const arcsArray = Array.isArray(arcs) ? arcs : [arcs];
  for (const arc$1 of arcsArray) draw(arc$1);
};
var coloringOp = (strokeStyle, fillStyle) => {
  const apply3 = (ctx) => {
    if (fillStyle) ctx.fillStyle = fillStyle;
    if (strokeStyle) ctx.strokeStyle = strokeStyle;
  };
  return apply3;
};
var lineOp = (lineWidth, lineJoin, lineCap) => {
  const apply3 = (ctx) => {
    if (lineWidth) ctx.lineWidth = lineWidth;
    if (lineJoin) ctx.lineJoin = lineJoin;
    if (lineCap) ctx.lineCap = lineCap;
  };
  return apply3;
};
var drawingStack = (ctx, stk) => {
  stk ??= new StackImmutable3();
  const push3 = (...ops) => {
    stk ??= new StackImmutable3();
    const s3 = stk.push(...ops);
    for (const o5 of ops) o5(ctx);
    return drawingStack(ctx, s3);
  };
  const pop3 = () => {
    const s3 = stk?.pop();
    return drawingStack(ctx, s3);
  };
  const apply3 = () => {
    if (stk === void 0) return drawingStack(ctx);
    for (const op of stk.data) op(ctx);
    return drawingStack(ctx, stk);
  };
  return {
    push: push3,
    pop: pop3,
    apply: apply3
  };
};
var lineThroughPoints = (ctx, points, opts) => {
  applyOpts$1(ctx, opts);
  ctx.moveTo(points[0].x, points[0].y);
  for (const [index, p3] of points.entries()) {
    if (index + 2 >= points.length) continue;
    const pNext = points[index + 1];
    const mid = {
      x: (p3.x + pNext.x) / 2,
      y: (p3.y + pNext.y) / 2
    };
    const cpX1 = (mid.x + p3.x) / 2;
    const cpX2 = (mid.x + pNext.x) / 2;
    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);
    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);
  }
};
var circle$1 = (ctx, circlesToDraw, opts = {}) => {
  applyOpts$1(ctx, opts);
  const draw = (c5) => {
    ctx.beginPath();
    ctx.arc(c5.x, c5.y, c5.radius, 0, PIPI);
    if (opts.strokeStyle) ctx.stroke();
    if (opts.fillStyle) ctx.fill();
  };
  if (Array.isArray(circlesToDraw)) for (const c5 of circlesToDraw) draw(c5);
  else draw(circlesToDraw);
};
var ellipse = (ctx, ellipsesToDraw, opts = {}) => {
  applyOpts$1(ctx, opts);
  const draw = (ellipse$1) => {
    ctx.beginPath();
    const rotation = ellipse$1.rotation ?? 0;
    const startAngle = ellipse$1.startAngle ?? 0;
    const endAngle = ellipse$1.endAngle ?? PIPI;
    ctx.ellipse(ellipse$1.x, ellipse$1.y, ellipse$1.radiusX, ellipse$1.radiusY, rotation, startAngle, endAngle);
    if (opts.strokeStyle) ctx.stroke();
    if (opts.fillStyle) ctx.fill();
  };
  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ellipsesToDraw];
  for (const ellipse$1 of ellipsesArray) draw(ellipse$1);
};
var paths = (ctx, pathsToDraw, opts = {}) => {
  applyOpts$1(ctx, opts);
  const draw = (path$1) => {
    if (isQuadraticBezier(path$1)) quadraticBezier(ctx, path$1, opts);
    else if (isLine(path$1)) line$1(ctx, path$1, opts);
    else throw new Error(`Unknown path type ${JSON.stringify(path$1)}`);
  };
  if (Array.isArray(pathsToDraw)) for (const p3 of pathsToDraw) draw(p3);
  else draw(pathsToDraw);
};
var connectedPoints = (ctx, pts, opts = {}) => {
  const shouldLoop = opts.loop ?? false;
  resultThrow(arrayTest(pts, `pts`));
  if (pts.length === 0) return;
  for (const [index, pt2] of pts.entries()) guard$1(pt2, `Index ${index}`);
  applyOpts$1(ctx, opts);
  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (const pt2 of pts) ctx.lineTo(pt2.x, pt2.y);
  if (shouldLoop) ctx.lineTo(pts[0].x, pts[0].y);
  if (opts.strokeStyle || opts.strokeStyle === void 0 && opts.fillStyle === void 0) ctx.stroke();
  if (opts.fillStyle) ctx.fill();
};
var pointLabels = (ctx, pts, opts = {}, labels) => {
  if (pts.length === 0) return;
  for (const [index, pt2] of pts.entries()) guard$1(pt2, `Index ${index}`);
  applyOpts$1(ctx, opts);
  for (const [index, pt2] of pts.entries()) {
    const label = labels !== void 0 && index < labels.length ? labels[index] : index.toString();
    ctx.fillText(label.toString(), pt2.x, pt2.y);
  }
};
var translatePoint = (ctx, point3) => {
  const m4 = ctx.getTransform();
  return {
    x: point3.x * m4.a + point3.y * m4.c + m4.e,
    y: point3.x * m4.b + point3.y * m4.d + m4.f
  };
};
var copyToImg = (canvasEl) => {
  const img = document.createElement(`img`);
  img.src = canvasEl.toDataURL(`image/jpeg`);
  return img;
};
var dot = (ctx, pos, opts) => {
  opts ??= {};
  const radius = opts.radius ?? 10;
  const positions = Array.isArray(pos) ? pos : [pos];
  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== void 0;
  let filled = opts.filled ? opts.filled : opts.fillStyle !== void 0;
  if (!stroke && !filled) filled = true;
  applyOpts$1(ctx, opts);
  for (const pos$1 of positions) {
    ctx.beginPath();
    if (`radius` in pos$1) ctx.arc(pos$1.x, pos$1.y, pos$1.radius, 0, 2 * Math.PI);
    else ctx.arc(pos$1.x, pos$1.y, radius, 0, 2 * Math.PI);
    if (filled) ctx.fill();
    if (stroke) ctx.stroke();
  }
};
var bezier = (ctx, bezierToDraw, opts) => {
  if (isQuadraticBezier(bezierToDraw)) quadraticBezier(ctx, bezierToDraw, opts);
  else if (isCubicBezier(bezierToDraw)) cubicBezier(ctx, bezierToDraw, opts);
};
var cubicBezier = (ctx, bezierToDraw, opts = {}) => {
  let stack = applyOpts$1(ctx, opts);
  const { a: a3, b: b3, cubic1, cubic2: cubic22 } = bezierToDraw;
  const isDebug = opts.debug ?? false;
  if (isDebug) {
  }
  ctx.beginPath();
  ctx.moveTo(a3.x, a3.y);
  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic22.x, cubic22.y, b3.x, b3.y);
  ctx.stroke();
  if (isDebug) {
    stack = stack.push(optsOp({
      ...opts,
      strokeStyle: multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),
      fillStyle: multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4)
    }));
    stack.apply();
    ctx.moveTo(a3.x, a3.y);
    ctx.lineTo(cubic1.x, cubic1.y);
    ctx.stroke();
    ctx.moveTo(b3.x, b3.y);
    ctx.lineTo(cubic22.x, cubic22.y);
    ctx.stroke();
    ctx.fillText(`a`, a3.x + 5, a3.y);
    ctx.fillText(`b`, b3.x + 5, b3.y);
    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);
    ctx.fillText(`c2`, cubic22.x + 5, cubic22.y);
    dot(ctx, cubic1, { radius: 3 });
    dot(ctx, cubic22, { radius: 3 });
    dot(ctx, a3, { radius: 3 });
    dot(ctx, b3, { radius: 3 });
    stack = stack.pop();
    stack.apply();
  }
};
var quadraticBezier = (ctx, bezierToDraw, opts = {}) => {
  const { a: a3, b: b3, quadratic: quadratic3 } = bezierToDraw;
  const isDebug = opts.debug ?? false;
  let stack = applyOpts$1(ctx, opts);
  ctx.beginPath();
  ctx.moveTo(a3.x, a3.y);
  ctx.quadraticCurveTo(quadratic3.x, quadratic3.y, b3.x, b3.y);
  ctx.stroke();
  if (isDebug) {
    stack = stack.push(optsOp({
      ...opts,
      strokeStyle: multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),
      fillStyle: multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4)
    }));
    connectedPoints(ctx, [
      a3,
      quadratic3,
      b3
    ]);
    ctx.fillText(`a`, a3.x + 5, a3.y);
    ctx.fillText(`b`, b3.x + 5, b3.y);
    ctx.fillText(`h`, quadratic3.x + 5, quadratic3.y);
    dot(ctx, quadratic3, { radius: 3 });
    dot(ctx, a3, { radius: 3 });
    dot(ctx, b3, { radius: 3 });
    stack = stack.pop();
    stack.apply();
  }
};
var line$1 = (ctx, toDraw, opts = {}) => {
  const isDebug = opts.debug ?? false;
  const o5 = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);
  applyOpts$1(ctx, opts, o5);
  const draw = (d3) => {
    const { a: a3, b: b3 } = d3;
    ctx.beginPath();
    ctx.moveTo(a3.x, a3.y);
    ctx.lineTo(b3.x, b3.y);
    if (isDebug) {
      ctx.fillText(`a`, a3.x, a3.y);
      ctx.fillText(`b`, b3.x, b3.y);
      dot(ctx, a3, {
        radius: 5,
        strokeStyle: `black`
      });
      dot(ctx, b3, {
        radius: 5,
        strokeStyle: `black`
      });
    }
    ctx.stroke();
  };
  if (Array.isArray(toDraw)) for (const t6 of toDraw) draw(t6);
  else draw(toDraw);
};
var triangle = (ctx, toDraw, opts = {}) => {
  applyOpts$1(ctx, opts);
  const draw = (t6) => {
    connectedPoints(ctx, corners(t6), {
      ...opts,
      loop: true
    });
    if (opts.debug) pointLabels(ctx, corners(t6), void 0, [
      `a`,
      `b`,
      `c`
    ]);
  };
  if (Array.isArray(toDraw)) for (const t6 of toDraw) draw(t6);
  else draw(toDraw);
};
var rect = (ctx, toDraw, opts = {}) => {
  applyOpts$1(ctx, opts);
  const filled = opts.filled ?? (opts.fillStyle === void 0 ? false : true);
  const stroke = opts.stroke ?? (opts.strokeStyle === void 0 ? false : true);
  const draw = (d3) => {
    const x3 = `x` in d3 ? d3.x : 0;
    const y3 = `y` in d3 ? d3.y : 0;
    if (filled) ctx.fillRect(x3, y3, d3.width, d3.height);
    if (stroke) {
      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;
      ctx.strokeRect(x3, y3, d3.width, d3.height);
    }
    if (opts.crossed) {
      ctx.beginPath();
      ctx.moveTo(x3, y3);
      ctx.lineTo(d3.width, d3.height);
      ctx.stroke();
      ctx.moveTo(0, d3.height);
      ctx.lineTo(d3.width, 0);
      ctx.stroke();
    }
    if (opts.debug) pointLabels(ctx, corners$1(d3), void 0, [
      `NW`,
      `NE`,
      `SE`,
      `SW`
    ]);
  };
  if (Array.isArray(toDraw)) for (const t6 of toDraw) draw(t6);
  else draw(toDraw);
};
var textWidth = (ctx, text$1, padding2 = 0, widthMultiple) => {
  const rect$1 = textRect(ctx, text$1, padding2, widthMultiple);
  return rect$1.width;
};
var textRect = (ctx, text$1, padding2 = 0, widthMultiple) => {
  if (text$1 === void 0 || text$1 === null || text$1.length === 0) return Empty$3;
  const m4 = ctx.measureText(text$1);
  const width = widthMultiple ? quantiseEvery(m4.width, widthMultiple) + padding2 : m4.width + padding2;
  return {
    width,
    height: m4.actualBoundingBoxAscent + m4.actualBoundingBoxDescent + padding2 + padding2
  };
};
var textHeight = (ctx, text$1, padding2 = 0) => {
  const rect$1 = textRect(ctx, text$1, padding2);
  return rect$1.height;
};
var textBlock = (ctx, lines, opts) => {
  applyOpts$1(ctx, opts);
  const anchorPadding = opts.anchorPadding ?? 0;
  const align = opts.align ?? `top`;
  const anchor = opts.anchor;
  const bounds = opts.bounds ?? {
    x: 0,
    y: 0,
    width: 1e6,
    height: 1e6
  };
  const blocks = lines.map((l3) => ctx.measureText(l3));
  const widths = blocks.map((tm) => tm.width);
  const heights = blocks.map((tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3);
  const maxWidth = Math.max(...widths);
  const totalHeight = heights.reduce((accumulator, value3) => accumulator + value3, 0);
  let { x: x3, y: y3 } = anchor;
  if (anchor.x + maxWidth > bounds.width) x3 = bounds.width - (maxWidth + anchorPadding);
  else x3 -= anchorPadding;
  if (x3 < bounds.x) x3 = bounds.x + anchorPadding;
  if (anchor.y + totalHeight > bounds.height) y3 = bounds.height - (totalHeight + anchorPadding);
  else y3 -= anchorPadding;
  if (y3 < bounds.y) y3 = bounds.y + anchorPadding;
  if (align === `top`) ctx.textBaseline = `top`;
  else ctx.textBaseline = `middle`;
  for (const [index, line$2] of lines.entries()) {
    ctx.fillText(line$2, x3, y3);
    y3 += heights[index];
  }
};
var textBlockAligned = (ctx, text$1, opts) => {
  const { bounds } = opts;
  const { horiz = `left`, vert = `top` } = opts;
  const lines = typeof text$1 === `string` ? [text$1] : text$1;
  applyOpts$1(ctx, opts);
  ctx.save();
  ctx.translate(bounds.x, bounds.y);
  ctx.textAlign = `left`;
  ctx.textBaseline = `top`;
  const middleX = bounds.width / 2;
  const middleY = bounds.height / 2;
  const blocks = lines.map((l3) => ctx.measureText(l3));
  const heights = blocks.map((tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);
  const totalHeight = heights.reduce((accumulator, value3) => accumulator + value3, 0);
  let y3 = 0;
  if (vert === `center`) y3 = middleY - totalHeight / 2;
  else if (vert === `bottom`) y3 = bounds.height - totalHeight;
  for (const [index, line$2] of lines.entries()) {
    let x3 = 0;
    if (horiz === `center`) x3 = middleX - blocks[index].width / 2;
    else if (horiz === `right`) x3 = bounds.width - blocks[index].width;
    ctx.fillText(line$2, x3, y3);
    y3 += heights[index];
  }
  ctx.restore();
};
var __defProp3 = Object.defineProperty;
var __defNormalProp = (obj, key, value3) => key in obj ? __defProp3(obj, key, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: value3
}) : obj[key] = value3;
var __export$1 = (target, all) => {
  for (var name2 in all) __defProp3(target, name2, {
    get: all[name2],
    enumerable: true
  });
};
var __publicField = (obj, key, value3) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value3);
function invariant(condition, message) {
  if (condition) return;
  if (message === void 0) throw new Error("invariant requires an error message argument");
  const error = !message ? /* @__PURE__ */ new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.") : new Error(message);
  error.name = "colorizr";
  throw error;
}
var COLOR_KEYS = {
  hsl: [
    "h",
    "s",
    "l"
  ],
  oklab: [
    "l",
    "a",
    "b"
  ],
  oklch: [
    "l",
    "c",
    "h"
  ],
  rgb: [
    "r",
    "g",
    "b"
  ]
};
var COLOR_MODELS = [
  "hsl",
  "oklab",
  "oklch",
  "rgb"
];
var DEG2RAD = Math.PI / 180;
var LAB_TO_LMS = {
  l: [0.3963377773761749, 0.2158037573099136],
  m: [-0.1055613458156586, -0.0638541728258133],
  s: [-0.0894841775298119, -1.2914855480194092]
};
var LRGB_TO_LMS = {
  l: [
    0.4122214708,
    0.5363325363,
    0.0514459929
  ],
  m: [
    0.2119034982,
    0.6806995451,
    0.1073969566
  ],
  s: [
    0.0883024619,
    0.2817188376,
    0.6299787005
  ]
};
var LSM_TO_LAB = {
  l: [
    0.2104542553,
    0.793617785,
    0.0040720468
  ],
  a: [
    1.9779984951,
    2.428592205,
    0.4505937099
  ],
  b: [
    0.0259040371,
    0.7827717662,
    0.808675766
  ]
};
var LSM_TO_RGB = {
  r: [
    4.076741636075958,
    -3.307711539258063,
    0.2309699031821043
  ],
  g: [
    -1.2684379732850315,
    2.609757349287688,
    -0.341319376002657
  ],
  b: [
    -0.0041960761386756,
    -0.7034186179359362,
    1.7076146940746117
  ]
};
var PRECISION = 5;
var RAD2DEG = 180 / Math.PI;
var MESSAGES = {
  alpha: "amount must be a number between 0 and 1",
  hueRange: "hue must be a number between 0 and 360",
  input: "input is required",
  inputHex: "input is required and must be a hex",
  inputNumber: "input is required and must be a number",
  inputString: "input is required and must be a string",
  invalid: "invalid input",
  invalidCSS: "invalid CSS string",
  left: "left is required and must be a string",
  lightnessRange: "lightness must be a number between 0 and 1",
  options: "invalid options",
  right: "right is required and must be a string",
  threshold: "threshold must be a number between 0 and 255"
};
var cssColors = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function hasValidMatches(input) {
  return Array.isArray(input) && input.length === 6;
}
function isNamedColor(input) {
  return isString(input) && Object.keys(cssColors).includes(input.toLowerCase());
}
function isNumber(input) {
  return typeof input === "number" && !Number.isNaN(input);
}
function isPlainObject(input) {
  if (!input) return false;
  const { toString: toString5 } = Object.prototype;
  const prototype = Object.getPrototypeOf(input);
  return toString5.call(input) === "[object Object]" && (prototype === null || prototype === Object.getPrototypeOf({}));
}
function isString(input, validate = true) {
  const isValid2 = typeof input === "string";
  if (validate) return isValid2 && !!input.trim().length;
  return isValid2;
}
function isValidColorModel(input) {
  return isHSL(input) || isRGB(input) || isLAB(input) || isLCH(input);
}
function isHex(input) {
  if (!isString(input)) return false;
  return /^#([\da-f]{3,4}|[\da-f]{6,8})$/i.test(input);
}
function isHSL(input) {
  if (!isPlainObject(input)) return false;
  const entries2 = Object.entries(input);
  return !!entries2.length && entries2.every(([key, value3]) => {
    if (key === "h") return value3 >= 0 && value3 <= 360;
    if (key === "alpha") return value3 >= 0 && value3 <= 1;
    return COLOR_KEYS.hsl.includes(key) && value3 >= 0 && value3 <= 100;
  });
}
function isLAB(input) {
  if (!isPlainObject(input)) return false;
  const entries2 = Object.entries(input);
  return !!entries2.length && entries2.every(([key, value3]) => {
    if (key === "l") return value3 >= 0 && value3 <= 100;
    if (key === "alpha") return value3 >= 0 && value3 <= 1;
    return COLOR_KEYS.oklab.includes(key) && value3 >= -1 && value3 <= 1;
  });
}
function isLCH(input) {
  if (!isPlainObject(input)) return false;
  const entries2 = Object.entries(input);
  return !!entries2.length && entries2.every(([key, value3]) => {
    if (key === "l") return value3 >= 0 && value3 <= 100;
    if (key === "alpha") return value3 >= 0 && value3 <= 1;
    return COLOR_KEYS.oklch.includes(key) && value3 >= 0 && value3 <= (key === "h" ? 360 : 1);
  });
}
function isRGB(input) {
  if (!isPlainObject(input)) return false;
  const entries2 = Object.entries(input);
  return !!entries2.length && entries2.every(([key, value3]) => {
    if (key === "alpha") return value3 >= 0 && value3 <= 1;
    return COLOR_KEYS.rgb.includes(key) && value3 >= 0 && value3 <= 255;
  });
}
function addAlpha(input, alpha) {
  invariant(isValidColorModel(input), MESSAGES.invalid);
  let value3 = alpha;
  if (!value3) return input;
  if (value3 > 1) value3 /= 100;
  if (value3 === 1) return input;
  return {
    ...input,
    alpha: value3
  };
}
function clamp$2(value3, min4 = 0, max4 = 100) {
  return Math.min(Math.max(value3, min4), max4);
}
function constrainDegrees(input, amount) {
  invariant(isNumber(input), MESSAGES.inputNumber);
  let value3 = input + amount;
  if (value3 > 360) value3 %= 360;
  if (value3 < 0) value3 += 360;
  return Math.abs(value3);
}
function limit(input, model, key) {
  invariant(isNumber(input), "Input is not a number");
  invariant(COLOR_MODELS.includes(model), `Invalid model${model ? `: ${model}` : ""}`);
  invariant(COLOR_KEYS[model].includes(key), `Invalid key${key ? `: ${key}` : ""}`);
  switch (model) {
    case "hsl": {
      invariant(COLOR_KEYS.hsl.includes(key), "Invalid key");
      if (["s", "l"].includes(key)) return clamp$2(input);
      return clamp$2(input, 0, 360);
    }
    case "rgb": {
      invariant(COLOR_KEYS.rgb.includes(key), "Invalid key");
      return clamp$2(input, 0, 255);
    }
    default:
      throw new Error("Invalid inputs");
  }
}
function parseInput(input, model) {
  const keys = COLOR_KEYS[model];
  const validator = {
    hsl: isHSL,
    oklab: isLAB,
    oklch: isLCH,
    rgb: isRGB
  };
  invariant(isPlainObject(input) || Array.isArray(input), MESSAGES.invalid);
  const value3 = Array.isArray(input) ? {
    [keys[0]]: input[0],
    [keys[1]]: input[1],
    [keys[2]]: input[2]
  } : input;
  invariant(validator[model](value3), `invalid ${model} color`);
  return value3;
}
function restrictValues(input, precision = PRECISION, forcePrecision = true) {
  const output = new Map(Object.entries(input));
  for (const [key, value3] of output.entries()) output.set(key, round$12(value3, precision, forcePrecision));
  return Object.fromEntries(output);
}
function round$12(input, precision = 2, forcePrecision = true) {
  if (!isNumber(input) || input === 0) return 0;
  if (forcePrecision) {
    const factor2 = 10 ** precision;
    return Math.round(input * factor2) / factor2;
  }
  const absInput = Math.abs(input);
  let digits = Math.abs(Math.ceil(Math.log(absInput) / Math.LN10));
  if (digits === 0) digits = 2;
  else if (digits > precision) digits = precision;
  let exponent = precision - (digits < 0 ? 0 : digits);
  if (exponent <= 1 && precision > 1) exponent = 2;
  else if (exponent > precision || exponent === 0) exponent = precision;
  const factor = 10 ** exponent;
  return Math.round(input * factor) / factor;
}
function addAlphaToHex(input, alpha) {
  invariant(isHex(input), MESSAGES.inputHex);
  invariant(isNumber(alpha), MESSAGES.inputNumber);
  if (alpha >= 1) return removeAlphaFromHex(input);
  return `${removeAlphaFromHex(input)}${convertAlphaToHex(alpha)}`;
}
function convertAlphaToHex(input) {
  invariant(isNumber(input), MESSAGES.inputNumber);
  let alpha = input;
  if (input > 1) alpha /= 100;
  return Math.round(alpha * 255).toString(16).padStart(2, "0");
}
function extractAlphaFromHex(input) {
  invariant(isHex(input), MESSAGES.inputString);
  const alpha = input.substring(7, 9);
  if (!alpha) return 1;
  return round$12(parseInt(alpha, 16) / 255);
}
function removeAlphaFromHex(input) {
  invariant(isHex(input), MESSAGES.inputHex);
  if (input.length === 5) return input.substring(0, 4);
  return input.substring(0, 7);
}
var converters_exports = {};
__export$1(converters_exports, {
  hex2hsl: () => hex2hsl,
  hex2oklab: () => hex2oklab,
  hex2oklch: () => hex2oklch,
  hex2rgb: () => hex2rgb,
  hsl2hex: () => hsl2hex,
  hsl2oklab: () => hsl2oklab,
  hsl2oklch: () => hsl2oklch,
  hsl2rgb: () => hsl2rgb,
  oklab2hex: () => oklab2hex,
  oklab2hsl: () => oklab2hsl,
  oklab2oklch: () => oklab2oklch,
  oklab2rgb: () => oklab2rgb,
  oklch2hex: () => oklch2hex,
  oklch2hsl: () => oklch2hsl,
  oklch2oklab: () => oklch2oklab,
  oklch2rgb: () => oklch2rgb,
  rgb2hex: () => rgb2hex,
  rgb2hsl: () => rgb2hsl,
  rgb2oklab: () => rgb2oklab,
  rgb2oklch: () => rgb2oklch
});
function formatHex(input) {
  invariant(isHex(input), MESSAGES.inputHex);
  let color = input.replace("#", "");
  if (color.length === 3 || color.length === 4) {
    const values3 = [...color];
    color = "";
    values3.forEach((d3) => {
      color += `${d3}${d3}`;
    });
  }
  const hex = `#${color}`;
  invariant(isHex(hex), "invalid hex");
  return hex;
}
function hex2rgb(input) {
  invariant(isHex(input), MESSAGES.inputHex);
  const hex = formatHex(input).slice(1);
  return {
    r: parseInt(hex.charAt(0) + hex.charAt(1), 16),
    g: parseInt(hex.charAt(2) + hex.charAt(3), 16),
    b: parseInt(hex.charAt(4) + hex.charAt(5), 16)
  };
}
function rgb2hsl(input) {
  const value3 = parseInput(input, "rgb");
  const rLimit = limit(value3.r, "rgb", "r") / 255;
  const gLimit = limit(value3.g, "rgb", "g") / 255;
  const bLimit = limit(value3.b, "rgb", "b") / 255;
  const min4 = Math.min(rLimit, gLimit, bLimit);
  const max4 = Math.max(rLimit, gLimit, bLimit);
  const delta = max4 - min4;
  let h5 = 0;
  let s3;
  const l3 = (max4 + min4) / 2;
  let rate2;
  switch (max4) {
    case rLimit:
      rate2 = !delta ? 0 : (gLimit - bLimit) / delta;
      h5 = 60 * rate2;
      break;
    case gLimit:
      rate2 = (bLimit - rLimit) / delta;
      h5 = 60 * rate2 + 120;
      break;
    case bLimit:
      rate2 = (rLimit - gLimit) / delta;
      h5 = 60 * rate2 + 240;
      break;
    default:
      break;
  }
  if (h5 < 0) h5 = 360 + h5;
  if (min4 === max4) s3 = 0;
  else s3 = l3 < 0.5 ? delta / (2 * l3) : delta / (2 - 2 * l3);
  return {
    h: Math.abs(+(h5 % 360).toFixed(2)),
    s: +(s3 * 100).toFixed(2),
    l: +(l3 * 100).toFixed(2)
  };
}
function hex2hsl(input) {
  invariant(isHex(input), MESSAGES.inputHex);
  return rgb2hsl(hex2rgb(input));
}
var { cbrt, sign } = Math;
function rgb2lrgb(input) {
  const abs22 = Math.abs(input);
  if (abs22 < 0.04045) return input / 12.92;
  return (sign(input) || 1) * ((abs22 + 0.055) / 1.055) ** 2.4;
}
function rgb2oklab(input, precision = PRECISION) {
  const value3 = parseInput(input, "rgb");
  const [lr2, lg, lb] = [
    rgb2lrgb(value3.r / 255),
    rgb2lrgb(value3.g / 255),
    rgb2lrgb(value3.b / 255)
  ];
  const l3 = cbrt(LRGB_TO_LMS.l[0] * lr2 + LRGB_TO_LMS.l[1] * lg + LRGB_TO_LMS.l[2] * lb);
  const m4 = cbrt(LRGB_TO_LMS.m[0] * lr2 + LRGB_TO_LMS.m[1] * lg + LRGB_TO_LMS.m[2] * lb);
  const s3 = cbrt(LRGB_TO_LMS.s[0] * lr2 + LRGB_TO_LMS.s[1] * lg + LRGB_TO_LMS.s[2] * lb);
  const lab = {
    l: LSM_TO_LAB.l[0] * l3 + LSM_TO_LAB.l[1] * m4 - LSM_TO_LAB.l[2] * s3,
    a: LSM_TO_LAB.a[0] * l3 - LSM_TO_LAB.a[1] * m4 + LSM_TO_LAB.a[2] * s3,
    b: LSM_TO_LAB.b[0] * l3 + LSM_TO_LAB.b[1] * m4 - LSM_TO_LAB.b[2] * s3
  };
  return restrictValues(lab, precision);
}
function hex2oklab(input, precision) {
  invariant(isHex(input), MESSAGES.inputHex);
  return rgb2oklab(hex2rgb(input), precision);
}
var { atan2: atan22, sqrt: sqrt3 } = Math;
function oklab2oklch(input, precision) {
  const { l: l3, a: a3, b: b3 } = restrictValues(parseInput(input, "oklab"));
  const c5 = sqrt3(a3 ** 2 + b3 ** 2);
  let h5 = (atan22(b3, a3) * RAD2DEG + 360) % 360;
  if (round$12(c5 * 1e4) === 0) h5 = 0;
  return restrictValues({
    l: l3,
    c: c5,
    h: h5
  }, precision);
}
function rgb2oklch(input, precision) {
  const value3 = parseInput(input, "rgb");
  return oklab2oklch(rgb2oklab(value3, precision), precision);
}
function hex2oklch(input, precision) {
  invariant(isHex(input), MESSAGES.inputHex);
  return rgb2oklch(hex2rgb(input), precision);
}
function hue2rgb(point3, chroma2, h5) {
  invariant(isNumber(point3) && isNumber(chroma2) && isNumber(h5), "point, chroma and h are required");
  let hue = h5;
  if (hue < 0) hue += 1;
  if (hue > 1) hue -= 1;
  if (hue < 1 / 6) return round$12(point3 + (chroma2 - point3) * 6 * hue, 4);
  if (hue < 1 / 2) return round$12(chroma2, 4);
  if (hue < 2 / 3) return round$12(point3 + (chroma2 - point3) * (2 / 3 - hue) * 6, 4);
  return round$12(point3, 4);
}
function hsl2rgb(input) {
  const value3 = parseInput(input, "hsl");
  const h5 = round$12(value3.h) / 360;
  const s3 = round$12(value3.s) / 100;
  const l3 = round$12(value3.l) / 100;
  let r5;
  let g4;
  let b3;
  let point3;
  let chroma2;
  if (s3 === 0) {
    r5 = l3;
    g4 = l3;
    b3 = l3;
  } else {
    chroma2 = l3 < 0.5 ? l3 * (1 + s3) : l3 + s3 - l3 * s3;
    point3 = 2 * l3 - chroma2;
    r5 = hue2rgb(point3, chroma2, h5 + 1 / 3);
    g4 = hue2rgb(point3, chroma2, h5);
    b3 = hue2rgb(point3, chroma2, h5 - 1 / 3);
  }
  return {
    r: Math.round(r5 * 255),
    g: Math.round(g4 * 255),
    b: Math.round(b3 * 255)
  };
}
function rgb2hex(input) {
  const rgb = parseInput(input, "rgb");
  return `#${Object.values(rgb).map((d3) => `0${Math.floor(d3).toString(16)}`.slice(-2)).join("")}`;
}
function hsl2hex(input) {
  const value3 = parseInput(input, "hsl");
  return rgb2hex(hsl2rgb(value3));
}
function hsl2oklab(input, precision) {
  const value3 = parseInput(input, "hsl");
  return rgb2oklab(hsl2rgb(value3), precision);
}
function hsl2oklch(input, precision) {
  const value3 = parseInput(input, "hsl");
  return rgb2oklch(hsl2rgb(value3), precision);
}
var { abs: abs3 } = Math;
function lrgb2rgb(input) {
  const absoluteNumber = abs3(input);
  const sign2 = input < 0 ? -1 : 1;
  if (absoluteNumber > 31308e-7) return sign2 * (absoluteNumber ** (1 / 2.4) * 1.055 - 0.055);
  return input * 12.92;
}
function oklab2rgb(input, precision = 0) {
  const { l: L2, a: A2, b: B3 } = parseInput(input, "oklab");
  const l3 = (L2 + LAB_TO_LMS.l[0] * A2 + LAB_TO_LMS.l[1] * B3) ** 3;
  const m4 = (L2 + LAB_TO_LMS.m[0] * A2 + LAB_TO_LMS.m[1] * B3) ** 3;
  const s3 = (L2 + LAB_TO_LMS.s[0] * A2 + LAB_TO_LMS.s[1] * B3) ** 3;
  const r5 = 255 * lrgb2rgb(LSM_TO_RGB.r[0] * l3 + LSM_TO_RGB.r[1] * m4 + LSM_TO_RGB.r[2] * s3);
  const g4 = 255 * lrgb2rgb(LSM_TO_RGB.g[0] * l3 + LSM_TO_RGB.g[1] * m4 + LSM_TO_RGB.g[2] * s3);
  const b3 = 255 * lrgb2rgb(LSM_TO_RGB.b[0] * l3 + LSM_TO_RGB.b[1] * m4 + LSM_TO_RGB.b[2] * s3);
  return {
    r: clamp$2(round$12(r5, precision), 0, 255),
    g: clamp$2(round$12(g4, precision), 0, 255),
    b: clamp$2(round$12(b3, precision), 0, 255)
  };
}
function oklab2hex(input) {
  const value3 = parseInput(input, "oklab");
  return rgb2hex(oklab2rgb(value3));
}
function oklab2hsl(input) {
  const value3 = parseInput(input, "oklab");
  return rgb2hsl(oklab2rgb(value3));
}
var { sin: sin3, cos: cos3 } = Math;
function oklch2oklab(input, precision) {
  let { l: l3, c: c5, h: h5 } = parseInput(input, "oklch");
  if (Number.isNaN(h5) || h5 < 0) h5 = 0;
  return restrictValues({
    l: l3,
    a: c5 * cos3(h5 * DEG2RAD),
    b: c5 * sin3(h5 * DEG2RAD)
  }, precision);
}
function oklch2rgb(input, precision = 0) {
  const value3 = parseInput(input, "oklch");
  return oklab2rgb(oklch2oklab(value3), precision);
}
function oklch2hex(input) {
  const value3 = parseInput(input, "oklch");
  return rgb2hex(oklch2rgb(value3));
}
function oklch2hsl(input) {
  const value3 = parseInput(input, "oklch");
  return rgb2hsl(oklch2rgb(value3));
}
function extractColorParts(input) {
  invariant(isString(input), MESSAGES.inputString);
  if (isHex(input)) {
    const keys2 = COLOR_KEYS.rgb;
    const { r: r5, g: g4, b: b3 } = hex2rgb(input);
    const alpha2 = extractAlphaFromHex(input);
    return {
      model: "rgb",
      [keys2[0]]: r5,
      [keys2[1]]: g4,
      [keys2[2]]: b3,
      alpha: alpha2 < 1 ? alpha2 : void 0
    };
  }
  const colorRegex = /(?:(rgb|hsl|oklab|oklch)a?\s*\(\s*([\d%.-]+)\s*[ ,/]\s*([\d%.-]+)\s*[ ,/]\s*([\d%.-]+)(?:\s*[ ,/]\s*([\d%.-]+))?\s*\))/i;
  const matches = colorRegex.exec(input);
  invariant(hasValidMatches(matches), MESSAGES.invalidCSS);
  const model = matches[1];
  const keys = COLOR_KEYS[model];
  let alpha = matches[5] ? parseFloat(matches[5]) : 1;
  if (alpha > 1) alpha /= 100;
  return {
    model,
    [keys[0]]: parseFloat(matches[2]),
    [keys[1]]: parseFloat(matches[3]),
    [keys[2]]: parseFloat(matches[4]),
    alpha: alpha < 1 ? alpha : void 0
  };
}
function parseCSS(input, format) {
  invariant(isString(input), MESSAGES.inputString);
  let result;
  const value3 = isNamedColor(input) ? cssColors[input.toLowerCase()] : input;
  const output = format ?? (isHex(value3) ? "hex" : extractColorParts(value3).model);
  const colorParams = (params) => Object.values(params);
  if (isHex(value3)) {
    const alpha = extractAlphaFromHex(value3);
    switch (output) {
      case "hsl": {
        result = addAlpha(hex2hsl(value3), alpha);
        break;
      }
      case "oklab": {
        result = addAlpha(hex2oklab(value3), alpha);
        break;
      }
      case "oklch": {
        result = addAlpha(hex2oklch(value3), alpha);
        break;
      }
      case "rgb": {
        result = addAlpha(hex2rgb(value3), alpha);
        break;
      }
      default: {
        result = `${removeAlphaFromHex(value3)}${alpha !== 1 ? convertAlphaToHex(alpha) : ""}`;
        break;
      }
    }
    return result;
  }
  switch (output) {
    case "hsl": {
      const { alpha, model, ...color } = extractColorParts(value3);
      if (["oklab", "oklch"].includes(model) && color.l > 1) color.l = round$12(color.l / 100, PRECISION);
      result = addAlpha(model === "hsl" ? color : converters_exports[`${model}2hsl`](colorParams(color)), alpha);
      break;
    }
    case "oklab": {
      const { alpha, model, ...color } = extractColorParts(value3);
      if (["oklab", "oklch"].includes(model) && color.l > 1) color.l = round$12(color.l / 100, PRECISION);
      result = addAlpha(model === "oklab" ? color : converters_exports[`${model}2oklab`](colorParams(color)), alpha);
      break;
    }
    case "oklch": {
      const { alpha, model, ...color } = extractColorParts(value3);
      if (["oklab", "oklch"].includes(model) && color.l > 1) color.l = round$12(color.l / 100, PRECISION);
      result = addAlpha(model === "oklch" ? color : converters_exports[`${model}2oklch`](colorParams(color)), alpha);
      break;
    }
    case "rgb": {
      const { alpha, model, ...color } = extractColorParts(value3);
      if (["oklab", "oklch"].includes(model) && color.l > 1) color.l /= 100;
      result = addAlpha(model === "rgb" ? color : converters_exports[`${model}2rgb`](colorParams(color)), alpha);
      break;
    }
    case "hex":
    default: {
      const { alpha, model, ...color } = extractColorParts(value3);
      let alphaPrefix = "";
      if (["oklab", "oklch"].includes(model) && color.l > 1) color.l = round$12(color.l / 100, PRECISION);
      if (alpha) alphaPrefix = convertAlphaToHex(alpha);
      result = `${converters_exports[`${model}2hex`](colorParams(color))}${alphaPrefix}`;
      break;
    }
  }
  return result;
}
function parseColor(color) {
  invariant(!!color, MESSAGES.input);
  const output = {};
  if (isString(color)) {
    const { alpha = 1 } = extractColorParts(color);
    const type = isHex(color) ? "hex" : extractColorParts(color).model;
    output.hex = addAlphaToHex(parseCSS(color, "hex"), alpha);
    output.hsl = addAlpha(parseCSS(color, "hsl"), alpha);
    output.oklab = addAlpha(parseCSS(color, "oklab"), alpha);
    output.oklch = addAlpha(parseCSS(color, "oklch"), alpha);
    output.rgb = addAlpha(parseCSS(color, "rgb"), alpha);
    output.alpha = alpha;
    output.type = type;
  } else if (isPlainObject(color)) {
    const { alpha = 1 } = color;
    if (isHSL(color)) {
      output.hsl = {
        h: limit(color.h, "hsl", "h"),
        s: limit(color.s, "hsl", "s"),
        l: limit(color.l, "hsl", "l")
      };
      output.rgb = hsl2rgb(output.hsl);
      output.oklab = hsl2oklab(output.hsl);
      output.oklch = hsl2oklch(output.hsl);
      output.type = "hsl";
    } else if (isLAB(color)) {
      output.hsl = oklab2hsl(color);
      output.oklab = color;
      output.oklch = oklab2oklch(color);
      output.rgb = oklab2rgb(color);
      output.type = "oklab";
    } else if (isLCH(color)) {
      output.hsl = oklch2hsl(color);
      output.oklab = oklch2oklab(color);
      output.oklch = color;
      output.rgb = oklch2rgb(color);
      output.type = "oklch";
    } else if (isRGB(color)) {
      output.rgb = {
        r: limit(color.r, "rgb", "r"),
        g: limit(color.g, "rgb", "g"),
        b: limit(color.b, "rgb", "b")
      };
      output.hsl = rgb2hsl(output.rgb);
      output.oklab = rgb2oklab(output.rgb);
      output.oklch = rgb2oklch(output.rgb);
      output.type = "rgb";
    } else throw new Error("invalid color");
    output.hex = addAlphaToHex(hsl2hex(output.hsl), alpha);
    output.hsl = addAlpha(output.hsl, alpha);
    output.oklab = addAlpha(output.oklab, alpha);
    output.oklch = addAlpha(output.oklch, alpha);
    output.rgb = addAlpha(output.rgb, alpha);
    output.alpha = alpha;
  } else throw new Error(MESSAGES.input);
  return output;
}
function brightnessDifference(left, right, precision = PRECISION) {
  invariant(isString(left), MESSAGES.left);
  invariant(isString(right), MESSAGES.right);
  const RGBLeft = parseCSS(left, "rgb");
  const RGBRight = parseCSS(right, "rgb");
  const brightnessLeft = (RGBLeft.r * 299 + RGBLeft.g * 587 + RGBLeft.b * 114) / 1e3;
  const brightnessRight = (RGBRight.r * 299 + RGBRight.g * 587 + RGBRight.b * 114) / 1e3;
  return round$12(Math.abs(brightnessRight - brightnessLeft), precision);
}
function chroma(input) {
  invariant(isString(input), MESSAGES.inputString);
  const { r: r5, g: g4, b: b3 } = parseCSS(input, "rgb");
  const max4 = Math.max(r5, g4, b3);
  const min4 = Math.min(r5, g4, b3);
  return round$12((max4 - min4) / 255, 4);
}
function colorDifference(left, right) {
  invariant(isString(left), MESSAGES.left);
  invariant(isString(right), MESSAGES.right);
  const RGBLeft = parseCSS(left, "rgb");
  const RGBRight = parseCSS(right, "rgb");
  return Math.max(RGBLeft.r, RGBRight.r) - Math.min(RGBLeft.r, RGBRight.r) + (Math.max(RGBLeft.g, RGBRight.g) - Math.min(RGBLeft.g, RGBRight.g)) + (Math.max(RGBLeft.b, RGBRight.b) - Math.min(RGBLeft.b, RGBRight.b));
}
function luminance(input) {
  invariant(isString(input), MESSAGES.inputString);
  const { r: r5, g: g4, b: b3 } = parseCSS(input, "rgb");
  const rgb = [
    r5 / 255,
    g4 / 255,
    b3 / 255
  ];
  for (let index = 0; index < rgb.length; index++) if (rgb[index] <= 0.03928) rgb[index] /= 12.92;
  else rgb[index] = ((rgb[index] + 0.055) / 1.055) ** 2.4;
  return round$12(0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2], 4);
}
function contrast(left, right) {
  invariant(isString(left), MESSAGES.left);
  invariant(isString(right), MESSAGES.right);
  const LuminanceLeft = luminance(left);
  const LuminanceRight = luminance(right);
  return round$12(LuminanceLeft >= LuminanceRight ? (LuminanceLeft + 0.05) / (LuminanceRight + 0.05) : (LuminanceRight + 0.05) / (LuminanceLeft + 0.05));
}
function compare4(left, right) {
  invariant(isString(left), MESSAGES.left);
  invariant(isString(right), MESSAGES.right);
  const colorThreshold = 500;
  const brightnessThreshold = 125;
  const colorDifference2 = colorDifference(left, right);
  const contrast2 = contrast(left, right);
  const brightnessDifference2 = brightnessDifference(left, right);
  const isBright = brightnessDifference2 >= brightnessThreshold;
  const hasEnoughDifference = colorDifference2 >= colorThreshold;
  let compliant = 0;
  if (isBright && hasEnoughDifference) compliant = 2;
  else if (isBright || hasEnoughDifference) compliant = 1;
  return {
    brightnessDifference: brightnessDifference2,
    colorDifference: colorDifference2,
    compliant,
    contrast: contrast2,
    largeAA: contrast2 >= 3,
    largeAAA: contrast2 >= 4.5,
    normalAA: contrast2 >= 4.5,
    normalAAA: contrast2 >= 7
  };
}
function getColorModel(input) {
  if (isHex(input) || isNamedColor(input)) return "hex";
  if (isString(input)) return extractColorParts(input).model;
  else if (isHSL(input)) return "hsl";
  else if (isLAB(input)) return "oklab";
  else if (isLCH(input)) return "oklch";
  else if (isRGB(input)) return "rgb";
  throw new Error(MESSAGES.invalid);
}
function getColorValue(input, output) {
  const value3 = isNamedColor(input) ? cssColors[input.toLowerCase()] : input;
  const from3 = getColorModel(value3);
  if (from3 === output) return value3;
  const converterKey = `${from3}2${output}`;
  const converter = converters_exports[converterKey];
  if (!converter) throw new Error(`Converter not found for ${from3} to ${output}`);
  switch (from3) {
    case "hex": {
      if (output === "hex") return value3;
      return converter(value3);
    }
    case "hsl": {
      if (output === "hsl") return value3;
      return converter(value3);
    }
    case "oklab": {
      if (output === "oklab") return value3;
      return converter(value3);
    }
    case "oklch": {
      if (output === "oklch") return value3;
      return converter(value3);
    }
    default: {
      if (output === "rgb") return value3;
      return converter(value3);
    }
  }
}
function formatCSS(input, options = {}) {
  invariant(isHex(input) || isValidColorModel(input), MESSAGES.invalid);
  const { alpha, format = "hex", precision = PRECISION, separator: baseSeparator = " " } = options;
  const opacity2 = alpha && alpha !== 1 ? `${round$12(alpha * 100)}%` : null;
  let params = [];
  let separator = baseSeparator;
  switch (format) {
    case "hsl": {
      const { h: h5, s: s3, l: l3 } = getColorValue(input, "hsl");
      params = [
        h5,
        `${s3}%`,
        `${l3}%`
      ];
      break;
    }
    case "oklab": {
      separator = " ";
      const { l: l3, a: a3, b: b3 } = restrictValues(getColorValue(input, "oklab"), precision);
      params = [
        `${round$12(l3 * 100, precision)}%`,
        a3,
        b3
      ];
      break;
    }
    case "oklch": {
      separator = " ";
      const { l: l3, c: c5, h: h5 } = restrictValues(getColorValue(input, "oklch"), precision);
      params = [
        `${round$12(l3 * 100, precision)}%`,
        c5,
        h5
      ];
      break;
    }
    case "rgb": {
      const { r: r5, g: g4, b: b3 } = getColorValue(input, "rgb");
      params = [
        r5,
        g4,
        b3
      ];
      break;
    }
    default: {
      const hex = removeAlphaFromHex(getColorValue(input, "hex"));
      if (alpha && alpha !== 1) return `${hex}${convertAlphaToHex(alpha)}`;
      return hex;
    }
  }
  return `${format}(${params.join(separator)}${opacity2 ? ` / ${opacity2}` : ""})`;
}
function updater(key, operator, format) {
  return (input, amount) => {
    invariant(isString(input), MESSAGES.inputString);
    invariant(isNumber(amount), MESSAGES.alpha);
    const color = parseCSS(input, "hsl");
    const output = isHex(input) || isNamedColor(input) ? "hex" : extractColorParts(input).model;
    return formatCSS({
      ...color,
      [key]: clamp$2(color[key] + (operator === "+" ? amount : -amount), 0, 100)
    }, { format: format ?? output });
  };
}
function darken(input, amount, format) {
  return updater("l", "-", format)(input, amount);
}
function desaturate(input, amount, format) {
  return updater("s", "-", format)(input, amount);
}
function rotate2(input, degrees, format) {
  invariant(isString(input), MESSAGES.inputString);
  invariant(isNumber(degrees), "degrees must be a number");
  const color = parseCSS(input, "hsl");
  const output = isHex(input) || isNamedColor(input) ? "hex" : extractColorParts(input).model;
  return formatCSS({
    ...color,
    h: constrainDegrees(color.h, degrees)
  }, { format: format ?? output });
}
function invert2(input) {
  invariant(isString(input), MESSAGES.inputString);
  const format = isHex(input) || isNamedColor(input) ? "hex" : extractColorParts(input).model;
  const hex = parseCSS(input, "hex");
  return formatCSS(rotate2(hex, 180), { format });
}
function lighten(input, amount, format) {
  return updater("l", "+", format)(input, amount);
}
function opacify(input, alpha, format) {
  invariant(isString(input), MESSAGES.inputString);
  invariant(isNumber(alpha), MESSAGES.alpha);
  const type = isHex(input) || isNamedColor(input) ? "hex" : extractColorParts(input).model;
  const rgb = parseCSS(input, "rgb");
  return formatCSS(rgb, {
    format: format ?? type,
    alpha
  });
}
function opacity(input) {
  invariant(isString(input), MESSAGES.inputString);
  if (isHex(input)) return extractAlphaFromHex(input);
  else if (Object.keys(cssColors).includes(input)) return 1;
  const { alpha } = extractColorParts(input);
  if (!alpha) return 1;
  return alpha;
}
function saturate(input, amount, format) {
  return updater("s", "+", format)(input, amount);
}
function textColor(input, options = {}) {
  const { darkColor = "#000000", lightColor = "#ffffff", threshold = 128 } = options;
  invariant(isString(input), MESSAGES.inputString);
  invariant(threshold >= 0 && threshold <= 255, MESSAGES.threshold);
  try {
    const { r: r5, g: g4, b: b3 } = hex2rgb(parseCSS(input, "hex"));
    const yiq = (r5 * 299 + g4 * 587 + b3 * 114) / 1e3;
    return yiq >= threshold ? darkColor : lightColor;
  } catch (error) {
    console.warn(`Invalid color input: ${input}`);
    console.warn(error);
    return darkColor;
  }
}
function transparentize(input, alpha, format) {
  invariant(isString(input), MESSAGES.inputString);
  invariant(isNumber(alpha), MESSAGES.alpha);
  invariant(alpha >= -1 && alpha <= 1, MESSAGES.alpha);
  const oklch = parseCSS(input, "oklab");
  const value3 = round$12(clamp$2(opacity(input) - alpha, 0, 1));
  return formatCSS(oklch, {
    format,
    alpha: value3
  });
}
var Colorizr = class {
  constructor(color, options = {}) {
    __publicField(this, "alpha");
    __publicField(this, "hex");
    __publicField(this, "hsl");
    __publicField(this, "oklab");
    __publicField(this, "oklch");
    __publicField(this, "rgb");
    __publicField(this, "type");
    invariant(!!color, "color is required");
    const { alpha, hex, hsl, oklab, oklch, rgb, type } = parseColor(color);
    this.hex = hex;
    this.hsl = hsl;
    this.oklab = oklab;
    this.oklch = oklch;
    this.rgb = rgb;
    this.alpha = alpha;
    this.type = options.format ?? type;
  }
  /**
  * Get css string
  */
  get css() {
    return this.selectedColor;
  }
  /**
  * Get the red value
  */
  get red() {
    return Number(this.rgb.r);
  }
  /**
  * Get the green value
  */
  get green() {
    return Number(this.rgb.g);
  }
  /**
  * Get the blue value
  */
  get blue() {
    return Number(this.rgb.b);
  }
  /**
  * Get the hue value
  */
  get hue() {
    return Number(this.hsl.h);
  }
  /**
  * Get the saturation value
  */
  get saturation() {
    return Number(this.hsl.s);
  }
  /**
  * Get the lightness value
  */
  get lightness() {
    return Number(this.hsl.l);
  }
  /**
  * Get the luminance value
  */
  get luminance() {
    return luminance(this.selectedColor);
  }
  /**
  * Get the chroma value
  */
  get chroma() {
    return chroma(this.selectedColor);
  }
  get opacity() {
    return opacity(this.selectedColor);
  }
  /**
  * Get the contrasted color
  */
  get textColor() {
    return textColor(this.selectedColor);
  }
  get selectedColor() {
    return formatCSS(this[this.type], {
      format: this.type,
      alpha: this.alpha
    });
  }
  brightnessDifference(input) {
    return brightnessDifference(this.selectedColor, input);
  }
  colorDifference(input) {
    return colorDifference(this.selectedColor, input);
  }
  /**
  * Test 2 colors for compliance
  */
  compare(input) {
    return compare4(this.selectedColor, input);
  }
  contrast(input) {
    return contrast(this.selectedColor, input);
  }
  format(type, precision) {
    return formatCSS(this.rgb, {
      alpha: this.alpha,
      format: type,
      precision
    });
  }
  /**
  * Increase lightness
  */
  lighten(amount) {
    return lighten(this.selectedColor, amount);
  }
  /**
  * Decrease lightness
  */
  darken(amount) {
    return darken(this.selectedColor, amount);
  }
  /**
  * Increase saturation
  */
  saturate(amount) {
    return saturate(this.selectedColor, amount);
  }
  /**
  * Decrease saturation
  */
  desaturate(amount) {
    return desaturate(this.selectedColor, amount);
  }
  /**
  * Invert color
  */
  invert() {
    return invert2(this.selectedColor);
  }
  /**
  * Add opacity to the color.
  */
  opacify(alpha = 0.9) {
    return opacify(this.selectedColor, alpha, this.type);
  }
  /**
  * Rotate color
  */
  rotate(degrees) {
    return rotate2(this.selectedColor, degrees);
  }
  /**
  * Make the color more transparent
  */
  transparentize(alpha = 0.1) {
    return transparentize(this.selectedColor, alpha, this.type);
  }
};
function convert$1(input, format) {
  const value3 = parseCSS(input, format);
  return formatCSS(value3, { format });
}
var index_default = Colorizr;
var isHsl = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`h` in v3)) return false;
  if (!(`s` in v3)) return false;
  if (!(`l` in v3)) return false;
  if (!(`unit` in v3)) return false;
  if (!(`space` in v3)) return false;
  if (v3.space !== `hsl`) return false;
  return true;
};
var isRgb = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`r` in v3)) return false;
  if (!(`g` in v3)) return false;
  if (!(`b` in v3)) return false;
  if (!(`space` in v3)) return false;
  if (!(`unit` in v3)) return false;
  if (v3.space === `srgb`) return true;
  return false;
};
var tryParseObjectToRgb = (v3) => {
  if (typeof v3 !== `object`) throw new TypeError(`Param 'v' is expected to be an object, got: ${typeof v3}`);
  if (!(`r` in v3 && `g` in v3 && `b` in v3)) return;
  if (!(`unit` in v3)) if (v3.r <= 1 && v3.g <= 1 && v3.b <= 1) v3.unit = `scalar`;
  else if (v3.r > 255 && v3.g <= 255 && v3.b <= 255) return;
  else v3.unit = `8bit`;
  if (!(`space` in v3)) v3.space = `srgb`;
  return v3;
};
var tryParseObjectToHsl = (v3) => {
  if (!(`h` in v3 && `s` in v3 && `l` in v3)) return;
  if (!(`unit` in v3)) if (v3.r <= 1 && v3.g <= 1 && v3.b <= 1) v3.unit = `scalar`;
  else if (v3.s > 100 && v3.l <= 100) return;
  else v3.unit = `absolute`;
  if (!(`space` in v3)) v3.space = `hsl`;
  return v3;
};
var isOkLch = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`l` in v3)) return false;
  if (!(`c` in v3)) return false;
  if (!(`h` in v3)) return false;
  if (!(`unit` in v3)) return false;
  if (!(`space` in v3)) return false;
  if (v3.space === `lch`) return true;
  if (v3.space === `oklch`) return true;
  return false;
};
var isColourish = (v3) => {
  if (typeof v3 === `string`) return true;
  if (typeof v3 !== `object`) return false;
  if (isHsl(v3)) return true;
  if (isOkLch(v3)) return true;
  if (isRgb(v3)) return true;
  return false;
};
function calculateHueDistance(a3, b3, limit$1 = 1) {
  let long = -1;
  let short = -1;
  if (b3 < a3) {
    long = b3 - a3;
    short = limit$1 - (a3 - b3);
  } else {
    long = b3 - a3;
    short = long - limit$1;
  }
  const forward = short > 0 ? short : long;
  const backward = short > 0 ? long : short;
  if (Math.abs(long) < Math.abs(short)) {
    const t6 = short;
    short = long;
    long = t6;
  }
  return {
    long,
    short,
    forward,
    backward
  };
}
var libraryRgbToHexString = (rgb) => {
  const componentToHex = (c5) => {
    const hex = Math.floor(c5).toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  };
  let part = `#${componentToHex(rgb.r)}${componentToHex(rgb.g)}${componentToHex(rgb.b)}`;
  if (typeof rgb.alpha !== `undefined` && rgb.alpha !== 255) part += componentToHex(rgb.alpha);
  return part;
};
function wrapScalarHue(value3) {
  value3 = value3 % 1;
  if (value3 < 0) return (1 - Math.abs(value3)) % 1;
  return value3;
}
var hsl_exports = {};
__export(hsl_exports, {
  absolute: () => absolute$1,
  changeLightness: () => changeLightness$1,
  fromCss: () => fromCss$2,
  fromHexString: () => fromHexString$2,
  generateScalar: () => generateScalar$1,
  guard: () => guard$52,
  interpolator: () => interpolator$3,
  parseCssHslFunction: () => parseCssHslFunction,
  scalar: () => scalar,
  toAbsolute: () => toAbsolute$1,
  toCssString: () => toCssString,
  toHexString: () => toHexString$2,
  toLibraryRgb: () => toLibraryRgb,
  toScalar: () => toScalar$2,
  withOpacity: () => withOpacity$3
});
var withOpacity$3 = (value3, fn2) => {
  switch (value3.unit) {
    case `absolute`:
      return {
        ...value3,
        opacity: fn2((value3.opacity ?? 100) / 100, value3) * 100
      };
    case `scalar`:
      return {
        ...value3,
        opacity: fn2(value3.opacity ?? 1, value3)
      };
  }
};
var changeLightness$1 = (value3, amount) => {
  let newL = 0;
  if (typeof amount.pdelta !== `undefined`) newL = value3.l + value3.l * amount.pdelta;
  else if (typeof amount.delta !== `undefined`) newL = amount.delta + value3.l;
  else if (typeof amount.fixed !== `undefined`) {
    if (amount.fixed < 0) throw new TypeError(`Cannot use negative value with 'fixed'`);
    newL = amount.fixed;
  } else throw new TypeError(`Parameter 'amount' is missing 'delta/pdelta/fixed' properties`);
  return {
    ...value3,
    l: scaleProperty(value3, newL, `l`)
  };
};
var scaleProperty = (hsl, value3, property) => {
  if (hsl.unit === `scalar`) {
    if (value3 > 1) value3 = 1;
    else if (value3 < 0) value3 = 0;
  } else if (value3 > 100) value3 = 100;
  else if (value3 < 0) value3 = 0;
  return value3;
};
var hslTransparent = Object.freeze({
  h: 0,
  s: 0,
  l: 0,
  opacity: 0,
  unit: `absolute`,
  space: `hsl`
});
function fromHexString$2(hexString, options = {}) {
  return fromLibrary$2(hex2hsl(hexString), options);
}
function fromCss$2(value3, options = {}) {
  value3 = value3.toLowerCase();
  if (value3.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);
  if (value3.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);
  if (value3.startsWith(`#`)) return fromHexString$2(value3, options);
  if (value3.startsWith(`--`)) try {
    value3 = resolveCss(value3);
  } catch (error) {
    if (typeof options.fallbackString !== `undefined`) value3 = options.fallbackString;
    if (typeof options.fallbackColour !== `undefined`) return options.fallbackColour;
    throw error;
  }
  if (value3 === `transparent`) return hslTransparent;
  if (typeof cssDefinedHexColours[value3] !== `undefined`) return fromHexString$2(cssDefinedHexColours[value3], options);
  if (value3.startsWith(`rgb(`)) {
    const hsl = toLibraryHsl(value3);
    return fromLibrary$2(hsl, options);
  }
  if (!value3.startsWith(`hsl(`)) try {
    value3 = convert$1(value3, `hsl`);
  } catch (error) {
    if (options.fallbackString) value3 = options.fallbackString;
    else throw error;
  }
  try {
    const hsl = parseCssHslFunction(value3);
    if (options.scalar) return toScalar$2(hsl);
    return toAbsolute$1(hsl);
  } catch (error) {
    if (options.fallbackColour) return options.fallbackColour;
    throw error;
  }
}
var toCssString = (hsl) => {
  const abs$12 = toAbsolute$1(hsl);
  let css = `hsl(${abs$12.h}deg ${abs$12.s}% ${abs$12.l}%`;
  if (`opacity` in abs$12 && abs$12.opacity !== void 0 && abs$12.opacity < 100) css += ` / ${abs$12.opacity}%`;
  css += ")";
  return css;
};
var toHexString$2 = (hsl) => {
  const rgb = toLibraryRgb(hsl);
  return libraryRgbToHexString(rgb);
};
function fromLibrary$2(hsl, parsingOptions = {}) {
  if (typeof hsl === `undefined` || hsl === null) {
    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;
  }
  const scalarOpt = parsingOptions.scalar ?? true;
  resultThrow(numberInclusiveRangeTest(hsl.h, 0, 360, `h`), numberInclusiveRangeTest(hsl.s, 0, 100, `s`), numberInclusiveRangeTest(hsl.l, 0, 100, `l`), percentTest(hsl.alpha ?? 1, `alpha`));
  if (scalarOpt) return scalar(hsl.h / 360, hsl.s / 100, hsl.l / 100, hsl.alpha ?? 1);
  else return absolute$1(hsl.h, hsl.s, hsl.l, (hsl.alpha ?? 1) * 100);
}
var toAbsolute$1 = (hslOrString) => {
  if (typeof hslOrString === `string`) return fromCss$2(hslOrString, { scalar: false });
  if (isRgb(hslOrString)) return toAbsolute$1(fromLibrary$2(toLibraryHsl(hslOrString), { scalar: false }));
  const hsl = hslOrString;
  guard$52(hsl);
  if (hsl.unit === `absolute`) return hsl;
  return {
    h: hsl.h * 360,
    s: hsl.s * 100,
    l: hsl.l * 100,
    opacity: (hsl.opacity ?? 1) * 100,
    unit: `absolute`,
    space: `hsl`
  };
};
var generateScalar$1 = (absoluteHslOrVariable, saturation = 1, lightness$1 = 0.5, opacity$1 = 1) => {
  if (typeof absoluteHslOrVariable === `string`) {
    if (absoluteHslOrVariable.startsWith(`--`)) absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim();
  }
  const hue = angleParse(absoluteHslOrVariable);
  if (saturation > 1) throw new TypeError(`Param 'saturation' must be between 0..1`);
  if (lightness$1 > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);
  if (opacity$1 > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);
  const hueDeg = angleConvert(hue, `deg`).value / 360;
  return {
    h: hueDeg,
    s: saturation,
    l: lightness$1,
    opacity: opacity$1,
    unit: `scalar`,
    space: `hsl`
  };
};
var toScalar$2 = (hslOrString) => {
  if (typeof hslOrString === `string`) return fromCss$2(hslOrString, { scalar: true });
  if (isRgb(hslOrString)) return toScalar$2(fromLibrary$2(toLibraryHsl(hslOrString), { scalar: true }));
  const hsl = hslOrString;
  guard$52(hsl);
  if (hsl.unit === `scalar`) return hsl;
  return {
    h: hsl.h / 360,
    s: hsl.s / 100,
    l: hsl.l / 100,
    opacity: (hsl.opacity ?? 1) / 100,
    unit: `scalar`,
    space: `hsl`
  };
};
var guard$52 = (hsl) => {
  const { h: h5, s: s3, l: l3, opacity: opacity$1, space, unit } = hsl;
  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${space}`);
  if (unit === `absolute`) resultThrow(numberTest(h5, `finite`, `h`), numberInclusiveRangeTest(s3, 0, 100, `s`), numberInclusiveRangeTest(l3, 0, 100, `l`), () => {
    if (typeof opacity$1 === `number`) return numberInclusiveRangeTest(opacity$1, 0, 100, `opacity`);
  });
  else if (unit === `scalar`) resultThrow(numberTest(h5, `percentage`, `h`), numberTest(s3, `percentage`, `s`), numberTest(l3, `percentage`, `l`), () => {
    if (typeof opacity$1 === `number`) return numberTest(opacity$1, `percentage`, `opacity`);
  });
  else throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${unit}`);
};
var interpolator$3 = (a3, b3, direction = `shorter`) => {
  a3 = toScalar$2(a3);
  b3 = toScalar$2(b3);
  const aOpacity = a3.opacity ?? 1;
  const distanceCalc = calculateHueDistance(a3.h, b3.h, 1);
  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;
  const satDistance = b3.s - a3.s;
  const lightDistance = b3.l - a3.l;
  const opacityDistance = (b3.opacity ?? 1) - aOpacity;
  return (amount) => {
    amount = clamp(amount);
    let h5 = interpolate(amount, 0, Math.abs(hueDistance));
    if (hueDistance < 0) h5 = a3.h - h5;
    else h5 = a3.h + h5;
    const s3 = interpolate(amount, 0, satDistance);
    const l3 = interpolate(amount, 0, lightDistance);
    const o5 = interpolate(amount, 0, opacityDistance);
    return scalar(wrapScalarHue(h5), s3 + a3.s, l3 + a3.l, o5 + aOpacity);
  };
};
function scalar(hue = 0.5, sat = 1, lightness$1 = 0.5, opacity$1 = 1) {
  const hsl = {
    unit: `scalar`,
    space: `hsl`,
    h: hue,
    s: sat,
    l: lightness$1,
    opacity: opacity$1
  };
  guard$52(hsl);
  return hsl;
}
function absolute$1(hue = 200, sat = 100, lightness$1 = 50, opacity$1 = 100) {
  const hsl = {
    unit: `absolute`,
    space: `hsl`,
    h: hue,
    s: sat,
    l: lightness$1,
    opacity: opacity$1
  };
  guard$52(hsl);
  return hsl;
}
function parseCssHslFunction(value3) {
  if (value3.startsWith(`hsla`)) throw new Error(`hsla() is not supported`);
  if (!value3.startsWith(`hsl(`)) throw new Error(`Expected hsl(..) CSS colour`);
  const start = value3.indexOf("(");
  const end = value3.indexOf(")");
  if (end < start) throw new Error(`Is hsl() not terminated? Missing ')'`);
  const part = value3.substring(start + 1, end);
  let split = part.split(/[\s,]+/);
  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${split.length} length`);
  let returnRelative = false;
  if (split[0].endsWith(`%`)) returnRelative = true;
  if (split[1].endsWith(`%`) && split[2].endsWith(`%`)) returnRelative = true;
  const valueAsScalar = (v3, pos) => {
    if (v3 === `none`) return 0;
    if (v3.endsWith(`%`)) return Number.parseFloat(v3.substring(0, v3.length - 1)) / 100;
    if (v3.endsWith(`deg`) && pos === 0) v3 = v3.substring(0, v3.length - 3);
    const vf = Number.parseFloat(v3);
    if (pos === 0) return vf / 360;
    if (pos === 3) return vf;
    return vf / 100;
  };
  const valueAsAbs = (v3, pos) => {
    if (v3 === `none`) return 0;
    if (v3.endsWith(`%`)) {
      const vf$1 = Number.parseFloat(v3.substring(0, v3.length - 1));
      if (pos === 0) return vf$1 * 360;
      return vf$1;
    }
    if (v3.endsWith(`deg`) && pos === 0) return Number.parseFloat(v3.substring(0, v3.length - 3));
    const vf = Number.parseFloat(v3);
    return vf;
  };
  if (split.length > 3) {
    if (split[3] === "/") split = [
      split[0],
      split[1],
      split[2],
      split[4]
    ];
  }
  if (returnRelative) return scalar(valueAsScalar(split[0], 0), valueAsScalar(split[1], 1), valueAsScalar(split[2], 2), valueAsScalar(split[3] ?? `100%`, 3));
  else return absolute$1(valueAsAbs(split[0], 0), valueAsAbs(split[1], 1), valueAsAbs(split[2], 2), valueAsAbs(split[3] ?? `100%`, 3));
}
function toLibraryRgb(hsl) {
  if (typeof hsl === `string`) {
    const parseResult = fromCss$2(hsl, { scalar: false });
    return toLibraryRgb(parseResult);
  }
  hsl = toAbsolute$1(hsl);
  const rgb = hsl2rgb({
    h: hsl.h,
    s: hsl.s,
    l: hsl.l
  });
  return {
    ...rgb,
    alpha: (hsl.opacity ?? 100) / 100 * 255
  };
}
var oklch_exports = {};
__export(oklch_exports, {
  OKLCH_CHROMA_MAX: () => OKLCH_CHROMA_MAX,
  absolute: () => absolute,
  fromCss: () => fromCss$1,
  fromHexString: () => fromHexString$1,
  fromLibrary: () => fromLibrary$1,
  generateScalar: () => generateScalar,
  guard: () => guard$42,
  interpolator: () => interpolator$2,
  scalar: () => scalar$2,
  toAbsolute: () => toAbsolute2,
  toCssString: () => toCssString$2,
  toHexString: () => toHexString$1,
  toScalar: () => toScalar$1,
  withOpacity: () => withOpacity$2
});
var OKLCH_CHROMA_MAX = 0.4;
var guard$42 = (lch) => {
  const { l: l3, c: c5, h: h5, opacity: opacity$1, space, unit } = lch;
  if (space !== `oklch`) throw new Error(`Space is expected to be 'oklch'. Got: ${space}`);
  if (unit === `absolute`) resultThrow(percentTest(l3, `l`), () => {
    if (typeof c5 === `number`) return numberInclusiveRangeTest(c5, 0, OKLCH_CHROMA_MAX, `c`);
  }, () => {
    if (typeof h5 === `number`) return numberInclusiveRangeTest(c5, 0, 360, `h`);
  }, percentTest(opacity$1 ?? 1, `opacity`));
  else if (unit === `scalar`) resultThrow(percentTest(l3, `l`), percentTest(c5, `c`), percentTest(h5, `h`), percentTest(lch.opacity ?? 1, `opacity`));
  else throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${unit}`);
};
function fromLibrary$1(lch, parsingOptions = {}) {
  if (typeof lch === `undefined` || lch === null) {
    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;
  }
  const scalarReturn = parsingOptions.scalar ?? true;
  resultThrow(percentTest(lch.l, `l`), percentTest(lch.c, `c`), numberInclusiveRangeTest(lch.h, 0, 360, `h`), percentTest(lch.alpha ?? 1, `alpha`));
  if (scalarReturn) return scalar$2(lch.l, lch.c / OKLCH_CHROMA_MAX, lch.h / 360, lch.alpha ?? 1);
  else return absolute(lch.l, lch.c, lch.h, lch.alpha ?? 1);
}
var fromHexString$1 = (hexString, options = {}) => {
  return fromLibrary$1(hex2oklch(hexString), options);
};
var oklchTransparent = Object.freeze({
  l: 0,
  c: 0,
  h: 0,
  opacity: 0,
  unit: `absolute`,
  space: `oklch`
});
function fromCss$1(value3, options = {}) {
  value3 = value3.toLowerCase();
  if (value3.startsWith(`#`)) return fromHexString$1(value3, options);
  if (value3 === `transparent`) return oklchTransparent;
  if (typeof cssDefinedHexColours[value3] !== `undefined`) return fromHexString$1(cssDefinedHexColours[value3], options);
  if (value3.startsWith(`rgb(`)) {
    const rgb = to8bit(parseCssRgbFunction(value3));
    const lch$1 = rgb2oklch({
      r: rgb.r,
      g: rgb.g,
      b: rgb.b
    });
    return fromLibrary$1(lch$1, options);
  }
  if (!value3.startsWith(`hsl(`) && !value3.startsWith(`oklch(`)) try {
    const converted = convert$1(value3, `oklch`);
    value3 = converted;
  } catch (error) {
    if (options.fallbackString) value3 = options.fallbackString;
    else throw error;
  }
  const cc = new index_default(value3);
  const lch = cc.oklch;
  return fromLibrary$1(lch, options);
}
var toAbsolute2 = (lchOrString) => {
  if (typeof lchOrString === `string`) return toAbsolute2(fromCss$1(lchOrString, { scalar: true }));
  guard$42(lchOrString);
  if (lchOrString.unit === `absolute`) return lchOrString;
  return {
    space: `oklch`,
    unit: `absolute`,
    l: lchOrString.l,
    c: lchOrString.c * OKLCH_CHROMA_MAX,
    h: lchOrString.h * 360,
    opacity: lchOrString.opacity
  };
};
var toScalar$1 = (lchOrString) => {
  if (typeof lchOrString === `string`) return toScalar$1(fromCss$1(lchOrString, { scalar: true }));
  const lch = lchOrString;
  guard$42(lch);
  if (lch.unit === `scalar`) return lch;
  return {
    l: lch.l,
    c: lch.c / OKLCH_CHROMA_MAX,
    h: lch.h / 360,
    opacity: lch.opacity ?? 1,
    unit: `scalar`,
    space: `oklch`
  };
};
var toLibrary$1 = (lch) => {
  const abs$12 = toAbsolute2(lch);
  return {
    l: abs$12.l,
    c: abs$12.c,
    h: abs$12.h,
    alpha: abs$12.opacity
  };
};
var toCssString$2 = (lch, precision = 3) => {
  guard$42(lch);
  const { l: l3, c: c5, h: h5, opacity: opacity$1 } = lch;
  let css = ``;
  switch (lch.unit) {
    case `absolute`:
      css = `oklch(${(l3 * 100).toFixed(precision)}% ${c5.toFixed(precision)} ${h5.toFixed(precision)}`;
      break;
    case `scalar`:
      css = `oklch(${l3.toFixed(precision)} ${(c5 * OKLCH_CHROMA_MAX).toFixed(precision)} ${(h5 * 360).toFixed(precision)}`;
      break;
  }
  if (typeof opacity$1 !== `undefined` && opacity$1 !== 1) css += ` / ${opacity$1.toFixed(precision)}`;
  css += `)`;
  return css;
};
var toHexString$1 = (lch) => {
  const lch1 = toLibrary$1(lch);
  const rgb = oklch2rgb(lch1);
  return libraryRgbToHexString(rgb);
};
var generateScalar = (absoluteHslOrVariable, chroma$1 = 1, lightness$1 = 0.5, opacity$1 = 1) => {
  if (typeof absoluteHslOrVariable === `string`) {
    if (absoluteHslOrVariable.startsWith(`--`)) absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim();
  }
  if (lightness$1 > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);
  if (chroma$1 > 1) throw new TypeError(`Param 'chroma' must be between 0..1`);
  const hue = angleParse(absoluteHslOrVariable);
  const hueDeg = angleConvert(hue, `deg`).value / 360;
  if (opacity$1 > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);
  return {
    l: lightness$1,
    c: chroma$1,
    h: hueDeg,
    opacity: opacity$1,
    unit: `scalar`,
    space: `oklch`
  };
};
var withOpacity$2 = (value3, fn2) => {
  switch (value3.unit) {
    case `absolute`:
      return {
        ...value3,
        opacity: fn2((value3.opacity ?? 100) / 100, value3) * 100
      };
    case `scalar`:
      return {
        ...value3,
        opacity: fn2(value3.opacity ?? 1, value3)
      };
  }
};
var interpolator$2 = (a3, b3, direction = `shorter`) => {
  a3 = toScalar$1(a3);
  b3 = toScalar$1(b3);
  const aOpacity = a3.opacity ?? 1;
  const distanceCalc = calculateHueDistance(a3.h, b3.h, 1);
  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;
  const chromaDistance = b3.c - a3.c;
  const lightDistance = b3.l - a3.l;
  const opacityDistance = (b3.opacity ?? 1) - aOpacity;
  return (amount) => {
    amount = clamp(amount);
    let h5 = interpolate(amount, 0, Math.abs(hueDistance));
    if (hueDistance < 0) h5 = a3.h - h5;
    else h5 = a3.h + h5;
    const c5 = interpolate(amount, 0, chromaDistance);
    const l3 = interpolate(amount, 0, lightDistance);
    const o5 = interpolate(amount, 0, opacityDistance);
    return scalar$2(l3 + a3.l, c5 + a3.c, wrapScalarHue(h5), o5 + aOpacity);
  };
};
function scalar$2(lightness$1 = 0.7, chroma$1 = 0.1, hue = 0.5, opacity$1 = 1) {
  const lch = {
    unit: `scalar`,
    space: `oklch`,
    l: lightness$1,
    c: chroma$1,
    h: hue,
    opacity: opacity$1
  };
  guard$42(lch);
  return lch;
}
var absolute = (l3, c5, h5, opacity$1 = 1) => {
  const lch = {
    space: `oklch`,
    unit: `absolute`,
    opacity: opacity$1,
    l: l3,
    c: c5,
    h: h5
  };
  guard$42(lch);
  return lch;
};
var fromCssColour = (colour) => {
  if (colour.startsWith(`#`)) return fromHexString(colour, true);
  if (typeof cssDefinedHexColours[colour] !== `undefined`) return fromHexString(cssDefinedHexColours[colour], true);
  if (colour.startsWith(`--`)) {
    const fromCss$3 = getComputedStyle(document.body).getPropertyValue(colour).trim();
    if (fromCss$3.length === 0 || fromCss$3 === null) throw new Error(`Variable missing: ${colour}`);
    return fromCssColour(fromCss$3);
  }
  colour = colour.toLowerCase();
  if (colour.startsWith(`hsl(`)) return fromCss$2(colour, { scalar: true });
  if (colour.startsWith(`rgb(`)) return fromCss(colour, { scalar: true });
  if (colour.startsWith(`oklch(`)) return fromCss$1(colour, { scalar: true });
  throw new Error(`String colour is not a hex colour, CSS variable nor well-defined colour. Input: '${colour}'`);
};
var resolveCss = (colour, fallback) => {
  if (colour.startsWith(`--`)) {
    const fromCss$3 = getComputedStyle(document.body).getPropertyValue(colour).trim();
    if (fromCss$3.length === 0 || fromCss$3 === null) {
      if (typeof fallback !== `undefined`) return fallback;
      throw new Error(`CSS variable missing: '${colour}'`);
    }
    return resolveCss(fromCss$3);
  }
  if (typeof cssDefinedHexColours[colour] !== `undefined`) return cssDefinedHexColours[colour];
  return colour;
};
var cssDefinedHexColours = {
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgray": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370db",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#db7093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32",
  "transparent": "#00000000"
};
var srgb_exports = {};
__export(srgb_exports, {
  changeLightness: () => changeLightness,
  eightBit: () => eightBit,
  fromCss: () => fromCss,
  fromHexString: () => fromHexString,
  guard: () => guard$32,
  interpolator: () => interpolator$1,
  lightness: () => lightness,
  parseCssRgbFunction: () => parseCssRgbFunction,
  scalar: () => scalar$1,
  to8bit: () => to8bit,
  toCssString: () => toCssString$1,
  toHexString: () => toHexString,
  toLibraryHsl: () => toLibraryHsl,
  toScalar: () => toScalar2,
  withOpacity: () => withOpacity$1
});
var withOpacity$1 = (value3, fn2) => {
  switch (value3.unit) {
    case `8bit`:
      return {
        ...value3,
        opacity: fn2((value3.opacity ?? 255) / 255, value3) * 255
      };
    case `scalar`:
      return {
        ...value3,
        opacity: fn2(value3.opacity ?? 1, value3)
      };
  }
};
function fromHexString(hexString, scalar$3 = true) {
  return fromLibrary(hex2rgb(hexString), { scalar: scalar$3 });
}
var srgbTansparent = Object.freeze({
  r: 0,
  g: 0,
  b: 0,
  opacity: 0,
  unit: `8bit`,
  space: `srgb`
});
function fromCss(value3, options = {}) {
  value3 = value3.toLowerCase();
  if (value3.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);
  if (value3.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);
  const scalar$3 = options.scalar ?? true;
  if (value3.startsWith(`#`)) return fromHexString(value3, scalar$3);
  if (value3 === `transparent`) return srgbTansparent;
  if (typeof cssDefinedHexColours[value3] !== `undefined`) fromHexString(cssDefinedHexColours[value3], scalar$3);
  if (value3.startsWith(`hsl(`)) {
    const rgb = toLibraryRgb(value3);
    return fromLibrary(rgb, options);
  }
  if (!value3.startsWith(`rgb(`)) try {
    value3 = convert$1(value3, `rgb`);
  } catch (error) {
    if (options.fallbackString) value3 = options.fallbackString;
    else throw error;
  }
  try {
    const rgb = parseCssRgbFunction(value3);
    if (scalar$3) return toScalar2(rgb);
    return to8bit(rgb);
  } catch (error) {
    if (options.fallbackColour) return options.fallbackColour;
    throw error;
  }
}
var toHexString = (rgb) => {
  const rgb1 = toLibrary(rgb);
  return libraryRgbToHexString(rgb1);
};
var toCssString$1 = (rgb) => {
  guard$32(rgb);
  switch (rgb.unit) {
    case `8bit`:
      if (rgb.opacity === void 0 || rgb.opacity === 255) return `rgb(${rgb.r} ${rgb.g} ${rgb.b})`;
      return `rgb(${rgb.r} ${rgb.g} ${rgb.b} / ${(rgb.opacity ?? 255) / 255})`;
    case `scalar`:
      if (rgb.opacity === void 0 || rgb.opacity === 1) return `rgb(${rgb.r * 100}% ${rgb.g * 100}% ${rgb.b * 100}%)`;
      return `rgb(${rgb.r * 100}% ${rgb.g * 100}% ${rgb.b * 100}% / ${(rgb.opacity ?? 1) * 100}%)`;
    default:
      throw new Error(`Unknown unit: ${rgb.unit}`);
  }
};
var toLibrary = (rgb) => {
  const abs$12 = to8bit(rgb);
  return {
    r: abs$12.r,
    g: abs$12.g,
    b: abs$12.b,
    alpha: abs$12.opacity
  };
};
function fromLibrary(rgb, parsingOptions = {}) {
  if (parsingOptions.scalar) return {
    r: rgb.r / 255,
    g: rgb.g / 255,
    b: rgb.b / 255,
    opacity: rgb.alpha ?? 1,
    unit: `scalar`,
    space: `srgb`
  };
  else return {
    r: rgb.r,
    g: rgb.g,
    b: rgb.b,
    opacity: rgb.alpha ?? 255,
    unit: `8bit`,
    space: `srgb`
  };
}
var to8bit = (rgbOrString) => {
  if (typeof rgbOrString === `string`) return fromCss(rgbOrString, { scalar: false });
  if (isHsl(rgbOrString)) return to8bit(fromLibrary(toLibraryRgb(rgbOrString), { scalar: false }));
  guard$32(rgbOrString);
  if (rgbOrString.unit === `8bit`) return rgbOrString;
  return {
    r: rgbOrString.r * 255,
    g: rgbOrString.g * 255,
    b: rgbOrString.b * 255,
    opacity: (rgbOrString.opacity ?? 1) * 255,
    unit: `8bit`,
    space: `srgb`
  };
};
var toScalar2 = (rgbOrString) => {
  if (typeof rgbOrString === `string`) return fromCss(rgbOrString, { scalar: true });
  if (isHsl(rgbOrString)) return toScalar2(fromLibrary(toLibraryRgb(rgbOrString), { scalar: true }));
  guard$32(rgbOrString);
  if (rgbOrString.unit === `scalar`) return rgbOrString;
  return {
    r: rgbOrString.r / 255,
    g: rgbOrString.g / 255,
    b: rgbOrString.b / 255,
    opacity: (rgbOrString.opacity ?? 1) / 255,
    unit: `scalar`,
    space: `srgb`
  };
};
var guard$32 = (rgb) => {
  const { r: r5, g: g4, b: b3, opacity: opacity$1, space, unit } = rgb;
  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${space}`);
  if (unit === `8bit`) resultThrow(numberInclusiveRangeTest(r5, 0, 255, `r`), numberInclusiveRangeTest(g4, 0, 255, `g`), numberInclusiveRangeTest(b3, 0, 255, `b`), () => {
    if (typeof opacity$1 === `number`) return numberInclusiveRangeTest(opacity$1, 0, 255, `opacity`);
  });
  else if (unit === `scalar`) resultThrow(numberTest(r5, `percentage`, `r`), numberTest(g4, `percentage`, `g`), numberTest(b3, `percentage`, `b`), () => {
    if (typeof opacity$1 === `number`) return numberTest(opacity$1, `percentage`, `opacity`);
  });
  else throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${unit}`);
};
var changeLightness = (rgb, amount) => {
  let newL = 0;
  const co2 = new index_default(toCssString$1(rgb));
  const scalarUnit = rgb.unit === `scalar`;
  if (typeof amount.pdelta !== `undefined`) newL = co2.oklab.l + co2.oklab.l * amount.pdelta;
  else if (typeof amount.delta !== `undefined`) newL = co2.oklab.l + amount.delta;
  else if (typeof amount.fixed !== `undefined`) {
    if (amount.fixed < 0) throw new TypeError(`Amount cannot be negative when using 'fixed'`);
    newL = amount.fixed;
  } else throw new TypeError(`Parameter 'amount' is missing 'pdelta/delta/fixed' properties`);
  if (newL < 0) newL = 0;
  else if (newL > 1) newL = 1;
  const rgbResult = oklab2rgb({
    a: co2.oklab.a,
    b: co2.oklab.b,
    l: newL,
    alpha: co2.oklab.alpha
  });
  return fromLibrary(rgbResult, { scalar: scalarUnit });
};
function lightness(rgb) {
  const co2 = new index_default(toCssString$1(rgb));
  return co2.oklab.l;
}
function eightBit(red = 100, green = 100, blue = 100, opacity$1 = 255) {
  const rgb = {
    unit: `8bit`,
    space: `srgb`,
    r: red,
    g: green,
    b: blue,
    opacity: opacity$1
  };
  guard$32(rgb);
  return rgb;
}
function scalar$1(red = 0.5, green = 0.5, blue = 0.5, opacity$1 = 1) {
  const rgb = {
    unit: `scalar`,
    space: `srgb`,
    r: red,
    g: green,
    b: blue,
    opacity: opacity$1
  };
  guard$32(rgb);
  return rgb;
}
function parseCssRgbFunction(value3) {
  if (value3.startsWith(`rgba`)) throw new Error(`RGBA is not supported`);
  if (!value3.startsWith(`rgb(`)) throw new Error(`Expected rgb(..) CSS colour`);
  const start = value3.indexOf("(");
  const end = value3.indexOf(")");
  if (end < start) throw new Error(`Is rgb() not terminated? Missing ')'`);
  const part = value3.substring(start + 1, end);
  let split = part.split(/[\s,]+/);
  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${split.length} length`);
  let relativeCount = 0;
  for (const s3 of split) if (s3.endsWith("%")) relativeCount++;
  const valueAsScalar = (v3, pos) => {
    if (v3.endsWith(`%`)) return Number.parseFloat(v3.substring(0, v3.length - 1)) / 100;
    if (pos < 3) return Number.parseFloat(v3) / 255;
    else return Number.parseFloat(v3);
  };
  const valueAs8bit = (v3, pos) => {
    if (v3.endsWith(`%`)) return Number.parseFloat(v3.substring(0, v3.length - 1)) / 100 * 255;
    if (pos < 3) return Number.parseFloat(v3);
    else return Number.parseFloat(v3) * 255;
  };
  if (split.length > 3) {
    if (split[3] === "/") split = [
      split[0],
      split[1],
      split[2],
      split[4]
    ];
  }
  if (relativeCount > 1) return scalar$1(valueAsScalar(split[0], 0), valueAsScalar(split[1], 1), valueAsScalar(split[2], 2), valueAsScalar(split[3] ?? `1`, 3));
  else return eightBit(valueAs8bit(split[0], 0), valueAs8bit(split[1], 1), valueAs8bit(split[2], 2), valueAs8bit(split[3] ?? `1`, 3));
}
var interpolator$1 = (colourA, colourB) => {
  const aa2 = toScalar2(colourA);
  const bb = toScalar2(colourB);
  const aOpacity = aa2.opacity ?? 1;
  const opacityDistance = (bb.opacity ?? 1) - aOpacity;
  const r5 = bb.r - aa2.r;
  const g4 = bb.g - aa2.g;
  const b3 = bb.b - aa2.b;
  return (amount) => {
    amount = clamp(amount);
    return scalar$1(aa2.r + interpolate(amount, 0, r5), aa2.g + interpolate(amount, 0, g4), aa2.b + interpolate(amount, 0, b3), aOpacity + interpolate(amount, 0, opacityDistance));
  };
};
function toLibraryHsl(rgb) {
  if (typeof rgb === `string`) {
    const parseResult = fromCss(rgb, { scalar: false });
    return toLibraryHsl(parseResult);
  }
  rgb = to8bit(rgb);
  const hsl = rgb2hsl({
    r: rgb.r,
    g: rgb.g,
    b: rgb.b
  });
  return {
    ...hsl,
    alpha: (rgb.opacity ?? 255) / 255
  };
}
var image_data_grid_exports = {};
__export(image_data_grid_exports, {
  accessor: () => accessor,
  byColumn: () => byColumn,
  byRow: () => byRow,
  grid: () => grid$1,
  setter: () => setter,
  wrap: () => wrap5
});
var grid$1 = (image) => {
  const g4 = {
    rows: image.width,
    cols: image.height
  };
  return g4;
};
var wrap5 = (image) => {
  return {
    ...grid$1(image),
    get: accessor(image),
    set: setter(image)
  };
};
var accessor = (image) => {
  const g4 = grid$1(image);
  const data = image.data;
  const fn2 = (cell, bounds = `undefined`) => {
    const index = indexFromCell(g4, cell, bounds);
    if (index === void 0) return;
    const pxIndex = index * 4;
    return {
      r: data[pxIndex],
      g: data[pxIndex + 1],
      b: data[pxIndex + 2],
      opacity: data[pxIndex + 3],
      unit: `8bit`,
      space: `srgb`
    };
  };
  return fn2;
};
var setter = (image) => {
  const g4 = grid$1(image);
  const data = image.data;
  const fn2 = (value3, cell, bounds = `undefined`) => {
    const index = indexFromCell(g4, cell, bounds);
    if (index === void 0) throw new Error(`Cell out of range. ${cell.x},${cell.y}`);
    const pixel = to8bit(value3);
    const pxIndex = index * 4;
    data[pxIndex] = pixel.r;
    data[pxIndex + 1] = pixel.g;
    data[pxIndex + 2] = pixel.b;
    data[pxIndex + 3] = pixel.opacity ?? 255;
  };
  return fn2;
};
function* byRow(image) {
  const a3 = accessor(image);
  const g4 = grid$1(image);
  const v3 = rows(g4, {
    x: 0,
    y: 0
  });
  for (const row of v3) {
    const pixels = row.map((p3) => a3(p3, `undefined`));
    yield pixels;
  }
}
function* byColumn(image) {
  const a3 = accessor(image);
  const g4 = grid$1(image);
  for (let x3 = 0; x3 < g4.cols; x3++) {
    const col = [];
    for (let y3 = 0; y3 < g4.rows; y3++) {
      const p3 = a3({
        x: x3,
        y: y3
      }, `undefined`);
      if (p3) col.push(p3);
    }
    yield col;
  }
}
var CanvasHelper = class extends SimpleEventEmitter {
  el;
  opts;
  #scaler;
  #scalerSize;
  #viewport = EmptyPositioned;
  #logicalSize = Empty$3;
  #ctx;
  #drawHelper;
  #resizer;
  #disposed = false;
  constructor(domQueryOrEl, opts = {}) {
    super();
    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined. Expected canvas element.`);
    this.el = resolveEl2(domQueryOrEl);
    if (this.el.nodeName !== `CANVAS`) throw new Error(`Expected CANVAS HTML element. Got: ${this.el.nodeName}`);
    const size = this.el.getBoundingClientRect();
    this.opts = {
      resizeLogic: opts.resizeLogic ?? `none`,
      disablePointerEvents: opts.disablePointerEvents ?? false,
      pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),
      height: opts.height ?? size.height,
      width: opts.width ?? size.width,
      zIndex: opts.zIndex ?? -1,
      coordinateScale: opts.coordinateScale ?? `both`,
      onResizing: opts.onResizing,
      onResized: opts.onResized,
      clearOnResize: opts.clearOnResize ?? true,
      draw: opts.draw,
      skipCss: opts.skipCss ?? false,
      colourSpace: `srgb`
    };
    this.#scaler = scaler2(`both`);
    this.#scalerSize = scaler2(`both`, size);
    this.#init();
  }
  getRectangle() {
    return {
      x: 0,
      y: 0,
      ...this.#logicalSize
    };
  }
  dispose(reason) {
    if (this.#disposed) return;
    this.#disposed = true;
    if (this.#resizer) {
      this.#resizer.dispose(`CanvasHelper disposing ${reason}`.trim());
      this.#resizer = void 0;
    }
  }
  #getContext(reset2 = false) {
    if (this.#ctx === void 0 || reset2) {
      const ratio = this.ratio;
      const c5 = this.el.getContext(`2d`);
      if (c5 === null) throw new Error(`Could not create drawing context`);
      this.#ctx = c5;
      c5.setTransform(1, 0, 0, 1, 0, 0);
      c5.scale(ratio, ratio);
    }
    return this.#ctx;
  }
  /**
  * Gets the drawable area of the canvas.
  * This accounts for scaling due to high-DPI displays etc.
  * @returns
  */
  getPhysicalSize() {
    return {
      width: this.width * this.ratio,
      height: this.height * this.ratio
    };
  }
  /**
  * Creates a drawing helper for the canvas.
  * If one is already created it is reused.
  */
  getDrawHelper() {
    if (!this.#drawHelper) this.#drawHelper = makeHelper$1(this.#getContext(), {
      width: this.width,
      height: this.height
    });
  }
  setLogicalSize(logicalSize) {
    guard$6(logicalSize, `logicalSize`);
    const logicalSizeInteger = applyFields((v3) => Math.floor(v3), logicalSize);
    const ratio = this.opts.pixelZoom;
    this.#scaler = scaler2(this.opts.coordinateScale, logicalSize);
    this.#scalerSize = scaler2(`both`, logicalSize);
    const pixelScaled = multiplyScalar$2(logicalSize, ratio);
    this.el.width = pixelScaled.width;
    this.el.height = pixelScaled.height;
    this.el.style.width = logicalSizeInteger.width.toString() + `px`;
    this.el.style.height = logicalSizeInteger.height.toString() + `px`;
    this.#getContext(true);
    if (this.opts.clearOnResize) this.ctx.clearRect(0, 0, this.width, this.height);
    this.#logicalSize = logicalSizeInteger;
    if (this.opts.onResizing) this.opts.onResizing(this.ctx, this.size, this);
    this.fireEvent(`resize`, {
      ctx: this.ctx,
      size: this.#logicalSize,
      helper: this
    });
  }
  #init() {
    const d3 = this.opts.draw;
    if (d3) {
      const sched = () => {
        d3(this.ctx, this.#logicalSize, this);
        requestAnimationFrame(sched);
      };
      setTimeout(() => {
        sched();
      }, 100);
    }
    if (!this.opts.disablePointerEvents) this.#handleEvents();
    const resizeLogic = this.opts.resizeLogic ?? `none`;
    if (resizeLogic === `none`) this.setLogicalSize({
      width: this.opts.width,
      height: this.opts.height
    });
    else {
      const resizerOptions = {
        onSizeChanging: (size) => {
          if (isEqual$5(this.#logicalSize, size)) return;
          this.setLogicalSize(size);
        },
        onSizeDone: (size, el2) => {
          this.#onResizeDone(size);
        },
        containerEl: this.opts.containerEl,
        naturalSize: {
          width: this.opts.width,
          height: this.opts.height
        },
        stretch: this.opts.resizeLogic ?? `none`
      };
      this.#resizer = new ElementSizer(this.el, resizerOptions);
    }
    this.#getContext();
  }
  #onResizeDone(size) {
    if (this.opts.onResized) this.opts.onResized(this.ctx, this.size, this);
    this.fireEvent(`resized`, {
      ctx: this.ctx,
      size: this.#logicalSize,
      helper: this
    });
  }
  #handleEvents() {
    const handlePointerEvent = (event2) => {
      const { offsetX, offsetY } = event2;
      const physicalX = offsetX * this.ratio;
      const physicalY = offsetY * this.ratio;
      event2 = cloneFromFields(event2);
      const eventData = {
        physicalX,
        physicalY,
        ...event2
      };
      switch (event2.type) {
        case `pointerup`: {
          this.fireEvent(`pointerup`, eventData);
          break;
        }
        case `pointermove`: {
          this.fireEvent(`pointermove`, eventData);
          break;
        }
        case `pointerdown`: {
          this.fireEvent(`pointerup`, eventData);
          break;
        }
      }
    };
    this.el.addEventListener(`pointermove`, handlePointerEvent);
    this.el.addEventListener(`pointerdown`, handlePointerEvent);
    this.el.addEventListener(`pointerup`, handlePointerEvent);
  }
  /**
  * Clears the canvas.
  *
  * Shortcut for:
  * `ctx.clearRect(0, 0, this.width, this.height)`
  */
  clear() {
    if (!this.#ctx) return;
    this.#ctx.clearRect(0, 0, this.width, this.height);
  }
  /**
  * Fills the canvas with a given colour.
  *
  * Shortcut for:
  * ```js
  * ctx.fillStyle = ``;
  * ctx.fillRect(0, 0, this.width, this.height);
  * ```
  * @param colour Colour
  */
  fill(colour) {
    if (!this.#ctx) return;
    if (colour) this.#ctx.fillStyle = colour;
    this.#ctx.fillRect(0, 0, this.width, this.height);
  }
  /**
  * Gets the drawing context
  */
  get ctx() {
    if (this.#ctx === void 0) throw new Error(`Context not available`);
    return this.#getContext();
  }
  get viewport() {
    return this.#viewport;
  }
  /**
  * Gets the logical width of the canvas
  * See also: {@link height}, {@link size}
  */
  get width() {
    return this.#logicalSize.width;
  }
  /**
  * Gets the logical height of the canvas
  * See also: {@link width}, {@link size}
  */
  get height() {
    return this.#logicalSize.height;
  }
  /**
  * Gets the logical size of the canvas
  * See also: {@link width}, {@link height}
  */
  get size() {
    return this.#logicalSize;
  }
  /**
  * Gets the current scaling ratio being used
  * to compensate for high-DPI display
  */
  get ratio() {
    return window.devicePixelRatio || 1;
  }
  /**
  * Returns the width or height, whichever is smallest
  */
  get dimensionMin() {
    return Math.min(this.width, this.height);
  }
  /**
  * Returns the width or height, whichever is largest
  */
  get dimensionMax() {
    return Math.max(this.width, this.height);
  }
  drawBounds(strokeStyle = `green`) {
    const ctx = this.#getContext();
    rect(ctx, {
      x: 0,
      y: 0,
      width: this.width,
      height: this.height
    }, {
      crossed: true,
      strokeStyle,
      strokeWidth: 1
    });
    rect(ctx, this.#viewport, {
      crossed: true,
      strokeStyle: `silver`,
      strokeWidth: 3
    });
  }
  /**
  * Returns a Scaler that converts from absolute
  * to relative coordinates.
  * This is based on the canvas size.
  *
  * ```js
  * // Assuming a canvas of 800x500
  * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }
  * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }
  * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }
  * ```
  */
  get toRelative() {
    return this.#scaler.rel;
  }
  /**
  * Returns a scaler for points based on width & height
  */
  get toAbsoluteFixed() {
    return this.#scalerSize.abs;
  }
  /**
  * Returns a scaler for points based on width & height
  */
  get toRelativeFixed() {
    return this.#scalerSize.rel;
  }
  get logicalCenter() {
    return {
      x: this.#logicalSize.width / 2,
      y: this.#logicalSize.height / 2
    };
  }
  /**
  * Returns a Scaler that converts from relative to absolute
  * coordinates.
  * This is based on the canvas size.
  *
  * ```js
  * // Assuming a canvas of 800x600
  * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}
  * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}
  * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}
  * ```
  */
  get toAbsolute() {
    return this.#scaler.abs;
  }
  /**
  * Gets the center coordinate of the canvas
  */
  get center() {
    return {
      x: this.width / 2,
      y: this.height / 2
    };
  }
  /**
  * Gets the image data for the canvas.
  * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be
  * 536x536 with a high-DPI display.
  * @returns
  */
  getImageData() {
    const size = this.getPhysicalSize();
    const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });
    if (data === null || data === void 0) throw new Error(`Could not get image data from context`);
    return data;
  }
  /**
  * Returns the canvas frame data as a writable grid.
  * When editing, make as many edits as needed before calling
  * `flip`, which writes buffer back to the canvas.
  * ```js
  * const g = helper.getWritableBuffer();
  * // Get {r,g,b,opacity} of pixel 10,10
  * const pixel = g.get({ x: 10, y: 10 });
  *
  * // Set a colour to pixel 10,10
  * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });
  *
  * // Write buffer to canvas
  * g.flip();
  * ```
  *
  * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will
  * mean a higher number of rows and columns compared to the logical size.
  * @returns
  */
  getWritableBuffer() {
    const ctx = this.ctx;
    const data = this.getImageData();
    const grid$2 = grid$1(data);
    const get3 = accessor(data);
    const set5 = setter(data);
    const flip2 = () => {
      ctx.putImageData(data, 0, 0);
    };
    return {
      grid: grid$2,
      get: get3,
      set: set5,
      flip: flip2
    };
  }
};
var piPi3 = Math.PI * 2;
var CanvasSource = class {
  #canvasEl;
  #ctx;
  #sizeBasis;
  #sizeScaler;
  #logicalSize;
  #pixelScaling;
  #regions = [];
  constructor(canvasElementOrQuery, sizeBasis = `min`) {
    this.#canvasEl = resolveEl2(canvasElementOrQuery);
    this.#sizeBasis = sizeBasis;
    this.#pixelScaling = window.devicePixelRatio || 1;
    this.#sizeScaler = this.#createSizeScaler();
    this.#logicalSize = this.setLogicalSize({
      width: this.#canvasEl.width,
      height: this.#canvasEl.height
    });
  }
  /**
  * Set logical size for region
  * @param size
  * @returns
  */
  setLogicalSize(size) {
    this.#logicalSize = size;
    const el2 = this.#canvasEl;
    el2.width = size.width * this.#pixelScaling;
    el2.height = size.height * this.#pixelScaling;
    el2.style.width = `${size.width.toString()}px`;
    el2.style.height = `${size.height.toString()}px`;
    this.#sizeScaler = this.#createSizeScaler();
    this.invalidateContext();
    return size;
  }
  #createSizeScaler() {
    let inMax = 1;
    switch (this.#sizeBasis) {
      case `min`:
        inMax = Math.min(this.#canvasEl.width, this.#canvasEl.height);
        break;
      case `max`:
        inMax = Math.max(this.#canvasEl.width, this.#canvasEl.height);
        break;
    }
    const s3 = scalerTwoWay(0, inMax, 0, 1);
    return {
      abs: s3.in,
      rel: s3.out
    };
  }
  /**
  * Causes drawing context to be re-created
  */
  invalidateContext() {
    this.#ctx = void 0;
  }
  #add(region) {
    if (!region) throw new Error(`Param 'region' is undefined/null`);
    if (this.#regions.includes(region)) throw new Error(`Region already exists`);
    this.#regions.push(region);
    return region;
  }
  /**
  * Convert relative to absolute
  * @param pt
  * @param kind
  * @returns
  */
  toAbsPoint(pt2, kind = `independent`) {
    let { x: x3, y: y3 } = pt2;
    switch (kind) {
      case `independent`:
        x3 *= this.width;
        y3 *= this.height;
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Gets the offset x,y
  */
  get offset() {
    const b3 = this.#canvasEl.getBoundingClientRect();
    return {
      x: b3.left,
      y: b3.top
    };
  }
  /**
  * Converts an absolute point to relative
  * @param pt
  * @param source
  * @param kind
  * @param clamped
  * @returns
  */
  toRelPoint(pt2, source, kind = `independent`, clamped = true) {
    let { x: x3, y: y3 } = pt2;
    if (source === `screen`) {
      const b3 = this.#canvasEl.getBoundingClientRect();
      x3 -= b3.x;
      y3 -= b3.y;
    }
    switch (kind) {
      case `independent`:
        x3 /= this.width;
        y3 /= this.height;
        break;
      case `skip`:
        break;
    }
    if (clamped) {
      x3 = clamp(x3);
      y3 = clamp(y3);
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Converts a rectangle to absolute coordinates
  * @param rect
  * @param kind
  * @returns
  */
  toAbsRect(rect$1, kind = `independent`) {
    let { width, height: height3 } = rect$1;
    switch (kind) {
      case `independent`:
        width *= this.width;
        height3 *= this.height;
        if (isRectPositioned(rect$1)) return {
          ...this.toAbsPoint(rect$1),
          width,
          height: height3
        };
    }
    return {
      width,
      height: height3
    };
  }
  /**
  * Creates a region
  *
  * Absolute positioned. Uses source coordinates which don't change
  * ```js
  * source.createRegion({
  *  absPositioned: { x: 0, y: 0, width: 100, height: 100}
  * });
  * ```
  *
  * Relative positioned. Uses coordiantes relative to source dimensions.
  * Updated if source changes.
  * ```js
  * source.createRegion({
  *  relativePositioned: { x: 0, y:0, width: 1, height: 0.5 },
  *  scale: `independent`
  * });
  * ```
  *
  * Relative sized. Uses size relative to source dimension. By default centers.
  * ```js
  * source.createRegion({
  *  relativeSize: { width: 0.5, height: 0.5 }
  *  position: `center`
  * })
  * ```
  * @param spec
  * @returns
  */
  createRegion(spec) {
    const marginPx = spec.marginPx ?? 0;
    const marginPx2 = marginPx * 2;
    if (`absPositioned` in spec) {
      const rect$1 = subtractSize(spec.absPositioned, marginPx, marginPx);
      return this.#add(new CanvasRegion(this, () => rect$1));
    }
    if (`relativePositioned` in spec) {
      let compute;
      const rect$1 = spec.relativePositioned;
      switch (spec.scale) {
        case `independent`:
          compute = (source) => ({
            x: rect$1.x * source.width + marginPx,
            y: rect$1.y * source.height + marginPx,
            width: rect$1.width * source.width - marginPx2,
            height: rect$1.height * source.height - marginPx2
          });
          break;
        default:
          throw new Error(`Param 'kind' unknown (${spec.scale})`);
      }
      return this.#add(new CanvasRegion(this, compute));
    }
    if (`relativeSize` in spec) {
      let compute;
      const rect$1 = spec.relativeSize;
      const position = spec.position;
      switch (spec.scale) {
        case `independent`:
          compute = (source) => {
            const width = rect$1.width * source.width - marginPx2;
            const height3 = rect$1.height * source.height - marginPx2;
            let x3 = source.width / 2 - width / 2;
            let y3 = source.height / 2 - height3 / 2;
            switch (position) {
              case `n`:
                y3 = 0;
                break;
              case `s`:
                y3 = source.height - height3;
                break;
              default:
            }
            x3 += marginPx;
            y3 += marginPx;
            return {
              width,
              height: height3,
              x: x3,
              y: y3
            };
          };
          break;
        default:
          throw new Error(`Param 'kind' unknown (${spec.scale})`);
      }
      return this.#add(new CanvasRegion(this, compute));
    }
    if (`match` in spec) {
      const result = resolveElementTry(spec.match);
      if (!result.success) throw new Error(`Could not resolve match element. ${resultErrorToString(result)}`);
      const compute = (_source) => {
        const bounds = result.value.getBoundingClientRect();
        return {
          x: bounds.x + marginPx,
          y: bounds.y + marginPx,
          width: bounds.width - marginPx2,
          height: bounds.height - marginPx2
        };
      };
      return this.#add(new CanvasRegion(this, compute));
    }
    throw new Error(`Spec doesn't seem valid`);
  }
  /**
  * Clears the region of the canvas
  */
  clear() {
    const c5 = this.context;
    c5.clearRect(0, 0, this.width, this.height);
  }
  /**
  * Gets - or creates - the drawing context
  */
  get context() {
    if (this.#ctx) return this.#ctx;
    const c5 = this.#canvasEl.getContext(`2d`);
    if (!c5) throw new Error(`Could not create 2d context`);
    c5.setTransform(1, 0, 0, 1, 0, 0);
    c5.scale(this.#pixelScaling, this.#pixelScaling);
    this.#ctx = c5;
    for (const r5 of this.#regions) r5.recomputeRegion();
    return this.#ctx;
  }
  /**
  * Gets a scaler for size
  */
  get sizeScaler() {
    return this.#sizeScaler;
  }
  /**
  * Gets the logical width
  */
  get width() {
    return this.#logicalSize.width;
  }
  /**
  * Gets the logical height
  */
  get height() {
    return this.#logicalSize.height;
  }
};
var CanvasRegion = class {
  source;
  #regionCompute;
  #r;
  /**
  * Creates, using coordinate in canvas coordinates
  */
  constructor(source, regionCompute) {
    this.source = source;
    this.#regionCompute = regionCompute;
    this.#r = regionCompute(source);
  }
  /**
  * Calls the original `regionCompute` function passed in to the constructor
  * to recompute the absolute region
  */
  recomputeRegion() {
    this.#r = this.#regionCompute(this.source);
  }
  /**
  * Converts a region-relative point (0..1) to an absolute
  * point, which uses region-relative coordinates.
  *
  * Eg if the region had an x,y of 100,100, `toAbsRegion({x:0,y:0})`
  * will return 0,0.
  *
  * @param regionRel
  * @param scaleBy
  * @returns
  */
  toAbsRegion(regionRel, scaleBy = `both`) {
    switch (scaleBy) {
      case `both`:
        return {
          x: regionRel.x * this.#r.width,
          y: regionRel.y * this.#r.height
        };
    }
  }
  /**
  * Returns a copy of `p` offset by the region's x & y
  * @param p
  * @returns
  */
  applyRegionOffset(p3) {
    return {
      x: p3.x + this.#r.x,
      y: p3.y + this.#r.y
    };
  }
  /**
  * Draws a line from a series of points.
  * Assumes region-relative, % coordinates (ie 0..1 scale)
  * @param relativePoints Points to connect, in region-relative coordinates
  * @param strokeStyle Stroke style
  * @param lineWidth Line with
  */
  drawConnectedPointsRelative(relativePoints, strokeStyle, lineWidth = 1) {
    const points = relativePoints.map((p3) => this.toAbsRegion(p3));
    this.drawConnectedPoints(points, strokeStyle, lineWidth);
  }
  /**
  * Draws connected points in absolute coordinates,
  * however with 0,0 being the top-left of the region.
  *
  * Thus, this will apply the region offset before drawing.
  * @param points Points to draw
  * @param strokeStyle Stroke style
  * @param lineWidth Line width
  */
  drawConnectedPoints(points, strokeStyle, lineWidth = 1) {
    const c5 = this.context;
    c5.save();
    c5.translate(this.#r.x, this.#r.y);
    c5.beginPath();
    c5.strokeStyle = strokeStyle;
    c5.lineWidth = lineWidth;
    for (let index = 0; index < points.length; index++) if (index === 0) c5.moveTo(points[index].x, points[index].y);
    else c5.lineTo(points[index].x, points[index].y);
    c5.stroke();
    c5.restore();
  }
  /**
  * Fills text at a relative position
  * @param text
  * @param relPos Relative, meaning 0.5,0.5 is the middle of the region
  * @param fillStyle
  * @param baseline
  * @param align
  */
  fillTextRelative(text$1, relPos, fillStyle = `black`, font, baseline = `alphabetic`, align = `start`) {
    const point3 = this.toAbsRegion(relPos);
    this.fillTextRelative(text$1, point3, fillStyle, font, baseline, align);
  }
  /**
  * Fills text at a region-relative position
  * @param text
  * @param point Region relative, meaning 0,0 is top-left of region
  * @param fillStyle
  * @param baseline
  * @param align
  */
  fillText(text$1, point3, fillStyle = `black`, font, baseline = `alphabetic`, align = `start`) {
    const c5 = this.context;
    c5.save();
    c5.translate(this.#r.x, this.#r.y);
    if (font.length > 0) c5.font = font;
    c5.textBaseline = baseline;
    c5.textAlign = align;
    c5.fillStyle = fillStyle;
    c5.fillText(text$1, point3.x, point3.y);
    c5.restore();
  }
  drawCircles(relativeCircles, fillStyle, strokeStyle = ``, lineWidth = 1) {
    const circles = relativeCircles.map((c$1) => {
      return {
        ...this.toAbsRegion(c$1),
        radius: this.source.sizeScaler.abs(c$1.radius)
      };
    });
    const c5 = this.context;
    c5.save();
    c5.translate(this.#r.x, this.#r.y);
    c5.fillStyle = fillStyle;
    c5.strokeStyle = strokeStyle;
    c5.lineWidth = lineWidth;
    for (const circle$2 of circles) {
      c5.beginPath();
      c5.arc(circle$2.x, circle$2.y, circle$2.radius, 0, piPi3);
      c5.closePath();
      if (fillStyle.length > 0) c5.fill();
      if (strokeStyle.length > 0) c5.stroke();
    }
    c5.restore();
  }
  /**
  * Clears the region
  */
  clear() {
    const c5 = this.context;
    c5.clearRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);
  }
  /**
  * Fills the region
  * @param fillStyle
  */
  fill(fillStyle = `white`) {
    const c5 = this.context;
    c5.fillStyle = fillStyle;
    c5.fillRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);
  }
  /**
  * For debugging, draws an outline of the bounds
  * @param strokeStyle
  * @param lineWidth
  */
  drawBounds(strokeStyle, lineWidth = 1) {
    this.drawConnectedPointsRelative([
      {
        x: 0,
        y: 0
      },
      {
        x: 1,
        y: 0
      },
      {
        x: 1,
        y: 1
      },
      {
        x: 0,
        y: 1
      },
      {
        x: 0,
        y: 0
      }
    ], strokeStyle, lineWidth);
    this.drawConnectedPointsRelative([{
      x: 0,
      y: 1
    }, {
      x: 1,
      y: 0
    }], strokeStyle, lineWidth);
    this.drawConnectedPointsRelative([{
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 1
    }], strokeStyle, lineWidth);
  }
  /**
  * Converts a  point to a region-relative one.
  * @param pt
  * @param kind
  * @returns
  */
  toRelPoint(pt2, source = `screen`, kind = `independent`, clamped = true) {
    pt2 = this.source.toRelPoint(pt2, source, `skip`, false);
    let { x: x3, y: y3 } = pt2;
    x3 -= this.x;
    y3 -= this.y;
    switch (kind) {
      case `independent`:
        x3 /= this.width;
        y3 /= this.height;
    }
    if (clamped) {
      x3 = clamp(x3);
      y3 = clamp(y3);
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Converts absolute to region point
  * @param pt
  * @param source
  * @param clamped
  * @returns
  */
  absToRegionPoint(pt2, source, clamped) {
    if (source === `screen`) pt2 = subtract(pt2, this.source.offset);
    let { x: x3, y: y3 } = pt2;
    x3 -= this.x;
    y3 -= this.y;
    if (clamped) {
      if (x3 < 0) x3 = 0;
      if (y3 < 0) y3 = 0;
      if (x3 > this.width + this.x) x3 = this.x + this.width;
      if (y3 > this.height + this.y) y3 = this.y + this.height;
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Get center of region
  */
  get center() {
    return center$1(this.#r);
  }
  /**
  * Gets the drawing context
  */
  get context() {
    return this.source.context;
  }
  /**
  * SEts the region
  */
  set region(value3) {
    this.#r = value3;
  }
  /**
  * Gets the region
  */
  get region() {
    return this.#r;
  }
  /**
  * Gets the width
  */
  get width() {
    return this.#r.width;
  }
  /**
  * Gets the height
  */
  get height() {
    return this.#r.height;
  }
  /**
  * Gets the x offset
  */
  get x() {
    return this.#r.x;
  }
  /**
  * Gets they y offset
  */
  get y() {
    return this.#r.y;
  }
  /**
  * Gets the width/height, whichever is smaller
  */
  get dimensionMin() {
    return Math.min(this.#r.width, this.#r.height);
  }
};
var applyOpts = (elem, opts) => {
  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);
  if (opts.opacity) elem.setAttributeNS(null, `opacity`, opts.opacity.toString());
};
var getBounds = (svg) => {
  const w3 = svg.getAttributeNS(null, `width`);
  const width = w3 === null ? 0 : Number.parseFloat(w3);
  const h5 = svg.getAttributeNS(null, `height`);
  const height3 = h5 === null ? 0 : Number.parseFloat(h5);
  return {
    width,
    height: height3
  };
};
var setBounds = (svg, bounds) => {
  svg.setAttributeNS(null, `width`, bounds.width.toString());
  svg.setAttributeNS(null, `height`, bounds.height.toString());
};
var createEl = (type, id) => {
  const m4 = document.createElementNS(`http://www.w3.org/2000/svg`, type);
  if (id) m4.id = id;
  return m4;
};
var createOrResolve = (parent, type, queryOrExisting, suffix) => {
  let existing = null;
  if (queryOrExisting !== void 0) existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;
  if (existing === null) {
    const p3 = document.createElementNS(`http://www.w3.org/2000/svg`, type);
    parent.append(p3);
    if (queryOrExisting && typeof queryOrExisting === `string` && queryOrExisting.startsWith(`#`)) p3.id = suffix !== void 0 && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);
    return p3;
  }
  return existing;
};
var goldenAngleColour = (index, saturation = 0.5, lightness$1 = 0.75, alpha = 1) => {
  resultThrow(numberTest(index, `positive`, `index`), numberTest(saturation, `percentage`, `saturation`), numberTest(lightness$1, `percentage`, `lightness`), numberTest(alpha, `percentage`, `alpha`));
  const hueDeg = index * 137.508;
  const hueRel = hueDeg % 360 / 360;
  return toCssString(scalar(hueRel, saturation, lightness$1, alpha));
};
var randomHue = (rand = Math.random) => rand() * 360;
function multiplyOpacity(colourish, amount) {
  return withOpacity(colourish, (o5) => clamp(o5 * amount));
}
function withOpacity(colourish, fn2) {
  const colour = toColour(colourish);
  let result;
  switch (colour.space) {
    case `hsl`:
      result = withOpacity$3(colour, fn2);
      break;
    case `srgb`:
      result = withOpacity$1(colour, fn2);
      break;
    case `oklch`:
      result = withOpacity$2(colour, fn2);
      break;
    default:
      throw new Error(`Unknown space: '${colour.space}'. Expected hsl, srgb, oklch`);
  }
  if (!result) throw new Error(`Is colour in correct form?`);
  if (typeof colourish === `string`) return toCssColour(result);
  return result;
}
function setOpacity(colourish, opacity$1) {
  const colour = toColour(colourish);
  colour.opacity = opacity$1;
  if (typeof colourish === `string`) return toCssColour(colour);
  return colour;
}
function interpolateInit(colours, destination = `hsl`) {
  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${typeof colours}`);
  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${colours.length}`);
  const c5 = colours.map((colour) => convertScalar(colour, destination));
  return [...pairwise(c5)];
}
var cssLinearGradient = (colours) => {
  const c5 = colours.map((c$1) => toCssColour(c$1));
  return `linear-gradient(to right, ${c5.join(`, `)})`;
};
var interpolator2 = (colourA, colourB, options = {}) => {
  const space = options.space ?? `oklch`;
  const direction = options.direction ?? `shorter`;
  let inter;
  switch (space) {
    case `hsl`:
      inter = interpolator$3(convert(colourA, `hsl-scalar`), convert(colourB, `hsl-scalar`), direction);
      break;
    case `srgb`:
      inter = interpolator$1(convert(colourA, `srgb-scalar`), convert(colourB, `srgb-scalar`));
      break;
    default:
      inter = interpolator$2(convert(colourA, `oklch-scalar`), convert(colourB, `oklch-scalar`), direction);
  }
  return (amount) => toCssColour(inter(amount));
};
var scale2 = (colours, opts = {}) => {
  const direction = opts.direction ?? `shorter`;
  const space = opts.space ?? `oklch`;
  const pieces = interpolateInit(colours, space);
  let stepsBetween = 0;
  if (typeof opts.stepsBetween === `number`) {
    stepsBetween = opts.stepsBetween;
    if (stepsBetween < 1) throw new Error(`Param 'stepsBetween' must be at least 1`);
  } else if (typeof opts.stepsTotal === `number`) {
    if (opts.stepsTotal <= colours.length) throw new Error(`Param 'stepsTotal' must be greater than number of provided colour stops (${colours.length}) +1 per stop`);
    const totalSteps = opts.stepsTotal - colours.length;
    stepsBetween = Math.floor(totalSteps / pieces.length);
  }
  const steps = pieces.map((piece) => {
    const pieceSteps = createSteps(piece[0], piece[1], {
      steps: stepsBetween,
      space,
      direction,
      exclusive: true
    });
    pieceSteps.push(piece[1]);
    return pieceSteps;
  });
  const firstPiece = pieces[0];
  steps.unshift([firstPiece[0]]);
  return steps.flat().map((c5) => toCssColour(c5));
};
function createSteps(a3, b3, options = {}) {
  const exclusive = options.exclusive ?? false;
  const steps = options.steps ?? 5;
  const space = options.space ?? `oklch`;
  const direction = options.direction ?? `shorter`;
  if (!exclusive && steps < 2) throw new Error(`Param 'steps' should be at least 2 when 'exclusive' is false`);
  if (exclusive && steps < 1) throw new Error(`Param 'steps' should be at least 1 when 'exlusive' is true`);
  const aa2 = convertScalar(a3, space);
  const bb = convertScalar(b3, space);
  let inter;
  switch (space) {
    case `hsl`:
      inter = interpolator$3(aa2, bb, direction);
      break;
    case `oklch`:
      inter = interpolator$2(aa2, bb, direction);
      break;
    case `srgb`:
      inter = interpolator$1(aa2, bb);
      break;
    default:
      throw new Error(`Colour space '${space}' not supported for interpolation.`);
  }
  if (!inter) throw new Error(`Could not create interpolator for space: ${space}`);
  let stepBy = 0;
  let startAt = 0;
  let endAt = 1;
  if (exclusive) {
    stepBy = 1 / (steps + 1);
    startAt = stepBy;
    endAt = 1 - stepBy;
  } else stepBy = 1 / (steps - 1);
  const results = [];
  for (let interpolateAmount = startAt; interpolateAmount <= endAt; interpolateAmount += stepBy) results.push(inter(interpolateAmount));
  return results;
}
var colour_exports = {};
__export(colour_exports, {
  HslSpace: () => hsl_exports,
  OklchSpace: () => oklch_exports,
  SrgbSpace: () => srgb_exports,
  convert: () => convert,
  convertScalar: () => convertScalar,
  convertToString: () => convertToString,
  createSteps: () => createSteps,
  cssDefinedHexColours: () => cssDefinedHexColours,
  cssLinearGradient: () => cssLinearGradient,
  fromCssColour: () => fromCssColour,
  goldenAngleColour: () => goldenAngleColour,
  guard: () => guard$22,
  interpolator: () => interpolator2,
  isColourish: () => isColourish,
  isHsl: () => isHsl,
  isOkLch: () => isOkLch,
  isRgb: () => isRgb,
  multiplyOpacity: () => multiplyOpacity,
  randomHue: () => randomHue,
  resolveCss: () => resolveCss,
  rgbToHsl: () => rgbToHsl,
  scale: () => scale2,
  setOpacity: () => setOpacity,
  toColour: () => toColour,
  toCssColour: () => toCssColour,
  toHexColour: () => toHexColour,
  toLibraryColour: () => toLibraryColour,
  toStringFirst: () => toStringFirst,
  tryParseObjectToHsl: () => tryParseObjectToHsl,
  tryParseObjectToRgb: () => tryParseObjectToRgb,
  withOpacity: () => withOpacity
});
function convert(colour, destination) {
  if (destination === `hsl-scalar`) {
    if (typeof colour === `string` || isHsl(colour) || isRgb(colour)) return toScalar$2(colour);
  } else if (destination === `hsl-absolute`) {
    if (typeof colour === `string` || isHsl(colour)) return toAbsolute$1(colour);
  } else if (destination === `oklch-scalar`) {
    if (typeof colour === `string` || isOkLch(colour)) return toScalar$1(colour);
  } else if (destination === `oklch-absolute`) {
    if (typeof colour === `string` || isOkLch(colour)) return toAbsolute2(colour);
  } else if (destination === `srgb-8bit`) {
    if (typeof colour === `string` || isRgb(colour)) return to8bit(colour);
  } else if (destination === `srgb-scalar`) {
    if (typeof colour === `string` || isRgb(colour)) return toScalar2(colour);
  } else throw new Error(`Destination '${destination}' not supported for input: ${JSON.stringify(colour)}`);
  return convert(toCssColour(colour), destination);
}
function convertToString(colour, destination) {
  const c5 = convert(colour, destination);
  return toCssColour(c5);
}
function convertScalar(colour, destination) {
  if (destination === `oklch`) return convert(colour, `oklch-scalar`);
  if (destination === `srgb`) return convert(colour, `srgb-scalar`);
  if (destination === `hsl`) return convert(colour, `hsl-scalar`);
  throw new Error(`Unknown destination: '${destination}'`);
}
var toCssColour = (colour) => {
  if (typeof colour === `string`) return colour;
  if (isHsl(colour)) return toCssString(colour);
  if (isRgb(colour)) return toCssString$1(colour);
  if (isOkLch(colour)) return toCssString$2(colour);
  const asRgb = tryParseObjectToRgb(colour);
  if (asRgb) return toCssString$1(asRgb);
  const asHsl = tryParseObjectToHsl(colour);
  if (asHsl) return toCssString(asHsl);
  throw new Error(`Unknown colour format: '${JSON.stringify(colour)}'`);
};
var toHexColour = (colour) => {
  if (isHsl(colour)) return toHexString$2(colour);
  if (isRgb(colour)) return toHexString(colour);
  if (isOkLch(colour)) return toHexString$1(colour);
  if (typeof colour === `string`) {
    if (colour.startsWith(`#`)) return colour;
    const c5 = convert(colour, `srgb-8bit`);
    return toHexString(c5);
  }
  const asRgb = tryParseObjectToRgb(colour);
  if (asRgb) return toHexString(asRgb);
  const asHsl = tryParseObjectToHsl(colour);
  if (asHsl) return toHexString$2(asHsl);
  throw new Error(`Unknown colour format: '${JSON.stringify(colour)}'`);
};
var toLibraryColour = (colour) => {
  const asCss = toCssColour(colour);
  return new index_default(asCss);
};
var guard$22 = (colour) => {
  switch (colour.space) {
    case `hsl`:
      guard$52(colour);
      break;
    case `srgb`:
      guard$32(colour);
      break;
    case `oklch`:
      guard$42(colour);
      break;
    default:
      throw new Error(`Unsupported colour space: '${colour.space}'`);
  }
};
var toColour = (colourish) => {
  if (!isColourish(colourish)) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc. Got: ${JSON.stringify(colourish)}`);
  let c5;
  if (typeof colourish === `string`) c5 = fromCssColour(colourish);
  else c5 = colourish;
  if (c5 === void 0) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);
  guard$22(c5);
  return c5;
};
var toStringFirst = (...colours) => {
  for (const colour of colours) {
    if (colour === void 0) continue;
    if (colour === null) continue;
    try {
      const c5 = toColour(colour);
      return toCssColour(c5);
    } catch {
    }
  }
  return `rebeccapurple`;
};
function rgbToHsl(rgb, scalarResult) {
  let { r: r5, g: g4, b: b3 } = rgb;
  const opacity$1 = rgb.opacity ?? 1;
  if (rgb.unit === `8bit`) {
    r5 /= 255;
    g4 /= 255;
    b3 /= 255;
  }
  const max4 = Math.max(r5, g4, b3);
  const min4 = Math.min(r5, g4, b3);
  let h5 = (max4 + min4) / 2;
  let s3 = h5;
  const l3 = h5;
  if (max4 === min4) if (scalarResult) return scalar(0, 0, 0, opacity$1);
  else return absolute$1(0, 0, 0, opacity$1);
  const d3 = max4 - min4;
  s3 = l3 >= 0.5 ? d3 / (2 - (max4 + min4)) : d3 / (max4 + min4);
  switch (max4) {
    case r5:
      h5 = ((g4 - b3) / d3 + 0) * 60;
      break;
    case g4:
      h5 = ((b3 - r5) / d3 + 2) * 60;
      break;
    case b3:
      h5 = ((r5 - g4) / d3 + 4) * 60;
      break;
  }
  if (scalarResult) return scalar(h5 / 360, s3, l3, opacity$1);
  else return absolute$1(h5, s3 * 100, l3 * 100, opacity$1);
}
var applyStrokeOpts = (elem, opts) => {
  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);
  if (opts.strokeWidth) elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());
  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);
  if (opts.strokeLineCap) elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);
};
var createMarker = (id, opts, childCreator) => {
  const m4 = createEl(`marker`, id);
  if (opts.markerWidth) m4.setAttribute(`markerWidth`, opts.markerWidth?.toString());
  if (opts.markerHeight) m4.setAttribute(`markerHeight`, opts.markerHeight?.toString());
  if (opts.orient) m4.setAttribute(`orient`, opts.orient.toString());
  else m4.setAttribute(`orient`, `auto-start-reverse`);
  if (opts.viewBox) m4.setAttribute(`viewBox`, opts.viewBox.toString());
  if (opts.refX) m4.setAttribute(`refX`, opts.refX.toString());
  if (opts.refY) m4.setAttribute(`refY`, opts.refY.toString());
  if (childCreator) {
    const c5 = childCreator();
    m4.appendChild(c5);
  }
  return m4;
};
var markerPrebuilt = (elem, opts, _context) => {
  if (elem === null) return `(elem null)`;
  const parent = elem.ownerSVGElement;
  if (parent === null) throw new Error(`parent for elem is null`);
  const defsEl = createOrResolve(parent, `defs`, `defs`);
  let defEl = defsEl.querySelector(`#${opts.id}`);
  if (defEl !== null) return `url(#${opts.id})`;
  if (opts.id === `triangle`) {
    opts = {
      ...opts,
      strokeStyle: `transparent`
    };
    if (!opts.markerHeight) opts = {
      ...opts,
      markerHeight: 6
    };
    if (!opts.markerWidth) opts = {
      ...opts,
      markerWidth: 6
    };
    if (!opts.refX) opts = {
      ...opts,
      refX: opts.markerWidth
    };
    if (!opts.refY) opts = {
      ...opts,
      refY: opts.markerHeight
    };
    if (!opts.fillStyle || opts.fillStyle === `none`) opts = {
      ...opts,
      fillStyle: `black`
    };
    if (!opts.viewBox) opts = {
      ...opts,
      viewBox: `0 0 10 10`
    };
    defEl = createMarker(opts.id, opts, () => {
      const tri = createEl(`path`);
      tri.setAttribute(`d`, `M 0 0 L 10 5 L 0 10 z`);
      if (opts) applyOpts(tri, opts);
      return tri;
    });
  } else throw new Error(`Do not know how to make ${opts.id}`);
  defEl.id = opts.id;
  defsEl.appendChild(defEl);
  return `url(#${opts.id})`;
};
var applyPathOpts = (elem, opts) => {
  if (opts.markerEnd) elem.setAttribute(`marker-end`, markerPrebuilt(elem, opts.markerEnd, opts));
  if (opts.markerStart) elem.setAttribute(`marker-start`, markerPrebuilt(elem, opts.markerStart, opts));
  if (opts.markerMid) elem.setAttribute(`marker-mid`, markerPrebuilt(elem, opts.markerMid, opts));
};
var elements_exports = {};
__export(elements_exports, {
  circle: () => circle,
  circleUpdate: () => circleUpdate,
  grid: () => grid,
  group: () => group,
  groupUpdate: () => groupUpdate,
  line: () => line,
  lineUpdate: () => lineUpdate,
  path: () => path,
  pathUpdate: () => pathUpdate,
  polarRayUpdate: () => polarRayUpdate,
  text: () => text,
  textPath: () => textPath,
  textPathUpdate: () => textPathUpdate,
  textUpdate: () => textUpdate
});
var numberOrPercentage = (v3) => {
  if (v3 >= 0 && v3 <= 1) return `${v3 * 100}%`;
  return v3.toString();
};
var path = (svgOrArray, parent, opts, queryOrExisting) => {
  const elem = createOrResolve(parent, `path`, queryOrExisting);
  const svg = typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`
`);
  elem.setAttributeNS(null, `d`, svg);
  parent.append(elem);
  return pathUpdate(elem, opts);
};
var pathUpdate = (elem, opts) => {
  if (opts) applyOpts(elem, opts);
  if (opts) applyStrokeOpts(elem, opts);
  return elem;
};
var circleUpdate = (elem, circle$2, opts) => {
  elem.setAttributeNS(null, `cx`, circle$2.x.toString());
  elem.setAttributeNS(null, `cy`, circle$2.y.toString());
  elem.setAttributeNS(null, `r`, circle$2.radius.toString());
  if (opts) applyOpts(elem, opts);
  if (opts) applyStrokeOpts(elem, opts);
  return elem;
};
var circle = (circle$2, parent, opts, queryOrExisting) => {
  const p3 = createOrResolve(parent, `circle`, queryOrExisting);
  return circleUpdate(p3, circle$2, opts);
};
var group = (children3, parent, queryOrExisting) => {
  const p3 = createOrResolve(parent, `g`, queryOrExisting);
  return groupUpdate(p3, children3);
};
var groupUpdate = (elem, children3) => {
  for (const c5 of children3) if (c5.parentNode !== elem) elem.append(c5);
  return elem;
};
var line = (line$2, parent, opts, queryOrExisting) => {
  const lineEl = createOrResolve(parent, `line`, queryOrExisting);
  return lineUpdate(lineEl, line$2, opts);
};
var lineUpdate = (lineEl, line$2, opts) => {
  lineEl.setAttributeNS(null, `x1`, line$2.a.x.toString());
  lineEl.setAttributeNS(null, `y1`, line$2.a.y.toString());
  lineEl.setAttributeNS(null, `x2`, line$2.b.x.toString());
  lineEl.setAttributeNS(null, `y2`, line$2.b.y.toString());
  if (opts) applyOpts(lineEl, opts);
  if (opts) applyPathOpts(lineEl, opts);
  if (opts) applyStrokeOpts(lineEl, opts);
  return lineEl;
};
var polarRayUpdate = (lineEl, ray, opts) => {
  const l3 = toCartesian$2(ray);
  lineEl.setAttributeNS(null, `x1`, l3.a.x.toString());
  lineEl.setAttributeNS(null, `y1`, l3.a.y.toString());
  lineEl.setAttributeNS(null, `x2`, l3.b.x.toString());
  lineEl.setAttributeNS(null, `y2`, l3.b.y.toString());
  if (opts) applyOpts(lineEl, opts);
  if (opts) applyPathOpts(lineEl, opts);
  if (opts) applyStrokeOpts(lineEl, opts);
  return lineEl;
};
var textPathUpdate = (el2, text$1, opts) => {
  if (opts?.method) el2.setAttributeNS(null, `method`, opts.method);
  if (opts?.side) el2.setAttributeNS(null, `side`, opts.side);
  if (opts?.spacing) el2.setAttributeNS(null, `spacing`, opts.spacing);
  if (opts?.startOffset) el2.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));
  if (opts?.textLength) el2.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));
  if (text$1) el2.textContent = text$1;
  if (opts) applyOpts(el2, opts);
  if (opts) applyStrokeOpts(el2, opts);
  return el2;
};
var textPath = (pathReference, text$1, parent, opts, textQueryOrExisting, pathQueryOrExisting) => {
  const textEl = createOrResolve(parent, `text`, textQueryOrExisting, `-text`);
  textUpdate(textEl, void 0, void 0, opts);
  const p3 = createOrResolve(textEl, `textPath`, pathQueryOrExisting);
  p3.setAttributeNS(null, `href`, pathReference);
  return textPathUpdate(p3, text$1, opts);
};
var textUpdate = (el2, pos, text$1, opts) => {
  if (pos) {
    el2.setAttributeNS(null, `x`, pos.x.toString());
    el2.setAttributeNS(null, `y`, pos.y.toString());
  }
  if (text$1) el2.textContent = text$1;
  if (opts) {
    applyOpts(el2, opts);
    if (opts) applyStrokeOpts(el2, opts);
    if (opts.anchor) el2.setAttributeNS(null, `text-anchor`, opts.anchor);
    if (opts.align) el2.setAttributeNS(null, `alignment-baseline`, opts.align);
    const userSelect = opts.userSelect ?? true;
    if (!userSelect) el2.style.userSelect = `none`;
  }
  return el2;
};
var text = (text$1, parent, pos, opts, queryOrExisting) => {
  const p3 = createOrResolve(parent, `text`, queryOrExisting);
  return textUpdate(p3, pos, text$1, opts);
};
var grid = (parent, center$13, spacing, width, height3, opts = {}) => {
  if (!opts.strokeStyle) opts = {
    ...opts,
    strokeStyle: toStringFirst(`bg-dim`, `silver`)
  };
  if (!opts.strokeWidth) opts = {
    ...opts,
    strokeWidth: 1
  };
  const g4 = createEl(`g`);
  applyOpts(g4, opts);
  applyPathOpts(g4, opts);
  applyStrokeOpts(g4, opts);
  let y3 = 0;
  while (y3 < height3) {
    const horiz = fromNumbers$1(0, y3, width, y3);
    line(horiz, g4);
    y3 += spacing;
  }
  let x3 = 0;
  while (x3 < width) {
    const vert = fromNumbers$1(x3, 0, x3, height3);
    line(vert, g4);
    x3 += spacing;
  }
  parent.append(g4);
  return g4;
};
var lineFromSvgLine = (el2) => {
  if (!el2) throw new Error(`Param 'el' is undefined`);
  const a3 = {
    x: el2.x1.baseVal.value,
    y: el2.y1.baseVal.value
  };
  const b3 = {
    x: el2.x2.baseVal.value,
    y: el2.y2.baseVal.value
  };
  return {
    a: a3,
    b: b3
  };
};
var polarRayFromSvgLine = (el2, origin) => {
  const l3 = lineFromSvgLine(el2);
  return fromLine(l3, origin);
};
var remove4 = (parent, queryOrExisting) => {
  if (typeof queryOrExisting === `string`) {
    const elem = parent.querySelector(queryOrExisting);
    if (elem === null) return;
    elem.remove();
  } else queryOrExisting.remove();
};
var clear2 = (parent) => {
  let c5 = parent.lastElementChild;
  while (c5) {
    c5.remove();
    c5 = parent.lastElementChild;
  }
};
var makeHelper = (parent, parentOpts) => {
  if (parentOpts) {
    applyOpts(parent, parentOpts);
    applyStrokeOpts(parent, parentOpts);
  }
  const o5 = {
    remove: (queryOrExisting) => {
      remove4(parent, queryOrExisting);
    },
    text: (text$1, pos, opts, queryOrExisting) => text(text$1, parent, pos, opts, queryOrExisting),
    textPath: (pathReference, text$1, opts, textQueryOrExisting, pathQueryOrExisting) => textPath(pathReference, text$1, parent, opts, textQueryOrExisting, pathQueryOrExisting),
    line: (line$2, opts, queryOrExisting) => line(line$2, parent, opts, queryOrExisting),
    circle: (circle$2, opts, queryOrExisting) => circle(circle$2, parent, opts, queryOrExisting),
    path: (svgString, opts, queryOrExisting) => path(svgString, parent, opts, queryOrExisting),
    grid: (center$13, spacing, width, height3, opts) => grid(parent, center$13, spacing, width, height3, opts),
    query: (selectors) => parent.querySelector(selectors),
    get width() {
      const w3 = parent.getAttributeNS(null, `width`);
      if (w3 === null) return 0;
      return Number.parseFloat(w3);
    },
    set width(width) {
      parent.setAttributeNS(null, `width`, width.toString());
    },
    get parent() {
      return parent;
    },
    get height() {
      const w3 = parent.getAttributeNS(null, `height`);
      if (w3 === null) return 0;
      return Number.parseFloat(w3);
    },
    set height(height3) {
      parent.setAttributeNS(null, `height`, height3.toString());
    },
    clear: () => {
      while (parent.firstChild) parent.lastChild.remove();
    }
  };
  return o5;
};
var svg_exports = {};
__export(svg_exports, {
  Elements: () => elements_exports,
  applyOpts: () => applyOpts,
  applyPathOpts: () => applyPathOpts,
  applyStrokeOpts: () => applyStrokeOpts,
  clear: () => clear2,
  createEl: () => createEl,
  createMarker: () => createMarker,
  createOrResolve: () => createOrResolve,
  getBounds: () => getBounds,
  lineFromSvgLine: () => lineFromSvgLine,
  makeHelper: () => makeHelper,
  markerPrebuilt: () => markerPrebuilt,
  polarRayFromSvgLine: () => polarRayFromSvgLine,
  remove: () => remove4,
  setBounds: () => setBounds
});
var pointerVisualise = (elOrQuery, options = {}) => {
  const touchRadius = options.touchRadius ?? 45;
  const mouseRadius = options.touchRadius ?? 20;
  const trace = options.trace ?? false;
  const hue = options.hue ?? 100;
  const startFillStyle = `hsla(${hue}, 100%, 10%, 10%)`;
  let currentHue = hue;
  const el2 = resolveEl2(elOrQuery);
  const tracker = new PointsTracker({ storeIntermediate: trace });
  const svg = document.createElementNS(`http://www.w3.org/2000/svg`, `svg`);
  svg.id = `pointerVis`;
  svg.style.zIndex = `-1000`;
  svg.style.position = `fixed`;
  svg.style.top = `0`;
  svg.style.left = `0`;
  svg.style.width = `100%`;
  svg.style.height = `100%`;
  svg.style.boxSizing = `border-box`;
  svg.style.border = `3px solid red`;
  svg.style.pointerEvents = `none`;
  svg.style.touchAction = `none`;
  const er2 = ElementSizer.svgViewport(svg);
  let pointerCount = 0;
  const lostPointer = (event2) => {
    const id = event2.pointerId.toString();
    tracker.delete(id);
    currentHue = hue;
    svg.querySelector(`#pv-start-${id}`)?.remove();
    for (let index = 0; index < pointerCount + 10; index++) svg.querySelector(`#pv-progress-${id}-${index}`)?.remove();
    pointerCount = 0;
  };
  const trackPointer = async (event2) => {
    const id = event2.pointerId.toString();
    const pt2 = {
      x: event2.x,
      y: event2.y
    };
    const type = event2.pointerType;
    if (event2.type === `pointermove` && !tracker.has(id)) return;
    const info = await tracker.seen(event2.pointerId.toString(), {
      x: event2.clientX,
      y: event2.clientY
    });
    if (info.values.length === 1) {
      const el$1 = circle({
        ...info.values[0],
        radius: type === `touch` ? touchRadius : mouseRadius
      }, svg, { fillStyle: startFillStyle }, `#pv-start-${id}`);
      el$1.style.pointerEvents = `none`;
      el$1.style.touchAction = `none`;
    }
    const fillStyle = `hsla(${currentHue}, 100%, 50%, 50%)`;
    const el22 = circle({
      ...pt2,
      radius: type === `touch` ? touchRadius : mouseRadius
    }, svg, { fillStyle }, `#pv-progress-${id}-${info.values.length}`);
    el22.style.pointerEvents = `none`;
    el22.style.touchAction = `none`;
    currentHue += 1;
    pointerCount = info.values.length;
  };
  document.body.append(svg);
  el2.addEventListener(`pointerdown`, trackPointer);
  el2.addEventListener(`pointermove`, trackPointer);
  el2.addEventListener(`pointerup`, lostPointer);
  el2.addEventListener(`pointerleave`, lostPointer);
  el2.addEventListener(`contextmenu`, (event2) => {
    event2.preventDefault();
  });
};
var convolve_2d_exports = {};
__export(convolve_2d_exports, {
  boxBlurKernel: () => boxBlurKernel,
  convolve: () => convolve,
  convolveCell: () => convolveCell,
  convolveImage: () => convolveImage,
  edgeDetectionKernel: () => edgeDetectionKernel,
  gaussianBlur3Kernel: () => gaussianBlur3Kernel,
  gaussianBlur5Kernel: () => gaussianBlur5Kernel,
  identityKernel: () => identityKernel,
  kernel2dToArray: () => kernel2dToArray,
  multiply: () => multiply2,
  rgbReducer: () => rgbReducer,
  sharpenKernel: () => sharpenKernel,
  unsharpMasking5Kernel: () => unsharpMasking5Kernel
});
var multiply2 = (kernel, scalar$3) => {
  const rows$1 = kernel.length;
  const cols = kernel[0].length;
  const copy = [];
  for (let row = 0; row < rows$1; row++) {
    copy[row] = [];
    for (let col = 0; col < cols; col++) copy[row][col] = kernel[row][col] * scalar$3;
  }
  return copy;
};
function convolveCell(cell, kernel, source, reduce4) {
  const valuesAtKernelPos = kernel.map((o5) => {
    const pos = offset(source, cell, o5.cell, `stop`);
    let kernelValue;
    let sourceValue;
    if (pos) {
      sourceValue = source.get(pos, `undefined`);
      kernelValue = o5.value;
    }
    return {
      cell: o5.cell,
      value: sourceValue,
      kernel: o5.value
    };
  });
  return reduce4(valuesAtKernelPos);
}
function* convolveImage(kernel, image) {
  const imageDataAsGrid = wrap5(image);
  yield* convolve(kernel, imageDataAsGrid, cells(imageDataAsGrid), rgbReducer);
}
function* convolve(kernel, source, visitor, reduce4, origin) {
  if (!origin) {
    const kernelRows = kernel.length;
    const kernelCols = kernel[0].length;
    origin = {
      x: Math.floor(kernelRows / 2),
      y: Math.floor(kernelCols / 2)
    };
  }
  const asArray2 = kernel2dToArray(kernel, origin);
  for (const cell of visitor) {
    const value3 = convolveCell(cell, asArray2, source, reduce4);
    yield {
      cell,
      value: value3
    };
  }
}
var kernel2dToArray = (kernel, origin) => {
  const offsets = [];
  const rows$1 = kernel.length;
  const cols = kernel[0].length;
  if (!origin) origin = {
    x: Math.floor(rows$1 / 2),
    y: Math.floor(cols / 2)
  };
  for (let xx = 0; xx < rows$1; xx++) for (let yy = 0; yy < cols; yy++) {
    const v3 = {
      cell: {
        x: xx - origin.x,
        y: yy - origin.y
      },
      value: kernel[xx][yy]
    };
    offsets.push(v3);
  }
  return offsets;
};
var rgbReducer = (values3) => {
  let r5 = 0;
  let g4 = 0;
  let b3 = 0;
  let opacity$1 = 0;
  for (const value3 of values3) {
    const rgb = value3.value;
    const kernelValue = value3.kernel;
    if (!rgb) continue;
    if (rgb.opacity === 0) continue;
    if (kernelValue === 0) continue;
    r5 += rgb.r * kernelValue;
    g4 += rgb.g * kernelValue;
    b3 += rgb.b * kernelValue;
    opacity$1 += (rgb.opacity ?? 1) * kernelValue;
  }
  const result = {
    r: r5,
    g: g4,
    b: b3,
    unit: `8bit`,
    space: `srgb`,
    opacity: opacity$1
  };
  return result;
};
var identityKernel = [
  [
    0,
    0,
    0
  ],
  [
    0,
    1,
    0
  ],
  [
    0,
    0,
    0
  ]
];
var edgeDetectionKernel = [
  [
    0,
    -1,
    0
  ],
  [
    -1,
    4,
    -1
  ],
  [
    0,
    -1,
    0
  ]
];
var sharpenKernel = [
  [
    0,
    -1,
    0
  ],
  [
    -1,
    5,
    -1
  ],
  [
    0,
    -1,
    0
  ]
];
var boxBlurKernel = multiply2([
  [
    1,
    1,
    1
  ],
  [
    1,
    1,
    1
  ],
  [
    1,
    1,
    1
  ]
], 1 / 9);
var gaussianBlur3Kernel = multiply2([
  [
    1,
    2,
    1
  ],
  [
    2,
    4,
    2
  ],
  [
    1,
    2,
    1
  ]
], 1 / 16);
var gaussianBlur5Kernel = multiply2([
  [
    1,
    4,
    6,
    4,
    1
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    6,
    24,
    36,
    24,
    6
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    1,
    4,
    6,
    4,
    1
  ]
], 1 / 256);
var unsharpMasking5Kernel = multiply2([
  [
    1,
    4,
    6,
    4,
    1
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    6,
    24,
    -476,
    24,
    6
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    1,
    4,
    6,
    4,
    1
  ]
], -1 / 256);
var named_colour_palette_exports = {};
__export(named_colour_palette_exports, { create: () => create4 });
var create4 = (fallbacks) => new NamedColourPaletteImpl(fallbacks);
var NamedColourPaletteImpl = class {
  #store = /* @__PURE__ */ new Map();
  #aliases = /* @__PURE__ */ new Map();
  fallbacks;
  #lastFallback = 0;
  #elementBase;
  constructor(fallbacks) {
    if (fallbacks !== void 0) this.fallbacks = fallbacks;
    else this.fallbacks = [
      `red`,
      `blue`,
      `green`,
      `orange`
    ];
    this.#elementBase = document.body;
  }
  setElementBase(el2) {
    this.#elementBase = el2;
  }
  add(key, colour) {
    this.#store.set(key, colour);
  }
  alias(from3, to3) {
    this.#aliases.set(from3, to3);
  }
  get(key, fallback) {
    const alias = this.#aliases.get(key);
    if (alias !== void 0) key = alias;
    const c5 = this.#store.get(key);
    if (c5 !== void 0) return c5;
    const variableName = `--` + key;
    let fromCss$3 = getComputedStyle(this.#elementBase).getPropertyValue(variableName).trim();
    if (fromCss$3 === void 0 || fromCss$3.length === 0) {
      if (fallback !== void 0) return fallback;
      fromCss$3 = this.fallbacks[this.#lastFallback];
      this.#lastFallback++;
      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;
    }
    return fromCss$3;
  }
  getOrAdd(key, fallback) {
    if (this.has(key)) return this.get(key);
    const c5 = this.get(key, fallback);
    this.add(key, c5);
    return c5;
  }
  has(key) {
    return this.#store.has(key);
  }
};
var video_exports = {};
__export(video_exports, {
  capture: () => capture,
  frames: () => frames,
  manualCapture: () => manualCapture
});
async function* frames(sourceVideoEl, opts = {}) {
  const maxIntervalMs = opts.maxIntervalMs ?? 0;
  const showCanvas = opts.showCanvas ?? false;
  let canvasEl = opts.canvasEl;
  let w3, h5;
  w3 = h5 = 0;
  if (canvasEl === void 0) {
    canvasEl = document.createElement(`CANVAS`);
    canvasEl.classList.add(`ixfx-frames`);
    if (!showCanvas) canvasEl.style.display = `none`;
    document.body.appendChild(canvasEl);
  }
  const updateSize = () => {
    if (canvasEl === void 0) return;
    w3 = sourceVideoEl.videoWidth;
    h5 = sourceVideoEl.videoHeight;
    canvasEl.width = w3;
    canvasEl.height = h5;
  };
  let c5 = null;
  const looper = delayLoop(maxIntervalMs);
  for await (const _3 of looper) {
    if (w3 === 0 || h5 === 0) updateSize();
    if (w3 === 0 || h5 === 0) continue;
    c5 ??= canvasEl.getContext(`2d`);
    if (c5 === null) return;
    c5.drawImage(sourceVideoEl, 0, 0, w3, h5);
    const pixels = c5.getImageData(0, 0, w3, h5);
    yield pixels;
  }
}
var capture = (sourceVideoEl, opts = {}) => {
  const maxIntervalMs = opts.maxIntervalMs ?? 0;
  const showCanvas = opts.showCanvas ?? false;
  const onFrame = opts.onFrame;
  const w3 = sourceVideoEl.videoWidth;
  const h5 = sourceVideoEl.videoHeight;
  const canvasEl = document.createElement(`CANVAS`);
  canvasEl.classList.add(`ixfx-capture`);
  if (!showCanvas) canvasEl.style.display = `none`;
  canvasEl.width = w3;
  canvasEl.height = h5;
  let c5 = null;
  let worker;
  if (opts.workerScript) worker = new Worker(opts.workerScript);
  const getPixels = worker || onFrame;
  if (!getPixels && !showCanvas) console.warn(`Video will be captured to hidden element without any processing. Is this what you want?`);
  const loop = continuously(() => {
    if (c5 === null) c5 = canvasEl.getContext(`2d`);
    if (c5 === null) return;
    c5.drawImage(sourceVideoEl, 0, 0, w3, h5);
    let pixels;
    if (getPixels) pixels = c5.getImageData(0, 0, w3, h5);
    if (worker) worker.postMessage({
      pixels: pixels.data.buffer,
      width: w3,
      height: h5,
      channels: 4
    }, [pixels.data.buffer]);
    if (onFrame) try {
      onFrame(pixels);
    } catch (e5) {
      console.error(e5);
    }
  }, maxIntervalMs);
  return {
    start: () => {
      loop.start();
    },
    cancel: () => {
      loop.cancel();
    },
    canvasEl
  };
};
var manualCapture = (sourceVideoEl, opts = {}) => {
  const showCanvas = opts.showCanvas ?? false;
  const w3 = sourceVideoEl.videoWidth;
  const h5 = sourceVideoEl.videoHeight;
  const definedCanvasEl = opts.canvasEl !== void 0;
  let canvasEl = opts.canvasEl;
  if (!canvasEl) {
    canvasEl = document.createElement(`CANVAS`);
    canvasEl.classList.add(`ixfx-capture`);
    document.body.append(canvasEl);
    if (!showCanvas) canvasEl.style.display = `none`;
  }
  canvasEl.width = w3;
  canvasEl.height = h5;
  const capture$1 = () => {
    let c$1;
    if (!c$1) c$1 = canvasEl.getContext(`2d`, { willReadFrequently: true });
    if (!c$1) throw new Error(`Could not create graphics context`);
    c$1.drawImage(sourceVideoEl, 0, 0, w3, h5);
    const pixels = c$1.getImageData(0, 0, w3, h5);
    pixels.currentTime = sourceVideoEl.currentTime;
    if (opts.postCaptureDraw) opts.postCaptureDraw(c$1, w3, h5);
    return pixels;
  };
  const dispose = () => {
    if (definedCanvasEl) return;
    try {
      canvasEl.remove();
    } catch (_3) {
    }
  };
  const c5 = {
    canvasEl,
    capture: capture$1,
    dispose
  };
  return c5;
};
var bipolar_view_exports = {};
__export(bipolar_view_exports, { init: () => init3 });
function getNumericAttribute(el2, name, defaultValue) {
  const a3 = el2.getAttribute(name);
  if (a3 === null) return defaultValue;
  return Number.parseInt(a3);
}
var init3 = (elementQuery, options = {}) => {
  const element = document.querySelector(elementQuery);
  if (!element) throw new Error(`Element query could not be found (${elementQuery})`);
  const labels = options.labels ?? [`x`, `y`];
  const labelPrecision = options.labelPrecision ?? 2;
  const asPercentages = options.asPercentages ?? false;
  const displayLastValues = options.displayLastValues ?? 0;
  const showWhiskers = options.showWhiskers ?? true;
  const showDot = options.showDot ?? true;
  const showLabels = options.showLabels ?? true;
  const yAxisBottomNegative = options.yAxisBottomNegative ?? true;
  const axisColour = toStringFirst(options.axisColour, `silver`);
  const bgColour = toStringFirst(options.bgColour, `white`);
  const whiskerColour = toStringFirst(options.whiskerColour, `black`);
  const dotColour = toStringFirst(options.dotColour, options.whiskerColour, `black`);
  const labelColour = toStringFirst(options.labelColour, options.axisColour, `silver`);
  const axisWidth = options.axisWidth ?? 1 * window.devicePixelRatio;
  const dotRadius = options.dotRadius ?? 5 * window.devicePixelRatio;
  const pad = options.padding ?? 10 * window.devicePixelRatio;
  const whiskerSize = options.whiskerSize ?? 5 * window.devicePixelRatio;
  const width = options.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio;
  const height3 = options.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio;
  let lastValues;
  if (displayLastValues > 0) lastValues = new QueueImmutable3({
    capacity: displayLastValues,
    discardPolicy: `older`
  });
  element.width = width;
  element.height = height3;
  element.style.width = `${width / window.devicePixelRatio}px`;
  element.style.height = `${height3 / window.devicePixelRatio}px`;
  const midY = height3 / 2;
  const midX = width / 2;
  const ctx = element.getContext(`2d`);
  if (!ctx) throw new Error(`Could not create drawing context`);
  if (window.devicePixelRatio >= 2) ctx.font = `20px sans-serif`;
  const percentageFormat = (v3) => `${Math.round(v3 * 100)}%`;
  const fixedFormat = (v3) => v3.toFixed(labelPrecision);
  const valueFormat = asPercentages ? percentageFormat : fixedFormat;
  if (showLabels) {
    labels[0] = labels[0] + `:`;
    labels[1] = labels[1] + `:`;
  } else {
    labels[0] = ``;
    labels[1] = ``;
  }
  const renderBackground = options.renderBackground ?? ((ctx$1, width$1, height$13) => {
    if (options.bgColour === `transparent`) ctx$1.clearRect(0, 0, width$1, height$13);
    else {
      ctx$1.fillStyle = bgColour;
      ctx$1.fillRect(0, 0, width$1, height$13);
    }
  });
  return (x3, y3) => {
    x3 = clamp$1(x3);
    y3 = clamp$1(y3);
    renderBackground(ctx, width, height3);
    ctx.fillStyle = labelColour;
    ctx.textBaseline = `top`;
    ctx.save();
    ctx.translate(midX, midY);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText((labels[1] + ` ` + valueFormat(y3)).trim(), -midX + pad, 1);
    ctx.restore();
    ctx.fillText((labels[0] + ` ` + valueFormat(x3)).trim(), pad, midX + 2);
    if (!yAxisBottomNegative) y3 *= -1;
    ctx.strokeStyle = axisColour;
    ctx.lineWidth = axisWidth;
    ctx.beginPath();
    ctx.moveTo(pad, midY);
    ctx.lineTo(width - pad, midY);
    ctx.moveTo(midX, pad);
    ctx.lineTo(midX, height3 - pad);
    ctx.stroke();
    ctx.closePath();
    const yy = (height3 - pad - pad) / 2 * -y3;
    const xx = (width - pad - pad) / 2 * x3;
    const dotPos = {
      x: xx,
      y: yy,
      radius: dotRadius
    };
    if (lastValues) lastValues = lastValues.enqueue(dotPos);
    ctx.save();
    ctx.translate(midX, midY);
    if (showDot) if (lastValues) {
      const opacityStep = 1 / lastValues.length;
      let opacity$1 = 1;
      lastValues.forEach((d3) => {
        const colour = multiplyOpacity(dotColour, opacity$1);
        circle$1(ctx, d3, { fillStyle: colour });
        opacity$1 -= opacityStep;
      });
    } else circle$1(ctx, dotPos, { fillStyle: dotColour });
    if (showWhiskers) {
      ctx.strokeStyle = whiskerColour;
      ctx.beginPath();
      ctx.moveTo(0, yy - whiskerSize);
      ctx.lineTo(0, yy + whiskerSize);
      ctx.moveTo(xx - whiskerSize, 0);
      ctx.lineTo(xx + whiskerSize, 0);
      ctx.stroke();
      ctx.closePath();
    }
    ctx.restore();
  };
};
var computeMinMax = (mm) => {
  const x3 = mm.map((m4) => m4.x);
  const y3 = mm.map((m4) => m4.y);
  const minX = Math.min(...x3);
  const maxX = Math.max(...x3);
  const minY = Math.min(...y3);
  const maxY = Math.max(...y3);
  const width = maxX - minX;
  const height3 = maxY - minY;
  return {
    min: {
      x: minX,
      y: minY
    },
    max: {
      x: maxX,
      y: maxY
    },
    width,
    height: height3,
    minDim: Math.min(width, height3),
    maxDim: Math.max(width, height3)
  };
};
var relativeCompute = (minMax) => {
  if (!Number.isFinite(minMax.height)) return (point3) => point3;
  const xScale = scaler(minMax.min.x, minMax.max.x);
  const yScale = scaler(minMax.min.y, minMax.max.y);
  return (point3) => ({
    x: xScale(point3.x),
    y: yScale(point3.y)
  });
};
var absoluteCompute = (minMax) => {
  const xScale = scaler(0, 1, minMax.min.x, minMax.max.x);
  const yScale = scaler(0, 1, minMax.min.y, minMax.max.y);
  return (point3) => ({
    x: xScale(point3.x),
    y: yScale(point3.y)
  });
};
var computeAxisMark = (mm, increments, major) => {
  const xValues = [];
  let count3 = 0;
  for (let x3 = mm.min.x; x3 < mm.max.x; x3 += increments) {
    const isMajor = count3 % major === 0;
    xValues.push({
      x: x3,
      y: 0,
      major: isMajor
    });
    count3++;
  }
  count3 = 0;
  const yValues = [];
  for (let y3 = mm.min.y; y3 < mm.max.y; y3 += increments) {
    const isMajor = count3 % major === 0;
    yValues.push({
      x: 0,
      y: y3,
      major: isMajor
    });
    count3++;
  }
  return {
    x: xValues,
    y: yValues
  };
};
var DataSet = class {
  #data;
  #meta;
  lastChange;
  constructor() {
    this.lastChange = performance.now();
    this.#data = new MapOfSimpleMutable2();
    this.#meta = /* @__PURE__ */ new Map();
  }
  get metaCount() {
    return this.#meta.size;
  }
  clear() {
    this.#data.clear();
    this.lastChange = performance.now();
  }
  set(series, data) {
    this.#data.setValues(series, data);
  }
  deleteBySeries(series) {
    const changed = this.#data.delete(series);
    if (changed) this.lastChange = performance.now();
    return changed;
  }
  setMeta(series, meta) {
    this.#meta.set(series, meta);
  }
  hasMeta(series) {
    return this.#meta.has(series);
  }
  getMeta(series) {
    return this.#meta.get(series);
  }
  *getValues() {
    yield* this.#data.valuesFlat();
  }
  *getEntries() {
    yield* this.#data.entries();
  }
  *getSeries() {
    yield* this.#data.values();
  }
  add(value3, series = `default`) {
    this.#data.addKeyedValues(series, value3);
    this.lastChange = performance.now();
  }
};
var insert = (insertOptions, options = {}) => {
  const parentEl = insertOptions.parent === void 0 ? document.body : resolveEl2(insertOptions.parent);
  const canvasEl = document.createElement(`canvas`);
  parentEl.prepend(canvasEl);
  const ds2 = new DataSet();
  const source = new CanvasSource(canvasEl, `min`);
  const spec = insertOptions.region ?? { relativePositioned: {
    x: 0,
    y: 0,
    width: 1,
    height: 1
  } };
  const region = source.createRegion(spec);
  const p3 = new CartesianCanvasPlot(region, ds2, options);
  if (insertOptions.canvasResizeTo === `viewport`) ElementSizer.canvasViewport(canvasEl, { onSizeChanging: (size, _el) => {
    source.setLogicalSize(size);
    p3.invalidateRange();
    p3.draw();
  } });
  else ElementSizer.canvasParent(canvasEl, { onSizeChanging: (size, _el) => {
    source.setLogicalSize(size);
    p3.invalidateRange();
    p3.draw();
  } });
  return p3;
};
var CartesianCanvasPlot = class {
  #data;
  #lastDataChange;
  #canvasRegion;
  actualDataRange = EmptyPositioned;
  visibleRange = PlaceholderPositioned;
  show;
  whiskerLength;
  axisRounder = round2(1, true);
  onInvalidated;
  /**
  * List of lines to draw after drawing everything else.
  * Lines are given in value-coordinate space
  */
  overlayLines = [];
  #grid;
  #rangeMode;
  #currentRange;
  #axisStyle;
  #valueStyle;
  #connectStyle;
  #rangeManual;
  #textStyle;
  #visualPadding;
  #visualClear;
  constructor(cr2, data, options = {}) {
    if (!data) throw new TypeError(`Param 'data' is undefined`);
    if (typeof data !== `object`) throw new TypeError(`Param 'data' is not an object. Got: ${typeof data}`);
    this.onInvalidated = options.onInvalidated;
    this.#data = data;
    this.#canvasRegion = cr2;
    this.#lastDataChange = 0;
    this.#visualClear = options.clear ?? `region`;
    this.#rangeMode = options.range ?? `auto`;
    this.#valueStyle = options.valueStyle ?? `dot`;
    this.#connectStyle = options.connectStyle ?? ``;
    this.whiskerLength = options.whiskerLength ?? 5;
    this.#visualPadding = options.visualPadding ?? 20;
    this.show = {
      axes: true,
      axisValues: true,
      grid: true,
      whiskers: true,
      ...options.show
    };
    this.#axisStyle = {
      colour: `black`,
      width: 2,
      ...options.axisStyle
    };
    this.#textStyle = {
      colour: `black`,
      size: `1em`,
      font: `system-ui`,
      ...options.textStyle
    };
    this.#grid = {
      increments: 0.1,
      major: 5,
      colour: `whitesmoke`,
      width: 1,
      ...options.grid
    };
  }
  getCurrentRange() {
    if (this.#data.lastChange === this.#lastDataChange && this.#currentRange) return this.#currentRange;
    this.#lastDataChange = this.#data.lastChange;
    const r5 = this.#createRange();
    this.#currentRange = r5;
    if (this.onInvalidated) this.onInvalidated();
    return r5;
  }
  invalidateRange() {
    this.#currentRange = void 0;
  }
  #createRange() {
    const range = this.getDataRange();
    const absDataToRelative = relativeCompute(range);
    const relDataToAbs = absoluteCompute(range);
    const cr2 = this.#canvasRegion;
    const padding2 = this.#visualPadding;
    let xOffset = cr2.x + padding2;
    let yOffset = cr2.y + padding2;
    const allowedHeight = cr2.height - padding2 * 2;
    const allowedWidth = cr2.width - padding2 * 2;
    const dimensionMin = Math.min(allowedHeight, allowedWidth);
    if (allowedWidth >= allowedHeight) xOffset += allowedWidth / 2 - dimensionMin / 2;
    else yOffset += allowedHeight / 2 - dimensionMin / 2;
    const relDataToCanvas = (pt2) => {
      let { x: x3, y: y3 } = pt2;
      if (x3 === Number.NEGATIVE_INFINITY) x3 = 0;
      else if (x3 === Number.POSITIVE_INFINITY) x3 = 1;
      if (y3 === Number.NEGATIVE_INFINITY) y3 = 0;
      else if (y3 === Number.POSITIVE_INFINITY) y3 = 1;
      x3 = x3 * dimensionMin;
      y3 = (1 - y3) * dimensionMin;
      x3 += xOffset;
      y3 += yOffset;
      return {
        x: x3,
        y: y3
      };
    };
    const canvasToRelData = (pt2) => {
      let { x: x3, y: y3 } = pt2;
      x3 -= xOffset;
      y3 -= yOffset;
      x3 = x3 / dimensionMin;
      y3 = 1 - y3 / dimensionMin;
      return {
        x: x3,
        y: y3
      };
    };
    const regionSpaceToRelative = (pt2) => {
      let { x: x3, y: y3 } = pt2;
      x3 = x3 - cr2.x + this.#visualPadding;
      y3 = dimensionMin + this.#visualPadding - y3;
      x3 /= dimensionMin;
      y3 = y3 / dimensionMin;
      return {
        x: x3,
        y: y3
      };
    };
    return {
      absDataToRelative,
      relDataToCanvas,
      canvasToRelData,
      regionSpaceToRelative,
      relDataToAbs,
      range
    };
  }
  /**
  * Positions an element at the viewport location of `data` point.
  * Ensure the element has `position:absolute` set.
  * @param data
  * @param elementToPosition
  * @param by
  */
  positionElementAt(data, elementToPosition, by = `middle`, relativeToQuery) {
    const el2 = resolveEl2(elementToPosition);
    let { x: x3, y: y3 } = this.valueToScreenSpace(data);
    if (by === `middle`) {
      const bounds = el2.getBoundingClientRect();
      x3 -= bounds.width / 2;
      y3 -= bounds.height / 2;
    } else if (by === `top-left`) {
    } else throw new Error(`Param 'by' expected to be 'middle' or 'top-left'.`);
    if (relativeToQuery) {
      const relativeTo = resolveEl2(relativeToQuery);
      const bounds = relativeTo.getBoundingClientRect();
      x3 -= bounds.x;
      y3 -= bounds.y;
    }
    el2.style.left = `${x3}px`;
    el2.style.top = `${y3}px`;
  }
  /**
  * When range is auto, returns the range of the data
  * Otherwise returns the user-provided range.
  * @returns
  */
  getDataRange() {
    if (this.#rangeMode === `auto`) return computeMinMax([...this.#data.getValues()]);
    else {
      if (!this.#rangeManual) this.#rangeManual = computeMinMax([this.#rangeMode.max, this.#rangeMode.min]);
      return this.#rangeManual;
    }
  }
  valueToScreenSpace(dataPoint) {
    const region = this.valueToRegionSpace(dataPoint);
    const offset$1 = this.canvasSource.offset;
    const scr = {
      x: region.x + offset$1.x,
      y: region.y + offset$1.y
    };
    return scr;
  }
  valueToRegionSpace(dataValue, debug3 = false) {
    const ds2 = this.getCurrentRange();
    const rel = ds2.absDataToRelative(dataValue);
    const region = ds2.relDataToCanvas(rel);
    if (debug3) console.log(`orig: ${dataValue.x}x${dataValue.y} rel: ${rel.x}x${rel.y} region: ${region.x}x${region.y}`);
    return {
      ...dataValue,
      x: region.x,
      y: region.y
    };
  }
  /**
  * Converts a point in pixel coordinates to a value.
  * Useful for converting from user input coordinates.
  * @param point
  * @returns
  */
  pointToValue(point3, _source) {
    const ds2 = this.getCurrentRange();
    const canvasPoint = subtract(point3, this.canvasSource.offset);
    const v3 = ds2.canvasToRelData(canvasPoint);
    return ds2.relDataToAbs(v3);
  }
  /**
  * Compute canvas-relative coordinates based on two points in value space
  * @param valueA
  * @param valueB
  */
  #valueLineToCanvasSpace(valueA, valueB, debug3 = false) {
    valueA = this.valueToRegionSpace(valueA, debug3);
    valueB = this.valueToRegionSpace(valueB, debug3);
    return {
      a: valueA,
      b: valueB
    };
  }
  getDefaultMeta() {
    return {
      colour: goldenAngleColour(this.#data.metaCount),
      lineWidth: 2,
      dotRadius: 5
    };
  }
  draw() {
    if (this.#visualClear === `region`) this.#canvasRegion.clear();
    else this.canvasSource.clear();
    this.#useGrid();
    if (this.show.axes) this.#drawAxes();
    for (const [k3, v3] of this.#data.getEntries()) {
      let meta = this.#data.getMeta(k3);
      if (!meta) {
        meta = this.getDefaultMeta();
        this.#data.setMeta(k3, meta);
      }
      this.#drawSeries(k3, v3, meta);
    }
    for (const line$2 of this.overlayLines) this.drawLine(line$2, line$2.colour, line$2.width);
  }
  /**
  * Draws a line in value-coordinate space
  * @param line
  * @param colour
  * @param width
  */
  drawLine(line$2, colour, width) {
    const l3 = this.#valueLineToCanvasSpace(line$2.a, line$2.b);
    this.#drawLineCanvasSpace(l3, colour, width);
  }
  setMeta(series, meta) {
    this.#data.setMeta(series, {
      ...this.getDefaultMeta(),
      ...meta
    });
  }
  #drawAxes() {
    const { colour, width } = this.#axisStyle;
    const yAxis = this.#valueLineToCanvasSpace({
      x: 0,
      y: Number.NEGATIVE_INFINITY
    }, {
      x: 0,
      y: Number.POSITIVE_INFINITY
    }, false);
    const xAxis = this.#valueLineToCanvasSpace({
      x: Number.NEGATIVE_INFINITY,
      y: 0
    }, {
      x: Number.POSITIVE_INFINITY,
      y: 0
    }, false);
    this.#drawLineCanvasSpace(xAxis, colour, width, false);
    this.#drawLineCanvasSpace(yAxis, colour, width, false);
  }
  #drawYAxisValues(yPoints) {
    const ctx = this.#canvasRegion.context;
    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;
    ctx.fillStyle = this.#textStyle.colour;
    ctx.textBaseline = `middle`;
    for (const p3 of yPoints) {
      if (p3.x === 0 && p3.y === 0) continue;
      const reg = this.valueToRegionSpace(p3, false);
      const value3 = this.axisRounder(p3.y);
      const label = value3.toString();
      const measure = ctx.measureText(label);
      const x3 = reg.x - measure.width - this.whiskerLength / 2 - 5;
      const y3 = reg.y;
      ctx.fillText(label, x3, y3);
    }
  }
  #drawXAxisValues(xPoints) {
    const ctx = this.#canvasRegion.context;
    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;
    ctx.fillStyle = this.#textStyle.colour;
    ctx.textBaseline = `top`;
    for (const p3 of xPoints) {
      const reg = this.valueToRegionSpace(p3, false);
      const value3 = this.axisRounder(p3.x);
      const label = value3.toString();
      const measure = ctx.measureText(label);
      const x3 = reg.x - measure.width / 2;
      const y3 = reg.y + measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent + this.whiskerLength / 2;
      ctx.fillText(label, x3, y3);
    }
  }
  #drawWhisker(p3, vertical) {
    const whiskerHalfLength = this.whiskerLength / 2;
    const v3 = vertical ? {
      x: p3.x,
      y: 0
    } : {
      y: p3.y,
      x: 0
    };
    const reg = this.valueToRegionSpace(v3, false);
    const line$2 = vertical ? {
      a: {
        x: reg.x,
        y: reg.y - whiskerHalfLength
      },
      b: {
        x: reg.x,
        y: reg.y + whiskerHalfLength
      }
    } : {
      a: {
        y: reg.y,
        x: reg.x - whiskerHalfLength
      },
      b: {
        y: reg.y,
        x: reg.x + whiskerHalfLength
      }
    };
    this.#drawLineCanvasSpace(line$2, this.#axisStyle.colour, this.#axisStyle.width, false);
  }
  #drawGridline(p3, vertical) {
    const line$2 = vertical ? this.#valueLineToCanvasSpace({
      x: p3.x,
      y: Number.NEGATIVE_INFINITY
    }, {
      x: p3.x,
      y: Number.POSITIVE_INFINITY
    }) : this.#valueLineToCanvasSpace({
      y: p3.y,
      x: Number.NEGATIVE_INFINITY
    }, {
      y: p3.y,
      x: Number.POSITIVE_INFINITY
    }, false);
    this.#drawLineCanvasSpace(line$2, this.#grid.colour, p3.major ? this.#grid.width * 2 : this.#grid.width);
  }
  #useGrid() {
    const g4 = this.#grid;
    const showGrid = this.show.grid;
    const showWhiskers = this.show.whiskers;
    const showValues = this.show.axisValues;
    const mm = this.getCurrentRange().range;
    const { increments, major } = g4;
    const axisMarks = computeAxisMark(mm, increments, major);
    for (const p3 of axisMarks.x) {
      if (showGrid) this.#drawGridline(p3, true);
      if (showWhiskers && p3.major) this.#drawWhisker(p3, true);
    }
    for (const p3 of axisMarks.y) {
      if (showGrid) this.#drawGridline(p3, false);
      if (showWhiskers && p3.major) this.#drawWhisker(p3, false);
    }
    if (showValues) {
      this.#drawXAxisValues(axisMarks.x.filter((p3) => p3.major));
      this.#drawYAxisValues(axisMarks.y.filter((p3) => p3.major));
    }
  }
  #drawSeries(name, series, meta) {
    if (this.#connectStyle === `line`) this.#drawConnected(series, meta.colour, meta.lineWidth);
    if (this.#valueStyle === `dot`) for (const v3 of series) this.#drawDot(v3, meta.colour, meta.dotRadius);
  }
  #drawConnected(dots, colour, width) {
    const ctx = this.#canvasRegion.context;
    ctx.beginPath();
    for (const [index, dot_] of dots.entries()) {
      const dot$1 = this.valueToRegionSpace(dot_, false);
      if (index === 0) ctx.moveTo(dot$1.x, dot$1.y);
      ctx.lineTo(dot$1.x, dot$1.y);
    }
    ctx.strokeStyle = toCssColour(colour);
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  }
  #drawDot(originalDot, fallbackColour, fallbackRadius) {
    const colour = toCssColour(originalDot.fillStyle ?? fallbackColour);
    const pos = this.valueToRegionSpace(originalDot);
    const radius = originalDot.radius ?? fallbackRadius;
    this.#canvasRegion.drawCircles([{
      ...pos,
      radius
    }], colour);
  }
  #drawLineCanvasSpace(line$2, colour, width, debug3 = false) {
    if (debug3) console.log(line$2);
    const ctx = this.#canvasRegion.context;
    colour = toCssColour(colour);
    ctx.beginPath();
    ctx.moveTo(line$2.a.x, line$2.a.y);
    ctx.lineTo(line$2.b.x, line$2.b.y);
    ctx.strokeStyle = toCssColour(colour);
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  }
  get dataSet() {
    return this.#data;
  }
  get canvasRegion() {
    return this.#canvasRegion;
  }
  get canvasSource() {
    return this.#canvasRegion.source;
  }
};
var plot_exports = {};
__export(plot_exports, {
  BipolarView: () => bipolar_view_exports,
  CartesianCanvasPlot: () => CartesianCanvasPlot,
  DataSet: () => DataSet,
  absoluteCompute: () => absoluteCompute,
  computeAxisMark: () => computeAxisMark,
  computeMinMax: () => computeMinMax,
  insert: () => insert,
  relativeCompute: () => relativeCompute
});
var src_exports9 = {};
__export(src_exports9, {
  CanvasHelper: () => CanvasHelper,
  CanvasRegion: () => CanvasRegion,
  CanvasSource: () => CanvasSource,
  Colour: () => colour_exports,
  Convolve2d: () => convolve_2d_exports,
  Drawing: () => drawing_exports,
  ImageDataGrid: () => image_data_grid_exports,
  Plot: () => plot_exports,
  Svg: () => svg_exports,
  Video: () => video_exports,
  pointerVisualise: () => pointerVisualise
});
try {
  if (typeof window !== `undefined`) window.ixfx = {
    ...window.ixfx,
    Visuals: {
      NamedColourPalette: named_colour_palette_exports,
      Colour: colour_exports,
      Video: video_exports
    }
  };
} catch {
}

// node_modules/ixfx/bundle/visual.js
var drawing_exports2 = {};
__export(drawing_exports2, {
  arc: () => arc2,
  bezier: () => bezier2,
  circle: () => circle$12,
  connectedPoints: () => connectedPoints2,
  copyToImg: () => copyToImg2,
  dot: () => dot2,
  drawingStack: () => drawingStack2,
  ellipse: () => ellipse2,
  getContext: () => getContext2,
  line: () => line$12,
  lineThroughPoints: () => lineThroughPoints2,
  makeHelper: () => makeHelper$12,
  paths: () => paths2,
  pointLabels: () => pointLabels2,
  rect: () => rect2,
  textBlock: () => textBlock2,
  textBlockAligned: () => textBlockAligned2,
  textHeight: () => textHeight2,
  textRect: () => textRect2,
  textWidth: () => textWidth2,
  translatePoint: () => translatePoint2,
  triangle: () => triangle2
});
var PIPI2 = Math.PI * 2;
var getContext2 = (canvasElementContextOrQuery) => {
  if (canvasElementContextOrQuery === null) throw new Error(`canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`);
  if (canvasElementContextOrQuery === void 0) throw new Error(`canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`);
  const ctx = canvasElementContextOrQuery instanceof CanvasRenderingContext2D ? canvasElementContextOrQuery : canvasElementContextOrQuery instanceof HTMLCanvasElement ? canvasElementContextOrQuery.getContext(`2d`) : typeof canvasElementContextOrQuery === `string` ? resolveEl2(canvasElementContextOrQuery).getContext(`2d`) : canvasElementContextOrQuery;
  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);
  return ctx;
};
var makeHelper$12 = (ctxOrCanvasEl, canvasBounds) => {
  const ctx = getContext2(ctxOrCanvasEl);
  return {
    ctx,
    paths(pathsToDraw, opts) {
      paths2(ctx, pathsToDraw, opts);
    },
    line(lineToDraw, opts) {
      line$12(ctx, lineToDraw, opts);
    },
    rect(rectsToDraw, opts) {
      rect2(ctx, rectsToDraw, opts);
    },
    bezier(bezierToDraw, opts) {
      bezier2(ctx, bezierToDraw, opts);
    },
    connectedPoints(pointsToDraw, opts) {
      connectedPoints2(ctx, pointsToDraw, opts);
    },
    pointLabels(pointsToDraw, opts) {
      pointLabels2(ctx, pointsToDraw, opts);
    },
    dot(dotPosition, opts) {
      dot2(ctx, dotPosition, opts);
    },
    circle(circlesToDraw, opts) {
      circle$12(ctx, circlesToDraw, opts);
    },
    arc(arcsToDraw, opts) {
      arc2(ctx, arcsToDraw, opts);
    },
    textBlock(lines, opts) {
      if (opts.bounds === void 0 && canvasBounds !== void 0) opts = {
        ...opts,
        bounds: {
          ...canvasBounds,
          x: 0,
          y: 0
        }
      };
      textBlock2(ctx, lines, opts);
    }
  };
};
var optsOp2 = (opts) => coloringOp2(opts.strokeStyle, opts.fillStyle);
var applyOpts$12 = (ctx, opts = {}, ...additionalOps) => {
  if (ctx === void 0) throw new Error(`ctx undefined`);
  const stack = drawingStack2(ctx).push(optsOp2(opts), ...additionalOps);
  stack.apply();
  return stack;
};
var arc2 = (ctx, arcs, opts = {}) => {
  applyOpts$12(ctx, opts);
  const draw = (arc$1) => {
    ctx.beginPath();
    ctx.arc(arc$1.x, arc$1.y, arc$1.radius, arc$1.startRadian, arc$1.endRadian);
    ctx.stroke();
  };
  const arcsArray = Array.isArray(arcs) ? arcs : [arcs];
  for (const arc$1 of arcsArray) draw(arc$1);
};
var coloringOp2 = (strokeStyle, fillStyle) => {
  const apply3 = (ctx) => {
    if (fillStyle) ctx.fillStyle = fillStyle;
    if (strokeStyle) ctx.strokeStyle = strokeStyle;
  };
  return apply3;
};
var lineOp2 = (lineWidth, lineJoin, lineCap) => {
  const apply3 = (ctx) => {
    if (lineWidth) ctx.lineWidth = lineWidth;
    if (lineJoin) ctx.lineJoin = lineJoin;
    if (lineCap) ctx.lineCap = lineCap;
  };
  return apply3;
};
var drawingStack2 = (ctx, stk) => {
  stk ??= new StackImmutable3();
  const push3 = (...ops) => {
    stk ??= new StackImmutable3();
    const s3 = stk.push(...ops);
    for (const o5 of ops) o5(ctx);
    return drawingStack2(ctx, s3);
  };
  const pop3 = () => {
    const s3 = stk?.pop();
    return drawingStack2(ctx, s3);
  };
  const apply3 = () => {
    if (stk === void 0) return drawingStack2(ctx);
    for (const op of stk.data) op(ctx);
    return drawingStack2(ctx, stk);
  };
  return {
    push: push3,
    pop: pop3,
    apply: apply3
  };
};
var lineThroughPoints2 = (ctx, points, opts) => {
  applyOpts$12(ctx, opts);
  ctx.moveTo(points[0].x, points[0].y);
  for (const [index, p3] of points.entries()) {
    if (index + 2 >= points.length) continue;
    const pNext = points[index + 1];
    const mid = {
      x: (p3.x + pNext.x) / 2,
      y: (p3.y + pNext.y) / 2
    };
    const cpX1 = (mid.x + p3.x) / 2;
    const cpX2 = (mid.x + pNext.x) / 2;
    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);
    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);
  }
};
var circle$12 = (ctx, circlesToDraw, opts = {}) => {
  applyOpts$12(ctx, opts);
  const draw = (c5) => {
    ctx.beginPath();
    ctx.arc(c5.x, c5.y, c5.radius, 0, PIPI2);
    if (opts.strokeStyle) ctx.stroke();
    if (opts.fillStyle) ctx.fill();
  };
  if (Array.isArray(circlesToDraw)) for (const c5 of circlesToDraw) draw(c5);
  else draw(circlesToDraw);
};
var ellipse2 = (ctx, ellipsesToDraw, opts = {}) => {
  applyOpts$12(ctx, opts);
  const draw = (ellipse$1) => {
    ctx.beginPath();
    const rotation = ellipse$1.rotation ?? 0;
    const startAngle = ellipse$1.startAngle ?? 0;
    const endAngle = ellipse$1.endAngle ?? PIPI2;
    ctx.ellipse(ellipse$1.x, ellipse$1.y, ellipse$1.radiusX, ellipse$1.radiusY, rotation, startAngle, endAngle);
    if (opts.strokeStyle) ctx.stroke();
    if (opts.fillStyle) ctx.fill();
  };
  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ellipsesToDraw];
  for (const ellipse$1 of ellipsesArray) draw(ellipse$1);
};
var paths2 = (ctx, pathsToDraw, opts = {}) => {
  applyOpts$12(ctx, opts);
  const draw = (path$1) => {
    if (isQuadraticBezier(path$1)) quadraticBezier2(ctx, path$1, opts);
    else if (isLine(path$1)) line$12(ctx, path$1, opts);
    else throw new Error(`Unknown path type ${JSON.stringify(path$1)}`);
  };
  if (Array.isArray(pathsToDraw)) for (const p3 of pathsToDraw) draw(p3);
  else draw(pathsToDraw);
};
var connectedPoints2 = (ctx, pts, opts = {}) => {
  const shouldLoop = opts.loop ?? false;
  resultThrow(arrayTest(pts, `pts`));
  if (pts.length === 0) return;
  for (const [index, pt2] of pts.entries()) guard$1(pt2, `Index ${index}`);
  applyOpts$12(ctx, opts);
  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;
  ctx.beginPath();
  ctx.moveTo(pts[0].x, pts[0].y);
  for (const pt2 of pts) ctx.lineTo(pt2.x, pt2.y);
  if (shouldLoop) ctx.lineTo(pts[0].x, pts[0].y);
  if (opts.strokeStyle || opts.strokeStyle === void 0 && opts.fillStyle === void 0) ctx.stroke();
  if (opts.fillStyle) ctx.fill();
};
var pointLabels2 = (ctx, pts, opts = {}, labels) => {
  if (pts.length === 0) return;
  for (const [index, pt2] of pts.entries()) guard$1(pt2, `Index ${index}`);
  applyOpts$12(ctx, opts);
  for (const [index, pt2] of pts.entries()) {
    const label = labels !== void 0 && index < labels.length ? labels[index] : index.toString();
    ctx.fillText(label.toString(), pt2.x, pt2.y);
  }
};
var translatePoint2 = (ctx, point3) => {
  const m4 = ctx.getTransform();
  return {
    x: point3.x * m4.a + point3.y * m4.c + m4.e,
    y: point3.x * m4.b + point3.y * m4.d + m4.f
  };
};
var copyToImg2 = (canvasEl) => {
  const img = document.createElement(`img`);
  img.src = canvasEl.toDataURL(`image/jpeg`);
  return img;
};
var dot2 = (ctx, pos, opts) => {
  opts ??= {};
  const radius = opts.radius ?? 10;
  const positions = Array.isArray(pos) ? pos : [pos];
  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== void 0;
  let filled = opts.filled ? opts.filled : opts.fillStyle !== void 0;
  if (!stroke && !filled) filled = true;
  applyOpts$12(ctx, opts);
  for (const pos$1 of positions) {
    ctx.beginPath();
    if (`radius` in pos$1) ctx.arc(pos$1.x, pos$1.y, pos$1.radius, 0, 2 * Math.PI);
    else ctx.arc(pos$1.x, pos$1.y, radius, 0, 2 * Math.PI);
    if (filled) ctx.fill();
    if (stroke) ctx.stroke();
  }
};
var bezier2 = (ctx, bezierToDraw, opts) => {
  if (isQuadraticBezier(bezierToDraw)) quadraticBezier2(ctx, bezierToDraw, opts);
  else if (isCubicBezier(bezierToDraw)) cubicBezier2(ctx, bezierToDraw, opts);
};
var cubicBezier2 = (ctx, bezierToDraw, opts = {}) => {
  let stack = applyOpts$12(ctx, opts);
  const { a: a3, b: b3, cubic1, cubic2: cubic22 } = bezierToDraw;
  const isDebug = opts.debug ?? false;
  if (isDebug) {
  }
  ctx.beginPath();
  ctx.moveTo(a3.x, a3.y);
  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic22.x, cubic22.y, b3.x, b3.y);
  ctx.stroke();
  if (isDebug) {
    stack = stack.push(optsOp2({
      ...opts,
      strokeStyle: multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),
      fillStyle: multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4)
    }));
    stack.apply();
    ctx.moveTo(a3.x, a3.y);
    ctx.lineTo(cubic1.x, cubic1.y);
    ctx.stroke();
    ctx.moveTo(b3.x, b3.y);
    ctx.lineTo(cubic22.x, cubic22.y);
    ctx.stroke();
    ctx.fillText(`a`, a3.x + 5, a3.y);
    ctx.fillText(`b`, b3.x + 5, b3.y);
    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);
    ctx.fillText(`c2`, cubic22.x + 5, cubic22.y);
    dot2(ctx, cubic1, { radius: 3 });
    dot2(ctx, cubic22, { radius: 3 });
    dot2(ctx, a3, { radius: 3 });
    dot2(ctx, b3, { radius: 3 });
    stack = stack.pop();
    stack.apply();
  }
};
var quadraticBezier2 = (ctx, bezierToDraw, opts = {}) => {
  const { a: a3, b: b3, quadratic: quadratic3 } = bezierToDraw;
  const isDebug = opts.debug ?? false;
  let stack = applyOpts$12(ctx, opts);
  ctx.beginPath();
  ctx.moveTo(a3.x, a3.y);
  ctx.quadraticCurveTo(quadratic3.x, quadratic3.y, b3.x, b3.y);
  ctx.stroke();
  if (isDebug) {
    stack = stack.push(optsOp2({
      ...opts,
      strokeStyle: multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),
      fillStyle: multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4)
    }));
    connectedPoints2(ctx, [
      a3,
      quadratic3,
      b3
    ]);
    ctx.fillText(`a`, a3.x + 5, a3.y);
    ctx.fillText(`b`, b3.x + 5, b3.y);
    ctx.fillText(`h`, quadratic3.x + 5, quadratic3.y);
    dot2(ctx, quadratic3, { radius: 3 });
    dot2(ctx, a3, { radius: 3 });
    dot2(ctx, b3, { radius: 3 });
    stack = stack.pop();
    stack.apply();
  }
};
var line$12 = (ctx, toDraw, opts = {}) => {
  const isDebug = opts.debug ?? false;
  const o5 = lineOp2(opts.lineWidth, opts.lineJoin, opts.lineCap);
  applyOpts$12(ctx, opts, o5);
  const draw = (d3) => {
    const { a: a3, b: b3 } = d3;
    ctx.beginPath();
    ctx.moveTo(a3.x, a3.y);
    ctx.lineTo(b3.x, b3.y);
    if (isDebug) {
      ctx.fillText(`a`, a3.x, a3.y);
      ctx.fillText(`b`, b3.x, b3.y);
      dot2(ctx, a3, {
        radius: 5,
        strokeStyle: `black`
      });
      dot2(ctx, b3, {
        radius: 5,
        strokeStyle: `black`
      });
    }
    ctx.stroke();
  };
  if (Array.isArray(toDraw)) for (const t6 of toDraw) draw(t6);
  else draw(toDraw);
};
var triangle2 = (ctx, toDraw, opts = {}) => {
  applyOpts$12(ctx, opts);
  const draw = (t6) => {
    connectedPoints2(ctx, corners(t6), {
      ...opts,
      loop: true
    });
    if (opts.debug) pointLabels2(ctx, corners(t6), void 0, [
      `a`,
      `b`,
      `c`
    ]);
  };
  if (Array.isArray(toDraw)) for (const t6 of toDraw) draw(t6);
  else draw(toDraw);
};
var rect2 = (ctx, toDraw, opts = {}) => {
  applyOpts$12(ctx, opts);
  const filled = opts.filled ?? (opts.fillStyle === void 0 ? false : true);
  const stroke = opts.stroke ?? (opts.strokeStyle === void 0 ? false : true);
  const draw = (d3) => {
    const x3 = `x` in d3 ? d3.x : 0;
    const y3 = `y` in d3 ? d3.y : 0;
    if (filled) ctx.fillRect(x3, y3, d3.width, d3.height);
    if (stroke) {
      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;
      ctx.strokeRect(x3, y3, d3.width, d3.height);
    }
    if (opts.crossed) {
      ctx.beginPath();
      ctx.moveTo(x3, y3);
      ctx.lineTo(d3.width, d3.height);
      ctx.stroke();
      ctx.moveTo(0, d3.height);
      ctx.lineTo(d3.width, 0);
      ctx.stroke();
    }
    if (opts.debug) pointLabels2(ctx, corners$1(d3), void 0, [
      `NW`,
      `NE`,
      `SE`,
      `SW`
    ]);
  };
  if (Array.isArray(toDraw)) for (const t6 of toDraw) draw(t6);
  else draw(toDraw);
};
var textWidth2 = (ctx, text$1, padding2 = 0, widthMultiple) => {
  const rect$1 = textRect2(ctx, text$1, padding2, widthMultiple);
  return rect$1.width;
};
var textRect2 = (ctx, text$1, padding2 = 0, widthMultiple) => {
  if (text$1 === void 0 || text$1 === null || text$1.length === 0) return Empty$3;
  const m4 = ctx.measureText(text$1);
  const width = widthMultiple ? quantiseEvery(m4.width, widthMultiple) + padding2 : m4.width + padding2;
  return {
    width,
    height: m4.actualBoundingBoxAscent + m4.actualBoundingBoxDescent + padding2 + padding2
  };
};
var textHeight2 = (ctx, text$1, padding2 = 0) => {
  const rect$1 = textRect2(ctx, text$1, padding2);
  return rect$1.height;
};
var textBlock2 = (ctx, lines, opts) => {
  applyOpts$12(ctx, opts);
  const anchorPadding = opts.anchorPadding ?? 0;
  const align = opts.align ?? `top`;
  const anchor = opts.anchor;
  const bounds = opts.bounds ?? {
    x: 0,
    y: 0,
    width: 1e6,
    height: 1e6
  };
  const blocks = lines.map((l3) => ctx.measureText(l3));
  const widths = blocks.map((tm) => tm.width);
  const heights = blocks.map((tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3);
  const maxWidth = Math.max(...widths);
  const totalHeight = heights.reduce((accumulator, value3) => accumulator + value3, 0);
  let { x: x3, y: y3 } = anchor;
  if (anchor.x + maxWidth > bounds.width) x3 = bounds.width - (maxWidth + anchorPadding);
  else x3 -= anchorPadding;
  if (x3 < bounds.x) x3 = bounds.x + anchorPadding;
  if (anchor.y + totalHeight > bounds.height) y3 = bounds.height - (totalHeight + anchorPadding);
  else y3 -= anchorPadding;
  if (y3 < bounds.y) y3 = bounds.y + anchorPadding;
  if (align === `top`) ctx.textBaseline = `top`;
  else ctx.textBaseline = `middle`;
  for (const [index, line$2] of lines.entries()) {
    ctx.fillText(line$2, x3, y3);
    y3 += heights[index];
  }
};
var textBlockAligned2 = (ctx, text$1, opts) => {
  const { bounds } = opts;
  const { horiz = `left`, vert = `top` } = opts;
  const lines = typeof text$1 === `string` ? [text$1] : text$1;
  applyOpts$12(ctx, opts);
  ctx.save();
  ctx.translate(bounds.x, bounds.y);
  ctx.textAlign = `left`;
  ctx.textBaseline = `top`;
  const middleX = bounds.width / 2;
  const middleY = bounds.height / 2;
  const blocks = lines.map((l3) => ctx.measureText(l3));
  const heights = blocks.map((tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);
  const totalHeight = heights.reduce((accumulator, value3) => accumulator + value3, 0);
  let y3 = 0;
  if (vert === `center`) y3 = middleY - totalHeight / 2;
  else if (vert === `bottom`) y3 = bounds.height - totalHeight;
  for (const [index, line$2] of lines.entries()) {
    let x3 = 0;
    if (horiz === `center`) x3 = middleX - blocks[index].width / 2;
    else if (horiz === `right`) x3 = bounds.width - blocks[index].width;
    ctx.fillText(line$2, x3, y3);
    y3 += heights[index];
  }
  ctx.restore();
};
var isHsl2 = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`h` in v3)) return false;
  if (!(`s` in v3)) return false;
  if (!(`l` in v3)) return false;
  if (!(`unit` in v3)) return false;
  if (!(`space` in v3)) return false;
  if (v3.space !== `hsl`) return false;
  return true;
};
var isRgb2 = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`r` in v3)) return false;
  if (!(`g` in v3)) return false;
  if (!(`b` in v3)) return false;
  if (!(`space` in v3)) return false;
  if (!(`unit` in v3)) return false;
  if (v3.space === `srgb`) return true;
  return false;
};
var tryParseObjectToRgb2 = (v3) => {
  if (typeof v3 !== `object`) throw new TypeError(`Param 'v' is expected to be an object, got: ${typeof v3}`);
  if (!(`r` in v3 && `g` in v3 && `b` in v3)) return;
  if (!(`unit` in v3)) if (v3.r <= 1 && v3.g <= 1 && v3.b <= 1) v3.unit = `scalar`;
  else if (v3.r > 255 && v3.g <= 255 && v3.b <= 255) return;
  else v3.unit = `8bit`;
  if (!(`space` in v3)) v3.space = `srgb`;
  return v3;
};
var tryParseObjectToHsl2 = (v3) => {
  if (!(`h` in v3 && `s` in v3 && `l` in v3)) return;
  if (!(`unit` in v3)) if (v3.r <= 1 && v3.g <= 1 && v3.b <= 1) v3.unit = `scalar`;
  else if (v3.s > 100 && v3.l <= 100) return;
  else v3.unit = `absolute`;
  if (!(`space` in v3)) v3.space = `hsl`;
  return v3;
};
var isOkLch2 = (v3) => {
  if (typeof v3 !== `object`) return false;
  if (!(`l` in v3)) return false;
  if (!(`c` in v3)) return false;
  if (!(`h` in v3)) return false;
  if (!(`unit` in v3)) return false;
  if (!(`space` in v3)) return false;
  if (v3.space === `lch`) return true;
  if (v3.space === `oklch`) return true;
  return false;
};
var isColourish2 = (v3) => {
  if (typeof v3 === `string`) return true;
  if (typeof v3 !== `object`) return false;
  if (isHsl2(v3)) return true;
  if (isOkLch2(v3)) return true;
  if (isRgb2(v3)) return true;
  return false;
};
function calculateHueDistance2(a3, b3, limit2 = 1) {
  let long = -1;
  let short = -1;
  if (b3 < a3) {
    long = b3 - a3;
    short = limit2 - (a3 - b3);
  } else {
    long = b3 - a3;
    short = long - limit2;
  }
  const forward = short > 0 ? short : long;
  const backward = short > 0 ? long : short;
  if (Math.abs(long) < Math.abs(short)) {
    const t6 = short;
    short = long;
    long = t6;
  }
  return {
    long,
    short,
    forward,
    backward
  };
}
var libraryRgbToHexString2 = (rgb) => {
  const componentToHex = (c5) => {
    const hex = Math.floor(c5).toString(16);
    return hex.length == 1 ? "0" + hex : hex;
  };
  let part = `#${componentToHex(rgb.r)}${componentToHex(rgb.g)}${componentToHex(rgb.b)}`;
  if (typeof rgb.alpha !== `undefined` && rgb.alpha !== 255) part += componentToHex(rgb.alpha);
  return part;
};
function wrapScalarHue2(value3) {
  value3 = value3 % 1;
  if (value3 < 0) return (1 - Math.abs(value3)) % 1;
  return value3;
}
var hsl_exports2 = {};
__export(hsl_exports2, {
  absolute: () => absolute$12,
  changeLightness: () => changeLightness$12,
  fromCss: () => fromCss$22,
  fromHexString: () => fromHexString$22,
  generateScalar: () => generateScalar$12,
  guard: () => guard$53,
  interpolator: () => interpolator$32,
  parseCssHslFunction: () => parseCssHslFunction2,
  scalar: () => scalar2,
  toAbsolute: () => toAbsolute$12,
  toCssString: () => toCssString2,
  toHexString: () => toHexString$22,
  toLibraryRgb: () => toLibraryRgb2,
  toScalar: () => toScalar$22,
  withOpacity: () => withOpacity$32
});
var withOpacity$32 = (value3, fn2) => {
  switch (value3.unit) {
    case `absolute`:
      return {
        ...value3,
        opacity: fn2((value3.opacity ?? 100) / 100, value3) * 100
      };
    case `scalar`:
      return {
        ...value3,
        opacity: fn2(value3.opacity ?? 1, value3)
      };
  }
};
var changeLightness$12 = (value3, amount) => {
  let newL = 0;
  if (typeof amount.pdelta !== `undefined`) newL = value3.l + value3.l * amount.pdelta;
  else if (typeof amount.delta !== `undefined`) newL = amount.delta + value3.l;
  else if (typeof amount.fixed !== `undefined`) {
    if (amount.fixed < 0) throw new TypeError(`Cannot use negative value with 'fixed'`);
    newL = amount.fixed;
  } else throw new TypeError(`Parameter 'amount' is missing 'delta/pdelta/fixed' properties`);
  return {
    ...value3,
    l: scaleProperty2(value3, newL, `l`)
  };
};
var scaleProperty2 = (hsl, value3, property) => {
  if (hsl.unit === `scalar`) {
    if (value3 > 1) value3 = 1;
    else if (value3 < 0) value3 = 0;
  } else if (value3 > 100) value3 = 100;
  else if (value3 < 0) value3 = 0;
  return value3;
};
var hslTransparent2 = Object.freeze({
  h: 0,
  s: 0,
  l: 0,
  opacity: 0,
  unit: `absolute`,
  space: `hsl`
});
function fromHexString$22(hexString, options = {}) {
  return fromLibrary$22(hex2hsl(hexString), options);
}
function fromCss$22(value3, options = {}) {
  value3 = value3.toLowerCase();
  if (value3.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);
  if (value3.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);
  if (value3.startsWith(`#`)) return fromHexString$22(value3, options);
  if (value3.startsWith(`--`)) try {
    value3 = resolveCss2(value3);
  } catch (error) {
    if (typeof options.fallbackString !== `undefined`) value3 = options.fallbackString;
    if (typeof options.fallbackColour !== `undefined`) return options.fallbackColour;
    throw error;
  }
  if (value3 === `transparent`) return hslTransparent2;
  if (typeof cssDefinedHexColours2[value3] !== `undefined`) return fromHexString$22(cssDefinedHexColours2[value3], options);
  if (value3.startsWith(`rgb(`)) {
    const hsl = toLibraryHsl2(value3);
    return fromLibrary$22(hsl, options);
  }
  if (!value3.startsWith(`hsl(`)) try {
    value3 = convert$1(value3, `hsl`);
  } catch (error) {
    if (options.fallbackString) value3 = options.fallbackString;
    else throw error;
  }
  try {
    const hsl = parseCssHslFunction2(value3);
    if (options.scalar) return toScalar$22(hsl);
    return toAbsolute$12(hsl);
  } catch (error) {
    if (options.fallbackColour) return options.fallbackColour;
    throw error;
  }
}
var toCssString2 = (hsl) => {
  const abs5 = toAbsolute$12(hsl);
  let css = `hsl(${abs5.h}deg ${abs5.s}% ${abs5.l}%`;
  if (`opacity` in abs5 && abs5.opacity !== void 0 && abs5.opacity < 100) css += ` / ${abs5.opacity}%`;
  css += ")";
  return css;
};
var toHexString$22 = (hsl) => {
  const rgb = toLibraryRgb2(hsl);
  return libraryRgbToHexString2(rgb);
};
function fromLibrary$22(hsl, parsingOptions = {}) {
  if (typeof hsl === `undefined` || hsl === null) {
    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;
  }
  const scalarOpt = parsingOptions.scalar ?? true;
  resultThrow(numberInclusiveRangeTest(hsl.h, 0, 360, `h`), numberInclusiveRangeTest(hsl.s, 0, 100, `s`), numberInclusiveRangeTest(hsl.l, 0, 100, `l`), percentTest(hsl.alpha ?? 1, `alpha`));
  if (scalarOpt) return scalar2(hsl.h / 360, hsl.s / 100, hsl.l / 100, hsl.alpha ?? 1);
  else return absolute$12(hsl.h, hsl.s, hsl.l, (hsl.alpha ?? 1) * 100);
}
var toAbsolute$12 = (hslOrString) => {
  if (typeof hslOrString === `string`) return fromCss$22(hslOrString, { scalar: false });
  if (isRgb2(hslOrString)) return toAbsolute$12(fromLibrary$22(toLibraryHsl2(hslOrString), { scalar: false }));
  const hsl = hslOrString;
  guard$53(hsl);
  if (hsl.unit === `absolute`) return hsl;
  return {
    h: hsl.h * 360,
    s: hsl.s * 100,
    l: hsl.l * 100,
    opacity: (hsl.opacity ?? 1) * 100,
    unit: `absolute`,
    space: `hsl`
  };
};
var generateScalar$12 = (absoluteHslOrVariable, saturation = 1, lightness$1 = 0.5, opacity2 = 1) => {
  if (typeof absoluteHslOrVariable === `string`) {
    if (absoluteHslOrVariable.startsWith(`--`)) absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim();
  }
  const hue = angleParse(absoluteHslOrVariable);
  if (saturation > 1) throw new TypeError(`Param 'saturation' must be between 0..1`);
  if (lightness$1 > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);
  if (opacity2 > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);
  const hueDeg = angleConvert(hue, `deg`).value / 360;
  return {
    h: hueDeg,
    s: saturation,
    l: lightness$1,
    opacity: opacity2,
    unit: `scalar`,
    space: `hsl`
  };
};
var toScalar$22 = (hslOrString) => {
  if (typeof hslOrString === `string`) return fromCss$22(hslOrString, { scalar: true });
  if (isRgb2(hslOrString)) return toScalar$22(fromLibrary$22(toLibraryHsl2(hslOrString), { scalar: true }));
  const hsl = hslOrString;
  guard$53(hsl);
  if (hsl.unit === `scalar`) return hsl;
  return {
    h: hsl.h / 360,
    s: hsl.s / 100,
    l: hsl.l / 100,
    opacity: (hsl.opacity ?? 1) / 100,
    unit: `scalar`,
    space: `hsl`
  };
};
var guard$53 = (hsl) => {
  const { h: h5, s: s3, l: l3, opacity: opacity2, space, unit } = hsl;
  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${space}`);
  if (unit === `absolute`) resultThrow(numberTest(h5, `finite`, `h`), numberInclusiveRangeTest(s3, 0, 100, `s`), numberInclusiveRangeTest(l3, 0, 100, `l`), () => {
    if (typeof opacity2 === `number`) return numberInclusiveRangeTest(opacity2, 0, 100, `opacity`);
  });
  else if (unit === `scalar`) resultThrow(numberTest(h5, `percentage`, `h`), numberTest(s3, `percentage`, `s`), numberTest(l3, `percentage`, `l`), () => {
    if (typeof opacity2 === `number`) return numberTest(opacity2, `percentage`, `opacity`);
  });
  else throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${unit}`);
};
var interpolator$32 = (a3, b3, direction = `shorter`) => {
  a3 = toScalar$22(a3);
  b3 = toScalar$22(b3);
  const aOpacity = a3.opacity ?? 1;
  const distanceCalc = calculateHueDistance2(a3.h, b3.h, 1);
  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;
  const satDistance = b3.s - a3.s;
  const lightDistance = b3.l - a3.l;
  const opacityDistance = (b3.opacity ?? 1) - aOpacity;
  return (amount) => {
    amount = clamp(amount);
    let h5 = interpolate(amount, 0, Math.abs(hueDistance));
    if (hueDistance < 0) h5 = a3.h - h5;
    else h5 = a3.h + h5;
    const s3 = interpolate(amount, 0, satDistance);
    const l3 = interpolate(amount, 0, lightDistance);
    const o5 = interpolate(amount, 0, opacityDistance);
    return scalar2(wrapScalarHue2(h5), s3 + a3.s, l3 + a3.l, o5 + aOpacity);
  };
};
function scalar2(hue = 0.5, sat = 1, lightness$1 = 0.5, opacity2 = 1) {
  const hsl = {
    unit: `scalar`,
    space: `hsl`,
    h: hue,
    s: sat,
    l: lightness$1,
    opacity: opacity2
  };
  guard$53(hsl);
  return hsl;
}
function absolute$12(hue = 200, sat = 100, lightness$1 = 50, opacity2 = 100) {
  const hsl = {
    unit: `absolute`,
    space: `hsl`,
    h: hue,
    s: sat,
    l: lightness$1,
    opacity: opacity2
  };
  guard$53(hsl);
  return hsl;
}
function parseCssHslFunction2(value3) {
  if (value3.startsWith(`hsla`)) throw new Error(`hsla() is not supported`);
  if (!value3.startsWith(`hsl(`)) throw new Error(`Expected hsl(..) CSS colour`);
  const start = value3.indexOf("(");
  const end = value3.indexOf(")");
  if (end < start) throw new Error(`Is hsl() not terminated? Missing ')'`);
  const part = value3.substring(start + 1, end);
  let split = part.split(/[\s,]+/);
  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${split.length} length`);
  let returnRelative = false;
  if (split[0].endsWith(`%`)) returnRelative = true;
  if (split[1].endsWith(`%`) && split[2].endsWith(`%`)) returnRelative = true;
  const valueAsScalar = (v3, pos) => {
    if (v3 === `none`) return 0;
    if (v3.endsWith(`%`)) return Number.parseFloat(v3.substring(0, v3.length - 1)) / 100;
    if (v3.endsWith(`deg`) && pos === 0) v3 = v3.substring(0, v3.length - 3);
    const vf = Number.parseFloat(v3);
    if (pos === 0) return vf / 360;
    if (pos === 3) return vf;
    return vf / 100;
  };
  const valueAsAbs = (v3, pos) => {
    if (v3 === `none`) return 0;
    if (v3.endsWith(`%`)) {
      const vf$1 = Number.parseFloat(v3.substring(0, v3.length - 1));
      if (pos === 0) return vf$1 * 360;
      return vf$1;
    }
    if (v3.endsWith(`deg`) && pos === 0) return Number.parseFloat(v3.substring(0, v3.length - 3));
    const vf = Number.parseFloat(v3);
    return vf;
  };
  if (split.length > 3) {
    if (split[3] === "/") split = [
      split[0],
      split[1],
      split[2],
      split[4]
    ];
  }
  if (returnRelative) return scalar2(valueAsScalar(split[0], 0), valueAsScalar(split[1], 1), valueAsScalar(split[2], 2), valueAsScalar(split[3] ?? `100%`, 3));
  else return absolute$12(valueAsAbs(split[0], 0), valueAsAbs(split[1], 1), valueAsAbs(split[2], 2), valueAsAbs(split[3] ?? `100%`, 3));
}
function toLibraryRgb2(hsl) {
  if (typeof hsl === `string`) {
    const parseResult = fromCss$22(hsl, { scalar: false });
    return toLibraryRgb2(parseResult);
  }
  hsl = toAbsolute$12(hsl);
  const rgb = hsl2rgb({
    h: hsl.h,
    s: hsl.s,
    l: hsl.l
  });
  return {
    ...rgb,
    alpha: (hsl.opacity ?? 100) / 100 * 255
  };
}
var oklch_exports2 = {};
__export(oklch_exports2, {
  OKLCH_CHROMA_MAX: () => OKLCH_CHROMA_MAX2,
  absolute: () => absolute2,
  fromCss: () => fromCss$12,
  fromHexString: () => fromHexString$12,
  fromLibrary: () => fromLibrary$12,
  generateScalar: () => generateScalar2,
  guard: () => guard$43,
  interpolator: () => interpolator$22,
  scalar: () => scalar$22,
  toAbsolute: () => toAbsolute3,
  toCssString: () => toCssString$22,
  toHexString: () => toHexString$12,
  toScalar: () => toScalar$12,
  withOpacity: () => withOpacity$22
});
var OKLCH_CHROMA_MAX2 = 0.4;
var guard$43 = (lch) => {
  const { l: l3, c: c5, h: h5, opacity: opacity2, space, unit } = lch;
  if (space !== `oklch`) throw new Error(`Space is expected to be 'oklch'. Got: ${space}`);
  if (unit === `absolute`) resultThrow(percentTest(l3, `l`), () => {
    if (typeof c5 === `number`) return numberInclusiveRangeTest(c5, 0, OKLCH_CHROMA_MAX2, `c`);
  }, () => {
    if (typeof h5 === `number`) return numberInclusiveRangeTest(c5, 0, 360, `h`);
  }, percentTest(opacity2 ?? 1, `opacity`));
  else if (unit === `scalar`) resultThrow(percentTest(l3, `l`), percentTest(c5, `c`), percentTest(h5, `h`), percentTest(lch.opacity ?? 1, `opacity`));
  else throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${unit}`);
};
function fromLibrary$12(lch, parsingOptions = {}) {
  if (typeof lch === `undefined` || lch === null) {
    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;
  }
  const scalarReturn = parsingOptions.scalar ?? true;
  resultThrow(percentTest(lch.l, `l`), percentTest(lch.c, `c`), numberInclusiveRangeTest(lch.h, 0, 360, `h`), percentTest(lch.alpha ?? 1, `alpha`));
  if (scalarReturn) return scalar$22(lch.l, lch.c / OKLCH_CHROMA_MAX2, lch.h / 360, lch.alpha ?? 1);
  else return absolute2(lch.l, lch.c, lch.h, lch.alpha ?? 1);
}
var fromHexString$12 = (hexString, options = {}) => {
  return fromLibrary$12(hex2oklch(hexString), options);
};
var oklchTransparent2 = Object.freeze({
  l: 0,
  c: 0,
  h: 0,
  opacity: 0,
  unit: `absolute`,
  space: `oklch`
});
function fromCss$12(value3, options = {}) {
  value3 = value3.toLowerCase();
  if (value3.startsWith(`#`)) return fromHexString$12(value3, options);
  if (value3 === `transparent`) return oklchTransparent2;
  if (typeof cssDefinedHexColours2[value3] !== `undefined`) return fromHexString$12(cssDefinedHexColours2[value3], options);
  if (value3.startsWith(`rgb(`)) {
    const rgb = to8bit2(parseCssRgbFunction2(value3));
    const lch$1 = rgb2oklch({
      r: rgb.r,
      g: rgb.g,
      b: rgb.b
    });
    return fromLibrary$12(lch$1, options);
  }
  if (!value3.startsWith(`hsl(`) && !value3.startsWith(`oklch(`)) try {
    const converted = convert$1(value3, `oklch`);
    value3 = converted;
  } catch (error) {
    if (options.fallbackString) value3 = options.fallbackString;
    else throw error;
  }
  const cc = new index_default(value3);
  const lch = cc.oklch;
  return fromLibrary$12(lch, options);
}
var toAbsolute3 = (lchOrString) => {
  if (typeof lchOrString === `string`) return toAbsolute3(fromCss$12(lchOrString, { scalar: true }));
  guard$43(lchOrString);
  if (lchOrString.unit === `absolute`) return lchOrString;
  return {
    space: `oklch`,
    unit: `absolute`,
    l: lchOrString.l,
    c: lchOrString.c * OKLCH_CHROMA_MAX2,
    h: lchOrString.h * 360,
    opacity: lchOrString.opacity
  };
};
var toScalar$12 = (lchOrString) => {
  if (typeof lchOrString === `string`) return toScalar$12(fromCss$12(lchOrString, { scalar: true }));
  const lch = lchOrString;
  guard$43(lch);
  if (lch.unit === `scalar`) return lch;
  return {
    l: lch.l,
    c: lch.c / OKLCH_CHROMA_MAX2,
    h: lch.h / 360,
    opacity: lch.opacity ?? 1,
    unit: `scalar`,
    space: `oklch`
  };
};
var toLibrary$12 = (lch) => {
  const abs5 = toAbsolute3(lch);
  return {
    l: abs5.l,
    c: abs5.c,
    h: abs5.h,
    alpha: abs5.opacity
  };
};
var toCssString$22 = (lch, precision = 3) => {
  guard$43(lch);
  const { l: l3, c: c5, h: h5, opacity: opacity2 } = lch;
  let css = ``;
  switch (lch.unit) {
    case `absolute`:
      css = `oklch(${(l3 * 100).toFixed(precision)}% ${c5.toFixed(precision)} ${h5.toFixed(precision)}`;
      break;
    case `scalar`:
      css = `oklch(${l3.toFixed(precision)} ${(c5 * OKLCH_CHROMA_MAX2).toFixed(precision)} ${(h5 * 360).toFixed(precision)}`;
      break;
  }
  if (typeof opacity2 !== `undefined` && opacity2 !== 1) css += ` / ${opacity2.toFixed(precision)}`;
  css += `)`;
  return css;
};
var toHexString$12 = (lch) => {
  const lch1 = toLibrary$12(lch);
  const rgb = oklch2rgb(lch1);
  return libraryRgbToHexString2(rgb);
};
var generateScalar2 = (absoluteHslOrVariable, chroma2 = 1, lightness$1 = 0.5, opacity2 = 1) => {
  if (typeof absoluteHslOrVariable === `string`) {
    if (absoluteHslOrVariable.startsWith(`--`)) absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim();
  }
  if (lightness$1 > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);
  if (chroma2 > 1) throw new TypeError(`Param 'chroma' must be between 0..1`);
  const hue = angleParse(absoluteHslOrVariable);
  const hueDeg = angleConvert(hue, `deg`).value / 360;
  if (opacity2 > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);
  return {
    l: lightness$1,
    c: chroma2,
    h: hueDeg,
    opacity: opacity2,
    unit: `scalar`,
    space: `oklch`
  };
};
var withOpacity$22 = (value3, fn2) => {
  switch (value3.unit) {
    case `absolute`:
      return {
        ...value3,
        opacity: fn2((value3.opacity ?? 100) / 100, value3) * 100
      };
    case `scalar`:
      return {
        ...value3,
        opacity: fn2(value3.opacity ?? 1, value3)
      };
  }
};
var interpolator$22 = (a3, b3, direction = `shorter`) => {
  a3 = toScalar$12(a3);
  b3 = toScalar$12(b3);
  const aOpacity = a3.opacity ?? 1;
  const distanceCalc = calculateHueDistance2(a3.h, b3.h, 1);
  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;
  const chromaDistance = b3.c - a3.c;
  const lightDistance = b3.l - a3.l;
  const opacityDistance = (b3.opacity ?? 1) - aOpacity;
  return (amount) => {
    amount = clamp(amount);
    let h5 = interpolate(amount, 0, Math.abs(hueDistance));
    if (hueDistance < 0) h5 = a3.h - h5;
    else h5 = a3.h + h5;
    const c5 = interpolate(amount, 0, chromaDistance);
    const l3 = interpolate(amount, 0, lightDistance);
    const o5 = interpolate(amount, 0, opacityDistance);
    return scalar$22(l3 + a3.l, c5 + a3.c, wrapScalarHue2(h5), o5 + aOpacity);
  };
};
function scalar$22(lightness$1 = 0.7, chroma2 = 0.1, hue = 0.5, opacity2 = 1) {
  const lch = {
    unit: `scalar`,
    space: `oklch`,
    l: lightness$1,
    c: chroma2,
    h: hue,
    opacity: opacity2
  };
  guard$43(lch);
  return lch;
}
var absolute2 = (l3, c5, h5, opacity2 = 1) => {
  const lch = {
    space: `oklch`,
    unit: `absolute`,
    opacity: opacity2,
    l: l3,
    c: c5,
    h: h5
  };
  guard$43(lch);
  return lch;
};
var fromCssColour2 = (colour) => {
  if (colour.startsWith(`#`)) return fromHexString2(colour, true);
  if (typeof cssDefinedHexColours2[colour] !== `undefined`) return fromHexString2(cssDefinedHexColours2[colour], true);
  if (colour.startsWith(`--`)) {
    const fromCss$3 = getComputedStyle(document.body).getPropertyValue(colour).trim();
    if (fromCss$3.length === 0 || fromCss$3 === null) throw new Error(`Variable missing: ${colour}`);
    return fromCssColour2(fromCss$3);
  }
  colour = colour.toLowerCase();
  if (colour.startsWith(`hsl(`)) return fromCss$22(colour, { scalar: true });
  if (colour.startsWith(`rgb(`)) return fromCss2(colour, { scalar: true });
  if (colour.startsWith(`oklch(`)) return fromCss$12(colour, { scalar: true });
  throw new Error(`String colour is not a hex colour, CSS variable nor well-defined colour. Input: '${colour}'`);
};
var resolveCss2 = (colour, fallback) => {
  if (colour.startsWith(`--`)) {
    const fromCss$3 = getComputedStyle(document.body).getPropertyValue(colour).trim();
    if (fromCss$3.length === 0 || fromCss$3 === null) {
      if (typeof fallback !== `undefined`) return fallback;
      throw new Error(`CSS variable missing: '${colour}'`);
    }
    return resolveCss2(fromCss$3);
  }
  if (typeof cssDefinedHexColours2[colour] !== `undefined`) return cssDefinedHexColours2[colour];
  return colour;
};
var cssDefinedHexColours2 = {
  "aliceblue": "#f0f8ff",
  "antiquewhite": "#faebd7",
  "aqua": "#00ffff",
  "aquamarine": "#7fffd4",
  "azure": "#f0ffff",
  "beige": "#f5f5dc",
  "bisque": "#ffe4c4",
  "black": "#000000",
  "blanchedalmond": "#ffebcd",
  "blue": "#0000ff",
  "blueviolet": "#8a2be2",
  "brown": "#a52a2a",
  "burlywood": "#deb887",
  "cadetblue": "#5f9ea0",
  "chartreuse": "#7fff00",
  "chocolate": "#d2691e",
  "coral": "#ff7f50",
  "cornflowerblue": "#6495ed",
  "cornsilk": "#fff8dc",
  "crimson": "#dc143c",
  "cyan": "#00ffff",
  "darkblue": "#00008b",
  "darkcyan": "#008b8b",
  "darkgoldenrod": "#b8860b",
  "darkgray": "#a9a9a9",
  "darkgreen": "#006400",
  "darkkhaki": "#bdb76b",
  "darkmagenta": "#8b008b",
  "darkolivegreen": "#556b2f",
  "darkorange": "#ff8c00",
  "darkorchid": "#9932cc",
  "darkred": "#8b0000",
  "darksalmon": "#e9967a",
  "darkseagreen": "#8fbc8f",
  "darkslateblue": "#483d8b",
  "darkslategray": "#2f4f4f",
  "darkturquoise": "#00ced1",
  "darkviolet": "#9400d3",
  "deeppink": "#ff1493",
  "deepskyblue": "#00bfff",
  "dimgray": "#696969",
  "dodgerblue": "#1e90ff",
  "firebrick": "#b22222",
  "floralwhite": "#fffaf0",
  "forestgreen": "#228b22",
  "fuchsia": "#ff00ff",
  "gainsboro": "#dcdcdc",
  "ghostwhite": "#f8f8ff",
  "gold": "#ffd700",
  "goldenrod": "#daa520",
  "gray": "#808080",
  "green": "#008000",
  "greenyellow": "#adff2f",
  "honeydew": "#f0fff0",
  "hotpink": "#ff69b4",
  "indianred": "#cd5c5c",
  "indigo": "#4b0082",
  "ivory": "#fffff0",
  "khaki": "#f0e68c",
  "lavender": "#e6e6fa",
  "lavenderblush": "#fff0f5",
  "lawngreen": "#7cfc00",
  "lemonchiffon": "#fffacd",
  "lightblue": "#add8e6",
  "lightcoral": "#f08080",
  "lightcyan": "#e0ffff",
  "lightgoldenrodyellow": "#fafad2",
  "lightgray": "#d3d3d3",
  "lightgreen": "#90ee90",
  "lightpink": "#ffb6c1",
  "lightsalmon": "#ffa07a",
  "lightseagreen": "#20b2aa",
  "lightskyblue": "#87cefa",
  "lightslategray": "#778899",
  "lightsteelblue": "#b0c4de",
  "lightyellow": "#ffffe0",
  "lime": "#00ff00",
  "limegreen": "#32cd32",
  "linen": "#faf0e6",
  "magenta": "#ff00ff",
  "maroon": "#800000",
  "mediumaquamarine": "#66cdaa",
  "mediumblue": "#0000cd",
  "mediumorchid": "#ba55d3",
  "mediumpurple": "#9370db",
  "mediumseagreen": "#3cb371",
  "mediumslateblue": "#7b68ee",
  "mediumspringgreen": "#00fa9a",
  "mediumturquoise": "#48d1cc",
  "mediumvioletred": "#c71585",
  "midnightblue": "#191970",
  "mintcream": "#f5fffa",
  "mistyrose": "#ffe4e1",
  "moccasin": "#ffe4b5",
  "navajowhite": "#ffdead",
  "navy": "#000080",
  "oldlace": "#fdf5e6",
  "olive": "#808000",
  "olivedrab": "#6b8e23",
  "orange": "#ffa500",
  "orangered": "#ff4500",
  "orchid": "#da70d6",
  "palegoldenrod": "#eee8aa",
  "palegreen": "#98fb98",
  "paleturquoise": "#afeeee",
  "palevioletred": "#db7093",
  "papayawhip": "#ffefd5",
  "peachpuff": "#ffdab9",
  "peru": "#cd853f",
  "pink": "#ffc0cb",
  "plum": "#dda0dd",
  "powderblue": "#b0e0e6",
  "purple": "#800080",
  "rebeccapurple": "#663399",
  "red": "#ff0000",
  "rosybrown": "#bc8f8f",
  "royalblue": "#4169e1",
  "saddlebrown": "#8b4513",
  "salmon": "#fa8072",
  "sandybrown": "#f4a460",
  "seagreen": "#2e8b57",
  "seashell": "#fff5ee",
  "sienna": "#a0522d",
  "silver": "#c0c0c0",
  "skyblue": "#87ceeb",
  "slateblue": "#6a5acd",
  "slategray": "#708090",
  "snow": "#fffafa",
  "springgreen": "#00ff7f",
  "steelblue": "#4682b4",
  "tan": "#d2b48c",
  "teal": "#008080",
  "thistle": "#d8bfd8",
  "tomato": "#ff6347",
  "turquoise": "#40e0d0",
  "violet": "#ee82ee",
  "wheat": "#f5deb3",
  "white": "#ffffff",
  "whitesmoke": "#f5f5f5",
  "yellow": "#ffff00",
  "yellowgreen": "#9acd32",
  "transparent": "#00000000"
};
var srgb_exports2 = {};
__export(srgb_exports2, {
  changeLightness: () => changeLightness2,
  eightBit: () => eightBit2,
  fromCss: () => fromCss2,
  fromHexString: () => fromHexString2,
  guard: () => guard$33,
  interpolator: () => interpolator$12,
  lightness: () => lightness2,
  parseCssRgbFunction: () => parseCssRgbFunction2,
  scalar: () => scalar$12,
  to8bit: () => to8bit2,
  toCssString: () => toCssString$12,
  toHexString: () => toHexString2,
  toLibraryHsl: () => toLibraryHsl2,
  toScalar: () => toScalar3,
  withOpacity: () => withOpacity$12
});
var withOpacity$12 = (value3, fn2) => {
  switch (value3.unit) {
    case `8bit`:
      return {
        ...value3,
        opacity: fn2((value3.opacity ?? 255) / 255, value3) * 255
      };
    case `scalar`:
      return {
        ...value3,
        opacity: fn2(value3.opacity ?? 1, value3)
      };
  }
};
function fromHexString2(hexString, scalar$3 = true) {
  return fromLibrary2(hex2rgb(hexString), { scalar: scalar$3 });
}
var srgbTansparent2 = Object.freeze({
  r: 0,
  g: 0,
  b: 0,
  opacity: 0,
  unit: `8bit`,
  space: `srgb`
});
function fromCss2(value3, options = {}) {
  value3 = value3.toLowerCase();
  if (value3.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);
  if (value3.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);
  const scalar$3 = options.scalar ?? true;
  if (value3.startsWith(`#`)) return fromHexString2(value3, scalar$3);
  if (value3 === `transparent`) return srgbTansparent2;
  if (typeof cssDefinedHexColours2[value3] !== `undefined`) fromHexString2(cssDefinedHexColours2[value3], scalar$3);
  if (value3.startsWith(`hsl(`)) {
    const rgb = toLibraryRgb2(value3);
    return fromLibrary2(rgb, options);
  }
  if (!value3.startsWith(`rgb(`)) try {
    value3 = convert$1(value3, `rgb`);
  } catch (error) {
    if (options.fallbackString) value3 = options.fallbackString;
    else throw error;
  }
  try {
    const rgb = parseCssRgbFunction2(value3);
    if (scalar$3) return toScalar3(rgb);
    return to8bit2(rgb);
  } catch (error) {
    if (options.fallbackColour) return options.fallbackColour;
    throw error;
  }
}
var toHexString2 = (rgb) => {
  const rgb1 = toLibrary2(rgb);
  return libraryRgbToHexString2(rgb1);
};
var toCssString$12 = (rgb) => {
  guard$33(rgb);
  switch (rgb.unit) {
    case `8bit`:
      if (rgb.opacity === void 0 || rgb.opacity === 255) return `rgb(${rgb.r} ${rgb.g} ${rgb.b})`;
      return `rgb(${rgb.r} ${rgb.g} ${rgb.b} / ${(rgb.opacity ?? 255) / 255})`;
    case `scalar`:
      if (rgb.opacity === void 0 || rgb.opacity === 1) return `rgb(${rgb.r * 100}% ${rgb.g * 100}% ${rgb.b * 100}%)`;
      return `rgb(${rgb.r * 100}% ${rgb.g * 100}% ${rgb.b * 100}% / ${(rgb.opacity ?? 1) * 100}%)`;
    default:
      throw new Error(`Unknown unit: ${rgb.unit}`);
  }
};
var toLibrary2 = (rgb) => {
  const abs5 = to8bit2(rgb);
  return {
    r: abs5.r,
    g: abs5.g,
    b: abs5.b,
    alpha: abs5.opacity
  };
};
function fromLibrary2(rgb, parsingOptions = {}) {
  if (parsingOptions.scalar) return {
    r: rgb.r / 255,
    g: rgb.g / 255,
    b: rgb.b / 255,
    opacity: rgb.alpha ?? 1,
    unit: `scalar`,
    space: `srgb`
  };
  else return {
    r: rgb.r,
    g: rgb.g,
    b: rgb.b,
    opacity: rgb.alpha ?? 255,
    unit: `8bit`,
    space: `srgb`
  };
}
var to8bit2 = (rgbOrString) => {
  if (typeof rgbOrString === `string`) return fromCss2(rgbOrString, { scalar: false });
  if (isHsl2(rgbOrString)) return to8bit2(fromLibrary2(toLibraryRgb2(rgbOrString), { scalar: false }));
  guard$33(rgbOrString);
  if (rgbOrString.unit === `8bit`) return rgbOrString;
  return {
    r: rgbOrString.r * 255,
    g: rgbOrString.g * 255,
    b: rgbOrString.b * 255,
    opacity: (rgbOrString.opacity ?? 1) * 255,
    unit: `8bit`,
    space: `srgb`
  };
};
var toScalar3 = (rgbOrString) => {
  if (typeof rgbOrString === `string`) return fromCss2(rgbOrString, { scalar: true });
  if (isHsl2(rgbOrString)) return toScalar3(fromLibrary2(toLibraryRgb2(rgbOrString), { scalar: true }));
  guard$33(rgbOrString);
  if (rgbOrString.unit === `scalar`) return rgbOrString;
  return {
    r: rgbOrString.r / 255,
    g: rgbOrString.g / 255,
    b: rgbOrString.b / 255,
    opacity: (rgbOrString.opacity ?? 1) / 255,
    unit: `scalar`,
    space: `srgb`
  };
};
var guard$33 = (rgb) => {
  const { r: r5, g: g4, b: b3, opacity: opacity2, space, unit } = rgb;
  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${space}`);
  if (unit === `8bit`) resultThrow(numberInclusiveRangeTest(r5, 0, 255, `r`), numberInclusiveRangeTest(g4, 0, 255, `g`), numberInclusiveRangeTest(b3, 0, 255, `b`), () => {
    if (typeof opacity2 === `number`) return numberInclusiveRangeTest(opacity2, 0, 255, `opacity`);
  });
  else if (unit === `scalar`) resultThrow(numberTest(r5, `percentage`, `r`), numberTest(g4, `percentage`, `g`), numberTest(b3, `percentage`, `b`), () => {
    if (typeof opacity2 === `number`) return numberTest(opacity2, `percentage`, `opacity`);
  });
  else throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${unit}`);
};
var changeLightness2 = (rgb, amount) => {
  let newL = 0;
  const co2 = new index_default(toCssString$12(rgb));
  const scalarUnit = rgb.unit === `scalar`;
  if (typeof amount.pdelta !== `undefined`) newL = co2.oklab.l + co2.oklab.l * amount.pdelta;
  else if (typeof amount.delta !== `undefined`) newL = co2.oklab.l + amount.delta;
  else if (typeof amount.fixed !== `undefined`) {
    if (amount.fixed < 0) throw new TypeError(`Amount cannot be negative when using 'fixed'`);
    newL = amount.fixed;
  } else throw new TypeError(`Parameter 'amount' is missing 'pdelta/delta/fixed' properties`);
  if (newL < 0) newL = 0;
  else if (newL > 1) newL = 1;
  const rgbResult = oklab2rgb({
    a: co2.oklab.a,
    b: co2.oklab.b,
    l: newL,
    alpha: co2.oklab.alpha
  });
  return fromLibrary2(rgbResult, { scalar: scalarUnit });
};
function lightness2(rgb) {
  const co2 = new index_default(toCssString$12(rgb));
  return co2.oklab.l;
}
function eightBit2(red = 100, green = 100, blue = 100, opacity2 = 255) {
  const rgb = {
    unit: `8bit`,
    space: `srgb`,
    r: red,
    g: green,
    b: blue,
    opacity: opacity2
  };
  guard$33(rgb);
  return rgb;
}
function scalar$12(red = 0.5, green = 0.5, blue = 0.5, opacity2 = 1) {
  const rgb = {
    unit: `scalar`,
    space: `srgb`,
    r: red,
    g: green,
    b: blue,
    opacity: opacity2
  };
  guard$33(rgb);
  return rgb;
}
function parseCssRgbFunction2(value3) {
  if (value3.startsWith(`rgba`)) throw new Error(`RGBA is not supported`);
  if (!value3.startsWith(`rgb(`)) throw new Error(`Expected rgb(..) CSS colour`);
  const start = value3.indexOf("(");
  const end = value3.indexOf(")");
  if (end < start) throw new Error(`Is rgb() not terminated? Missing ')'`);
  const part = value3.substring(start + 1, end);
  let split = part.split(/[\s,]+/);
  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${split.length} length`);
  let relativeCount = 0;
  for (const s3 of split) if (s3.endsWith("%")) relativeCount++;
  const valueAsScalar = (v3, pos) => {
    if (v3.endsWith(`%`)) return Number.parseFloat(v3.substring(0, v3.length - 1)) / 100;
    if (pos < 3) return Number.parseFloat(v3) / 255;
    else return Number.parseFloat(v3);
  };
  const valueAs8bit = (v3, pos) => {
    if (v3.endsWith(`%`)) return Number.parseFloat(v3.substring(0, v3.length - 1)) / 100 * 255;
    if (pos < 3) return Number.parseFloat(v3);
    else return Number.parseFloat(v3) * 255;
  };
  if (split.length > 3) {
    if (split[3] === "/") split = [
      split[0],
      split[1],
      split[2],
      split[4]
    ];
  }
  if (relativeCount > 1) return scalar$12(valueAsScalar(split[0], 0), valueAsScalar(split[1], 1), valueAsScalar(split[2], 2), valueAsScalar(split[3] ?? `1`, 3));
  else return eightBit2(valueAs8bit(split[0], 0), valueAs8bit(split[1], 1), valueAs8bit(split[2], 2), valueAs8bit(split[3] ?? `1`, 3));
}
var interpolator$12 = (colourA, colourB) => {
  const aa2 = toScalar3(colourA);
  const bb = toScalar3(colourB);
  const aOpacity = aa2.opacity ?? 1;
  const opacityDistance = (bb.opacity ?? 1) - aOpacity;
  const r5 = bb.r - aa2.r;
  const g4 = bb.g - aa2.g;
  const b3 = bb.b - aa2.b;
  return (amount) => {
    amount = clamp(amount);
    return scalar$12(aa2.r + interpolate(amount, 0, r5), aa2.g + interpolate(amount, 0, g4), aa2.b + interpolate(amount, 0, b3), aOpacity + interpolate(amount, 0, opacityDistance));
  };
};
function toLibraryHsl2(rgb) {
  if (typeof rgb === `string`) {
    const parseResult = fromCss2(rgb, { scalar: false });
    return toLibraryHsl2(parseResult);
  }
  rgb = to8bit2(rgb);
  const hsl = rgb2hsl({
    r: rgb.r,
    g: rgb.g,
    b: rgb.b
  });
  return {
    ...hsl,
    alpha: (rgb.opacity ?? 255) / 255
  };
}
var image_data_grid_exports2 = {};
__export(image_data_grid_exports2, {
  accessor: () => accessor2,
  byColumn: () => byColumn2,
  byRow: () => byRow2,
  grid: () => grid$12,
  setter: () => setter2,
  wrap: () => wrap6
});
var grid$12 = (image) => {
  const g4 = {
    rows: image.width,
    cols: image.height
  };
  return g4;
};
var wrap6 = (image) => {
  return {
    ...grid$12(image),
    get: accessor2(image),
    set: setter2(image)
  };
};
var accessor2 = (image) => {
  const g4 = grid$12(image);
  const data = image.data;
  const fn2 = (cell, bounds = `undefined`) => {
    const index = indexFromCell(g4, cell, bounds);
    if (index === void 0) return;
    const pxIndex = index * 4;
    return {
      r: data[pxIndex],
      g: data[pxIndex + 1],
      b: data[pxIndex + 2],
      opacity: data[pxIndex + 3],
      unit: `8bit`,
      space: `srgb`
    };
  };
  return fn2;
};
var setter2 = (image) => {
  const g4 = grid$12(image);
  const data = image.data;
  const fn2 = (value3, cell, bounds = `undefined`) => {
    const index = indexFromCell(g4, cell, bounds);
    if (index === void 0) throw new Error(`Cell out of range. ${cell.x},${cell.y}`);
    const pixel = to8bit2(value3);
    const pxIndex = index * 4;
    data[pxIndex] = pixel.r;
    data[pxIndex + 1] = pixel.g;
    data[pxIndex + 2] = pixel.b;
    data[pxIndex + 3] = pixel.opacity ?? 255;
  };
  return fn2;
};
function* byRow2(image) {
  const a3 = accessor2(image);
  const g4 = grid$12(image);
  const v3 = rows(g4, {
    x: 0,
    y: 0
  });
  for (const row of v3) {
    const pixels = row.map((p3) => a3(p3, `undefined`));
    yield pixels;
  }
}
function* byColumn2(image) {
  const a3 = accessor2(image);
  const g4 = grid$12(image);
  for (let x3 = 0; x3 < g4.cols; x3++) {
    const col = [];
    for (let y3 = 0; y3 < g4.rows; y3++) {
      const p3 = a3({
        x: x3,
        y: y3
      }, `undefined`);
      if (p3) col.push(p3);
    }
    yield col;
  }
}
var piPi4 = Math.PI * 2;
var CanvasSource2 = class {
  #canvasEl;
  #ctx;
  #sizeBasis;
  #sizeScaler;
  #logicalSize;
  #pixelScaling;
  #regions = [];
  constructor(canvasElementOrQuery, sizeBasis = `min`) {
    this.#canvasEl = resolveEl2(canvasElementOrQuery);
    this.#sizeBasis = sizeBasis;
    this.#pixelScaling = window.devicePixelRatio || 1;
    this.#sizeScaler = this.#createSizeScaler();
    this.#logicalSize = this.setLogicalSize({
      width: this.#canvasEl.width,
      height: this.#canvasEl.height
    });
  }
  /**
  * Set logical size for region
  * @param size
  * @returns 
  */
  setLogicalSize(size) {
    this.#logicalSize = size;
    const el2 = this.#canvasEl;
    el2.width = size.width * this.#pixelScaling;
    el2.height = size.height * this.#pixelScaling;
    el2.style.width = `${size.width.toString()}px`;
    el2.style.height = `${size.height.toString()}px`;
    this.#sizeScaler = this.#createSizeScaler();
    this.invalidateContext();
    return size;
  }
  #createSizeScaler() {
    let inMax = 1;
    switch (this.#sizeBasis) {
      case `min`:
        inMax = Math.min(this.#canvasEl.width, this.#canvasEl.height);
        break;
      case `max`:
        inMax = Math.max(this.#canvasEl.width, this.#canvasEl.height);
        break;
    }
    const s3 = scalerTwoWay(0, inMax, 0, 1);
    return {
      abs: s3.in,
      rel: s3.out
    };
  }
  /**
  * Causes drawing context to be re-created
  */
  invalidateContext() {
    this.#ctx = void 0;
  }
  #add(region) {
    if (!region) throw new Error(`Param 'region' is undefined/null`);
    if (this.#regions.includes(region)) throw new Error(`Region already exists`);
    this.#regions.push(region);
    return region;
  }
  /**
  * Convert relative to absolute
  * @param pt 
  * @param kind 
  * @returns 
  */
  toAbsPoint(pt2, kind = `independent`) {
    let { x: x3, y: y3 } = pt2;
    switch (kind) {
      case `independent`:
        x3 *= this.width;
        y3 *= this.height;
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Gets the offset x,y
  */
  get offset() {
    const b3 = this.#canvasEl.getBoundingClientRect();
    return {
      x: b3.left,
      y: b3.top
    };
  }
  /**
  * Converts an absolute point to relative
  * @param pt 
  * @param source 
  * @param kind 
  * @param clamped 
  * @returns 
  */
  toRelPoint(pt2, source, kind = `independent`, clamped = true) {
    let { x: x3, y: y3 } = pt2;
    if (source === `screen`) {
      const b3 = this.#canvasEl.getBoundingClientRect();
      x3 -= b3.x;
      y3 -= b3.y;
    }
    switch (kind) {
      case `independent`:
        x3 /= this.width;
        y3 /= this.height;
        break;
      case `skip`:
        break;
    }
    if (clamped) {
      x3 = clamp(x3);
      y3 = clamp(y3);
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Converts a rectangle to absolute coordinates
  * @param rect 
  * @param kind 
  * @returns 
  */
  toAbsRect(rect$1, kind = `independent`) {
    let { width, height: height3 } = rect$1;
    switch (kind) {
      case `independent`:
        width *= this.width;
        height3 *= this.height;
        if (isRectPositioned(rect$1)) return {
          ...this.toAbsPoint(rect$1),
          width,
          height: height3
        };
    }
    return {
      width,
      height: height3
    };
  }
  /**
  * Creates a region
  * 
  * Absolute positioned. Uses source coordinates which don't change
  * ```js
  * source.createRegion({ 
  *  absPositioned: { x: 0, y: 0, width: 100, height: 100} 
  * });
  * ```
  * 
  * Relative positioned. Uses coordiantes relative to source dimensions.
  * Updated if source changes.
  * ```js
  * source.createRegion({
  *  relativePositioned: { x: 0, y:0, width: 1, height: 0.5 },
  *  scale: `independent`
  * });
  * ```
  * 
  * Relative sized. Uses size relative to source dimension. By default centers.
  * ```js
  * source.createRegion({
  *  relativeSize: { width: 0.5, height: 0.5 }
  *  position: `center`
  * })
  * ```
  * @param spec 
  * @returns 
  */
  createRegion(spec) {
    const marginPx = spec.marginPx ?? 0;
    const marginPx2 = marginPx * 2;
    if (`absPositioned` in spec) {
      const rect$1 = subtractSize(spec.absPositioned, marginPx, marginPx);
      return this.#add(new CanvasRegion2(this, () => rect$1));
    }
    if (`relativePositioned` in spec) {
      let compute;
      const rect$1 = spec.relativePositioned;
      switch (spec.scale) {
        case `independent`:
          compute = (source) => ({
            x: rect$1.x * source.width + marginPx,
            y: rect$1.y * source.height + marginPx,
            width: rect$1.width * source.width - marginPx2,
            height: rect$1.height * source.height - marginPx2
          });
          break;
        default:
          throw new Error(`Param 'kind' unknown (${spec.scale})`);
      }
      return this.#add(new CanvasRegion2(this, compute));
    }
    if (`relativeSize` in spec) {
      let compute;
      const rect$1 = spec.relativeSize;
      const position = spec.position;
      switch (spec.scale) {
        case `independent`:
          compute = (source) => {
            const width = rect$1.width * source.width - marginPx2;
            const height3 = rect$1.height * source.height - marginPx2;
            let x3 = source.width / 2 - width / 2;
            let y3 = source.height / 2 - height3 / 2;
            switch (position) {
              case `n`:
                y3 = 0;
                break;
              case `s`:
                y3 = source.height - height3;
                break;
              default:
            }
            x3 += marginPx;
            y3 += marginPx;
            return {
              width,
              height: height3,
              x: x3,
              y: y3
            };
          };
          break;
        default:
          throw new Error(`Param 'kind' unknown (${spec.scale})`);
      }
      return this.#add(new CanvasRegion2(this, compute));
    }
    if (`match` in spec) {
      const result = resolveElementTry(spec.match);
      if (!result.success) throw new Error(`Could not resolve match element. ${resultErrorToString(result)}`);
      const compute = (_source) => {
        const bounds = result.value.getBoundingClientRect();
        return {
          x: bounds.x + marginPx,
          y: bounds.y + marginPx,
          width: bounds.width - marginPx2,
          height: bounds.height - marginPx2
        };
      };
      return this.#add(new CanvasRegion2(this, compute));
    }
    throw new Error(`Spec doesn't seem valid`);
  }
  /**
  * Clears the region of the canvas
  */
  clear() {
    const c5 = this.context;
    c5.clearRect(0, 0, this.width, this.height);
  }
  /**
  * Gets - or creates - the drawing context
  */
  get context() {
    if (this.#ctx) return this.#ctx;
    const c5 = this.#canvasEl.getContext(`2d`);
    if (!c5) throw new Error(`Could not create 2d context`);
    c5.setTransform(1, 0, 0, 1, 0, 0);
    c5.scale(this.#pixelScaling, this.#pixelScaling);
    this.#ctx = c5;
    for (const r5 of this.#regions) r5.recomputeRegion();
    return this.#ctx;
  }
  /**
  * Gets a scaler for size
  */
  get sizeScaler() {
    return this.#sizeScaler;
  }
  /**
  * Gets the logical width
  */
  get width() {
    return this.#logicalSize.width;
  }
  /**
  * Gets the logical height
  */
  get height() {
    return this.#logicalSize.height;
  }
};
var CanvasRegion2 = class {
  source;
  #regionCompute;
  #r;
  /**
  * Creates, using coordinate in canvas coordinates
  */
  constructor(source, regionCompute) {
    this.source = source;
    this.#regionCompute = regionCompute;
    this.#r = regionCompute(source);
  }
  /**
  * Calls the original `regionCompute` function passed in to the constructor
  * to recompute the absolute region
  */
  recomputeRegion() {
    this.#r = this.#regionCompute(this.source);
  }
  /**
  * Converts a region-relative point (0..1) to an absolute
  * point, which uses region-relative coordinates.
  * 
  * Eg if the region had an x,y of 100,100, `toAbsRegion({x:0,y:0})`
  * will return 0,0.
  *
  * @param regionRel 
  * @param scaleBy 
  * @returns 
  */
  toAbsRegion(regionRel, scaleBy = `both`) {
    switch (scaleBy) {
      case `both`:
        return {
          x: regionRel.x * this.#r.width,
          y: regionRel.y * this.#r.height
        };
    }
  }
  /**
  * Returns a copy of `p` offset by the region's x & y
  * @param p 
  * @returns 
  */
  applyRegionOffset(p3) {
    return {
      x: p3.x + this.#r.x,
      y: p3.y + this.#r.y
    };
  }
  /**
  * Draws a line from a series of points.
  * Assumes region-relative, % coordinates (ie 0..1 scale)
  * @param relativePoints Points to connect, in region-relative coordinates
  * @param strokeStyle Stroke style
  * @param lineWidth Line with
  */
  drawConnectedPointsRelative(relativePoints, strokeStyle, lineWidth = 1) {
    const points = relativePoints.map((p3) => this.toAbsRegion(p3));
    this.drawConnectedPoints(points, strokeStyle, lineWidth);
  }
  /**
  * Draws connected points in absolute coordinates,
  * however with 0,0 being the top-left of the region.
  * 
  * Thus, this will apply the region offset before drawing.
  * @param points Points to draw
  * @param strokeStyle Stroke style
  * @param lineWidth Line width
  */
  drawConnectedPoints(points, strokeStyle, lineWidth = 1) {
    const c5 = this.context;
    c5.save();
    c5.translate(this.#r.x, this.#r.y);
    c5.beginPath();
    c5.strokeStyle = strokeStyle;
    c5.lineWidth = lineWidth;
    for (let index = 0; index < points.length; index++) if (index === 0) c5.moveTo(points[index].x, points[index].y);
    else c5.lineTo(points[index].x, points[index].y);
    c5.stroke();
    c5.restore();
  }
  /**
  * Fills text at a relative position
  * @param text 
  * @param relPos Relative, meaning 0.5,0.5 is the middle of the region
  * @param fillStyle 
  * @param baseline 
  * @param align 
  */
  fillTextRelative(text$1, relPos, fillStyle = `black`, font, baseline = `alphabetic`, align = `start`) {
    const point3 = this.toAbsRegion(relPos);
    this.fillTextRelative(text$1, point3, fillStyle, font, baseline, align);
  }
  /**
  * Fills text at a region-relative position
  * @param text 
  * @param point Region relative, meaning 0,0 is top-left of region
  * @param fillStyle 
  * @param baseline 
  * @param align 
  */
  fillText(text$1, point3, fillStyle = `black`, font, baseline = `alphabetic`, align = `start`) {
    const c5 = this.context;
    c5.save();
    c5.translate(this.#r.x, this.#r.y);
    if (font.length > 0) c5.font = font;
    c5.textBaseline = baseline;
    c5.textAlign = align;
    c5.fillStyle = fillStyle;
    c5.fillText(text$1, point3.x, point3.y);
    c5.restore();
  }
  drawCircles(relativeCircles, fillStyle, strokeStyle = ``, lineWidth = 1) {
    const circles = relativeCircles.map((c$1) => {
      return {
        ...this.toAbsRegion(c$1),
        radius: this.source.sizeScaler.abs(c$1.radius)
      };
    });
    const c5 = this.context;
    c5.save();
    c5.translate(this.#r.x, this.#r.y);
    c5.fillStyle = fillStyle;
    c5.strokeStyle = strokeStyle;
    c5.lineWidth = lineWidth;
    for (const circle$2 of circles) {
      c5.beginPath();
      c5.arc(circle$2.x, circle$2.y, circle$2.radius, 0, piPi4);
      c5.closePath();
      if (fillStyle.length > 0) c5.fill();
      if (strokeStyle.length > 0) c5.stroke();
    }
    c5.restore();
  }
  /**
  * Clears the region
  */
  clear() {
    const c5 = this.context;
    c5.clearRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);
  }
  /**
  * Fills the region
  * @param fillStyle
  */
  fill(fillStyle = `white`) {
    const c5 = this.context;
    c5.fillStyle = fillStyle;
    c5.fillRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);
  }
  /**
  * For debugging, draws an outline of the bounds
  * @param strokeStyle 
  * @param lineWidth 
  */
  drawBounds(strokeStyle, lineWidth = 1) {
    this.drawConnectedPointsRelative([
      {
        x: 0,
        y: 0
      },
      {
        x: 1,
        y: 0
      },
      {
        x: 1,
        y: 1
      },
      {
        x: 0,
        y: 1
      },
      {
        x: 0,
        y: 0
      }
    ], strokeStyle, lineWidth);
    this.drawConnectedPointsRelative([{
      x: 0,
      y: 1
    }, {
      x: 1,
      y: 0
    }], strokeStyle, lineWidth);
    this.drawConnectedPointsRelative([{
      x: 0,
      y: 0
    }, {
      x: 1,
      y: 1
    }], strokeStyle, lineWidth);
  }
  /**
  * Converts a  point to a region-relative one.
  * @param pt 
  * @param kind 
  * @returns 
  */
  toRelPoint(pt2, source = `screen`, kind = `independent`, clamped = true) {
    pt2 = this.source.toRelPoint(pt2, source, `skip`, false);
    let { x: x3, y: y3 } = pt2;
    x3 -= this.x;
    y3 -= this.y;
    switch (kind) {
      case `independent`:
        x3 /= this.width;
        y3 /= this.height;
    }
    if (clamped) {
      x3 = clamp(x3);
      y3 = clamp(y3);
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Converts absolute to region point
  * @param pt 
  * @param source 
  * @param clamped 
  * @returns 
  */
  absToRegionPoint(pt2, source, clamped) {
    if (source === `screen`) pt2 = subtract(pt2, this.source.offset);
    let { x: x3, y: y3 } = pt2;
    x3 -= this.x;
    y3 -= this.y;
    if (clamped) {
      if (x3 < 0) x3 = 0;
      if (y3 < 0) y3 = 0;
      if (x3 > this.width + this.x) x3 = this.x + this.width;
      if (y3 > this.height + this.y) y3 = this.y + this.height;
    }
    return {
      x: x3,
      y: y3
    };
  }
  /**
  * Get center of region
  */
  get center() {
    return center$1(this.#r);
  }
  /**
  * Gets the drawing context
  */
  get context() {
    return this.source.context;
  }
  /**
  * SEts the region
  */
  set region(value3) {
    this.#r = value3;
  }
  /**
  * Gets the region
  */
  get region() {
    return this.#r;
  }
  /**
  * Gets the width
  */
  get width() {
    return this.#r.width;
  }
  /**
  * Gets the height
  */
  get height() {
    return this.#r.height;
  }
  /**
  * Gets the x offset
  */
  get x() {
    return this.#r.x;
  }
  /**
  * Gets they y offset
  */
  get y() {
    return this.#r.y;
  }
  /**
  * Gets the width/height, whichever is smaller
  */
  get dimensionMin() {
    return Math.min(this.#r.width, this.#r.height);
  }
};
var applyOpts2 = (elem, opts) => {
  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);
  if (opts.opacity) elem.setAttributeNS(null, `opacity`, opts.opacity.toString());
};
var getBounds2 = (svg) => {
  const w3 = svg.getAttributeNS(null, `width`);
  const width = w3 === null ? 0 : Number.parseFloat(w3);
  const h5 = svg.getAttributeNS(null, `height`);
  const height3 = h5 === null ? 0 : Number.parseFloat(h5);
  return {
    width,
    height: height3
  };
};
var setBounds2 = (svg, bounds) => {
  svg.setAttributeNS(null, `width`, bounds.width.toString());
  svg.setAttributeNS(null, `height`, bounds.height.toString());
};
var createEl2 = (type, id) => {
  const m4 = document.createElementNS(`http://www.w3.org/2000/svg`, type);
  if (id) m4.id = id;
  return m4;
};
var createOrResolve2 = (parent, type, queryOrExisting, suffix) => {
  let existing = null;
  if (queryOrExisting !== void 0) existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;
  if (existing === null) {
    const p3 = document.createElementNS(`http://www.w3.org/2000/svg`, type);
    parent.append(p3);
    if (queryOrExisting && typeof queryOrExisting === `string` && queryOrExisting.startsWith(`#`)) p3.id = suffix !== void 0 && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);
    return p3;
  }
  return existing;
};
var goldenAngleColour2 = (index, saturation = 0.5, lightness$1 = 0.75, alpha = 1) => {
  resultThrow(numberTest(index, `positive`, `index`), numberTest(saturation, `percentage`, `saturation`), numberTest(lightness$1, `percentage`, `lightness`), numberTest(alpha, `percentage`, `alpha`));
  const hueDeg = index * 137.508;
  const hueRel = hueDeg % 360 / 360;
  return toCssString2(scalar2(hueRel, saturation, lightness$1, alpha));
};
var randomHue2 = (rand = Math.random) => rand() * 360;
function multiplyOpacity$1(colourish, amount) {
  return withOpacity2(colourish, (o5) => clamp(o5 * amount));
}
function withOpacity2(colourish, fn2) {
  const colour = toColour2(colourish);
  let result;
  switch (colour.space) {
    case `hsl`:
      result = withOpacity$32(colour, fn2);
      break;
    case `srgb`:
      result = withOpacity$12(colour, fn2);
      break;
    case `oklch`:
      result = withOpacity$22(colour, fn2);
      break;
    default:
      throw new Error(`Unknown space: '${colour.space}'. Expected hsl, srgb, oklch`);
  }
  if (!result) throw new Error(`Is colour in correct form?`);
  if (typeof colourish === `string`) return toCssColour2(result);
  return result;
}
function setOpacity2(colourish, opacity2) {
  const colour = toColour2(colourish);
  colour.opacity = opacity2;
  if (typeof colourish === `string`) return toCssColour2(colour);
  return colour;
}
function interpolateInit2(colours, destination = `hsl`) {
  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${typeof colours}`);
  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${colours.length}`);
  const c5 = colours.map((colour) => convertScalar2(colour, destination));
  return [...pairwise(c5)];
}
var cssLinearGradient2 = (colours) => {
  const c5 = colours.map((c$1) => toCssColour2(c$1));
  return `linear-gradient(to right, ${c5.join(`, `)})`;
};
var interpolator3 = (colourA, colourB, options = {}) => {
  const space = options.space ?? `oklch`;
  const direction = options.direction ?? `shorter`;
  let inter;
  switch (space) {
    case `hsl`:
      inter = interpolator$32(convert$12(colourA, `hsl-scalar`), convert$12(colourB, `hsl-scalar`), direction);
      break;
    case `srgb`:
      inter = interpolator$12(convert$12(colourA, `srgb-scalar`), convert$12(colourB, `srgb-scalar`));
      break;
    default:
      inter = interpolator$22(convert$12(colourA, `oklch-scalar`), convert$12(colourB, `oklch-scalar`), direction);
  }
  return (amount) => toCssColour2(inter(amount));
};
var scale3 = (colours, opts = {}) => {
  const direction = opts.direction ?? `shorter`;
  const space = opts.space ?? `oklch`;
  const pieces = interpolateInit2(colours, space);
  let stepsBetween = 0;
  if (typeof opts.stepsBetween === `number`) {
    stepsBetween = opts.stepsBetween;
    if (stepsBetween < 1) throw new Error(`Param 'stepsBetween' must be at least 1`);
  } else if (typeof opts.stepsTotal === `number`) {
    if (opts.stepsTotal <= colours.length) throw new Error(`Param 'stepsTotal' must be greater than number of provided colour stops (${colours.length}) +1 per stop`);
    const totalSteps = opts.stepsTotal - colours.length;
    stepsBetween = Math.floor(totalSteps / pieces.length);
  }
  const steps = pieces.map((piece) => {
    const pieceSteps = createSteps2(piece[0], piece[1], {
      steps: stepsBetween,
      space,
      direction,
      exclusive: true
    });
    pieceSteps.push(piece[1]);
    return pieceSteps;
  });
  const firstPiece = pieces[0];
  steps.unshift([firstPiece[0]]);
  return steps.flat().map((c5) => toCssColour2(c5));
};
function createSteps2(a3, b3, options = {}) {
  const exclusive = options.exclusive ?? false;
  const steps = options.steps ?? 5;
  const space = options.space ?? `oklch`;
  const direction = options.direction ?? `shorter`;
  if (!exclusive && steps < 2) throw new Error(`Param 'steps' should be at least 2 when 'exclusive' is false`);
  if (exclusive && steps < 1) throw new Error(`Param 'steps' should be at least 1 when 'exlusive' is true`);
  const aa2 = convertScalar2(a3, space);
  const bb = convertScalar2(b3, space);
  let inter;
  switch (space) {
    case `hsl`:
      inter = interpolator$32(aa2, bb, direction);
      break;
    case `oklch`:
      inter = interpolator$22(aa2, bb, direction);
      break;
    case `srgb`:
      inter = interpolator$12(aa2, bb);
      break;
    default:
      throw new Error(`Colour space '${space}' not supported for interpolation.`);
  }
  if (!inter) throw new Error(`Could not create interpolator for space: ${space}`);
  let stepBy = 0;
  let startAt = 0;
  let endAt = 1;
  if (exclusive) {
    stepBy = 1 / (steps + 1);
    startAt = stepBy;
    endAt = 1 - stepBy;
  } else stepBy = 1 / (steps - 1);
  const results = [];
  for (let interpolateAmount = startAt; interpolateAmount <= endAt; interpolateAmount += stepBy) results.push(inter(interpolateAmount));
  return results;
}
var colour_exports2 = {};
__export(colour_exports2, {
  HslSpace: () => hsl_exports2,
  OklchSpace: () => oklch_exports2,
  SrgbSpace: () => srgb_exports2,
  convert: () => convert$12,
  convertScalar: () => convertScalar2,
  convertToString: () => convertToString2,
  createSteps: () => createSteps2,
  cssDefinedHexColours: () => cssDefinedHexColours2,
  cssLinearGradient: () => cssLinearGradient2,
  fromCssColour: () => fromCssColour2,
  goldenAngleColour: () => goldenAngleColour2,
  guard: () => guard$23,
  interpolator: () => interpolator3,
  isColourish: () => isColourish2,
  isHsl: () => isHsl2,
  isOkLch: () => isOkLch2,
  isRgb: () => isRgb2,
  multiplyOpacity: () => multiplyOpacity$1,
  randomHue: () => randomHue2,
  resolveCss: () => resolveCss2,
  rgbToHsl: () => rgbToHsl2,
  scale: () => scale3,
  setOpacity: () => setOpacity2,
  toColour: () => toColour2,
  toCssColour: () => toCssColour2,
  toHexColour: () => toHexColour2,
  toLibraryColour: () => toLibraryColour2,
  toStringFirst: () => toStringFirst2,
  tryParseObjectToHsl: () => tryParseObjectToHsl2,
  tryParseObjectToRgb: () => tryParseObjectToRgb2,
  withOpacity: () => withOpacity2
});
function convert$12(colour, destination) {
  if (destination === `hsl-scalar`) {
    if (typeof colour === `string` || isHsl2(colour) || isRgb2(colour)) return toScalar$22(colour);
  } else if (destination === `hsl-absolute`) {
    if (typeof colour === `string` || isHsl2(colour)) return toAbsolute$12(colour);
  } else if (destination === `oklch-scalar`) {
    if (typeof colour === `string` || isOkLch2(colour)) return toScalar$12(colour);
  } else if (destination === `oklch-absolute`) {
    if (typeof colour === `string` || isOkLch2(colour)) return toAbsolute3(colour);
  } else if (destination === `srgb-8bit`) {
    if (typeof colour === `string` || isRgb2(colour)) return to8bit2(colour);
  } else if (destination === `srgb-scalar`) {
    if (typeof colour === `string` || isRgb2(colour)) return toScalar3(colour);
  } else throw new Error(`Destination '${destination}' not supported for input: ${JSON.stringify(colour)}`);
  return convert$12(toCssColour2(colour), destination);
}
function convertToString2(colour, destination) {
  const c5 = convert$12(colour, destination);
  return toCssColour2(c5);
}
function convertScalar2(colour, destination) {
  if (destination === `oklch`) return convert$12(colour, `oklch-scalar`);
  if (destination === `srgb`) return convert$12(colour, `srgb-scalar`);
  if (destination === `hsl`) return convert$12(colour, `hsl-scalar`);
  throw new Error(`Unknown destination: '${destination}'`);
}
var toCssColour2 = (colour) => {
  if (typeof colour === `string`) return colour;
  if (isHsl2(colour)) return toCssString2(colour);
  if (isRgb2(colour)) return toCssString$12(colour);
  if (isOkLch2(colour)) return toCssString$22(colour);
  const asRgb = tryParseObjectToRgb2(colour);
  if (asRgb) return toCssString$12(asRgb);
  const asHsl = tryParseObjectToHsl2(colour);
  if (asHsl) return toCssString2(asHsl);
  throw new Error(`Unknown colour format: '${JSON.stringify(colour)}'`);
};
var toHexColour2 = (colour) => {
  if (isHsl2(colour)) return toHexString$22(colour);
  if (isRgb2(colour)) return toHexString2(colour);
  if (isOkLch2(colour)) return toHexString$12(colour);
  if (typeof colour === `string`) {
    if (colour.startsWith(`#`)) return colour;
    const c5 = convert$12(colour, `srgb-8bit`);
    return toHexString2(c5);
  }
  const asRgb = tryParseObjectToRgb2(colour);
  if (asRgb) return toHexString2(asRgb);
  const asHsl = tryParseObjectToHsl2(colour);
  if (asHsl) return toHexString$22(asHsl);
  throw new Error(`Unknown colour format: '${JSON.stringify(colour)}'`);
};
var toLibraryColour2 = (colour) => {
  const asCss = toCssColour2(colour);
  return new index_default(asCss);
};
var guard$23 = (colour) => {
  switch (colour.space) {
    case `hsl`:
      guard$53(colour);
      break;
    case `srgb`:
      guard$33(colour);
      break;
    case `oklch`:
      guard$43(colour);
      break;
    default:
      throw new Error(`Unsupported colour space: '${colour.space}'`);
  }
};
var toColour2 = (colourish) => {
  if (!isColourish2(colourish)) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc. Got: ${JSON.stringify(colourish)}`);
  let c5;
  if (typeof colourish === `string`) c5 = fromCssColour2(colourish);
  else c5 = colourish;
  if (c5 === void 0) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);
  guard$23(c5);
  return c5;
};
var toStringFirst2 = (...colours) => {
  for (const colour of colours) {
    if (colour === void 0) continue;
    if (colour === null) continue;
    try {
      const c5 = toColour2(colour);
      return toCssColour2(c5);
    } catch {
    }
  }
  return `rebeccapurple`;
};
function rgbToHsl2(rgb, scalarResult) {
  let { r: r5, g: g4, b: b3 } = rgb;
  const opacity2 = rgb.opacity ?? 1;
  if (rgb.unit === `8bit`) {
    r5 /= 255;
    g4 /= 255;
    b3 /= 255;
  }
  const max4 = Math.max(r5, g4, b3);
  const min4 = Math.min(r5, g4, b3);
  let h5 = (max4 + min4) / 2;
  let s3 = h5;
  const l3 = h5;
  if (max4 === min4) if (scalarResult) return scalar2(0, 0, 0, opacity2);
  else return absolute$12(0, 0, 0, opacity2);
  const d3 = max4 - min4;
  s3 = l3 >= 0.5 ? d3 / (2 - (max4 + min4)) : d3 / (max4 + min4);
  switch (max4) {
    case r5:
      h5 = ((g4 - b3) / d3 + 0) * 60;
      break;
    case g4:
      h5 = ((b3 - r5) / d3 + 2) * 60;
      break;
    case b3:
      h5 = ((r5 - g4) / d3 + 4) * 60;
      break;
  }
  if (scalarResult) return scalar2(h5 / 360, s3, l3, opacity2);
  else return absolute$12(h5, s3 * 100, l3 * 100, opacity2);
}
var applyStrokeOpts2 = (elem, opts) => {
  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);
  if (opts.strokeWidth) elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());
  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);
  if (opts.strokeLineCap) elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);
};
var createMarker2 = (id, opts, childCreator) => {
  const m4 = createEl2(`marker`, id);
  if (opts.markerWidth) m4.setAttribute(`markerWidth`, opts.markerWidth?.toString());
  if (opts.markerHeight) m4.setAttribute(`markerHeight`, opts.markerHeight?.toString());
  if (opts.orient) m4.setAttribute(`orient`, opts.orient.toString());
  else m4.setAttribute(`orient`, `auto-start-reverse`);
  if (opts.viewBox) m4.setAttribute(`viewBox`, opts.viewBox.toString());
  if (opts.refX) m4.setAttribute(`refX`, opts.refX.toString());
  if (opts.refY) m4.setAttribute(`refY`, opts.refY.toString());
  if (childCreator) {
    const c5 = childCreator();
    m4.appendChild(c5);
  }
  return m4;
};
var markerPrebuilt2 = (elem, opts, _context) => {
  if (elem === null) return `(elem null)`;
  const parent = elem.ownerSVGElement;
  if (parent === null) throw new Error(`parent for elem is null`);
  const defsEl = createOrResolve2(parent, `defs`, `defs`);
  let defEl = defsEl.querySelector(`#${opts.id}`);
  if (defEl !== null) return `url(#${opts.id})`;
  if (opts.id === `triangle`) {
    opts = {
      ...opts,
      strokeStyle: `transparent`
    };
    if (!opts.markerHeight) opts = {
      ...opts,
      markerHeight: 6
    };
    if (!opts.markerWidth) opts = {
      ...opts,
      markerWidth: 6
    };
    if (!opts.refX) opts = {
      ...opts,
      refX: opts.markerWidth
    };
    if (!opts.refY) opts = {
      ...opts,
      refY: opts.markerHeight
    };
    if (!opts.fillStyle || opts.fillStyle === `none`) opts = {
      ...opts,
      fillStyle: `black`
    };
    if (!opts.viewBox) opts = {
      ...opts,
      viewBox: `0 0 10 10`
    };
    defEl = createMarker2(opts.id, opts, () => {
      const tri = createEl2(`path`);
      tri.setAttribute(`d`, `M 0 0 L 10 5 L 0 10 z`);
      if (opts) applyOpts2(tri, opts);
      return tri;
    });
  } else throw new Error(`Do not know how to make ${opts.id}`);
  defEl.id = opts.id;
  defsEl.appendChild(defEl);
  return `url(#${opts.id})`;
};
var applyPathOpts2 = (elem, opts) => {
  if (opts.markerEnd) elem.setAttribute(`marker-end`, markerPrebuilt2(elem, opts.markerEnd, opts));
  if (opts.markerStart) elem.setAttribute(`marker-start`, markerPrebuilt2(elem, opts.markerStart, opts));
  if (opts.markerMid) elem.setAttribute(`marker-mid`, markerPrebuilt2(elem, opts.markerMid, opts));
};
var elements_exports2 = {};
__export(elements_exports2, {
  circle: () => circle2,
  circleUpdate: () => circleUpdate2,
  grid: () => grid2,
  group: () => group2,
  groupUpdate: () => groupUpdate2,
  line: () => line2,
  lineUpdate: () => lineUpdate2,
  path: () => path2,
  pathUpdate: () => pathUpdate2,
  polarRayUpdate: () => polarRayUpdate2,
  text: () => text2,
  textPath: () => textPath2,
  textPathUpdate: () => textPathUpdate2,
  textUpdate: () => textUpdate2
});
var numberOrPercentage2 = (v3) => {
  if (v3 >= 0 && v3 <= 1) return `${v3 * 100}%`;
  return v3.toString();
};
var path2 = (svgOrArray, parent, opts, queryOrExisting) => {
  const elem = createOrResolve2(parent, `path`, queryOrExisting);
  const svg = typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`
`);
  elem.setAttributeNS(null, `d`, svg);
  parent.append(elem);
  return pathUpdate2(elem, opts);
};
var pathUpdate2 = (elem, opts) => {
  if (opts) applyOpts2(elem, opts);
  if (opts) applyStrokeOpts2(elem, opts);
  return elem;
};
var circleUpdate2 = (elem, circle$2, opts) => {
  elem.setAttributeNS(null, `cx`, circle$2.x.toString());
  elem.setAttributeNS(null, `cy`, circle$2.y.toString());
  elem.setAttributeNS(null, `r`, circle$2.radius.toString());
  if (opts) applyOpts2(elem, opts);
  if (opts) applyStrokeOpts2(elem, opts);
  return elem;
};
var circle2 = (circle$2, parent, opts, queryOrExisting) => {
  const p3 = createOrResolve2(parent, `circle`, queryOrExisting);
  return circleUpdate2(p3, circle$2, opts);
};
var group2 = (children3, parent, queryOrExisting) => {
  const p3 = createOrResolve2(parent, `g`, queryOrExisting);
  return groupUpdate2(p3, children3);
};
var groupUpdate2 = (elem, children3) => {
  for (const c5 of children3) if (c5.parentNode !== elem) elem.append(c5);
  return elem;
};
var line2 = (line$2, parent, opts, queryOrExisting) => {
  const lineEl = createOrResolve2(parent, `line`, queryOrExisting);
  return lineUpdate2(lineEl, line$2, opts);
};
var lineUpdate2 = (lineEl, line$2, opts) => {
  lineEl.setAttributeNS(null, `x1`, line$2.a.x.toString());
  lineEl.setAttributeNS(null, `y1`, line$2.a.y.toString());
  lineEl.setAttributeNS(null, `x2`, line$2.b.x.toString());
  lineEl.setAttributeNS(null, `y2`, line$2.b.y.toString());
  if (opts) applyOpts2(lineEl, opts);
  if (opts) applyPathOpts2(lineEl, opts);
  if (opts) applyStrokeOpts2(lineEl, opts);
  return lineEl;
};
var polarRayUpdate2 = (lineEl, ray, opts) => {
  const l3 = toCartesian$2(ray);
  lineEl.setAttributeNS(null, `x1`, l3.a.x.toString());
  lineEl.setAttributeNS(null, `y1`, l3.a.y.toString());
  lineEl.setAttributeNS(null, `x2`, l3.b.x.toString());
  lineEl.setAttributeNS(null, `y2`, l3.b.y.toString());
  if (opts) applyOpts2(lineEl, opts);
  if (opts) applyPathOpts2(lineEl, opts);
  if (opts) applyStrokeOpts2(lineEl, opts);
  return lineEl;
};
var textPathUpdate2 = (el2, text$1, opts) => {
  if (opts?.method) el2.setAttributeNS(null, `method`, opts.method);
  if (opts?.side) el2.setAttributeNS(null, `side`, opts.side);
  if (opts?.spacing) el2.setAttributeNS(null, `spacing`, opts.spacing);
  if (opts?.startOffset) el2.setAttributeNS(null, `startOffset`, numberOrPercentage2(opts.startOffset));
  if (opts?.textLength) el2.setAttributeNS(null, `textLength`, numberOrPercentage2(opts.textLength));
  if (text$1) el2.textContent = text$1;
  if (opts) applyOpts2(el2, opts);
  if (opts) applyStrokeOpts2(el2, opts);
  return el2;
};
var textPath2 = (pathReference, text$1, parent, opts, textQueryOrExisting, pathQueryOrExisting) => {
  const textEl = createOrResolve2(parent, `text`, textQueryOrExisting, `-text`);
  textUpdate2(textEl, void 0, void 0, opts);
  const p3 = createOrResolve2(textEl, `textPath`, pathQueryOrExisting);
  p3.setAttributeNS(null, `href`, pathReference);
  return textPathUpdate2(p3, text$1, opts);
};
var textUpdate2 = (el2, pos, text$1, opts) => {
  if (pos) {
    el2.setAttributeNS(null, `x`, pos.x.toString());
    el2.setAttributeNS(null, `y`, pos.y.toString());
  }
  if (text$1) el2.textContent = text$1;
  if (opts) {
    applyOpts2(el2, opts);
    if (opts) applyStrokeOpts2(el2, opts);
    if (opts.anchor) el2.setAttributeNS(null, `text-anchor`, opts.anchor);
    if (opts.align) el2.setAttributeNS(null, `alignment-baseline`, opts.align);
    const userSelect = opts.userSelect ?? true;
    if (!userSelect) el2.style.userSelect = `none`;
  }
  return el2;
};
var text2 = (text$1, parent, pos, opts, queryOrExisting) => {
  const p3 = createOrResolve2(parent, `text`, queryOrExisting);
  return textUpdate2(p3, pos, text$1, opts);
};
var grid2 = (parent, center$13, spacing, width, height3, opts = {}) => {
  if (!opts.strokeStyle) opts = {
    ...opts,
    strokeStyle: toStringFirst2(`bg-dim`, `silver`)
  };
  if (!opts.strokeWidth) opts = {
    ...opts,
    strokeWidth: 1
  };
  const g4 = createEl2(`g`);
  applyOpts2(g4, opts);
  applyPathOpts2(g4, opts);
  applyStrokeOpts2(g4, opts);
  let y3 = 0;
  while (y3 < height3) {
    const horiz = fromNumbers$1(0, y3, width, y3);
    line2(horiz, g4);
    y3 += spacing;
  }
  let x3 = 0;
  while (x3 < width) {
    const vert = fromNumbers$1(x3, 0, x3, height3);
    line2(vert, g4);
    x3 += spacing;
  }
  parent.append(g4);
  return g4;
};
var lineFromSvgLine2 = (el2) => {
  if (!el2) throw new Error(`Param 'el' is undefined`);
  const a3 = {
    x: el2.x1.baseVal.value,
    y: el2.y1.baseVal.value
  };
  const b3 = {
    x: el2.x2.baseVal.value,
    y: el2.y2.baseVal.value
  };
  return {
    a: a3,
    b: b3
  };
};
var polarRayFromSvgLine2 = (el2, origin) => {
  const l3 = lineFromSvgLine2(el2);
  return fromLine(l3, origin);
};
var remove5 = (parent, queryOrExisting) => {
  if (typeof queryOrExisting === `string`) {
    const elem = parent.querySelector(queryOrExisting);
    if (elem === null) return;
    elem.remove();
  } else queryOrExisting.remove();
};
var clear3 = (parent) => {
  let c5 = parent.lastElementChild;
  while (c5) {
    c5.remove();
    c5 = parent.lastElementChild;
  }
};
var makeHelper2 = (parent, parentOpts) => {
  if (parentOpts) {
    applyOpts2(parent, parentOpts);
    applyStrokeOpts2(parent, parentOpts);
  }
  const o5 = {
    remove: (queryOrExisting) => {
      remove5(parent, queryOrExisting);
    },
    text: (text$1, pos, opts, queryOrExisting) => text2(text$1, parent, pos, opts, queryOrExisting),
    textPath: (pathReference, text$1, opts, textQueryOrExisting, pathQueryOrExisting) => textPath2(pathReference, text$1, parent, opts, textQueryOrExisting, pathQueryOrExisting),
    line: (line$2, opts, queryOrExisting) => line2(line$2, parent, opts, queryOrExisting),
    circle: (circle$2, opts, queryOrExisting) => circle2(circle$2, parent, opts, queryOrExisting),
    path: (svgString, opts, queryOrExisting) => path2(svgString, parent, opts, queryOrExisting),
    grid: (center$13, spacing, width, height3, opts) => grid2(parent, center$13, spacing, width, height3, opts),
    query: (selectors) => parent.querySelector(selectors),
    get width() {
      const w3 = parent.getAttributeNS(null, `width`);
      if (w3 === null) return 0;
      return Number.parseFloat(w3);
    },
    set width(width) {
      parent.setAttributeNS(null, `width`, width.toString());
    },
    get parent() {
      return parent;
    },
    get height() {
      const w3 = parent.getAttributeNS(null, `height`);
      if (w3 === null) return 0;
      return Number.parseFloat(w3);
    },
    set height(height3) {
      parent.setAttributeNS(null, `height`, height3.toString());
    },
    clear: () => {
      while (parent.firstChild) parent.lastChild.remove();
    }
  };
  return o5;
};
var svg_exports2 = {};
__export(svg_exports2, {
  Elements: () => elements_exports2,
  applyOpts: () => applyOpts2,
  applyPathOpts: () => applyPathOpts2,
  applyStrokeOpts: () => applyStrokeOpts2,
  clear: () => clear3,
  createEl: () => createEl2,
  createMarker: () => createMarker2,
  createOrResolve: () => createOrResolve2,
  getBounds: () => getBounds2,
  lineFromSvgLine: () => lineFromSvgLine2,
  makeHelper: () => makeHelper2,
  markerPrebuilt: () => markerPrebuilt2,
  polarRayFromSvgLine: () => polarRayFromSvgLine2,
  remove: () => remove5,
  setBounds: () => setBounds2
});
var convolve_2d_exports2 = {};
__export(convolve_2d_exports2, {
  boxBlurKernel: () => boxBlurKernel2,
  convolve: () => convolve2,
  convolveCell: () => convolveCell2,
  convolveImage: () => convolveImage2,
  edgeDetectionKernel: () => edgeDetectionKernel2,
  gaussianBlur3Kernel: () => gaussianBlur3Kernel2,
  gaussianBlur5Kernel: () => gaussianBlur5Kernel2,
  identityKernel: () => identityKernel2,
  kernel2dToArray: () => kernel2dToArray2,
  multiply: () => multiply3,
  rgbReducer: () => rgbReducer2,
  sharpenKernel: () => sharpenKernel2,
  unsharpMasking5Kernel: () => unsharpMasking5Kernel2
});
var multiply3 = (kernel, scalar$3) => {
  const rows$1 = kernel.length;
  const cols = kernel[0].length;
  const copy = [];
  for (let row = 0; row < rows$1; row++) {
    copy[row] = [];
    for (let col = 0; col < cols; col++) copy[row][col] = kernel[row][col] * scalar$3;
  }
  return copy;
};
function convolveCell2(cell, kernel, source, reduce4) {
  const valuesAtKernelPos = kernel.map((o5) => {
    const pos = offset(source, cell, o5.cell, `stop`);
    let kernelValue;
    let sourceValue;
    if (pos) {
      sourceValue = source.get(pos, `undefined`);
      kernelValue = o5.value;
    }
    return {
      cell: o5.cell,
      value: sourceValue,
      kernel: o5.value
    };
  });
  return reduce4(valuesAtKernelPos);
}
function* convolveImage2(kernel, image) {
  const imageDataAsGrid = wrap6(image);
  yield* convolve2(kernel, imageDataAsGrid, cells(imageDataAsGrid), rgbReducer2);
}
function* convolve2(kernel, source, visitor, reduce4, origin) {
  if (!origin) {
    const kernelRows = kernel.length;
    const kernelCols = kernel[0].length;
    origin = {
      x: Math.floor(kernelRows / 2),
      y: Math.floor(kernelCols / 2)
    };
  }
  const asArray2 = kernel2dToArray2(kernel, origin);
  for (const cell of visitor) {
    const value3 = convolveCell2(cell, asArray2, source, reduce4);
    yield {
      cell,
      value: value3
    };
  }
}
var kernel2dToArray2 = (kernel, origin) => {
  const offsets = [];
  const rows$1 = kernel.length;
  const cols = kernel[0].length;
  if (!origin) origin = {
    x: Math.floor(rows$1 / 2),
    y: Math.floor(cols / 2)
  };
  for (let xx = 0; xx < rows$1; xx++) for (let yy = 0; yy < cols; yy++) {
    const v3 = {
      cell: {
        x: xx - origin.x,
        y: yy - origin.y
      },
      value: kernel[xx][yy]
    };
    offsets.push(v3);
  }
  return offsets;
};
var rgbReducer2 = (values3) => {
  let r5 = 0;
  let g4 = 0;
  let b3 = 0;
  let opacity2 = 0;
  for (const value3 of values3) {
    const rgb = value3.value;
    const kernelValue = value3.kernel;
    if (!rgb) continue;
    if (rgb.opacity === 0) continue;
    if (kernelValue === 0) continue;
    r5 += rgb.r * kernelValue;
    g4 += rgb.g * kernelValue;
    b3 += rgb.b * kernelValue;
    opacity2 += (rgb.opacity ?? 1) * kernelValue;
  }
  const result = {
    r: r5,
    g: g4,
    b: b3,
    unit: `8bit`,
    space: `srgb`,
    opacity: opacity2
  };
  return result;
};
var identityKernel2 = [
  [
    0,
    0,
    0
  ],
  [
    0,
    1,
    0
  ],
  [
    0,
    0,
    0
  ]
];
var edgeDetectionKernel2 = [
  [
    0,
    -1,
    0
  ],
  [
    -1,
    4,
    -1
  ],
  [
    0,
    -1,
    0
  ]
];
var sharpenKernel2 = [
  [
    0,
    -1,
    0
  ],
  [
    -1,
    5,
    -1
  ],
  [
    0,
    -1,
    0
  ]
];
var boxBlurKernel2 = multiply3([
  [
    1,
    1,
    1
  ],
  [
    1,
    1,
    1
  ],
  [
    1,
    1,
    1
  ]
], 1 / 9);
var gaussianBlur3Kernel2 = multiply3([
  [
    1,
    2,
    1
  ],
  [
    2,
    4,
    2
  ],
  [
    1,
    2,
    1
  ]
], 1 / 16);
var gaussianBlur5Kernel2 = multiply3([
  [
    1,
    4,
    6,
    4,
    1
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    6,
    24,
    36,
    24,
    6
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    1,
    4,
    6,
    4,
    1
  ]
], 1 / 256);
var unsharpMasking5Kernel2 = multiply3([
  [
    1,
    4,
    6,
    4,
    1
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    6,
    24,
    -476,
    24,
    6
  ],
  [
    4,
    16,
    24,
    16,
    4
  ],
  [
    1,
    4,
    6,
    4,
    1
  ]
], -1 / 256);
var named_colour_palette_exports2 = {};
__export(named_colour_palette_exports2, { create: () => create5 });
var create5 = (fallbacks) => new NamedColourPaletteImpl2(fallbacks);
var NamedColourPaletteImpl2 = class {
  #store = /* @__PURE__ */ new Map();
  #aliases = /* @__PURE__ */ new Map();
  fallbacks;
  #lastFallback = 0;
  #elementBase;
  constructor(fallbacks) {
    if (fallbacks !== void 0) this.fallbacks = fallbacks;
    else this.fallbacks = [
      `red`,
      `blue`,
      `green`,
      `orange`
    ];
    this.#elementBase = document.body;
  }
  setElementBase(el2) {
    this.#elementBase = el2;
  }
  add(key, colour) {
    this.#store.set(key, colour);
  }
  alias(from3, to3) {
    this.#aliases.set(from3, to3);
  }
  get(key, fallback) {
    const alias = this.#aliases.get(key);
    if (alias !== void 0) key = alias;
    const c5 = this.#store.get(key);
    if (c5 !== void 0) return c5;
    const variableName = `--` + key;
    let fromCss$3 = getComputedStyle(this.#elementBase).getPropertyValue(variableName).trim();
    if (fromCss$3 === void 0 || fromCss$3.length === 0) {
      if (fallback !== void 0) return fallback;
      fromCss$3 = this.fallbacks[this.#lastFallback];
      this.#lastFallback++;
      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;
    }
    return fromCss$3;
  }
  getOrAdd(key, fallback) {
    if (this.has(key)) return this.get(key);
    const c5 = this.get(key, fallback);
    this.add(key, c5);
    return c5;
  }
  has(key) {
    return this.#store.has(key);
  }
};
var video_exports2 = {};
__export(video_exports2, {
  capture: () => capture2,
  frames: () => frames2,
  manualCapture: () => manualCapture2
});
async function* frames2(sourceVideoEl, opts = {}) {
  const maxIntervalMs = opts.maxIntervalMs ?? 0;
  const showCanvas = opts.showCanvas ?? false;
  let canvasEl = opts.canvasEl;
  let w3, h5;
  w3 = h5 = 0;
  if (canvasEl === void 0) {
    canvasEl = document.createElement(`CANVAS`);
    canvasEl.classList.add(`ixfx-frames`);
    if (!showCanvas) canvasEl.style.display = `none`;
    document.body.appendChild(canvasEl);
  }
  const updateSize = () => {
    if (canvasEl === void 0) return;
    w3 = sourceVideoEl.videoWidth;
    h5 = sourceVideoEl.videoHeight;
    canvasEl.width = w3;
    canvasEl.height = h5;
  };
  let c5 = null;
  const looper = delayLoop(maxIntervalMs);
  for await (const _3 of looper) {
    if (w3 === 0 || h5 === 0) updateSize();
    if (w3 === 0 || h5 === 0) continue;
    c5 ??= canvasEl.getContext(`2d`);
    if (c5 === null) return;
    c5.drawImage(sourceVideoEl, 0, 0, w3, h5);
    const pixels = c5.getImageData(0, 0, w3, h5);
    yield pixels;
  }
}
var capture2 = (sourceVideoEl, opts = {}) => {
  const maxIntervalMs = opts.maxIntervalMs ?? 0;
  const showCanvas = opts.showCanvas ?? false;
  const onFrame = opts.onFrame;
  const w3 = sourceVideoEl.videoWidth;
  const h5 = sourceVideoEl.videoHeight;
  const canvasEl = document.createElement(`CANVAS`);
  canvasEl.classList.add(`ixfx-capture`);
  if (!showCanvas) canvasEl.style.display = `none`;
  canvasEl.width = w3;
  canvasEl.height = h5;
  let c5 = null;
  let worker;
  if (opts.workerScript) worker = new Worker(opts.workerScript);
  const getPixels = worker || onFrame;
  if (!getPixels && !showCanvas) console.warn(`Video will be captured to hidden element without any processing. Is this what you want?`);
  const loop = continuously(() => {
    if (c5 === null) c5 = canvasEl.getContext(`2d`);
    if (c5 === null) return;
    c5.drawImage(sourceVideoEl, 0, 0, w3, h5);
    let pixels;
    if (getPixels) pixels = c5.getImageData(0, 0, w3, h5);
    if (worker) worker.postMessage({
      pixels: pixels.data.buffer,
      width: w3,
      height: h5,
      channels: 4
    }, [pixels.data.buffer]);
    if (onFrame) try {
      onFrame(pixels);
    } catch (e5) {
      console.error(e5);
    }
  }, maxIntervalMs);
  return {
    start: () => {
      loop.start();
    },
    cancel: () => {
      loop.cancel();
    },
    canvasEl
  };
};
var manualCapture2 = (sourceVideoEl, opts = {}) => {
  const showCanvas = opts.showCanvas ?? false;
  const w3 = sourceVideoEl.videoWidth;
  const h5 = sourceVideoEl.videoHeight;
  const definedCanvasEl = opts.canvasEl !== void 0;
  let canvasEl = opts.canvasEl;
  if (!canvasEl) {
    canvasEl = document.createElement(`CANVAS`);
    canvasEl.classList.add(`ixfx-capture`);
    document.body.append(canvasEl);
    if (!showCanvas) canvasEl.style.display = `none`;
  }
  canvasEl.width = w3;
  canvasEl.height = h5;
  const capture$1 = () => {
    let c$1;
    if (!c$1) c$1 = canvasEl.getContext(`2d`, { willReadFrequently: true });
    if (!c$1) throw new Error(`Could not create graphics context`);
    c$1.drawImage(sourceVideoEl, 0, 0, w3, h5);
    const pixels = c$1.getImageData(0, 0, w3, h5);
    pixels.currentTime = sourceVideoEl.currentTime;
    if (opts.postCaptureDraw) opts.postCaptureDraw(c$1, w3, h5);
    return pixels;
  };
  const dispose = () => {
    if (definedCanvasEl) return;
    try {
      canvasEl.remove();
    } catch (_3) {
    }
  };
  const c5 = {
    canvasEl,
    capture: capture$1,
    dispose
  };
  return c5;
};
var bipolar_view_exports2 = {};
__export(bipolar_view_exports2, { init: () => init4 });
function getNumericAttribute2(el2, name, defaultValue) {
  const a3 = el2.getAttribute(name);
  if (a3 === null) return defaultValue;
  return Number.parseInt(a3);
}
var init4 = (elementQuery, options = {}) => {
  const element = document.querySelector(elementQuery);
  if (!element) throw new Error(`Element query could not be found (${elementQuery})`);
  const labels = options.labels ?? [`x`, `y`];
  const labelPrecision = options.labelPrecision ?? 2;
  const asPercentages = options.asPercentages ?? false;
  const displayLastValues = options.displayLastValues ?? 0;
  const showWhiskers = options.showWhiskers ?? true;
  const showDot = options.showDot ?? true;
  const showLabels = options.showLabels ?? true;
  const yAxisBottomNegative = options.yAxisBottomNegative ?? true;
  const axisColour = toStringFirst2(options.axisColour, `silver`);
  const bgColour = toStringFirst2(options.bgColour, `white`);
  const whiskerColour = toStringFirst2(options.whiskerColour, `black`);
  const dotColour = toStringFirst2(options.dotColour, options.whiskerColour, `black`);
  const labelColour = toStringFirst2(options.labelColour, options.axisColour, `silver`);
  const axisWidth = options.axisWidth ?? 1 * window.devicePixelRatio;
  const dotRadius = options.dotRadius ?? 5 * window.devicePixelRatio;
  const pad = options.padding ?? 10 * window.devicePixelRatio;
  const whiskerSize = options.whiskerSize ?? 5 * window.devicePixelRatio;
  const width = options.width ?? getNumericAttribute2(element, `width`, 200) * window.devicePixelRatio;
  const height3 = options.height ?? getNumericAttribute2(element, `height`, 200) * window.devicePixelRatio;
  let lastValues;
  if (displayLastValues > 0) lastValues = new QueueImmutable3({
    capacity: displayLastValues,
    discardPolicy: `older`
  });
  element.width = width;
  element.height = height3;
  element.style.width = `${width / window.devicePixelRatio}px`;
  element.style.height = `${height3 / window.devicePixelRatio}px`;
  const midY = height3 / 2;
  const midX = width / 2;
  const ctx = element.getContext(`2d`);
  if (!ctx) throw new Error(`Could not create drawing context`);
  if (window.devicePixelRatio >= 2) ctx.font = `20px sans-serif`;
  const percentageFormat = (v3) => `${Math.round(v3 * 100)}%`;
  const fixedFormat = (v3) => v3.toFixed(labelPrecision);
  const valueFormat = asPercentages ? percentageFormat : fixedFormat;
  if (showLabels) {
    labels[0] = labels[0] + `:`;
    labels[1] = labels[1] + `:`;
  } else {
    labels[0] = ``;
    labels[1] = ``;
  }
  const renderBackground = options.renderBackground ?? ((ctx$1, width$1, height$13) => {
    if (options.bgColour === `transparent`) ctx$1.clearRect(0, 0, width$1, height$13);
    else {
      ctx$1.fillStyle = bgColour;
      ctx$1.fillRect(0, 0, width$1, height$13);
    }
  });
  return (x3, y3) => {
    x3 = clamp$1(x3);
    y3 = clamp$1(y3);
    renderBackground(ctx, width, height3);
    ctx.fillStyle = labelColour;
    ctx.textBaseline = `top`;
    ctx.save();
    ctx.translate(midX, midY);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText((labels[1] + ` ` + valueFormat(y3)).trim(), -midX + pad, 1);
    ctx.restore();
    ctx.fillText((labels[0] + ` ` + valueFormat(x3)).trim(), pad, midX + 2);
    if (!yAxisBottomNegative) y3 *= -1;
    ctx.strokeStyle = axisColour;
    ctx.lineWidth = axisWidth;
    ctx.beginPath();
    ctx.moveTo(pad, midY);
    ctx.lineTo(width - pad, midY);
    ctx.moveTo(midX, pad);
    ctx.lineTo(midX, height3 - pad);
    ctx.stroke();
    ctx.closePath();
    const yy = (height3 - pad - pad) / 2 * -y3;
    const xx = (width - pad - pad) / 2 * x3;
    const dotPos = {
      x: xx,
      y: yy,
      radius: dotRadius
    };
    if (lastValues) lastValues = lastValues.enqueue(dotPos);
    ctx.save();
    ctx.translate(midX, midY);
    if (showDot) if (lastValues) {
      const opacityStep = 1 / lastValues.length;
      let opacity2 = 1;
      lastValues.forEach((d3) => {
        const colour = multiplyOpacity$1(dotColour, opacity2);
        circle$12(ctx, d3, { fillStyle: colour });
        opacity2 -= opacityStep;
      });
    } else circle$12(ctx, dotPos, { fillStyle: dotColour });
    if (showWhiskers) {
      ctx.strokeStyle = whiskerColour;
      ctx.beginPath();
      ctx.moveTo(0, yy - whiskerSize);
      ctx.lineTo(0, yy + whiskerSize);
      ctx.moveTo(xx - whiskerSize, 0);
      ctx.lineTo(xx + whiskerSize, 0);
      ctx.stroke();
      ctx.closePath();
    }
    ctx.restore();
  };
};
var computeMinMax2 = (mm) => {
  const x3 = mm.map((m4) => m4.x);
  const y3 = mm.map((m4) => m4.y);
  const minX = Math.min(...x3);
  const maxX = Math.max(...x3);
  const minY = Math.min(...y3);
  const maxY = Math.max(...y3);
  const width = maxX - minX;
  const height3 = maxY - minY;
  return {
    min: {
      x: minX,
      y: minY
    },
    max: {
      x: maxX,
      y: maxY
    },
    width,
    height: height3,
    minDim: Math.min(width, height3),
    maxDim: Math.max(width, height3)
  };
};
var relativeCompute2 = (minMax) => {
  if (!Number.isFinite(minMax.height)) return (point3) => point3;
  const xScale = scaler(minMax.min.x, minMax.max.x);
  const yScale = scaler(minMax.min.y, minMax.max.y);
  return (point3) => ({
    x: xScale(point3.x),
    y: yScale(point3.y)
  });
};
var absoluteCompute2 = (minMax) => {
  const xScale = scaler(0, 1, minMax.min.x, minMax.max.x);
  const yScale = scaler(0, 1, minMax.min.y, minMax.max.y);
  return (point3) => ({
    x: xScale(point3.x),
    y: yScale(point3.y)
  });
};
var computeAxisMark2 = (mm, increments, major) => {
  const xValues = [];
  let count3 = 0;
  for (let x3 = mm.min.x; x3 < mm.max.x; x3 += increments) {
    const isMajor = count3 % major === 0;
    xValues.push({
      x: x3,
      y: 0,
      major: isMajor
    });
    count3++;
  }
  count3 = 0;
  const yValues = [];
  for (let y3 = mm.min.y; y3 < mm.max.y; y3 += increments) {
    const isMajor = count3 % major === 0;
    yValues.push({
      x: 0,
      y: y3,
      major: isMajor
    });
    count3++;
  }
  return {
    x: xValues,
    y: yValues
  };
};
var DataSet2 = class {
  #data;
  #meta;
  lastChange;
  constructor() {
    this.lastChange = performance.now();
    this.#data = new MapOfSimpleMutable2();
    this.#meta = /* @__PURE__ */ new Map();
  }
  get metaCount() {
    return this.#meta.size;
  }
  clear() {
    this.#data.clear();
    this.lastChange = performance.now();
  }
  set(series, data) {
    this.#data.setValues(series, data);
  }
  deleteBySeries(series) {
    const changed = this.#data.delete(series);
    if (changed) this.lastChange = performance.now();
    return changed;
  }
  setMeta(series, meta) {
    this.#meta.set(series, meta);
  }
  hasMeta(series) {
    return this.#meta.has(series);
  }
  getMeta(series) {
    return this.#meta.get(series);
  }
  *getValues() {
    yield* this.#data.valuesFlat();
  }
  *getEntries() {
    yield* this.#data.entries();
  }
  *getSeries() {
    yield* this.#data.values();
  }
  add(value3, series = `default`) {
    this.#data.addKeyedValues(series, value3);
    this.lastChange = performance.now();
  }
};
var insert2 = (insertOptions, options = {}) => {
  const parentEl = insertOptions.parent === void 0 ? document.body : resolveEl2(insertOptions.parent);
  const canvasEl = document.createElement(`canvas`);
  parentEl.prepend(canvasEl);
  const ds2 = new DataSet2();
  const source = new CanvasSource2(canvasEl, `min`);
  const spec = insertOptions.region ?? { relativePositioned: {
    x: 0,
    y: 0,
    width: 1,
    height: 1
  } };
  const region = source.createRegion(spec);
  const p3 = new CartesianCanvasPlot2(region, ds2, options);
  if (insertOptions.canvasResizeTo === `viewport`) ElementSizer.canvasViewport(canvasEl, { onSizeChanging: (size, _el) => {
    source.setLogicalSize(size);
    p3.invalidateRange();
    p3.draw();
  } });
  else ElementSizer.canvasParent(canvasEl, { onSizeChanging: (size, _el) => {
    source.setLogicalSize(size);
    p3.invalidateRange();
    p3.draw();
  } });
  return p3;
};
var CartesianCanvasPlot2 = class {
  #data;
  #lastDataChange;
  #canvasRegion;
  actualDataRange = EmptyPositioned;
  visibleRange = PlaceholderPositioned;
  show;
  whiskerLength;
  axisRounder = round2(1, true);
  onInvalidated;
  /**
  * List of lines to draw after drawing everything else.
  * Lines are given in value-coordinate space
  */
  overlayLines = [];
  #grid;
  #rangeMode;
  #currentRange;
  #axisStyle;
  #valueStyle;
  #connectStyle;
  #rangeManual;
  #textStyle;
  #visualPadding;
  #visualClear;
  constructor(cr2, data, options = {}) {
    if (!data) throw new TypeError(`Param 'data' is undefined`);
    if (typeof data !== `object`) throw new TypeError(`Param 'data' is not an object. Got: ${typeof data}`);
    this.onInvalidated = options.onInvalidated;
    this.#data = data;
    this.#canvasRegion = cr2;
    this.#lastDataChange = 0;
    this.#visualClear = options.clear ?? `region`;
    this.#rangeMode = options.range ?? `auto`;
    this.#valueStyle = options.valueStyle ?? `dot`;
    this.#connectStyle = options.connectStyle ?? ``;
    this.whiskerLength = options.whiskerLength ?? 5;
    this.#visualPadding = options.visualPadding ?? 20;
    this.show = {
      axes: true,
      axisValues: true,
      grid: true,
      whiskers: true,
      ...options.show
    };
    this.#axisStyle = {
      colour: `black`,
      width: 2,
      ...options.axisStyle
    };
    this.#textStyle = {
      colour: `black`,
      size: `1em`,
      font: `system-ui`,
      ...options.textStyle
    };
    this.#grid = {
      increments: 0.1,
      major: 5,
      colour: `whitesmoke`,
      width: 1,
      ...options.grid
    };
  }
  getCurrentRange() {
    if (this.#data.lastChange === this.#lastDataChange && this.#currentRange) return this.#currentRange;
    this.#lastDataChange = this.#data.lastChange;
    const r5 = this.#createRange();
    this.#currentRange = r5;
    if (this.onInvalidated) this.onInvalidated();
    return r5;
  }
  invalidateRange() {
    this.#currentRange = void 0;
  }
  #createRange() {
    const range = this.getDataRange();
    const absDataToRelative = relativeCompute2(range);
    const relDataToAbs = absoluteCompute2(range);
    const cr2 = this.#canvasRegion;
    const padding2 = this.#visualPadding;
    let xOffset = cr2.x + padding2;
    let yOffset = cr2.y + padding2;
    const allowedHeight = cr2.height - padding2 * 2;
    const allowedWidth = cr2.width - padding2 * 2;
    const dimensionMin = Math.min(allowedHeight, allowedWidth);
    if (allowedWidth >= allowedHeight) xOffset += allowedWidth / 2 - dimensionMin / 2;
    else yOffset += allowedHeight / 2 - dimensionMin / 2;
    const relDataToCanvas = (pt2) => {
      let { x: x3, y: y3 } = pt2;
      if (x3 === Number.NEGATIVE_INFINITY) x3 = 0;
      else if (x3 === Number.POSITIVE_INFINITY) x3 = 1;
      if (y3 === Number.NEGATIVE_INFINITY) y3 = 0;
      else if (y3 === Number.POSITIVE_INFINITY) y3 = 1;
      x3 = x3 * dimensionMin;
      y3 = (1 - y3) * dimensionMin;
      x3 += xOffset;
      y3 += yOffset;
      return {
        x: x3,
        y: y3
      };
    };
    const canvasToRelData = (pt2) => {
      let { x: x3, y: y3 } = pt2;
      x3 -= xOffset;
      y3 -= yOffset;
      x3 = x3 / dimensionMin;
      y3 = 1 - y3 / dimensionMin;
      return {
        x: x3,
        y: y3
      };
    };
    const regionSpaceToRelative = (pt2) => {
      let { x: x3, y: y3 } = pt2;
      x3 = x3 - cr2.x + this.#visualPadding;
      y3 = dimensionMin + this.#visualPadding - y3;
      x3 /= dimensionMin;
      y3 = y3 / dimensionMin;
      return {
        x: x3,
        y: y3
      };
    };
    return {
      absDataToRelative,
      relDataToCanvas,
      canvasToRelData,
      regionSpaceToRelative,
      relDataToAbs,
      range
    };
  }
  /**
  * Positions an element at the viewport location of `data` point.
  * Ensure the element has `position:absolute` set.
  * @param data 
  * @param elementToPosition 
  * @param by 
  */
  positionElementAt(data, elementToPosition, by = `middle`, relativeToQuery) {
    const el2 = resolveEl2(elementToPosition);
    let { x: x3, y: y3 } = this.valueToScreenSpace(data);
    if (by === `middle`) {
      const bounds = el2.getBoundingClientRect();
      x3 -= bounds.width / 2;
      y3 -= bounds.height / 2;
    } else if (by === `top-left`) {
    } else throw new Error(`Param 'by' expected to be 'middle' or 'top-left'.`);
    if (relativeToQuery) {
      const relativeTo = resolveEl2(relativeToQuery);
      const bounds = relativeTo.getBoundingClientRect();
      x3 -= bounds.x;
      y3 -= bounds.y;
    }
    el2.style.left = `${x3}px`;
    el2.style.top = `${y3}px`;
  }
  /**
  * When range is auto, returns the range of the data
  * Otherwise returns the user-provided range.
  * @returns 
  */
  getDataRange() {
    if (this.#rangeMode === `auto`) return computeMinMax2([...this.#data.getValues()]);
    else {
      if (!this.#rangeManual) this.#rangeManual = computeMinMax2([this.#rangeMode.max, this.#rangeMode.min]);
      return this.#rangeManual;
    }
  }
  valueToScreenSpace(dataPoint) {
    const region = this.valueToRegionSpace(dataPoint);
    const offset$1 = this.canvasSource.offset;
    const scr = {
      x: region.x + offset$1.x,
      y: region.y + offset$1.y
    };
    return scr;
  }
  valueToRegionSpace(dataValue, debug3 = false) {
    const ds2 = this.getCurrentRange();
    const rel = ds2.absDataToRelative(dataValue);
    const region = ds2.relDataToCanvas(rel);
    if (debug3) console.log(`orig: ${dataValue.x}x${dataValue.y} rel: ${rel.x}x${rel.y} region: ${region.x}x${region.y}`);
    return {
      ...dataValue,
      x: region.x,
      y: region.y
    };
  }
  /**
  * Converts a point in pixel coordinates to a value.
  * Useful for converting from user input coordinates.
  * @param point 
  * @returns 
  */
  pointToValue(point3, _source) {
    const ds2 = this.getCurrentRange();
    const canvasPoint = subtract(point3, this.canvasSource.offset);
    const v3 = ds2.canvasToRelData(canvasPoint);
    return ds2.relDataToAbs(v3);
  }
  /**
  * Compute canvas-relative coordinates based on two points in value space
  * @param valueA 
  * @param valueB 
  */
  #valueLineToCanvasSpace(valueA, valueB, debug3 = false) {
    valueA = this.valueToRegionSpace(valueA, debug3);
    valueB = this.valueToRegionSpace(valueB, debug3);
    return {
      a: valueA,
      b: valueB
    };
  }
  getDefaultMeta() {
    return {
      colour: goldenAngleColour2(this.#data.metaCount),
      lineWidth: 2,
      dotRadius: 5
    };
  }
  draw() {
    if (this.#visualClear === `region`) this.#canvasRegion.clear();
    else this.canvasSource.clear();
    this.#useGrid();
    if (this.show.axes) this.#drawAxes();
    for (const [k3, v3] of this.#data.getEntries()) {
      let meta = this.#data.getMeta(k3);
      if (!meta) {
        meta = this.getDefaultMeta();
        this.#data.setMeta(k3, meta);
      }
      this.#drawSeries(k3, v3, meta);
    }
    for (const line$2 of this.overlayLines) this.drawLine(line$2, line$2.colour, line$2.width);
  }
  /**
  * Draws a line in value-coordinate space
  * @param line 
  * @param colour 
  * @param width 
  */
  drawLine(line$2, colour, width) {
    const l3 = this.#valueLineToCanvasSpace(line$2.a, line$2.b);
    this.#drawLineCanvasSpace(l3, colour, width);
  }
  setMeta(series, meta) {
    this.#data.setMeta(series, {
      ...this.getDefaultMeta(),
      ...meta
    });
  }
  #drawAxes() {
    const { colour, width } = this.#axisStyle;
    const yAxis = this.#valueLineToCanvasSpace({
      x: 0,
      y: Number.NEGATIVE_INFINITY
    }, {
      x: 0,
      y: Number.POSITIVE_INFINITY
    }, false);
    const xAxis = this.#valueLineToCanvasSpace({
      x: Number.NEGATIVE_INFINITY,
      y: 0
    }, {
      x: Number.POSITIVE_INFINITY,
      y: 0
    }, false);
    this.#drawLineCanvasSpace(xAxis, colour, width, false);
    this.#drawLineCanvasSpace(yAxis, colour, width, false);
  }
  #drawYAxisValues(yPoints) {
    const ctx = this.#canvasRegion.context;
    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;
    ctx.fillStyle = this.#textStyle.colour;
    ctx.textBaseline = `middle`;
    for (const p3 of yPoints) {
      if (p3.x === 0 && p3.y === 0) continue;
      const reg = this.valueToRegionSpace(p3, false);
      const value3 = this.axisRounder(p3.y);
      const label = value3.toString();
      const measure = ctx.measureText(label);
      const x3 = reg.x - measure.width - this.whiskerLength / 2 - 5;
      const y3 = reg.y;
      ctx.fillText(label, x3, y3);
    }
  }
  #drawXAxisValues(xPoints) {
    const ctx = this.#canvasRegion.context;
    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;
    ctx.fillStyle = this.#textStyle.colour;
    ctx.textBaseline = `top`;
    for (const p3 of xPoints) {
      const reg = this.valueToRegionSpace(p3, false);
      const value3 = this.axisRounder(p3.x);
      const label = value3.toString();
      const measure = ctx.measureText(label);
      const x3 = reg.x - measure.width / 2;
      const y3 = reg.y + measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent + this.whiskerLength / 2;
      ctx.fillText(label, x3, y3);
    }
  }
  #drawWhisker(p3, vertical) {
    const whiskerHalfLength = this.whiskerLength / 2;
    const v3 = vertical ? {
      x: p3.x,
      y: 0
    } : {
      y: p3.y,
      x: 0
    };
    const reg = this.valueToRegionSpace(v3, false);
    const line$2 = vertical ? {
      a: {
        x: reg.x,
        y: reg.y - whiskerHalfLength
      },
      b: {
        x: reg.x,
        y: reg.y + whiskerHalfLength
      }
    } : {
      a: {
        y: reg.y,
        x: reg.x - whiskerHalfLength
      },
      b: {
        y: reg.y,
        x: reg.x + whiskerHalfLength
      }
    };
    this.#drawLineCanvasSpace(line$2, this.#axisStyle.colour, this.#axisStyle.width, false);
  }
  #drawGridline(p3, vertical) {
    const line$2 = vertical ? this.#valueLineToCanvasSpace({
      x: p3.x,
      y: Number.NEGATIVE_INFINITY
    }, {
      x: p3.x,
      y: Number.POSITIVE_INFINITY
    }) : this.#valueLineToCanvasSpace({
      y: p3.y,
      x: Number.NEGATIVE_INFINITY
    }, {
      y: p3.y,
      x: Number.POSITIVE_INFINITY
    }, false);
    this.#drawLineCanvasSpace(line$2, this.#grid.colour, p3.major ? this.#grid.width * 2 : this.#grid.width);
  }
  #useGrid() {
    const g4 = this.#grid;
    const showGrid = this.show.grid;
    const showWhiskers = this.show.whiskers;
    const showValues = this.show.axisValues;
    const mm = this.getCurrentRange().range;
    const { increments, major } = g4;
    const axisMarks = computeAxisMark2(mm, increments, major);
    for (const p3 of axisMarks.x) {
      if (showGrid) this.#drawGridline(p3, true);
      if (showWhiskers && p3.major) this.#drawWhisker(p3, true);
    }
    for (const p3 of axisMarks.y) {
      if (showGrid) this.#drawGridline(p3, false);
      if (showWhiskers && p3.major) this.#drawWhisker(p3, false);
    }
    if (showValues) {
      this.#drawXAxisValues(axisMarks.x.filter((p3) => p3.major));
      this.#drawYAxisValues(axisMarks.y.filter((p3) => p3.major));
    }
  }
  #drawSeries(name, series, meta) {
    if (this.#connectStyle === `line`) this.#drawConnected(series, meta.colour, meta.lineWidth);
    if (this.#valueStyle === `dot`) for (const v3 of series) this.#drawDot(v3, meta.colour, meta.dotRadius);
  }
  #drawConnected(dots, colour, width) {
    const ctx = this.#canvasRegion.context;
    ctx.beginPath();
    for (const [index, dot_] of dots.entries()) {
      const dot$1 = this.valueToRegionSpace(dot_, false);
      if (index === 0) ctx.moveTo(dot$1.x, dot$1.y);
      ctx.lineTo(dot$1.x, dot$1.y);
    }
    ctx.strokeStyle = toCssColour2(colour);
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  }
  #drawDot(originalDot, fallbackColour, fallbackRadius) {
    const colour = toCssColour2(originalDot.fillStyle ?? fallbackColour);
    const pos = this.valueToRegionSpace(originalDot);
    const radius = originalDot.radius ?? fallbackRadius;
    this.#canvasRegion.drawCircles([{
      ...pos,
      radius
    }], colour);
  }
  #drawLineCanvasSpace(line$2, colour, width, debug3 = false) {
    if (debug3) console.log(line$2);
    const ctx = this.#canvasRegion.context;
    colour = toCssColour2(colour);
    ctx.beginPath();
    ctx.moveTo(line$2.a.x, line$2.a.y);
    ctx.lineTo(line$2.b.x, line$2.b.y);
    ctx.strokeStyle = toCssColour2(colour);
    ctx.lineWidth = width;
    ctx.stroke();
    ctx.closePath();
  }
  get dataSet() {
    return this.#data;
  }
  get canvasRegion() {
    return this.#canvasRegion;
  }
  get canvasSource() {
    return this.#canvasRegion.source;
  }
};
var plot_exports2 = {};
__export(plot_exports2, {
  BipolarView: () => bipolar_view_exports2,
  CartesianCanvasPlot: () => CartesianCanvasPlot2,
  DataSet: () => DataSet2,
  absoluteCompute: () => absoluteCompute2,
  computeAxisMark: () => computeAxisMark2,
  computeMinMax: () => computeMinMax2,
  insert: () => insert2,
  relativeCompute: () => relativeCompute2
});
try {
  if (typeof window !== `undefined`) window.ixfx = {
    ...window.ixfx,
    Visuals: {
      NamedColourPalette: named_colour_palette_exports2,
      Colour: colour_exports2,
      Video: video_exports2
    }
  };
} catch {
}

// src/components/pose-overlay.ts
var _colours;
var OverlayElement = class extends h3 {
  constructor() {
    super(...arguments);
    this.canvasEl = ii();
    __privateAdd(this, _colours, new ExpiringMap({
      autoDeleteElapsedMs: 1e3,
      autoDeletePolicy: `get`
    }));
    this.lastHue = 100;
    this.labelPoints = true;
  }
  render() {
    return ke`
      <canvas ${Kt(this.canvasEl)}></canvas>
    `;
  }
  setSize(width, height3) {
    const el2 = this.canvasEl.value;
    if (!el2) return;
    el2.width = width;
    el2.height = height3;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  draw(mode, data) {
    const el2 = this.canvasEl.value;
    if (!el2) return;
    const wrap7 = wrap(el2);
    wrap7.clear();
    if (!data) return;
    switch (mode) {
      case `hand`: {
        this.drawHands(wrap7, data);
        break;
      }
      case `objects`: {
        this.drawObjects(wrap7, data.detections);
        break;
      }
      case `pose`: {
        for (const d3 of data) {
          if (`poseid` in d3) {
            const pose = d3;
            this.drawPose(wrap7, pose);
          }
        }
        this.drawLandmarks(wrap7, data.landmarks);
        break;
      }
      case `face`: {
        this.drawFaces(wrap7, data.detections);
        break;
      }
    }
  }
  drawFaces(wrap7, d3) {
    for (let i4 = 0; i4 < d3.length; i4++) {
      const bbox3 = d3[i4].boundingBox;
      const colour = colour_exports2.goldenAngleColour(i4);
      for (let k3 = 0; k3 < d3[i4].keypoints.length; k3++) {
        const label = this.labelPoints ? k3.toString() : ``;
        wrap7.dot(d3[i4].keypoints[k3], 0.01, colour, label);
      }
    }
  }
  drawHands(wrap7, results) {
    let index = 0;
    for (const hand of results.landmarks) {
      const colour = colour_exports2.goldenAngleColour(index);
      this.drawHand(wrap7, hand, colour);
      this.drawOneSetOfLandmarks(wrap7, hand, 0.02, colour);
      index++;
    }
  }
  drawHand(wrap7, p3, colour) {
    const width = 0.01;
    wrap7.ctx.strokeStyle = colour;
    wrap7.joinPoints(width, p3[0], p3[1], p3[2], p3[3], p3[4]);
    wrap7.joinPoints(width, p3[5], p3[6], p3[7], p3[8]);
    wrap7.joinPoints(width, p3[9], p3[10], p3[11], p3[12]);
    wrap7.joinPoints(width, p3[13], p3[14], p3[15], p3[16]);
    wrap7.joinPoints(width, p3[17], p3[18], p3[19], p3[20]);
    wrap7.joinPoints(width, p3[5], p3[9], p3[13], p3[17], p3[0], p3[5]);
  }
  drawObjects(wrap7, data) {
    const typewriter2 = typewriter(wrap7.ctx, 10, 100);
    let index = 0;
    for (const d3 of data) {
      const colour = colour_exports2.goldenAngleColour(index);
      this.drawDetectionBoundingBox(wrap7, d3, colour, typewriter2);
      index++;
    }
  }
  drawDetectionBoundingBox(wrap7, det, colour, typewriter2) {
    const ctx = wrap7.ctx;
    const bbox3 = det.boundingBox;
    if (bbox3) {
      this.drawBoundingBox(ctx, bbox3, colour);
    }
    if (det.categories) {
      for (const c5 of det.categories) {
        typewriter2.line(`${c5.score.toPrecision(2)} - ${c5.categoryName}`, colour);
      }
    }
  }
  drawBoundingBox(ctx, bbox3, colour) {
    ctx.save();
    ctx.translate(bbox3.originX, bbox3.originY);
    ctx.rotate(bbox3.angle);
    ctx.lineWidth = 5;
    ctx.strokeStyle = colour;
    ctx.strokeRect(0, 0, bbox3.width, bbox3.height);
    ctx.restore();
  }
  getColour(id) {
    let colour = __privateGet(this, _colours).get(id);
    __privateGet(this, _colours).touch(id);
    if (!colour) {
      this.lastHue += 45 * Math.random();
      if (this.lastHue > 360) this.lastHue = this.lastHue % 360;
      colour = `hsl(${this.lastHue}deg, 50%, 50%)`;
      __privateGet(this, _colours).set(id, colour);
    }
    return colour;
  }
  drawLandmarks(wrap7, poses) {
    if (!poses) return;
    let index = 0;
    for (const p3 of poses) {
      this.drawOneSetOfLandmarks(wrap7, p3, 0.01, this.getColour(index.toString()));
      index++;
    }
  }
  drawOneSetOfLandmarks(wrap7, p3, maxRadius, colour) {
    let index = 0;
    for (const l3 of p3) {
      let z3 = -1 * l3.z;
      const r5 = Math.min(maxRadius * 3, Math.max(1e-4, maxRadius + maxRadius * z3 * 3));
      const label = this.labelPoints ? index.toString() : ``;
      wrap7.dot(l3, r5, colour, label);
      index++;
    }
  }
  drawPose(wrap7, pose) {
    const colour = this.getColour(pose.poseid);
    this.drawPoseLines(wrap7, pose.landmarks, colour);
    if (this.labelPoints) {
      this.drawOneSetOfLandmarks(wrap7, pose.landmarks, 2e-3, colour);
    }
  }
  drawPoseLines(wrap7, p3, colour) {
    let index = 0;
    const width = 0.01;
    wrap7.ctx.strokeStyle = colour;
    wrap7.joinPoints(width, p3[32], p3[30], p3[28], p3[26], p3[24], p3[12], p3[14], p3[16], p3[18], p3[20], p3[16], p3[22]);
    wrap7.joinPoints(width, p3[31], p3[29], p3[27], p3[25], p3[23], p3[11], p3[13], p3[15], p3[17], p3[19], p3[15], p3[21]);
    wrap7.joinPoints(width, p3[12], p3[11]);
    wrap7.joinPoints(width, p3[24], p3[23]);
    wrap7.joinPoints(width, p3[10], p3[9]);
    wrap7.joinPoints(width, p3[8], p3[6], p3[5], p3[4], p3[0], p3[1], p3[2], p3[3], p3[7]);
  }
};
_colours = new WeakMap();
OverlayElement.styles = i`
    :host {
      display: block;
      height: 100%;
      width: 100%;
    }
  `;
OverlayElement = __decorateClass([
  t3("overlay-element")
], OverlayElement);

// src/util/log.ts
var Log = class {
  constructor(prefix, verbosity) {
    if (typeof verbosity === `string`) {
      this.verbosity = verbosity;
    } else {
      this.verbosity = verbosity.verbosity;
    }
    this.prefix = prefix;
  }
  info(msg) {
    if (this.verbosity === `errors`) return;
    console.log(this.prefix, msg);
  }
  debug(msg) {
    if (this.verbosity !== `debug`) return;
    console.log(this.prefix, msg);
  }
};

// src/recorder.ts
var Recorder = class extends EventTarget {
  constructor(recordings, dispatcher) {
    super();
    this.recordings = recordings;
    this.dispatcher = dispatcher;
    this.#state = `idle`;
    this.buffer = [];
    this.computeFreqMs = 0;
    this.log = new Log(`Recorder`, `info`);
    this.onDataBound = this.onData.bind(this);
  }
  #state;
  #mode;
  start(computeFreqMs) {
    this.computeFreqMs = computeFreqMs;
    this.#setState(`recording`);
    this.dispatcher.addEventListener(`data`, this.onDataBound);
  }
  get length() {
    return this.buffer.length;
  }
  onData(event2) {
    const detail = event2.detail;
    const data = detail.data;
    const mode = detail.mode;
    this.#mode = mode;
    this.buffer.push(data);
    if (this.buffer.length % 5 === 0) {
      this.log.info(`Recorder: ${this.buffer.length} samples`);
    }
  }
  stop() {
    this.#setState(`complete`);
    this.dispatcher.removeEventListener(`data`, this.onDataBound);
    const name = this.recordings.promptName();
    if (name) {
      const rec = {
        rateMs: this.computeFreqMs,
        samples: this.buffer,
        mode: this.#mode,
        name
      };
      this.recordings.add(rec);
    }
    this.buffer = [];
  }
  #setState(state) {
    const prior = this.#state;
    if (state === prior) return;
    this.#state = state;
    if (state === `recording` && prior !== `idle`) throw new Error(`Cannot transition ${prior} - > ${state}`);
    if (state === `complete` && prior !== `recording`) throw new Error(`Cannot transition ${prior} - > ${state}`);
    this.log.debug(`${prior} -> ${state}`);
    this.dispatchEvent(new CustomEvent(`state-change`, {
      detail: {
        priorState: prior,
        newState: state
      }
    }));
  }
  get state() {
    return this.#state;
  }
};

// src/components/vision-element.ts
var _lastCameras, _lastRecordings, _lastSource, _lastOptions;
var VisionElement = class extends h3 {
  constructor() {
    super(...arguments);
    this.videoSelectorEl = ii();
    this.videoSourceEl = ii();
    this.overlayEl = ii();
    this.recPanelEl = ii();
    this.debug = true;
    __privateAdd(this, _lastCameras, []);
    __privateAdd(this, _lastRecordings, []);
    __privateAdd(this, _lastSource);
    __privateAdd(this, _lastOptions);
    this.uiSource = `video`;
    this.hideModelSelector = false;
  }
  render() {
    return ke`
      <div id="sources">
        <video-source id="video" ${Kt(this.videoSourceEl)} @sized=${this.onVideoSized}></video-source>
        <overlay-element @click=${this.onOverlayClick} id="overlay" ${Kt(this.overlayEl)} ></overlay-element>
      </div>
      <div id="controls">
        ${this.hideModelSelector ? ke`` : ke`<details><summary>Model</summary>
                  <model-element @request-mode=${this.onRequestMode}></model-element>
                </details>`}
        <details><summary>Source</summary>
          <fieldset @change=${this.onSelectSource}>
            <input type="radio" checked name="source" id="source-video" value="video"><label for="source-video">Video</label>
            <input type="radio" name="source" id="source-recording" value="recording"><label for="source-recording">Recording</label>
          </fieldset>
          <video-selector class=${this.uiSource === `video` ? `show` : `hidden`} 
            .source=${__privateGet(this, _lastSource)} 
            .cameras=${__privateGet(this, _lastCameras)} ${Kt(this.videoSelectorEl)} 
            @startstop=${this.onVideoStartStop}
            @change=${this.onVideoSelectorChange}>
          </video-selector>
          <rec-panel class=${this.uiSource === `recording` ? `show` : `hidden`} 
            .recordings=${__privateGet(this, _lastRecordings)} 
            @startstop=${this.onRecStartStop}
            @change=${this.onRecSelectorChange}
            @request-delete=${this.onRecRequestDelete}
            id="rec-panel" ${Kt(this.recPanelEl)}>
            </rec-panel>
        </details>
        <details><summary>Recording</summary>
        ${this.getRecordingUi()}
        </details>
      </div>
    `;
  }
  onRequestMode(event2) {
    this.dispatchEvent(new CustomEvent(`request-mode`, {
      detail: event2.detail
    }));
  }
  onRecRequestDelete(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`request-source-delete`, { detail }));
  }
  onRecSelectorChange(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`request-source`, { detail }));
  }
  /**
   * User has choosing a new camera
   * @param event 
   */
  onVideoSelectorChange(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`request-source`, { detail }));
  }
  onRecStartStop(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`source-startstop`, {
      detail
    }));
  }
  onVideoStartStop(event2) {
    const detail = event2.detail;
    this.dispatchEvent(new CustomEvent(`source-startstop`, {
      detail
    }));
  }
  getRecordingUi() {
    if (!this.recorder) return ke`<button @click=${this.onStartRecording}>Start recording</button>`;
    const r5 = this.recorder;
    switch (r5.state) {
      case "recording": {
        return ke`<button @click=${this.onStopRecording}>Stop recording</button>`;
      }
      case "complete": {
        return ke`<em>Complete</em>`;
      }
    }
  }
  onStopRecording() {
    const r5 = this.recorder;
    if (!r5) return;
    r5.stop();
    this.recorder = void 0;
  }
  onStartRecording() {
    this.dispatchEvent(new CustomEvent(`request-recorder`));
  }
  onOverlayClick() {
    this.videoSourceEl.value?.togglePreview();
  }
  setOptions(options) {
    __privateSet(this, _lastOptions, options);
  }
  /**
   * User swapped between camera/recording in UI
   * @param event 
   * @returns 
   */
  onSelectSource(event2) {
    const t6 = event2.target;
    if (!t6) return;
    if (t6.value === `video`) {
      this.uiSource = `video`;
    } else if (t6.value === `recording`) {
      this.uiSource = `recording`;
    }
  }
  /**
   * Notification that sources have been updated
   * @param sources 
   */
  onSourcesUpdated(cameras, recordings) {
    __privateSet(this, _lastCameras, cameras);
    __privateSet(this, _lastRecordings, recordings);
    const el2 = this.videoSelectorEl.value;
    if (el2) {
      el2.cameras = cameras;
    }
    const recPanel = this.recPanelEl.value;
    if (recPanel) {
      recPanel.recordings = __privateGet(this, _lastRecordings);
    } else {
      console.warn(`Not able to set recordings, element missing.`);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    window.addEventListener(`resize`, () => {
      this.resizeElements();
    });
  }
  firstUpdated(_changedProperties) {
    const overlay = this.overlayEl.value;
    const opts = __privateGet(this, _lastOptions)?.overlay;
    if (overlay && opts) {
      overlay.labelPoints = opts.label;
    } else {
      console.warn(`Not able to set options for overlay, element missing.`);
    }
  }
  updateRecPanel() {
    const el2 = this.shadowRoot?.getElementById(`rec-panel`);
    const recPanel = this.recPanelEl.value || el2;
    if (recPanel) {
      recPanel.recordings = __privateGet(this, _lastRecordings);
    } else {
      console.warn(`Not able to set recordings, element missing.`);
    }
  }
  /**
   * Notification that source has changed
   * @param source 
   */
  notifySourceChange(source) {
    __privateSet(this, _lastSource, source);
    let el2 = this.videoSelectorEl.value;
    if (el2) {
      el2.source = source;
    }
  }
  notifySourceState(state, source) {
    if (!source) {
      this.videoSelectorEl.value?.notifySourceState(state);
      this.recPanelEl.value?.notifySourceState(state);
    } else if (source.kind === `camera` || source.kind === `file`) {
      this.videoSelectorEl.value?.notifySourceState(state);
    } else if (source.kind === `recording`) {
      this.recPanelEl.value?.notifySourceState(state);
    }
  }
  onVideoSized() {
    this.resizeElements();
  }
  resizeElements() {
    const overlay = this.overlayEl.value;
    const v3 = this.videoSourceEl.value;
    if (!v3 || !overlay) return;
    const container = this.getBoundingClientRect();
    const videoSize = v3.getVideoSize();
    if (!videoSize) return;
    let w3 = videoSize?.width;
    let h5 = videoSize?.height;
    const isVideoLandscape = w3 >= h5;
    const videoRatioWoverH = w3 / h5;
    const videoRatioHoverW = h5 / w3;
    const isLandscape = w3 >= h5;
    let constrainedDimension = isVideoLandscape ? `width` : `height`;
    if (isLandscape) constrainedDimension = `height`;
    if (constrainedDimension === `width`) {
      w3 = container.width;
      h5 = w3 * videoRatioHoverW;
    } else {
      h5 = container.height;
      w3 = h5 * videoRatioWoverH;
    }
    const left = container.width / 2 - w3 / 2;
    const top = container.height / 2 - h5 / 2;
    v3.style.height = overlay.style.height = `${h5}px`;
    v3.style.width = overlay.style.width = `${w3}px`;
    v3.style.left = overlay.style.left = `${left}px`;
    v3.style.top = overlay.style.top = `${top}px`;
    overlay.setSize(w3, h5);
  }
  onSourceChange(event2) {
    const d3 = event2.detail;
    this.dispatchEvent(new CustomEvent(`change-source`, {
      detail: d3
    }));
  }
  onReceivedData(mode, data) {
    const el2 = this.overlayEl.value;
    if (!el2) return;
    el2.draw(mode, data);
  }
  getVideoSource() {
    return this.videoSourceEl.value;
  }
  getVideoElement() {
    const src = this.getVideoSource();
    if (!src) return;
    return src.getVideoElement();
  }
};
_lastCameras = new WeakMap();
_lastRecordings = new WeakMap();
_lastSource = new WeakMap();
_lastOptions = new WeakMap();
VisionElement.styles = i`
  :host {
    display: block;
    background-color: transparent;
    font-family: system-ui, sans-serif;
  }
  #controls {
    background: black;
    color: white;
    position: absolute;
    top: 0px;
    left: 0px;
    padding: 0.5rem;
  }
  #overlay,#video {
    position:absolute;
  }
  #sources {
    background:green;
  }
  fieldset {
    border: 0;
  }
  summary {
    user-select: none;
    pointer:default;
  }
  details {
    padding:0.3rem;
  }

  .hidden {
    display:none;
  }
  `;
__decorateClass([
  n4()
], VisionElement.prototype, "uiSource", 2);
__decorateClass([
  n4()
], VisionElement.prototype, "recorder", 2);
__decorateClass([
  n4()
], VisionElement.prototype, "hideModelSelector", 2);
VisionElement = __decorateClass([
  t3("vision-element")
], VisionElement);

// src/components/rec-panel.ts
var RecPanel = class extends h3 {
  constructor() {
    super(...arguments);
    this.recordings = [];
    this.playing = false;
    this.selectEl = ii();
  }
  render() {
    if (this.recordings.length === 0) {
      return ke`<em>No recordings</em>`;
    }
    let recs = [
      ...this.recordings
    ];
    return ke`
    <div id="contents">
      <div id="toolbar">
        <button @click=${this.onStartStopClick}>${this.playing ? `Stop` : `Play`}</button>
      </div>
      <select ${Kt(this.selectEl)} @change=${this.onSelectChange}>
        ${this.recordings.map((r5) => ke`<option .source=${r5}>${r5.label}</option>`)}
      </select>
      <button @click=${this.onDeleteClick}>Delete</button>
    </div>
    `;
  }
  onStartStopClick() {
    const rec = this.getSelected();
    if (!rec) {
      console.warn(`No recording selected?`);
      return;
    }
    this.dispatchEvent(new CustomEvent(`startstop`, { detail: rec }));
  }
  onSelectChange(event2) {
    const target = event2.target;
    if (!target) return;
    const item = target.item(target.selectedIndex);
    if (!item) return;
    const recording = item.recording;
  }
  getSelected() {
    const el2 = this.selectEl.value;
    if (!el2) return;
    const item = el2.item(el2.selectedIndex);
    if (!item) return;
    return item.source;
  }
  onDeleteClick() {
    const rec = this.getSelected();
    if (!rec) return;
    this.dispatchEvent(new CustomEvent(`request-delete`, { detail: rec }));
  }
  // #setState(state: RecPanelStates) {
  //   const prior = this.#state;
  //   if (state === prior) return;
  //   this.#state = state;
  //   this.#log(`state ${ prior } -> ${ state }`);
  //   this.dispatchEvent(new CustomEvent(`state`, {
  //     detail: {
  //       priorState: prior,
  //       newState: state
  //     }
  //   }));
  // }
  notifySourceState(state) {
    this.playing = state === `started`;
  }
  // onToggle() {
  //   this.expanded = !this.expanded;
  // }
};
RecPanel.styles = i`
    :host {
      display:block;
      background-color: hsla(0,0%,30%,0.5);
    }
    #contents {
      padding: 0.5rem;
    }
    #toolbar {
      margin-bottom: 0.5rem;
    }
  `;
__decorateClass([
  n4()
], RecPanel.prototype, "recordings", 2);
__decorateClass([
  n4()
], RecPanel.prototype, "playing", 2);
RecPanel = __decorateClass([
  t3("rec-panel")
], RecPanel);

// src/components/video-source.ts
var _state, _VideoSourceElement_instances, setState_fn;
var VideoSourceElement = class extends h3 {
  constructor() {
    super(...arguments);
    __privateAdd(this, _VideoSourceElement_instances);
    this.videoEl = ii();
    this.log = new Log(`VideoSourceElement`, `errors`);
    __privateAdd(this, _state, `stopped`);
    this.showPreview = true;
  }
  render() {
    return ke`
      <video class=${this.showPreview ? `show` : `hide`} @pause=${this.onPause} @loadedmetadata=${this.onLoadedMetadata} @playing=${this.onPlaying} @ended=${this.onEnded} loop autoplay muted playsInline webkitPlaysInline ${Kt(this.videoEl)}></video>
    `;
  }
  togglePreview() {
    this.showPreview = !this.showPreview;
  }
  getVideoElement() {
    return this.videoEl.value;
  }
  getVideoSize() {
    const el2 = this.videoEl.value;
    if (!el2) return;
    return {
      width: el2.videoWidth,
      height: el2.videoHeight
    };
  }
  get isStarted() {
    return __privateGet(this, _state) === `started`;
  }
  start() {
    const el2 = this.videoEl.value;
    if (!el2) {
      console.warn(`No video element`);
    } else {
      el2.play();
    }
  }
  stop() {
    const el2 = this.videoEl.value;
    if (!el2) {
      console.warn(`No video element`);
    } else {
      el2.pause();
    }
  }
  onLoadedMetadata() {
    const el2 = this.videoEl.value;
    if (!el2) return;
    this.dispatchEvent(new CustomEvent(
      `sized`,
      {
        detail: {
          width: el2.videoWidth,
          height: el2.videoHeight
        }
      }
    ));
  }
  /**
   * From video element - now playing
   */
  onPlaying() {
    __privateMethod(this, _VideoSourceElement_instances, setState_fn).call(this, `started`);
  }
  /**
   * From video element - now stopped
   */
  onPause() {
    __privateMethod(this, _VideoSourceElement_instances, setState_fn).call(this, `stopped`);
  }
  /**
   * From video element - now stopped
   */
  onEnded() {
    __privateMethod(this, _VideoSourceElement_instances, setState_fn).call(this, `stopped`);
  }
  setVideoSource(source) {
    const el2 = this.videoEl.value;
    if (el2) {
      el2.classList.remove(`hide`);
      if (typeof source === `string`) {
        el2.srcObject = null;
        el2.src = source;
      } else {
        if (!source) {
          el2.pause();
          el2.classList.add(`hide`);
        }
        el2.srcObject = source ?? null;
      }
    } else {
      console.warn(`Video element unavailable`);
    }
    if (source && el2?.paused) {
      el2.play();
    }
  }
};
_state = new WeakMap();
_VideoSourceElement_instances = new WeakSet();
setState_fn = function(state) {
  const prior = __privateGet(this, _state);
  if (state === prior) return;
  __privateSet(this, _state, state);
  this.log.debug(`state ${prior} -> ${state}`);
  this.dispatchEvent(new CustomEvent(`state`, {
    detail: {
      priorState: prior,
      newState: state
    }
  }));
};
VideoSourceElement.styles = i`
    :host {
      display: block;
    }
    video {
      width: 100%;
      height: 100%;
      opacity: 0.5;
    }
    video.hide {
      display:none;
    }
  `;
__decorateClass([
  n4()
], VideoSourceElement.prototype, "source", 2);
__decorateClass([
  n4()
], VideoSourceElement.prototype, "showPreview", 2);
VideoSourceElement = __decorateClass([
  t3("video-source")
], VideoSourceElement);

// src/processor-modes.ts
var getProcessorModes = () => [`pose`, `objects`, `hand`, `face`];
var validateProcessorMode = (a3, fallback) => {
  if (typeof a3 === `string`) {
    if (a3 === `pose`) return `pose`;
    if (a3 === `hand`) return `hand`;
    if (a3 === `face`) return `face`;
    if (a3 === `objects`) return `objects`;
  }
  if (fallback) return fallback;
  throw new Error(`Invalid mode: ${a3}. Expected: ${getProcessorModes().join(`,`)}`);
};

// src/components/model-element.ts
var ModelElement = class extends h3 {
  render() {
    const modes = getProcessorModes();
    return ke`
      <select @change=${this.onSelectChange}>
      ${modes.map((m4) => ke`<option>${m4}</option>`)}
      </select>
    `;
  }
  onSelectChange(event2) {
    const value3 = event2.target.value;
    this.dispatchEvent(new CustomEvent(`request-mode`, {
      detail: {
        mode: validateProcessorMode(value3)
      }
    }));
  }
};
ModelElement.styles = i`
    :host {
      display: block;
    
    }
  `;
ModelElement = __decorateClass([
  t3("model-element")
], ModelElement);

// node_modules/ixfx/bundle/geometry.js
var piPi5 = Math.PI * 2;
function degreeToRadian2(angleInDegrees) {
  return Array.isArray(angleInDegrees) ? angleInDegrees.map((v3) => v3 * (Math.PI / 180)) : angleInDegrees * (Math.PI / 180);
}
function radianInvert2(angleInRadians) {
  return (angleInRadians + Math.PI) % (2 * Math.PI);
}
function radianToDegree2(angleInRadians) {
  return Array.isArray(angleInRadians) ? angleInRadians.map((v3) => v3 * 180 / Math.PI) : angleInRadians * 180 / Math.PI;
}
var radiansSum2 = (start, amount, clockwise = true) => {
  if (clockwise) {
    let x3 = start + amount;
    if (x3 >= piPi5) x3 = x3 % piPi5;
    return x3;
  } else {
    const x3 = start - amount;
    if (x3 < 0) return piPi5 + x3;
    return x3;
  }
};
var radianArc2 = (start, end, clockwise = true) => {
  let s3 = start;
  if (end < s3) {
    s3 = 0;
    end = piPi5 - start + end;
  }
  let d3 = end - s3;
  if (clockwise) d3 = piPi5 - d3;
  if (d3 >= piPi5) return d3 % piPi5;
  return d3;
};
var isNull2 = (p3) => {
  if (isPoint3d2(p3)) {
    if (p3.z !== null) return false;
  }
  return p3.x === null && p3.y === null;
};
var isNaN$12 = (p3) => {
  if (isPoint3d2(p3)) {
    if (!Number.isNaN(p3.z)) return false;
  }
  return Number.isNaN(p3.x) || Number.isNaN(p3.y);
};
function test2(p3, name = `Point`, extraInfo = ``) {
  if (p3 === void 0) return errorResult(`'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (p3 === null) return errorResult(`'${name}' is null. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (typeof p3 !== `object`) return errorResult(`'${name}' is type '${typeof p3}'. Expected object.`, extraInfo);
  if (p3.x === void 0) return errorResult(`'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (p3.y === void 0) return errorResult(`'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p3)}`, extraInfo);
  if (typeof p3.x !== `number`) return errorResult(`'${name}.x' must be a number. Got ${typeof p3.x}`, extraInfo);
  if (typeof p3.y !== `number`) return errorResult(`'${name}.y' must be a number. Got ${typeof p3.y}`, extraInfo);
  if (p3.z !== void 0) {
    if (typeof p3.z !== `number`) return errorResult(`${name}.z must be a number. Got: ${typeof p3.z}`, extraInfo);
    if (Number.isNaN(p3.z)) return errorResult(`'${name}.z' is NaN. Got: ${JSON.stringify(p3)}`, extraInfo);
  }
  if (p3.x === null) return errorResult(`'${name}.x' is null`, extraInfo);
  if (p3.y === null) return errorResult(`'${name}.y' is null`, extraInfo);
  if (Number.isNaN(p3.x)) return errorResult(`'${name}.x' is NaN`, extraInfo);
  if (Number.isNaN(p3.y)) return errorResult(`'${name}.y' is NaN`, extraInfo);
  return {
    success: true,
    value: p3
  };
}
function guard$12(p3, name = `Point`, info) {
  resultThrow(test2(p3, name, info));
}
var guardNonZeroPoint2 = (pt2, name = `pt`) => {
  guard$12(pt2, name);
  resultThrow(numberTest(pt2.x, `nonZero`, `${name}.x`), numberTest(pt2.y, `nonZero`, `${name}.y`), () => {
    if (typeof pt2.z !== `undefined`) return numberTest(pt2.z, `nonZero`, `${name}.z`);
  });
  return true;
};
function isPoint2(p3) {
  if (p3 === void 0) return false;
  if (p3 === null) return false;
  if (p3.x === void 0) return false;
  if (p3.y === void 0) return false;
  return true;
}
var isPoint3d2 = (p3) => {
  if (p3 === void 0) return false;
  if (p3 === null) return false;
  if (p3.x === void 0) return false;
  if (p3.y === void 0) return false;
  if (p3.z === void 0) return false;
  return true;
};
var isEmpty4 = (p3) => {
  if (isPoint3d2(p3)) {
    if (p3.z !== 0) return false;
  }
  return p3.x === 0 && p3.y === 0;
};
var isPlaceholder2 = (p3) => {
  if (isPoint3d2(p3)) {
    if (!Number.isNaN(p3.z)) return false;
  }
  return Number.isNaN(p3.x) && Number.isNaN(p3.y);
};
function getTwoPointParameters2(a1, ab2, ab3, ab4, ab5, ab6) {
  if (isPoint3d2(a1) && isPoint3d2(ab2)) return [a1, ab2];
  if (isPoint2(a1) && isPoint2(ab2)) return [a1, ab2];
  if (isPoint3d2(a1)) {
    const b$1 = {
      x: ab2,
      y: ab3,
      z: ab4
    };
    if (!isPoint3d2(b$1)) throw new Error(`Expected x, y & z parameters`);
    return [a1, b$1];
  }
  if (isPoint2(a1)) {
    const b$1 = {
      x: ab2,
      y: ab3
    };
    if (!isPoint2(b$1)) throw new Error(`Expected x & y parameters`);
    return [a1, b$1];
  }
  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {
    const a$1 = {
      x: a1,
      y: ab2,
      z: ab3
    };
    const b$1 = {
      x: ab4,
      y: ab5,
      z: ab6
    };
    if (!isPoint3d2(a$1)) throw new Error(`Expected x,y,z for first point`);
    if (!isPoint3d2(b$1)) throw new Error(`Expected x,y,z for second point`);
    return [a$1, b$1];
  }
  const a3 = {
    x: a1,
    y: ab2
  };
  const b3 = {
    x: ab3,
    y: ab4
  };
  if (!isPoint2(a3)) throw new Error(`Expected x,y for first point`);
  if (!isPoint2(b3)) throw new Error(`Expected x,y for second point`);
  return [a3, b3];
}
function getPointParameter2(a3, b3, c5) {
  if (a3 === void 0) return {
    x: 0,
    y: 0
  };
  if (Array.isArray(a3)) {
    if (a3.length === 0) return Object.freeze({
      x: 0,
      y: 0
    });
    if (a3.length === 1) return Object.freeze({
      x: a3[0],
      y: 0
    });
    if (a3.length === 2) return Object.freeze({
      x: a3[0],
      y: a3[1]
    });
    if (a3.length === 3) return Object.freeze({
      x: a3[0],
      y: a3[1],
      z: a3[2]
    });
    throw new Error(`Expected array to be 1-3 elements in length. Got ${a3.length}.`);
  }
  if (isPoint2(a3)) return a3;
  else if (typeof a3 !== `number` || typeof b3 !== `number`) throw new TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(a3)} b: ${JSON.stringify(b3)}`);
  if (typeof c5 === `number`) return Object.freeze({
    x: a3,
    y: b3,
    z: c5
  });
  return Object.freeze({
    x: a3,
    y: b3
  });
}
function distance4(a3, xOrB, y3, z3) {
  const pt2 = getPointParameter2(xOrB, y3, z3);
  guard$12(pt2, `b`);
  guard$12(a3, `a`);
  return isPoint3d2(pt2) && isPoint3d2(a3) ? Math.hypot(pt2.x - a3.x, pt2.y - a3.y, pt2.z - a3.z) : Math.hypot(pt2.x - a3.x, pt2.y - a3.y);
}
function findMinimum2(comparer, ...points) {
  if (points.length === 0) throw new Error(`No points provided`);
  let min4 = points[0];
  for (const p3 of points) if (isPoint3d2(min4) && isPoint3d2(p3)) min4 = comparer(min4, p3);
  else min4 = comparer(min4, p3);
  return min4;
}
var maxFromCorners2 = (topLeft, topRight, bottomRight, bottomLeft) => {
  if (topLeft.y > bottomRight.y) throw new Error(`topLeft.y greater than bottomRight.y`);
  if (topLeft.y > bottomLeft.y) throw new Error(`topLeft.y greater than bottomLeft.y`);
  const w1 = topRight.x - topLeft.x;
  const w22 = bottomRight.x - bottomLeft.x;
  const h1 = Math.abs(bottomLeft.y - topLeft.y);
  const h22 = Math.abs(bottomRight.y - topRight.y);
  return {
    x: Math.min(topLeft.x, bottomLeft.x),
    y: Math.min(topRight.y, topLeft.y),
    width: Math.max(w1, w22),
    height: Math.max(h1, h22)
  };
};
var bbox$12 = (...points) => {
  const leftMost = findMinimum2((a3, b3) => {
    return a3.x < b3.x ? a3 : b3;
  }, ...points);
  const rightMost = findMinimum2((a3, b3) => {
    return a3.x > b3.x ? a3 : b3;
  }, ...points);
  const topMost = findMinimum2((a3, b3) => {
    return a3.y < b3.y ? a3 : b3;
  }, ...points);
  const bottomMost = findMinimum2((a3, b3) => {
    return a3.y > b3.y ? a3 : b3;
  }, ...points);
  const topLeft = {
    x: leftMost.x,
    y: topMost.y
  };
  const topRight = {
    x: rightMost.x,
    y: topMost.y
  };
  const bottomRight = {
    x: rightMost.x,
    y: bottomMost.y
  };
  const bottomLeft = {
    x: leftMost.x,
    y: bottomMost.y
  };
  return maxFromCorners2(topLeft, topRight, bottomRight, bottomLeft);
};
var bbox3d2 = (...points) => {
  const box = bbox$12(...points);
  const zMin = findMinimum2((a3, b3) => {
    return a3.z < b3.z ? a3 : b3;
  }, ...points);
  const zMax = findMinimum2((a3, b3) => {
    return a3.z > b3.z ? a3 : b3;
  }, ...points);
  return {
    ...box,
    z: zMin.z,
    depth: zMax.z - zMin.z
  };
};
var isPolarCoord2 = (p3) => {
  if (p3.distance === void 0) return false;
  if (p3.angleRadian === void 0) return false;
  return true;
};
var guard$62 = (p3, name = `Point`) => {
  if (p3 === void 0) throw new Error(`'${name}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (p3 === null) throw new Error(`'${name}' is null. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (p3.angleRadian === void 0) throw new Error(`'${name}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (p3.distance === void 0) throw new Error(`'${name}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p3)}`);
  if (typeof p3.angleRadian !== `number`) throw new TypeError(`'${name}.angleRadian' must be a number. Got ${p3.angleRadian}`);
  if (typeof p3.distance !== `number`) throw new TypeError(`'${name}.distance' must be a number. Got ${p3.distance}`);
  if (p3.angleRadian === null) throw new Error(`'${name}.angleRadian' is null`);
  if (p3.distance === null) throw new Error(`'${name}.distance' is null`);
  if (Number.isNaN(p3.angleRadian)) throw new TypeError(`'${name}.angleRadian' is NaN`);
  if (Number.isNaN(p3.distance)) throw new Error(`'${name}.distance' is NaN`);
};
var rotate$32 = (c5, amountRadian) => Object.freeze({
  ...c5,
  angleRadian: c5.angleRadian + amountRadian
});
var invert$12 = (p3) => {
  guard$62(p3, `c`);
  return Object.freeze({
    ...p3,
    angleRadian: p3.angleRadian - Math.PI
  });
};
var isOpposite2 = (a3, b3) => {
  guard$62(a3, `a`);
  guard$62(b3, `b`);
  if (a3.distance !== b3.distance) return false;
  return a3.angleRadian === -b3.angleRadian;
};
var isParallel2 = (a3, b3) => {
  guard$62(a3, `a`);
  guard$62(b3, `b`);
  return a3.angleRadian === b3.angleRadian;
};
var isAntiParallel2 = (a3, b3) => {
  guard$62(a3, `a`);
  guard$62(b3, `b`);
  return a3.angleRadian === -b3.angleRadian;
};
var rotateDegrees2 = (c5, amountDeg) => Object.freeze({
  ...c5,
  angleRadian: c5.angleRadian + degreeToRadian2(amountDeg)
});
function subtract$22(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters2(a1, ab2, ab3, ab4, ab5, ab6);
  guard$12(ptA, `a`);
  guard$12(ptB, `b`);
  const pt2 = {
    x: ptA.x - ptB.x,
    y: ptA.y - ptB.y
  };
  if (isPoint3d2(ptA) || isPoint3d2(ptB)) pt2.z = (ptA.z ?? 0) - (ptB.z ?? 0);
  return Object.freeze(pt2);
}
var Empty2 = {
  x: 0,
  y: 0
};
var Unit2 = {
  x: 1,
  y: 1
};
var Empty3d2 = {
  x: 0,
  y: 0,
  z: 0
};
var Unit3d2 = {
  x: 1,
  y: 1,
  z: 1
};
var toLine$12 = (c5, start) => {
  const b3 = toCartesian2(c5, start);
  return {
    a: start,
    b: b3
  };
};
var toCartesian2 = (a3, b3, c5) => {
  if (isPolarCoord2(a3)) {
    if (typeof b3 === `undefined`) b3 = Empty2;
    if (isPoint2(b3)) return polarToCartesian2(a3.distance, a3.angleRadian, b3);
    throw new Error(`Expecting (Coord, Point). Second parameter is not a point`);
  } else if (typeof a3 === `object`) throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(a3)}`);
  else if (typeof a3 === `number` && typeof b3 === `number`) {
    if (typeof c5 === `undefined`) c5 = Empty2;
    if (!isPoint2(c5)) throw new Error(`Expecting (number, number, Point). Point param wrong type`);
    return polarToCartesian2(a3, b3, c5);
  } else throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof a3}, ${typeof b3}, ${typeof c5}). a: ${JSON.stringify(a3)}`);
};
var fromCartesian2 = (point$1, origin) => {
  if (typeof point$1 === `undefined`) throw new Error(`Param 'point' missing. Expecting a Point`);
  if (typeof origin === `undefined`) throw new Error(`Param 'origin' missing. Expecting a Point`);
  point$1 = subtract$22(point$1, origin);
  const angle = Math.atan2(point$1.y, point$1.x);
  const distance$2 = Math.hypot(point$1.x, point$1.y);
  const polar = {
    ...point$1,
    angleRadian: angle,
    distance: distance$2
  };
  delete polar.x;
  delete polar.y;
  return Object.freeze(polar);
};
var polarToCartesian2 = (distance$2, angleRadians, origin = Empty2) => {
  guard$12(origin);
  return Object.freeze({
    x: origin.x + distance$2 * Math.cos(angleRadians),
    y: origin.y + distance$2 * Math.sin(angleRadians)
  });
};
var toString$52 = (p3, digits) => {
  if (p3 === void 0) return `(undefined)`;
  if (p3 === null) return `(null)`;
  const angleDeg = radianToDegree2(p3.angleRadian);
  const d3 = digits ? p3.distance.toFixed(digits) : p3.distance;
  const a3 = digits ? angleDeg.toFixed(digits) : angleDeg;
  return `(${d3},${a3})`;
};
var toPoint2 = (v3, origin = Empty2) => {
  guard$62(v3, `v`);
  return Object.freeze({
    x: origin.x + v3.distance * Math.cos(v3.angleRadian),
    y: origin.y + v3.distance * Math.sin(v3.angleRadian)
  });
};
var normalise$22 = (c5) => {
  if (c5.distance === 0) throw new Error(`Cannot normalise vector of length 0`);
  return Object.freeze({
    ...c5,
    distance: 1
  });
};
var clampMagnitude$22 = (v3, max4 = 1, min4 = 0) => {
  let mag = v3.distance;
  if (mag > max4) mag = max4;
  if (mag < min4) mag = min4;
  return Object.freeze({
    ...v3,
    distance: mag
  });
};
var dotProduct$32 = (a3, b3) => {
  guard$62(a3, `a`);
  guard$62(b3, `b`);
  return a3.distance * b3.distance * Math.cos(b3.angleRadian - a3.angleRadian);
};
var multiply$42 = (v3, amt) => {
  guard$62(v3);
  resultThrow(numberTest(amt, ``, `amt`));
  return Object.freeze({
    ...v3,
    distance: v3.distance * amt
  });
};
var divide$42 = (v3, amt) => {
  guard$62(v3);
  resultThrow(numberTest(amt, ``, `amt`));
  return Object.freeze({
    ...v3,
    distance: v3.distance / amt
  });
};
var Placeholder$32 = Object.freeze({
  x: NaN,
  y: NaN
});
var Placeholder3d2 = Object.freeze({
  x: NaN,
  y: NaN,
  z: NaN
});
var angleRadian2 = (a3, b3, c5) => {
  guard$12(a3, `a`);
  if (b3 === void 0) return Math.atan2(a3.y, a3.x);
  guard$12(b3, `b`);
  if (c5 === void 0) return Math.atan2(b3.y - a3.y, b3.x - a3.x);
  guard$12(c5, `c`);
  return Math.atan2(b3.y - a3.y, b3.x - a3.x) - Math.atan2(c5.y - a3.y, c5.x - a3.x);
};
var angleRadianCircle2 = (a3, b3, c5) => {
  const angle = angleRadian2(a3, b3, c5);
  if (angle < 0) return angle + piPi5;
  return angle;
};
var toIntegerValues2 = (pt2, rounder = Math.round) => {
  guard$12(pt2, `pt`);
  return Object.freeze({
    x: rounder(pt2.x),
    y: rounder(pt2.y)
  });
};
var to2d2 = (pt2) => {
  guard$12(pt2, `pt`);
  let copy = { ...pt2 };
  delete copy.z;
  return Object.freeze(copy);
};
var to3d2 = (pt2, z3 = 0) => {
  guard$12(pt2, `pt`);
  return Object.freeze({
    ...pt2,
    z: z3
  });
};
function toString$22(p3, digits) {
  if (p3 === void 0) return `(undefined)`;
  if (p3 === null) return `(null)`;
  guard$12(p3, `pt`);
  const x3 = digits ? p3.x.toFixed(digits) : p3.x;
  const y3 = digits ? p3.y.toFixed(digits) : p3.y;
  if (p3.z === void 0) return `(${x3},${y3})`;
  else {
    const z3 = digits ? p3.z.toFixed(digits) : p3.z;
    return `(${x3},${y3},${z3})`;
  }
}
var ray_exports2 = {};
__export(ray_exports2, {
  fromLine: () => fromLine2,
  toCartesian: () => toCartesian$22,
  toString: () => toString$42
});
var toCartesian$22 = (ray, origin) => {
  const o5 = getOrigin2(ray, origin);
  const a3 = toCartesian2(ray.offset, ray.angleRadian, o5);
  const b3 = toCartesian2(ray.offset + ray.length, ray.angleRadian, o5);
  return {
    a: a3,
    b: b3
  };
};
var getOrigin2 = (ray, origin) => {
  if (origin !== void 0) return origin;
  if (ray.origin !== void 0) return ray.origin;
  return {
    x: 0,
    y: 0
  };
};
var toString$42 = (ray) => {
  let basic = `PolarRay(angle: ${ray.angleRadian} offset: ${ray.offset} len: ${ray.length}`;
  if (ray.origin) basic += ` origin: ${toString$22(ray.origin)}`;
  basic += `)`;
  return basic;
};
var fromLine2 = (line3, origin) => {
  const o5 = origin ?? line3.a;
  return {
    angleRadian: angleRadian2(line3.b, o5),
    offset: distance4(line3.a, o5),
    length: distance4(line3.b, line3.a),
    origin: o5
  };
};
function* spiral2(smoothness, zoom) {
  let step = 0;
  while (true) {
    const a3 = smoothness * step++;
    yield {
      distance: zoom * a3,
      angleRadian: a3,
      step
    };
  }
}
var spiralRaw2 = (step, smoothness, zoom) => {
  const a3 = smoothness * step;
  return Object.freeze({
    distance: zoom * a3,
    angleRadian: a3
  });
};
var polar_exports2 = {};
__export(polar_exports2, {
  Ray: () => ray_exports2,
  clampMagnitude: () => clampMagnitude$22,
  divide: () => divide$42,
  dotProduct: () => dotProduct$32,
  fromCartesian: () => fromCartesian2,
  guard: () => guard$62,
  invert: () => invert$12,
  isAntiParallel: () => isAntiParallel2,
  isOpposite: () => isOpposite2,
  isParallel: () => isParallel2,
  isPolarCoord: () => isPolarCoord2,
  multiply: () => multiply$42,
  normalise: () => normalise$22,
  rotate: () => rotate$32,
  rotateDegrees: () => rotateDegrees2,
  spiral: () => spiral2,
  spiralRaw: () => spiralRaw2,
  toCartesian: () => toCartesian2,
  toLine: () => toLine$12,
  toPoint: () => toPoint2,
  toString: () => toString$52
});
var fromPoints$22 = (a3, b3) => {
  guard$12(a3, `a`);
  guard$12(b3, `b`);
  a3 = Object.freeze({ ...a3 });
  b3 = Object.freeze({ ...b3 });
  return Object.freeze({
    a: a3,
    b: b3
  });
};
var arc_exports2 = {};
__export(arc_exports2, {
  angularSize: () => angularSize2,
  bbox: () => bbox$52,
  distanceCenter: () => distanceCenter$12,
  fromCircle: () => fromCircle2,
  fromCircleAmount: () => fromCircleAmount2,
  fromDegrees: () => fromDegrees$12,
  getStartEnd: () => getStartEnd2,
  guard: () => guard$54,
  interpolate: () => interpolate$42,
  isArc: () => isArc2,
  isEqual: () => isEqual$62,
  isPositioned: () => isPositioned$22,
  length: () => length$32,
  point: () => point2,
  toLine: () => toLine2,
  toPath: () => toPath$32,
  toSvg: () => toSvg$12
});
var isArc2 = (p3) => typeof p3.startRadian !== `undefined` && typeof p3.endRadian !== `undefined` && typeof p3.clockwise !== `undefined`;
var isPositioned$22 = (p3) => typeof p3.x !== `undefined` && typeof p3.y !== `undefined`;
function fromDegrees$12(radius, startDegrees, endDegrees, clockwise, origin) {
  const a3 = {
    radius,
    startRadian: degreeToRadian2(startDegrees),
    endRadian: degreeToRadian2(endDegrees),
    clockwise
  };
  if (isPoint2(origin)) {
    guard$12(origin);
    const ap = {
      ...a3,
      x: origin.x,
      y: origin.y
    };
    return Object.freeze(ap);
  } else return Object.freeze(a3);
}
var toLine2 = (arc3) => fromPoints$22(point2(arc3, arc3.startRadian), point2(arc3, arc3.endRadian));
var getStartEnd2 = (arc3, origin) => {
  guard$54(arc3);
  const start = point2(arc3, arc3.startRadian, origin);
  const end = point2(arc3, arc3.endRadian, origin);
  return [start, end];
};
var point2 = (arc3, angleRadian$2, origin) => {
  if (typeof origin === `undefined`) origin = isPositioned$22(arc3) ? arc3 : {
    x: 0,
    y: 0
  };
  return {
    x: Math.cos(angleRadian$2) * arc3.radius + origin.x,
    y: Math.sin(angleRadian$2) * arc3.radius + origin.y
  };
};
var guard$54 = (arc3) => {
  if (typeof arc3 === `undefined`) throw new TypeError(`Arc is undefined`);
  if (isPositioned$22(arc3)) guard$12(arc3, `arc`);
  if (typeof arc3.radius === `undefined`) throw new TypeError(`Arc radius is undefined (${JSON.stringify(arc3)})`);
  if (typeof arc3.radius !== `number`) throw new TypeError(`Radius must be a number`);
  if (Number.isNaN(arc3.radius)) throw new TypeError(`Radius is NaN`);
  if (arc3.radius <= 0) throw new TypeError(`Radius must be greater than zero`);
  if (typeof arc3.startRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);
  if (typeof arc3.endRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);
  if (Number.isNaN(arc3.endRadian)) throw new TypeError(`Arc endRadian is NaN`);
  if (Number.isNaN(arc3.startRadian)) throw new TypeError(`Arc endRadian is NaN`);
  if (typeof arc3.clockwise === `undefined`) throw new TypeError(`Arc is missing 'clockwise field`);
  if (arc3.startRadian >= arc3.endRadian) throw new TypeError(`startRadian is expected to be les than endRadian`);
};
var interpolate$42 = (amount, arc3, allowOverflow, origin) => {
  guard$54(arc3);
  const overflowOk = allowOverflow ?? false;
  if (!overflowOk) {
    if (amount < 0) throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);
    if (amount > 1) throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);
  }
  const span = angularSize2(arc3);
  const rel = span * amount;
  const angle = radiansSum2(arc3.startRadian, rel, arc3.clockwise);
  return point2(arc3, angle, origin);
};
var angularSize2 = (arc3) => radianArc2(arc3.startRadian, arc3.endRadian, arc3.clockwise);
var toPath$32 = (arc3) => {
  guard$54(arc3);
  return Object.freeze({
    ...arc3,
    nearest: (_point) => {
      throw new Error(`not implemented`);
    },
    interpolate: (amount) => interpolate$42(amount, arc3),
    bbox: () => bbox$52(arc3),
    length: () => length$32(arc3),
    toSvgString: () => toSvg$12(arc3),
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    kind: `arc`
  });
};
var fromCircle2 = (circle3, startRadian, endRadian, clockwise = true) => {
  const a3 = Object.freeze({
    ...circle3,
    endRadian,
    startRadian,
    clockwise
  });
  return a3;
};
var fromCircleAmount2 = (circle3, startRadian, sizeRadian, clockwise = true) => {
  const endRadian = radiansSum2(startRadian, sizeRadian, clockwise);
  return fromCircle2(circle3, startRadian, endRadian);
};
var length$32 = (arc3) => piPi5 * arc3.radius * ((arc3.startRadian - arc3.endRadian) / piPi5);
var bbox$52 = (arc3) => {
  if (isPositioned$22(arc3)) {
    const middle = interpolate$42(0.5, arc3);
    const asLine = toLine2(arc3);
    return bbox$12(middle, asLine.a, asLine.b);
  } else return {
    width: arc3.radius * 2,
    height: arc3.radius * 2
  };
};
var toSvg$12 = (a3, b3, c5, d3, e5) => {
  if (isArc2(a3)) if (isPositioned$22(a3)) if (isPoint2(b3)) return toSvgFull$12(b3, a3.radius, a3.startRadian, a3.endRadian, c5);
  else return toSvgFull$12(a3, a3.radius, a3.startRadian, a3.endRadian, b3);
  else return isPoint2(b3) ? toSvgFull$12(b3, a3.radius, a3.startRadian, a3.endRadian, c5) : toSvgFull$12({
    x: 0,
    y: 0
  }, a3.radius, a3.startRadian, a3.endRadian);
  else {
    if (c5 === void 0) throw new Error(`startAngle undefined`);
    if (d3 === void 0) throw new Error(`endAngle undefined`);
    if (isPoint2(a3)) if (typeof b3 === `number` && typeof c5 === `number` && typeof d3 === `number`) return toSvgFull$12(a3, b3, c5, d3, e5);
    else throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);
    else throw new Error(`Expected (point, number, number, number). Missing first point.`);
  }
};
var toSvgFull$12 = (origin, radius, startRadian, endRadian, opts) => {
  if (opts === void 0 || typeof opts !== `object`) opts = {};
  const isFullCircle = endRadian - startRadian === 360;
  const start = toCartesian2(radius, endRadian - 0.01, origin);
  const end = toCartesian2(radius, startRadian, origin);
  const { largeArc = false, sweep = false } = opts;
  const d3 = [`
    M ${start.x} ${start.y}
    A ${radius} ${radius} 0 ${largeArc ? `1` : `0`} ${sweep ? `1` : `0`} ${end.x} ${end.y},
  `];
  if (isFullCircle) d3.push(`z`);
  return d3;
};
var distanceCenter$12 = (a3, b3) => distance4(a3, b3);
var isEqual$62 = (a3, b3) => {
  if (a3.radius !== b3.radius) return false;
  if (a3.endRadian !== b3.endRadian) return false;
  if (a3.startRadian !== b3.startRadian) return false;
  if (a3.clockwise !== b3.clockwise) return false;
  if (isPositioned$22(a3) && isPositioned$22(b3)) {
    if (a3.x !== b3.x) return false;
    if (a3.y !== b3.y) return false;
    if (a3.z !== b3.z) return false;
  } else if (!isPositioned$22(a3) && !isPositioned$22(b3)) {
  } else return false;
  return true;
};
var isLine2 = (p3) => {
  if (p3 === void 0) return false;
  if (p3.a === void 0) return false;
  if (p3.b === void 0) return false;
  if (!isPoint2(p3.a)) return false;
  if (!isPoint2(p3.b)) return false;
  return true;
};
var isPolyLine2 = (p3) => {
  if (!Array.isArray(p3)) return false;
  const valid = !p3.some((v3) => !isLine2(v3));
  return valid;
};
var guard$34 = (line3, name = `line`) => {
  if (line3 === void 0) throw new Error(`${name} undefined`);
  if (line3.a === void 0) throw new Error(`${name}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(line3)}`);
  if (line3.b === void 0) throw new Error(`${name}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(line3)}`);
};
var getPointParameter$12 = (aOrLine, b3) => {
  let a3;
  if (isLine2(aOrLine)) {
    b3 = aOrLine.b;
    a3 = aOrLine.a;
  } else {
    a3 = aOrLine;
    if (b3 === void 0) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(a3)} b: ${JSON.stringify(b3)}`);
  }
  guard$12(a3, `a`);
  guard$12(a3, `b`);
  return [a3, b3];
};
function length2(aOrLine, pointB) {
  if (isPolyLine2(aOrLine)) {
    const sum$4 = aOrLine.reduce((accumulator, v3) => length2(v3) + accumulator, 0);
    return sum$4;
  }
  if (aOrLine === void 0) throw new TypeError(`Parameter 'aOrLine' is undefined`);
  const [a3, b3] = getPointParameter$12(aOrLine, pointB);
  const x3 = b3.x - a3.x;
  const y3 = b3.y - a3.y;
  if (a3.z !== void 0 && b3.z !== void 0) {
    const z3 = b3.z - a3.z;
    return Math.hypot(x3, y3, z3);
  } else return Math.hypot(x3, y3);
}
function reverse2(line3) {
  guard$34(line3, `line`);
  return {
    a: line3.b,
    b: line3.a
  };
}
function interpolate$12(amount, aOrLine, pointBOrAllowOverflow, allowOverflow) {
  if (typeof pointBOrAllowOverflow === `boolean`) {
    allowOverflow = pointBOrAllowOverflow;
    pointBOrAllowOverflow = void 0;
  }
  if (!allowOverflow) resultThrow(percentTest(amount, `amount`));
  else resultThrow(numberTest(amount, ``, `amount`));
  const [a3, b3] = getPointParameter$12(aOrLine, pointBOrAllowOverflow);
  const d3 = length2(a3, b3);
  const d22 = d3 * (1 - amount);
  if (d3 === 0 && d22 === 0) return Object.freeze({ ...b3 });
  const x3 = b3.x - d22 * (b3.x - a3.x) / d3;
  const y3 = b3.y - d22 * (b3.y - a3.y) / d3;
  return Object.freeze({
    ...b3,
    x: x3,
    y: y3
  });
}
function pointAtDistance2(line3, distance$2, fromA$2 = true) {
  if (!fromA$2) line3 = reverse2(line3);
  const dx = line3.b.x - line3.a.x;
  const dy = line3.b.y - line3.a.y;
  const theta = Math.atan2(dy, dx);
  const xp = distance$2 * Math.cos(theta);
  const yp = distance$2 * Math.sin(theta);
  return {
    x: xp + line3.a.x,
    y: yp + line3.a.y
  };
}
var guardDim2 = (d3, name = `Dimension`) => {
  if (d3 === void 0) throw new Error(`${name} is undefined`);
  if (Number.isNaN(d3)) throw new Error(`${name} is NaN`);
  if (d3 < 0) throw new Error(`${name} cannot be negative`);
};
var guard$24 = (rect3, name = `rect`) => {
  if (rect3 === void 0) throw new Error(`{$name} undefined`);
  if (isPositioned2(rect3)) guard$12(rect3, name);
  guardDim2(rect3.width, name + `.width`);
  guardDim2(rect3.height, name + `.height`);
};
var getRectPositioned2 = (rect3, origin) => {
  guard$24(rect3);
  if (isPositioned2(rect3) && origin === void 0) return rect3;
  if (origin === void 0) throw new Error(`Unpositioned rect needs origin parameter`);
  return Object.freeze({
    ...rect3,
    ...origin
  });
};
var guardPositioned2 = (rect3, name = `rect`) => {
  if (!isPositioned2(rect3)) throw new Error(`Expected ${name} to have x,y`);
  guard$24(rect3, name);
};
var isEmpty$32 = (rect3) => rect3.width === 0 && rect3.height === 0;
var isPlaceholder$32 = (rect3) => Number.isNaN(rect3.width) && Number.isNaN(rect3.height);
var isPositioned2 = (rect3) => rect3.x !== void 0 && rect3.y !== void 0;
var isRect2 = (rect3) => {
  if (rect3 === void 0) return false;
  if (rect3.width === void 0) return false;
  if (rect3.height === void 0) return false;
  return true;
};
var isRectPositioned2 = (rect3) => isRect2(rect3) && isPositioned2(rect3);
var fromTopLeft2 = (origin, width, height$3) => {
  guardDim2(width, `width`);
  guardDim2(height$3, `height`);
  guard$12(origin, `origin`);
  return {
    x: origin.x,
    y: origin.y,
    width,
    height: height$3
  };
};
var isQuadraticBezier2 = (path3) => path3.quadratic !== void 0;
var isCubicBezier2 = (path3) => path3.cubic1 !== void 0 && path3.cubic2 !== void 0;
var bezier_exports2 = {};
__export(bezier_exports2, {
  cubic: () => cubic2,
  interpolator: () => interpolator4,
  isCubicBezier: () => isCubicBezier2,
  isQuadraticBezier: () => isQuadraticBezier2,
  quadratic: () => quadratic2,
  quadraticSimple: () => quadraticSimple2,
  quadraticToSvgString: () => quadraticToSvgString2,
  toPath: () => toPath$22
});
var quadraticSimple2 = (start, end, bend = 0) => {
  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);
  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);
  const middle = interpolate$12(0.5, start, end);
  let target = middle;
  if (end.y < start.y) target = bend > 0 ? {
    x: Math.min(start.x, end.x),
    y: Math.min(start.y, end.y)
  } : {
    x: Math.max(start.x, end.x),
    y: Math.max(start.y, end.y)
  };
  else target = bend > 0 ? {
    x: Math.max(start.x, end.x),
    y: Math.min(start.y, end.y)
  } : {
    x: Math.min(start.x, end.x),
    y: Math.max(start.y, end.y)
  };
  const handle = interpolate$12(Math.abs(bend), middle, target);
  return quadratic2(start, end, handle);
};
var interpolator4 = (q3) => {
  const bzr = isCubicBezier2(q3) ? new Bezier(q3.a.x, q3.a.y, q3.cubic1.x, q3.cubic1.y, q3.cubic2.x, q3.cubic2.y, q3.b.x, q3.b.y) : new Bezier(q3.a, q3.quadratic, q3.b);
  return (amount) => bzr.compute(amount);
};
var quadraticToSvgString2 = (start, end, handle) => [`M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`];
var toPath$22 = (cubicOrQuadratic) => {
  if (isCubicBezier2(cubicOrQuadratic)) return cubicToPath2(cubicOrQuadratic);
  else if (isQuadraticBezier2(cubicOrQuadratic)) return quadratictoPath2(cubicOrQuadratic);
  else throw new Error(`Unknown bezier type`);
};
var cubic2 = (start, end, cubic1, cubic22) => ({
  a: Object.freeze(start),
  b: Object.freeze(end),
  cubic1: Object.freeze(cubic1),
  cubic2: Object.freeze(cubic22)
});
var cubicToPath2 = (cubic$1) => {
  const { a: a3, cubic1, cubic2: cubic22, b: b3 } = cubic$1;
  const bzr = new Bezier(a3, cubic1, cubic22, b3);
  return Object.freeze({
    ...cubic$1,
    length: () => bzr.length(),
    interpolate: (t6) => bzr.compute(t6),
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    bbox: () => {
      const { x: x3, y: y3 } = bzr.bbox();
      const xSize = x3.size;
      const ySize = y3.size;
      if (xSize === void 0) throw new Error(`x.size not present on calculated bbox`);
      if (ySize === void 0) throw new Error(`x.size not present on calculated bbox`);
      return fromTopLeft2({
        x: x3.min,
        y: y3.min
      }, xSize, ySize);
    },
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    toSvgString: () => [`brrup`],
    kind: `bezier/cubic`
  });
};
var quadratic2 = (start, end, handle) => ({
  a: Object.freeze(start),
  b: Object.freeze(end),
  quadratic: Object.freeze(handle)
});
var quadratictoPath2 = (quadraticBezier3) => {
  const { a: a3, b: b3, quadratic: quadratic$1 } = quadraticBezier3;
  const bzr = new Bezier(a3, quadratic$1, b3);
  return Object.freeze({
    ...quadraticBezier3,
    length: () => bzr.length(),
    interpolate: (t6) => bzr.compute(t6),
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    bbox: () => {
      const { x: x3, y: y3 } = bzr.bbox();
      const xSize = x3.size;
      const ySize = y3.size;
      if (xSize === void 0) throw new Error(`x.size not present on calculated bbox`);
      if (ySize === void 0) throw new Error(`x.size not present on calculated bbox`);
      return fromTopLeft2({
        x: x3.min,
        y: y3.min
      }, xSize, ySize);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    toString: () => bzr.toString(),
    toSvgString: () => quadraticToSvgString2(a3, b3, quadratic$1),
    kind: `bezier/quadratic`
  });
};
var guard$44 = (circle3, parameterName = `circle`) => {
  if (isCirclePositioned2(circle3)) guard$12(circle3, `circle`);
  if (Number.isNaN(circle3.radius)) throw new Error(`${parameterName}.radius is NaN`);
  if (circle3.radius <= 0) throw new Error(`${parameterName}.radius must be greater than zero`);
};
var guardPositioned$12 = (circle3, parameterName = `circle`) => {
  if (!isCirclePositioned2(circle3)) throw new Error(`Expected a positioned circle with x,y`);
  guard$44(circle3, parameterName);
};
var isNaN3 = (a3) => {
  if (Number.isNaN(a3.radius)) return true;
  if (isCirclePositioned2(a3)) {
    if (Number.isNaN(a3.x)) return true;
    if (Number.isNaN(a3.y)) return true;
  }
  return false;
};
var isPositioned$12 = (p3) => p3.x !== void 0 && p3.y !== void 0;
var isCircle2 = (p3) => p3.radius !== void 0;
var isCirclePositioned2 = (p3) => isCircle2(p3) && isPositioned$12(p3);
var area$52 = (circle3) => {
  guard$44(circle3);
  return Math.PI * circle3.radius * circle3.radius;
};
var fromCenter$22 = (origin, width, height$3) => {
  guard$12(origin, `origin`);
  guardDim2(width, `width`);
  guardDim2(height$3, `height`);
  const halfW = width / 2;
  const halfH = height$3 / 2;
  return {
    x: origin.x - halfW,
    y: origin.y - halfH,
    width,
    height: height$3
  };
};
var bbox$42 = (circle3) => {
  return isCirclePositioned2(circle3) ? fromCenter$22(circle3, circle3.radius * 2, circle3.radius * 2) : {
    width: circle3.radius * 2,
    height: circle3.radius * 2,
    x: 0,
    y: 0
  };
};
var center2 = (circle3) => {
  return isCirclePositioned2(circle3) ? Object.freeze({
    x: circle3.x,
    y: circle3.y
  }) : Object.freeze({
    x: circle3.radius,
    y: circle3.radius
  });
};
var distanceCenter2 = (a3, b3) => {
  guardPositioned$12(a3, `a`);
  if (isCirclePositioned2(b3)) guardPositioned$12(b3, `b`);
  return distance4(a3, b3);
};
var distanceFromExterior$12 = (a3, b3) => {
  guardPositioned$12(a3, `a`);
  if (isCirclePositioned2(b3)) return Math.max(0, distanceCenter2(a3, b3) - a3.radius - b3.radius);
  else if (isPoint2(b3)) {
    const distribution = distance4(a3, b3);
    if (distribution < a3.radius) return 0;
    return distribution;
  } else throw new Error(`Second parameter invalid type`);
};
function* exteriorIntegerPoints2(circle3) {
  const { x: x3, y: y3, radius } = circle3;
  let xx = radius;
  let yy = 0;
  let radiusError = 1 - x3;
  while (xx >= yy) {
    yield {
      x: xx + x3,
      y: yy + y3
    };
    yield {
      x: yy + x3,
      y: xx + y3
    };
    yield {
      x: -xx + x3,
      y: yy + y3
    };
    yield {
      x: -yy + x3,
      y: xx + y3
    };
    yield {
      x: -xx + x3,
      y: -yy + y3
    };
    yield {
      x: -yy + x3,
      y: -xx + y3
    };
    yield {
      x: xx + x3,
      y: -yy + y3
    };
    yield {
      x: yy + x3,
      y: -xx + y3
    };
    yy++;
    if (radiusError < 0) radiusError += 2 * yy + 1;
    else {
      xx--;
      radiusError += 2 * (yy - xx + 1);
    }
  }
}
function* interiorIntegerPoints2(circle3) {
  const xMin = circle3.x - circle3.radius;
  const xMax = circle3.x + circle3.radius;
  const yMin = circle3.y - circle3.radius;
  const yMax = circle3.y + circle3.radius;
  for (let x3 = xMin; x3 < xMax; x3++) for (let y3 = yMin; y3 < yMax; y3++) {
    const r5 = Math.abs(distance4(circle3, x3, y3));
    if (r5 <= circle3.radius) yield {
      x: x3,
      y: y3
    };
  }
}
var piPi$52 = Math.PI * 2;
var nearest$12 = (circle3, point$1) => {
  const n6 = (a3) => {
    const l3 = Math.sqrt(Math.pow(point$1.x - a3.x, 2) + Math.pow(point$1.y - a3.y, 2));
    const x3 = a3.x + a3.radius * ((point$1.x - a3.x) / l3);
    const y3 = a3.y + a3.radius * ((point$1.y - a3.y) / l3);
    return {
      x: x3,
      y: y3
    };
  };
  if (Array.isArray(circle3)) {
    const pts = circle3.map((l3) => n6(l3));
    const dists = pts.map((p3) => distance4(p3, point$1));
    return Object.freeze(pts[minIndex(...dists)]);
  } else return Object.freeze(n6(circle3));
};
var pointOnPerimeter2 = (circle3, angleRadian$2, origin) => {
  if (origin === void 0) origin = isCirclePositioned2(circle3) ? circle3 : {
    x: 0,
    y: 0
  };
  return {
    x: Math.cos(-angleRadian$2) * circle3.radius + origin.x,
    y: Math.sin(-angleRadian$2) * circle3.radius + origin.y
  };
};
var circumference2 = (circle3) => {
  guard$44(circle3);
  return piPi$52 * circle3.radius;
};
var length$22 = (circle3) => circumference2(circle3);
var piPi$42 = Math.PI * 2;
var interpolate$32 = (circle3, t6) => pointOnPerimeter2(circle3, t6 * piPi$42);
var isEqual$52 = (a3, b3) => {
  if (a3.radius !== b3.radius) return false;
  if (isCirclePositioned2(a3) && isCirclePositioned2(b3)) {
    if (a3.x !== b3.x) return false;
    if (a3.y !== b3.y) return false;
    if (a3.z !== b3.z) return false;
    return true;
  } else if (!isCirclePositioned2(a3) && !isCirclePositioned2(b3)) {
  } else return false;
  return false;
};
function sum$13(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters2(a1, ab2, ab3, ab4, ab5, ab6);
  guard$12(ptA, `a`);
  guard$12(ptB, `b`);
  const pt2 = {
    x: ptA.x + ptB.x,
    y: ptA.y + ptB.y
  };
  if (isPoint3d2(ptA) || isPoint3d2(ptB)) pt2.z = (ptA.z ?? 0) + (ptB.z ?? 0);
  return Object.freeze(pt2);
}
var intersectionLine2 = (circle3, line3) => {
  const v1 = {
    x: line3.b.x - line3.a.x,
    y: line3.b.y - line3.a.y
  };
  const v22 = {
    x: line3.a.x - circle3.x,
    y: line3.a.y - circle3.y
  };
  const b3 = (v1.x * v22.x + v1.y * v22.y) * -2;
  const c5 = 2 * (v1.x * v1.x + v1.y * v1.y);
  const d3 = Math.sqrt(b3 * b3 - 2 * c5 * (v22.x * v22.x + v22.y * v22.y - circle3.radius * circle3.radius));
  if (Number.isNaN(d3)) return [];
  const u1 = (b3 - d3) / c5;
  const u22 = (b3 + d3) / c5;
  const returnValue = [];
  if (u1 <= 1 && u1 >= 0) returnValue.push({
    x: line3.a.x + v1.x * u1,
    y: line3.a.y + v1.y * u1
  });
  if (u22 <= 1 && u22 >= 0) returnValue.push({
    x: line3.a.x + v1.x * u22,
    y: line3.a.y + v1.y * u22
  });
  return returnValue;
};
var intersections2 = (a3, b3) => {
  const vector = subtract$22(b3, a3);
  const centerD = Math.hypot(vector.y, vector.x);
  if (centerD > a3.radius + b3.radius) return [];
  if (centerD < Math.abs(a3.radius - b3.radius)) return [];
  if (isEqual$52(a3, b3)) return [];
  const centroidD = (a3.radius * a3.radius - b3.radius * b3.radius + centerD * centerD) / (2 * centerD);
  const centroid$2 = {
    x: a3.x + vector.x * centroidD / centerD,
    y: a3.y + vector.y * centroidD / centerD
  };
  const centroidIntersectionD = Math.sqrt(a3.radius * a3.radius - centroidD * centroidD);
  const intersection2 = {
    x: -vector.y * (centroidIntersectionD / centerD),
    y: vector.x * (centroidIntersectionD / centerD)
  };
  return [sum$13(centroid$2, intersection2), subtract$22(centroid$2, intersection2)];
};
var circleRect2 = (a3, b3) => {
  const deltaX = a3.x - Math.max(b3.x, Math.min(a3.x, b3.x + b3.width));
  const deltaY = a3.y - Math.max(b3.y, Math.min(a3.y, b3.y + b3.height));
  return deltaX * deltaX + deltaY * deltaY < a3.radius * a3.radius;
};
var circleCircle2 = (a3, b3) => intersections2(a3, b3).length === 2;
var isContainedBy2 = (a3, b3, c5) => {
  const d3 = distanceCenter2(a3, b3);
  if (isCircle2(b3)) return d3 < Math.abs(a3.radius - b3.radius);
  else if (isPoint2(b3)) if (c5 === void 0) return d3 <= a3.radius;
  else return d3 < Math.abs(a3.radius - c5);
  else throw new Error(`b parameter is expected to be CirclePositioned or Point`);
};
var isEqual3 = (...p3) => {
  if (p3 === void 0) throw new Error(`parameter 'p' is undefined`);
  if (p3.length < 2) return true;
  for (let index = 1; index < p3.length; index++) {
    if (p3[index].x !== p3[0].x) return false;
    if (p3[index].y !== p3[0].y) return false;
  }
  return true;
};
var isIntersecting2 = (a3, b3, c5) => {
  if (isEqual3(a3, b3)) return true;
  if (isContainedBy2(a3, b3, c5)) return true;
  if (isCircle2(b3)) return circleCircle2(a3, b3);
  else if (isRectPositioned2(b3)) return circleRect2(a3, b3);
  else if (isPoint2(b3) && c5 !== void 0) return circleCircle2(a3, {
    ...b3,
    radius: c5
  });
  return false;
};
function multiply$22(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters2(a1, ab2, ab3, ab4, ab5, ab6);
  guard$12(ptA, `a`);
  guard$12(ptB, `b`);
  const pt2 = {
    x: ptA.x * ptB.x,
    y: ptA.y * ptB.y
  };
  if (isPoint3d2(ptA) || isPoint3d2(ptB)) pt2.z = (ptA.z ?? 0) * (ptB.z ?? 0);
  return Object.freeze(pt2);
}
var multiplyScalar$12 = (pt2, v3) => {
  return isPoint3d2(pt2) ? Object.freeze({
    ...pt2,
    x: pt2.x * v3,
    y: pt2.y * v3,
    z: pt2.z * v3
  }) : Object.freeze({
    ...pt2,
    x: pt2.x * v3,
    y: pt2.y * v3
  });
};
function multiplyScalar$22(a3, value3) {
  if (isCirclePositioned2(a3)) {
    const pt2 = multiplyScalar$12(a3, value3);
    return Object.freeze({
      ...a3,
      ...pt2,
      radius: a3.radius * value3
    });
  } else return Object.freeze({
    ...a3,
    radius: a3.radius * value3
  });
}
var piPi$32 = Math.PI * 2;
var randomPoint$12 = (within, opts = {}) => {
  const offset$1 = isCirclePositioned2(within) ? within : {
    x: 0,
    y: 0
  };
  const strategy = opts.strategy ?? `uniform`;
  const margin = opts.margin ?? 0;
  const radius = within.radius - margin;
  const rand = opts.randomSource ?? Math.random;
  switch (strategy) {
    case `naive`:
      return sum$13(offset$1, toCartesian2(rand() * radius, rand() * piPi$32));
    case `uniform`:
      return sum$13(offset$1, toCartesian2(Math.sqrt(rand()) * radius, rand() * piPi$32));
    default:
      throw new Error(`Unknown strategy '${strategy}'. Expects 'uniform' or 'naive'`);
  }
};
var toSvg2 = (a3, sweep, origin) => {
  if (isCircle2(a3)) {
    if (origin !== void 0) return toSvgFull2(a3.radius, origin, sweep);
    if (isCirclePositioned2(a3)) return toSvgFull2(a3.radius, a3, sweep);
    else throw new Error(`origin parameter needed for non-positioned circle`);
  } else if (origin === void 0) throw new Error(`origin parameter needed`);
  else return toSvgFull2(a3, origin, sweep);
};
var toSvgFull2 = (radius, origin, sweep) => {
  const { x: x3, y: y3 } = origin;
  const s3 = sweep ? `1` : `0`;
  return `
    M ${x3}, ${y3}
    m -${radius}, 0
    a ${radius},${radius} 0 1,${s3} ${radius * 2},0
    a ${radius},${radius} 0 1,${s3} -${radius * 2},0
  `.split(`
`);
};
var toPath$12 = (circle3) => {
  guard$44(circle3);
  return {
    ...circle3,
    nearest: (point$1) => nearest$12(circle3, point$1),
    interpolate: (t6) => interpolate$32(circle3, t6),
    bbox: () => bbox$42(circle3),
    length: () => circumference2(circle3),
    toSvgString: (sweep = true) => toSvg2(circle3, sweep),
    relativePosition: (_point, _intersectionThreshold) => {
      throw new Error(`Not implemented`);
    },
    distanceToPoint: (_point) => {
      throw new Error(`Not implemented`);
    },
    kind: `circular`
  };
};
var toPositioned2 = (circle3, defaultPositionOrX, y3) => {
  if (isCirclePositioned2(circle3)) return circle3;
  const pt2 = getPointParameter2(defaultPositionOrX, y3);
  return Object.freeze({
    ...circle3,
    ...pt2
  });
};
var circle_exports2 = {};
__export(circle_exports2, {
  area: () => area$52,
  bbox: () => bbox$42,
  center: () => center2,
  circumference: () => circumference2,
  distanceCenter: () => distanceCenter2,
  distanceFromExterior: () => distanceFromExterior$12,
  exteriorIntegerPoints: () => exteriorIntegerPoints2,
  guard: () => guard$44,
  guardPositioned: () => guardPositioned$12,
  interiorIntegerPoints: () => interiorIntegerPoints2,
  interpolate: () => interpolate$32,
  intersectionLine: () => intersectionLine2,
  intersections: () => intersections2,
  isCircle: () => isCircle2,
  isCirclePositioned: () => isCirclePositioned2,
  isContainedBy: () => isContainedBy2,
  isEqual: () => isEqual$52,
  isIntersecting: () => isIntersecting2,
  isNaN: () => isNaN3,
  isPositioned: () => isPositioned$12,
  length: () => length$22,
  multiplyScalar: () => multiplyScalar$22,
  nearest: () => nearest$12,
  pointOnPerimeter: () => pointOnPerimeter2,
  randomPoint: () => randomPoint$12,
  toPath: () => toPath$12,
  toPositioned: () => toPositioned2,
  toSvg: () => toSvg2
});
var inside2 = (grid3, cell) => {
  if (cell.x < 0 || cell.y < 0) return false;
  if (cell.x >= grid3.cols || cell.y >= grid3.rows) return false;
  return true;
};
var isCell2 = (cell) => {
  if (cell === void 0) return false;
  return `x` in cell && `y` in cell;
};
var guardCell2 = (cell, parameterName = `Param`, grid3) => {
  if (cell === void 0) throw new Error(parameterName + ` is undefined. Expecting {x,y}`);
  if (cell.x === void 0) throw new Error(parameterName + `.x is undefined`);
  if (cell.y === void 0) throw new Error(parameterName + `.y is undefined`);
  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);
  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);
  if (!Number.isInteger(cell.x)) throw new TypeError(parameterName + `.x is non-integer`);
  if (!Number.isInteger(cell.y)) throw new TypeError(parameterName + `.y is non-integer`);
  if (grid3 !== void 0 && !inside2(grid3, cell)) throw new Error(`${parameterName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid3.cols}, ${grid3.rows}`);
};
var guardGrid2 = (grid3, parameterName = `Param`) => {
  if (grid3 === void 0) throw new Error(`${parameterName} is undefined. Expecting grid.`);
  if (!(`rows` in grid3)) throw new Error(`${parameterName}.rows is undefined`);
  if (!(`cols` in grid3)) throw new Error(`${parameterName}.cols is undefined`);
  if (!Number.isInteger(grid3.rows)) throw new TypeError(`${parameterName}.rows is not an integer`);
  if (!Number.isInteger(grid3.cols)) throw new TypeError(`${parameterName}.cols is not an integer`);
};
var applyBounds2 = function(grid3, cell, wrap$4 = `undefined`) {
  guardGrid2(grid3, `grid`);
  guardCell2(cell, `cell`);
  let x3 = cell.x;
  let y3 = cell.y;
  switch (wrap$4) {
    case `wrap`: {
      x3 = x3 % grid3.cols;
      y3 = y3 % grid3.rows;
      if (x3 < 0) x3 = grid3.cols + x3;
      else if (x3 >= grid3.cols) x3 -= grid3.cols;
      if (y3 < 0) y3 = grid3.rows + y3;
      else if (y3 >= grid3.rows) y3 -= grid3.rows;
      x3 = Math.abs(x3);
      y3 = Math.abs(y3);
      break;
    }
    case `stop`: {
      x3 = clampIndex(x3, grid3.cols);
      y3 = clampIndex(y3, grid3.rows);
      break;
    }
    case `undefined`: {
      if (x3 < 0 || y3 < 0) return;
      if (x3 >= grid3.cols || y3 >= grid3.rows) return;
      break;
    }
    case `unbounded`:
      break;
    default:
      throw new Error(`Unknown BoundsLogic '${wrap$4}'. Expected: wrap, stop, undefined or unbounded`);
  }
  return Object.freeze({
    x: x3,
    y: y3
  });
};
var array_1d_exports2 = {};
__export(array_1d_exports2, {
  access: () => access$12,
  createArray: () => createArray2,
  createMutable: () => createMutable2,
  set: () => set$12,
  setMutate: () => setMutate$12,
  wrap: () => wrap$32,
  wrapMutable: () => wrapMutable$12
});
var access$12 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions2(array3, cols);
  const fn2 = (cell, wrap$4 = `undefined`) => accessWithGrid$12(grid3, array3, cell, wrap$4);
  return fn2;
};
var accessWithGrid$12 = (grid3, array3, cell, wrap$4) => {
  const index = indexFromCell2(grid3, cell, wrap$4);
  if (index === void 0) return void 0;
  return array3[index];
};
var setMutate$12 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions2(array3, cols);
  return (value3, cell, wrap$4 = `undefined`) => setMutateWithGrid$12(grid3, array3, value3, cell, wrap$4);
};
var setMutateWithGrid$12 = (grid3, array3, value3, cell, wrap$4) => {
  const index = indexFromCell2(grid3, cell, wrap$4);
  if (index === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  array3[index] = value3;
  return array3;
};
var set$12 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions2(array3, cols);
  return (value3, cell, wrap$4) => setWithGrid$12(grid3, array3, value3, cell, wrap$4);
};
var setWithGrid$12 = (grid3, array3, value3, cell, wrap$4) => {
  const index = indexFromCell2(grid3, cell, wrap$4);
  if (index === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  const copy = [...array3];
  copy[index] = value3;
  array3 = copy;
  return copy;
};
var gridFromArrayDimensions2 = (array3, cols) => {
  const grid3 = {
    cols,
    rows: Math.ceil(array3.length / cols)
  };
  return grid3;
};
var wrapMutable$12 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions2(array3, cols);
  return {
    ...grid3,
    get: access$12(array3, cols),
    set: setMutate$12(array3, cols),
    get array() {
      return array3;
    }
  };
};
var wrap$32 = (array3, cols) => {
  const grid3 = gridFromArrayDimensions2(array3, cols);
  return {
    ...grid3,
    get: (cell, boundsLogic = `undefined`) => accessWithGrid$12(grid3, array3, cell, boundsLogic),
    set: (value3, cell, boundsLogic = `undefined`) => {
      array3 = setWithGrid$12(grid3, array3, value3, cell, boundsLogic);
      return wrap$32(array3, cols);
    },
    get array() {
      return array3;
    }
  };
};
var createArray2 = (initialValue, rowsOrGrid, columns$1) => {
  const rows$1 = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;
  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns$1;
  if (!cols) throw new Error(`Parameter 'columns' missing`);
  resultThrow(integerTest(rows$1, `aboveZero`, `rows`), integerTest(cols, `aboveZero`, `cols`));
  const t6 = [];
  const total2 = rows$1 * cols;
  for (let index = 0; index < total2; index++) t6[index] = initialValue;
  return t6;
};
var createMutable2 = (initialValue, rowsOrGrid, columns$1) => {
  const rows$1 = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;
  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns$1;
  if (!cols) throw new Error(`Parameter 'columns' missing`);
  const array3 = createArray2(initialValue, rows$1, cols);
  return wrapMutable$12(array3, cols);
};
var array_2d_exports2 = {};
__export(array_2d_exports2, {
  access: () => access2,
  create: () => create$14,
  set: () => set4,
  setMutate: () => setMutate2,
  wrap: () => wrap$22,
  wrapMutable: () => wrapMutable2
});
var create$14 = (array3) => {
  let colLen = NaN;
  for (const row of array3) if (Number.isNaN(colLen)) colLen = row.length;
  else if (colLen !== row.length) throw new Error(`Array does not have uniform column length`);
  return {
    rows: array3.length,
    cols: colLen
  };
};
var setMutate2 = (array3) => {
  const grid3 = create$14(array3);
  return (value3, cell, wrap$4 = `undefined`) => setMutateWithGrid2(grid3, array3, value3, cell, wrap$4);
};
var setMutateWithGrid2 = (grid3, array3, value3, cell, bounds) => {
  let boundCell = applyBounds2(grid3, cell, bounds);
  if (boundCell === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  array3[boundCell.y][boundCell.x] = value3;
  return array3;
};
var access2 = (array3) => {
  const grid3 = create$14(array3);
  const fn2 = (cell, wrap$4 = `undefined`) => accessWithGrid2(grid3, array3, cell, wrap$4);
  return fn2;
};
var accessWithGrid2 = (grid3, array3, cell, wrap$4) => {
  let boundCell = applyBounds2(grid3, cell, wrap$4);
  if (boundCell === void 0) return void 0;
  return array3[boundCell.y][boundCell.x];
};
var wrapMutable2 = (array3) => {
  const grid3 = create$14(array3);
  return {
    ...grid3,
    get: access2(array3),
    set: setMutate2(array3),
    get array() {
      return array3;
    }
  };
};
var set4 = (array3) => {
  const grid3 = create$14(array3);
  return (value3, cell, wrap$4) => setWithGrid2(grid3, array3, value3, cell, wrap$4);
};
var setWithGrid2 = (grid3, array3, value3, cell, wrap$4) => {
  let boundCell = applyBounds2(grid3, cell, wrap$4);
  if (boundCell === void 0) throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid3.cols} rows: ${grid3.rows}`);
  let copyWhole = [...array3];
  let copyRow = [...copyWhole[boundCell.y]];
  copyRow[boundCell.x] = value3;
  copyWhole[boundCell.y] = copyRow;
  array3 = copyWhole;
  return copyWhole;
};
var wrap$22 = (array3) => {
  const grid3 = create$14(array3);
  return {
    ...grid3,
    get: (cell, boundsLogic = `undefined`) => accessWithGrid2(grid3, array3, cell, boundsLogic),
    set: (value3, cell, boundsLogic = `undefined`) => {
      array3 = setWithGrid2(grid3, array3, value3, cell, boundsLogic);
      return wrap$22(array3);
    },
    get array() {
      return array3;
    }
  };
};
function* values2(grid3, iter) {
  for (const d3 of iter) if (Array.isArray(d3)) yield d3.map((v3) => grid3.get(v3, `undefined`));
  else yield grid3.get(d3, `undefined`);
}
function* cells2(grid3, start, wrap$4 = true) {
  if (!start) start = {
    x: 0,
    y: 0
  };
  guardGrid2(grid3, `grid`);
  guardCell2(start, `start`, grid3);
  let { x: x3, y: y3 } = start;
  let canMove = true;
  do {
    yield {
      x: x3,
      y: y3
    };
    x3++;
    if (x3 === grid3.cols) {
      y3++;
      x3 = 0;
    }
    if (y3 === grid3.rows) if (wrap$4) {
      y3 = 0;
      x3 = 0;
    } else canMove = false;
    if (x3 === start.x && y3 === start.y) canMove = false;
  } while (canMove);
}
function* cellValues2(grid3, start, wrap$4 = true) {
  yield* values2(grid3, cells2(grid3, start, wrap$4));
}
function* cellsAndValues2(grid3, start, wrap$4 = true) {
  for (const cell of cells2(grid3, start, wrap$4)) yield {
    cell,
    value: grid3.get(cell)
  };
}
var as_exports2 = {};
__export(as_exports2, {
  columns: () => columns2,
  rows: () => rows2
});
var rows2 = function* (grid3, start) {
  if (!start) start = {
    x: 0,
    y: 0
  };
  let row = start.y;
  let rowCells = [];
  for (const c5 of cells2(grid3, start)) if (c5.y === row) rowCells.push(c5);
  else {
    yield rowCells;
    rowCells = [c5];
    row = c5.y;
  }
  if (rowCells.length > 0) yield rowCells;
};
function* columns2(grid3, start) {
  if (!start) start = {
    x: 0,
    y: 0
  };
  for (let x3 = start.x; x3 < grid3.cols; x3++) {
    let colCells = [];
    for (let y3 = start.y; y3 < grid3.rows; y3++) colCells.push({
      x: x3,
      y: y3
    });
    yield colCells;
  }
}
var offset2 = function(grid3, start, vector, bounds = `undefined`) {
  return applyBounds2(grid3, {
    x: start.x + vector.x,
    y: start.y + vector.y
  }, bounds);
};
var allDirections2 = Object.freeze([
  `n`,
  `ne`,
  `nw`,
  `e`,
  `s`,
  `se`,
  `sw`,
  `w`
]);
var crossDirections2 = Object.freeze([
  `n`,
  `e`,
  `s`,
  `w`
]);
var offsetCardinals2 = (grid3, start, steps, bounds = `stop`) => {
  guardGrid2(grid3, `grid`);
  guardCell2(start, `start`);
  resultThrow(integerTest(steps, `aboveZero`, `steps`));
  const directions = allDirections2;
  const vectors = directions.map((d3) => getVectorFromCardinal2(d3, steps));
  const cells$1 = directions.map((d3, index) => offset2(grid3, start, vectors[index], bounds));
  return zipKeyValue(directions, cells$1);
};
var getVectorFromCardinal2 = (cardinal$1, multiplier = 1) => {
  let v3;
  switch (cardinal$1) {
    case `n`: {
      v3 = {
        x: 0,
        y: -1 * multiplier
      };
      break;
    }
    case `ne`: {
      v3 = {
        x: 1 * multiplier,
        y: -1 * multiplier
      };
      break;
    }
    case `e`: {
      v3 = {
        x: 1 * multiplier,
        y: 0
      };
      break;
    }
    case `se`: {
      v3 = {
        x: 1 * multiplier,
        y: 1 * multiplier
      };
      break;
    }
    case `s`: {
      v3 = {
        x: 0,
        y: 1 * multiplier
      };
      break;
    }
    case `sw`: {
      v3 = {
        x: -1 * multiplier,
        y: 1 * multiplier
      };
      break;
    }
    case `w`: {
      v3 = {
        x: -1 * multiplier,
        y: 0
      };
      break;
    }
    case `nw`: {
      v3 = {
        x: -1 * multiplier,
        y: -1 * multiplier
      };
      break;
    }
    default:
      v3 = {
        x: 0,
        y: 0
      };
  }
  return Object.freeze(v3);
};
var enumerators_exports2 = {};
__export(enumerators_exports2, {
  cellValues: () => cellValues2,
  cells: () => cells2,
  cellsAndValues: () => cellsAndValues2
});
var getLine2 = (start, end) => {
  guardCell2(start);
  guardCell2(end);
  let startX = start.x;
  let startY = start.y;
  const dx = Math.abs(end.x - startX);
  const dy = Math.abs(end.y - startY);
  const sx = startX < end.x ? 1 : -1;
  const sy = startY < end.y ? 1 : -1;
  let error = dx - dy;
  const cells$1 = [];
  while (true) {
    cells$1.push(Object.freeze({
      x: startX,
      y: startY
    }));
    if (startX === end.x && startY === end.y) break;
    const error2 = 2 * error;
    if (error2 > -dy) {
      error -= dy;
      startX += sx;
    }
    if (error2 < dx) {
      error += dx;
      startY += sy;
    }
  }
  return cells$1;
};
var simpleLine2 = function(start, end, endInclusive = false) {
  const cells$1 = [];
  if (start.x === end.x) {
    const lastY = endInclusive ? end.y + 1 : end.y;
    for (let y3 = start.y; y3 < lastY; y3++) cells$1.push({
      x: start.x,
      y: y3
    });
  } else if (start.y === end.y) {
    const lastX = endInclusive ? end.x + 1 : end.x;
    for (let x3 = start.x; x3 < lastX; x3++) cells$1.push({
      x: x3,
      y: start.y
    });
  } else throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);
  return cells$1;
};
var indexFromCell2 = (grid3, cell, wrap$4) => {
  guardGrid2(grid3, `grid`);
  if (cell.x < 0) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        x: 0
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = offset2(grid3, {
        x: 0,
        y: cell.y
      }, {
        x: cell.x,
        y: 0
      }, `wrap`);
      break;
    }
  }
  if (cell.y < 0) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        y: 0
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = {
        ...cell,
        y: grid3.rows + cell.y
      };
      break;
    }
  }
  if (cell.x >= grid3.cols) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        x: grid3.cols - 1
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = {
        ...cell,
        x: cell.x % grid3.cols
      };
      break;
    }
  }
  if (cell.y >= grid3.rows) switch (wrap$4) {
    case `stop`: {
      cell = {
        ...cell,
        y: grid3.rows - 1
      };
      break;
    }
    case `unbounded`:
      throw new Error(`unbounded not supported`);
    case `undefined`:
      return void 0;
    case `wrap`: {
      cell = {
        ...cell,
        y: cell.y % grid3.rows
      };
      break;
    }
  }
  const index = cell.y * grid3.cols + cell.x;
  return index;
};
var cellFromIndex2 = (colsOrGrid, index) => {
  let cols = 0;
  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;
  resultThrow(integerTest(cols, `aboveZero`, `colsOrGrid`));
  return {
    x: index % cols,
    y: Math.floor(index / cols)
  };
};
var isEqual$42 = (a3, b3) => {
  if (b3 === void 0) return false;
  if (a3 === void 0) return false;
  if (`rows` in a3 && `cols` in a3) if (`rows` in b3 && `cols` in b3) {
    if (a3.rows !== b3.rows || a3.cols !== b3.cols) return false;
  } else return false;
  if (`size` in a3) if (`size` in b3) {
    if (a3.size !== b3.size) return false;
  } else return false;
  return true;
};
var cellEquals2 = (a3, b3) => {
  if (b3 === void 0) return false;
  if (a3 === void 0) return false;
  return a3.x === b3.x && a3.y === b3.y;
};
var randomNeighbour2 = (nbos) => randomElement2(nbos);
var isNeighbour2 = (n6) => {
  if (n6 === void 0) return false;
  if (n6[1] === void 0) return false;
  return true;
};
var neighbourList2 = (grid3, cell, directions, bounds) => {
  const cellNeighbours = neighbours2(grid3, cell, bounds, directions);
  const entries2 = Object.entries(cellNeighbours);
  return entries2.filter((n6) => isNeighbour2(n6));
};
var neighbours2 = (grid3, cell, bounds = `undefined`, directions) => {
  const directories = directions ?? allDirections2;
  const points = directories.map((c5) => offset2(grid3, cell, getVectorFromCardinal2(c5), bounds));
  return zipKeyValue(directories, points);
};
var toArray2d2 = (grid3, initialValue) => {
  const returnValue = [];
  for (let row = 0; row < grid3.rows; row++) {
    returnValue[row] = Array.from({ length: grid3.cols });
    if (initialValue) for (let col = 0; col < grid3.cols; col++) returnValue[row][col] = initialValue;
  }
  return returnValue;
};
var cellKeyString2 = (v3) => `Cell{${v3.x},${v3.y}}`;
function* asRectangles2(grid3) {
  for (const c5 of cells2(grid3)) yield rectangleForCell2(grid3, c5);
}
var cellAtPoint2 = (grid3, position) => {
  const size = grid3.size;
  resultThrow(numberTest(size, `positive`, `grid.size`));
  if (position.x < 0 || position.y < 0) return;
  const x3 = Math.floor(position.x / size);
  const y3 = Math.floor(position.y / size);
  if (x3 >= grid3.cols) return;
  if (y3 >= grid3.rows) return;
  return {
    x: x3,
    y: y3
  };
};
var rectangleForCell2 = (grid3, cell) => {
  guardCell2(cell);
  const size = grid3.size;
  const x3 = cell.x * size;
  const y3 = cell.y * size;
  const r5 = fromTopLeft2({
    x: x3,
    y: y3
  }, size, size);
  return r5;
};
var cellMiddle2 = (grid3, cell) => {
  guardCell2(cell);
  const size = grid3.size;
  const x3 = cell.x * size;
  const y3 = cell.y * size;
  return Object.freeze({
    x: x3 + size / 2,
    y: y3 + size / 2
  });
};
var breadthLogic2 = () => {
  return { select: (nbos) => nbos[0] };
};
var neighboursLogic2 = () => {
  return {
    select: (neighbours$1) => {
      return neighbours$1.at(0);
    },
    getNeighbours: (grid3, cell) => {
      return neighbourList2(grid3, cell, allDirections2, `undefined`);
    }
  };
};
var columnLogic2 = (opts = {}) => {
  const reversed = opts.reversed ?? false;
  return {
    select: (nbos) => nbos.find((n6) => n6[0] === (reversed ? `n` : `s`)),
    getNeighbours: (grid3, cell) => {
      if (reversed) if (cell.y > 0) cell = {
        x: cell.x,
        y: cell.y - 1
      };
      else if (cell.x === 0) cell = {
        x: grid3.cols - 1,
        y: grid3.rows - 1
      };
      else cell = {
        x: cell.x - 1,
        y: grid3.rows - 1
      };
      else if (cell.y < grid3.rows - 1) cell = {
        x: cell.x,
        y: cell.y + 1
      };
      else if (cell.x < grid3.cols - 1) cell = {
        x: cell.x + 1,
        y: 0
      };
      else cell = {
        x: 0,
        y: 0
      };
      return [[reversed ? `n` : `s`, cell]];
    }
  };
};
var depthLogic2 = () => {
  return { select: (nbos) => nbos.at(-1) };
};
var randomLogic2 = () => {
  return {
    getNeighbours: (grid3, cell) => {
      const t6 = [];
      for (const c5 of cells2(grid3, cell)) t6.push([`n`, c5]);
      return t6;
    },
    select: randomNeighbour2
  };
};
var randomContiguousLogic2 = () => {
  return { select: randomNeighbour2 };
};
var rowLogic2 = (opts = {}) => {
  const reversed = opts.reversed ?? false;
  return {
    select: (nbos) => nbos.find((n6) => n6[0] === (reversed ? `w` : `e`)),
    getNeighbours: (grid3, cell) => {
      if (reversed) if (cell.x > 0) cell = {
        x: cell.x - 1,
        y: cell.y
      };
      else if (cell.y > 0) cell = {
        x: grid3.cols - 1,
        y: cell.y - 1
      };
      else cell = {
        x: grid3.cols - 1,
        y: grid3.rows - 1
      };
      else if (cell.x < grid3.rows - 1) cell = {
        x: cell.x + 1,
        y: cell.y
      };
      else if (cell.y < grid3.rows - 1) cell = {
        x: 0,
        y: cell.y + 1
      };
      else cell = {
        x: 0,
        y: 0
      };
      return [[reversed ? `w` : `e`, cell]];
    }
  };
};
function* visitByNeighbours2(logic, grid3, opts = {}) {
  guardGrid2(grid3, `grid`);
  const start = opts.start ?? {
    x: 0,
    y: 0
  };
  guardCell2(start, `opts.start`, grid3);
  const v3 = opts.visited ?? mutable$22(cellKeyString2);
  const possibleNeighbours = logic.getNeighbours ?? ((g4, c5) => neighbourList2(g4, c5, crossDirections2, `undefined`));
  let cellQueue = [start];
  let moveQueue = [];
  let current = void 0;
  while (cellQueue.length > 0) {
    if (current === void 0) {
      const nv = cellQueue.pop();
      if (nv === void 0) break;
      current = nv;
    }
    if (!v3.has(current)) {
      v3.add(current);
      yield current;
      const nextSteps = possibleNeighbours(grid3, current).filter((step) => {
        if (step[1] === void 0) return false;
        return !v3.has(step[1]);
      });
      if (nextSteps.length === 0) {
        if (current !== void 0) cellQueue = cellQueue.filter((cq) => cellEquals2(cq, current));
      } else for (const n6 of nextSteps) {
        if (n6 === void 0) continue;
        if (n6[1] === void 0) continue;
        moveQueue.push(n6);
      }
    }
    moveQueue = moveQueue.filter((step) => !v3.has(step[1]));
    if (moveQueue.length === 0) current = void 0;
    else {
      const potential = logic.select(moveQueue);
      if (potential !== void 0) {
        cellQueue.push(potential[1]);
        current = potential[1];
      }
    }
  }
}
var stepper2 = (grid3, createVisitor, start = {
  x: 0,
  y: 0
}, resolution = 1) => {
  guardGrid2(grid3, `grid`);
  guardCell2(start, `start`);
  resultThrow(integerTest(resolution, ``, `resolution`));
  const steps = [];
  let count3 = 0;
  let position = 0;
  for (const c5 of createVisitor(grid3, {
    start,
    boundsWrap: `undefined`
  })) {
    count3++;
    if (count3 % resolution !== 0) continue;
    steps.push(c5);
  }
  return (step, fromStart = false) => {
    resultThrow(integerTest(step, ``, `step`));
    if (fromStart) position = step;
    else position += step;
    return steps.at(position % steps.length);
  };
};
var visitors_exports2 = {};
__export(visitors_exports2, {
  breadthLogic: () => breadthLogic2,
  columnLogic: () => columnLogic2,
  create: () => create6,
  depthLogic: () => depthLogic2,
  neighboursLogic: () => neighboursLogic2,
  randomContiguousLogic: () => randomContiguousLogic2,
  randomLogic: () => randomLogic2,
  rowLogic: () => rowLogic2,
  stepper: () => stepper2,
  visitByNeighbours: () => visitByNeighbours2,
  withLogic: () => withLogic2
});
var create6 = (type, opts = {}) => {
  switch (type) {
    case `random-contiguous`:
      return withLogic2(randomContiguousLogic2(), opts);
    case `random`:
      return withLogic2(randomLogic2(), opts);
    case `depth`:
      return withLogic2(depthLogic2(), opts);
    case `breadth`:
      return withLogic2(breadthLogic2(), opts);
    case `neighbours`:
      return withLogic2(neighboursLogic2(), opts);
    case `row`:
      return withLogic2(rowLogic2(opts), opts);
    case `column`:
      return withLogic2(columnLogic2(opts), opts);
    default:
      throw new TypeError(`Param 'type' unknown. Value: ${type}`);
  }
};
var withLogic2 = (logic, options = {}) => {
  return (grid3, optionsOverride = {}) => {
    return visitByNeighbours2(logic, grid3, {
      ...options,
      ...optionsOverride
    });
  };
};
var grid_exports2 = {};
__export(grid_exports2, {
  Array1d: () => array_1d_exports2,
  Array2d: () => array_2d_exports2,
  As: () => as_exports2,
  By: () => enumerators_exports2,
  Visit: () => visitors_exports2,
  allDirections: () => allDirections2,
  applyBounds: () => applyBounds2,
  asRectangles: () => asRectangles2,
  cellAtPoint: () => cellAtPoint2,
  cellEquals: () => cellEquals2,
  cellFromIndex: () => cellFromIndex2,
  cellKeyString: () => cellKeyString2,
  cellMiddle: () => cellMiddle2,
  crossDirections: () => crossDirections2,
  getLine: () => getLine2,
  getVectorFromCardinal: () => getVectorFromCardinal2,
  guardCell: () => guardCell2,
  guardGrid: () => guardGrid2,
  indexFromCell: () => indexFromCell2,
  inside: () => inside2,
  isCell: () => isCell2,
  isEqual: () => isEqual$42,
  neighbourList: () => neighbourList2,
  neighbours: () => neighbours2,
  offset: () => offset2,
  offsetCardinals: () => offsetCardinals2,
  randomNeighbour: () => randomNeighbour2,
  rectangleForCell: () => rectangleForCell2,
  simpleLine: () => simpleLine2,
  toArray2d: () => toArray2d2,
  values: () => values2
});
function normaliseByRect2(a3, b3, c5, d3) {
  if (isPoint2(a3)) {
    if (typeof b3 === `number` && c5 !== void 0) resultThrow(numberTest(b3, `positive`, `width`), numberTest(c5, `positive`, `height`));
    else {
      if (!isRect2(b3)) throw new Error(`Expected second parameter to be a rect`);
      c5 = b3.height;
      b3 = b3.width;
    }
    return Object.freeze({
      x: a3.x / b3,
      y: a3.y / c5
    });
  } else {
    resultThrow(numberTest(a3, `positive`, `x`));
    if (typeof b3 !== `number`) throw new TypeError(`Expecting second parameter to be a number (width)`);
    if (typeof c5 !== `number`) throw new TypeError(`Expecting third parameter to be a number (height)`);
    resultThrow(numberTest(b3, `positive`, `y`));
    resultThrow(numberTest(c5, `positive`, `width`));
    if (d3 === void 0) throw new Error(`Expected height parameter`);
    resultThrow(numberTest(d3, `positive`, `height`));
    return Object.freeze({
      x: a3 / c5,
      y: b3 / d3
    });
  }
}
var nearest2 = (line3, point$1) => {
  const n6 = (line$13) => {
    const { a: a3, b: b3 } = line$13;
    const atob2 = {
      x: b3.x - a3.x,
      y: b3.y - a3.y
    };
    const atop = {
      x: point$1.x - a3.x,
      y: point$1.y - a3.y
    };
    const length$4 = atob2.x * atob2.x + atob2.y * atob2.y;
    let dot3 = atop.x * atob2.x + atop.y * atob2.y;
    const t6 = Math.min(1, Math.max(0, dot3 / length$4));
    dot3 = (b3.x - a3.x) * (point$1.y - a3.y) - (b3.y - a3.y) * (point$1.x - a3.x);
    return {
      x: a3.x + atob2.x * t6,
      y: a3.y + atob2.y * t6
    };
  };
  if (Array.isArray(line3)) {
    const pts = line3.map((l3) => n6(l3));
    const dists = pts.map((p3) => distance4(p3, point$1));
    return Object.freeze(pts[minIndex(...dists)]);
  } else return Object.freeze(n6(line3));
};
var distanceSingleLine2 = (line3, point$1) => {
  guard$34(line3, `line`);
  guard$12(point$1, `point`);
  if (length2(line3) === 0) return length2(line3.a, point$1);
  const near = nearest2(line3, point$1);
  return length2(near, point$1);
};
var directionVector2 = (line3) => ({
  x: line3.b.x - line3.a.x,
  y: line3.b.y - line3.a.y
});
var directionVectorNormalised2 = (line3) => {
  const l3 = length2(line3);
  const v3 = directionVector2(line3);
  return {
    x: v3.x / l3,
    y: v3.y / l3
  };
};
var parallel2 = (line3, distance$2) => {
  const dv = directionVector2(line3);
  const dvn = directionVectorNormalised2(line3);
  const a3 = {
    x: line3.a.x - dvn.y * distance$2,
    y: line3.a.y + dvn.x * distance$2
  };
  return {
    a: a3,
    b: {
      x: a3.x + dv.x,
      y: a3.y + dv.y
    }
  };
};
var perpendicularPoint2 = (line3, distance$2, amount = 0) => {
  const origin = interpolate$12(amount, line3);
  const dvn = directionVectorNormalised2(line3);
  return {
    x: origin.x - dvn.y * distance$2,
    y: origin.y + dvn.x * distance$2
  };
};
var bbox$32 = (line3) => bbox$12(line3.a, line3.b);
function divide$22(a1, ab2, ab3, ab4, ab5, ab6) {
  const [ptA, ptB] = getTwoPointParameters2(a1, ab2, ab3, ab4, ab5, ab6);
  guard$12(ptA, `a`);
  guard$12(ptB, `b`);
  if (ptB.x === 0) throw new TypeError("Cannot divide by zero (b.x is 0)");
  if (ptB.y === 0) throw new TypeError("Cannot divide by zero (b.y is 0)");
  const pt2 = {
    x: ptA.x / ptB.x,
    y: ptA.y / ptB.y
  };
  if (isPoint3d2(ptA) || isPoint3d2(ptB)) {
    if (ptB.z === 0) throw new TypeError("Cannot divide by zero (b.z is 0)");
    pt2.z = (ptA.z ?? 0) / (ptB.z ?? 0);
  }
  return Object.freeze(pt2);
}
function divider2(a3, b3, c5) {
  const divisor = getPointParameter2(a3, b3, c5);
  guardNonZeroPoint2(divisor, `divisor`);
  return (aa2, bb, cc) => {
    const dividend = getPointParameter2(aa2, bb, cc);
    return typeof dividend.z === `undefined` ? Object.freeze({
      x: dividend.x / divisor.x,
      y: dividend.y / divisor.y
    }) : Object.freeze({
      x: dividend.x / divisor.x,
      y: dividend.y / divisor.y,
      z: dividend.z / (divisor.z ?? 1)
    });
  };
}
var divide$12 = (line3, point$1) => Object.freeze({
  ...line3,
  a: divide$22(line3.a, point$1),
  b: divide$22(line3.b, point$1)
});
var fromNumbers$22 = (x1, y1, x22, y22) => {
  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);
  if (Number.isNaN(x22)) throw new Error(`x2 is NaN`);
  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);
  if (Number.isNaN(y22)) throw new Error(`y2 is NaN`);
  const a3 = {
    x: x1,
    y: y1
  };
  const b3 = {
    x: x22,
    y: y22
  };
  return fromPoints$22(a3, b3);
};
var fromFlatArray$12 = (array3) => {
  if (!Array.isArray(array3)) throw new Error(`arr parameter is not an array`);
  if (array3.length !== 4) throw new Error(`array is expected to have length four`);
  return fromNumbers$22(array3[0], array3[1], array3[2], array3[3]);
};
var fromPivot2 = (origin = {
  x: 0.5,
  y: 0.5
}, length$4 = 1, angleRadian$2 = 0, balance = 0.5) => {
  const left = length$4 * balance;
  const right = length$4 * (1 - balance);
  const a3 = toCartesian2(left, radianInvert2(angleRadian$2), origin);
  const b3 = toCartesian2(right, angleRadian$2, origin);
  return Object.freeze({
    a: a3,
    b: b3
  });
};
var midpoint2 = (aOrLine, pointB) => {
  const [a3, b3] = getPointParameter$12(aOrLine, pointB);
  return interpolate$12(0.5, a3, b3);
};
var relativePosition$12 = (line3, pt2) => {
  const fromStart = distance4(line3.a, pt2);
  const total2 = length2(line3);
  return fromStart / total2;
};
var sum$22 = (line3, point$1) => Object.freeze({
  ...line3,
  a: sum$13(line3.a, point$1),
  b: sum$13(line3.b, point$1)
});
function abs4(pt2) {
  if (isPoint3d2(pt2)) return Object.freeze({
    ...pt2,
    x: Math.abs(pt2.x),
    y: Math.abs(pt2.y),
    z: Math.abs(pt2.z)
  });
  else if (isPoint2(pt2)) return Object.freeze({
    ...pt2,
    x: Math.abs(pt2.x),
    y: Math.abs(pt2.y)
  });
  else throw new TypeError(`Param 'pt' is not a point`);
}
function apply$22(pt2, fn2) {
  guard$12(pt2, `pt`);
  if (isPoint3d2(pt2)) return Object.freeze({
    ...pt2,
    x: fn2(pt2.x, `x`),
    y: fn2(pt2.y, `y`),
    z: fn2(pt2.z, `z`)
  });
  return Object.freeze({
    ...pt2,
    x: fn2(pt2.x, `x`),
    y: fn2(pt2.y, `y`)
  });
}
function averager2(kind, opts = {}) {
  let x3;
  let y3;
  let z3;
  switch (kind) {
    case `moving-average-light`: {
      const scaling = opts.scaling ?? 3;
      x3 = movingAverageLight(scaling);
      y3 = movingAverageLight(scaling);
      z3 = movingAverageLight(scaling);
      break;
    }
    default:
      throw new Error(`Unknown averaging kind '${kind}'. Expected: 'moving-average-light'`);
  }
  return (point$1) => {
    const ax = x3(point$1.x);
    const ay = y3(point$1.y);
    if (isPoint3d2(point$1)) {
      const az = z3(point$1.z);
      return Object.freeze({
        x: ax,
        y: ay,
        z: az
      });
    } else return Object.freeze({
      x: ax,
      y: ay
    });
  };
}
var centroid$12 = (...points) => {
  if (!Array.isArray(points)) throw new Error(`Expected list of points`);
  const sum$4 = points.reduce((previous, p3) => {
    if (p3 === void 0) return previous;
    if (Array.isArray(p3)) throw new TypeError(`'points' list contains an array. Did you mean: centroid(...myPoints)?`);
    if (!isPoint2(p3)) throw new Error(`'points' contains something which is not a point: ${JSON.stringify(p3)}`);
    return {
      x: previous.x + p3.x,
      y: previous.y + p3.y
    };
  }, {
    x: 0,
    y: 0
  });
  return Object.freeze({
    x: sum$4.x / points.length,
    y: sum$4.y / points.length
  });
};
function clamp$13(a3, min4 = 0, max4 = 1) {
  if (isPoint3d2(a3)) return Object.freeze({
    x: clamp(a3.x, min4, max4),
    y: clamp(a3.y, min4, max4),
    z: clamp(a3.z, min4, max4)
  });
  else return Object.freeze({
    x: clamp(a3.x, min4, max4),
    y: clamp(a3.y, min4, max4)
  });
}
var compare5 = (a3, b3) => {
  if (a3.x < b3.x && a3.y < b3.y) return -2;
  if (a3.x > b3.x && a3.y > b3.y) return 2;
  if (a3.x < b3.x || a3.y < b3.y) return -1;
  if (a3.x > b3.x || a3.y > b3.y) return 1;
  if (a3.x === b3.x && a3.x === b3.y) return 0;
  return NaN;
};
var compareByX2 = (a3, b3) => {
  if (a3.x === b3.x) return 0;
  if (a3.x < b3.x) return -1;
  return 1;
};
var compareByY2 = (a3, b3) => {
  if (a3.y === b3.y) return 0;
  if (a3.y < b3.y) return -1;
  return 1;
};
var compareByZ2 = (a3, b3) => {
  if (a3.z === b3.z) return 0;
  if (a3.z < b3.z) return -1;
  return 1;
};
var convexHull2 = (...pts) => {
  const sorted = [...pts].sort(compareByX2);
  if (sorted.length === 1) return sorted;
  const x3 = (points) => {
    const v3 = [];
    for (const p3 of points) {
      while (v3.length >= 2) {
        const q3 = v3.at(-1);
        const r5 = v3.at(-2);
        if ((q3.x - r5.x) * (p3.y - r5.y) >= (q3.y - r5.y) * (p3.x - r5.x)) v3.pop();
        else break;
      }
      v3.push(p3);
    }
    v3.pop();
    return v3;
  };
  const upper = x3(sorted);
  const lower = x3(sorted.reverse());
  if (upper.length === 1 && lower.length === 1 && isEqual3(lower[0], upper[0])) return upper;
  return [...upper, ...lower];
};
function intersectsPoint2(rect3, a3, b3) {
  guard$24(rect3, `rect`);
  let x3 = 0;
  let y3 = 0;
  if (typeof a3 === `number`) {
    if (b3 === void 0) throw new Error(`x and y coordinate needed`);
    x3 = a3;
    y3 = b3;
  } else {
    x3 = a3.x;
    y3 = a3.y;
  }
  if (isPositioned2(rect3)) {
    if (x3 - rect3.x > rect3.width || x3 < rect3.x) return false;
    if (y3 - rect3.y > rect3.height || y3 < rect3.y) return false;
  } else {
    if (x3 > rect3.width || x3 < 0) return false;
    if (y3 > rect3.height || y3 < 0) return false;
  }
  return true;
}
var isIntersecting$12 = (a3, b3) => {
  if (!isRectPositioned2(a3)) throw new Error(`a parameter should be RectPositioned`);
  if (isCirclePositioned2(b3)) return circleRect2(b3, a3);
  else if (isPoint2(b3)) return intersectsPoint2(a3, b3);
  throw new Error(`Unknown shape for b: ${JSON.stringify(b3)}`);
};
var center$12 = (rect3, origin) => {
  guard$24(rect3);
  if (origin === void 0 && isPoint2(rect3)) origin = rect3;
  else if (origin === void 0) origin = {
    x: 0,
    y: 0
  };
  const r5 = getRectPositioned2(rect3, origin);
  return Object.freeze({
    x: origin.x + rect3.width / 2,
    y: origin.y + rect3.height / 2
  });
};
var distanceFromExterior2 = (rect3, pt2) => {
  guardPositioned2(rect3, `rect`);
  guard$12(pt2, `pt`);
  if (intersectsPoint2(rect3, pt2)) return 0;
  const dx = Math.max(rect3.x - pt2.x, 0, pt2.x - rect3.x + rect3.width);
  const dy = Math.max(rect3.y - pt2.y, 0, pt2.y - rect3.y + rect3.height);
  return Math.hypot(dx, dy);
};
var distanceFromCenter2 = (rect3, pt2) => distance4(center$12(rect3), pt2);
var distanceToCenter2 = (a3, shape) => {
  if (isRectPositioned2(shape)) return distanceFromExterior2(shape, a3);
  if (isCirclePositioned2(shape)) return distanceFromExterior$12(shape, a3);
  if (isPoint2(shape)) return distance4(a3, shape);
  throw new Error(`Unknown shape`);
};
var distanceToExterior2 = (a3, shape) => {
  if (isRectPositioned2(shape)) return distanceFromExterior2(shape, a3);
  if (isCirclePositioned2(shape)) return distanceFromExterior$12(shape, a3);
  if (isPoint2(shape)) return distance4(a3, shape);
  throw new Error(`Unknown shape`);
};
var toArray$13 = (p3) => [p3.x, p3.y];
var dotProduct$12 = (...pts) => {
  const a3 = pts.map((p3) => toArray$13(p3));
  return dotProduct(a3);
};
function from2(xOrArray, y3, z3) {
  if (Array.isArray(xOrArray)) if (xOrArray.length === 3) return Object.freeze({
    x: xOrArray[0],
    y: xOrArray[1],
    z: xOrArray[2]
  });
  else if (xOrArray.length === 2) return Object.freeze({
    x: xOrArray[0],
    y: xOrArray[1]
  });
  else throw new Error(`Expected array of length two or three, got ${xOrArray.length}`);
  else {
    if (xOrArray === void 0) throw new Error(`Requires an array of [x,y] or x,y parameters at least`);
    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);
    if (y3 === void 0) throw new Error(`Param 'y' is missing`);
    else if (Number.isNaN(y3)) throw new Error(`y is NaN`);
    if (z3 === void 0) return Object.freeze({
      x: xOrArray,
      y: y3
    });
    else return Object.freeze({
      x: xOrArray,
      y: y3,
      z: z3
    });
  }
}
var fromString2 = (string_) => {
  if (typeof string_ !== `string`) throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof string_}`);
  const comma = string_.indexOf(`,`);
  const x3 = Number.parseFloat(string_.substring(0, comma));
  const nextComma = string_.indexOf(",", comma + 1);
  if (nextComma > 0) {
    const y3 = Number.parseFloat(string_.substring(comma + 1, nextComma - comma + 2));
    const z3 = Number.parseFloat(string_.substring(nextComma + 1));
    return {
      x: x3,
      y: y3,
      z: z3
    };
  } else {
    const y3 = Number.parseFloat(string_.substring(comma + 1));
    return {
      x: x3,
      y: y3
    };
  }
};
var fromNumbers2 = (...coords) => {
  const pts = [];
  if (Array.isArray(coords[0])) for (const coord of coords) {
    if (!(coord.length % 2 === 0)) throw new Error(`coords array should be even-numbered`);
    pts.push(Object.freeze({
      x: coord[0],
      y: coord[1]
    }));
  }
  else {
    if (coords.length % 2 !== 0) throw new Error(`Expected even number of elements: [x,y,x,y...]`);
    for (let index = 0; index < coords.length; index += 2) pts.push(Object.freeze({
      x: coords[index],
      y: coords[index + 1]
    }));
  }
  return pts;
};
var interpolate$22 = (amount, a3, b3, allowOverflow = false) => interpolate$12(amount, a3, b3, allowOverflow);
var invert3 = (pt2, what = `both`) => {
  switch (what) {
    case `both`:
      return isPoint3d2(pt2) ? Object.freeze({
        ...pt2,
        x: pt2.x * -1,
        y: pt2.y * -1,
        z: pt2.z * -1
      }) : Object.freeze({
        ...pt2,
        x: pt2.x * -1,
        y: pt2.y * -1
      });
    case `x`:
      return Object.freeze({
        ...pt2,
        x: pt2.x * -1
      });
    case `y`:
      return Object.freeze({
        ...pt2,
        y: pt2.y * -1
      });
    case `z`:
      if (isPoint3d2(pt2)) return Object.freeze({
        ...pt2,
        z: pt2.z * -1
      });
      else throw new Error(`pt parameter is missing z`);
    default:
      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);
  }
};
var clampMagnitude2 = (pt2, max4 = 1, min4 = 0) => {
  const length$4 = distance4(pt2);
  let ratio = 1;
  if (length$4 > max4) ratio = max4 / length$4;
  else if (length$4 < min4) ratio = min4 / length$4;
  return ratio === 1 ? pt2 : multiply$22(pt2, ratio, ratio);
};
var leftmost2 = (...points) => findMinimum2((a3, b3) => a3.x <= b3.x ? a3 : b3, ...points);
var rightmost2 = (...points) => findMinimum2((a3, b3) => a3.x >= b3.x ? a3 : b3, ...points);
var length$12 = (ptOrX, y3) => {
  if (isPoint2(ptOrX)) {
    y3 = ptOrX.y;
    ptOrX = ptOrX.x;
  }
  if (y3 === void 0) throw new Error(`Expected y`);
  return Math.hypot(ptOrX, y3);
};
var normalise2 = (ptOrX, y3) => {
  const pt2 = getPointParameter2(ptOrX, y3);
  const l3 = length$12(pt2);
  if (l3 === 0) return Empty2;
  return Object.freeze({
    ...pt2,
    x: pt2.x / l3,
    y: pt2.y / l3
  });
};
var pipelineApply2 = (point$1, ...pipelineFns) => pipeline2(...pipelineFns)(point$1);
var pipeline2 = (...pipeline$1) => (pt2) => pipeline$1.reduce((previous, current) => current(previous), pt2);
var vector_exports2 = {};
__export(vector_exports2, {
  clampMagnitude: () => clampMagnitude$12,
  divide: () => divide$32,
  dotProduct: () => dotProduct$22,
  fromLineCartesian: () => fromLineCartesian2,
  fromLinePolar: () => fromLinePolar2,
  fromPointPolar: () => fromPointPolar2,
  fromRadians: () => fromRadians2,
  multiply: () => multiply$32,
  normalise: () => normalise$12,
  quadrantOffsetAngle: () => quadrantOffsetAngle2,
  subtract: () => subtract$32,
  sum: () => sum$32,
  toCartesian: () => toCartesian$12,
  toPolar: () => toPolar2,
  toRadians: () => toRadians2,
  toString: () => toString$32
});
var EmptyCartesian2 = Object.freeze({
  x: 0,
  y: 0
});
var piPi$22 = Math.PI * 2;
var pi$13 = Math.PI;
var fromRadians2 = (radians) => {
  return Object.freeze({
    x: Math.cos(radians),
    y: Math.sin(radians)
  });
};
var toRadians2 = (point$1) => {
  return Math.atan2(point$1.y, point$1.x);
};
var fromPointPolar2 = (pt2, angleNormalisation = ``, origin = EmptyCartesian2) => {
  pt2 = subtract$22(pt2, origin);
  let direction = Math.atan2(pt2.y, pt2.x);
  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi$22;
  else if (angleNormalisation === `bipolar`) {
    if (direction > pi$13) direction -= piPi$22;
    else if (direction <= -pi$13) direction += piPi$22;
  }
  return Object.freeze({
    distance: distance4(pt2),
    angleRadian: direction
  });
};
var fromLineCartesian2 = (line3) => subtract$22(line3.b, line3.a);
var fromLinePolar2 = (line3) => {
  guard$34(line3, `line`);
  const pt2 = subtract$22(line3.b, line3.a);
  return fromPointPolar2(pt2);
};
var isPolar2 = (v3) => {
  if (isPolarCoord2(v3)) return true;
  return false;
};
var isCartesian2 = (v3) => {
  if (isPoint2(v3)) return true;
  return false;
};
var normalise$12 = (v3) => {
  if (isPolar2(v3)) return normalise$22(v3);
  else if (isCartesian2(v3)) return normalise2(v3);
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var quadrantOffsetAngle2 = (p3) => {
  if (p3.x >= 0 && p3.y >= 0) return 0;
  if (p3.x < 0 && p3.y >= 0) return pi$13;
  if (p3.x < 0 && p3.y < 0) return pi$13;
  return piPi$22;
};
var toPolar2 = (v3, origin = Empty2) => {
  if (isPolar2(v3)) return v3;
  else if (isCartesian2(v3)) return fromCartesian2(v3, origin);
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var toCartesian$12 = (v3) => {
  if (isPolar2(v3)) return toPoint2(v3);
  else if (isCartesian2(v3)) return v3;
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var toString$32 = (v3, digits) => {
  if (isPolar2(v3)) return toString$52(v3, digits);
  else if (isCartesian2(v3)) return toString$22(v3, digits);
  throw new Error(`Expected polar/cartesian vector. Got: ${v3}`);
};
var dotProduct$22 = (a3, b3) => {
  if (isPolar2(a3) && isPolar2(b3)) return dotProduct$32(a3, b3);
  else if (isCartesian2(a3) && isCartesian2(b3)) return dotProduct$12(a3, b3);
  throw new Error(`Expected two polar/Cartesian vectors.`);
};
var clampMagnitude$12 = (v3, max4 = 1, min4 = 0) => {
  if (isPolar2(v3)) return clampMagnitude$22(v3, max4, min4);
  else if (isCartesian2(v3)) return clampMagnitude2(v3, max4, min4);
  throw new Error(`Expected either polar or Cartesian vector`);
};
var sum$32 = (a3, b3) => {
  const polar = isPolar2(a3);
  a3 = toCartesian$12(a3);
  b3 = toCartesian$12(b3);
  const c5 = sum$13(a3, b3);
  return polar ? toPolar2(c5) : c5;
};
var subtract$32 = (a3, b3) => {
  const polar = isPolar2(a3);
  a3 = toCartesian$12(a3);
  b3 = toCartesian$12(b3);
  const c5 = subtract$22(a3, b3);
  return polar ? toPolar2(c5) : c5;
};
var multiply$32 = (a3, b3) => {
  const polar = isPolar2(a3);
  a3 = toCartesian$12(a3);
  b3 = toCartesian$12(b3);
  const c5 = multiply$22(a3, b3);
  return polar ? toPolar2(c5) : c5;
};
var divide$32 = (a3, b3) => {
  const polar = isPolar2(a3);
  a3 = toCartesian$12(a3);
  b3 = toCartesian$12(b3);
  const c5 = divide$22(a3, b3);
  return polar ? toPolar2(c5) : c5;
};
var joinPointsToLines2 = (...points) => {
  const lines = [];
  let start = points[0];
  for (let index = 1; index < points.length; index++) {
    lines.push(fromPoints$22(start, points[index]));
    start = points[index];
  }
  return lines;
};
var relation2 = (a3, b3) => {
  const start = getPointParameter2(a3, b3);
  let totalX = 0;
  let totalY = 0;
  let count3 = 0;
  let lastUpdate = performance.now();
  let lastPoint = start;
  const update = (aa2, bb) => {
    const p3 = getPointParameter2(aa2, bb);
    totalX += p3.x;
    totalY += p3.y;
    count3++;
    const distanceFromStart = distance4(p3, start);
    const distanceFromLast = distance4(p3, lastPoint);
    const now = performance.now();
    const speed = distanceFromLast / (now - lastUpdate);
    lastUpdate = now;
    lastPoint = p3;
    return Object.freeze({
      angle: angleRadian2(p3, start),
      distanceFromStart,
      distanceFromLast,
      speed,
      centroid: centroid$12(p3, start),
      average: {
        x: totalX / count3,
        y: totalY / count3
      }
    });
  };
  return update;
};
var PointTracker2 = class extends ObjectTracker {
  initialRelation;
  markRelation;
  lastResult;
  constructor(opts = {}) {
    super(opts);
  }
  /**
  * Notification that buffer has been knocked down to `sampleLimit`.
  * 
  * This will reset the `initialRelation`, which will use the new oldest value.
  */
  onTrimmed(_reason) {
    this.initialRelation = void 0;
  }
  /**
  * @ignore
  */
  onReset() {
    super.onReset();
    this.lastResult = void 0;
    this.initialRelation = void 0;
    this.markRelation = void 0;
  }
  /**
  * Makes a 'mark' in the tracker, allowing you to compare values
  * to this point.
  */
  mark() {
    this.markRelation = relation2(this.last);
  }
  /**
  * Tracks a point, returning data on its relation to the
  * initial point and the last received point.
  * 
  * Use {@link seenEvent} to track a raw `PointerEvent`.
  * 
  * @param _p Point
  */
  computeResults(_p) {
    const currentLast = this.last;
    const previousLast = this.values.at(-2);
    if (this.initialRelation === void 0 && this.initial) this.initialRelation = relation2(this.initial);
    else if (this.initialRelation === void 0) throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);
    const lastRelation = previousLast === void 0 ? relation2(currentLast) : relation2(previousLast);
    const initialRel = this.initialRelation(currentLast);
    const markRel = this.markRelation !== void 0 ? this.markRelation(currentLast) : void 0;
    const speed = previousLast === void 0 ? 0 : length2(previousLast, currentLast) / (currentLast.at - previousLast.at);
    const lastRel = {
      ...lastRelation(currentLast),
      speed
    };
    const r5 = {
      fromInitial: initialRel,
      fromLast: lastRel,
      fromMark: markRel,
      values: [...this.values]
    };
    this.lastResult = r5;
    return r5;
  }
  /**
  * Returns a polyline representation of stored points.
  * Returns an empty array if points were not saved, or there's only one.
  */
  get line() {
    if (this.values.length === 1) return [];
    return joinPointsToLines2(...this.values);
  }
  /**
  * Returns a vector of the initial/last points of the tracker.
  * Returns as a polar coordinate
  */
  get vectorPolar() {
    return fromLinePolar2(this.lineStartEnd);
  }
  /**
  * Returns a vector of the initial/last points of the tracker.
  * Returns as a Cartesian coordinate
  */
  get vectorCartesian() {
    return fromLineCartesian2(this.lineStartEnd);
  }
  /**
  * Returns a line from initial point to last point.
  *
  * If there are less than two points, Lines.Empty is returned
  */
  get lineStartEnd() {
    const initial = this.initial;
    if (this.values.length < 2 || !initial) return Empty$32;
    return {
      a: initial,
      b: this.last
    };
  }
  /**
  * Returns distance from latest point to initial point.
  * If there are less than two points, zero is returned.
  *
  * This is the direct distance from initial to last,
  * not the accumulated length. Use {@link length} for that.
  * @returns Distance
  */
  distanceFromStart() {
    const initial = this.initial;
    return this.values.length >= 2 && initial !== void 0 ? distance4(initial, this.last) : 0;
  }
  /**
  * Returns the speed (over milliseconds) based on accumulated travel distance.
  * 
  * If there's no initial point, 0 is returned.
  * @returns 
  */
  speedFromStart() {
    const d3 = this.length;
    const t6 = this.timespan;
    if (Number.isNaN(t6)) return 0;
    if (d3 === 0) return 0;
    return Math.abs(d3) / t6;
  }
  /**
  * Difference between last point and the initial point, calculated
  * as a simple subtraction of x,y & z.
  *
  * `Points.Placeholder` is returned if there's only one point so far.
  */
  difference() {
    const initial = this.initial;
    return this.values.length >= 2 && initial !== void 0 ? subtract$22(this.last, initial) : Placeholder$32;
  }
  /**
  * Returns angle (in radians) from latest point to the initial point
  * If there are less than two points, undefined is return.
  * @returns Angle in radians
  */
  angleFromStart() {
    const initial = this.initial;
    if (initial !== void 0 && this.values.length > 2) return angleRadian2(initial, this.last);
  }
  /**
  * Returns the total distance from accumulated points.
  * Returns 0 if points were not saved, or there's only one
  */
  get length() {
    if (this.values.length === 1) return 0;
    const l3 = this.line;
    return length2(l3);
  }
  /**
  * Returns the last x coord
  */
  get x() {
    return this.last.x;
  }
  /**
  * Returns the last y coord
  */
  get y() {
    return this.last.y;
  }
  /**
  * Returns the last z coord (or _undefined_ if not available)
  */
  get z() {
    return this.last.z;
  }
};
var PointsTracker2 = class extends TrackedValueMap {
  constructor(opts = {}) {
    super((key, start) => {
      if (start === void 0) throw new Error(`Requires start point`);
      const p3 = new PointTracker2({
        ...opts,
        id: key
      });
      p3.seen(start);
      return p3;
    });
  }
  get(id) {
    const v3 = super.get(id);
    return v3;
  }
};
var UserPointerTracker2 = class extends PointTracker2 {
  /**
  * Adds a PointerEvent along with its
  * coalesced events, if available.
  * @param p 
  * @returns 
  */
  seenEvent(p3) {
    if (`getCoalescedEvents` in p3) {
      const events = p3.getCoalescedEvents();
      const asPoints$1 = events.map((event2) => ({
        x: event2.clientX,
        y: event2.clientY
      }));
      return this.seen(...asPoints$1);
    } else return this.seen({
      x: p3.clientX,
      y: p3.clientY
    });
  }
};
var UserPointersTracker2 = class extends TrackedValueMap {
  constructor(opts = {}) {
    super((key, start) => {
      if (start === void 0) throw new Error(`Requires start point`);
      const p3 = new UserPointerTracker2({
        ...opts,
        id: key
      });
      p3.seen(start);
      return p3;
    });
  }
  get(id) {
    const v3 = super.get(id);
    return v3;
  }
  /**
  * Track a PointerEvent
  * @param event
  */
  seenEvent(event2) {
    if (`getCoalescedEvents` in event2) {
      const events = event2.getCoalescedEvents();
      const seens = events.map((subEvent) => super.seen(subEvent.pointerId.toString(), subEvent));
      return Promise.all(seens);
    } else return Promise.all([super.seen(event2.pointerId.toString(), event2)]);
  }
};
var progressBetween2 = (position, waypointA, waypointB) => {
  const a3 = subtract$22(position, waypointA);
  const b3 = subtract$22(waypointB, waypointA);
  return isPoint3d2(a3) && isPoint3d2(b3) ? (a3.x * b3.x + a3.y * b3.y + a3.z * b3.z) / (b3.x * b3.x + b3.y * b3.y + b3.z * b3.z) : (a3.x * b3.x + a3.y * b3.y) / (b3.x * b3.x + b3.y * b3.y);
};
var project2 = (origin, distance$2, angle) => {
  const x3 = Math.cos(angle) * distance$2 + origin.x;
  const y3 = Math.sin(angle) * distance$2 + origin.y;
  return {
    x: x3,
    y: y3
  };
};
function quantiseEvery$12(pt2, snap, middleRoundsUp = true) {
  guard$12(pt2, `pt`);
  guard$12(snap, `snap`);
  if (isPoint3d2(pt2)) {
    if (!isPoint3d2(snap)) throw new TypeError(`Param 'snap' is missing 'z' field`);
    return Object.freeze({
      x: quantiseEvery(pt2.x, snap.x, middleRoundsUp),
      y: quantiseEvery(pt2.y, snap.y, middleRoundsUp),
      z: quantiseEvery(pt2.z, snap.z, middleRoundsUp)
    });
  }
  return Object.freeze({
    x: quantiseEvery(pt2.x, snap.x, middleRoundsUp),
    y: quantiseEvery(pt2.y, snap.y, middleRoundsUp)
  });
}
var random$22 = (rando) => {
  if (typeof rando === `undefined`) rando = Math.random;
  return Object.freeze({
    x: rando(),
    y: rando()
  });
};
var random3d2 = (rando) => {
  if (typeof rando === `undefined`) rando = Math.random;
  return Object.freeze({
    x: rando(),
    y: rando(),
    z: rando()
  });
};
var reduce3 = (pts, fn2, initial) => {
  if (initial === void 0) initial = {
    x: 0,
    y: 0
  };
  let accumulator = initial;
  for (const p3 of pts) accumulator = fn2(p3, accumulator);
  return accumulator;
};
function rotate3(pt2, amountRadian, origin) {
  if (typeof origin === `undefined`) origin = {
    x: 0,
    y: 0
  };
  guard$12(origin, `origin`);
  resultThrow(numberTest(amountRadian, ``, `amountRadian`));
  const arrayInput = Array.isArray(pt2);
  if (amountRadian === 0) return pt2;
  if (!arrayInput) pt2 = [pt2];
  const ptAr = pt2;
  for (const [index, p3] of ptAr.entries()) guard$12(p3, `pt[${index}]`);
  const asPolar = ptAr.map((p3) => fromCartesian2(p3, origin));
  const rotated = asPolar.map((p3) => rotate$32(p3, amountRadian));
  const asCartesisan = rotated.map((p3) => toCartesian2(p3, origin));
  return arrayInput ? asCartesisan : asCartesisan[0];
}
var rotatePointArray2 = (v3, amountRadian) => {
  const mat = [[Math.cos(amountRadian), -Math.sin(amountRadian)], [Math.sin(amountRadian), Math.cos(amountRadian)]];
  const result = [];
  for (const [index, element] of v3.entries()) result[index] = [mat[0][0] * element[0] + mat[0][1] * element[1], mat[1][0] * element[0] + mat[1][1] * element[1]];
  return result;
};
var round$13 = (ptOrX, yOrDigits, digits) => {
  const pt2 = getPointParameter2(ptOrX, yOrDigits);
  digits = digits ?? yOrDigits;
  digits = digits ?? 2;
  return Object.freeze({
    ...pt2,
    x: round2(digits, pt2.x),
    y: round2(digits, pt2.y)
  });
};
var withinRange$12 = (a3, b3, maxRange) => {
  guard$12(a3, `a`);
  guard$12(b3, `b`);
  if (typeof maxRange === `number`) {
    resultThrow(numberTest(maxRange, `positive`, `maxRange`));
    maxRange = {
      x: maxRange,
      y: maxRange
    };
  } else guard$12(maxRange, `maxRange`);
  const x3 = Math.abs(b3.x - a3.x);
  const y3 = Math.abs(b3.y - a3.y);
  return x3 <= maxRange.x && y3 <= maxRange.y;
};
var wrap$12 = (pt2, ptMax, ptMin) => {
  if (ptMax === void 0) ptMax = {
    x: 1,
    y: 1
  };
  if (ptMin === void 0) ptMin = {
    x: 0,
    y: 0
  };
  guard$12(pt2, `pt`);
  guard$12(ptMax, `ptMax`);
  guard$12(ptMin, `ptMin`);
  return Object.freeze({
    x: wrap2(pt2.x, ptMin.x, ptMax.x),
    y: wrap2(pt2.y, ptMin.y, ptMax.y)
  });
};
var point_exports2 = {};
__export(point_exports2, {
  Empty: () => Empty2,
  Empty3d: () => Empty3d2,
  Placeholder: () => Placeholder$32,
  Placeholder3d: () => Placeholder3d2,
  PointTracker: () => PointTracker2,
  PointsTracker: () => PointsTracker2,
  Unit: () => Unit2,
  Unit3d: () => Unit3d2,
  UserPointerTracker: () => UserPointerTracker2,
  UserPointersTracker: () => UserPointersTracker2,
  abs: () => abs4,
  angleRadian: () => angleRadian2,
  angleRadianCircle: () => angleRadianCircle2,
  apply: () => apply$22,
  averager: () => averager2,
  bbox: () => bbox$12,
  bbox3d: () => bbox3d2,
  centroid: () => centroid$12,
  clamp: () => clamp$13,
  clampMagnitude: () => clampMagnitude2,
  compare: () => compare5,
  compareByX: () => compareByX2,
  compareByY: () => compareByY2,
  compareByZ: () => compareByZ2,
  convexHull: () => convexHull2,
  distance: () => distance4,
  distanceToCenter: () => distanceToCenter2,
  distanceToExterior: () => distanceToExterior2,
  divide: () => divide$22,
  divider: () => divider2,
  dotProduct: () => dotProduct$12,
  findMinimum: () => findMinimum2,
  from: () => from2,
  fromNumbers: () => fromNumbers2,
  fromString: () => fromString2,
  getPointParameter: () => getPointParameter2,
  getTwoPointParameters: () => getTwoPointParameters2,
  guard: () => guard$12,
  guardNonZeroPoint: () => guardNonZeroPoint2,
  interpolate: () => interpolate$22,
  invert: () => invert3,
  isEmpty: () => isEmpty4,
  isEqual: () => isEqual3,
  isNaN: () => isNaN$12,
  isNull: () => isNull2,
  isPlaceholder: () => isPlaceholder2,
  isPoint: () => isPoint2,
  isPoint3d: () => isPoint3d2,
  leftmost: () => leftmost2,
  multiply: () => multiply$22,
  multiplyScalar: () => multiplyScalar$12,
  normalise: () => normalise2,
  normaliseByRect: () => normaliseByRect2,
  pipeline: () => pipeline2,
  pipelineApply: () => pipelineApply2,
  progressBetween: () => progressBetween2,
  project: () => project2,
  quantiseEvery: () => quantiseEvery$12,
  random: () => random$22,
  random3d: () => random3d2,
  reduce: () => reduce3,
  relation: () => relation2,
  rightmost: () => rightmost2,
  rotate: () => rotate3,
  rotatePointArray: () => rotatePointArray2,
  round: () => round$13,
  subtract: () => subtract$22,
  sum: () => sum$13,
  test: () => test2,
  to2d: () => to2d2,
  to3d: () => to3d2,
  toArray: () => toArray$13,
  toIntegerValues: () => toIntegerValues2,
  toString: () => toString$22,
  withinRange: () => withinRange$12,
  wrap: () => wrap$12
});
var rotate$22 = (line3, amountRadian, origin) => {
  if (typeof amountRadian === `undefined` || amountRadian === 0) return line3;
  if (typeof origin === `undefined`) origin = 0.5;
  if (typeof origin === `number`) origin = interpolate$12(origin, line3.a, line3.b);
  return Object.freeze({
    ...line3,
    a: rotate3(line3.a, amountRadian, origin),
    b: rotate3(line3.b, amountRadian, origin)
  });
};
var isEqual$32 = (a3, b3) => isEqual3(a3.a, b3.a) && isEqual3(a3.b, b3.b);
var multiply$12 = (line3, point$1) => Object.freeze({
  ...line3,
  a: multiply$22(line3.a, point$1),
  b: multiply$22(line3.b, point$1)
});
var subtract$12 = (line3, point$1) => Object.freeze({
  ...line3,
  a: subtract$22(line3.a, point$1),
  b: subtract$22(line3.b, point$1)
});
function toString$14(a3, b3) {
  if (isLine2(a3)) {
    guard$34(a3, `a`);
    b3 = a3.b;
    a3 = a3.a;
  } else if (b3 === void 0) throw new Error(`Expect second point if first is a point`);
  return toString$22(a3) + `-` + toString$22(b3);
}
var toPath2 = (line3) => {
  const { a: a3, b: b3 } = line3;
  return Object.freeze({
    ...line3,
    length: () => length2(a3, b3),
    interpolate: (amount) => interpolate$12(amount, a3, b3),
    relativePosition: (point$1) => relativePosition$12(line3, point$1),
    bbox: () => bbox$32(line3),
    toString: () => toString$14(a3, b3),
    toFlatArray: () => toFlatArray$12(a3, b3),
    toSvgString: () => toSvgString$12(a3, b3),
    toPoints: () => [a3, b3],
    rotate: (amountRadian, origin) => toPath2(rotate$22(line3, amountRadian, origin)),
    nearest: (point$1) => nearest2(line3, point$1),
    sum: (point$1) => toPath2(sum$22(line3, point$1)),
    divide: (point$1) => toPath2(divide$12(line3, point$1)),
    multiply: (point$1) => toPath2(multiply$12(line3, point$1)),
    subtract: (point$1) => toPath2(subtract$12(line3, point$1)),
    midpoint: () => midpoint2(a3, b3),
    distanceToPoint: (point$1) => distanceSingleLine2(line3, point$1),
    parallel: (distance$2) => parallel2(line3, distance$2),
    perpendicularPoint: (distance$2, amount) => perpendicularPoint2(line3, distance$2, amount),
    slope: () => slope2(line3),
    withinRange: (point$1, maxRange) => withinRange2(line3, point$1, maxRange),
    isEqual: (otherLine) => isEqual$32(line3, otherLine),
    apply: (fn2) => toPath2(apply$12(line3, fn2)),
    kind: `line`
  });
};
var fromPointsToPath2 = (a3, b3) => toPath2(fromPoints$22(a3, b3));
var line_exports2 = {};
__export(line_exports2, {
  Empty: () => Empty$32,
  Placeholder: () => Placeholder$22,
  angleRadian: () => angleRadian$12,
  apply: () => apply$12,
  asPoints: () => asPoints2,
  bbox: () => bbox$32,
  distance: () => distance$12,
  distanceSingleLine: () => distanceSingleLine2,
  divide: () => divide$12,
  extendFromA: () => extendFromA2,
  fromFlatArray: () => fromFlatArray$12,
  fromNumbers: () => fromNumbers$22,
  fromPivot: () => fromPivot2,
  fromPoints: () => fromPoints$22,
  fromPointsToPath: () => fromPointsToPath2,
  getPointParameter: () => getPointParameter$12,
  guard: () => guard$34,
  interpolate: () => interpolate$12,
  isEmpty: () => isEmpty$22,
  isEqual: () => isEqual$32,
  isLine: () => isLine2,
  isPlaceholder: () => isPlaceholder$22,
  isPolyLine: () => isPolyLine2,
  joinPointsToLines: () => joinPointsToLines2,
  length: () => length2,
  midpoint: () => midpoint2,
  multiply: () => multiply$12,
  nearest: () => nearest2,
  normaliseByRect: () => normaliseByRect$12,
  parallel: () => parallel2,
  perpendicularPoint: () => perpendicularPoint2,
  pointAtDistance: () => pointAtDistance2,
  pointAtX: () => pointAtX2,
  pointsOf: () => pointsOf2,
  relativePosition: () => relativePosition$12,
  reverse: () => reverse2,
  rotate: () => rotate$22,
  scaleFromMidpoint: () => scaleFromMidpoint2,
  slope: () => slope2,
  subtract: () => subtract$12,
  sum: () => sum$22,
  toFlatArray: () => toFlatArray$12,
  toPath: () => toPath2,
  toString: () => toString$14,
  toSvgString: () => toSvgString$12,
  withinRange: () => withinRange2
});
var Empty$32 = Object.freeze({
  a: Object.freeze({
    x: 0,
    y: 0
  }),
  b: Object.freeze({
    x: 0,
    y: 0
  })
});
var Placeholder$22 = Object.freeze({
  a: Object.freeze({
    x: NaN,
    y: NaN
  }),
  b: Object.freeze({
    x: NaN,
    y: NaN
  })
});
var isEmpty$22 = (l3) => isEmpty4(l3.a) && isEmpty4(l3.b);
var isPlaceholder$22 = (l3) => isPlaceholder2(l3.a) && isPlaceholder2(l3.b);
var apply$12 = (line3, fn2) => Object.freeze({
  ...line3,
  a: fn2(line3.a),
  b: fn2(line3.b)
});
var angleRadian$12 = (lineOrPoint, b3) => {
  let a3;
  if (isLine2(lineOrPoint)) {
    a3 = lineOrPoint.a;
    b3 = lineOrPoint.b;
  } else {
    a3 = lineOrPoint;
    if (b3 === void 0) throw new Error(`b point must be provided`);
  }
  return Math.atan2(b3.y - a3.y, b3.x - a3.x);
};
var normaliseByRect$12 = (line3, width, height$3) => Object.freeze({
  ...line3,
  a: normaliseByRect2(line3.a, width, height$3),
  b: normaliseByRect2(line3.b, width, height$3)
});
var withinRange2 = (line3, point$1, maxRange) => {
  const calculatedDistance = distance$12(line3, point$1);
  return calculatedDistance <= maxRange;
};
var slope2 = (lineOrPoint, b3) => {
  let a3;
  if (isLine2(lineOrPoint)) {
    a3 = lineOrPoint.a;
    b3 = lineOrPoint.b;
  } else {
    a3 = lineOrPoint;
    if (b3 === void 0) throw new Error(`b parameter required`);
  }
  if (b3 === void 0) throw new TypeError(`Second point missing`);
  else return (b3.y - a3.y) / (b3.x - a3.x);
};
var scaleFromMidpoint2 = (line3, factor) => {
  const a3 = interpolate$12(factor / 2, line3);
  const b3 = interpolate$12(0.5 + factor / 2, line3);
  return {
    a: a3,
    b: b3
  };
};
var pointAtX2 = (line3, x3) => {
  const y3 = line3.a.y + (x3 - line3.a.x) * slope2(line3);
  return Object.freeze({
    x: x3,
    y: y3
  });
};
var extendFromA2 = (line3, distance$2) => {
  const calculatedLength = length2(line3);
  return Object.freeze({
    ...line3,
    a: line3.a,
    b: Object.freeze({
      x: line3.b.x + (line3.b.x - line3.a.x) / calculatedLength * distance$2,
      y: line3.b.y + (line3.b.y - line3.a.y) / calculatedLength * distance$2
    })
  });
};
function* pointsOf2(line3) {
  const { a: a3, b: b3 } = line3;
  let x0 = Math.floor(a3.x);
  let y0 = Math.floor(a3.y);
  const x1 = Math.floor(b3.x);
  const y1 = Math.floor(b3.y);
  const dx = Math.abs(x1 - x0);
  const dy = -Math.abs(y1 - y0);
  const sx = x0 < x1 ? 1 : -1;
  const sy = y0 < y1 ? 1 : -1;
  let err = dx + dy;
  while (true) {
    yield {
      x: x0,
      y: y0
    };
    if (x0 === x1 && y0 === y1) break;
    const e22 = 2 * err;
    if (e22 >= dy) {
      err += dy;
      x0 += sx;
    }
    if (e22 <= dx) {
      err += dx;
      y0 += sy;
    }
  }
}
var distance$12 = (line3, point$1) => {
  if (Array.isArray(line3)) {
    const distances = line3.map((l3) => distanceSingleLine2(l3, point$1));
    return minFast(distances);
  } else return distanceSingleLine2(line3, point$1);
};
var toFlatArray$12 = (a3, b3) => {
  if (isLine2(a3)) return [
    a3.a.x,
    a3.a.y,
    a3.b.x,
    a3.b.y
  ];
  else if (isPoint2(a3) && isPoint2(b3)) return [
    a3.x,
    a3.y,
    b3.x,
    b3.y
  ];
  else throw new Error(`Expected single line parameter, or a and b points`);
};
function* asPoints2(lines) {
  for (const l3 of lines) {
    yield l3.a;
    yield l3.b;
  }
}
var toSvgString$12 = (a3, b3) => [`M${a3.x} ${a3.y} L ${b3.x} ${b3.y}`];
var corners$12 = (rect3, origin) => {
  const r5 = getRectPositioned2(rect3, origin);
  return [
    {
      x: r5.x,
      y: r5.y
    },
    {
      x: r5.x + r5.width,
      y: r5.y
    },
    {
      x: r5.x + r5.width,
      y: r5.y + r5.height
    },
    {
      x: r5.x,
      y: r5.y + r5.height
    }
  ];
};
var getStart2 = function(path3) {
  if (isQuadraticBezier2(path3)) return path3.a;
  else if (isLine2(path3)) return path3.a;
  else throw new Error(`Unknown path type ${JSON.stringify(path3)}`);
};
var getEnd2 = function(path3) {
  if (isQuadraticBezier2(path3)) return path3.b;
  else if (isLine2(path3)) return path3.b;
  else throw new Error(`Unknown path type ${JSON.stringify(path3)}`);
};
var compound_path_exports2 = {};
__export(compound_path_exports2, {
  bbox: () => bbox$22,
  computeDimensions: () => computeDimensions2,
  distanceToPoint: () => distanceToPoint2,
  fromPaths: () => fromPaths2,
  guardContinuous: () => guardContinuous2,
  interpolate: () => interpolate3,
  relativePosition: () => relativePosition2,
  setSegment: () => setSegment2,
  toString: () => toString4,
  toSvgString: () => toSvgString2
});
var setSegment2 = (compoundPath, index, path3) => {
  const existing = [...compoundPath.segments];
  existing[index] = path3;
  return fromPaths2(...existing);
};
var interpolate3 = (paths3, t6, useWidth, dimensions) => {
  if (dimensions === void 0) dimensions = computeDimensions2(paths3);
  const expected = t6 * (useWidth ? dimensions.totalWidth : dimensions.totalLength);
  let soFar = 0;
  const l3 = useWidth ? dimensions.widths : dimensions.lengths;
  for (const [index, element] of l3.entries()) if (soFar + element >= expected) {
    const relative2 = expected - soFar;
    let amt = relative2 / element;
    if (amt > 1) amt = 1;
    return paths3[index].interpolate(amt);
  } else soFar += element;
  return {
    x: 0,
    y: 0
  };
};
var distanceToPoint2 = (paths3, point$1) => {
  if (paths3.length === 0) return 0;
  let distances = paths3.map((p3, index) => ({
    path: p3,
    index,
    distance: p3.distanceToPoint(point$1)
  }));
  distances = sortByNumericProperty(distances, `distance`);
  if (distances.length === 0) throw new Error(`Could not look up distances`);
  return distances[0].distance;
};
var relativePosition2 = (paths3, point$1, intersectionThreshold, dimensions) => {
  if (dimensions === void 0) dimensions = computeDimensions2(paths3);
  let distances = paths3.map((p3, index) => ({
    path: p3,
    index,
    distance: p3.distanceToPoint(point$1)
  }));
  distances = sortByNumericProperty(distances, `distance`);
  if (distances.length < 0) throw new Error(`Point does not intersect with path`);
  const d3 = distances[0];
  if (d3.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${d3.distance}, threshold: ${intersectionThreshold}`);
  const relativePositionOnPath = d3.path.relativePosition(point$1, intersectionThreshold);
  let accumulated = 0;
  for (let index = 0; index < d3.index; index++) accumulated += dimensions.lengths[index];
  accumulated += dimensions.lengths[d3.index] * relativePositionOnPath;
  const accumulatedRel = accumulated / dimensions.totalLength;
  console.log(`acc: ${accumulated} rel: ${accumulatedRel} on path: ${relativePositionOnPath} path: ${d3.index}`);
  return accumulatedRel;
};
var computeDimensions2 = (paths3) => {
  const widths = paths3.map((l3) => l3.bbox().width);
  const lengths$2 = paths3.map((l3) => l3.length());
  let totalLength = 0;
  let totalWidth = 0;
  for (const length$4 of lengths$2) totalLength += length$4;
  for (const width of widths) totalWidth += width;
  return {
    totalLength,
    totalWidth,
    widths,
    lengths: lengths$2
  };
};
var bbox$22 = (paths3) => {
  const boxes = paths3.map((p3) => p3.bbox());
  const corners$2 = boxes.flatMap((b3) => corners$12(b3));
  return bbox$12(...corners$2);
};
var toString4 = (paths3) => paths3.map((p3) => p3.toString()).join(`, `);
var guardContinuous2 = (paths3) => {
  let lastPos = getEnd2(paths3[0]);
  for (let index = 1; index < paths3.length; index++) {
    const start = getStart2(paths3[index]);
    if (!isEqual3(start, lastPos)) throw new Error(`Path index ${index} does not start at prior path end. Start: ${start.x},${start.y} expected: ${lastPos.x},${lastPos.y}`);
    lastPos = getEnd2(paths3[index]);
  }
};
var toSvgString2 = (paths3) => paths3.flatMap((p3) => p3.toSvgString());
var fromPaths2 = (...paths3) => {
  guardContinuous2(paths3);
  const dims = computeDimensions2(paths3);
  return Object.freeze({
    segments: paths3,
    length: () => dims.totalLength,
    nearest: (_3) => {
      throw new Error(`not implemented`);
    },
    interpolate: (t6, useWidth = false) => interpolate3(paths3, t6, useWidth, dims),
    relativePosition: (point$1, intersectionThreshold) => relativePosition2(paths3, point$1, intersectionThreshold, dims),
    distanceToPoint: (point$1) => distanceToPoint2(paths3, point$1),
    bbox: () => bbox$22(paths3),
    toString: () => toString4(paths3),
    toSvgString: () => toSvgString2(paths3),
    kind: `compound`
  });
};
var path_exports2 = {};
__export(path_exports2, {
  bbox: () => bbox$22,
  computeDimensions: () => computeDimensions2,
  distanceToPoint: () => distanceToPoint2,
  fromPaths: () => fromPaths2,
  getEnd: () => getEnd2,
  getStart: () => getStart2,
  guardContinuous: () => guardContinuous2,
  interpolate: () => interpolate3,
  relativePosition: () => relativePosition2,
  setSegment: () => setSegment2,
  toString: () => toString4,
  toSvgString: () => toSvgString2
});
var area$42 = (rect3) => {
  guard$24(rect3);
  return rect3.height * rect3.width;
};
function applyFields2(op, rectOrWidth, heightValue) {
  let width = typeof rectOrWidth === `number` ? rectOrWidth : rectOrWidth.width;
  let height$3 = typeof rectOrWidth === `number` ? heightValue : rectOrWidth.height;
  if (width === void 0) throw new Error(`Param 'width' undefined`);
  if (height$3 === void 0) throw new Error(`Param 'height' undefined`);
  width = op(width, `width`);
  height$3 = op(height$3, `height`);
  if (typeof rectOrWidth === `object`) if (isPositioned2(rectOrWidth)) {
    const x3 = op(rectOrWidth.x, `x`);
    const y3 = op(rectOrWidth.y, `y`);
    return {
      ...rectOrWidth,
      width,
      height: height$3,
      x: x3,
      y: y3
    };
  } else return {
    ...rectOrWidth,
    width,
    height: height$3
  };
  return {
    width,
    height: height$3
  };
}
function applyMerge2(op, a3, b3, c5) {
  guard$24(a3, `a`);
  if (isRect2(b3)) return isRectPositioned2(a3) ? Object.freeze({
    ...a3,
    x: op(a3.x, b3.width),
    y: op(a3.y, b3.height),
    width: op(a3.width, b3.width),
    height: op(a3.height, b3.height)
  }) : Object.freeze({
    ...a3,
    width: op(a3.width, b3.width),
    height: op(a3.height, b3.height)
  });
  else {
    if (typeof b3 !== `number`) throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(b3)}`);
    if (typeof c5 !== `number`) throw new Error(`Expected third param as height. Got ${JSON.stringify(c5)}`);
    return isRectPositioned2(a3) ? Object.freeze({
      ...a3,
      x: op(a3.x, b3),
      y: op(a3.y, c5),
      width: op(a3.width, b3),
      height: op(a3.height, c5)
    }) : Object.freeze({
      ...a3,
      width: op(a3.width, b3),
      height: op(a3.height, c5)
    });
  }
}
function applyScalar2(op, rect3, parameter) {
  return isPositioned2(rect3) ? Object.freeze({
    ...rect3,
    x: op(rect3.x, parameter),
    y: op(rect3.y, parameter),
    width: op(rect3.width, parameter),
    height: op(rect3.height, parameter)
  }) : Object.freeze({
    ...rect3,
    width: op(rect3.width, parameter),
    height: op(rect3.height, parameter)
  });
}
function applyDim2(op, rect3, parameter) {
  return Object.freeze({
    ...rect3,
    width: op(rect3.width, parameter),
    height: op(rect3.height, parameter)
  });
}
var cardinal2 = (rect3, card) => {
  const { x: x3, y: y3, width, height: height$3 } = rect3;
  switch (card) {
    case `nw`:
      return Object.freeze({
        x: x3,
        y: y3
      });
    case `n`:
      return Object.freeze({
        x: x3 + width / 2,
        y: y3
      });
    case `ne`:
      return Object.freeze({
        x: x3 + width,
        y: y3
      });
    case `sw`:
      return Object.freeze({
        x: x3,
        y: y3 + height$3
      });
    case `s`:
      return Object.freeze({
        x: x3 + width / 2,
        y: y3 + height$3
      });
    case `se`:
      return Object.freeze({
        x: x3 + width,
        y: y3 + height$3
      });
    case `w`:
      return Object.freeze({
        x: x3,
        y: y3 + height$3 / 2
      });
    case `e`:
      return Object.freeze({
        x: x3 + width,
        y: y3 + height$3 / 2
      });
    case `center`:
      return Object.freeze({
        x: x3 + width / 2,
        y: y3 + height$3 / 2
      });
    default:
      throw new Error(`Unknown direction: ${card}`);
  }
};
var centerOrigin2 = (rectAbsolute) => {
  const c5 = center$12(rectAbsolute);
  const w3 = rectAbsolute.width / 2;
  const h5 = rectAbsolute.height / 2;
  const relativeToAbsolute = (point$1) => {
    return {
      ...point$1,
      x: point$1.x * w3 + c5.x,
      y: point$1.y * h5 + c5.y
    };
  };
  const absoluteToRelative = (point$1) => {
    return {
      ...point$1,
      x: (point$1.x - rectAbsolute.x) / w3 - 1,
      y: (point$1.y - rectAbsolute.y) / h5 - 1
    };
  };
  return {
    relativeToAbsolute,
    absoluteToRelative
  };
};
var divideOp2 = (a3, b3) => a3 / b3;
function divide2(a3, b3, c5) {
  return applyMerge2(divideOp2, a3, b3, c5);
}
function divideScalar2(rect3, amount) {
  return applyScalar2(divideOp2, rect3, amount);
}
function divideDim2(rect3, amount) {
  return applyDim2(divideOp2, rect3, amount);
}
var edges$12 = (rect3, origin) => {
  const c5 = corners$12(rect3, origin);
  return joinPointsToLines2(...c5, c5[0]);
};
var getEdgeX2 = (rect3, edge) => {
  guard$24(rect3);
  switch (edge) {
    case `top`:
      return isPoint2(rect3) ? rect3.x : 0;
    case `bottom`:
      return isPoint2(rect3) ? rect3.x : 0;
    case `left`:
      return isPoint2(rect3) ? rect3.y : 0;
    case `right`:
      return isPoint2(rect3) ? rect3.x + rect3.width : rect3.width;
  }
};
var getEdgeY2 = (rect3, edge) => {
  guard$24(rect3);
  switch (edge) {
    case `top`:
      return isPoint2(rect3) ? rect3.y : 0;
    case `bottom`:
      return isPoint2(rect3) ? rect3.y + rect3.height : rect3.height;
    case `left`:
      return isPoint2(rect3) ? rect3.y : 0;
    case `right`:
      return isPoint2(rect3) ? rect3.y : 0;
  }
};
var Empty$22 = Object.freeze({
  width: 0,
  height: 0
});
var EmptyPositioned2 = Object.freeze({
  x: 0,
  y: 0,
  width: 0,
  height: 0
});
var encompass2 = (rect3, ...points) => {
  const x3 = points.map((p3) => p3.x);
  const y3 = points.map((p3) => p3.y);
  let minX = Math.min(...x3, rect3.x);
  let minY = Math.min(...y3, rect3.y);
  let maxX = Math.max(...x3, rect3.x + rect3.width);
  let maxY = Math.max(...y3, rect3.y + rect3.height);
  let rectW = Math.max(rect3.width, maxX - minX);
  let rectH = Math.max(rect3.height, maxY - minY);
  return Object.freeze({
    ...rect3,
    x: minX,
    y: minY,
    width: rectW,
    height: rectH
  });
};
var fromElement2 = (el2) => ({
  width: el2.clientWidth,
  height: el2.clientHeight
});
function fromNumbers$12(xOrWidth, yOrHeight, width, height$3) {
  if (width === void 0 || height$3 === void 0) {
    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);
    if (typeof yOrHeight !== `number`) throw new TypeError(`height is not an number`);
    return Object.freeze({
      width: xOrWidth,
      height: yOrHeight
    });
  }
  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);
  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);
  if (typeof width !== `number`) throw new Error(`width is not an number`);
  if (typeof height$3 !== `number`) throw new Error(`height is not an number`);
  return Object.freeze({
    x: xOrWidth,
    y: yOrHeight,
    width,
    height: height$3
  });
}
function getRectPositionedParameter2(a3, b3, c5, d3) {
  if (typeof a3 === `number`) if (typeof b3 === `number`) if (typeof c5 === `number` && typeof d3 === `number`) return {
    x: a3,
    y: b3,
    width: c5,
    height: d3
  };
  else if (isRect2(c5)) return {
    x: a3,
    y: b3,
    width: c5.width,
    height: c5.height
  };
  else throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);
  else throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);
  else if (isRectPositioned2(a3)) return a3;
  else if (isRect2(a3)) if (typeof b3 === `number` && typeof c5 === `number`) return {
    width: a3.width,
    height: a3.height,
    x: b3,
    y: c5
  };
  else if (isPoint2(b3)) return {
    width: a3.width,
    height: a3.height,
    x: b3.x,
    y: b3.y
  };
  else throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);
  else if (isPoint2(a3)) if (typeof b3 === `number` && typeof c5 === `number`) return {
    x: a3.x,
    y: a3.y,
    width: b3,
    height: c5
  };
  else if (isRect2(b3)) return {
    x: a3.x,
    y: a3.y,
    width: b3.width,
    height: b3.height
  };
  else throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);
  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);
}
var isEqualSize2 = (a3, b3) => {
  if (a3 === void 0) throw new Error(`a undefined`);
  if (b3 === void 0) throw new Error(`b undefined`);
  return a3.width === b3.width && a3.height === b3.height;
};
var isEqual$22 = (a3, b3) => {
  if (isPositioned2(a3) && isPositioned2(b3)) {
    if (!isEqual3(a3, b3)) return false;
    return a3.width === b3.width && a3.height === b3.height;
  } else if (!isPositioned2(a3) && !isPositioned2(b3)) return a3.width === b3.width && a3.height === b3.height;
  else return false;
};
var lengths$12 = (rect3) => {
  guardPositioned2(rect3, `rect`);
  return edges$12(rect3).map((l3) => length2(l3));
};
var multiplyOp2 = (a3, b3) => a3 * b3;
function multiply4(a3, b3, c5) {
  return applyMerge2(multiplyOp2, a3, b3, c5);
}
function multiplyScalar2(rect3, amount) {
  return applyScalar2(multiplyOp2, rect3, amount);
}
function multiplyDim2(rect3, amount) {
  return applyDim2(multiplyOp2, rect3, amount);
}
var nearestInternal2 = (rect3, p3) => {
  let { x: x3, y: y3 } = p3;
  if (x3 < rect3.x) x3 = rect3.x;
  else if (x3 > rect3.x + rect3.width) x3 = rect3.x + rect3.width;
  if (y3 < rect3.y) y3 = rect3.y;
  else if (y3 > rect3.y + rect3.height) y3 = rect3.y + rect3.height;
  return Object.freeze({
    ...p3,
    x: x3,
    y: y3
  });
};
var Placeholder2 = Object.freeze({
  width: NaN,
  height: NaN
});
var PlaceholderPositioned2 = Object.freeze({
  x: NaN,
  y: NaN,
  width: NaN,
  height: NaN
});
var perimeter$42 = (rect3) => {
  guard$24(rect3);
  return rect3.height + rect3.height + rect3.width + rect3.width;
};
var dividerByLargestDimension2 = (rect3) => {
  const largest = Math.max(rect3.width, rect3.height);
  return (value3) => {
    if (typeof value3 === `number`) return value3 / largest;
    else if (isPoint3d2(value3)) return Object.freeze({
      ...value3,
      x: value3.x / largest,
      y: value3.y / largest,
      z: value3.x / largest
    });
    else if (isPoint2(value3)) return Object.freeze({
      ...value3,
      x: value3.x / largest,
      y: value3.y / largest
    });
    else throw new Error(`Param 'value' is neither number nor Point`);
  };
};
var random$12 = (rando) => {
  rando ??= Math.random;
  return Object.freeze({
    x: rando(),
    y: rando(),
    width: rando(),
    height: rando()
  });
};
var randomPoint$22 = (within, options = {}) => {
  const rand = options.randomSource ?? Math.random;
  const margin = options.margin ?? {
    x: 0,
    y: 0
  };
  const x3 = rand() * (within.width - margin.x - margin.x);
  const y3 = rand() * (within.height - margin.y - margin.y);
  const pos = {
    x: x3 + margin.x,
    y: y3 + margin.y
  };
  return isPositioned2(within) ? sum$13(pos, within) : Object.freeze(pos);
};
var subtractOp2 = (a3, b3) => a3 - b3;
function subtract2(a3, b3, c5) {
  return applyMerge2(subtractOp2, a3, b3, c5);
}
function subtractSize2(a3, b3, c5) {
  const w3 = typeof b3 === `number` ? b3 : b3.width;
  const h5 = typeof b3 === `number` ? c5 : b3.height;
  if (h5 === void 0) throw new Error(`Expected height as third parameter`);
  const r5 = {
    ...a3,
    width: a3.width - w3,
    height: a3.height - h5
  };
  return r5;
}
function subtractOffset2(a3, b3) {
  let x3 = 0;
  let y3 = 0;
  if (isPositioned2(a3)) {
    x3 = a3.x;
    y3 = a3.y;
  }
  let xB = 0;
  let yB = 0;
  if (isPositioned2(b3)) {
    xB = b3.x;
    yB = b3.y;
  }
  return Object.freeze({
    ...a3,
    x: x3 - xB,
    y: y3 - yB,
    width: a3.width - b3.width,
    height: a3.height - b3.height
  });
}
var sumOp2 = (a3, b3) => a3 + b3;
function sum3(a3, b3, c5) {
  return applyMerge2(sumOp2, a3, b3, c5);
}
function sumOffset2(a3, b3) {
  let x3 = 0;
  let y3 = 0;
  if (isPositioned2(a3)) {
    x3 = a3.x;
    y3 = a3.y;
  }
  let xB = 0;
  let yB = 0;
  if (isPositioned2(b3)) {
    xB = b3.x;
    yB = b3.y;
  }
  return Object.freeze({
    ...a3,
    x: x3 + xB,
    y: y3 + yB,
    width: a3.width + b3.width,
    height: a3.height + b3.height
  });
}
function toArray4(rect3) {
  if (isPositioned2(rect3)) return [
    rect3.x,
    rect3.y,
    rect3.width,
    rect3.height
  ];
  else if (isRect2(rect3)) return [rect3.width, rect3.height];
  else throw new Error(`Param 'rect' is not a rectangle. Got: ${JSON.stringify(rect3)}`);
}
var rect_exports2 = {};
__export(rect_exports2, {
  Empty: () => Empty$22,
  EmptyPositioned: () => EmptyPositioned2,
  Placeholder: () => Placeholder2,
  PlaceholderPositioned: () => PlaceholderPositioned2,
  applyDim: () => applyDim2,
  applyFields: () => applyFields2,
  applyMerge: () => applyMerge2,
  applyScalar: () => applyScalar2,
  area: () => area$42,
  cardinal: () => cardinal2,
  center: () => center$12,
  centerOrigin: () => centerOrigin2,
  corners: () => corners$12,
  distanceFromCenter: () => distanceFromCenter2,
  distanceFromExterior: () => distanceFromExterior2,
  divide: () => divide2,
  divideDim: () => divideDim2,
  divideScalar: () => divideScalar2,
  dividerByLargestDimension: () => dividerByLargestDimension2,
  edges: () => edges$12,
  encompass: () => encompass2,
  fromCenter: () => fromCenter$22,
  fromElement: () => fromElement2,
  fromNumbers: () => fromNumbers$12,
  fromTopLeft: () => fromTopLeft2,
  getEdgeX: () => getEdgeX2,
  getEdgeY: () => getEdgeY2,
  getRectPositioned: () => getRectPositioned2,
  getRectPositionedParameter: () => getRectPositionedParameter2,
  guard: () => guard$24,
  guardDim: () => guardDim2,
  guardPositioned: () => guardPositioned2,
  intersectsPoint: () => intersectsPoint2,
  isEmpty: () => isEmpty$32,
  isEqual: () => isEqual$22,
  isEqualSize: () => isEqualSize2,
  isIntersecting: () => isIntersecting$12,
  isPlaceholder: () => isPlaceholder$32,
  isPositioned: () => isPositioned2,
  isRect: () => isRect2,
  isRectPositioned: () => isRectPositioned2,
  lengths: () => lengths$12,
  maxFromCorners: () => maxFromCorners2,
  multiply: () => multiply4,
  multiplyDim: () => multiplyDim2,
  multiplyScalar: () => multiplyScalar2,
  nearestInternal: () => nearestInternal2,
  perimeter: () => perimeter$42,
  random: () => random$12,
  randomPoint: () => randomPoint$22,
  subtract: () => subtract2,
  subtractOffset: () => subtractOffset2,
  subtractSize: () => subtractSize2,
  sum: () => sum3,
  sumOffset: () => sumOffset2,
  toArray: () => toArray4
});
var Empty$12 = Object.freeze({
  a: {
    x: 0,
    y: 0
  },
  b: {
    x: 0,
    y: 0
  },
  c: {
    x: 0,
    y: 0
  }
});
var Placeholder$12 = Object.freeze({
  a: {
    x: NaN,
    y: NaN
  },
  b: {
    x: NaN,
    y: NaN
  },
  c: {
    x: NaN,
    y: NaN
  }
});
var equilateralFromVertex2 = (origin, length$4 = 10, angleRadian$2 = Math.PI / 2) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const a3 = project2(origin, length$4, Math.PI - -angleRadian$2 / 2);
  const c5 = project2(origin, length$4, Math.PI - angleRadian$2 / 2);
  return {
    a: a3,
    b: origin,
    c: c5
  };
};
var arrow2 = (origin, from$1, opts = {}) => {
  const tailLength = opts.tailLength ?? 10;
  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);
  const angleRadian$2 = opts.angleRadian ?? 0;
  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);
  const triAngle = Math.PI / 2;
  let tri;
  let tailPoints;
  if (from$1 === `tip`) {
    tri = equilateralFromVertex2(origin, arrowSize, triAngle);
    tailPoints = corners$12(fromTopLeft2({
      x: tri.a.x - tailLength,
      y: origin.y - tailThickness / 2
    }, tailLength, tailThickness));
  } else if (from$1 === `middle`) {
    const midX = tailLength + arrowSize / 2;
    const midY = tailThickness / 2;
    tri = equilateralFromVertex2({
      x: origin.x + arrowSize * 1.2,
      y: origin.y
    }, arrowSize, triAngle);
    tailPoints = corners$12(fromTopLeft2({
      x: origin.x - midX,
      y: origin.y - midY
    }, tailLength + arrowSize, tailThickness));
  } else {
    tailPoints = corners$12(fromTopLeft2({
      x: origin.x,
      y: origin.y - tailThickness / 2
    }, tailLength, tailThickness));
    tri = equilateralFromVertex2({
      x: origin.x + tailLength + arrowSize * 0.7,
      y: origin.y
    }, arrowSize, triAngle);
  }
  const arrow$1 = rotate3([
    tailPoints[0],
    tailPoints[1],
    tri.a,
    tri.b,
    tri.c,
    tailPoints[2],
    tailPoints[3]
  ], angleRadian$2, origin);
  return arrow$1;
};
var guard2 = (t6, name = `t`) => {
  if (t6 === void 0) throw new Error(`{$name} undefined`);
  guard$12(t6.a, name + `.a`);
  guard$12(t6.b, name + `.b`);
  guard$12(t6.c, name + `.c`);
};
var isTriangle2 = (p3) => {
  if (p3 === void 0) return false;
  const tri = p3;
  if (!isPoint2(tri.a)) return false;
  if (!isPoint2(tri.b)) return false;
  if (!isPoint2(tri.c)) return false;
  return true;
};
var isEmpty$14 = (t6) => isEmpty4(t6.a) && isEmpty4(t6.b) && isEmpty4(t6.c);
var isPlaceholder$12 = (t6) => isPlaceholder2(t6.a) && isPlaceholder2(t6.b) && isPlaceholder2(t6.c);
var isEqual$12 = (a3, b3) => isEqual3(a3.a, b3.a) && isEqual3(a3.b, b3.b) && isEqual3(a3.c, b3.c);
var centroid2 = (t6) => {
  guard2(t6);
  const total2 = reduce3([
    t6.a,
    t6.b,
    t6.c
  ], (p3, accumulator) => ({
    x: p3.x + accumulator.x,
    y: p3.y + accumulator.y
  }));
  const div = {
    x: total2.x / 3,
    y: total2.y / 3
  };
  return div;
};
var randomPoint2 = (shape, opts = {}) => {
  if (isCirclePositioned2(shape)) return randomPoint$12(shape, opts);
  else if (isRectPositioned2(shape)) return randomPoint$22(shape, opts);
  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);
};
var center$22 = (shape) => {
  if (shape === void 0) return Object.freeze({
    x: 0.5,
    y: 0.5
  });
  else if (isRect2(shape)) return center$12(shape);
  else if (isTriangle2(shape)) return centroid2(shape);
  else if (isCircle2(shape)) return center2(shape);
  else throw new Error(`Unknown shape: ${JSON.stringify(shape)}`);
};
var isIntersecting$22 = (a3, b3) => {
  if (isCirclePositioned2(a3)) return isIntersecting2(a3, b3);
  else if (isRectPositioned2(a3)) return isIntersecting$12(a3, b3);
  throw new Error(`a or b are unknown shapes. a: ${JSON.stringify(a3)} b: ${JSON.stringify(b3)}`);
};
var starburst2 = (outerRadius, points = 5, innerRadius, origin = Empty2, opts) => {
  resultThrow(integerTest(points, `positive`, `points`));
  const angle = Math.PI * 2 / points;
  const angleHalf = angle / 2;
  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;
  if (innerRadius === void 0) innerRadius = outerRadius / 2;
  let a3 = initialAngle;
  const pts = [];
  for (let index = 0; index < points; index++) {
    const peak = toCartesian2(outerRadius, a3, origin);
    const left = toCartesian2(innerRadius, a3 - angleHalf, origin);
    const right = toCartesian2(innerRadius, a3 + angleHalf, origin);
    pts.push(left, peak);
    if (index + 1 < points) pts.push(right);
    a3 += angle;
  }
  return pts;
};
var shape_exports2 = {};
__export(shape_exports2, {
  arrow: () => arrow2,
  center: () => center$22,
  isIntersecting: () => isIntersecting$22,
  randomPoint: () => randomPoint2,
  starburst: () => starburst2
});
var waypoint_exports2 = {};
__export(waypoint_exports2, {
  fromPoints: () => fromPoints$12,
  init: () => init5
});
var fromPoints$12 = (waypoints, opts = {}) => {
  const lines = joinPointsToLines2(...waypoints);
  return init5(lines.map((l3) => toPath2(l3)), opts);
};
var init5 = (paths3, opts = {}) => {
  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;
  const checkUnordered = (pt2) => {
    const results = paths3.map((p3, index) => {
      const nearest$2 = p3.nearest(pt2);
      const distance$2 = distance4(pt2, nearest$2);
      const positionRelative2 = p3.relativePosition(nearest$2, maxDistanceFromLine);
      return {
        positionRelative: positionRelative2,
        path: p3,
        index,
        nearest: nearest$2,
        distance: distance$2,
        rank: Number.MAX_SAFE_INTEGER
      };
    });
    const filtered = results.filter((v3) => v3.distance <= maxDistanceFromLine);
    const sorted = sortByNumericProperty(filtered, `distance`);
    for (let rank2 = 0; rank2 < sorted.length; rank2++) sorted[rank2].rank = rank2;
    return sorted;
  };
  return checkUnordered;
};
var circle_packing_exports2 = {};
__export(circle_packing_exports2, { random: () => random2 });
var random2 = (circles, container, opts = {}) => {
  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);
  const attempts = opts.attempts ?? 2e3;
  const sorted = sortByNumericProperty(circles, `radius`);
  const positionedCircles = [];
  const willHit = (b3, radius) => positionedCircles.some((v3) => isIntersecting2(v3, b3, radius));
  while (sorted.length > 0) {
    const circle3 = sorted.pop();
    if (!circle3) break;
    const randomPointOpts = {
      ...opts,
      margin: {
        x: circle3.radius,
        y: circle3.radius
      }
    };
    for (let index = 0; index < attempts; index++) {
      const position = randomPoint2(container, randomPointOpts);
      if (!willHit(position, circle3.radius)) {
        positionedCircles.push(Object.freeze({
          ...circle3,
          ...position
        }));
        break;
      }
    }
  }
  return positionedCircles;
};
var layout_exports2 = {};
__export(layout_exports2, { CirclePacking: () => circle_packing_exports2 });
var ellipse_exports2 = {};
__export(ellipse_exports2, { fromDegrees: () => fromDegrees2 });
var fromDegrees2 = (radiusX, radiusY, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360) => ({
  radiusX,
  radiusY,
  rotation: degreeToRadian2(rotationDeg),
  startAngle: degreeToRadian2(startAngleDeg),
  endAngle: degreeToRadian2(endAngleDeg)
});
var curve_simplification_exports2 = {};
__export(curve_simplification_exports2, {
  rdpPerpendicularDistance: () => rdpPerpendicularDistance2,
  rdpShortestDistance: () => rdpShortestDistance2
});
var rdpShortestDistance2 = (points, epsilon2 = 0.1) => {
  const firstPoint = points[0];
  const lastPoint = points.at(-1);
  if (points.length < 3) return points;
  let index = -1;
  let distribution = 0;
  for (let index_ = 1; index_ < points.length - 1; index_++) {
    const cDistribution = distanceFromPointToLine2(points[index_], firstPoint, lastPoint);
    if (cDistribution > distribution) {
      distribution = cDistribution;
      index = index_;
    }
  }
  if (distribution > epsilon2) {
    const l1 = points.slice(0, index + 1);
    const l22 = points.slice(index);
    const r1 = rdpShortestDistance2(l1, epsilon2);
    const r22 = rdpShortestDistance2(l22, epsilon2);
    const rs2 = [...r1.slice(0, -1), ...r22];
    return rs2;
  } else return [firstPoint, lastPoint];
};
var rdpPerpendicularDistance2 = (points, epsilon2 = 0.1) => {
  const firstPoint = points[0];
  const lastPoint = points.at(-1);
  if (points.length < 3) return points;
  let index = -1;
  let distribution = 0;
  for (let index_ = 1; index_ < points.length - 1; index_++) {
    const cDistribution = findPerpendicularDistance2(points[index_], firstPoint, lastPoint);
    if (cDistribution > distribution) {
      distribution = cDistribution;
      index = index_;
    }
  }
  if (distribution > epsilon2) {
    const l1 = points.slice(0, index + 1);
    const l22 = points.slice(index);
    const r1 = rdpPerpendicularDistance2(l1, epsilon2);
    const r22 = rdpPerpendicularDistance2(l22, epsilon2);
    const rs2 = [...r1.slice(0, -1), ...r22];
    return rs2;
  } else return [firstPoint, lastPoint];
};
function findPerpendicularDistance2(p3, p1, p22) {
  let result;
  let slope$1;
  let intercept;
  if (p1.x == p22.x) result = Math.abs(p3.x - p1.x);
  else {
    slope$1 = (p22.y - p1.y) / (p22.x - p1.x);
    intercept = p1.y - slope$1 * p1.x;
    result = Math.abs(slope$1 * p3.x - p3.y + intercept) / Math.sqrt(Math.pow(slope$1, 2) + 1);
  }
  return result;
}
var distanceFromPointToLine2 = (p3, index, index_) => {
  const lineLength = distance4(index, index_);
  if (lineLength == 0) return distance4(p3, index);
  const t6 = ((p3.x - index.x) * (index_.x - index.x) + (p3.y - index.y) * (index_.y - index.y)) / lineLength;
  if (t6 < 0) return distance4(p3, index);
  if (t6 > 1) return distance4(p3, index_);
  return distance4(p3, {
    x: index.x + t6 * (index_.x - index.x),
    y: index.y + t6 * (index_.y - index.y)
  });
};
var quad_tree_exports2 = {};
__export(quad_tree_exports2, {
  Direction: () => Direction2,
  QuadTreeNode: () => QuadTreeNode3,
  quadTree: () => quadTree2
});
var Direction2 = /* @__PURE__ */ function(Direction$1) {
  Direction$1[Direction$1["Nw"] = 0] = "Nw";
  Direction$1[Direction$1["Ne"] = 1] = "Ne";
  Direction$1[Direction$1["Sw"] = 2] = "Sw";
  Direction$1[Direction$1["Se"] = 3] = "Se";
  return Direction$1;
}({});
var quadTree2 = (bounds, initialData = [], opts = {}) => {
  const o5 = {
    maxItems: opts.maxItems ?? 4,
    maxLevels: opts.maxLevels ?? 4
  };
  const n6 = new QuadTreeNode3(void 0, bounds, 0, o5);
  for (const d3 of initialData) n6.add(d3);
  return n6;
};
var QuadTreeNode3 = class QuadTreeNode4 {
  #items = [];
  #children = [];
  #parent;
  /**
  * Constructor
  * @param boundary
  * @param level
  * @param opts
  */
  constructor(parent, boundary, level, opts) {
    this.boundary = boundary;
    this.level = level;
    this.opts = opts;
    this.#parent = parent;
  }
  getLengthChildren() {
    return this.#children.length;
  }
  *parents() {
    let n6 = this;
    while (n6.#parent !== void 0) {
      yield n6.#parent;
      n6 = n6.#parent;
    }
  }
  getParent() {
    return this.#parent;
  }
  /**
  * Iterates over immediate children
  */
  *children() {
    for (const c5 of this.#children) yield c5;
  }
  /**
  * Array of QuadTreeItem
  * @returns
  */
  getValue() {
    return this.#items;
  }
  getIdentity() {
    return this;
  }
  /**
  * Get a descendant node in a given direction
  * @param d
  * @returns
  */
  direction(d3) {
    return this.#children[d3];
  }
  /**
  * Add an item to the quadtree
  * @param p
  * @returns False if item is outside of boundary, True if item was added
  */
  add(p3) {
    if (!isIntersecting$22(this.boundary, p3)) return false;
    if (this.#children.length > 0) {
      for (const d3 of this.#children) d3.add(p3);
      return true;
    }
    this.#items.push(p3);
    if (this.#items.length > this.opts.maxItems && this.level < this.opts.maxLevels) {
      if (this.#children.length === 0) this.#subdivide();
      for (const item of this.#items) for (const d3 of this.#children) d3.add(item);
      this.#items = [];
    }
    return true;
  }
  /**
  * Returns true if point is inside node's boundary
  * @param p
  * @returns
  */
  couldHold(p3) {
    return intersectsPoint2(this.boundary, p3);
  }
  #subdivide() {
    const w3 = this.boundary.width / 2;
    const h5 = this.boundary.height / 2;
    const x3 = this.boundary.x;
    const y3 = this.boundary.y;
    const coords = fromNumbers2(x3 + w3, y3, x3, y3, x3, y3 + h5, x3 + w3, y3 + h5);
    const rects = coords.map((p3) => fromTopLeft2(p3, w3, h5));
    this.#children = rects.map((r5) => new QuadTreeNode4(this, r5, this.level + 1, this.opts));
  }
};
var surface_points_exports2 = {};
__export(surface_points_exports2, {
  circleRings: () => circleRings2,
  circleVogelSpiral: () => circleVogelSpiral2,
  sphereFibonacci: () => sphereFibonacci2
});
var cos4 = Math.cos;
var sin4 = Math.sin;
var asin2 = Math.asin;
var sqrt4 = Math.sqrt;
var pow3 = Math.pow;
var pi4 = Math.PI;
var piPi$12 = Math.PI * 2;
var goldenAngle2 = pi4 * (3 - sqrt4(5));
var goldenSection2 = (1 + sqrt4(5)) / 2;
function* circleVogelSpiral2(circle3, opts = {}) {
  const maxPoints = opts.maxPoints ?? 5e3;
  const density = opts.density ?? 0.95;
  const rotationOffset = opts.rotation ?? 0;
  const c5 = toPositioned2(circle3 ?? {
    radius: 1,
    x: 0,
    y: 0
  });
  const max4 = c5.radius;
  let spacing = c5.radius * scale(density, 0, 1, 0.3, 0.01);
  if (opts.spacing) spacing = opts.spacing;
  let radius = 0;
  let count3 = 0;
  let angle = 0;
  while (count3 < maxPoints && radius < max4) {
    radius = spacing * count3 ** 0.5;
    angle = rotationOffset + count3 * 2 * pi4 / goldenSection2;
    yield Object.freeze({
      x: c5.x + radius * cos4(angle),
      y: c5.y + radius * sin4(angle)
    });
    count3++;
  }
}
function* circleRings2(circle3, opts = {}) {
  const rings = opts.rings ?? 5;
  const c5 = toPositioned2(circle3 ?? {
    radius: 1,
    x: 0,
    y: 0
  });
  const ringR = 1 / rings;
  const rotationOffset = opts.rotation ?? 0;
  let ringCount = 1;
  yield Object.freeze({
    x: c5.x,
    y: c5.y
  });
  for (let r5 = ringR; r5 <= 1; r5 += ringR) {
    const n6 = Math.round(pi4 / asin2(1 / (2 * ringCount)));
    for (const theta of linearSpace(0, piPi$12, n6 + 1)) yield Object.freeze({
      x: c5.x + r5 * cos4(theta + rotationOffset) * c5.radius,
      y: c5.y + r5 * sin4(theta + rotationOffset) * c5.radius
    });
    ringCount++;
  }
}
function* sphereFibonacci2(samples = 100, rotationRadians = 0, sphere) {
  const offset$1 = 2 / samples;
  const s3 = sphere ?? {
    x: 0,
    y: 0,
    z: 0,
    radius: 1
  };
  for (let index = 0; index < samples; index++) {
    const y3 = index * offset$1 - 1 + offset$1 / 2;
    const r5 = sqrt4(1 - pow3(y3, 2));
    const a3 = (index + 1) % samples * goldenAngle2 + rotationRadians;
    const x3 = cos4(a3) * r5;
    const z3 = sin4(a3) * r5;
    yield Object.freeze({
      x: s3.x + x3 * s3.radius,
      y: s3.y + y3 * s3.radius,
      z: s3.z + z3 * s3.radius
    });
  }
}
var angles2 = (t6) => {
  guard2(t6);
  return [
    angleRadian2(t6.a, t6.b),
    angleRadian2(t6.b, t6.c),
    angleRadian2(t6.c, t6.a)
  ];
};
var anglesDegrees2 = (t6) => {
  guard2(t6);
  return radianToDegree2(angles2(t6));
};
var edges4 = (t6) => {
  guard2(t6);
  return joinPointsToLines2(t6.a, t6.b, t6.c, t6.a);
};
var area$32 = (t6) => {
  guard2(t6, `t`);
  const lengths$2 = edges4(t6).map((l3) => length2(l3));
  const p3 = (lengths$2[0] + lengths$2[1] + lengths$2[2]) / 2;
  return Math.sqrt(p3 * (p3 - lengths$2[0]) * (p3 - lengths$2[1]) * (p3 - lengths$2[2]));
};
var barycentricCoord2 = (t6, a3, b3) => {
  const pt2 = getPointParameter2(a3, b3);
  const ab = (x3, y3, pa2, pb) => (pa2.y - pb.y) * x3 + (pb.x - pa2.x) * y3 + pa2.x * pb.y - pb.x * pa2.y;
  const alpha = ab(pt2.x, pt2.y, t6.b, t6.c) / ab(t6.a.x, t6.a.y, t6.b, t6.c);
  const theta = ab(pt2.x, pt2.y, t6.c, t6.a) / ab(t6.b.x, t6.b.y, t6.c, t6.a);
  const gamma = ab(pt2.x, pt2.y, t6.a, t6.b) / ab(t6.c.x, t6.c.y, t6.a, t6.b);
  return {
    a: alpha,
    b: theta,
    c: gamma
  };
};
var barycentricToCartestian2 = (t6, bc) => {
  guard2(t6);
  const { a: a3, b: b3, c: c5 } = t6;
  const x3 = a3.x * bc.a + b3.x * bc.b + c5.x * bc.c;
  const y3 = a3.y * bc.a + b3.y * bc.b + c5.y * bc.c;
  if (a3.z && b3.z && c5.z) {
    const z3 = a3.z * bc.a + b3.z * bc.b + c5.z * bc.c;
    return Object.freeze({
      x: x3,
      y: y3,
      z: z3
    });
  } else return Object.freeze({
    x: x3,
    y: y3
  });
};
var bbox2 = (t6, inflation = 0) => {
  const { a: a3, b: b3, c: c5 } = t6;
  const xMin = Math.min(a3.x, b3.x, c5.x) - inflation;
  const xMax = Math.max(a3.x, b3.x, c5.x) + inflation;
  const yMin = Math.min(a3.y, b3.y, c5.y) - inflation;
  const yMax = Math.max(a3.y, b3.y, c5.y) + inflation;
  const r5 = {
    x: xMin,
    y: yMin,
    width: xMax - xMin,
    height: yMax - yMin
  };
  return r5;
};
var corners2 = (t6) => {
  guard2(t6);
  return [
    t6.a,
    t6.b,
    t6.c
  ];
};
var fromRadius2 = (origin, radius, opts = {}) => {
  resultThrow(numberTest(radius, `positive`, `radius`));
  guard$12(origin, `origin`);
  const initialAngleRadian = opts.initialAngleRadian ?? 0;
  const angles$1 = [
    initialAngleRadian,
    initialAngleRadian + piPi5 * 1 / 3,
    initialAngleRadian + piPi5 * 2 / 3
  ];
  const points = angles$1.map((a3) => toCartesian2(radius, a3, origin));
  return fromPoints2(points);
};
var fromFlatArray2 = (coords) => {
  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);
  if (coords.length !== 6) throw new Error(`coords array expected with 6 elements. Got ${coords.length}`);
  return fromPoints2(fromNumbers2(...coords));
};
var fromPoints2 = (points) => {
  if (!Array.isArray(points)) throw new Error(`points expected as array`);
  if (points.length !== 3) throw new Error(`points array expected with 3 elements. Got ${points.length}`);
  const t6 = {
    a: points[0],
    b: points[1],
    c: points[2]
  };
  return t6;
};
var perimeter$32 = (t6) => {
  guard2(t6);
  return edges4(t6).reduce((accumulator, v3) => accumulator + length2(v3), 0);
};
var innerCircle2 = (t6) => {
  const c5 = centroid2(t6);
  const p3 = perimeter$32(t6) / 2;
  const a3 = area$32(t6);
  const radius = a3 / p3;
  return {
    radius,
    ...c5
  };
};
var intersectsPoint$12 = (t6, a3, b3) => {
  const box = bbox2(t6);
  const pt2 = getPointParameter2(a3, b3);
  if (!intersectsPoint2(box, pt2)) return false;
  const bc = barycentricCoord2(t6, pt2);
  return 0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1;
};
var lengths2 = (t6) => {
  guard2(t6);
  return [
    distance4(t6.a, t6.b),
    distance4(t6.b, t6.c),
    distance4(t6.c, t6.a)
  ];
};
var isEquilateral2 = (t6) => {
  guard2(t6);
  const [a3, b3, c5] = lengths2(t6);
  return a3 === b3 && b3 === c5;
};
var isIsosceles2 = (t6) => {
  const [a3, b3, c5] = lengths2(t6);
  if (a3 === b3) return true;
  if (b3 === c5) return true;
  if (c5 === a3) return true;
  return false;
};
var isRightAngle2 = (t6) => angles2(t6).includes(Math.PI / 2);
var isOblique2 = (t6) => !isRightAngle2(t6);
var isAcute2 = (t6) => !angles2(t6).some((v3) => v3 >= Math.PI / 2);
var isObtuse2 = (t6) => angles2(t6).some((v3) => v3 > Math.PI / 2);
var apply2 = (t6, fn2) => Object.freeze({
  ...t6,
  a: fn2(t6.a, `a`),
  b: fn2(t6.b, `b`),
  c: fn2(t6.c, `c`)
});
var outerCircle2 = (t6) => {
  const [a3, b3, c5] = edges4(t6).map((l3) => length2(l3));
  const cent = centroid2(t6);
  const radius = a3 * b3 * c5 / Math.sqrt((a3 + b3 + c5) * (-a3 + b3 + c5) * (a3 - b3 + c5) * (a3 + b3 - c5));
  return {
    radius,
    ...cent
  };
};
var rotate$12 = (triangle3, amountRadian, origin) => {
  if (amountRadian === void 0 || amountRadian === 0) return triangle3;
  if (origin === void 0) origin = centroid2(triangle3);
  return Object.freeze({
    ...triangle3,
    a: rotate3(triangle3.a, amountRadian, origin),
    b: rotate3(triangle3.b, amountRadian, origin),
    c: rotate3(triangle3.c, amountRadian, origin)
  });
};
var rotateByVertex2 = (triangle3, amountRadian, vertex = `b`) => {
  const origin = vertex === `a` ? triangle3.a : vertex === `b` ? triangle3.b : triangle3.c;
  return Object.freeze({
    a: rotate3(triangle3.a, amountRadian, origin),
    b: rotate3(triangle3.b, amountRadian, origin),
    c: rotate3(triangle3.c, amountRadian, origin)
  });
};
var toFlatArray2 = (t6) => {
  guard2(t6);
  return [
    t6.a.x,
    t6.a.y,
    t6.b.x,
    t6.b.y,
    t6.c.x,
    t6.c.y
  ];
};
var equilateral_exports2 = {};
__export(equilateral_exports2, {
  area: () => area$22,
  centerFromA: () => centerFromA2,
  centerFromB: () => centerFromB2,
  centerFromC: () => centerFromC2,
  circumcircle: () => circumcircle$22,
  fromCenter: () => fromCenter$12,
  height: () => height$22,
  incircle: () => incircle$22,
  perimeter: () => perimeter$22
});
var pi4over32 = Math.PI * 4 / 3;
var pi2over32 = Math.PI * 2 / 3;
var resolveLength2 = (t6) => {
  if (typeof t6 === `number`) return t6;
  return t6.length;
};
var fromCenter$12 = (t6, origin, rotationRad) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const r5 = resolveLength2(t6) / Math.sqrt(3);
  const rot = rotationRad ?? Math.PI * 1.5;
  const b3 = {
    x: r5 * Math.cos(rot) + origin.x,
    y: r5 * Math.sin(rot) + origin.y
  };
  const a3 = {
    x: r5 * Math.cos(rot + pi4over32) + origin.x,
    y: r5 * Math.sin(rot + pi4over32) + origin.y
  };
  const c5 = {
    x: r5 * Math.cos(rot + pi2over32) + origin.x,
    y: r5 * Math.sin(rot + pi2over32) + origin.y
  };
  return Object.freeze({
    a: a3,
    b: b3,
    c: c5
  });
};
var centerFromA2 = (t6, ptA) => {
  if (!ptA) ptA = Object.freeze({
    x: 0,
    y: 0
  });
  const r5 = resolveLength2(t6);
  const { radius } = incircle$22(t6);
  return {
    x: ptA.x + r5 / 2,
    y: ptA.y - radius
  };
};
var centerFromB2 = (t6, ptB) => {
  if (!ptB) ptB = Object.freeze({
    x: 0,
    y: 0
  });
  const { radius } = incircle$22(t6);
  return {
    x: ptB.x,
    y: ptB.y + radius * 2
  };
};
var centerFromC2 = (t6, ptC) => {
  if (!ptC) ptC = Object.freeze({
    x: 0,
    y: 0
  });
  const r5 = resolveLength2(t6);
  const { radius } = incircle$22(t6);
  return {
    x: ptC.x - r5 / 2,
    y: ptC.y - radius
  };
};
var height$22 = (t6) => Math.sqrt(3) / 2 * resolveLength2(t6);
var perimeter$22 = (t6) => resolveLength2(t6) * 3;
var area$22 = (t6) => Math.pow(resolveLength2(t6), 2) * Math.sqrt(3) / 4;
var circumcircle$22 = (t6) => ({ radius: Math.sqrt(3) / 3 * resolveLength2(t6) });
var incircle$22 = (t6) => ({ radius: Math.sqrt(3) / 6 * resolveLength2(t6) });
var right_exports2 = {};
__export(right_exports2, {
  adjacentFromHypotenuse: () => adjacentFromHypotenuse2,
  adjacentFromOpposite: () => adjacentFromOpposite2,
  angleAtPointA: () => angleAtPointA2,
  angleAtPointB: () => angleAtPointB2,
  area: () => area$12,
  circumcircle: () => circumcircle$12,
  fromA: () => fromA$12,
  fromB: () => fromB$12,
  fromC: () => fromC$12,
  height: () => height$12,
  hypotenuseFromAdjacent: () => hypotenuseFromAdjacent2,
  hypotenuseFromOpposite: () => hypotenuseFromOpposite2,
  hypotenuseSegments: () => hypotenuseSegments2,
  incircle: () => incircle$12,
  medians: () => medians$12,
  oppositeFromAdjacent: () => oppositeFromAdjacent2,
  oppositeFromHypotenuse: () => oppositeFromHypotenuse2,
  perimeter: () => perimeter$12,
  resolveLengths: () => resolveLengths2
});
var fromA$12 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const tt2 = resolveLengths2(t6);
  const seg = hypotenuseSegments2(t6);
  const h5 = height$12(t6);
  const a3 = {
    x: origin.x,
    y: origin.y
  };
  const b3 = {
    x: origin.x + tt2.hypotenuse,
    y: origin.y
  };
  const c5 = {
    x: origin.x + seg[1],
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromB$12 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const tt2 = resolveLengths2(t6);
  const seg = hypotenuseSegments2(t6);
  const h5 = height$12(t6);
  const b3 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - tt2.hypotenuse,
    y: origin.y
  };
  const c5 = {
    x: origin.x - seg[0],
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromC$12 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const seg = hypotenuseSegments2(t6);
  const h5 = height$12(t6);
  const c5 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - seg[1],
    y: origin.y + h5
  };
  const b3 = {
    x: origin.x + seg[0],
    y: origin.y + h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var resolveLengths2 = (t6) => {
  const a3 = t6.adjacent;
  const o5 = t6.opposite;
  const h5 = t6.hypotenuse;
  if (a3 !== void 0 && o5 !== void 0) return {
    ...t6,
    adjacent: a3,
    opposite: o5,
    hypotenuse: Math.hypot(a3, o5)
  };
  else if (a3 && h5) return {
    ...t6,
    adjacent: a3,
    hypotenuse: h5,
    opposite: h5 * h5 - a3 * a3
  };
  else if (o5 && h5) return {
    ...t6,
    hypotenuse: h5,
    opposite: o5,
    adjacent: h5 * h5 - o5 * o5
  };
  else if (t6.opposite && t6.hypotenuse && t6.adjacent) return t6;
  throw new Error(`Missing at least two edges`);
};
var height$12 = (t6) => {
  const tt2 = resolveLengths2(t6);
  const p3 = tt2.opposite * tt2.opposite / tt2.hypotenuse;
  const q3 = tt2.adjacent * tt2.adjacent / tt2.hypotenuse;
  return Math.sqrt(p3 * q3);
};
var hypotenuseSegments2 = (t6) => {
  const tt2 = resolveLengths2(t6);
  const p3 = tt2.opposite * tt2.opposite / tt2.hypotenuse;
  const q3 = tt2.adjacent * tt2.adjacent / tt2.hypotenuse;
  return [p3, q3];
};
var perimeter$12 = (t6) => {
  const tt2 = resolveLengths2(t6);
  return tt2.adjacent + tt2.hypotenuse + tt2.opposite;
};
var area$12 = (t6) => {
  const tt2 = resolveLengths2(t6);
  return tt2.opposite * tt2.adjacent / 2;
};
var angleAtPointA2 = (t6) => {
  const tt2 = resolveLengths2(t6);
  return Math.acos((tt2.adjacent * tt2.adjacent + tt2.hypotenuse * tt2.hypotenuse - tt2.opposite * tt2.opposite) / (2 * tt2.adjacent * tt2.hypotenuse));
};
var angleAtPointB2 = (t6) => {
  const tt2 = resolveLengths2(t6);
  return Math.acos((tt2.opposite * tt2.opposite + tt2.hypotenuse * tt2.hypotenuse - tt2.adjacent * tt2.adjacent) / (2 * tt2.opposite * tt2.hypotenuse));
};
var medians$12 = (t6) => {
  const tt2 = resolveLengths2(t6);
  const b3 = tt2.adjacent * tt2.adjacent;
  const c5 = tt2.hypotenuse * tt2.hypotenuse;
  const a3 = tt2.opposite * tt2.opposite;
  return [
    Math.sqrt(2 * (b3 + c5) - a3) / 2,
    Math.sqrt(2 * (c5 + a3) - b3) / 2,
    Math.sqrt(2 * (a3 + b3) - c5) / 2
  ];
};
var circumcircle$12 = (t6) => {
  const tt2 = resolveLengths2(t6);
  return { radius: tt2.hypotenuse / 2 };
};
var incircle$12 = (t6) => {
  const tt2 = resolveLengths2(t6);
  return { radius: (tt2.adjacent + tt2.opposite - tt2.hypotenuse) / 2 };
};
var oppositeFromAdjacent2 = (angleRad, adjacent) => Math.tan(angleRad) * adjacent;
var oppositeFromHypotenuse2 = (angleRad, hypotenuse) => Math.sin(angleRad) * hypotenuse;
var adjacentFromHypotenuse2 = (angleRadian$2, hypotenuse) => Math.cos(angleRadian$2) * hypotenuse;
var adjacentFromOpposite2 = (angleRadian$2, opposite) => opposite / Math.tan(angleRadian$2);
var hypotenuseFromOpposite2 = (angleRadian$2, opposite) => opposite / Math.sin(angleRadian$2);
var hypotenuseFromAdjacent2 = (angleRadian$2, adjacent) => adjacent / Math.cos(angleRadian$2);
var isosceles_exports2 = {};
__export(isosceles_exports2, {
  apexAngle: () => apexAngle2,
  area: () => area2,
  baseAngle: () => baseAngle2,
  circumcircle: () => circumcircle2,
  fromA: () => fromA2,
  fromB: () => fromB2,
  fromC: () => fromC2,
  fromCenter: () => fromCenter2,
  height: () => height2,
  incircle: () => incircle2,
  legHeights: () => legHeights2,
  medians: () => medians2,
  perimeter: () => perimeter2
});
var baseAngle2 = (t6) => Math.acos(t6.base / (2 * t6.legs));
var apexAngle2 = (t6) => {
  const aa2 = t6.legs * t6.legs;
  const cc = t6.base * t6.base;
  return Math.acos((2 * aa2 - cc) / (2 * aa2));
};
var height2 = (t6) => {
  const aa2 = t6.legs * t6.legs;
  const cc = t6.base * t6.base;
  return Math.sqrt((4 * aa2 - cc) / 4);
};
var legHeights2 = (t6) => {
  const b3 = baseAngle2(t6);
  return t6.base * Math.sin(b3);
};
var perimeter2 = (t6) => 2 * t6.legs + t6.base;
var area2 = (t6) => {
  const h5 = height2(t6);
  return h5 * t6.base / 2;
};
var circumcircle2 = (t6) => {
  const h5 = height2(t6);
  const hh2 = h5 * h5;
  const cc = t6.base * t6.base;
  return { radius: (4 * hh2 + cc) / (8 * h5) };
};
var incircle2 = (t6) => {
  const h5 = height2(t6);
  return { radius: t6.base * h5 / (2 * t6.legs + t6.base) };
};
var medians2 = (t6) => {
  const aa2 = t6.legs * t6.legs;
  const cc = t6.base * t6.base;
  const medianAB = Math.sqrt(aa2 + 2 * cc) / 2;
  const medianC = Math.sqrt(4 * aa2 - cc) / 2;
  return [
    medianAB,
    medianAB,
    medianC
  ];
};
var fromCenter2 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height2(t6);
  const incircleR = incircle2(t6).radius;
  const verticalToApex = h5 - incircleR;
  const a3 = {
    x: origin.x - t6.base / 2,
    y: origin.y + incircleR
  };
  const b3 = {
    x: origin.x + t6.base / 2,
    y: origin.y + incircleR
  };
  const c5 = {
    x: origin.x,
    y: origin.y - verticalToApex
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromA2 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height2(t6);
  const a3 = {
    x: origin.x,
    y: origin.y
  };
  const b3 = {
    x: origin.x + t6.base,
    y: origin.y
  };
  const c5 = {
    x: origin.x + t6.base / 2,
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromB2 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height2(t6);
  const b3 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - t6.base,
    y: origin.y
  };
  const c5 = {
    x: origin.x - t6.base / 2,
    y: origin.y - h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var fromC2 = (t6, origin) => {
  if (!origin) origin = Object.freeze({
    x: 0,
    y: 0
  });
  const h5 = height2(t6);
  const c5 = {
    x: origin.x,
    y: origin.y
  };
  const a3 = {
    x: origin.x - t6.base / 2,
    y: origin.y + h5
  };
  const b3 = {
    x: origin.x + t6.base / 2,
    y: origin.y + h5
  };
  return {
    a: a3,
    b: b3,
    c: c5
  };
};
var triangle_exports2 = {};
__export(triangle_exports2, {
  Empty: () => Empty$12,
  Equilateral: () => equilateral_exports2,
  Isosceles: () => isosceles_exports2,
  Placeholder: () => Placeholder$12,
  Right: () => right_exports2,
  angles: () => angles2,
  anglesDegrees: () => anglesDegrees2,
  apply: () => apply2,
  area: () => area$32,
  barycentricCoord: () => barycentricCoord2,
  barycentricToCartestian: () => barycentricToCartestian2,
  bbox: () => bbox2,
  centroid: () => centroid2,
  corners: () => corners2,
  edges: () => edges4,
  equilateralFromVertex: () => equilateralFromVertex2,
  fromFlatArray: () => fromFlatArray2,
  fromPoints: () => fromPoints2,
  fromRadius: () => fromRadius2,
  guard: () => guard2,
  innerCircle: () => innerCircle2,
  intersectsPoint: () => intersectsPoint$12,
  isAcute: () => isAcute2,
  isEmpty: () => isEmpty$14,
  isEqual: () => isEqual$12,
  isEquilateral: () => isEquilateral2,
  isIsosceles: () => isIsosceles2,
  isOblique: () => isOblique2,
  isObtuse: () => isObtuse2,
  isPlaceholder: () => isPlaceholder$12,
  isRightAngle: () => isRightAngle2,
  isTriangle: () => isTriangle2,
  lengths: () => lengths2,
  outerCircle: () => outerCircle2,
  perimeter: () => perimeter$32,
  rotate: () => rotate$12,
  rotateByVertex: () => rotateByVertex2,
  toFlatArray: () => toFlatArray2
});

// node_modules/ixfx/bundle/random.js
var shortGuid2 = (options = {}) => {
  const source = options.source ?? Math.random;
  const firstPart = Math.trunc(source() * 46656);
  const secondPart = Math.trunc(source() * 46656);
  const firstPartString = `000${firstPart.toString(36)}`.slice(-3);
  const secondPartString = `000${secondPart.toString(36)}`.slice(-3);
  return firstPartString + secondPartString;
};

// src/mediapipe/pose-matcher.ts
var TrackedPose = class {
  constructor() {
    this.centroid = point_exports2.Empty;
    this.firstSeen = performance.now();
    this.lastSeen = performance.now();
    this.id = shortGuid2();
  }
};
var getLowest = (data, fn2) => {
  const ranked = data.map((d3) => fn2(d3));
  let index = -1;
  let score = Number.MAX_SAFE_INTEGER;
  for (let i4 = 0; i4 < ranked.length; i4++) {
    if (ranked[i4] < score) {
      score = ranked[i4];
      index = i4;
    }
  }
  if (index === -1) return void 0;
  return { data: data[index], score };
};
var PoseMatcher = class {
  constructor(opts) {
    this.tracked = [];
    this.lastPrune = 0;
    this.distanceThreshold = opts.distanceThreshold;
    this.ageThreshold = opts.maxAgeMs;
    this.log = new Log(`PoseMatcher`, opts.verbosity);
  }
  *toPoses(poses) {
    for (let i4 = 0; i4 < poses.landmarks.length; i4++) {
      yield this.toPose(poses.landmarks[i4], poses.worldLandmarks[i4]);
    }
  }
  toPose(n6, l3) {
    const c5 = point_exports2.centroid(n6[12], n6[11], n6[24], n6[23]);
    const now = performance.now();
    if (now - this.lastPrune > this.ageThreshold) {
      let pre = this.tracked.length;
      this.tracked = this.tracked.filter((d3) => {
        const age = now - d3.lastSeen;
        if (age > this.ageThreshold) return false;
        return true;
      });
      this.lastPrune = now;
      let post = this.tracked.length;
      if (post < pre) {
        this.log.debug(`Pruned: ${pre - post} expired pose(s)`);
      }
    }
    const closest = getLowest(this.tracked, (d3) => point_exports2.distance(d3.centroid, c5));
    let target;
    if (!closest || closest.score > this.distanceThreshold) {
      if (closest) {
        this.log.info(`Closest match exceeds threshold. Score: ${closest?.score} Threshold: ${this.distanceThreshold}`);
      } else {
        this.log.info(`No poses`);
      }
      target = new TrackedPose();
      this.tracked.push(target);
    } else {
      target = closest.data;
    }
    target.lastSeen = now;
    target.centroid = c5;
    return {
      poseid: target.id,
      landmarks: n6,
      world: l3
    };
  }
};

// src/mediapipe/makeModelPath.ts
var makeModelPath = (basePath, provided) => {
  if (provided.startsWith(`http`)) return provided;
  return basePath + provided;
};

// src/mediapipe/pose-detector.ts
var PoseDetector = class _PoseDetector {
  constructor(p3, opts = {}) {
    this.p = p3;
    this.opts = {
      ..._PoseDetector.defaults(),
      ...opts
    };
    this.log = new Log(`PoseDetector`, this.opts.verbosity);
    this.matcher = new PoseMatcher(this.opts.matcher);
  }
  static defaults() {
    return {
      numPoses: 5,
      minPoseDetectionConfidence: 0.3,
      minPosePresenceConfidence: 0.3,
      minTrackingConfidence: 0.3,
      outputSegmentationMasks: false,
      modelPath: "pose_landmarker_full.task",
      verbosity: `errors`,
      matcher: {
        distanceThreshold: 0.1,
        maxAgeMs: 2e3,
        verbosity: `errors`
      }
    };
  }
  compute(v3, callback, timestamp2) {
    this.lp?.detectForVideo(v3, timestamp2, (poses) => {
      const matched = [...this.matcher.toPoses(poses)];
      callback(matched);
    });
  }
  async init() {
    const p3 = this.p;
    const v3 = await Xo.forVisionTasks(p3.wasmBase);
    const opts = this.opts;
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p3.modelsBase, opts.modelPath),
        delegate: `GPU`
      },
      runningMode: `VIDEO`,
      numPoses: opts.numPoses,
      minPoseDetectionConfidence: opts.minPoseDetectionConfidence,
      minPosePresenceConfidence: opts.minPosePresenceConfidence,
      minTrackingConfidence: opts.minTrackingConfidence,
      outputSegmentationMasks: opts.outputSegmentationMasks
    };
    this.log.info(mpOpts);
    this.lp = await hc.createFromOptions(v3, mpOpts);
    return true;
  }
  set minPoseDetectionConfidence(value3) {
    this.opts = {
      ...this.opts,
      minPoseDetectionConfidence: value3
    };
    this.lp?.setOptions({ minPoseDetectionConfidence: value3 });
  }
  get minPoseDetectionConfidence() {
    return this.opts.minPoseDetectionConfidence;
  }
  set minPosePresenceConfidence(value3) {
    this.opts = {
      ...this.opts,
      minPosePresenceConfidence: value3
    };
    this.lp?.setOptions({ minPosePresenceConfidence: value3 });
  }
  get minPosePresenceConfidence() {
    return this.opts.minPosePresenceConfidence;
  }
  set minTrackingConfidence(value3) {
    this.opts = {
      ...this.opts,
      minTrackingConfidence: value3
    };
    this.lp?.setOptions({ minTrackingConfidence: value3 });
  }
  get minTrackingConfidence() {
    return this.opts.minTrackingConfidence;
  }
  set numPoses(value3) {
    this.opts = {
      ...this.opts,
      numPoses: value3
    };
    this.lp?.setOptions({ numPoses: value3 });
  }
  get numPoses() {
    return this.opts.numPoses;
  }
  dispose() {
    this.lp?.close();
    this.lp = void 0;
  }
};

// src/mediapipe/object-detector.ts
var ObjectDetector = class _ObjectDetector {
  constructor(p3, options = {}) {
    this.p = p3;
    this.opts = {
      ..._ObjectDetector.defaults(),
      ...options
    };
    this.log = new Log(`ObjectDetector`, this.opts.verbosity);
  }
  static defaults() {
    return {
      verbosity: `errors`,
      modelPath: "efficientdet_lite0.tflite",
      scoreThreshold: 0.5
    };
  }
  compute(v3, callback, timestamp2) {
    const results = this.od?.detectForVideo(v3, timestamp2);
    callback(results);
  }
  dispose() {
    this.od?.close();
    this.od = void 0;
  }
  async init() {
    const p3 = this.p;
    const vision = await Xo.forVisionTasks(p3.wasmBase);
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p3.modelsBase, this.opts.modelPath)
      },
      scoreThreshold: 0.5,
      runningMode: `VIDEO`
    };
    this.od = await ic.createFromOptions(vision, mpOpts);
    this.log.info(mpOpts);
    return true;
  }
};

// src/mediapipe/face-detector.ts
var FaceDetector = class _FaceDetector {
  constructor(p3, options = {}) {
    this.p = p3;
    this.opts = {
      ..._FaceDetector.defaults(),
      ...options
    };
    this.log = new Log(`FaceDetector`, this.opts.verbosity);
  }
  static defaults() {
    return {
      verbosity: `errors`,
      modelPath: "blaze_face_short_range.tflite",
      minDetectionConfidence: 0.5,
      minSupressionThreshold: 0.3
    };
  }
  compute(v3, callback, timestamp2) {
    const results = this.fd?.detectForVideo(v3, timestamp2);
    callback(results);
  }
  dispose() {
    this.fd?.close();
    this.fd = void 0;
  }
  async init() {
    const opts = this.opts;
    const p3 = this.p;
    const vision = await Xo.forVisionTasks(p3.wasmBase);
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p3.modelsBase, this.opts.modelPath)
      },
      minDetectionConfidence: opts.minDetectionConfidence,
      minSuppressionThreshold: opts.minSupressionThreshold,
      runningMode: `VIDEO`
    };
    this.log.info(mpOpts);
    this.fd = await sh.createFromOptions(vision, mpOpts);
    return true;
  }
};

// src/mediapipe/hand-detector.ts
var HandDetector = class _HandDetector {
  constructor(p3, options = {}) {
    this.p = p3;
    this.opts = {
      ..._HandDetector.defaults(),
      ...options
    };
    this.log = new Log(`HandDetector`, this.opts.verbosity);
  }
  static defaults() {
    return {
      verbosity: `errors`,
      numHands: 2,
      modelPath: "hand_landmarker.task",
      minHandDetectionConfidence: 0.5,
      minHandPresenceConfidence: 0.5,
      minTrackingConfidence: 0.5
    };
  }
  compute(v3, callback, timestamp2) {
    const results = this.hd?.detectForVideo(v3, timestamp2);
    callback(results);
  }
  dispose() {
    this.hd?.close();
    this.hd = void 0;
  }
  async init() {
    const opts = this.opts;
    const p3 = this.p;
    const vision = await Xo.forVisionTasks(p3.wasmBase);
    const mpOpts = {
      baseOptions: {
        modelAssetPath: makeModelPath(p3.modelsBase, this.opts.modelPath)
      },
      minHandDetectionConfidence: opts.minHandDetectionConfidence,
      minHandPresenceConfidence: opts.minHandPresenceConfidence,
      minTrackingConfidence: opts.minTrackingConfidence,
      numHands: opts.numHands,
      runningMode: `VIDEO`
    };
    this.hd = await kh.createFromOptions(vision, mpOpts);
    this.log.info(mpOpts);
    return true;
  }
};

// src/processing.ts
var Processing = class extends EventTarget {
  constructor(mlv, opts) {
    super();
    this.mlv = mlv;
    this.#currentMode = opts.mode;
    this.wasmBase = opts.wasmBase;
    this.modelsBase = opts.modelsBase;
    this.log = new Log(`Processing`, opts.verbosity);
    this.dispatcher = mlv.dispatcher;
    this.dispatcherBound = this.dispatcher.receivedData.bind(this.dispatcher);
    this.computeFreqMs = opts.computeFreqMs;
    this.poseOptions = opts.pose ?? PoseDetector.defaults();
    this.objectDetectorOptions = opts.objects ?? ObjectDetector.defaults();
    this.faceDetectorOptions = opts.face ?? FaceDetector.defaults();
    this.handDetectorOptions = opts.hand ?? HandDetector.defaults();
  }
  #state = `stopped`;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  #updateTimer;
  #model;
  #currentMode = `face`;
  #videoEl;
  stop() {
    if (this.#state === `stopping` || this.#state === `stopped`) return;
    this.setState(`stopping`);
    this.#model?.dispose();
    this.#model = void 0;
    this.setState(`stopped`);
  }
  setMode(mode) {
    if (mode === this.currentMode) return;
    if (typeof mode !== `string`) throw new Error(`Expected string. Got: ${typeof mode}`);
    validateProcessorMode(mode);
    localStorage.setItem(`last-mode`, mode);
    const video = this.#videoEl;
    if (!video) return;
    this.stop();
    this.#currentMode = mode;
    this.start(video);
  }
  getModelOptions() {
    const modelOpts = {
      wasmBase: this.wasmBase,
      modelsBase: this.modelsBase
    };
    return modelOpts;
  }
  async start(video) {
    this.setState(`starting`);
    this.#videoEl = video;
    switch (this.#currentMode) {
      case `pose`: {
        this.log.info(this.poseOptions);
        this.#model = new PoseDetector(this.getModelOptions(), this.poseOptions);
        break;
      }
      case `objects`: {
        this.log.info(this.objectDetectorOptions);
        this.#model = new ObjectDetector(this.getModelOptions(), this.objectDetectorOptions);
        break;
      }
      case `face`: {
        this.log.info(this.faceDetectorOptions);
        this.#model = new FaceDetector(this.getModelOptions(), this.faceDetectorOptions);
        break;
      }
      case `hand`: {
        this.log.info(this.handDetectorOptions);
        this.#model = new HandDetector(this.getModelOptions(), this.handDetectorOptions);
        break;
      }
      default: {
        throw new Error(`Unsupported mode '${this.#currentMode}'. Expected: 'hand', 'pose', 'objects' or 'face'`);
      }
    }
    if (this.#model) {
      this.#model.init();
      this.setState(`started`);
    }
  }
  #run() {
    const v3 = this.#videoEl;
    if (!v3) {
      console.warn(`No video element`);
      return;
    }
    this.#model?.compute(v3, (data) => this.dispatcher.receivedData(this.#currentMode, data), performance.now());
    if (this.#state === `started`) {
      this.#updateTimer = setTimeout(() => this.#run(), this.computeFreqMs);
    }
  }
  setState(state) {
    if (this.#state === state) return;
    const prior = this.#state;
    if (state === `starting`) {
      if (prior !== `stopped` && prior !== `queued-start`) throw new Error(`Cannot start when in state: ${prior}`);
    }
    if (state === `started`) {
      if (prior !== `starting`) throw new Error(`Cannot go to 'started' when state is: ${prior}`);
    }
    this.#state = state;
    if (state === `started`) {
      this.#updateTimer = setTimeout(() => this.#run(), this.computeFreqMs);
    } else {
      if (this.#updateTimer) {
        clearTimeout(this.#updateTimer);
      }
      this.#updateTimer = 0;
    }
    this.log.debug(`State ${prior} -> ${state}`);
    this.dispatchEvent(new CustomEvent(`state`, {
      detail: {
        priorState: prior,
        newState: state
      }
    }));
  }
  get isStarted() {
    return this.#state === `started`;
  }
  get state() {
    return this.#state;
  }
  get currentMode() {
    return this.#currentMode;
  }
  get currentModel() {
    return this.#model;
  }
  get currentModelPoseDetector() {
    if (this.#currentMode !== `pose`) {
      throw new Error(`Current mode is not 'pose': ${this.#currentMode}`);
    }
    return this.#model;
  }
};

// src/util/text.ts
var snipBefore = (input, match) => {
  const pos = input.indexOf(match);
  if (pos >= 0) {
    return input.substring(0, pos);
  }
  return input;
};

// src/sources/camera-sources.ts
var CameraSources = class {
  constructor(sources) {
    this.sources = sources;
  }
  #disabled = false;
  #cameras = [];
  init() {
    this.updateDevices();
  }
  async updateDevices() {
    if (this.#disabled) return;
    if (!(`mediaDevices` in navigator)) {
      console.warn(`navigator.mediaDevices is missing -- are you running over https:// or via localhost?`);
      this.#disabled = true;
      return;
    }
    if (!("getUserMedia" in navigator.mediaDevices)) {
      this.#disabled = true;
      console.warn(`navigator.getUserMedia is missing -- are you running over https:// or via localhost?`);
      return;
    }
    await navigator.mediaDevices.getUserMedia({ video: true });
    const devices = await navigator.mediaDevices.enumerateDevices();
    this.#cameras = devices.filter((d3) => d3.kind === `videoinput`).map((d3) => ({
      id: d3.deviceId,
      kind: `camera`,
      label: snipBefore(d3.label, "(").trim()
    }));
    this.sources.notifySourceUpdated(this);
  }
  get cameras() {
    return this.#cameras;
  }
};

// src/sources/record-player.ts
var RecordPlayer = class {
  constructor(data, dispatcher) {
    this.data = data;
    this.dispatcher = dispatcher;
  }
  #timer = 0;
  async start() {
    let pos = 0;
    const mode = this.data.mode;
    const samples = this.data.samples;
    this.#timer = setInterval(() => {
      this.dispatcher.receivedData(mode, samples[pos]);
      pos++;
      if (pos >= this.data.samples.length) pos = 0;
    }, this.data.rateMs * 2);
    return true;
  }
  stop() {
    clearInterval(this.#timer);
  }
};

// src/sources/recording-sources.ts
var Recordings = class {
  constructor(sources) {
    this.sources = sources;
  }
  #store = [];
  delete(source) {
    const filtered = this.#store.filter((rd) => rd.name !== source.id);
    if (filtered.length !== this.#store.length) {
      this.#store = filtered;
      this.save();
    }
  }
  getSources() {
    return this.#store.map((r5) => ({
      id: r5.name,
      kind: `recording`,
      label: r5.name
    }));
  }
  getRecording(name) {
    return this.#store.find((r5) => r5.name === name);
  }
  add(data) {
    this.#store.push(data);
    this.save();
  }
  save() {
    localStorage.setItem(`recordings`, JSON.stringify(this.#store));
    this.sources.notifySourceUpdated(this);
  }
  init() {
    const s3 = localStorage.getItem(`recordings`);
    if (!s3) return;
    try {
      const o5 = JSON.parse(s3);
      for (const d3 of o5) {
        this.#store.push(d3);
      }
      this.sources.notifySourceUpdated(this);
    } catch (error) {
      console.error(error);
    }
  }
  promptName() {
    const formatOpts = {
      dateStyle: `short`,
      timeStyle: `short`
    };
    const defaultName = new Intl.DateTimeFormat("se-SE", formatOpts).format(Date.now()) + " recording " + this.#store.length + 1;
    const name = window.prompt(`Name for recording`, defaultName);
    return name;
  }
};

// src/sources/video-element-source.ts
var VideoElementSource = class {
  constructor(src, data, camera) {
    this.src = src;
    this.data = data;
    this.camera = camera;
  }
  async start() {
    let stream2 = void 0;
    switch (this.data.kind) {
      case "camera": {
        stream2 = await this.getMediaStream();
        this.mediaStream = stream2;
        break;
      }
      case "file": {
        stream2 = this.data.id;
        break;
      }
    }
    this.src.setVideoSource(stream2);
    if (stream2) {
      this.src.start();
      return true;
    } else {
      this.src.stop();
      return false;
    }
  }
  stop() {
    if (this.mediaStream) {
      for (const vt2 of this.mediaStream.getVideoTracks()) {
        vt2.stop();
      }
    }
    this.src.stop();
  }
  async getMediaStream() {
    if (this.data.id === `-`) return void 0;
    const c5 = getConstraints(this.data, this.camera);
    try {
      const stream2 = await navigator.mediaDevices.getUserMedia(c5);
      return stream2;
    } catch (error) {
      if (typeof error === `object`) {
        const name = error.name ?? ``;
        if (name === `OverconstrainedError`) {
          console.error(`Overconstrained error: ${error.constraint}`);
          console.error(`Constraints: ${JSON.stringify(c5)}`);
        }
      }
      throw error;
    }
  }
};
var getConstraints = (source, options) => {
  const video = {};
  if (source.id.length > 0) {
    video.deviceId = { exact: source.id };
  }
  if (options.facingMode) {
    video.facingMode = options.facingMode;
  }
  if (options.height) {
    video.height = { ideal: options.height };
  }
  if (options.width) {
    video.width = { ideal: options.width };
  }
  const constraints = {
    video
  };
  return constraints;
};

// src/sources/index.ts
var Sources = class extends EventTarget {
  constructor(cameraOptions, mlv) {
    super();
    this.mlv = mlv;
    this.log = new Log(`Sources`, mlv.log);
    this.#cameraOpts = cameraOptions;
    this.#camera = new CameraSources(this);
    this.#recordings = new Recordings(this);
  }
  #camera;
  #recordings;
  #state = `stopped`;
  #current;
  #currentData;
  #videoEl;
  #cameraOpts;
  delete(source) {
    if (source.kind !== `recording`) throw new Error(`Cannot delete type: ${source.kind}`);
    this.#recordings.delete(source);
  }
  get isStarted() {
    return this.#state === `started`;
  }
  createRecorder() {
    return new Recorder(this.#recordings, this.mlv.dispatcher);
  }
  startStop() {
    if (this.#state === `stopped`) {
      this.start();
      return true;
    } else if (this.#state === `started`) {
      this.stop();
      return false;
    } else {
      console.warn(`Cannot start/stop in state: ${this.#state}`);
      return false;
    }
  }
  kindMatch(kind) {
    if (this.#currentData) {
      if (this.#currentData.kind === kind) return true;
    }
    return false;
  }
  async start() {
    this.#setState(`starting`);
    const sourceData = this.#currentData;
    if (!sourceData) throw new Error(`Cannot start, no source data available`);
    let source;
    let videoEl = this.#videoEl;
    if (!videoEl) {
      videoEl = this.#videoEl = this.mlv.el.getVideoSource();
    }
    switch (sourceData.kind) {
      case `camera`: {
        if (!videoEl) throw new Error(`No video element`);
        source = new VideoElementSource(videoEl, sourceData, this.#cameraOpts);
        break;
      }
      case `file`: {
        if (!videoEl) throw new Error(`No video element`);
        source = new VideoElementSource(videoEl, sourceData, this.#cameraOpts);
        break;
      }
      case `recording`: {
        const rec = this.#recordings.getRecording(sourceData.id);
        if (rec) {
          source = new RecordPlayer(rec, this.mlv.dispatcher);
        } else {
          console.warn(`Could not get recording: ${sourceData.id}`);
        }
      }
    }
    this.#current = source;
    if (await source?.start()) {
      this.#setState(`started`);
    } else {
      this.#setState(`stopped`);
    }
  }
  stop() {
    const current = this.#current;
    if (current) {
      try {
        current.stop();
        this.#current = void 0;
      } catch (error) {
        console.error(error);
      }
    }
    this.#setState(`stopped`);
  }
  get cameras() {
    return this.#camera.cameras;
  }
  get recordings() {
    return this.#recordings.getSources();
  }
  init() {
    this.#camera.init();
    this.#recordings.init();
  }
  setSource(sourceData) {
    this.log.debug(`setSource: ${JSON.stringify(sourceData)}`);
    this.#currentData = sourceData;
    this.dispatchEvent(new CustomEvent(`source-change`, { detail: sourceData }));
  }
  getCurrentId() {
    if (this.#currentData) return this.#currentData.id;
    return ``;
  }
  notifySourceUpdated(source) {
    this.dispatchEvent(new CustomEvent(`updated`, {
      detail: source
    }));
    if (source === this.#camera && !this.#current) {
      const c5 = this.#camera.cameras[0];
      if (c5) {
        this.setSource(c5);
        this.start();
      }
    }
  }
  #setState(state) {
    const prior = this.#state;
    if (prior === state) return;
    this.#state = state;
    if (state === `starting` && prior !== `stopped`) throw new Error(`Cannot transition ${prior} -> ${state}`);
    this.log.debug(`state ${prior} -> ${state} (current: ${JSON.stringify(this.#currentData)})`);
    const dict = {
      priorState: prior,
      newState: state
    };
    this.dispatchEvent(new CustomEvent(`state-change`, { detail: dict }));
  }
  get currentSourceData() {
    return this.#currentData;
  }
};

// node_modules/@clinth/remote/dist/Util.js
var shortUuid = () => {
  const firstPart = Math.random() * 46656 | 0;
  const secondPart = Math.random() * 46656 | 0;
  return ("000" + firstPart.toString(36)).slice(-3) + ("000" + secondPart.toString(36)).slice(-3);
};
var elapsed = (from3) => {
  let e5 = Date.now() - from3;
  if (e5 < 1e3)
    return `${e5}ms`;
  e5 /= 1e3;
  if (e5 < 1e3)
    return `${e5}s`;
  e5 /= 60;
  if (e5 < 60)
    return `${e5}mins`;
  e5 /= 60;
  return `${e5}hrs`;
};

// node_modules/@clinth/remote/dist/BroadcasterBase.js
var BroadcasterBase = class {
  _name;
  _broadcast;
  _log;
  _state;
  constructor(_name, _broadcast, _log) {
    this._name = _name;
    this._broadcast = _broadcast;
    this._log = _log;
    this._state = `idle`;
  }
  setState(newState) {
    if (newState == this._state)
      return;
    const priorState = this._state;
    this._state = newState;
    this._log.verbose(priorState + " -> " + newState);
    this._broadcast.onBroadcasterState(priorState, newState, this);
  }
  get state() {
    return this._state;
  }
  get name() {
    return this._name;
  }
};

// node_modules/@clinth/remote/dist/util/Log.js
var Log2 = class _Log {
  _prefix;
  _level;
  constructor(_prefix, _level = `error`) {
    this._prefix = _prefix;
    this._level = _level;
  }
  static fromConfig(opts, category, prefix) {
    let l3 = opts[category];
    if (l3 === void 0) {
      const log2 = opts.log;
      if (log2 !== void 0)
        l3 = log2[category];
    }
    if (l3 === `silent` || l3 === `verbose` || `error`)
      return new _Log(prefix, l3);
    return new _Log(prefix);
  }
  warn(msg) {
    if (this._level !== `verbose`)
      return;
    console.warn(this._prefix, msg);
  }
  verbose(msg) {
    if (this._level !== `verbose`)
      return;
    console.log(this._prefix, msg);
  }
  error(msg) {
    if (this._level === `silent`)
      return;
    console.error(this._prefix, msg);
  }
};

// node_modules/@clinth/remote/dist/BcBroadcast.js
var BcBroadcast = class extends BroadcasterBase {
  _bc;
  constructor(_broadcast) {
    super(`bc`, _broadcast, Log2.fromConfig(_broadcast._manager.opts, `bc`, `BcBroadcast`));
    this._bc = new BroadcastChannel(`remote`);
    this._bc.addEventListener(`message`, (evt) => {
      try {
        const msg = JSON.parse(evt.data);
        this._log.verbose(msg);
        this._broadcast.onMessage(msg, this);
      } catch (e5) {
        console.error(e5);
      }
    });
    setTimeout(() => {
      this.setState(`open`);
    }, 500);
  }
  static isSupported() {
    return `BroadcastChannel` in self;
  }
  toString() {
    return `BcBroadcast`;
  }
  maintain() {
  }
  send(payload) {
    payload = this._broadcast._manager.validateOutgoing(payload);
    payload._channel = `bc-bc`;
    this._bc.postMessage(JSON.stringify(payload));
    return true;
  }
};

// node_modules/@clinth/remote/dist/Broadcast.js
var Broadcast = class extends EventTarget {
  _manager;
  _broadcast;
  _peerId;
  constructor(_manager) {
    super();
    this._manager = _manager;
    this._broadcast = [];
    this._peerId = _manager.peerId;
  }
  dumpToConsole() {
    console.group(`Broadcasters`);
    for (const b3 of this._broadcast) {
      console.log(b3.name + " (" + b3.state + ")");
    }
    console.groupEnd();
  }
  onBroadcasterState(priorState, newState, source) {
    this.dispatchEvent(new CustomEvent(`change`, {
      detail: { priorState, newState, source }
    }));
  }
  add(b3) {
    this._broadcast.push(b3);
  }
  send(payload) {
    payload = this._manager.validateOutgoing(payload);
    this._broadcast.forEach((b3) => b3.send(payload));
  }
  warn(msg) {
    console.log(`Broadcast`, msg);
  }
  onSessionMessageReceived(data, via, session) {
    if (typeof data === `string`)
      throw new Error(`Expected object`);
    const { _id, _kind, _from } = data;
    if (_from !== void 0)
      this._manager.peering.notifySeenPeer(_from, session);
    if (_id === void 0) {
      this.warn(`Session message received without an id. Dropping. ${JSON.stringify(data)}`);
      return;
    }
    if (!this._manager.validateIncoming(data))
      return;
    this._manager.onMessageReceived(data, via);
  }
  onMessage(data, via) {
    const { _id, _kind, _from } = data;
    if (_from !== void 0) {
      this._manager.peering.notifySeenPeer(_from, via);
    }
    if (_id === void 0) {
      this.warn(`Message received without an id. Dropping. ${JSON.stringify(data)}`);
      return;
    }
    if (!this._manager.validateIncoming(data))
      return;
    if (_kind === void 0) {
      this._manager.onBroadcastReceived(data, via);
      return;
    }
    switch (_kind) {
      case `peering-ad`:
        this._manager.peering.onAdvertReceived(data, via);
        break;
      case `peering-invite`:
        this._manager.peering.onInviteReceived(data, via);
        break;
      case `peering-reply`:
        this._manager.peering.onReply(data, via);
        break;
      default:
        this.log(`Unknown message kind: ${_kind}`);
    }
  }
  maintain() {
    const bcs = [...this._broadcast];
    bcs.forEach((b3) => b3.maintain());
  }
  log(msg) {
    console.log(`BroadcastMessageHandler`, msg);
  }
};

// node_modules/@clinth/remote/dist/LogicalNode.js
var LogicalNode = class {
  _id;
  _peering;
  _sessions;
  _state;
  _idleSince;
  _deadAfterIdleMs = 60 * 1e3;
  _log;
  constructor(_id, _peering) {
    this._id = _id;
    this._peering = _peering;
    this._sessions = [];
    this._state = `idle`;
    this._idleSince = Date.now();
    this._log = new Log2(`LogicalNode[${_id}]`, _peering.manager.opts.defaultLog ?? `error`);
  }
  send(data) {
    if (this.isDead)
      throw new Error(`Cannot send while node is dead`);
    for (const s3 of this._sessions) {
      if (s3.state === `open`) {
        console.log(`Send via ${s3.channel.name}`);
        s3.send(data);
        return true;
      }
    }
    return false;
  }
  setState(newState) {
    if (newState == this._state)
      return;
    if (this.isDead)
      throw new Error(`Node is marked dead, cannot change state`);
    const priorState = this._state;
    this._state = newState;
    if (newState === `idle`)
      this._idleSince = Date.now();
    this._peering.onLogicalNodeState(priorState, newState, this);
  }
  hasChannel(channelName) {
    return this._sessions.some((c5) => c5.channel.name === channelName);
  }
  onSessionEstablished(s3) {
    if (this.isDead)
      throw new Error(`Node is marked dead, cannot establish session`);
    this._sessions.push(s3);
    this._log.verbose(`Session established. ch: ${s3.channel.name} id: ${s3.id}. ${this._sessions.length} sesion(s)`);
    this.setState(`open`);
  }
  dump() {
    let t6 = [`LogicalNode[${this._id}]`];
    this._sessions.forEach((s3) => {
      t6.push(` - ` + s3.statusString());
    });
    return t6.join("\n");
  }
  dumpSessions() {
    let t6 = "";
    this._sessions.forEach((s3) => {
      t6 += ` - ` + s3.state + " " + s3.channel.name + " elapsed: " + s3.elapsedString() + "\n";
    });
    return t6.trim();
  }
  maintain() {
    if (this.isDead)
      return;
    const sessions = [...this._sessions];
    for (const s3 of sessions) {
      s3.maintain();
    }
    const length3 = this._sessions.length;
    this._sessions = this._sessions.filter((s3) => s3.state === `open`);
    if (this._sessions.length !== length3) {
      this._log.verbose(`Removed ${length3 - this._sessions.length} session(s).`);
    }
    if (this.sessions.length === 0)
      this.setState(`idle`);
    if (this._state === `idle`) {
      const elapsed2 = Date.now() - this._idleSince;
      if (elapsed2 > this._deadAfterIdleMs)
        this.setState(`dead`);
    }
  }
  get id() {
    return this._id;
  }
  get sessions() {
    return [...this._sessions];
  }
  get isDead() {
    return this._state === `dead`;
  }
  get state() {
    return this._state;
  }
};

// node_modules/@clinth/remote/dist/PeeringSession.js
var PeeringSession = class _PeeringSession extends EventTarget {
  id;
  weInitiated;
  remotePeer;
  channel;
  bc;
  manager;
  _state;
  _createdAt;
  constructor(id, weInitiated, remotePeer, channel, bc, manager) {
    super();
    this.id = id;
    this.weInitiated = weInitiated;
    this.remotePeer = remotePeer;
    this.channel = channel;
    this.bc = bc;
    this.manager = manager;
    this._state = `idle`;
    this._createdAt = Date.now();
  }
  onMessageReceived(data, via) {
    this.manager.broadcast.onSessionMessageReceived(data, via, this);
  }
  send(data) {
    this.dispatchEvent(new CustomEvent(`send`, { detail: { ...data } }));
    return true;
  }
  get name() {
    return `peering-session`;
  }
  statusString() {
    return `${this.state} ${this.channel.name} id: ${this.id} ${this.weInitiated ? `local` : `remote`} elapsed: ${elapsed(this._createdAt)}`;
  }
  elapsedString() {
    return elapsed(this._createdAt);
  }
  setState(newState) {
    if (this._state === newState)
      return;
    const priorState = this._state;
    this._state = newState;
    this.dispatchEvent(new CustomEvent(`change`, { detail: { priorState, newState } }));
  }
  maintain() {
    if (this._state == `started` || this._state == `idle`) {
      if (Date.now() - this._createdAt > 10 * 1e3) {
        this.setState(`timeout`);
      }
    }
  }
  get state() {
    return this._state;
  }
  onClosed(reason) {
    this.dispose();
  }
  onOpened() {
    this.setState(`open`);
    this.manager.peering.onSessionEstablished(this);
  }
  dispose() {
    this.log(`dispose`);
    this.setState(`closed`);
    this.dispatchEvent(new Event(`disposing`));
  }
  static initiate(remotePeer, channel, bc, manager) {
    const id = shortUuid();
    return new _PeeringSession(id, true, remotePeer, channel, bc, manager);
  }
  static accept(sessionId, remotePeer, channel, bc, manager) {
    return new _PeeringSession(sessionId, false, remotePeer, channel, bc, manager);
  }
  start() {
    if (this.state !== `idle`)
      throw new Error(`Can only start while idle`);
    this.channel.initiatePeering(this.remotePeer, this);
  }
  log(msg) {
    console.log(`PeeringSession`, msg);
  }
  onReply(r5, bc) {
    this.dispatchEvent(new CustomEvent(`reply`, { detail: { reply: r5, bc } }));
  }
  broadcastReply(kind, data) {
    data = {
      ...data,
      _kind: kind
    };
    this.bc.send(data);
  }
};

// node_modules/@clinth/remote/dist/util/ExpiringMap.js
var ExpiringMultiMap = class {
  expiryMs;
  _store;
  constructor(expiryMs) {
    this.expiryMs = expiryMs;
    this._store = /* @__PURE__ */ new Map();
    setTimeout(() => {
      this.maintain();
    }, Math.min(expiryMs, 30 * 1e3));
  }
  get lengthKeys() {
    const keys = [...this._store.keys()];
    return keys.length;
  }
  maintain() {
    const entries2 = [...this._store.entries()];
    const now = Date.now();
    entries2.forEach(([k3, arr]) => {
      arr = arr.filter((v3) => v3.expiresAt > now);
      if (arr.length == 0) {
        this._store.delete(k3);
      } else {
        this._store.set(k3, arr);
      }
    });
  }
  get(key) {
    const a3 = this._store.get(key);
    if (a3 === void 0)
      return [];
    return a3.map((v3) => v3.data);
  }
  *valuesForKey(key) {
    const a3 = this._store.get(key);
    if (a3 === void 0)
      return;
    for (let i4 = 0; i4 < a3.length; i4++) {
      yield a3[i4];
    }
  }
  *keys() {
    yield* this._store.keys();
  }
  *entriesRaw() {
    yield* this._store.entries();
  }
  *entries() {
    for (const e5 of this._store.entries()) {
      for (let i4 = 0; i4 < e5[1].length; i4++) {
        yield [e5[0], e5[1][i4].data];
      }
    }
  }
  dump() {
    const now = Date.now();
    const until3 = (v3) => {
      let e5 = v3 - now;
      if (e5 < 1e3)
        return `${e5}ms`;
      e5 /= 1e3;
      if (e5 < 1e3)
        return `${Math.round(e5)}s`;
      e5 /= 60;
      return `${Math.round(e5)}mins`;
    };
    let t6 = ``;
    for (const [k3, v3] of this._store.entries()) {
      t6 += `${k3} = `;
      for (let i4 = 0; i4 < v3.length; i4++) {
        t6 += v3[i4].data + " (expires in " + until3(v3[i4].expiresAt) + ") ";
      }
    }
    if (t6.length === 0)
      return `(empty)`;
    else
      return t6;
  }
  add(key, value3) {
    let a3 = this._store.get(key);
    if (a3 === void 0) {
      a3 = [];
      this._store.set(key, a3);
    }
    const existing = a3.find((v3) => v3.data === value3);
    if (existing === void 0) {
      a3.push({ data: value3, expiresAt: Date.now() + this.expiryMs });
    } else {
      existing.expiresAt = Date.now() + this.expiryMs;
    }
  }
};

// node_modules/@clinth/remote/dist/Peering.js
var Peering = class extends EventTarget {
  manager;
  _nodes;
  _inProgress;
  _ephemeral;
  _log;
  constructor(manager) {
    super();
    this.manager = manager;
    this._log = new Log2(`Peering`, manager.opts.defaultLog ?? `silent`);
    this._nodes = /* @__PURE__ */ new Map();
    this._inProgress = [];
    this._ephemeral = new ExpiringMultiMap(30 * 1e3);
  }
  getEphemeral(peerId) {
    return this._ephemeral.get(peerId);
  }
  getLogicalNode(peerId) {
    return this._nodes.get(peerId);
  }
  onLogicalNodeState(priorState, newState, node) {
    this.dispatchEvent(new CustomEvent(`logicalNodeState`, {
      detail: {
        newState,
        priorState,
        node
      }
    }));
  }
  hasChannel(channelName) {
    for (const n6 of this._nodes.values()) {
      if (n6.hasChannel(channelName))
        return true;
    }
  }
  dumpToConsole() {
    console.group(`Peering`);
    console.group(`LogicalNodes`);
    for (const n6 of this._nodes.values()) {
      let ln2 = n6.id + ` (${n6.state})
`;
      const sessions = n6.sessions;
      for (const s3 of sessions) {
        ln2 += " - " + s3.channel.name + " (" + s3.state + ") " + s3.id + "\n";
      }
      console.log(ln2);
    }
    console.groupEnd();
    if (this._inProgress.length > 0) {
      console.group("In progress");
      for (const s3 of this._inProgress) {
        console.log(s3.state + " " + s3.channel.name + " " + s3.id + " " + s3.elapsedString());
      }
      console.groupEnd();
    }
    if (this._ephemeral.lengthKeys > 0) {
      console.group("Ephemeral");
      console.log(this._ephemeral.dump());
      console.groupEnd();
    }
    console.groupEnd();
  }
  onSessionEstablished(s3) {
    const n6 = this.getOrCreate(s3.remotePeer);
    n6.onSessionEstablished(s3);
    this._inProgress = this._inProgress.filter((p3) => p3.id !== s3.id);
  }
  maintain() {
    const ip = [...this._inProgress];
    ip.forEach((i4) => {
      i4.maintain();
    });
    this._inProgress = this._inProgress.filter((i4) => i4.state === `idle` || i4.state == `open` || i4.state === `started`);
    const nodes = [...this._nodes.values()];
    nodes.forEach((n6) => {
      n6.maintain();
      if (this.manager._debugMaintain)
        console.log(n6.dump());
    });
    const dead = nodes.filter((n6) => n6.isDead);
    for (const d3 of dead) {
      this._log.verbose(`Removing dead node: ${d3.id}`);
      this.dispatchEvent(new CustomEvent(`logicalNodeRemoved`, {
        detail: {
          node: d3,
          type: `removed`
        }
      }));
      this._nodes.delete(d3.id);
    }
    if (this.manager._debugMaintain)
      console.log(this._ephemeral.dump());
  }
  getOrCreate(id) {
    let n6 = this._nodes.get(id);
    if (n6 === void 0) {
      n6 = new LogicalNode(id, this);
      this._nodes.set(id, n6);
      this.dispatchEvent(new CustomEvent(`logicalNodeAdded`, {
        detail: {
          node: n6,
          type: `added`
        }
      }));
    }
    return n6;
  }
  findPeeringSession(peerId, channel) {
    return this._inProgress.find((p3) => p3.remotePeer === peerId && p3.channel === channel);
  }
  findPeeringSessionById(session) {
    return this._inProgress.find((p3) => p3.id === session);
  }
  findPeeringSessionByRemote(remote) {
    return this._inProgress.find((p3) => p3.remotePeer === remote);
  }
  onInviteReceived(i4, bc) {
    try {
      const invitee = i4.invitee;
      if (invitee !== this.manager.peerId)
        return;
      if (this.findPeeringSessionByRemote(i4.inviter)) {
        this.warn(`Dropping invitation from a peer we have already invited: ${i4.inviter}. Our id: ${this.manager.peerId}`);
        return;
      }
      this.onAllowInvite(i4, bc);
    } catch (ex) {
      this.warn(ex);
    }
  }
  onReply(r5, bc) {
    const s3 = this.findPeeringSessionById(r5.peeringSessionId);
    if (s3 === void 0) {
      this._log.warn(`Received peering reply for unknown session  ${r5.peeringSessionId}`);
      this._log.warn(r5);
      this._log.warn(`Sessions: ` + this._inProgress.map((p3) => p3.id).join(", "));
      return;
    }
    s3.onReply(r5, bc);
  }
  onAllowInvite(i4, bc) {
    const payload = JSON.parse(i4.payload);
    const ch2 = this.manager.getChannelFactory(i4.channel);
    if (ch2 === void 0) {
      this.warn(`Received invitation for channel ${i4.channel}, but we do not support it`);
      return;
    }
    const s3 = PeeringSession.accept(i4.peeringSessionId, i4.inviter, ch2, bc, this.manager);
    this._inProgress.push(s3);
    ch2.acceptInvitation(i4, s3, bc);
  }
  warn(msg) {
    console.warn(`PeeringHandler`, msg);
  }
  notifySeenPeer(peer, bc) {
    this._ephemeral.add(peer, bc);
  }
  onAdvertReceived(pa2, bc) {
    const n6 = this.getOrCreate(pa2.peerId);
    const channels = pa2.channels.split(", ");
    this.notifySeenPeer(pa2.peerId, bc);
    channels.forEach((c5) => {
      if (c5.length === 0 || c5 === void 0)
        return;
      const ch2 = this.manager.getChannelFactory(c5);
      if (ch2 === void 0) {
        return;
      }
      if (!n6.hasChannel(c5)) {
        const inProgress = this.findPeeringSession(pa2.peerId, ch2);
        if (inProgress) {
        } else {
          const start = PeeringSession.initiate(pa2.peerId, ch2, bc, this.manager);
          this._inProgress.push(start);
          start.start();
        }
      }
    });
  }
  getLogicalNodes() {
    return [...this._nodes.values()];
  }
};

// node_modules/@clinth/remote/dist/RtcChannelFactory.js
var RtcPeeringSession = class {
  session;
  _pc;
  _log;
  _dc;
  _onDisposingH;
  _onReplyH;
  _onSendH;
  constructor(session) {
    this.session = session;
    this._pc = new RTCPeerConnection({
      iceServers: [
        { urls: ["stun:stun.services.mozilla.com"] },
        { urls: ["stun:stun.l.google.com:19302"] }
      ]
    });
    this._log = Log2.fromConfig(session.manager.opts, `rtc`, `RtcPeeringSession`);
    this._onDisposingH = this.onDisposing.bind(this);
    this._onReplyH = this.onReply.bind(this);
    this._onSendH = this.onSend.bind(this);
    session.addEventListener(`reply`, this._onReplyH);
    session.addEventListener(`disposing`, this._onDisposingH);
    session.addEventListener(`send`, this._onSendH);
  }
  onSend(evt) {
    const data = evt.detail;
    if (this._dc) {
      console.log(`RTC Sending`, data);
      this._dc.send(JSON.stringify(data));
    } else {
      this.warn(`Cannot send without data channel`);
    }
  }
  onDisposing() {
    this._log.verbose(`onDisposing`);
    this.session.removeEventListener(`reply`, this._onReplyH);
    this.session.removeEventListener(`disposing`, this._onDisposingH);
  }
  onReply(evt) {
    const { reply, bc } = evt.detail;
    const subKind = reply.sub;
    switch (subKind) {
      case `rtc-accept`:
        try {
          const descr = JSON.parse(reply.payload);
          this._pc.setRemoteDescription(descr);
        } catch (ex) {
          this.warn(ex);
        }
        break;
      case `rtc-ice`:
        try {
          const c5 = new RTCIceCandidate({
            sdpMLineIndex: reply.label,
            candidate: reply.candidate
          });
          this._pc.addIceCandidate(c5);
        } catch (ex) {
          this.warn(ex);
          this.warn(reply);
        }
        break;
      default:
        this._log.verbose(`Cannot handle reply ${subKind}`);
    }
  }
  warn(msg) {
    console.warn(`RtcPeeringSession`, msg);
  }
  async start() {
    const p3 = this._pc;
    const dc = this._pc.createDataChannel(`${this.session.remotePeer}`);
    this.setupDataChannel(dc);
    p3.addEventListener(`icecandidate`, (evt) => {
      const c5 = evt.candidate;
      if (c5 === null)
        return;
      this.session.broadcastReply(`peering-reply`, {
        sub: `rtc-ice`,
        peeringSessionId: this.session.id,
        label: c5.sdpMLineIndex,
        id: c5.sdpMid,
        candidate: c5.candidate
      });
    });
    p3.addEventListener(`close`, (evt) => {
      this._log.verbose(`channel close`);
    });
    p3.addEventListener(`error`, (evt) => {
      this._log.verbose(`channel error`);
    });
    p3.addEventListener(`open`, (evt) => {
      this._log.verbose(`channel open`);
    });
    p3.addEventListener(`message`, (evt) => {
      this._log.verbose(`channel message: ${JSON.stringify(evt)}`);
    });
    this._pc = p3;
    const o5 = await p3.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
    await p3.setLocalDescription(o5);
    const invite = {
      invitee: this.session.remotePeer,
      inviter: this.session.manager.peerId,
      channel: `rtc`,
      peeringSessionId: this.session.id,
      payload: JSON.stringify(o5)
    };
    this.session.broadcastReply(`peering-invite`, invite);
  }
  setupDataChannel(dc) {
    this._dc = dc;
    dc.addEventListener(`close`, (evt) => {
      this._log.verbose(`dc close`);
      this.session.onClosed(`data channel closed`);
    });
    dc.addEventListener(`closing`, (evt) => {
      this._log.verbose(`dc closing`);
    });
    dc.addEventListener(`error`, (evt) => {
      this._log.verbose(`dc error`);
    });
    dc.addEventListener(`message`, (evt) => {
      try {
        const o5 = JSON.parse(evt.data);
        this.session.onMessageReceived(o5, this);
      } catch (e5) {
        this._log.warn(`Could not parse: ${evt.data}`);
      }
    });
    dc.addEventListener(`open`, (evt) => {
      this._log.verbose(`dc open`);
      this.session.onOpened();
    });
  }
  acceptInvitation(i4) {
    this._log.verbose(`Accept invitation from ${i4.inviter}`);
    try {
      const payload = JSON.parse(i4.payload);
      const p3 = this._pc;
      p3.addEventListener(`datachannel`, (evt) => {
        this._log.verbose(`Data channel created!`);
        this.setupDataChannel(evt.channel);
      });
      p3.setRemoteDescription(payload);
      p3.createAnswer().then((descr) => {
        p3.setLocalDescription(descr);
        this.session.broadcastReply(`peering-reply`, {
          invitee: i4.invitee,
          sub: `rtc-accept`,
          peeringSessionId: this.session.id,
          inviter: i4.inviter,
          payload: JSON.stringify(descr)
        });
      });
    } catch (ex) {
      console.warn(ex);
    }
  }
};
var RtcChannelFactory = class {
  constructor() {
  }
  get name() {
    return `rtc`;
  }
  maintain() {
  }
  acceptInvitation(i4, session, bc) {
    const s3 = new RtcPeeringSession(session);
    s3.acceptInvitation(i4);
  }
  initiatePeering(remoteId, session) {
    const s3 = new RtcPeeringSession(session);
    s3.start();
  }
};

// node_modules/@clinth/remote/dist/util/StatusDisplay.js
var StatusDisplay = class {
  manager;
  _el;
  hue;
  constructor(manager, opts = {}) {
    this.manager = manager;
    const defaultOpacity = opts.defaultOpacity ?? 0.1;
    const updateRateMs = opts.updateRateMs ?? 5e3;
    this.hue = opts.hue ?? 90;
    const e5 = this._el = document.getElementById(`remote-status`);
    if (e5 === null)
      return;
    const styleIndicators = (el2) => {
      el2.style.display = `flex`;
      el2.style.alignItems = `center`;
    };
    const bcIndicators = document.createElement(`DIV`);
    bcIndicators.append(this.createIndicator(`ws`, `WebSockets`), this.createIndicator(`bc`, `BroadcastChannel`));
    styleIndicators(bcIndicators);
    e5.append(bcIndicators);
    const nodeIndicators = document.createElement(`DIV`);
    styleIndicators(nodeIndicators);
    e5.append(nodeIndicators);
    e5.style.background = `hsla(${this.hue}, 20%, 50%, 50%)`;
    e5.style.color = `hsl(${this.hue}, 50%, 10%)`;
    e5.style.border = `1px solid hsla(${this.hue}, 20%, 10%, 50%)`;
    e5.style.fontSize = `0.7em`;
    e5.style.position = `fixed`;
    e5.style.bottom = `0`;
    e5.style.right = `0`;
    e5.style.padding = `0.3em`;
    e5.style.opacity = defaultOpacity.toString();
    e5.addEventListener(`pointerover`, () => {
      e5.style.opacity = `1.0`;
    });
    e5.addEventListener(`pointerout`, () => {
      e5.style.opacity = defaultOpacity.toString();
    });
    e5.addEventListener(`click`, () => {
      manager.dump();
    });
    manager.broadcast.addEventListener(`change`, (evt) => {
      const { priorState, newState, source } = evt.detail;
      this.setIndicator(bcIndicators, source.name, newState === `open`, newState);
    });
    manager.peering.addEventListener(`logicalNodeState`, (evt) => {
      const { priorState, newState, node } = evt.detail;
      this.setIndicator(nodeIndicators, node.id, node.state === `open`, node.dumpSessions());
    });
    manager.peering.addEventListener(`logicalNodeAdded`, (evt) => {
      const { type, node } = evt.detail;
      nodeIndicators.append(this.createIndicator(node.id, `Node`));
    });
    manager.peering.addEventListener(`logicalNodeRemoved`, (evt) => {
      const { type, node } = evt.detail;
      const i4 = this.getIndicator(nodeIndicators, node.id);
      if (i4 !== null)
        i4.remove();
    });
    setInterval(() => {
      const nodes = this.manager.peering.getLogicalNodes();
      const seen = /* @__PURE__ */ new Set();
      for (const n6 of nodes) {
        seen.add(n6.id);
        let sessions = n6.dumpSessions();
        const eph = this.manager.peering.getEphemeral(n6.id);
        for (const e6 of eph) {
          sessions += "\nSeen on: " + e6.name + " (" + e6.state + ")";
        }
        this.setIndicator(nodeIndicators, n6.id, n6.state === `open`, sessions);
      }
      const indicators = this.getIndicators(nodeIndicators);
      for (const i4 of indicators) {
        if (!seen.has(i4.getAttribute(`data-for`))) {
          i4.remove();
        }
      }
    }, updateRateMs);
  }
  getIndicators(parent) {
    return Array.from(parent.querySelectorAll(`.remote-indicator`));
  }
  getIndicator(parent, label) {
    return parent.querySelector(`[data-for="${label}"]`);
  }
  setIndicator(parent, label, state, titleAddition = ``) {
    let el2 = this.getIndicator(parent, label);
    if (el2 === null) {
      el2 = this.createIndicator(label, titleAddition);
      parent.append(el2);
      return;
    }
    const title = el2.getAttribute(`data-title`) + ` ` + titleAddition;
    el2.title = title;
    if (state) {
      el2.style.border = `1px solid hsla(${this.hue}, 30%, 10%, 50%)`;
    } else {
      el2.style.border = ``;
    }
  }
  createIndicator(label, title = ``) {
    const ind = document.createElement(`div`);
    ind.innerText = label;
    ind.title = title;
    ind.classList.add(`remote-indicator`);
    ind.setAttribute(`data-for`, label);
    ind.style.padding = `0.3em`;
    ind.setAttribute(`data-title`, title);
    return ind;
  }
};

// node_modules/@clinth/remote/dist/util/Events.js
var Event2 = class {
  target;
  type;
  constructor(type, target) {
    this.target = target;
    this.type = type;
  }
};
var ErrorEvent = class extends Event2 {
  message;
  error;
  constructor(error, target) {
    super("error", target);
    this.message = error.message;
    this.error = error;
  }
};
var CloseEvent = class extends Event2 {
  code;
  reason;
  wasClean = true;
  constructor(code = 1e3, reason = "", target) {
    super("close", target);
    this.code = code;
    this.reason = reason;
  }
};

// node_modules/@clinth/remote/dist/ReconnectingWebsocket.js
var getGlobalWebSocket = () => {
  if (typeof WebSocket !== "undefined") {
    return WebSocket;
  }
};
var isWebSocket = (w3) => typeof w3 !== "undefined" && !!w3 && w3.CLOSING === 2;
var DEFAULT = {
  maxReconnectionDelay: 1e4,
  minReconnectionDelay: 1e3 + Math.random() * 4e3,
  minUptime: 5e3,
  reconnectionDelayGrowFactor: 1.3,
  connectionTimeout: 4e3,
  maxRetries: Infinity,
  maxEnqueuedMessages: Infinity,
  startClosed: false,
  debug: false
};
var ReconnectingWebSocket = class _ReconnectingWebSocket {
  _ws;
  _listeners = {
    error: [],
    message: [],
    open: [],
    close: []
  };
  _retryCount = -1;
  _uptimeTimeout;
  _connectTimeout;
  _shouldReconnect = true;
  _connectLock = false;
  _binaryType = "blob";
  _closeCalled = false;
  _messageQueue = [];
  _url;
  _protocols;
  _options;
  constructor(url, protocols, options = {}) {
    this._url = url;
    this._protocols = protocols;
    this._options = options;
    if (this._options.startClosed) {
      this._shouldReconnect = false;
    }
    this._connect();
  }
  static get CONNECTING() {
    return 0;
  }
  static get OPEN() {
    return 1;
  }
  static get CLOSING() {
    return 2;
  }
  static get CLOSED() {
    return 3;
  }
  get CONNECTING() {
    return _ReconnectingWebSocket.CONNECTING;
  }
  get OPEN() {
    return _ReconnectingWebSocket.OPEN;
  }
  get CLOSING() {
    return _ReconnectingWebSocket.CLOSING;
  }
  get CLOSED() {
    return _ReconnectingWebSocket.CLOSED;
  }
  get binaryType() {
    return this._ws ? this._ws.binaryType : this._binaryType;
  }
  set binaryType(value3) {
    this._binaryType = value3;
    if (this._ws) {
      this._ws.binaryType = value3;
    }
  }
  get retryCount() {
    return Math.max(this._retryCount, 0);
  }
  get bufferedAmount() {
    const bytes = this._messageQueue.reduce((acc, message) => {
      if (typeof message === "string") {
        acc += message.length;
      } else if (message instanceof Blob) {
        acc += message.size;
      } else {
        acc += message.byteLength;
      }
      return acc;
    }, 0);
    return bytes + (this._ws ? this._ws.bufferedAmount : 0);
  }
  get extensions() {
    return this._ws ? this._ws.extensions : "";
  }
  get protocol() {
    return this._ws ? this._ws.protocol : "";
  }
  get readyState() {
    if (this._ws) {
      return this._ws.readyState;
    }
    return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
  }
  get url() {
    return this._ws ? this._ws.url : "";
  }
  onclose = null;
  onerror = null;
  onmessage = null;
  onopen = null;
  close(code = 1e3, reason) {
    this._closeCalled = true;
    this._shouldReconnect = false;
    this._clearTimeouts();
    if (!this._ws) {
      this._debug("close enqueued: no ws instance");
      return;
    }
    if (this._ws.readyState === this.CLOSED) {
      this._debug("close: already closed");
      return;
    }
    this._ws.close(code, reason);
  }
  reconnect(code, reason) {
    this._shouldReconnect = true;
    this._closeCalled = false;
    this._retryCount = -1;
    if (!this._ws || this._ws.readyState === this.CLOSED) {
      this._connect();
    } else {
      this._disconnect(code, reason);
      this._connect();
    }
  }
  isReady() {
    if (this._ws && this._ws.readyState === this.OPEN)
      return true;
    return false;
  }
  send(data) {
    if (this._ws && this._ws.readyState === this.OPEN) {
      this._debug("send", data);
      this._ws.send(data);
    } else {
      const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
      if (this._messageQueue.length < maxEnqueuedMessages) {
        this._debug("enqueue", data);
        this._messageQueue.push(data);
      }
    }
  }
  addEventListener(type, listener) {
    if (this._listeners[type]) {
      this._listeners[type].push(listener);
    }
  }
  dispatchEvent(event2) {
    const listeners = this._listeners[event2.type];
    if (listeners) {
      for (const listener of listeners) {
        this._callEventListener(event2, listener);
      }
    }
    return true;
  }
  removeEventListener(type, listener) {
    if (this._listeners[type]) {
      this._listeners[type] = this._listeners[type].filter((l3) => l3 !== listener);
    }
  }
  _debug(...args) {
    if (this._options.debug) {
      console.log.apply(console, ["RWS>", ...args]);
    }
  }
  _getNextDelay() {
    const { reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor, minReconnectionDelay = DEFAULT.minReconnectionDelay, maxReconnectionDelay = DEFAULT.maxReconnectionDelay } = this._options;
    let delay3 = 0;
    if (this._retryCount > 0) {
      delay3 = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
      if (delay3 > maxReconnectionDelay) {
        delay3 = maxReconnectionDelay;
      }
    }
    this._debug("next delay", delay3);
    return delay3;
  }
  _wait() {
    return new Promise((resolve2) => {
      setTimeout(resolve2, this._getNextDelay());
    });
  }
  _getNextUrl(urlProvider) {
    if (typeof urlProvider === "string") {
      return Promise.resolve(urlProvider);
    }
    if (typeof urlProvider === "function") {
      const url = urlProvider();
      if (typeof url === "string") {
        return Promise.resolve(url);
      }
      if (url.then) {
        return url;
      }
    }
    throw Error("Invalid URL");
  }
  _connect() {
    if (this._connectLock || !this._shouldReconnect) {
      return;
    }
    this._connectLock = true;
    const { maxRetries = DEFAULT.maxRetries, connectionTimeout = DEFAULT.connectionTimeout, WebSocket: WebSocket2 = getGlobalWebSocket() } = this._options;
    if (this._retryCount >= maxRetries) {
      this._debug("max retries reached", this._retryCount, ">=", maxRetries);
      return;
    }
    this._retryCount++;
    this._debug("connect", this._retryCount);
    this._removeListeners();
    if (!isWebSocket(WebSocket2)) {
      throw Error("No valid WebSocket class provided");
    }
    this._wait().then(() => this._getNextUrl(this._url)).then((url) => {
      if (this._closeCalled) {
        return;
      }
      this._debug("connect", { url, protocols: this._protocols });
      this._ws = this._protocols ? new WebSocket2(url, this._protocols) : new WebSocket2(url);
      this._ws.binaryType = this._binaryType;
      this._connectLock = false;
      this._addListeners();
      this._connectTimeout = setTimeout(() => this._handleTimeout(), connectionTimeout);
    });
  }
  _handleTimeout() {
    this._debug("timeout event");
    this._handleError(new ErrorEvent(Error("TIMEOUT"), this));
  }
  _disconnect(code = 1e3, reason) {
    this._clearTimeouts();
    if (!this._ws) {
      return;
    }
    this._removeListeners();
    try {
      this._ws.close(code, reason);
      this._handleClose(new CloseEvent(code, reason, this));
    } catch (error) {
    }
  }
  _acceptOpen() {
    this._debug("accept open");
    this._retryCount = 0;
  }
  _callEventListener(event2, listener) {
    if ("handleEvent" in listener) {
      listener.handleEvent(event2);
    } else {
      listener(event2);
    }
  }
  _handleOpen = (event2) => {
    this._debug("open event");
    const { minUptime = DEFAULT.minUptime } = this._options;
    clearTimeout(this._connectTimeout);
    this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
    this._ws.binaryType = this._binaryType;
    this._messageQueue.forEach((message) => this._ws?.send(message));
    this._messageQueue = [];
    if (this.onopen) {
      this.onopen(event2);
    }
    this._listeners.open.forEach((listener) => this._callEventListener(event2, listener));
  };
  _handleMessage = (event2) => {
    this._debug("message event");
    if (this.onmessage) {
      this.onmessage(event2);
    }
    this._listeners.message.forEach((listener) => this._callEventListener(event2, listener));
  };
  _handleError = (event2) => {
    this._debug("error event", event2.message);
    this._disconnect(void 0, event2.message === "TIMEOUT" ? "timeout" : void 0);
    if (this.onerror) {
      this.onerror(event2);
    }
    this._debug("exec error listeners");
    this._listeners.error.forEach((listener) => this._callEventListener(event2, listener));
    this._connect();
  };
  _handleClose = (event2) => {
    this._debug("close event");
    this._clearTimeouts();
    if (this._shouldReconnect) {
      this._connect();
    }
    if (this.onclose) {
      this.onclose(event2);
    }
    this._listeners.close.forEach((listener) => this._callEventListener(event2, listener));
  };
  _removeListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("removeListeners");
    this._ws.removeEventListener("open", this._handleOpen);
    this._ws.removeEventListener("close", this._handleClose);
    this._ws.removeEventListener("message", this._handleMessage);
    this._ws.removeEventListener("error", this._handleError);
  }
  _addListeners() {
    if (!this._ws) {
      return;
    }
    this._debug("addListeners");
    this._ws.addEventListener("open", this._handleOpen);
    this._ws.addEventListener("close", this._handleClose);
    this._ws.addEventListener("message", this._handleMessage);
    this._ws.addEventListener("error", this._handleError);
  }
  _clearTimeouts() {
    clearTimeout(this._connectTimeout);
    clearTimeout(this._uptimeTimeout);
  }
};

// node_modules/@clinth/remote/dist/WebsocketBroadcast.js
var WebsocketBroadcast = class extends BroadcasterBase {
  _ws;
  constructor(broadcast, serverUrl) {
    super(`ws`, broadcast, Log2.fromConfig(broadcast._manager.opts, `ws`, `WebsocketBroadcast`));
    const url = serverUrl ?? (location.protocol === "http:" ? "ws://" : "wss://") + location.host + "/ws";
    this._ws = new ReconnectingWebSocket(url);
    let alrightSeenErrorThankYou = false;
    this._ws.addEventListener(`close`, (evt) => {
      this._log.verbose(`close`);
      this.setState(`closed`);
    });
    this._ws.addEventListener(`error`, (evt) => {
      if (evt.message === `TIMEOUT` || alrightSeenErrorThankYou)
        return;
      this._log.warn(`error: ${evt}`);
      alrightSeenErrorThankYou = true;
      this.setState(`error`);
    });
    this._ws.addEventListener(`message`, (evt) => {
      try {
        const m4 = JSON.parse(evt.data);
        this._broadcast.onMessage(m4, this);
      } catch (e5) {
        this._log.warn(e5);
      }
    });
    this._ws.addEventListener(`open`, (evt) => {
      alrightSeenErrorThankYou = false;
      this.setState(`open`);
      this._log.verbose(`Connected to ${url}`);
    });
  }
  toString() {
    return `WebsocketBroadcast`;
  }
  maintain() {
  }
  send(payload) {
    payload = this._broadcast._manager.validateOutgoing(payload);
    payload._channel = `ws-bc`;
    this._ws.send(JSON.stringify(payload));
    return true;
  }
};

// node_modules/@clinth/remote/dist/Manager.js
var Manager = class extends EventTarget {
  opts;
  _channelFactories;
  broadcast;
  peering;
  _allowNetwork;
  _debugMaintain;
  _defaultLog;
  _statusDisplay;
  _seenIds;
  peerId;
  constructor(opts = {}) {
    super();
    this.opts = opts;
    this._seenIds = /* @__PURE__ */ new Set();
    this.peerId = opts.peerId ?? (/* @__PURE__ */ new Date()).getMilliseconds() + `-` + Math.floor(Math.random() * 100);
    this._allowNetwork = opts.allowNetwork ?? false;
    this._debugMaintain = opts.debugMaintain ?? false;
    this._defaultLog = opts.defaultLog ?? `error`;
    if (!opts.log)
      opts.log = {};
    if (!opts.log.rtc)
      opts.log.rtc = this._defaultLog;
    if (!opts.log.bc)
      opts.log.bc = this._defaultLog;
    this.log(`Id: ${this.peerId}. network allowed: ${this._allowNetwork}`);
    this.peering = new Peering(this);
    this.broadcast = new Broadcast(this);
    this._channelFactories = [];
    this._statusDisplay = new StatusDisplay(this);
    if (this._allowNetwork) {
      this.broadcast.add(new WebsocketBroadcast(this.broadcast, opts.websocket));
      this.addChannelFactory(new RtcChannelFactory());
    }
    if (BcBroadcast.isSupported()) {
      this.broadcast.add(new BcBroadcast(this.broadcast));
    } else {
      this.log(`BroadcastChannel not supported by this browser`);
    }
    const loopMs = opts.maintainLoopMs ?? 60 * 1e3 + 20 * 1e3 * Math.random();
    setInterval(() => {
      this.maintain();
    }, loopMs);
    setTimeout(() => {
      this.advertise();
    }, 5e3 * Math.random());
  }
  getChannelFactory(name) {
    return this._channelFactories.find((c5) => c5.name === name);
  }
  addChannelFactory(c5) {
    this._channelFactories.push(c5);
  }
  onBroadcastReceived(data, via) {
    this.dispatchEvent(new CustomEvent(`message`, {
      detail: data
    }));
  }
  onMessageReceived(data, via) {
    this.dispatchEvent(new CustomEvent(`message`, {
      detail: data
    }));
  }
  send(data, to3) {
    data = this.validateOutgoing(data);
    if (to3 !== void 0 && to3.length > 0) {
      data._to = to3;
      const n6 = this.peering.getLogicalNode(to3);
      if (n6 !== void 0) {
        if (n6.send(data)) {
          return;
        }
      }
      const channels = this.peering.getEphemeral(to3);
      for (const ch2 of channels) {
        if (ch2.send(data)) {
          console.log(`Sent on channel ${ch2.name}`);
          return;
        }
      }
    }
    this.broadcast.send(data);
  }
  advertise() {
    let f5 = this._channelFactories.map((f6) => f6.name);
    const ad = {
      _kind: `peering-ad`,
      peerId: this.peerId,
      channels: f5.join(", ")
    };
    this.broadcast.send({ ...ad });
  }
  validateOutgoing(payload) {
    const t6 = typeof payload;
    if (t6 === `string` || t6 === `number` || t6 === `boolean`) {
      payload = { data: payload };
    } else if (Array.isArray(payload)) {
      payload = { data: payload };
    } else if (t6 === `bigint` || t6 === `function`) {
      throw new Error(`cannot send type ${t6}`);
    }
    if (payload._id === void 0) {
      const id = shortUuid();
      payload._id = id;
      this._seenIds.add(id);
    }
    payload._from = this.peerId;
    return payload;
  }
  validateIncoming(msg) {
    if (this._seenIds.has(msg._id)) {
      return false;
    }
    this._seenIds.add(msg._id);
    return true;
  }
  maintain() {
    const seen = [...this._seenIds.values()];
    this._seenIds = new Set(seen.slice(seen.length / 2));
    this.peering.maintain();
    this.broadcast.maintain();
    const cf = [...this._channelFactories];
    cf.forEach((c5) => c5.maintain());
    this.advertise();
  }
  dump() {
    console.group(`remote`);
    console.log(`# seen msg ids: ${[...this._seenIds.values()].length}`);
    this.peering.dumpToConsole();
    this.broadcast.dumpToConsole();
    console.groupEnd();
  }
  log(msg) {
    console.log(`Remote`, msg);
  }
};

// node_modules/@clinth/remote/dist/index.js
var Remote = class {
  _manager;
  constructor(opts) {
    this._manager = new Manager(opts);
    this._manager.addEventListener(`message`, (evt) => {
      const d3 = evt.detail;
      delete d3._id;
      delete d3._channel;
      this.onData(d3);
    });
  }
  get id() {
    return this._manager.peerId;
  }
  send(data, to3) {
    this._manager.send(data, to3);
  }
  broadcast(data) {
    this._manager.broadcast.send(data);
  }
  onData(msg) {
  }
};

// src/dispatcher.ts
var Dispatcher = class extends EventTarget {
  #remote;
  constructor(options) {
    super();
    this.#remote = new Remote(options.remote);
  }
  receivedData(mode, data) {
    if (!data) return;
    if (this.#remote) {
      this.#remote.send(JSON.stringify(data));
    }
    if (this.onData) this.onData(mode, data);
    const args = { data, mode };
    this.dispatchEvent(new CustomEvent(`data`, {
      detail: args
    }));
  }
};

// src/ml-vision.ts
var defaults = (mode) => {
  const opts = {
    overlay: {
      label: true,
      show: true
    },
    camera: {
      facingMode: `user`
    },
    computeFreqMs: 10,
    mode,
    remote: {
      allowNetwork: false
    },
    verbosity: `errors`,
    wasmBase: "./wasm",
    modelsBase: "/models"
  };
  if (mode === `pose`) opts.pose = PoseDetector.defaults();
  else if (mode === `objects`) opts.objects = ObjectDetector.defaults();
  else if (mode === `face`) opts.face = FaceDetector.defaults();
  return opts;
};
var MlVision2 = class extends EventTarget {
  #overlayEl;
  #proc;
  #opts;
  constructor(elQuery, options = {}) {
    super();
    const lastMode = validateProcessorMode(localStorage.getItem(`last-mode`), `pose`);
    const opts = !options ? defaults(lastMode) : {
      ...defaults(options.mode ?? lastMode),
      ...options
    };
    this.#opts = opts;
    this.log = new Log(`MlVision`, opts.verbosity);
    const el2 = document.querySelector(elQuery);
    if (!el2) throw new Error(`VisionElement not found with query: ${elQuery}`);
    this.el = el2;
    this.sources = new Sources(opts.camera, this);
    this.dispatcher = new Dispatcher(opts);
    this.#proc = new Processing(this, opts);
    this.#proc.addEventListener(`state`, (event2) => {
      this.dispatchEvent(new CustomEvent(`processorstate`, { detail: this.#proc.state }));
    });
  }
  get processing() {
    return this.#proc;
  }
  init() {
    const el2 = this.el;
    const opts = this.#opts;
    el2.setOptions(opts);
    el2.addEventListener(`source-startstop`, (event2) => {
      const source = event2.detail;
      if (source.id !== this.sources.getCurrentId()) {
        this.log.info(`Different source. Id: ${source.id} Existing: ${this.sources.getCurrentId()}`);
        this.sources.stop();
        this.sources.setSource(source);
      }
      const started = this.sources.startStop();
    });
    el2.addEventListener(`request-source`, (event2) => {
      const detail = event2.detail;
      this.sources.stop();
      this.sources.setSource(detail);
      this.sources.start();
    });
    el2.addEventListener(`request-recorder`, () => {
      const r5 = this.sources.createRecorder();
      r5.start(this.#proc.computeFreqMs);
      el2.recorder = r5;
    });
    el2.addEventListener(`request-source-delete`, (event2) => {
      const source = event2.detail;
      this.sources.delete(source);
    });
    el2.addEventListener(`request-mode`, (event2) => {
      const req = event2.detail;
      console.log(req);
      this.#proc.setMode(validateProcessorMode(req.mode));
    });
    this.dispatcher.addEventListener(`data`, (event2) => {
      const data = event2.detail;
      el2.onReceivedData(data.mode, data.data);
    });
    this.sources.addEventListener(`updated`, () => {
      el2.onSourcesUpdated(this.sources.cameras, this.sources.recordings);
    });
    this.sources.addEventListener(`source-change`, (event2) => {
      const source = event2.detail;
      el2.notifySourceChange(source);
    });
    this.sources.addEventListener(`state-change`, (e5) => {
      const { priorState, newState } = e5.detail;
      this.log.debug(`${priorState}->${newState}`);
      if (newState === `started`) {
        const video = el2.getVideoElement();
        if (video) {
          this.#proc.stop();
          this.#proc.start(video);
        } else {
          console.warn(`Could not start processing because not video element is found`);
        }
      } else if (newState === `stopped`) {
        this.#proc.stop();
      }
      el2.notifySourceState(newState, this.sources.currentSourceData);
    });
    this.sources.init();
    if (opts.hideModelSelector) el2.hideModelSelector = opts.hideModelSelector;
  }
};

// src/client.ts
var Client = class extends EventTarget {
  #remote;
  constructor(options = {}) {
    super();
    options = {
      allowNetwork: false,
      ...options
    };
    this.#remote = new Remote(options);
    this.#remote.onData = (msg) => {
      const asObj = typeof msg === `object` ? msg : JSON.parse(msg);
      if (this.onData) this.onData(asObj);
      this.dispatchEvent(new CustomEvent(`message`, {
        detail: asObj
      }));
    };
  }
};
export {
  Client,
  MlVision2 as MlVision,
  ModelElement,
  OverlayElement,
  PoseDetector,
  PoseMatcher,
  Processing,
  RecPanel,
  VideoSourceElement,
  VisionElement,
  defaults,
  getLowest,
  getProcessorModes,
  validateProcessorMode
};
/*! Bundled license information:

@lit-labs/ssr-dom-shim/lib/element-internals.js:
  (**
   * @license
   * Copyright 2023 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/ssr-dom-shim/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/node/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/node/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@clinth/remote/dist/ReconnectingWebsocket.js:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=index.js.map