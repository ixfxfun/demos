{"version":3,"sources":["../../src/client/poses/index.ts","../../node_modules/ixfx/bundle/chunk-51aI8Tpl.js","../../node_modules/guards/dist/src/result.js","../../node_modules/guards/dist/src/numbers.js","../../node_modules/guards/dist/src/arrays.js","../../node_modules/guards/dist/src/empty.js","../../node_modules/guards/dist/src/function.js","../../node_modules/guards/dist/src/object.js","../../node_modules/guards/dist/src/range.js","../../node_modules/guards/dist/src/string.js","../../node_modules/guards/dist/src/index.js","../../node_modules/core/dist/src/is-primitive.js","../../node_modules/core/dist/src/records/circular.js","../../node_modules/core/dist/src/to-string.js","../../node_modules/core/dist/src/is-equal.js","../../node_modules/core/dist/src/iterable-compare-values-shallow.js","../../node_modules/core/dist/src/util/round.js","../../node_modules/core/dist/src/interval-type.js","../../node_modules/core/dist/src/comparers.js","../../node_modules/core/dist/src/maps.js","../../node_modules/core/dist/src/continuously.js","../../node_modules/core/dist/src/elapsed.js","../../node_modules/core/dist/src/promise-from-event.js","../../node_modules/core/dist/src/sleep.js","../../node_modules/process/dist/src/basic.js","../../node_modules/arrays/dist/src/cycle.js","../../node_modules/arrays/dist/src/at-wrap.js","../../node_modules/arrays/dist/src/chunks.js","../../node_modules/arrays/dist/src/util/to-string.js","../../node_modules/arrays/dist/src/util/is-equal.js","../../node_modules/arrays/dist/src/contains.js","../../node_modules/arrays/dist/src/ensure-length.js","../../node_modules/arrays/dist/src/equality.js","../../node_modules/arrays/dist/src/filter.js","../../node_modules/arrays/dist/src/flatten.js","../../node_modules/arrays/dist/src/for-each.js","../../node_modules/arrays/dist/src/frequency.js","../../node_modules/arrays/dist/src/group-by.js","../../node_modules/arrays/dist/src/unique.js","../../node_modules/arrays/dist/src/insert-at.js","../../node_modules/arrays/dist/src/interleave.js","../../node_modules/arrays/dist/src/intersection.js","../../node_modules/arrays/dist/src/merge-by-key.js","../../node_modules/arrays/dist/src/pairwise.js","../../node_modules/arrays/dist/src/random.js","../../node_modules/arrays/dist/src/remove.js","../../node_modules/arrays/dist/src/sample.js","../../node_modules/arrays/dist/src/sort.js","../../node_modules/arrays/dist/src/until.js","../../node_modules/arrays/dist/src/without.js","../../node_modules/arrays/dist/src/zip.js","../../node_modules/arrays/dist/src/index.js","../../node_modules/numbers/dist/src/apply-to-values.js","../../node_modules/numbers/dist/src/numeric-arrays.js","../../node_modules/numbers/dist/src/average-weighted.js","../../node_modules/numbers/dist/src/clamp.js","../../node_modules/numbers/dist/src/count.js","../../node_modules/numbers/dist/src/difference.js","../../node_modules/numbers/dist/src/guard.js","../../node_modules/numbers/dist/src/filter.js","../../node_modules/numbers/dist/src/flip.js","../../node_modules/numbers/dist/src/generate.js","../../node_modules/numbers/dist/src/round.js","../../node_modules/numbers/dist/src/is-approx.js","../../node_modules/numbers/dist/src/bipolar.js","../../node_modules/numbers/dist/src/wrap.js","../../node_modules/numbers/dist/src/pi-pi.js","../../node_modules/numbers/dist/src/interpolate.js","../../node_modules/numbers/dist/src/linear-space.js","../../node_modules/numbers/dist/src/util/queue-mutable.js","../../node_modules/numbers/dist/src/moving-average.js","../../node_modules/numbers/dist/src/scale.js","../../node_modules/numbers/dist/src/number-array-compute.js","../../node_modules/numbers/dist/src/normalise.js","../../node_modules/numbers/dist/src/proportion.js","../../node_modules/numbers/dist/src/quantise.js","../../node_modules/numbers/dist/src/range.js","../../node_modules/numbers/dist/src/softmax.js","../../node_modules/numbers/dist/src/track-simple.js","../../node_modules/numbers/dist/src/index.js","../../node_modules/core/dist/src/default-keyer.js","../../node_modules/core/dist/src/text.js","../../node_modules/iterables/dist/src/guard.js","../../node_modules/iterables/dist/src/sync/slice.js","../../node_modules/iterables/dist/src/sync/reduce.js","../../node_modules/iterables/dist/src/sync.js","../../node_modules/events/dist/src/map-of.js","../../node_modules/events/dist/src/simple-event-emitter.js","../../node_modules/events/dist/src/index.js","../../node_modules/iterables/dist/src/async.js","../../node_modules/iterables/dist/src/chain/utility.js","../../node_modules/iterables/dist/src/util/dom.js","../../node_modules/iterables/dist/src/chain/dom.js","../../node_modules/iterables/dist/src/chain/links.js","../../node_modules/iterables/dist/src/chain/from/array.js","../../node_modules/iterables/dist/src/chain/from/event.js","../../node_modules/iterables/dist/src/chain/from/function.js","../../node_modules/iterables/dist/src/chain/from/iterable.js","../../node_modules/iterables/dist/src/chain/from/ticks.js","../../node_modules/iterables/dist/src/chain/from/index.js","../../node_modules/iterables/dist/src/chain/add-to-array.js","../../node_modules/iterables/dist/src/chain/as-array.js","../../node_modules/iterables/dist/src/chain/as-callback.js","../../node_modules/iterables/dist/src/chain/as-promise.js","../../node_modules/iterables/dist/src/chain/as-value.js","../../node_modules/iterables/dist/src/chain/combine-latest-to-array.js","../../node_modules/iterables/dist/src/chain/combine-latest-to-object.js","../../node_modules/iterables/dist/src/chain/lazy.js","../../node_modules/iterables/dist/src/util/queueMutable.js","../../node_modules/iterables/dist/src/chain/merge-flat.js","../../node_modules/iterables/dist/src/chain/run.js","../../node_modules/iterables/dist/src/chain/prepare.js","../../node_modules/iterables/dist/src/chain/single.js","../../node_modules/iterables/dist/src/chain/sync.js","../../node_modules/iterables/dist/src/chain/index.js","../../node_modules/iterables/dist/src/compare-values.js","../../node_modules/iterables/dist/src/controller.js","../../node_modules/iterables/dist/src/from-event.js","../../node_modules/iterables/dist/src/numbers-compute.js","../../node_modules/iterables/dist/src/index.js","../../node_modules/core/dist/src/key-value.js","../../node_modules/core/dist/src/reactive-core.js","../../node_modules/debug/dist/src/util.js","../../node_modules/debug/dist/src/logger.js","../../node_modules/debug/dist/src/fps-counter.js","../../node_modules/debug/dist/src/error-message.js","../../node_modules/debug/dist/src/index.js","../../node_modules/core/dist/src/resolve-core.js","../../node_modules/collections/dist/src/circular-array.js","../../node_modules/collections/dist/src/queue/queue-fns.js","../../node_modules/collections/dist/src/queue/queue-mutable.js","../../node_modules/collections/dist/src/stack/StackFns.js","../../node_modules/collections/dist/src/stack/StackMutable.js","../../node_modules/collections/dist/src/tree/compare.js","../../node_modules/collections/dist/src/tree/tree-mutable.js","../../node_modules/collections/dist/src/tree/traverse-object.js","../../node_modules/collections/dist/src/tree/pathed.js","../../node_modules/collections/dist/src/tree/traversable-tree.js","../../node_modules/collections/dist/src/tree/index.js","../../node_modules/collections/dist/src/stack/StackImmutable.js","../../node_modules/collections/dist/src/stack/index.js","../../node_modules/collections/dist/src/set/set-mutable.js","../../node_modules/collections/dist/src/set/SetImmutable.js","../../node_modules/collections/dist/src/set/massive-set.js","../../node_modules/collections/dist/src/set/index.js","../../node_modules/collections/dist/src/queue/priority-mutable.js","../../node_modules/collections/dist/src/queue/queue-immutable.js","../../node_modules/collections/dist/src/queue/index.js","../../node_modules/collections/dist/src/map/expiring-map.js","../../node_modules/collections/dist/src/map/map-multi-fns.js","../../node_modules/collections/dist/src/map/map-of-simple-base.js","../../node_modules/collections/dist/src/map/map-of-simple-mutable.js","../../node_modules/collections/dist/src/map/map-immutable-fns.js","../../node_modules/collections/dist/src/map/map.js","../../node_modules/collections/dist/src/map/map-mutable.js","../../node_modules/collections/dist/src/map/map-of-multi-impl.js","../../node_modules/collections/dist/src/map/map-of-set-mutable.js","../../node_modules/collections/dist/src/map/map-of-circular-mutable.js","../../node_modules/collections/dist/src/map/number-map.js","../../node_modules/collections/dist/src/map/map-of-array-mutable.js","../../node_modules/collections/dist/src/map/map-of-simple.js","../../node_modules/collections/dist/src/map/index.js","../../node_modules/collections/dist/src/table.js","../../node_modules/collections/dist/src/graph/directed-graph.js","../../node_modules/collections/dist/src/graph/undirected-graph.js","../../node_modules/collections/dist/src/graph/index.js","../../node_modules/collections/dist/src/index.js","../../node_modules/flow/dist/src/behaviour-tree.js","../../node_modules/flow/dist/src/delay.js","../../node_modules/flow/dist/src/timeout.js","../../node_modules/flow/dist/src/debounce.js","../../node_modules/flow/dist/src/dispatch-list.js","../../node_modules/flow/dist/src/every.js","../../node_modules/flow/dist/src/execute.js","../../node_modules/flow/dist/src/event-race.js","../../node_modules/flow/dist/src/moving-average.js","../../node_modules/flow/dist/src/pool.js","../../node_modules/flow/dist/src/promise-with-resolvers.js","../../node_modules/flow/dist/src/rate-minimum.js","../../node_modules/flow/dist/src/repeat.js","../../node_modules/flow/dist/src/req-resp-match.js","../../node_modules/flow/dist/src/retry.js","../../node_modules/flow/dist/src/run-once.js","../../node_modules/flow/dist/src/sync-wait.js","../../node_modules/flow/dist/src/task-queue-mutable.js","../../node_modules/flow/dist/src/throttle.js","../../node_modules/flow/dist/src/timer.js","../../node_modules/flow/dist/src/update-outdated.js","../../node_modules/flow/dist/src/wait-for-value.js","../../node_modules/flow/dist/src/wait-for.js","../../node_modules/flow/dist/src/state-machine/state-machine.js","../../node_modules/flow/dist/src/state-machine/driver.js","../../node_modules/flow/dist/src/state-machine/with-events.js","../../node_modules/flow/dist/src/state-machine/index.js","../../node_modules/flow/dist/src/index.js","../../node_modules/random/dist/src/weighted-index.js","../../node_modules/random/dist/src/arrays.js","../../node_modules/random/dist/src/chance.js","../../node_modules/random/dist/src/float-source.js","../../node_modules/random/dist/src/non-zero.js","../../node_modules/random/dist/src/gaussian.js","../../node_modules/random/dist/src/guid.js","../../node_modules/random/dist/src/util/count.js","../../node_modules/random/dist/src/integer.js","../../node_modules/random/dist/src/seeded.js","../../node_modules/random/dist/src/string.js","../../node_modules/random/dist/src/time.js","../../node_modules/random/dist/src/util/clamp.js","../../node_modules/random/dist/src/weighted-integer.js","../../node_modules/random/dist/src/weighted.js","../../node_modules/random/dist/src/index.js","../../node_modules/trackers/dist/src/changes.js","../../node_modules/trackers/dist/src/frequency-mutable.js","../../node_modules/trackers/dist/src/tracker-base.js","../../node_modules/trackers/dist/src/primitive-tracker.js","../../node_modules/trackers/dist/src/number-tracker.js","../../node_modules/trackers/dist/src/interval-tracker.js","../../node_modules/trackers/dist/src/rate-tracker.js","../../node_modules/trackers/dist/src/object-tracker.js","../../node_modules/trackers/dist/src/tracked-value.js","../../node_modules/trackers/dist/src/index.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js","../../node_modules/geometry/src/pi.ts","../../node_modules/geometry/src/angles.ts","../../node_modules/geometry/src/point/guard.ts","../../node_modules/geometry/src/point/get-point-parameter.ts","../../node_modules/geometry/src/point/distance.ts","../../node_modules/geometry/src/point/find-minimum.ts","../../node_modules/geometry/src/rect/max.ts","../../node_modules/geometry/src/point/bbox.ts","../../node_modules/geometry/src/polar/guard.ts","../../node_modules/geometry/src/polar/angles.ts","../../node_modules/geometry/src/point/subtract.ts","../../node_modules/geometry/src/point/empty.ts","../../node_modules/geometry/src/polar/conversions.ts","../../node_modules/geometry/src/polar/math.ts","../../node_modules/geometry/src/point/point-type.ts","../../node_modules/geometry/src/point/angle.ts","../../node_modules/geometry/src/point/To.ts","../../node_modules/geometry/src/polar/ray.ts","../../node_modules/geometry/src/polar/spiral.ts","../../node_modules/geometry/src/polar/index.ts","../../node_modules/geometry/src/line/from-points.ts","../../node_modules/geometry/src/arc/index.ts","../../node_modules/geometry/src/line/guard.ts","../../node_modules/geometry/src/line/get-points-parameter.ts","../../node_modules/geometry/src/line/length.ts","../../node_modules/geometry/src/line/reverse.ts","../../node_modules/geometry/src/line/interpolate.ts","../../node_modules/geometry/src/rect/guard.ts","../../node_modules/geometry/src/rect/from-top-left.ts","../../node_modules/geometry/src/bezier/guard.ts","../../node_modules/geometry/src/bezier/index.ts","../../node_modules/geometry/src/circle/guard.ts","../../node_modules/geometry/src/circle/area.ts","../../node_modules/geometry/src/rect/from-center.ts","../../node_modules/geometry/src/circle/bbox.ts","../../node_modules/geometry/src/circle/center.ts","../../node_modules/geometry/src/circle/distance-center.ts","../../node_modules/geometry/src/circle/distance-from-exterior.ts","../../node_modules/geometry/src/circle/exterior-points.ts","../../node_modules/geometry/src/circle/interior-points.ts","../../node_modules/geometry/src/circle/perimeter.ts","../../node_modules/geometry/src/circle/interpolate.ts","../../node_modules/geometry/src/circle/is-equal.ts","../../node_modules/geometry/src/point/sum.ts","../../node_modules/geometry/src/circle/intersections.ts","../../node_modules/geometry/src/intersects.ts","../../node_modules/geometry/src/circle/is-contained-by.ts","../../node_modules/geometry/src/point/is-equal.ts","../../node_modules/geometry/src/circle/intersecting.ts","../../node_modules/geometry/src/point/multiply.ts","../../node_modules/geometry/src/circle/multiply.ts","../../node_modules/geometry/src/circle/random.ts","../../node_modules/geometry/src/circle/svg.ts","../../node_modules/geometry/src/circle/to-path.ts","../../node_modules/geometry/src/circle/to-positioned.ts","../../node_modules/geometry/src/circle/index.ts","../../node_modules/geometry/src/grid/inside.ts","../../node_modules/geometry/src/grid/guards.ts","../../node_modules/geometry/src/grid/apply-bounds.ts","../../node_modules/geometry/src/grid/array-1d.ts","../../node_modules/geometry/src/grid/array-2d.ts","../../node_modules/geometry/src/grid/values.ts","../../node_modules/geometry/src/grid/enumerators/cells.ts","../../node_modules/geometry/src/grid/as.ts","../../node_modules/geometry/src/grid/offset.ts","../../node_modules/geometry/src/grid/directions.ts","../../node_modules/geometry/src/grid/enumerators/index.ts","../../node_modules/geometry/src/grid/geometry.ts","../../node_modules/geometry/src/grid/indexing.ts","../../node_modules/geometry/src/grid/is-equal.ts","../../node_modules/geometry/src/grid/neighbour.ts","../../node_modules/geometry/src/grid/to-array.ts","../../node_modules/geometry/src/grid/to-string.ts","../../node_modules/geometry/src/grid/visual.ts","../../node_modules/geometry/src/grid/visitors/breadth.ts","../../node_modules/geometry/src/grid/visitors/cell-neighbours.ts","../../node_modules/geometry/src/grid/visitors/columns.ts","../../node_modules/geometry/src/grid/visitors/depth.ts","../../node_modules/geometry/src/grid/visitors/random.ts","../../node_modules/geometry/src/grid/visitors/random-contiguous.ts","../../node_modules/geometry/src/grid/visitors/rows.ts","../../node_modules/geometry/src/grid/visitors/visitor.ts","../../node_modules/geometry/src/grid/visitors/step.ts","../../node_modules/geometry/src/grid/visitors/index.ts","../../node_modules/geometry/src/grid/index.ts","../../node_modules/geometry/src/point/normalise-by-rect.ts","../../node_modules/geometry/src/line/nearest.ts","../../node_modules/geometry/src/line/distance-single-line.ts","../../node_modules/geometry/src/line/angles.ts","../../node_modules/geometry/src/line/bbox.ts","../../node_modules/geometry/src/point/divider.ts","../../node_modules/geometry/src/line/divide.ts","../../node_modules/geometry/src/line/from-numbers.ts","../../node_modules/geometry/src/line/from-flat-array.ts","../../node_modules/geometry/src/line/from-pivot.ts","../../node_modules/geometry/src/line/midpoint.ts","../../node_modules/geometry/src/line/relative-position.ts","../../node_modules/geometry/src/line/sum.ts","../../node_modules/geometry/src/point/abs.ts","../../node_modules/geometry/src/point/apply.ts","../../node_modules/geometry/src/point/averager.ts","../../node_modules/geometry/src/point/centroid.ts","../../node_modules/geometry/src/point/clamp.ts","../../node_modules/geometry/src/point/compare.ts","../../node_modules/geometry/src/point/convex-hull.ts","../../node_modules/geometry/src/rect/Intersects.ts","../../node_modules/geometry/src/rect/center.ts","../../node_modules/geometry/src/rect/distance.ts","../../node_modules/geometry/src/point/distance-to-center.ts","../../node_modules/geometry/src/point/distance-to-exterior.ts","../../node_modules/geometry/src/point/to-array.ts","../../node_modules/geometry/src/point/dot-product.ts","../../node_modules/geometry/src/point/from.ts","../../node_modules/geometry/src/point/interpolate.ts","../../node_modules/geometry/src/point/invert.ts","../../node_modules/geometry/src/point/magnitude.ts","../../node_modules/geometry/src/point/most.ts","../../node_modules/geometry/src/point/normalise.ts","../../node_modules/geometry/src/point/pipeline.ts","../../node_modules/geometry/src/vector.ts","../../node_modules/geometry/src/line/join-points-to-lines.ts","../../node_modules/geometry/src/point/relation.ts","../../node_modules/geometry/src/point/point-tracker.ts","../../node_modules/geometry/src/point/progress-between.ts","../../node_modules/geometry/src/point/project.ts","../../node_modules/geometry/src/point/quantise.ts","../../node_modules/geometry/src/point/random.ts","../../node_modules/geometry/src/point/reduce.ts","../../node_modules/geometry/src/point/rotate.ts","../../node_modules/geometry/src/point/rotate-point-array.ts","../../node_modules/geometry/src/point/round.ts","../../node_modules/geometry/src/point/within-range.ts","../../node_modules/geometry/src/point/wrap.ts","../../node_modules/geometry/src/point/index.ts","../../node_modules/geometry/src/line/rotate.ts","../../node_modules/geometry/src/line/is-equal.ts","../../node_modules/geometry/src/line/multiply.ts","../../node_modules/geometry/src/line/subtract.ts","../../node_modules/geometry/src/line/to-string.ts","../../node_modules/geometry/src/line/to-path.ts","../../node_modules/geometry/src/line/from-points-to-path.ts","../../node_modules/geometry/src/line/index.ts","../../node_modules/geometry/src/rect/corners.ts","../../node_modules/geometry/src/path/start-end.ts","../../node_modules/geometry/src/path/compound-path.ts","../../node_modules/geometry/src/path/index.ts","../../node_modules/geometry/src/rect/area.ts","../../node_modules/geometry/src/rect/apply.ts","../../node_modules/geometry/src/rect/cardinal.ts","../../node_modules/geometry/src/rect/center-origin.ts","../../node_modules/geometry/src/rect/divide.ts","../../node_modules/geometry/src/rect/edges.ts","../../node_modules/geometry/src/rect/empty.ts","../../node_modules/geometry/src/rect/encompass.ts","../../node_modules/geometry/src/rect/from-element.ts","../../node_modules/geometry/src/rect/from-numbers.ts","../../node_modules/geometry/src/rect/get-rect-positionedparameter.ts","../../node_modules/geometry/src/rect/is-equal.ts","../../node_modules/geometry/src/rect/lengths.ts","../../node_modules/geometry/src/rect/multiply.ts","../../node_modules/geometry/src/rect/nearest.ts","../../node_modules/geometry/src/rect/placeholder.ts","../../node_modules/geometry/src/rect/perimeter.ts","../../node_modules/geometry/src/rect/normalise-by-rect.ts","../../node_modules/geometry/src/rect/random.ts","../../node_modules/geometry/src/rect/subtract.ts","../../node_modules/geometry/src/rect/sum.ts","../../node_modules/geometry/src/rect/to-array.ts","../../node_modules/geometry/src/rect/index.ts","../../node_modules/geometry/src/triangle/create.ts","../../node_modules/geometry/src/shape/arrow.ts","../../node_modules/geometry/src/triangle/guard.ts","../../node_modules/geometry/src/triangle/centroid.ts","../../node_modules/geometry/src/shape/etc.ts","../../node_modules/geometry/src/shape/is-intersecting.ts","../../node_modules/geometry/src/shape/starburst.ts","../../node_modules/geometry/src/shape/index.ts","../../node_modules/geometry/src/waypoint.ts","../../node_modules/geometry/src/circle-packing.ts","../../node_modules/geometry/src/layout.ts","../../node_modules/geometry/src/ellipse.ts","../../node_modules/geometry/src/curve-simplification.ts","../../node_modules/geometry/src/quad-tree.ts","../../node_modules/geometry/src/scaler.ts","../../node_modules/geometry/src/surface-points.ts","../../node_modules/geometry/src/triangle/angles.ts","../../node_modules/geometry/src/triangle/edges.ts","../../node_modules/geometry/src/triangle/area.ts","../../node_modules/geometry/src/triangle/barycentric.ts","../../node_modules/geometry/src/triangle/bbox.ts","../../node_modules/geometry/src/triangle/corners.ts","../../node_modules/geometry/src/triangle/from.ts","../../node_modules/geometry/src/triangle/perimeter.ts","../../node_modules/geometry/src/triangle/inner-circle.ts","../../node_modules/geometry/src/triangle/intersects.ts","../../node_modules/geometry/src/triangle/lengths.ts","../../node_modules/geometry/src/triangle/kinds.ts","../../node_modules/geometry/src/triangle/math.ts","../../node_modules/geometry/src/triangle/outer-circle.ts","../../node_modules/geometry/src/triangle/rotate.ts","../../node_modules/geometry/src/triangle/to.ts","../../node_modules/geometry/src/triangle/equilateral.ts","../../node_modules/geometry/src/triangle/right.ts","../../node_modules/geometry/src/triangle/isosceles.ts","../../node_modules/geometry/src/triangle/index.ts","../../src/client/poses/landmarks.ts","../../src/client/poses/geometry.ts","../../node_modules/arrays/src/cycle.ts","../../node_modules/arrays/src/at-wrap.ts","../../node_modules/arrays/src/chunks.ts","../../node_modules/arrays/src/util/to-string.ts","../../node_modules/arrays/src/util/is-equal.ts","../../node_modules/arrays/src/contains.ts","../../node_modules/arrays/src/ensure-length.ts","../../node_modules/arrays/src/equality.ts","../../node_modules/arrays/src/filter.ts","../../node_modules/arrays/src/flatten.ts","../../node_modules/arrays/src/for-each.ts","../../node_modules/arrays/src/frequency.ts","../../node_modules/arrays/src/group-by.ts","../../node_modules/arrays/src/unique.ts","../../node_modules/arrays/src/insert-at.ts","../../node_modules/arrays/src/interleave.ts","../../node_modules/arrays/src/intersection.ts","../../node_modules/arrays/src/merge-by-key.ts","../../node_modules/arrays/src/pairwise.ts","../../node_modules/arrays/src/random.ts","../../node_modules/arrays/src/remove.ts","../../node_modules/arrays/src/sample.ts","../../node_modules/arrays/src/sort.ts","../../node_modules/arrays/src/until.ts","../../node_modules/arrays/src/without.ts","../../node_modules/arrays/src/zip.ts","../../node_modules/numbers/src/apply-to-values.ts","../../node_modules/numbers/src/numeric-arrays.ts","../../node_modules/numbers/src/average-weighted.ts","../../node_modules/numbers/src/clamp.ts","../../node_modules/numbers/src/count.ts","../../node_modules/numbers/src/difference.ts","../../node_modules/numbers/src/guard.ts","../../node_modules/numbers/src/filter.ts","../../node_modules/numbers/src/flip.ts","../../node_modules/numbers/src/generate.ts","../../node_modules/numbers/src/round.ts","../../node_modules/numbers/src/is-approx.ts","../../node_modules/numbers/src/bipolar.ts","../../node_modules/numbers/src/wrap.ts","../../node_modules/numbers/src/pi-pi.ts","../../node_modules/numbers/src/interpolate.ts","../../node_modules/numbers/src/linear-space.ts","../../node_modules/numbers/src/util/queue-mutable.ts","../../node_modules/numbers/src/moving-average.ts","../../node_modules/numbers/src/scale.ts","../../node_modules/numbers/src/number-array-compute.ts","../../node_modules/numbers/src/normalise.ts","../../node_modules/numbers/src/proportion.ts","../../node_modules/numbers/src/quantise.ts","../../node_modules/numbers/src/range.ts","../../node_modules/numbers/src/softmax.ts","../../node_modules/numbers/src/track-simple.ts","../../src/client/poses/pose-tracker.ts","../../src/client/poses/poses-tracker.ts","../../src/client/hands/index.ts"],"sourcesContent":["export * from './geometry.js';\nexport * from './landmarks.js';\nexport * from './pose-tracker.js';\nexport * from './poses-tracker.js';\nexport type { PoseData } from '../../types.js';","//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function() {\n\treturn mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\nexport { __commonJS, __export, __toESM };","export const getErrorMessage = (ex) => {\n    if (typeof ex === `string`)\n        return ex;\n    if (ex instanceof Error) {\n        return ex.message;\n    }\n    return ex;\n};\n/**\n * Throws an error if any result is a failure.\n * Error message will be the combined from all errors.\n * @param results\n * @returns\n */\nexport const throwIfFailed = (...results) => {\n    const failed = results.filter(r => resultIsError(r)); // as ResultError<any>[];\n    if (failed.length === 0)\n        return;\n    const messages = failed.map(f => resultErrorToString(f));\n    throw new Error(messages.join(`, `));\n};\n/**\n * If any of `results` is an error, throws it, otherwise ignored.\n * @param results\n * @returns _true_ or throws\n */\nexport function resultThrow(...results) {\n    for (const r of results) {\n        const rr = typeof r === `object` ? r : r();\n        if (rr === undefined)\n            continue;\n        if (rr.success)\n            continue;\n        throw resultToError(rr);\n    }\n    return true;\n}\nexport function resultThrowSingle(result) {\n    if (result.success)\n        return true;\n    throw resultToError(result);\n}\n/**\n * Returns the first failed result, or _undefined_ if there are no fails\n * @param results\n * @returns\n */\nexport const resultFirstFail_ = (...results) => {\n    for (const r of results) {\n        const rr = typeof r === `object` ? r : r();\n        if (rr === undefined)\n            continue;\n        if (!rr.success)\n            return rr;\n    }\n};\n/**\n * Returns _true_ if `result` is an error\n * @param result\n * @returns\n */\nexport function resultIsError(result) {\n    if (typeof result !== `object`)\n        return false;\n    return !result.success;\n}\n/**\n * Returns _true_ if `result` is OK and has a value\n * @param result\n * @returns\n */\nexport function resultIsOk(result) {\n    if (typeof result !== `object`)\n        return false;\n    return result.success;\n}\n/**\n * Gets the result as an Error\n * @param result\n * @returns\n */\nexport function resultToError(result) {\n    if (typeof result.error === `string`) {\n        throw new Error(result.error, { cause: result.info });\n    }\n    if (result.error instanceof Error)\n        throw result.error;\n    return new Error(JSON.stringify(result.error), { cause: result.info });\n}\n/**\n * Unwraps the result, returning its value if OK.\n * If not, an exception is thrown.\n * @param result\n * @returns\n */\nexport function resultToValue(result) {\n    if (resultIsOk(result)) {\n        return result.value;\n    }\n    throw resultToError(result);\n}\n/**\n * Returns the error as a string.\n * @param result\n * @returns\n */\nexport function resultErrorToString(result) {\n    if (result.error instanceof Error)\n        return getErrorMessage(result.error);\n    if (typeof result.error === `string`)\n        return result.error;\n    return JSON.stringify(result.error);\n}\n/**\n * Returns a {@link ResultError} using 'error' as the message.\n * @param error\n * @param info\n * @returns\n */\nexport function errorResult(error, info) {\n    return {\n        success: false,\n        error,\n        info\n    };\n}\n/**\n * Returns first failed result or final value.\n * @param results\n * @returns\n */\nexport const resultsCollate = (...results) => {\n    let rr;\n    for (const r of results) {\n        rr = typeof r === `object` ? r : r();\n        if (rr === undefined)\n            continue;\n        if (!rr.success)\n            return rr;\n    }\n    if (!rr)\n        throw new Error(`No results`);\n    return rr;\n};\n/**\n * If `result` is an error, calls `callback`, passing the error.\n * Otherwise does nothing\n * @param result\n * @param callback\n */\nexport const resultWithFail = (result, callback) => {\n    if (resultIsError(result)) {\n        callback(result);\n    }\n};\n","import { resultsCollate } from \"./result.js\";\n/**\n * Returns true if `x` is a power of two\n * @param x\n * @returns True if `x` is a power of two\n */\nexport const isPowerOfTwo = (x) => Math.log2(x) % 1 === 0;\n/**\n * Returns `fallback` if `v` is NaN, otherwise returns `v`.\n *\n * Throws if `v` is not a number type, null or undefined\n * @param v\n * @param fallback\n * @returns\n */\nexport const ifNaN = (v, fallback) => {\n    if (typeof v !== `number`) {\n        throw new TypeError(`v is not a number. Got: ${typeof v}`);\n    }\n    if (Number.isNaN(v))\n        return fallback;\n    return v;\n};\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n *\n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n *\n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n *\n * @param value\n * @param range\n * @param defaultValue\n * @returns\n */\nexport const integerParse = (value, range = ``, defaultValue = Number.NaN) => {\n    if (typeof value === `undefined`)\n        return defaultValue;\n    if (value === null)\n        return defaultValue;\n    try {\n        const parsed = Number.parseInt(typeof value === `number` ? value.toString() : value);\n        const r = integerTest(parsed, range, `parsed`);\n        return r.success ? parsed : defaultValue;\n    }\n    catch {\n        return defaultValue;\n    }\n};\n/**\n * Checks if `t` is not a number or within specified range.\n * Returns `[false, reason:string]` if invalid or `[true]` if valid.\n *\n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n *\n * * (empty, default): must be a number type and not NaN.\n * * finite: must be a number, not NaN and not infinite\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param parameterName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns\n */\nexport const numberTest = (value, range = ``, parameterName = `?`, info) => {\n    if (value === null)\n        return { success: false, error: `Parameter '${parameterName}' is null`, info };\n    if (typeof value === `undefined`) {\n        return { success: false, error: `Parameter '${parameterName}' is undefined`, info };\n    }\n    if (Number.isNaN(value)) {\n        return { success: false, error: `Parameter '${parameterName}' is NaN`, info };\n    }\n    if (typeof value !== `number`) {\n        return { success: false, error: `Parameter '${parameterName}' is not a number (${JSON.stringify(value)})`, info };\n    }\n    switch (range) {\n        case `finite`: {\n            if (!Number.isFinite(value)) {\n                return { success: false, error: `Parameter '${parameterName} must be finite (Got: ${value})`, info };\n            }\n            break;\n        }\n        case `positive`: {\n            if (value < 0) {\n                return { success: false, error: `Parameter '${parameterName}' must be at least zero (${value})`, info };\n            }\n            break;\n        }\n        case `negative`: {\n            if (value > 0) {\n                return { success: false, error: `Parameter '${parameterName}' must be zero or lower (${value})`, info };\n            }\n            break;\n        }\n        case `aboveZero`: {\n            if (value <= 0) {\n                return {\n                    success: false, error: `Parameter '${parameterName}' must be above zero (${value})`, info\n                };\n            }\n            break;\n        }\n        case `belowZero`: {\n            if (value >= 0) {\n                return { success: false, error: `Parameter '${parameterName}' must be below zero (${value})`, info };\n            }\n            break;\n        }\n        case `percentage`: {\n            if (value > 1 || value < 0) {\n                return {\n                    success: false, error: `Parameter '${parameterName}' must be in percentage range (0 to 1). (${value})`, info\n                };\n            }\n            break;\n        }\n        case `nonZero`: {\n            if (value === 0) {\n                return { success: false, error: `Parameter '${parameterName}' must non-zero. (${value})`, info };\n            }\n            break;\n        }\n        case `bipolar`: {\n            if (value > 1 || value < -1) {\n                return { success: false, error: `Parameter '${parameterName}' must be in bipolar percentage range (-1 to 1). (${value})`, info };\n            }\n            break;\n        }\n    }\n    return { success: true, value, info };\n};\n/**\n * Checks if `t` is not a number or within specified range.\n * Throws if invalid. Use {@link numberTest} to test without throwing.\n *\n* * (empty, default): must be a number type and not NaN.\n* * positive: must be at least zero\n* * negative: must be zero or lower\n* * aboveZero: must be above zero\n* * belowZero: must be below zero\n* * percentage: must be within 0-1, inclusive\n* * nonZero: can be anything except zero\n* * bipolar: can be -1 to 1, inclusive\n*\n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n * @param value Value to test\n * @param range Range\n * @param parameterName Name of parameter\n */\n// export const throwNumberTest = (value?: unknown,\n//   range: NumberGuardRange = ``,\n//   parameterName = `?`) => {\n//   throwFromResult(numberTest(value, range, parameterName));\n// }\n/**\n * Compares two numbers with a given number of decimal places\n * ```js\n * a: 10.123 b: 10.1    decimals: 1 = true\n * a: 10.123 b: 10.2    decimals: 0 = true\n * a: 10.123 b: 10.14   decimals: 1 = true\n * a: 10.123 b: 10.14   decimals: 2 = false\n * ``\n * @param a\n * @param b\n * @param decimals How many decimals to include\n * @returns\n */\nexport const numberDecimalTest = (a, b, decimals = 3) => {\n    if (decimals === 0) {\n        a = Math.floor(a);\n        b = Math.floor(b);\n        if (a === b)\n            return { success: true, value: a };\n        return { success: false, error: `A is not identical to B` };\n    }\n    const mult = Math.pow(10, decimals);\n    const aa = Math.floor(a * mult);\n    const bb = Math.floor(b * mult);\n    if (aa !== bb)\n        return { success: false, error: `A is not close enough to B. A: ${a} B: ${b} Decimals: ${decimals}` };\n    return { success: true, value: a };\n};\n/**\n * Returns test of `value` being in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n *\n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @returns\n */\nexport const percentTest = (value, parameterName = `?`, info) => numberTest(value, `percentage`, parameterName, info);\n// export const throwPercentTest = (value: number, parameterName = `?`) => {\n//   throwFromResult(percentTest(value, parameterName));\n//}\n/**\n * Checks if `value` an integer and meets additional criteria.\n * See {@link numberTest} for guard details, or use that if integer checking is not required.\n *\n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integerTest = (value, range = ``, parameterName = `?`) => {\n    return resultsCollate(numberTest(value, range, parameterName), () => {\n        if (!Number.isInteger(value)) {\n            return { success: false, error: `Param '${parameterName}' is not an integer` };\n        }\n        return { success: true, value: value };\n    });\n};\nexport const integerArrayTest = (numbers) => {\n    for (const v of numbers) {\n        if (Math.abs(v) % 1 !== 0)\n            return { success: false, error: `Value is not an integer: ${v}` };\n    }\n    return { success: true, value: numbers };\n};\n/**\n * Returns _true_ if `value` is an integer in number or string form\n * @param value\n * @returns\n */\nexport const isInteger = (value) => {\n    if (typeof value === `string`)\n        value = Number.parseFloat(value);\n    const r = integerTest(value);\n    return r.success;\n};\n// export const throwIntegerTest = (value: number | undefined,\n//   range: NumberGuardRange = ``,\n//   parameterName = `?`) => {\n//   throwFromResult(integerTest(value, range, parameterName));\n// }\nexport const numberInclusiveRangeTest = (value, min, max, parameterName = `?`) => {\n    if (typeof value !== `number`) {\n        return { success: false, error: `Param '${parameterName}' is not a number type. Got type: '${typeof value}' value: '${JSON.stringify(value)}'` };\n    }\n    if (Number.isNaN(value)) {\n        return { success: false, error: `Param '${parameterName}' is not within range ${min}-${max}. Got: NaN` };\n    }\n    if (Number.isFinite(value)) {\n        if (value < min) {\n            return { success: false, error: `Param '${parameterName}' is below range ${min}-${max}. Got: ${value}` };\n        }\n        else if (value > max) {\n            return { success: false, error: `Param '${parameterName}' is above range ${min}-${max}. Got: ${value}` };\n        }\n        return { success: true, value };\n    }\n    else {\n        return { success: false, error: `Param '${parameterName}' is not within range ${min}-${max}. Got: infinite` };\n    }\n};\n// export const throwNumberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`) => {\n//   const r = numberInclusiveRangeTest(value, min, max, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ]);\n// }\n","import { integerTest, numberInclusiveRangeTest } from \"./numbers.js\";\nimport { resultsCollate, resultThrow } from \"./result.js\";\n/**\n * Throws an error if parameter is not an array\n * @param value\n * @param parameterName\n */\nexport const arrayTest = (value, parameterName = `?`) => {\n    if (!Array.isArray(value)) {\n        return { success: false, error: `Parameter '${parameterName}' is expected to be an array'` };\n    }\n    return { success: true, value };\n};\n// export const throwArrayTest = (value: unknown, parameterName = `?`) => {\n//   resultThrow(arrayTest(value, parameterName));\n// }\n/**\n * Throws if `index` is an invalid array index for `array`, and if\n * `array` itself is not a valid array.\n * @param array\n * @param index\n */\nexport const arrayIndexTest = (array, index, name = `index`) => {\n    return resultsCollate(arrayTest(array), integerTest(index, `positive`, name), numberInclusiveRangeTest(index, 0, array.length - 1, name));\n};\n/**\n * Returns true if parameter is an array of strings\n * @param value\n * @returns\n */\nexport const arrayStringsTest = (value) => {\n    if (!Array.isArray(value))\n        return { success: false, error: `Value is not an array` };\n    if (value.some((v) => typeof v !== `string`)) {\n        return { success: false, error: `Contains something not a string` };\n    }\n    return { success: true, value };\n};\n// export const guardArray = <V>(array: ArrayLike<V>, name = `?`) => {\n//   if (array === undefined) {\n//     throw new TypeError(`Param '${ name }' is undefined. Expected array.`);\n//   }\n//   if (array === null) {\n//     throw new TypeError(`Param '${ name }' is null. Expected array.`);\n//   }\n//   if (!Array.isArray(array)) {\n//     throw new TypeError(`Param '${ name }' not an array as expected`);\n//   }\n// };\n","export const nullUndefTest = (value, parameterName = `?`) => {\n    if (typeof value === `undefined`) {\n        return { success: false, error: `${parameterName} param is undefined` };\n    }\n    if (value === null)\n        return { success: false, error: `${parameterName} param is null` };\n    return { success: true, value };\n};\n// export const throwNullUndef = (value: any, parameterName = `?`) => {\n//   const r = nullUndef(value, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ]);\n// }\nexport const isDefined = (argument) => argument !== undefined;\n","export const isFunction = (object) => object instanceof Function;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport const functionTest = (value, parameterName = `?`) => {\n    if (value === undefined)\n        return { success: false, error: `Param '${parameterName}' is undefined. Expected: function.` };\n    if (value === null)\n        return { success: false, error: `Param '${parameterName}' is null. Expected: function.` };\n    if (typeof value !== `function`)\n        return { success: false, error: `Param '${parameterName}' is type '${typeof value}'. Expected: function` };\n    return { success: true, value };\n};\n// export const throwFunctionTest = (value: unknown, parameterName = `?`) => {\n//   const [ ok, message ] = functionTest(value, parameterName);\n//   if (ok) return;\n//   throw new TypeError(message);\n// }\n","/**\n * Tests_if `value` is a plain object\n *\n * ```js\n * isPlainObject(`text`); // false\n * isPlainObject(document); // false\n * isPlainObject({ hello: `there` }); // true\n * ```\n * @param value\n * @returns\n */\nexport const testPlainObject = (value) => {\n    if (typeof value !== `object` || value === null)\n        return { success: false, error: `Value is null or not object type` };\n    const prototype = Object.getPrototypeOf(value);\n    const t = (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n    if (t)\n        return { success: true, value };\n    return { success: false, error: `Fancy object` };\n};\n/**\n * Tests if `value` is primitive value (bigint,number,string or boolean) or plain object\n * @param value\n * @returns\n */\nexport const testPlainObjectOrPrimitive = (value) => {\n    const t = typeof value;\n    if (t === `symbol`)\n        return { success: false, error: `Symbol type` };\n    if (t === `function`)\n        return { success: false, error: `Function type` };\n    if (t === `bigint`)\n        return { success: true, value: value };\n    if (t === `number`)\n        return { success: true, value: value };\n    if (t === `string`)\n        return { success: true, value: value };\n    if (t === `boolean`)\n        return { success: true, value: value };\n    return testPlainObject(value);\n};\n","import { integerArrayTest } from \"./numbers.js\";\nimport { resultsCollate } from \"./result.js\";\nexport const rangeIntegerTest = (v, expected) => {\n    return resultsCollate(rangeTest(v, expected), integerArrayTest(v));\n};\n/**\n * Inclusive range 4-6 = 4, 5, 6\n * Exclusive range 4-6 = 5\n *\n * @param numbers\n * @param expected\n * @returns\n */\nexport const rangeTest = (numbers, expected) => {\n    for (const v of numbers) {\n        if (expected.minExclusive !== undefined) {\n            if (v <= expected.minExclusive) {\n                return { success: false, error: `Value '${v}' must be higher than minExclusive: '${expected.minExclusive}'` };\n            }\n        }\n        if (expected.minInclusive !== undefined) {\n            if (v < expected.minInclusive) {\n                return { success: false, error: `Value '${v}' must be equal or higher than minInclusive: '${expected.minInclusive}'` };\n            }\n        }\n        if (expected.maxExclusive !== undefined) {\n            if (v >= expected.maxExclusive) {\n                return { success: false, error: `Value '${v}' must be less than maxExclusive: '${expected.maxExclusive}'` };\n            }\n        }\n        if (expected.maxInclusive !== undefined) {\n            if (v > expected.maxInclusive) {\n                return { success: false, error: `Value '${v}' must be equal or less than maxInclusive: '${expected.maxInclusive}'` };\n            }\n        }\n    }\n    return { success: true, value: numbers };\n};\n","/**\n * Throws an error if parameter is not an string\n * @param value\n * @param parameterName\n */\nexport const stringTest = (value, range = ``, parameterName = `?`) => {\n    if (typeof value !== `string`)\n        return { success: false, error: `Param '${parameterName} is not type string. Got: ${typeof value}` };\n    switch (range) {\n        case `non-empty`:\n            if (value.length === 0)\n                return { success: false, error: `Param '${parameterName} is empty` };\n            break;\n    }\n    return { success: true, value };\n};\n// export const throwStringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`) => {\n//   throwFromResult(stringTest(value, range, parameterName));\n// }\n","export * from './arrays.js';\nexport * from './empty.js';\nexport * from './function.js';\nexport * from './numbers.js';\nexport * from './object.js';\nexport * from './range.js';\nexport * from './result.js';\nexport * from './string.js';\nexport * from './types.js';\n","/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n *\n * Use {@link isPrimitiveOrObject} to also return true if `value` is an object.\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value) {\n    if (typeof value === `number`)\n        return true;\n    if (typeof value === `string`)\n        return true;\n    if (typeof value === `bigint`)\n        return true;\n    if (typeof value === `boolean`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `value` is number, string, bigint, boolean or an object\n *\n * Use {@link isPrimitive} to not include objects.\n * @param value\n * @returns\n */\nexport function isPrimitiveOrObject(value) {\n    if (isPrimitive(value))\n        return true;\n    if (typeof value === `object`)\n        return true;\n    return false;\n}\n","export const removeCircularReferences = (value, replaceWith = null, seen = new WeakSet(), path = ``) => {\n    if (value === null)\n        return value;\n    if (typeof value !== `object`)\n        throw new TypeError(`Param 'value' must be an object. Got type: ${typeof value}`);\n    seen.add(value);\n    const entries = Object.entries(value);\n    for (const entry of entries) {\n        if (entry[1] === null)\n            continue;\n        if (typeof entry[1] !== `object`)\n            continue;\n        if (seen.has(entry[1])) {\n            //value[ entry[0] ] = replaceWith;\n            entry[1] = replaceWith;\n            continue;\n        }\n        entry[1] = removeCircularReferences(entry[1], replaceWith, seen, `${entry[0]}.`);\n    }\n    return Object.fromEntries(entries);\n};\n","// Via Vuejs\nimport { removeCircularReferences } from \"./records/circular.js\";\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\n/**\n * Returns _true_ if `value` is a Map type\n * @param value\n * @returns\n */\nexport const isMap = (value) => toTypeString(value) === `[object Map]`;\n/**\n * Returns _true_ if `value` is a Set type\n * @param value\n * @returns\n */\nexport const isSet = (value) => toTypeString(value) === `[object Set]`;\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n/**\n * Converts a value to string form.\n * For simple objects, .toString() is used, other JSON.stringify is used.\n * It is meant for creating debugging output or 'hash' versions of objects, and does\n * not necessarily maintain full fidelity of the input\n * @param value\n * @returns\n */\nexport const defaultToString = (value) => {\n    //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n    if (value === null)\n        return `null`;\n    if (typeof value === `boolean` || typeof value === `number`) {\n        return value.toString();\n    }\n    if (typeof value === `string`)\n        return value;\n    if (typeof value === `symbol`)\n        throw new TypeError(`Symbol cannot be converted to string`);\n    try {\n        const s = JSON.stringify(value);\n        return s;\n    }\n    catch (error) {\n        // Circular maybe\n        if (typeof value === `object`) {\n            return JSON.stringify(removeCircularReferences(value, `(circular)`));\n        }\n        else {\n            throw error;\n        }\n    }\n};\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\nexport const toStringOrdered = (itemToMakeStringFor) => {\n    if (typeof itemToMakeStringFor === `string`)\n        return itemToMakeStringFor;\n    const allKeys = new Set();\n    JSON.stringify(itemToMakeStringFor, (key, value) => (allKeys.add(key), value));\n    return JSON.stringify(itemToMakeStringFor, [...allKeys].sort());\n};\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    //  UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = (a, b) => {\n    //  UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b` are equal based on their JSON representations.\n * `path` is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","import { isEqualDefault } from \"./is-equal.js\";\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common and those unique in `a` or `b`.\n * Ignores ordering of values, and is NOT recursive.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValuesShallow(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n *\n * By default uses === semantics for comparison.\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareIterableValuesShallow = (a, b, eq = (isEqualDefault)) => {\n    const shared = [];\n    const aUnique = [];\n    const bUnique = [];\n    for (const elementOfA of a) {\n        let seenInB = false;\n        // Does B contain this thing from A?\n        for (const elementOfB of b) {\n            if (eq(elementOfA, elementOfB)) {\n                seenInB = true;\n                break;\n            }\n        }\n        if (seenInB) {\n            // Common in A & B\n            shared.push(elementOfA);\n        }\n        else {\n            // No, it's only found in A\n            aUnique.push(elementOfA);\n        }\n    }\n    for (const elementOfB of b) {\n        let seenInA = false;\n        // Does A contain this thing from B?\n        for (const elementOfA of a) {\n            if (eq(elementOfB, elementOfA)) {\n                seenInA = true;\n            }\n        }\n        if (!seenInA) {\n            // No, something unique to B\n            bUnique.push(elementOfB);\n        }\n    }\n    // Are the two iterables the same?\n    const isSame = aUnique.length === 0 && bUnique.length === 0;\n    return {\n        shared,\n        isSame,\n        a: aUnique,\n        b: bUnique\n    };\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest } from '@ixfx/guards';\nimport { round } from './util/round.js';\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n/**\n * Return the millisecond value of an Interval.\n *\n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(interval, defaultNumber) {\n    if (isInterval(interval)) {\n        // Number given, must be millis?\n        if (typeof interval === `number`)\n            return interval;\n        let ms = interval.millis ?? 0;\n        ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n        ms += (interval.mins ?? 0) * 60 * 1000;\n        ms += (interval.secs ?? 0) * 1000;\n        return ms;\n    }\n    else {\n        if (typeof defaultNumber !== `undefined`)\n            return defaultNumber;\n        throw new Error(`Not a valid interval: ${JSON.stringify(interval)}`);\n    }\n}\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval\n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval) {\n    if (typeof interval === `undefined`)\n        return false;\n    if (interval === null)\n        return false;\n    if (typeof interval === `number`) {\n        if (Number.isNaN(interval))\n            return false;\n        if (!Number.isFinite(interval))\n            return false;\n        return true;\n    }\n    if (typeof interval !== `object`)\n        return false;\n    const hasMillis = `millis` in interval;\n    const hasSecs = `secs` in interval;\n    const hasMins = `mins` in interval;\n    const hasHours = `hours` in interval;\n    if (hasMillis && !numberTest(interval.millis).success)\n        return false;\n    if (hasSecs && !numberTest(interval.secs).success)\n        return false;\n    if (hasMins && !numberTest(interval.mins).success)\n        return false;\n    if (hasHours && !numberTest(interval.hours).success)\n        return false;\n    if (hasMillis || hasSecs || hasHours || hasMins)\n        return true;\n    return false;\n}\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n *\n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns\n */\nexport const elapsedToHumanString = (millisOrFunction, rounding = 2) => {\n    let interval = 0;\n    if (typeof millisOrFunction === `function`) {\n        const intervalResult = millisOrFunction();\n        return elapsedToHumanString(intervalResult);\n    }\n    else if (typeof millisOrFunction === `number`) {\n        interval = millisOrFunction;\n    }\n    else if (typeof millisOrFunction === `object`) {\n        interval = intervalToMs(interval);\n    }\n    let ms = intervalToMs(interval);\n    if (typeof ms === `undefined`)\n        return `(undefined)`;\n    if (ms < 1000)\n        return `${round(rounding, ms)}ms`;\n    ms /= 1000;\n    if (ms < 120)\n        return `${ms.toFixed(1)}secs`;\n    ms /= 60;\n    if (ms < 60)\n        return `${ms.toFixed(2)}mins`;\n    ms /= 60;\n    return `${ms.toFixed(2)}hrs`;\n};\n","import { defaultToString } from \"./to-string.js\";\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n *\n * Returns:\n * * 0: values are equal\n * * negative: `a` should be before `b`\n * * positive: `a` should come after `b`\n * @param a\n * @param b\n * @returns\n */\nexport const numericComparer = (a, b) => {\n    //  Unit tested\n    if (a === b)\n        return 0;\n    if (a > b)\n        return 1;\n    return -1;\n};\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\nexport const jsComparer = (x, y) => {\n    //  Unit tested\n    // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n    if (x === undefined && y === undefined)\n        return 0;\n    if (x === undefined)\n        return 1;\n    if (y === undefined)\n        return -1;\n    const xString = defaultToString(x);\n    const yString = defaultToString(y);\n    if (xString < yString)\n        return -1;\n    if (xString > yString)\n        return 1;\n    return 0;\n};\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = (comparer) => {\n    return (x, y) => {\n        const v = comparer(x, y);\n        return v * -1;\n    };\n};\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x, y) => {\n    if (typeof x === `number` && typeof y === `number`) {\n        return numericComparer(x, y);\n    }\n    return jsComparer(x, y);\n};\n","import { defaultComparer } from './comparers.js';\nimport { isEqualDefault } from './is-equal.js';\nimport { toStringDefault, } from './to-string.js';\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (data, target) => {\n    target = Math.round(target);\n    if (data.has(target)) {\n        return target;\n    }\n    else {\n        let offset = 1;\n        while (offset < 1000) {\n            if (data.has(target - offset))\n                return target - offset;\n            else if (data.has(target + offset))\n                return target + offset;\n            offset++;\n        }\n        throw new Error(`Could not find target ${target.toString()}`);\n    }\n};\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = findBySomeKey(data, keys);\n * ```\n * @param data\n * @param keys\n * @returns\n */\nexport const findBySomeKey = (data, keys) => {\n    for (const key of keys) {\n        if (data.has(key))\n            return data.get(key);\n    }\n};\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match. By default uses === comparison.\n * @returns True if key is found\n */\nexport const hasKeyValue = (map, key, value, comparer = isEqualDefault) => {\n    if (!map.has(key))\n        return false;\n    const values = [...map.values()];\n    return values.some((v) => comparer(v, value));\n};\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueCompareMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer Uses === equality by default. Use isEqualValueDefault to compare by value\n */\nexport const deleteByValueCompareMutate = (map, value, comparer = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (comparer(entry[1], value)) {\n            map.delete(entry[0]);\n        }\n    }\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link findEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const findEntryByPredicate = (map, predicate) => {\n    for (const entry of map.entries()) {\n        if (predicate(entry[1], entry[0]))\n            return entry;\n    }\n};\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * Uses JS's === comparison by default. Consider using `isEqualValueDefault` to match by value.\n * An alternative is {@link findEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const findEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (isEqual(entry[1], value))\n            return entry;\n    }\n};\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n * Returns a copy of the input map.\n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\n// export const addKeepingExisting = <V>(\n//   set: ReadonlyMap<string, V> | undefined,\n//   hasher: ToString<V>,\n//   ...values: readonly V[]\n// ) => {\n//   const s = set === undefined ? new Map() : new Map(set);\n//   for (const v of values) {\n//     const hashResult = hasher(v);\n//     if (s.has(hashResult)) continue;\n//     s.set(hashResult, v);\n//   }\n//   return s;\n// };\n/**\n * Mutates `map`, adding each value to it using a\n * function to produce a key. Use {@link addValue} for an immutable version.\n * ```\n * const map = new Map();\n * addValueMutate(map, v=>v.name, { name:`Jane`, size:10 }, { name:`Bob`, size: 9 });\n * // Map consists of entries:\n * // [ `Jane`, { name:`Jane`, size:10 } ],\n * // [ `Bob` { name:`Bob`, size: 9 } ]\n * ```\n *\n * Uses {@link addValueMutator} under the hood.\n * @param map Map to modify. If _undefined_, a new map is created\n * @param hasher Function to generate a string key for a given object value\n * @param values Values to add\n * @param collisionPolicy What to do if the key already exists\n * @returns Map instance\n */\nexport const addValueMutate = (map, hasher, collisionPolicy, ...values) => {\n    const m = map ?? new Map();\n    const f = addValueMutator(m, hasher, collisionPolicy);\n    f(...values);\n    return m;\n};\n/**\n * Adds values to a map, returning a new, modified copy and leaving the original\n * intact.\n *\n * Use {@link addValueMutate} for a mutable\n * @param map Map to start with, or _undefined_ to automatically create a map\n * @param hasher Function to create keys for values\n * @param collisionPolicy What to do if a key already exists\n * @param values Values to add\n * @returns A new map containing values\n */\nexport const addValue = (map, hasher, collisionPolicy, ...values) => {\n    const m = map === undefined ? new Map() : new Map(map);\n    for (const v of values) {\n        const hashResult = hasher(v);\n        if (collisionPolicy !== `overwrite`) {\n            if (m.has(hashResult)) {\n                if (collisionPolicy === `throw`)\n                    throw new Error(`Key '${hashResult}' already in map`);\n                if (collisionPolicy === `skip`)\n                    continue;\n            }\n        }\n        m.set(hashResult, v);\n    }\n    return m;\n};\n/**\n * Returns a function that adds values to a map, using a hashing function to produce a key.\n * Use {@link addValueMutate} if you don't need a reusable function.\n *\n * ```js\n * const map = new Map(); // Create map\n * const mutate = addValueMutator(map, v=>v.name); // Create a mutator using default 'overwrite' policy\n * mutate( { name:`Bob`, size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( {name: `Bob`, size: 11 }); // Change the value stored under key `Bob`.\n * map.get(`Bob`); // { name: `Bob`, size: 11 }\n * ```\n *\n * The 'collision policy' determines what to do if the key already exists. The default behaviour\n * is to overwrite the key, just as Map.set would.\n * ```js\n * const map = new Map();\n * const mutate = addValueMutator(map, v=>v.name, `skip`);\n * mutate( { name:`Bob`,size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( { name:`Bob`, size: 20 }); // This value would be skipped because map already contains 'Bob'\n * map.get(`Bob`); // { name: `Bob`, size: 10 }\n * ```\n *\n * @param map Map to modify\n * @param hasher Hashing function to make a key for a value\n * @param collisionPolicy What to do if a value is already stored under a key\n * @returns Function\n */\nexport const addValueMutator = (map, hasher, collisionPolicy = `overwrite`) => {\n    return (...values) => {\n        for (const v of values) {\n            const hashResult = hasher(v);\n            if (collisionPolicy !== `overwrite`) {\n                if (map.has(hashResult)) {\n                    if (collisionPolicy === `throw`)\n                        throw new Error(`Key '${hashResult}' already in map`);\n                    if (collisionPolicy === `skip`)\n                        continue;\n                }\n            }\n            map.set(hashResult, v);\n        }\n        return map;\n    };\n};\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = (map, comparer) => {\n    const f = comparer ?? defaultComparer;\n    return [...map.entries()].sort((a, b) => f(a[1], b[1]));\n};\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = sortByValueProperty(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = (map, property, compareFunction) => {\n    const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n    return [...map.entries()].sort((aE, bE) => {\n        const a = aE[1];\n        const b = bE[1];\n        return cfn(a[property], b[property]);\n    });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = (map, value, comparer) => {\n    const entries = [...map.entries()];\n    return entries.some((kv) => comparer(kv[1], value));\n};\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filterValues(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filterValues(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\nexport function* filterValues(map, predicate) {\n    for (const v of map.values()) {\n        if (predicate(v))\n            yield v;\n    }\n}\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = (map) => [...map.values()];\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` },\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = fromIterable(data, v => v.fruit);\n * map.get(`granny-smith`); // { fruit: `granny-smith`, family: `apple`, colour: `green` }\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param collisionPolicy By default, values with same key overwrite previous (`overwrite`)\n * @returns\n */\nexport const fromIterable = (data, keyFunction = (toStringDefault), collisionPolicy = `overwrite`) => {\n    const m = new Map();\n    for (const d of data) {\n        const key = keyFunction(d);\n        if (m.has(key)) {\n            if (collisionPolicy === `throw`)\n                throw new Error(`Key '${key}' is already used and new data will overwrite it. `);\n            if (collisionPolicy === `skip`)\n                continue;\n        }\n        m.set(key, d);\n    }\n    return m;\n};\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectEntriesMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = (data) => {\n    const map = new Map();\n    if (Array.isArray(data)) {\n        for (const d of data)\n            addObjectEntriesMutate(map, d);\n    }\n    else {\n        addObjectEntriesMutate(map, data);\n    }\n    return map;\n};\n/**\n * Adds an object to an existing map, mutating it.\n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObjectEntriesMutate(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectEntriesMutate = (map, data) => {\n    const entries = Object.entries(data);\n    for (const [key, value] of entries) {\n        map.set(key, value);\n    }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n * To get an entry see {@link findEntryByPredicate}\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filterValue} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = findValue(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const findValue = (map, predicate) => [...map.values()].find(v => predicate(v));\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link findValue} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map\n * @param predicate\n * @returns\n */\nexport const some = (map, predicate) => [...map.values()].some(v => predicate(v));\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = (m, valueTransform) => [...m].reduce((object, [key, value]) => {\n    const t = valueTransform(value);\n    object[key] = t;\n    return object;\n}, {});\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = (keys, values) => {\n    if (keys.length !== values.length) {\n        throw new Error(`Keys and values arrays should be same length`);\n    }\n    return Object.fromEntries(keys.map((k, index) => [k, values[index]]));\n};\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = (source, transformer) => new Map(Array.from(source, (v) => [v[0], transformer(v[1], v[0])]));\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = (m) => [...m].reduce((object, [key, value]) => {\n    object[key] = value;\n    return object;\n}, {});\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * const person = { age: 29, name: `John`};\n * map.set(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = (m, transformer) => [...m.entries()].map((x) => transformer(x[0], x[1]));\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also @ixfx/arrays/mergeByKey if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 1 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = (reconcile, ...maps) => {\n    const result = new Map();\n    for (const m of maps) {\n        for (const [mk, mv] of m) {\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return result;\n};\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate = (map, fn) => async (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value; //Promise.resolve(value);\n    value = await fn(key, args);\n    if (value === undefined)\n        throw new Error(`fn returned undefined`);\n    map.set(key, value);\n    return value;\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport const continuously = (callback, interval = 0, options = {}) => {\n    let intervalMs = intervalToMs(interval, 0);\n    resultThrow(integerTest(intervalMs, `positive`, `interval`));\n    const fireBeforeWait = options.fireBeforeWait ?? false;\n    const onStartCalled = options.onStartCalled;\n    const signal = options.signal;\n    let disposed = false;\n    let runState = `idle`;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let startedAt = performance.now();\n    let intervalUsed = interval ?? 0;\n    let cancelled = false;\n    let currentTimer;\n    const deschedule = () => {\n        if (currentTimer === undefined)\n            return;\n        globalThis.clearTimeout(currentTimer);\n        currentTimer = undefined;\n        startCount = 0;\n        startedAt = Number.NaN;\n    };\n    const schedule = (scheduledCallback) => {\n        if (intervalMs === 0) {\n            if (typeof requestAnimationFrame === `undefined`) {\n                currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n            }\n            else {\n                currentTimer = undefined;\n                requestAnimationFrame(scheduledCallback);\n            }\n        }\n        else {\n            currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n        }\n    };\n    const cancel = () => {\n        if (cancelled)\n            return;\n        cancelled = true;\n        if (runState === `idle`)\n            return; // No need to cancel\n        runState = `idle`;\n        deschedule();\n    };\n    const loop = async () => {\n        if (signal?.aborted) {\n            runState = `idle`;\n        }\n        if (runState === `idle`)\n            return;\n        runState = `running`;\n        startCount++;\n        startCountTotal++;\n        const valueOrPromise = callback(startCount, performance.now() - startedAt);\n        const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n        if (cancelled) {\n            return;\n        }\n        runState = `scheduled`;\n        // Didn't get a value, exit out\n        if (value !== undefined && !value) {\n            cancel();\n            return;\n        }\n        if (cancelled)\n            return; // has been cancelled\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop);\n    };\n    const start = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        if (onStartCalled !== undefined) {\n            // A function governs whether to allow .start() to go ahead\n            const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n            switch (doWhat) {\n                case `cancel`: {\n                    cancel();\n                    return;\n                }\n                case `reset`: {\n                    reset();\n                    return;\n                }\n                case `dispose`: {\n                    disposed = true;\n                    cancel();\n                    return;\n                }\n                // No default\n            }\n        }\n        if (runState === `idle`) {\n            // Start running\n            startCount = 0;\n            startedAt = performance.now();\n            runState = `scheduled`;\n            if (fireBeforeWait) {\n                void loop(); // Exec first, then wait\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                schedule(loop); // Wait first, then exec\n            }\n        } // else: already running, ignore\n    };\n    const reset = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        startCount = 0;\n        startedAt = Number.NaN;\n        // Cancel scheduled iteration\n        if (runState !== `idle`) {\n            cancel();\n        }\n        start();\n    };\n    return {\n        start,\n        reset,\n        cancel,\n        get interval() {\n            return intervalUsed;\n        },\n        get runState() {\n            return runState;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        },\n        get startCount() {\n            return startCount;\n        },\n        set interval(interval) {\n            const ms = intervalToMs(interval, 0);\n            resultThrow(integerTest(ms, `positive`, `interval`));\n            intervalMs = ms;\n            intervalUsed = interval;\n        },\n        get isDisposed() {\n            return disposed;\n        },\n        get elapsedMs() {\n            return performance.now() - startedAt;\n        },\n    };\n};\n","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n/**\n * Returns elapsed time since the initial call.\n *\n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = () => {\n    const start = performance.now();\n    return () => {\n        return performance.now() - start;\n    };\n};\n/**\n * Returns the interval between the start and each subsequent call.\n *\n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n *\n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns\n */\nexport const elapsedInterval = () => {\n    let start = performance.now();\n    return () => {\n        const now = performance.now();\n        const x = now - start;\n        start = now;\n        return x;\n    };\n};\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n *\n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = () => {\n    const start = Date.now();\n    let stoppedAt = 0;\n    return () => {\n        if (stoppedAt === 0) {\n            stoppedAt = Date.now() - start;\n        }\n        return stoppedAt;\n    };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = () => {\n    return () => {\n        return Number.POSITIVE_INFINITY;\n    };\n};\n","export const promiseFromEvent = (target, name) => {\n    return new Promise(resolve => {\n        const handler = (...args) => {\n            target.removeEventListener(name, handler);\n            if (Array.isArray(args) && args.length === 1)\n                resolve(args[0]);\n            else\n                resolve(args);\n        };\n        target.addEventListener(name, handler);\n    });\n};\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n    if (typeof window === `undefined`) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        globalThis.requestAnimationFrame = (callback) => {\n            setTimeout(callback, 1);\n        };\n    }\n}\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * `Flow.delay()` and {@link sleep} are similar. `Flow.delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = (optsOrMillis) => {\n    const timeoutMs = intervalToMs(optsOrMillis, 1);\n    const signal = optsOrMillis.signal;\n    const value = optsOrMillis.value;\n    resultThrow(numberTest(timeoutMs, `positive`, `timeoutMs`));\n    if (timeoutMs === 0) {\n        return new Promise((resolve) => requestAnimationFrame((_) => {\n            resolve(value);\n        }));\n    }\n    else {\n        return new Promise((resolve, reject) => {\n            const onAbortSignal = () => {\n                clearTimeout(t);\n                if (signal) {\n                    signal.removeEventListener(`abort`, onAbortSignal);\n                    reject(new Error(signal.reason));\n                }\n                else {\n                    reject(new Error(`Cancelled`));\n                }\n            };\n            if (signal) {\n                signal.addEventListener(`abort`, onAbortSignal);\n            }\n            const t = setTimeout(() => {\n                signal?.removeEventListener(`abort`, onAbortSignal);\n                if (signal?.aborted) {\n                    reject(new Error(signal.reason));\n                    return;\n                }\n                resolve(value);\n            }, timeoutMs);\n        });\n    }\n};\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate\n * @param checkInterval\n */\nexport const sleepWhile = async (predicate, checkInterval = 100) => {\n    while (predicate()) {\n        await sleep(checkInterval);\n    }\n};\n","/**\n * Outputs the current largest-seen value\n * @returns\n */\nexport const max = () => {\n    let max = Number.MIN_SAFE_INTEGER;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                break;\n            max = Math.max(subValue, max);\n        }\n        return max;\n    };\n    return compute;\n};\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = () => {\n    let min = Number.MAX_SAFE_INTEGER;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                break;\n            min = Math.min(subValue, min);\n        }\n        return min;\n    };\n    return compute;\n};\n/**\n * Returns a sum of values\n * @returns\n */\nexport const sum = () => {\n    let t = 0;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                continue;\n            t += subValue;\n        }\n        return t;\n    };\n    return compute;\n};\n/**\n * Returns the current average of input values\n * @returns\n */\nexport const average = () => {\n    let total = 0;\n    let tally = 0;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                continue;\n            tally++;\n            total += subValue;\n        }\n        return total / tally;\n    };\n    return compute;\n};\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems\n * @returns\n */\nexport const tally = (countArrayItems) => {\n    let t = 0;\n    const compute = (value) => {\n        if (countArrayItems) {\n            if (Array.isArray(value))\n                t += value.length;\n            else\n                t++;\n        }\n        else {\n            t++;\n        }\n        return t;\n    };\n    return compute;\n};\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r\n * @param options\n * @returns\n */\nexport function rank(r, options = {}) {\n    const includeType = options.includeType;\n    const emitEqualRanked = options.emitEqualRanked ?? false;\n    const emitRepeatHighest = options.emitRepeatHighest ?? false;\n    let best;\n    return (value) => {\n        if (includeType && typeof value !== includeType)\n            return;\n        if (best === undefined) {\n            best = value;\n            return best;\n        }\n        else {\n            const result = r(value, best);\n            //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n            if (result == `a`) {\n                // New value is the current best\n                best = value;\n                return best;\n            }\n            else if (result === `eq` && emitEqualRanked) {\n                // New value is same rank as previous, but we have flag on\n                return best;\n            }\n            else if (emitRepeatHighest) {\n                // Emit current highest due to flag\n                return best;\n            }\n        }\n    };\n}\n","import { arrayTest, throwIfFailed } from \"@ixfx/guards\";\n/**\n * Returns a function that cycles through the contents of an array. By default starts at index 0.\n *\n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n *\n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n *\n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n *\n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over\n * @returns\n */\nexport const cycle = (options) => {\n    throwIfFailed(arrayTest(options, `options`));\n    const opts = [...options];\n    let index = 0;\n    const next = () => {\n        index++;\n        if (index === opts.length)\n            index = 0;\n        return value();\n    };\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const prev = () => {\n        index--;\n        if (index === -1)\n            index = opts.length - 1;\n        return value();\n    };\n    const value = () => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return opts.at(index);\n    };\n    const select = (indexOrValue) => {\n        if (typeof indexOrValue === `number`) {\n            index = indexOrValue;\n        }\n        else {\n            const found = opts.indexOf(indexOrValue);\n            if (found === -1)\n                throw new Error(`Could not find value`);\n            index = found;\n        }\n    };\n    const toArray = () => [...opts];\n    return { toArray, next, prev, get current() { return value(); }, select };\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Similar to Javascript's in-built Array.at function, but allows offsets\n * to wrap.\n *\n * @remarks\n * ```js\n * const test = [1,2,3,4,5,6];\n * atWrap(0);   // 1\n * atWrap(-1);  // 6\n * atWrap(-6);  // 1\n * ```\n *\n * These values would return _undefined_ using Array.at since its beyond\n * the length of the array\n * ```js\n * atWrap(6);   // 1\n * atWrap(-7);  // 6\n * ```\n * @param array Array\n * @param index Index\n * @returns\n */\nexport const atWrap = (array, index) => {\n    resultThrow(numberTest(index, ``, `index`));\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array`);\n    index = index % array.length;\n    return array.at(index);\n};\n","/**\n * Return `array` broken up into chunks of `size` values\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param array\n * @param size\n * @returns\n */\nimport { arrayTest, integerTest, throwIfFailed } from \"@ixfx/guards\";\nexport function chunks(array, size) {\n    throwIfFailed(integerTest(size, \"aboveZero\", `size`), arrayTest(array, `array`));\n    // https://surma.github.io/underdash/\n    const output = [];\n    for (let index = 0; index < array.length; index += size) {\n        output.push(array.slice(index, index + size));\n    }\n    return output;\n}\n","/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\n// export const toStringOrdered = (itemToMakeStringFor: unknown) => {\n//   if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n//   const allKeys = new Set<string>();\n//   JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n//   return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n// }\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    //  UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\n// export const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n//   //  UNIT TESTED\n//   if (a === b) return true; // Object references are the same, or string values are the same\n//   return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n// };\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b` are equal based on their JSON representations.\n * `path` parameter is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n/**\n * Returns _true_ if all value in `needles` is contained in `haystack`.\n *\n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n *\n * If `needles` is empty, `contains` will return true.\n * @param haystack Array to search\n * @param needles Things to look for\n * @param eq\n */\nexport const contains = (haystack, needles, eq = (isEqualDefault)) => {\n    if (!Array.isArray(haystack)) {\n        throw new TypeError(`Expects haystack parameter to be an array`);\n    }\n    if (!Array.isArray(needles)) {\n        throw new TypeError(`Expects needles parameter to be an array. Got: ${typeof needles}`);\n    }\n    for (const needle of needles) {\n        let found = false;\n        for (const element of haystack) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            if (eq(needle, element)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n *\n * Uses JSON.toString() by default to compare values.\n *\n * See also:\n * * {@link unique}: Get unique set of values in an array\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link containsDuplicateValues}: Returns _true_ if every item in array is the same\n * @param data Array to examine\n * @param keyFunction Function to generate key string for object, uses JSON.stringify by default.\n * @returns\n */\nexport const containsDuplicateValues = (data, keyFunction = (toStringDefault)) => {\n    if (typeof data !== `object`)\n        throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${typeof data}`);\n    const set = new Set();\n    for (const v of data) {\n        const string_ = keyFunction(v);\n        if (set.has(string_))\n            return true;\n        set.add(string_);\n    }\n    return false;\n};\n/**\n * Returns _true_ if array contains duplicate instances based on `===` equality checking\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array\n * @returns\n */\nexport const containsDuplicateInstances = (array) => {\n    if (!Array.isArray(array))\n        throw new Error(`Parameter needs to be an array`);\n    for (let index = 0; index < array.length; index++) {\n        for (let x = 0; x < array.length; x++) {\n            if (index === x)\n                continue;\n            if (array[index] === array[x])\n                return true;\n        }\n    }\n    return false;\n};\n","/**\n * Returns a copy of an array with specified length - padded or truncated as needed.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with _undefined_ (default)\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * Truncate:\n * ```js\n * ensureLength([1,2,3], 2); // [1,2]\n * ```\n *\n * Padded:\n * ```js\n * ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expandStrategy Expand strategy\n * @param truncateStrategy Truncation strategy. By default removes from end ('from-end')\n * @typeParam V Type of array\n */\nexport function ensureLength(data, length, expandStrategy = `undefined`, truncateStrategy = `from-end`) {\n    if (data === undefined)\n        throw new Error(`Data undefined`);\n    if (!Array.isArray(data))\n        throw new Error(`data is not an array`);\n    if (data.length === length)\n        return [...data];\n    if (data.length > length) {\n        if (truncateStrategy === `from-end`) {\n            return data.slice(0, length);\n        }\n        else {\n            return data.slice(data.length - length);\n        }\n    }\n    const d = [...data];\n    const add = length - d.length;\n    for (let index = 0; index < add; index++) {\n        switch (expandStrategy) {\n            case `undefined`: {\n                // @ts-expect-error all fine .....\n                d.push(undefined);\n                break;\n            }\n            case `repeat`: {\n                d.push(data[index % data.length]);\n                break;\n            }\n            case `first`: {\n                d.push(data[0]);\n                break;\n            }\n            case `last`: {\n                // @ts-expect-error all fine .....\n                d.push(data.at(-1));\n                break;\n            }\n            // No default\n        }\n    }\n    return d;\n}\n;\n","import { isEqualDefault, isEqualValueDefault } from \"./util/is-equal.js\";\nimport { arrayTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns _true_ if the two arrays have the same items at same indexes.\n *\n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n *\n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n *\n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n *\n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA\n * @param arrayB\n * @param equality Function to compare values\n */\nexport const isEqual = (arrayA, arrayB, equality = (isEqualDefault)) => {\n    // TODO: 'eq' function could be a key-generating function too\n    resultThrow(arrayTest(arrayA, `arrayA`), arrayTest(arrayB, `arrayB`));\n    if (arrayA.length !== arrayB.length)\n        return false;\n    for (let indexA = 0; indexA < arrayA.length; indexA++) {\n        if (!(equality(arrayA[indexA], arrayB[indexA])))\n            return false;\n    }\n    return true;\n};\n/**\n * Returns _true_ if all values in the array are the same. Uses value-based equality checking by default.\n *\n * @example Using default equality function\n * ```js\n * const a1 = [ 10, 10, 10 ];\n * containsIdenticalValues(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * containsIdenticalValues(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * containsIdenticalValues(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const containsIdenticalValues = (array, equality) => {\n    // TODO: 'equality' function could be a key-generating function too\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array.`);\n    if (array.length === 0)\n        return true;\n    const eq = equality ?? isEqualValueDefault;\n    const a = array[0];\n    const r = array.some((v) => !eq(a, v));\n    if (r)\n        return false;\n    return true;\n};\n","import { arrayIndexTest, arrayTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on.\n *\n * Same idea as the in-built Array.filter, but that only returns values for one case.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = (data, filter) => {\n    const a = [];\n    const b = [];\n    for (const datum of data) {\n        if (filter(datum))\n            a.push(datum);\n        else\n            b.push(datum);\n    }\n    return [a, b];\n};\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween(array, predicate, startIndex, endIndex) {\n    resultThrow(arrayTest(array, `array`));\n    if (typeof startIndex === `undefined`)\n        startIndex = 0;\n    if (typeof endIndex === `undefined`)\n        endIndex = array.length; //- 1;\n    resultThrow(arrayIndexTest(array, startIndex, `startIndex`));\n    resultThrow(arrayIndexTest(array, endIndex - 1, `endIndex`));\n    for (let index = startIndex; index < endIndex; index++) {\n        if (predicate(array[index], index, array))\n            yield array[index]; //t.push(array[ index ]);\n    }\n}\n;\n","/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array) => [...array].flat();\n","/**\n * Returns the array.map() output, or a value if `array`\n * is not an array or empty.\n *\n * ```js\n * mapWithEmptyFallback([1,2,3], v => v+2, 100); // Yields: [3,4,5]\n * mapWithEmptyFallback([], v=>v+2, 100); // Yields: [100]\n * mapWithEmptyFallback({}, v=>v+2, [100]); // Yields: [100]\n * ```\n *\n * If the fallback value is an array, it is returned as an\n * array if needed. If it's a single value, it is wrapped as an array.\n * @param array Array of values\n * @param fn Function to use for mapping values\n * @param fallback Fallback single value or array of values\n * @returns\n */\nexport const mapWithEmptyFallback = (array, fn, fallback) => {\n    if (typeof array !== `object` || !Array.isArray(array) || array.length === 0) {\n        if (Array.isArray(fallback))\n            return fallback;\n        return [fallback];\n    }\n    return array.map(fn);\n};\n","/**\n * Computes the frequency of values by a grouping function.\n *\n * ```js\n * const data = [1,2,3,4,5,6,7,8,9,10];\n * // Returns 'odd' or 'even' for an input value\n *\n * const groupBy = v => v % 2 === 0 ? `even`:`odd`;\n *\n * const data = frequencyByGroup(groupBy, data);\n * // Yields map with:\n * //  key: 'even', value: 5\n * //  key: 'odd', value: 5\n * @param groupBy\n * @param data\n * @returns\n */\nexport const frequencyByGroup = (groupBy, data) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'array' is expected to be an array. Got type: '${typeof data}'`);\n    const store = new Map();\n    for (const value of data) {\n        const group = groupBy(value);\n        if (typeof group !== `string` && typeof group !== `number`) {\n            throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${typeof group}' for value: '${value}'`);\n        }\n        let groupValue = store.get(group);\n        groupValue ??= 0;\n        groupValue++;\n        store.set(group, groupValue);\n    }\n    return store;\n};\n","/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * const data = [\n *  { age: 39, city: `London` },\n *  { age: 14, city: `Copenhagen` },\n *  { age: 23, city: `Stockholm` },\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = Arrays.groupBy(data, item => item.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = (array, grouper) => {\n    const map = new Map();\n    for (const a of array) {\n        const key = grouper(a);\n        let existing = map.get(key);\n        if (!existing) {\n            existing = [];\n            map.set(key, existing);\n        }\n        existing.push(a);\n    }\n    return map;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n *\n * By default uses Javascript's default equality checking\n *\n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * Iterables.additionalValues: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = (arrays, comparer = (isEqualDefault)) => {\n    const t = [];\n    const contains = (v) => {\n        for (const tValue of t) {\n            if (comparer(tValue, v))\n                return true;\n        }\n        return false;\n    };\n    const flattened = arrays.flat(10);\n    for (const v of flattened) {\n        if (!contains(v))\n            t.push(v);\n    }\n    return t;\n};\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n *\n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n *\n * By default uses JSON.toString() to compare values.\n *\n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * Iterables.additionalValues: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays Array (or array of arrays) to examine\n * @param toString Function to convert values to a string for comparison purposes. By default uses JSON formatting.\n * @returns\n */\nexport const unique = (arrays, toString = toStringDefault) => {\n    const matching = new Set();\n    const t = [];\n    const flattened = arrays.flat(10);\n    for (const a of flattened) {\n        const stringRepresentation = toString(a);\n        if (matching.has(stringRepresentation))\n            continue;\n        matching.add(stringRepresentation);\n        t.push(a);\n    }\n    return t;\n};\n","import { arrayIndexTest, arrayTest, integerTest, throwIfFailed } from \"@ixfx/guards\";\n/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down and returning changed result.\n *\n * Does not modify the input array.\n *\n * ```js\n * const data = [ 1, 2, 3 ]\n *\n * // Inserts 20,30,40 at index 1\n * Arrays.insertAt(data, 1, 20, 30, 40);\n *\n * // Yields: 1, 20, 30, 40, 2, 3\n * ```\n * @param data\n * @param index\n * @param values\n * @returns\n */\nexport const insertAt = (data, index, ...values) => {\n    throwIfFailed(arrayTest(data, `data`), arrayIndexTest(data, index, `index`));\n    // Adding at end\n    if (index === data.length - 1) {\n        return [...data, ...values];\n    }\n    // Adding at beginning\n    if (index === 0) {\n        return [...values, ...data];\n    }\n    return [...data.slice(0, index), ...values, ...data.slice(index)];\n};\n","import { containsIdenticalValues } from \"./equality.js\";\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = Arrays.interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map(a => a.length);\n    if (!containsIdenticalValues(lengths)) {\n        throw new Error(`Arrays must be of same length`);\n    }\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        for (const array of arrays) {\n            returnValue.push(array[index]);\n        }\n    }\n    return returnValue;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n *\n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also:\n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA\n * @param arrayB\n * @param equality\n * @returns\n */\nexport const intersection = (arrayA, arrayB, equality = isEqualDefault) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n","/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also Core.Maps.mergeByKey if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFunction Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = (keyFunction, reconcile, ...arrays) => {\n    const result = new Map();\n    for (const m of arrays) {\n        for (const mv of m) {\n            if (mv === undefined)\n                continue;\n            const mk = keyFunction(mv);\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return [...result.values()];\n};\n","import { resultThrow, arrayTest } from \"@ixfx/guards\";\n/**\n * Yields pairs made up of overlapping items from the input array.\n *\n * Throws an error if there are less than two entries.\n *\n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [ [1,2], [2,3], [3,4], [4,5] ]\n * ```\n * @param values\n */\nexport function* pairwise(values) {\n    resultThrow(arrayTest(values, `values`));\n    if (values.length < 2)\n        throw new Error(`Array needs to have at least two entries. Length: ${values.length}`);\n    for (let index = 1; index < values.length; index++) {\n        yield [values[index - 1], values[index]];\n    }\n}\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = (array, reducer, initial) => {\n    resultThrow(arrayTest(array, `arr`));\n    if (array.length < 2)\n        return initial;\n    for (let index = 0; index < array.length - 1; index++) {\n        initial = reducer(initial, array[index], array[index + 1]);\n    }\n    return initial;\n};\n","import { arrayTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n *\n * It can be useful to randomly access each item from an array exactly once:\n * ```js\n * for (const value of shuffle(inputArray)) {\n *  // Do something with the value...\n * }\n * ```\n * @param dataToShuffle Input array\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = (dataToShuffle, rand = Math.random) => {\n    resultThrow(arrayTest(dataToShuffle, `dataToShuffle`));\n    const array = [...dataToShuffle];\n    for (let index = array.length - 1; index > 0; index--) {\n        const index_ = Math.floor(rand() * (index + 1));\n        [array[index], array[index_]] = [array[index_], array[index]];\n    }\n    return array;\n};\n/**\n * Returns a random element of an array\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Note that repeated calls might yield the same value\n * multiple times. If you want to random unique values, consider using {@link shuffle}.\n *\n * See also:\n * * {@link randomIndex} if you want a random index rather than value.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = (array, rand = Math.random) => {\n    resultThrow(arrayTest(array, `array`));\n    return array[Math.floor(rand() * array.length)];\n};\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = (array, rand = Math.random) => Math.floor(rand() * array.length);\n","import { arrayIndexTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = (data, index) => {\n    if (!Array.isArray(data)) {\n        throw new TypeError(`'data' parameter should be an array`);\n    }\n    resultThrow(arrayIndexTest(data, index, `index`));\n    return [...data.slice(0, index), ...data.slice(index + 1)];\n};\n","import { resultThrow, integerTest } from '@ixfx/guards';\n/**\n * Samples values from an array.\n *\n * If `amount` is less or equal to 1, it's treated as a percentage to sample.\n * Otherwise it's treated as every _n_th value to sample.\n *\n * @example\n * By percentage - get half of the items\n * ```\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example\n * By steps - every third value\n * ```\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = (array, amount) => {\n    if (!Array.isArray(array))\n        throw new TypeError(`Param 'array' is not actually an array. Got type: ${typeof array}`);\n    let subsampleSteps = 1;\n    if (amount <= 1) {\n        // Subsample based on a percentage\n        const numberOfItems = array.length * amount;\n        subsampleSteps = Math.round(array.length / numberOfItems);\n    }\n    else {\n        subsampleSteps = amount;\n    }\n    resultThrow(integerTest(subsampleSteps, `positive`, `amount`));\n    if (subsampleSteps > array.length - 1) {\n        throw new Error(`Subsample steps exceeds array length`);\n    }\n    const r = [];\n    for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n        r.push(array[index]);\n    }\n    return r;\n};\n","import { arrayTest, resultThrow } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = (data, propertyName) => [...data].sort((a, b) => {\n    resultThrow(arrayTest(data, `data`));\n    const av = a[propertyName];\n    const bv = b[propertyName];\n    if (av < bv)\n        return -1;\n    if (av > bv)\n        return 1;\n    return 0;\n});\n/**\n * Sorts an array of objects by some named property.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * sortByProperty(data, `colour`);\n *\n * Yields [\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n *  { size: 10, colour: `red` },\n * ]\n * ```\n *\n * You can also provide a custom comparer that is passed property values.\n * This function should return 0 if values are equal, 1 if `a > b` and -1 if `a < b`.\n * @param data\n * @param propertyName\n * @returns\n */\nexport const sortByProperty = (data, propertyName, comparer) => [...data].sort((a, b) => {\n    resultThrow(arrayTest(data, `data`));\n    const av = a[propertyName];\n    const bv = b[propertyName];\n    if (comparer === undefined) {\n        if (av < bv)\n            return -1;\n        if (av > bv)\n            return 1;\n        return 0;\n    }\n    else {\n        return comparer(av, bv);\n    }\n});\n","/**\n * Yields all items in the input array for as long as `predicate` returns true.\n *\n * `predicate` yields arrays of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = [...until([1,2,3,4,5], v => v === 3];\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total, using 0 as initial value\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport function* until(data, predicate, initial) {\n    let total = initial;\n    for (const datum of data) {\n        const r = predicate(datum, total);\n        if (typeof r === `boolean`) {\n            if (r)\n                break;\n        }\n        else {\n            const [stop, accumulator] = r;\n            if (stop)\n                break;\n            total = accumulator;\n        }\n        yield datum;\n    }\n}\n;\n","import { isEqualDefault } from \"./util/is-equal.js\";\n/**\n * Returns a copy of an input array with _undefined_ values removed.\n * @param data\n * @returns\n */\nexport const withoutUndefined = (data) => {\n    return data.filter(v => v !== undefined);\n};\n/**\n * Returns an array with value(s) omitted.\n *\n * If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * const data = [100, 20, 40];\n * const filtered = without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * const data = [{ name: `Alice` }, { name:`Sam` }];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * without(data, { name: `Alice` });\n *\n * // So instead we can use a value comparer:\n * without(data, { name:`Alice` }, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * const data = [ { name: `Alice` }, { name:`Sam` }];\n * without(data, { name:`ALICE` }, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = (sourceArray, toRemove, comparer = isEqualDefault) => {\n    if (Array.isArray(toRemove)) {\n        const returnArray = [];\n        for (const source of sourceArray) {\n            if (!toRemove.some(v => comparer(source, v))) {\n                returnArray.push(source);\n            }\n        }\n        return returnArray;\n    }\n    else {\n        return sourceArray.filter((v) => !comparer(v, toRemove));\n    }\n};\n","import { containsIdenticalValues } from \"./equality.js\";\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map((a) => a.length);\n    if (!containsIdenticalValues(lengths)) {\n        throw new Error(`Arrays must be of same length`);\n    }\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        returnValue.push(arrays.map((a) => a[index]));\n    }\n    return returnValue;\n};\n","export * from './cycle.js';\nexport * from './at-wrap.js';\nexport * from './chunks.js';\nexport * from './contains.js';\nexport * from './ensure-length.js';\nexport * from './equality.js';\nexport * from './filter.js';\nexport * from './flatten.js';\nexport * from './for-each.js';\nexport * from './frequency.js';\nexport * from './group-by.js';\nexport * from './unique.js';\nexport * from './insert-at.js';\nexport * from './interleave.js';\nexport * from './intersection.js';\nexport * from './merge-by-key.js';\nexport * from './pairwise.js';\nexport * from './random.js';\nexport * from './remove.js';\nexport * from './sample.js';\nexport * from './sort.js';\nexport * from './unique.js';\nexport * from './until.js';\nexport * from './without.js';\nexport * from './zip.js';\n","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n *\n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object\n * @param apply\n * @returns\n */\nexport const applyToValues = (object, apply) => {\n    const o = { ...object };\n    for (const [key, value] of Object.entries(object)) {\n        if (typeof value === `number`) {\n            // Run number through function\n            //eslint-disable-next-line functional/immutable-data\n            o[key] = apply(value);\n        }\n        else {\n            // Copy value\n            //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n            o[key] = value;\n        }\n    }\n    return o;\n};\n","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (data, fn) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof data}`);\n    const weightingFunction = fn ?? ((x) => x);\n    return data.map((value, index) => {\n        if (typeof value !== `number`)\n            throw new TypeError(`Param 'data' contains non-number at index: '${index}'. Type: '${typeof value}' value: '${value}'`);\n        const relativePos = index / (data.length - 1);\n        const weightForPosition = weightingFunction(relativePos);\n        if (typeof weightForPosition !== `number`)\n            throw new TypeError(`Weighting function returned type '${typeof weightForPosition}' rather than number for input: '${relativePos}'`);\n        const finalResult = value * weightForPosition;\n        //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n        return finalResult;\n    });\n};\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data) => data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (values) => {\n    let r = 0;\n    const length = values[0].length;\n    for (let index = 0; index < length; index++) {\n        let t = 0;\n        for (const [p, value] of values.entries()) {\n            if (p === 0)\n                t = value[index];\n            else {\n                t *= value[index];\n            }\n        }\n        r += t;\n    }\n    return r;\n};\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link numberArrayCompute} if you want min, max and total as well.\n *\n * @example\n * ```js\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data) => {\n    //  UNIT TESTED\n    if (data === undefined)\n        throw new Error(`data parameter is undefined`);\n    const valid = validNumbers(data);\n    const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n    return total / valid.length;\n};\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data) => Math.min(...validNumbers(data));\n/**\n * Returns the index of the largest value.\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data) => data.reduce((bestIndex, value, index, array) => value > array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data) => data.reduce((bestIndex, value, index, array) => value < array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data) => Math.max(...validNumbers(data));\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data) => data.reduce((previous, current) => {\n    if (typeof current !== `number`)\n        return previous;\n    if (Number.isNaN(current))\n        return previous;\n    if (!Number.isFinite(current))\n        return previous;\n    return previous + current;\n}, 0);\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.max(m, datum);\n    }\n    return m;\n};\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data) => {\n    let m = 0;\n    for (const datum of data) {\n        m += datum;\n    }\n    return m;\n};\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.min(m, datum);\n    }\n    return m;\n};\n","import { zip } from '@ixfx/arrays';\nimport { weight } from './numeric-arrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * averageWeighted[1,2,3], Random.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * const data = [1,2,3];\n * const w = weight(data, Random.gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (data, weightings) => {\n    if (typeof weightings === `function`)\n        weightings = weight(data, weightings);\n    const ww = zip(data, weightings);\n    const [totalV, totalW] = ww.reduce((accumulator, v) => [accumulator[0] + v[0] * v[1], accumulator[1] + v[1]], [0, 0]);\n    return totalV / totalW;\n};\n","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link https://api.ixfx.fun/_ixfx/geometry/Points/clamp/ @ixfx/geometry/Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value, min = 0, max = 1) => {\n    //  UNIT TESTED\n    if (Number.isNaN(value))\n        throw new Error(`Param 'value' is NaN`);\n    if (Number.isNaN(min))\n        throw new Error(`Param 'min' is NaN`);\n    if (Number.isNaN(max))\n        throw new Error(`Param 'max' is NaN`);\n    if (value < min)\n        return min;\n    if (value > max)\n        return max;\n    return value;\n};\n/**\n * Returns a function that clamps values.\n *\n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport const clamper = (min = 0, max = 1) => {\n    if (Number.isNaN(min))\n        throw new Error(`Param 'min' is NaN`);\n    if (Number.isNaN(max))\n        throw new Error(`Param 'max' is NaN`);\n    return (v) => {\n        if (v > max)\n            return max;\n        if (v < min)\n            return min;\n        return v;\n    };\n};\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport const clampIndex = (v, arrayOrLength) => {\n    //  UNIT TESTED\n    if (!Number.isInteger(v)) {\n        throw new TypeError(`v parameter must be an integer (${v})`);\n    }\n    const length = Array.isArray(arrayOrLength)\n        ? arrayOrLength.length\n        : arrayOrLength;\n    if (!Number.isInteger(length)) {\n        throw new TypeError(`length parameter must be an integer (${length}, ${typeof length})`);\n    }\n    v = Math.round(v);\n    if (v < 0)\n        return 0;\n    if (v >= length)\n        return length - 1;\n    return v;\n};\n/**\n * Returns the largest value, ignoring the sign of numbers\n *\n * ```js\n * maxAbs(1, 5);    // 5\n * maxAbs(-10, 5);  // -10 (since sign is ignored)\n * ```\n * @param values\n * @returns\n */\nexport const maxAbs = (...values) => {\n    let index = -1;\n    let maxA = Number.MIN_SAFE_INTEGER;\n    for (let index_ = 0; index_ < values.length; index_++) {\n        const vA = Math.abs(values[index_]);\n        if (vA > maxA) {\n            maxA = vA;\n            index = index_;\n        }\n    }\n    return values[index];\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount, offset = 0) {\n    resultThrow(integerTest(amount, ``, `amount`), integerTest(offset, ``, `offset`));\n    if (amount === 0)\n        return;\n    let index = 0;\n    do {\n        yield (amount < 0 ? -index + offset : index + offset);\n    } while (index++ < Math.abs(amount) - 1);\n}\n;\n","/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n *\n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n *\n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n *\n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport const differenceFromFixed = (initial, kind = `absolute`) => (value) => differenceFrom(kind, value, initial);\n/**\n * Returns a function which yields difference compared to last value.\n *\n * If no initial value is provided, the first difference will be returned as 0.\n *\n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n *\n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n *\n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n *\n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value\n * @returns\n */\nexport const differenceFromLast = (kind = `absolute`, initialValue = Number.NaN) => {\n    let lastValue = initialValue;\n    return (value) => {\n        const x = differenceFrom(kind, value, lastValue);\n        lastValue = value;\n        return x;\n    };\n};\n//   const compute = (v: number) => {\n//     if (Number.isNaN(lastValue)) {\n//       lastValue = v;\n//       return 0;\n//     }\n//     const d = v - lastValue;\n//     let r = 0;\n//     if (kind === `absolute`) {\n//       r = Math.abs(d);\n//     } else if (kind === `numerical`) {\n//       r = d;\n//     } else if (kind === `relative`) {\n//       r = Math.abs(d / lastValue);\n//     } else if (kind === `relativeSigned`) {\n//       r = d / lastValue;\n//     } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n//     lastValue = v;\n//     return r;\n//   }\n//   return compute;\n// }\nconst differenceFrom = (kind = `absolute`, value, from) => {\n    if (Number.isNaN(from)) {\n        return 0;\n    }\n    const d = value - from;\n    let r = 0;\n    if (kind === `absolute`) {\n        r = Math.abs(d);\n    }\n    else if (kind === `numerical`) {\n        r = d;\n    }\n    else if (kind === `relative`) {\n        r = Math.abs(d / from);\n    }\n    else if (kind === `relativeSigned`) {\n        r = d / from;\n    }\n    else\n        throw new TypeError(`Unknown kind: '${kind}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n    return r;\n};\n","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber) => {\n    if (typeof possibleNumber !== `number`)\n        return false;\n    if (Number.isNaN(possibleNumber))\n        return false;\n    return true;\n};\n","import { isValid } from './guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filterIterable(data)) {\n *  // 10\n * }\n * ```\n * @param it\n */\nexport function* filterIterable(it) {\n    for (const v of it) {\n        if (isValid(v))\n            yield v;\n    }\n}\n/**\n * Returns a function that yields _true_ if a value\n * is at least `threshold`\n * ```js\n * const t = thresholdAtLeast(50);\n * t(50); // true\n * t(0);  // false\n * t(55); // true\n * ```\n * @param threshold\n * @returns\n */\nexport const thresholdAtLeast = (threshold) => {\n    return (v) => {\n        return v >= threshold;\n    };\n};\n/**\n * Returns a function that yields _true_\n * if a number is at least _min_ and no greater than _max_\n *\n * ```js\n * const t = rangeInclusive(50, 100);\n * t(40); // false\n * t(50); // true\n * t(60); // true\n * t(100); // true\n * t(101);  // false\n * ```\n * @param min\n * @param max\n * @returns\n */\nexport const rangeInclusive = (min, max) => {\n    return (v) => {\n        return v >= min && v <= max;\n    };\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v) => {\n    if (typeof v === `function`)\n        v = v();\n    resultThrow(numberTest(v, `percentage`, `v`));\n    return 1 - v;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (interval, start = 0, end, repeating = false) {\n    if (interval <= 0)\n        throw new Error(`Interval is expected to be above zero`);\n    if (typeof end === `undefined`)\n        end = Number.MAX_SAFE_INTEGER;\n    let v = start;\n    do {\n        while (v < end) {\n            yield v;\n            v += interval;\n        }\n    } while (repeating);\n};\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (interval, start = 0, end, repeating = false, rounding) {\n    resultThrow(numberTest(interval, `nonZero`));\n    const negativeInterval = interval < 0;\n    if (end === undefined) {\n        /* no op */\n    }\n    else {\n        if (negativeInterval && start < end) {\n            throw new Error(`Interval of ${interval.toString()} will never go from ${start.toString()} to ${end.toString()}`);\n        }\n        if (!negativeInterval && start > end) {\n            throw new Error(`Interval of ${interval.toString()} will never go from ${start.toString()} to ${end.toString()}`);\n        }\n    }\n    rounding = rounding ?? 1000;\n    if (end === undefined)\n        end = Number.MAX_SAFE_INTEGER;\n    else\n        end *= rounding;\n    interval = interval * rounding;\n    do {\n        let v = start * rounding;\n        while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n            yield v / rounding;\n            v += interval;\n        }\n    } while (repeating);\n};\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (interval = 0.01, repeating = false, start = 0, end = 1) {\n    resultThrow(numberTest(interval, `percentage`, `interval`), numberTest(start, `percentage`, `start`), numberTest(end, `percentage`, `end`));\n    return numericRange(interval, start, end, repeating);\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n/**\n * Checks if a value is within range of a base value\n *\n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n *\n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n *\n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n *\n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent\n * @param baseValue\n * @param v\n * @returns\n */\nexport function isApprox(rangePercent, baseValue, v) {\n    resultThrow(numberTest(rangePercent, `percentage`, `rangePercent`));\n    // Round percentages to avoid floating point nonsense\n    const range = Math.floor(rangePercent * 100);\n    const test = (base, value) => {\n        try {\n            if (typeof value !== `number`)\n                return false;\n            if (Number.isNaN(value))\n                return false;\n            if (!Number.isFinite(value))\n                return false;\n            // Round value\n            const diff = Math.abs(value - base);\n            const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n            //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n            return relative <= range;\n        }\n        catch {\n            return false;\n        }\n    };\n    if (baseValue === undefined)\n        return test;\n    resultThrow(numberTest(baseValue, ``, `baseValue`));\n    if (v === undefined) {\n        return (value) => test(baseValue, value);\n    }\n    else {\n        return test(baseValue, v);\n    }\n}\n// export const isCloseTo = (a: number, b: number, precision = 3):Result<number,string> => {\n//   const aa = a.toPrecision(precision);\n//   const bb = b.toPrecision(precision);\n//   if (aa !== bb) return [ false, `A is not close enough to B. A: ${ a } B: ${ b } Precision: ${ precision }` ];\n//   else return [ true ];\n// }\n/**\n * Yields a function that checks if a value is close to any target value\n * ```js\n * const c = isCloseToAny(1, 10, 20, 30, 40);\n * c(11); // True - within 1 range of 10\n * c(19); // True - within 1 range of 20\n * c(0);  // False\n * ```\n *\n * Returned function accepts multiple values, returning\n * _true_ if any of them are within range\n * ```js\n * c(0, 1, 11); // Would return true based on 11\n * ```\n * @param allowedRangeAbsolute\n * @param targets\n * @returns\n */\nexport const isCloseToAny = (allowedRangeAbsolute, ...targets) => {\n    const targetsMin = targets.map(t => t - allowedRangeAbsolute);\n    const targetsMax = targets.map(t => t + allowedRangeAbsolute);\n    return (...values) => {\n        for (const v of values) {\n            for (let index = 0; index < targets.length; index++) {\n                if (v >= targetsMin[index] && v <= targetsMax[index])\n                    return true;\n            }\n        }\n        return false;\n    };\n};\n","//import { floatSource,type RandomOptions, type RandomSource } from '@ixfx/random';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { interpolate, scaler as numberScaler, scale as numberScale } from '@ixfx/numbers';\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n *\n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n *\n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n *\n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns\n */\nexport const immutable = (startingValueOrBipolar = 0) => {\n    if (typeof startingValueOrBipolar === `undefined`)\n        throw new Error(`Start value is undefined`);\n    const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n    if (startingValue > 1)\n        throw new Error(`Start value cannot be larger than 1`);\n    if (startingValue < -1)\n        throw new Error(`Start value cannot be smaller than -1`);\n    if (Number.isNaN(startingValue))\n        throw new Error(`Start value is NaN`);\n    const v = startingValue;\n    return {\n        [Symbol.toPrimitive](hint) {\n            if (hint === `number`)\n                return v;\n            else if (hint === `string`)\n                return v.toString();\n            return true;\n        },\n        value: v,\n        towardZero: (amt) => {\n            return immutable(towardZero(v, amt));\n        },\n        add: (amt) => {\n            return immutable(clamp(v + amt));\n        },\n        multiply: (amt) => {\n            return immutable(clamp(v * amt));\n        },\n        inverse: () => {\n            return immutable(-v);\n        },\n        interpolate: (amt, b) => {\n            return immutable(clamp(interpolate(amt, v, b)));\n        },\n        asScalar: (max = 1, min = 0) => {\n            return toScalar(v, max, min);\n        }\n    };\n};\n/**\n * Converts bipolar value to a scalar. That is, converts from\n * -1..1 range to 0..1.\n *\n * ```js\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n *\n * Range can be changed:\n * ```js\n * Bipolar.toScalar(0, 100); // Uses 0..100 scale, so output is 50\n * Bipolar.toScalar(0, 100, 50); // Uses 50..1000 scale, so output is 75\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue, max = 1, min = 0) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Expected v to be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Parameter is NaN`);\n    return numberScale(bipolarValue, -1, 1, min, max);\n};\n/**\n * Makes a scalar into a bipolar value.\n *\n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n *\n * Throws an error if `scalarValue` is outside 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue) => {\n    resultThrow(numberTest(scalarValue, `percentage`, `v`));\n    return (scalarValue * 2) - 1;\n};\n/**\n * Scale & clamp value to bipolar range (-1..1).\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue, inMin, inMax) => {\n    return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n};\n/**\n * Scale a number to bipolar range (-1..1). Not clamped, so we might exceed range.\n *\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scaleUnclamped(100, 0, 100); // 1\n * Bipolar.scaleUnclamped(50, 0, 100);  // 0\n * Bipolar.scaleUnclamped(0, 0, 100);   // -1\n * ```\n *\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleUnclamped = (inputValue, inMin, inMax) => {\n    return numberScaler(inMin, inMax, -1, 1)(inputValue);\n};\n/**\n * Clamp a bipolar value\n * ```js\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Param 'bipolarValue' is NaN`);\n    if (bipolarValue > 1)\n        return 1;\n    if (bipolarValue < -1)\n        return -1;\n    return bipolarValue;\n};\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n *\n * ```js\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n *\n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue, amount) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Parameter 'v' must be a number. Got: ${typeof bipolarValue}`);\n    if (typeof amount !== `number`)\n        throw new Error(`Parameter 'amt' must be a number. Got: ${typeof amount}`);\n    if (amount < 0)\n        throw new Error(`Parameter 'amt' must be positive`);\n    if (bipolarValue < 0) {\n        bipolarValue += amount;\n        if (bipolarValue > 0)\n            bipolarValue = 0;\n    }\n    else if (bipolarValue > 0) {\n        bipolarValue -= amount;\n        if (bipolarValue < 0)\n            bipolarValue = 0;\n    }\n    return bipolarValue;\n};\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { numberTest, integerTest, resultThrow } from '@ixfx/guards';\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v, min = 0, max = 360) => {\n    resultThrow(integerTest(v, undefined, `v`), integerTest(min, undefined, `min`), integerTest(max, undefined, `max`));\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    if (v > 0 && v < min)\n        v += min;\n    v -= min;\n    max -= min;\n    v = v % max;\n    if (v < 0)\n        v = max - Math.abs(v) + min;\n    return v + min;\n};\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v, min = 0, max = 1) => {\n    resultThrow(numberTest(v, ``, `min`), numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    while (v <= min || v >= max) {\n        if (v === max)\n            break;\n        if (v === min)\n            break;\n        if (v > max) {\n            v = min + (v - max);\n        }\n        else if (v < min) {\n            v = max - (min - v);\n        }\n    }\n    return v;\n};\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (min, max, fn, a, b) => {\n    let r = 0;\n    const distF = Math.abs(b - a);\n    // When b is wrapped forwards\n    const distFwrap = Math.abs(max - a + b);\n    // When b is wrapped backwards (10, 300)\n    const distBWrap = Math.abs(a + (360 - b));\n    const distMin = Math.min(distF, distFwrap, distBWrap);\n    if (distMin === distBWrap) {\n        // (10, 300) = 70\n        r = a - fn(distMin);\n    }\n    else if (distMin === distFwrap) {\n        // (300, 60) = 120\n        r = a + fn(distMin);\n    }\n    else {\n        // Forwards or backwards without wrapping\n        if (a > b) {\n            // (240,120) -- backwards\n            r = a - fn(distMin);\n        }\n        else {\n            // (120,240) -- forwards\n            r = a + fn(distMin);\n        }\n    }\n    return wrapInteger(r, min, max);\n};\n","export const piPi = Math.PI * 2;\n","import { wrap } from './wrap.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link https://api.ixfx.fun/_ixfx/modulation/interpolatorInterval/} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        resultThrow(numberTest(_a, ``, `a`), numberTest(_b, ``, `b`), numberTest(_amt, ``, `amount`));\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        resultThrow(numberTest(amount, ``, `amount`));\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link https://api.ixfx.fun/_ixfx/modulation/interpolatorInterval/}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(start, end, steps, precision) {\n    resultThrow(numberTest(start, ``, `start`), numberTest(end, ``, `end`), numberTest(steps, ``, `steps`));\n    const r = precision ? round(precision) : (v) => v;\n    const step = (end - start) / (steps - 1);\n    resultThrow(numberTest(step, ``, `step`));\n    if (!Number.isFinite(step)) {\n        throw new TypeError(`Calculated step value is infinite`);\n    }\n    for (let index = 0; index < steps; index++) {\n        const v = start + step * index;\n        yield r(v);\n    }\n}\n","export class BasicQueueMutable {\n    #store = [];\n    enqueue(data) {\n        this.#store.push(data);\n    }\n    dequeue() {\n        return this.#store.shift();\n    }\n    get data() {\n        return this.#store;\n    }\n    get size() {\n        return this.#store.length;\n    }\n}\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3) => {\n    resultThrow(numberTest(scaling, `aboveZero`, `scaling`));\n    let average = 0;\n    let count = 0;\n    return (v) => {\n        const r = numberTest(v, ``, `v`);\n        if (r.success && v !== undefined) {\n            // Valid number\n            count++;\n            average = average + (v - average) / Math.min(count, scaling);\n        }\n        return average;\n    };\n};\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from '@ixfx/numbers.js';\n * import { gaussian } from '@ixfx/modulation.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (samples = 100, weighter) => {\n    const q = new BasicQueueMutable();\n    return (v) => {\n        const r = numberTest(v);\n        if (r.success && v !== undefined) {\n            q.enqueue(v);\n            while (q.size > samples) {\n                q.dequeue();\n            }\n        }\n        return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n    };\n};\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n//   const mal = movingAverageLight(scaling);\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n//   return ma;\n// };\nconst smoothingFactor = (timeDelta, cutoff) => {\n    const r = PiPi * cutoff * timeDelta;\n    return r / (r + 1);\n};\nconst exponentialSmoothing = (smoothingFactor, value, previous) => {\n    return smoothingFactor * value + (1 - smoothingFactor) * previous;\n};\n/**\n * Noise filtering\n *\n * Algorithm: https://gery.casiez.net/1euro/\n *\n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n    let previousValue = 0;\n    let derivativeLast = 0;\n    let timestampLast = 0;\n    const compute = (value, timestamp) => {\n        timestamp ??= performance.now();\n        const timeDelta = timestamp - timestampLast;\n        // Filtered derivative\n        const s = smoothingFactor(timeDelta, cutoffDefault);\n        const valueDelta = (value - previousValue) / timeDelta;\n        const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n        // Filtered signal\n        const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n        const a = smoothingFactor(timeDelta, cutoff);\n        const smoothed = exponentialSmoothing(a, value, previousValue);\n        previousValue = smoothed;\n        derivativeLast = derivative;\n        timestampLast = timestamp;\n        return smoothed;\n    };\n    return compute;\n};\n","import { clamp, clamper } from './clamp.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (v, inMin, inMax, outMin, outMax, easing) => scaler(inMin, inMax, outMin, outMax, easing)(v);\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (inMin, inMax, outMin, outMax, easing, clamped) => {\n    resultThrow(numberTest(inMin, `finite`, `inMin`), numberTest(inMax, `finite`, `inMax`));\n    const oMax = outMax ?? 1;\n    const oMin = outMin ?? 0;\n    const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n    return (v) => {\n        if (inMin === inMax)\n            return oMax;\n        let a = (v - inMin) / (inMax - inMin);\n        if (easing !== undefined)\n            a = easing(a);\n        const x = a * (oMax - oMin) + oMin;\n        if (clampFunction)\n            return clampFunction(x);\n        return x;\n    };\n};\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns\n */\nexport const scalerNull = () => (v) => v;\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (v, inMin, inMax, outMin, outMax, easing) => {\n    if (typeof outMax === `undefined`)\n        outMax = 1;\n    if (typeof outMin === `undefined`)\n        outMin = 0;\n    if (inMin === inMax)\n        return outMax;\n    const x = scale(v, inMin, inMax, outMin, outMax, easing);\n    return clamp(x, outMin, outMax);\n};\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (percentage, outMin, outMax = 1) => {\n    resultThrow(numberTest(percentage, `percentage`, `v`), numberTest(outMin, `percentage`, `outMin`), numberTest(outMax, `percentage`, `outMax`));\n    return scale(percentage, 0, 1, outMin, outMax);\n};\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (v, outMin, outMax) => scalerPercent(outMin, outMax)(v);\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin, outMax) => {\n    return (v) => {\n        resultThrow(numberTest(v, `percentage`, `v`));\n        return scale(v, 0, 1, outMin, outMax);\n    };\n};\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n *\n * // Scale from input to output\n * s.out(50); // 0.5\n *\n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin\n * @param inMax\n * @param outMin\n * @param outMax\n * @returns\n */\nexport const scalerTwoWay = (inMin, inMax, outMin = 0, outMax = 1, clamped = false, easing) => {\n    const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n    const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n    return { out: toOut, in: toIn };\n};\n","/**\n * Calculate the min, max, total, average and count of input array `data`.\n * ```js\n * const { total, min, max, avg, count } = numberArrayCompute([ 1, 2, 3 ]);\n * ```\n * @param data\n * @param opts\n * @returns\n */\nexport const numberArrayCompute = (data, opts = {}) => {\n    if (data.length === 0) {\n        return {\n            total: Number.NaN,\n            min: Number.NaN,\n            max: Number.NaN,\n            avg: Number.NaN,\n            count: Number.NaN\n        };\n    }\n    const nonNumbers = opts.nonNumbers ?? `throw`;\n    let total = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let index = 0; index < data.length; index++) {\n        let value = data[index];\n        if (typeof value !== `number`) {\n            if (nonNumbers === `ignore`)\n                continue;\n            if (nonNumbers === `throw`)\n                throw new Error(`Param 'data' contains a non-number at index: ${index.toString()}`);\n            if (nonNumbers === `nan`)\n                value = Number.NaN;\n        }\n        if (Number.isNaN(value))\n            continue;\n        if (value !== undefined) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n            total += value;\n            count++;\n        }\n    }\n    return {\n        total, max, min, count,\n        avg: total / count\n    };\n};\n","import { scale } from './scale.js';\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { clamp } from './clamp.js';\nimport { numberArrayCompute } from './number-array-compute.js';\n/**\n * A more advanced form of {@link stream}.\n *\n * With this version\n * @example\n * ```js\n * const s = Normalise.streamWithContext();\n * s.seen(2);    // 1 (because 2 is highest seen)\n * s.seen(1);    // 0 (because 1 is the lowest so far)\n * s.seen(1.5);  // 0.5 (50% of range 1-2)\n * s.seen(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * And the more advanced features\n * ```js\n * s.min / s.max / s.range\n * s.reset();\n * s.reset(10, 100);\n * ```\n * @returns\n */\nexport const streamWithContext = (minDefault, maxDefault) => {\n    let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n    let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n    resultThrow(numberTest(min), numberTest(max));\n    return {\n        seen: (v) => {\n            resultThrow(numberTest(v));\n            min = Math.min(min, v);\n            max = Math.max(max, v);\n            return scale(v, min, max);\n        },\n        reset: (minDefault, maxDefault) => {\n            min = minDefault ?? Number.MAX_SAFE_INTEGER;\n            max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n        },\n        get min() {\n            return min;\n        },\n        get max() {\n            return max;\n        },\n        get range() {\n            return Math.abs(max - min);\n        }\n    };\n};\n/**\n * Normalises numbers, adjusting min/max as new values are processed. Return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * Use {@link streamWithContext} if you want to be able to check the min/max or reset the normaliser.\n *\n * @example\n * ```js\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault, maxDefault) => {\n    const c = streamWithContext(minDefault, maxDefault);\n    return c.seen;\n};\n/**\n * Normalises an array.\n *\n * This version returns additional context of the normalisation, alternatively use {@link array}\n *\n * ```js\n * const c = arrayWithContext(someValues);\n * c.values;    // Array of normalised values\n * c.original;  // Original input array\n * c.min / c.max / c.range\n * ```\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const arrayWithContext = (values, minForced, maxForced) => {\n    if (!Array.isArray(values)) {\n        throw new TypeError(`Param 'values' should be an array. Got: ${typeof values}`);\n    }\n    const mma = numberArrayCompute(values);\n    const min = minForced ?? mma.min;\n    const max = maxForced ?? mma.max;\n    return {\n        values: values.map((v) => clamp(scale(v, min, max))),\n        original: values,\n        min, max,\n        range: Math.abs(max - min)\n    };\n};\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range.\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * Use {@link arrayWithContext} to get back the min/max/range and original values\n *\n * ```js\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values, minForced, maxForced) => {\n    const c = arrayWithContext(values, minForced, maxForced);\n    return c.values;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n *\n * The utility of this function is that it sanity-checks that\n * both parameters are in the 0..1 scale.\n *\n * Parameters can also be a function that takes no parameters\n * and returns a number. It will be invoked when `proportion` is called.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (v, t) => {\n    if (typeof v === `function`)\n        v = v();\n    if (typeof t === `function`)\n        t = t();\n    resultThrow(numberTest(v, `percentage`, `v`), numberTest(t, `percentage`, `t`));\n    return v * t;\n};\n","import { integerTest, numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n *\n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (v, every, middleRoundsUp = true) => {\n    const everyString = every.toString();\n    const decimal = everyString.indexOf(`.`);\n    let multiplier = 1;\n    if (decimal >= 0) {\n        const d = everyString.substring(decimal + 1).length;\n        multiplier = 10 * d;\n        every = Math.floor(multiplier * every);\n        v = v * multiplier;\n    }\n    resultThrow(numberTest(v, ``, `v`), integerTest(every, ``, `every`));\n    let div = v / every;\n    const divModule = div % 1;\n    div = Math.floor(div);\n    if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5)\n        div++;\n    const vv = (every * div) / multiplier;\n    return vv;\n};\n","import { scaler } from \"./scale.js\";\n/**\n * Computes min/max based on a new value and previous range.\n * Returns existing object reference if value is within existing range.\n *\n * If `value` is not a number, by default it will be ignored. Use the 'nonNumberHandling' param to set it\n * to throw an error instead if you want to catch that\n * @param value Value to compare against range\n * @param previous Previous range\n * @param nonNumberHandling 'skip' (default), non numbers are ignored; 'error' an error is thrown\n * @returns\n */\nexport function rangeMergeValue(value, previous, nonNumberHandling = `skip`) {\n    if (typeof value === `number`) {\n        if (Number.isNaN(value) || !Number.isFinite(value)) {\n            if (nonNumberHandling === `error`)\n                throw new TypeError(`Param 'value' is NaN or infinite, and nonNumberHandling is set to 'error'`);\n            return previous;\n        }\n        // Skip creating an object if it's in range\n        if (value >= previous.min && value <= previous.max)\n            return previous;\n        // Return new range\n        return {\n            min: Math.min(value, previous.min),\n            max: Math.max(value, previous.max),\n        };\n    }\n    else if (nonNumberHandling === `error`) {\n        throw new TypeError(`Param 'value' is not a number (type: '${typeof value}') and nonNumberHandling is set to 'error'`);\n    }\n    return previous;\n}\n/**\n * Returns a function that scales values in a range, by default on 0..1 scale.\n * ```js\n * const range = { min: 10, max: 20 }\n * const s = rangeScaler(range);\n * s(15); // 0.5\n * ```\n * @param range Range to scale on\n * @param outMax Output range max. Default: 1\n * @param outMin Output range min. Default: 0\n * @param easing Easing function: Default: none\n * @param clamped Whether input values should be clamped if they exceed range. Default: true\n * @returns\n */\nexport function rangeScaler(range, outMax = 1, outMin = 0, easing, clamped = true) {\n    return scaler(range.min, range.max, outMin, outMax, easing, clamped);\n}\n/**\n * Expands a range to encompass a new range.\n * Returns `existingRange` if `newRange` is within it.\n * @param newRange\n * @param existingRange\n * @returns\n */\nexport function rangeMergeRange(newRange, existingRange) {\n    if (newRange.max <= existingRange.max && newRange.min >= existingRange.min)\n        return existingRange;\n    return {\n        min: Math.min(newRange.min, existingRange.min),\n        max: Math.max(newRange.max, existingRange.max)\n    };\n}\n/**\n * Returns an empty range:\n * ```js\n * {\n *  min: Number.MAX_SAFE_INTEGER,\n *  max: Number.MIN_SAFE_INTEGER\n * }\n * ```\n * @returns\n */\nexport const rangeInit = () => ({ min: Number.MAX_SAFE_INTEGER, max: Number.MIN_SAFE_INTEGER });\n/**\n * Returns _true_ if ranges `a` and `b` have identical min/max values.\n * Returns _false_ if not, or if either/both values are _undefined_\n * @param a\n * @param b\n * @returns\n */\nexport const rangeIsEqual = (a, b) => {\n    if (typeof a === `undefined`)\n        return false;\n    if (typeof b === `undefined`)\n        return false;\n    return (a.max === b.max && a.min === b.min);\n};\n/**\n * Returns _true_ if range 'a' is within or same as range 'b'.\n * Returns _false_ if not or if either/both ranges are _undefined_\n * @param a\n * @param b\n * @returns\n */\nexport const rangeIsWithin = (a, b) => {\n    if (typeof a === `undefined`)\n        return false;\n    if (typeof b === `undefined`)\n        return false;\n    if (a.min >= b.min && a.max <= b.max)\n        return true;\n    return false;\n};\n/**\n * Keeps track of min/max values.\n *\n * ```js\n * const s = rangeStream();\n * s.seen(10);  // { min: 10, max: 10}\n * s.seen(5);   // { min:5, max: 10}\n * ```\n *\n * When calling `seen`, non-numbers, or non-finite numbers are silently ignored.\n *\n * ```js\n * s.reset();   // Reset\n * s.min/s.max; // Current min/max\n * s.range;     // Current { min, max }\n * ```\n * @param initWith\n * @returns\n */\nexport const rangeStream = (initWith = rangeInit()) => {\n    let { min, max } = initWith;\n    const seen = (v) => {\n        if (typeof v === `number`) {\n            if (!Number.isNaN(v) && Number.isFinite(v)) {\n                min = Math.min(min, v);\n                max = Math.max(max, v);\n            }\n        }\n        return { min, max };\n    };\n    const reset = () => {\n        min = Number.MAX_SAFE_INTEGER;\n        max = Number.MIN_SAFE_INTEGER;\n    };\n    return {\n        seen, reset,\n        get range() {\n            return { min, max };\n        },\n        get min() {\n            return min;\n        },\n        get max() {\n            return max;\n        }\n    };\n};\n/**\n * Iterates over `values` finding the min/max.\n * By default non-numbers, as well as NaN and infinite values are skipped.\n * @param values\n * @param nonNumberHandling\n * @returns\n */\nexport function rangeCompute(values, nonNumberHandling = `skip`) {\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let position = 0;\n    for (const v of values) {\n        if (typeof v === `number`) {\n            if (Number.isNaN(v) || !Number.isFinite(v)) {\n                if (nonNumberHandling === `error`)\n                    throw new Error(`Value NaN or infinite at position: ${position}`);\n                continue;\n            }\n        }\n        else {\n            if (nonNumberHandling === `error`)\n                throw new Error(`Contains non number value. Type: '${typeof v}' Position: ${position}`);\n            continue;\n        }\n        if (v < min)\n            min = v;\n        if (v > max)\n            max = v;\n        position++;\n    }\n    return { min, max };\n}\n","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits\n * @returns\n */\nexport const softmax = (logits) => {\n    const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n    const scores = logits.map((l) => Math.exp(l - maxLogit));\n    const denom = scores.reduce((a, b) => a + b);\n    return scores.map((s) => s / denom);\n};\n","export const trackSimple = () => {\n    let count = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let total = 0;\n    const seen = (v) => {\n        min = Math.min(v, min);\n        max = Math.max(v, max);\n        total += v;\n        count++;\n    };\n    const reset = () => {\n        count = 0;\n        min = Number.MAX_SAFE_INTEGER;\n        max = Number.MIN_SAFE_INTEGER;\n        total = 0;\n    };\n    const rangeToString = (digits = 2) => {\n        return `${min.toFixed(2)} - ${max.toFixed(2)}`;\n    };\n    return {\n        seen, reset, rangeToString,\n        get avg() {\n            return total / count;\n        },\n        get min() {\n            return min;\n        },\n        get max() {\n            return max;\n        },\n        get total() {\n            return total;\n        },\n        get count() {\n            return count;\n        }\n    };\n};\n","export * from './apply-to-values.js';\nexport * from './average-weighted.js';\nexport * from './clamp.js';\nexport * from './count.js';\nexport * from './difference.js';\nexport * from './filter.js';\nexport * from './flip.js';\nexport * from './generate.js';\nexport * from './guard.js';\nexport * from './is-approx.js';\nexport * as Bipolar from './bipolar.js';\nexport * from './interpolate.js';\nexport * from './linear-space.js';\nexport * from './moving-average.js';\nexport * as Normalise from './normalise.js';\nexport * from './number-array-compute.js';\nexport * from './numeric-arrays.js';\nexport * from './proportion.js';\nexport * from './quantise.js';\nexport * from './range.js';\nexport * from './round.js';\nexport * from './scale.js';\nexport * from './softmax.js';\nexport * from './track-simple.js';\nexport * from './wrap.js';\nexport * from './types.js';\n","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = (a) => {\n    return typeof a === `string` ? a : JSON.stringify(a);\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Whittles down from whole string to last token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToEnd(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const trimmed = afterMatch(source, delimiter);\n        if (trimmed === source) {\n            // Delimiter not found\n            break;\n        }\n        source = trimmed;\n    }\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Starts with last token, builds to whole.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsLastToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n        if (ba[0] === ba[1] && ba[1] === source) {\n            // Delimiter not found\n            break;\n        }\n        const v = ba[1] + accumulator;\n        yield v;\n        accumulator = delimiter + v;\n        source = ba[0];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with the first token and build up until end.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsFirstToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n        if (ba[0] === source && ba[1] === source)\n            break;\n        accumulator += ba[0];\n        yield accumulator;\n        accumulator += delimiter;\n        source = ba[1];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with whole string and whittle down to starting token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToFirst(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n        if (b === source)\n            break;\n        source = b;\n    }\n}\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n *\n * If `source` is under `maxLength` the original is returned.\n * @param source\n * @param maxLength Maximum length. Defaults to 20\n * @returns\n */\nexport const abbreviate = (source, maxLength = 15) => {\n    resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (source.length > maxLength && source.length > 3) {\n        if (maxLength > 15) {\n            const chunk = Math.round((maxLength - 2) / 2);\n            return source.slice(0, chunk) + `...` + source.slice(-chunk);\n        }\n        return source.slice(0, maxLength) + `...`;\n    }\n    return source;\n};\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns\n */\nexport const toStringAbbreviate = (source, maxLength = 20) => {\n    if (source === undefined)\n        return `(undefined)`;\n    if (source === null)\n        return `(null)`;\n    return abbreviate(JSON.stringify(source), maxLength);\n};\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (source, start, end, lastEndMatch = true) => {\n    //  Unit tested\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return;\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return;\n    return source.slice(startPos + 1, endPos);\n};\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (source, start, end, lastEndMatch = true) => {\n    //  Unit tested\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (typeof start !== `string`)\n        throw new Error(`Parameter 'start' is not a string`);\n    if (end !== undefined && typeof end !== `string`)\n        throw new Error(`Parameter 'end' is not a string`);\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return [source, undefined];\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return [source, undefined];\n    const between = source.slice(startPos + 1, endPos);\n    const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n    return [sourceResult, between];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {\n    for (let index = start; index <= end; index++) {\n        if (source.codePointAt(index) === code)\n            return index;\n    }\n    return -1;\n};\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) +\n    source.slice(removeStart + removeLength);\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (source, length) => {\n    resultThrow(integerTest(length, `aboveZero`, `length`));\n    if (source === null)\n        throw new Error(`source parameter null`);\n    if (typeof source !== `string`) {\n        throw new TypeError(`source parameter not a string`);\n    }\n    //  Unit tested\n    const chunks = Math.ceil(source.length / length);\n    const returnValue = [];\n    let start = 0;\n    for (let c = 0; c < chunks; c++) {\n        returnValue.push(source.slice(start, start + length));\n        start += length;\n    }\n    return returnValue;\n};\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n//   //   Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[0];\n};\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[1];\n};\n/**\n * Returns the text that is before and after `match`.\n *\n * See also: {@link beforeMatch}, {@link afterMatch}.\n *\n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeAfterMatch = (source, match, options = {}) => {\n    if (source === undefined)\n        throw new Error(`Param 'source' is undefined`);\n    let fallback = options.fallback;\n    const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n    if (ifNoMatch === `original`)\n        fallback = source;\n    if (ifNoMatch === `fallback` && fallback === undefined)\n        throw new Error(`Fallback must be provided`);\n    const startPos = options.startPos ?? undefined;\n    const fromEnd = options.fromEnd ?? false;\n    const m = fromEnd\n        ? source.lastIndexOf(match, startPos)\n        : source.indexOf(match, startPos);\n    if (m < 0 && ifNoMatch === `throw`)\n        throw new Error(`Match '${match}' not found in source.`);\n    if (m < 0 && ifNoMatch === `original`)\n        return [source, source];\n    if (m < 0 && ifNoMatch === `fallback`) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return [fallback, fallback];\n    }\n    return [\n        source.slice(0, m),\n        source.slice(Math.max(0, m + match.length))\n    ];\n};\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (source, ...wrappers) => {\n    let matched = false;\n    do {\n        matched = false;\n        for (const w of wrappers) {\n            if (source.startsWith(w) && source.endsWith(w)) {\n                source = source.slice(w.length, source.length - w.length * 2 + 1);\n                matched = true;\n            }\n        }\n    } while (matched);\n    return source;\n};\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges, start, end) => {\n    let s = -1;\n    let endPos = -1;\n    for (const [index, r] of ranges.entries()) {\n        s = index;\n        if (r.text.length === 0)\n            continue;\n        if (start < r.end) {\n            break;\n        }\n    }\n    for (let index = s; index < ranges.length; index++) {\n        const r = ranges[index];\n        endPos = index;\n        if (end === r.end) {\n            endPos = index + 1;\n            break;\n        }\n        if (end < r.end) {\n            break;\n        }\n    }\n    return { length: endPos - s, start: s, end: endPos };\n};\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (source, split) => {\n    let start = 0;\n    let text = ``;\n    const ranges = [];\n    let index = 0;\n    for (let index_ = 0; index_ < source.length; index_++) {\n        if (source.indexOf(split, index_) === index_) {\n            const end = index_;\n            ranges.push({\n                text,\n                start,\n                end,\n                index,\n            });\n            start = end + 1;\n            text = ``;\n            index++;\n        }\n        else {\n            text += source.charAt(index_);\n        }\n    }\n    if (start < source.length) {\n        ranges.push({ text, start, index, end: source.length });\n    }\n    return ranges;\n};\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (source, ...chars) => {\n    let counted = 0;\n    for (let index = 0; index < source.length; index++) {\n        if (chars.includes(source.charAt(index))) {\n            counted++;\n        }\n        else {\n            break;\n        }\n    }\n    return counted;\n};\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);\nexport const htmlEntities = (source) => source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${index.codePointAt(0)};`);\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern\n * @returns\n */\nexport const wildcard = (pattern) => {\n    // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n    // for this solution to work on any string, no matter what characters it has\n    const escapeRegex = (value) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n    // \".\"  => Find a single character, except newline or line terminator\n    // \".*\" => Matches any string that contains zero or more characters\n    pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n    // \"^\"  => Matches any string with the following at the beginning of it\n    // \"$\"  => Matches any string with that in front at the end of it\n    pattern = `^` + pattern + `$`;\n    // Create a regular expression object for matching string\n    const regex = new RegExp(pattern);\n    return (value) => {\n        // Returns true if it finds a match, otherwse it returns false\n        return regex.test(value);\n    };\n};\n","export const isAsyncIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.asyncIterator in v;\n};\nexport const isIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.iterator in v;\n};\n","export function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    if (start < 0)\n        throw new Error(`Param 'start' should be at least 0`);\n    let index = 0;\n    for (const v of it) {\n        if (index < start) {\n            index++;\n            continue;\n        }\n        if (index > end) {\n            break;\n        }\n        yield v;\n        index++;\n    }\n}\n","export function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for (const v of it)\n        start = f(start, v);\n    return start;\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { isIterable } from './guard.js';\nexport { slice } from './sync/slice.js';\nexport { reduce } from './sync/reduce.js';\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    for (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(generator, defaultValue) {\n    return () => {\n        const v = generator.next().value;\n        if (v === undefined)\n            return defaultValue;\n        return v;\n    };\n}\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first(it) {\n    for (const value of it) {\n        return value;\n    }\n}\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last(it) {\n    let returnValue;\n    for (const value of it) {\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping(it, size) {\n    if (size <= 1)\n        throw new Error(`Size should be at least 2`);\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer = [buffer.at(-1)];\n        }\n    }\n    if (buffer.length <= 1)\n        return;\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* chunks(it, size) {\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* concat(...its) {\n    for (const it of its)\n        yield* it;\n}\nexport function* dropWhile(it, f) {\n    for (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it, callback) => {\n    for (const _ of it) {\n        const value = callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\nexport const next = (it) => {\n    return () => {\n        const r = it.next();\n        if (r.done)\n            return;\n        return r.value;\n    };\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    //it1 = it1[Symbol.iterator]();\n    //it2 = it2[Symbol.iterator]();\n    while (true) {\n        const index1 = it1.next(), index2 = it2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport function every(it, f) {\n    for (const v of it) {\n        const result = f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for (const _ of it)\n        yield v;\n}\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * import { Sync } from \"@ixfx/iterables.js\"\n * Sync.forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * Sync.forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * Sync.forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEach} if you want to use an async `iterator` and async `fn`.\n *\n * Alternatives:\n * * {@link https://api.ixfx.fun/_ixfx/flow/repeat/ @ixfx/flow.repeat}/{@link https://api.ixfx.fun/_ixfx/flow/repeatSync/ @ixfx/flow.repeatSync}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam T Type of iterable's values\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport function forEach(iterator, fn) {\n    for (const v of iterator) {\n        const result = fn(v);\n        if (typeof result === `boolean` && !result)\n            break;\n    }\n}\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (!f(v))\n            continue;\n        yield v;\n    }\n}\nexport function find(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return v;\n    }\n}\nexport function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\nexport function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        yield f(v);\n    }\n}\nexport function* max(it, gt = (a, b) => a > b) {\n    let max;\n    for (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield max;\n            continue;\n        }\n        if (gt(v, max)) {\n            max = v;\n            yield max;\n        }\n    }\n    return max;\n}\nexport function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n        }\n        if (gt(min, v)) {\n            min = v;\n            yield min;\n        }\n    }\n}\nexport function some(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return true;\n    }\n    return false;\n}\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\nexport function* repeat(genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n}\nexport function* unique(iterable) {\n    // Adapted from https://surma.github.io/underdash/\n    const buffer = [];\n    let itera = [];\n    itera = Array.isArray(iterable) ? iterable : [iterable];\n    for (const it of itera) {\n        for (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.iterator]());\n    while (true) {\n        const vs = iits.map((it) => it.next());\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\nexport function* fromIterable(iterable) {\n    for (const v of iterable) {\n        yield v;\n    }\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    const result = [];\n    const started = Date.now();\n    const whileFunction = options.while;\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    for (const v of it) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        if (result.length >= maxItems)\n            break;\n        if (Date.now() - started > maxElapsed)\n            break;\n        result.push(v);\n    }\n    return result;\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray(array) {\n    for (const v of array) {\n        yield v;\n    }\n}\n","export class MapOfSimple {\n    #store = new Map();\n    /**\n     * Gets a copy of the underlying array storing values at `key`, or an empty array if\n     * key does not exist\n     * @param key\n     * @returns\n     */\n    get(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return [];\n        return [...arr];\n    }\n    /**\n     * Returns the number of values stored under `key`\n     * @param key\n     * @returns\n     */\n    size(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return 0;\n        return arr.length;\n    }\n    /**\n     * Iterate over all values contained under `key`\n     * @param key\n     * @returns\n     */\n    *iterateKey(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return;\n        yield* arr.values();\n    }\n    /**\n     * Iterate all values, regardless of key\n     */\n    *iterateValues() {\n        for (const key of this.#store.keys()) {\n            yield* this.iterateKey(key);\n        }\n    }\n    /**\n     * Iterate all keys\n     */\n    *iterateKeys() {\n        yield* this.#store.keys();\n    }\n    addKeyedValues(key, ...values) {\n        let arr = this.#store.get(key);\n        if (!arr) {\n            arr = [];\n            this.#store.set(key, arr);\n        }\n        arr.push(...values);\n    }\n    deleteKeyValue(key, value) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return false;\n        const arrCopy = arr.filter(v => v !== value);\n        if (arrCopy.length === arr.length)\n            return false;\n        this.#store.set(key, arrCopy);\n        return true;\n    }\n    clear() {\n        this.#store.clear();\n    }\n}\n","import { MapOfSimple } from \"./map-of.js\";\nexport class SimpleEventEmitter {\n    #listeners = new MapOfSimple();\n    #disposed = false;\n    dispose() {\n        if (this.#disposed)\n            return;\n        this.clearEventListeners();\n    }\n    get isDisposed() {\n        return this.#disposed;\n    }\n    /**\n     * Fire event\n     * @param type Type of event\n     * @param args Arguments for event\n     * @returns\n     */\n    fireEvent(type, args) {\n        if (this.#disposed)\n            throw new Error(`Disposed`);\n        //console.log(`Firing ${ type as string }. Listeners: ${ this.#listeners.size(type as string) }`);\n        for (const l of this.#listeners.iterateKey(type)) {\n            l(args, this);\n        }\n    }\n    /**\n     * Adds event listener.\n     *\n     * @throws Error if emitter is disposed\n     * @typeParam K - Events\n     * @param name Event name\n     * @param listener Event handler\n     */\n    addEventListener(name, listener) {\n        if (this.#disposed)\n            throw new Error(`Disposed`);\n        this.#listeners.addKeyedValues(name, listener);\n    }\n    /**\n     * Remove event listener\n     *\n     * @param listener\n     */\n    removeEventListener(type, listener) {\n        if (this.#disposed)\n            return;\n        // listener: Listener<Events>): void {\n        this.#listeners.deleteKeyValue(type, listener);\n    }\n    /**\n     * Clear all event listeners\n     * @private\n     */\n    clearEventListeners() {\n        if (this.#disposed)\n            return;\n        this.#listeners.clear();\n    }\n}\n","export { SimpleEventEmitter } from './simple-event-emitter.js';\nexport * from './types.js';\n","import { intervalToMs, toStringDefault } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\nimport { isAsyncIterable, isIterable } from './guard.js';\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray(array, interval = 1) {\n    for (const v of array) {\n        yield v;\n        await sleep(interval);\n    }\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable(iterable, interval = 1) {\n    for await (const v of iterable) {\n        yield v;\n        await sleep(interval);\n    }\n}\nexport async function* chunks(it, size) {\n    // Source: https://surma.github.io/underdash/\n    let buffer = [];\n    for await (const v of it) {\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport async function* concat(...its) {\n    // Source: https://surma.github.io/underdash/\n    for await (const it of its)\n        yield* it;\n}\nexport async function* dropWhile(it, f) {\n    for await (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n *\n * In this version, we do a `for await of` over `gen`, and also `await callback()`.\n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n *\n * If you want the value from the generator, use a `for of` loop as usual.\n *\n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it, callback) => {\n    for await (const _ of it) {\n        const value = await callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n *\n * For example, {@link https://api.ixfx.fun/_ixfx/numbers/count/ @ixfx/numbers.count} will count from 0..number and then finish:\n * ```js\n * import { count } from '@ixfx/numbers'\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n *\n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n *\n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n *\n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator\n * @param repeatsOrSignal\n */\nexport const repeat = async function* (genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for await (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals(it1, it2, equality) {\n    // https://surma.github.io/underdash/\n    const iit1 = it1[Symbol.asyncIterator](); // it1[ Symbol.iterator ]();\n    const iit2 = it2[Symbol.asyncIterator]();\n    while (true) {\n        const index1 = await iit1.next();\n        const index2 = await iit2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport async function every(it, f) {\n    for await (const v of it) {\n        const result = await f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport async function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for await (const _ of it)\n        yield v;\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (!await f(v))\n            continue;\n        yield v;\n    }\n}\nexport async function find(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return v;\n    }\n}\nexport async function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isAsyncIterable(v)) {\n                for await (const vv of v) {\n                    yield vv;\n                }\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"@ixfx/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function (iterator, fn, options = {}) {\n    const interval = options.interval;\n    if (Array.isArray(iterator)) {\n        // Handle array\n        for (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n    else {\n        // Handle an async iterator\n        for await (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n};\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last(it, opts = {}) {\n    const abort = opts.abort;\n    let returnValue;\n    for await (const value of it) {\n        if (abort?.aborted)\n            return undefined;\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport async function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        yield f(v);\n    }\n}\nexport async function* max(it, gt = ((a, b) => a > b)) {\n    let max;\n    for await (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield (max);\n            continue;\n        }\n        // If V is bigger than max, we have a new max\n        if (gt(v, max)) {\n            max = v;\n            yield v;\n        }\n    }\n}\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n *\n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for await (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n            continue;\n        }\n        // If min is bigger than V, V is the new min\n        if (gt(min, v)) {\n            min = v;\n            yield v;\n        }\n    }\n    return min;\n}\nexport async function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for await (const v of it)\n        start = f(start, v);\n    return start;\n}\n/**\n * Calls `callback` whenever the async generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport async function asCallback(input, callback, onDone) {\n    for await (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\nexport async function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    console.log(`Async slice start: ${start}`);\n    // https://surma.github.io/underdash/\n    const iit = it[Symbol.asyncIterator]();\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    for (; start > 0; start--, end--)\n        await iit.next();\n    for await (const v of it) {\n        if (end-- > 0) {\n            yield v;\n        }\n        else {\n            break;\n        }\n    }\n}\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it\n * @param delay\n */\nexport async function* withDelay(it, delay) {\n    for (const v of it) {\n        await sleep(delay);\n        yield v;\n    }\n}\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout(it, options) {\n    const ms = intervalToMs(options, 1000);\n    const value = await Promise.race([\n        (async () => {\n            await sleep({ millis: ms, signal: options.signal });\n            return undefined;\n        })(),\n        (async () => {\n            return await it.next();\n        })()\n    ]);\n    if (value === undefined)\n        throw new Error(`Timeout`);\n    return value;\n}\nexport async function some(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return true;\n    }\n    return false;\n}\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray(it, options = {}) {\n    // https://2ality.com/2016/10/asynchronous-iteration.html\n    const result = [];\n    const iterator = it[Symbol.asyncIterator]();\n    const started = Date.now();\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const whileFunction = options.while;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        const r = await iterator.next();\n        if (r.done)\n            break;\n        //eslint-disable-next-line functional/immutable-data\n        result.push(r.value);\n    }\n    return result;\n}\nexport async function* unique(iterable) {\n    const buffer = [];\n    const itera = Array.isArray(iterable) ? iterable : [iterable];\n    for await (const it of itera) {\n        for await (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\nexport async function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for await (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.asyncIterator]());\n    while (true) {\n        const vs = await Promise.all(iits.map((it) => it.next()));\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\n","import * as Async from \"../async.js\";\nimport { isAsyncIterable } from \"../index.js\";\nimport { sleep } from \"@ixfx/core\";\nexport function isGenFactoryNoInput(c) {\n    if (!(`_type` in c))\n        return false;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (c._type === `GenFactoryNoInput`)\n        return true;\n    return false;\n}\n/**\n * Wrap the primitive value as generator\n * @param value\n */\nfunction* primitiveToGenerator(value) {\n    yield value;\n}\n/**\n * Wrap the primitive value as an async generator\n * @param value\n */\nasync function* primitiveToAsyncGenerator(value) {\n    yield value;\n    await sleep(1);\n}\n/**\n * Resolve the array, data or function to a Generator\n * @param input\n * @returns\n */\nexport function resolveToGen(input) {\n    if (Array.isArray(input)) {\n        const a = input.values();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        a._name = `arrayInput`;\n        return a;\n    }\n    else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n        // Assumes V is primitive\n        return primitiveToGenerator(input);\n    }\n    else if (typeof input === `function`) {\n        return input();\n    }\n    return input;\n}\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input\n * @returns\n */\nexport function resolveToAsyncGen(input) {\n    if (input === undefined)\n        return;\n    if (Array.isArray(input)) {\n        return Async.fromArray(input);\n    }\n    else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n        // Assumes V is primitive\n        return primitiveToAsyncGenerator(input);\n    }\n    else if (typeof input === `function`) {\n        return input();\n    }\n    else if (isAsyncIterable(input)) {\n        return input;\n    }\n    return Async.fromIterable(input);\n}\n","export function resolveEl(elOrQuery) {\n    if (typeof elOrQuery === `string`) {\n        const el = document.querySelector(elOrQuery);\n        if (!el)\n            throw new Error(`Element not found '${elOrQuery}'`);\n        return el;\n    }\n    return elOrQuery;\n}\n","import { toStringDefault } from \"@ixfx/core\";\nimport { resolveToGen } from \"./utility.js\";\nimport { resolveEl } from \"../util/dom.js\";\nconst createMap = (key) => {\n    const keyFunction = key ?? ((value) => value);\n    const map = new Map();\n    return {\n        has(key) {\n            return map.has(keyFunction(key));\n        },\n        get(key) {\n            return map.get(keyFunction(key));\n        },\n        set(key, value) {\n            //console.log(`Chains.Dom.createMap: key: ${ keyFunction(key) } value: ${ value }`);\n            map.set(keyFunction(key), value);\n        },\n        entries() {\n            return map.entries();\n        },\n        delete(key) {\n            map.delete(key);\n        }\n    };\n};\n/**\n * Creates a HTML element per value. By default compares\n * values by `JSON.stringify`. Set `byReference:true` to\n * compare values based on reference. Or provide a toString\n * function via `key`.\n *\n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n *\n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n * ```\n */\nexport function perValue(options = {}) {\n    const byReference = options.byReference;\n    const tagName = options.tagName ?? `div`;\n    if (byReference && options.key)\n        throw new Error(`byReference and key options are mutually exclusive`);\n    const keyFunction = byReference ? undefined : options.key ?? toStringDefault;\n    const map = createMap(keyFunction);\n    const parentElementOrQuery = options.parentEl ?? document.body;\n    const parentEl = resolveEl(parentElementOrQuery);\n    const usedElements = new Set();\n    async function* perValue(input) {\n        for await (const value of resolveToGen(input)) {\n            let el = map.get(value);\n            if (!el) {\n                el = document.createElement(tagName);\n                map.set(value, el);\n                if (options.beforeInsert)\n                    options.beforeInsert(el);\n                parentEl.append(el);\n                if (options.afterInsert)\n                    options.afterInsert(el);\n            }\n            usedElements.add(el);\n            yield { el, value };\n        }\n        // Remove unused elements\n        for (const [id, el] of map.entries()) {\n            if (usedElements.has(el))\n                continue;\n            if (options.beforeRemove)\n                options.beforeRemove(el);\n            el.remove();\n            map.delete(id);\n        }\n    }\n    perValue._name = `dom.perValue`;\n    return perValue;\n}\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options\n * @returns\n */\nexport function query(options = {}) {\n    const baseElement = options.baseElement ?? document;\n    async function* query(input) {\n        const gen = resolveToGen(input);\n        for await (const value of gen) {\n            for (const element of baseElement.querySelectorAll(value)) {\n                yield element;\n            }\n        }\n    }\n    query._name = `dom.query`;\n    return query;\n}\n","import { intervalToMs, sleep, elapsedSince } from \"@ixfx/core\";\nimport { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { resolveToGen } from \"./utility.js\";\nimport * as BasicProcessors from \"@ixfx/process/basic\";\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer\n * @returns\n */\nexport function transform(transformer) {\n    async function* transform(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            yield transformer(value);\n        }\n    }\n    transform._name = `transform`;\n    return transform;\n}\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit\n * @returns\n */\nexport function take(limit) {\n    async function* take(input) {\n        input = resolveToGen(input);\n        let yielded = 0;\n        for await (const value of input) {\n            if (++yielded > limit)\n                break;\n            yield value;\n        }\n    }\n    take._name = `take`;\n    return take;\n}\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `reducer` function.\n *\n * ```js\n * // Create a chain that flattens values\n * const reduce = Chains.reduce(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(reduce, [ 1, 2, 3]); // 3\n * ```\n * @param reducer Function to reduce array of values to a single value\n * @returns\n */\nexport function reduce(reducer) {\n    async function* reduce(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            yield reducer(value);\n        }\n    }\n    reduce._name = `reduce`;\n    return reduce;\n}\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed\n * @returns\n */\nexport function duration(elapsed) {\n    const durationMs = intervalToMs(elapsed, 0);\n    async function* duration(input) {\n        input = resolveToGen(input);\n        const elapsed = elapsedSince();\n        for await (const value of input) {\n            if (elapsed() > durationMs)\n                break;\n            yield value;\n        }\n    }\n    duration._name = `duration`;\n    return duration;\n}\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options\n * @returns\n */\nexport function delay(options) {\n    const before = intervalToMs(options.before, 0);\n    const after = intervalToMs(options.after, 0);\n    async function* delay(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            if (before > 0) {\n                await sleep(before);\n            }\n            yield value;\n            if (after > 0) {\n                await sleep(after);\n            }\n        }\n    }\n    delay._name = `delay`;\n    return delay;\n}\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n *\n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.run(\n *  // Produce values every 10ms for 350ms\n *  Chains.From.timestamp({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.Links.debounce(100)\n * );\n * ```\n * @param rate\n * @returns\n */\nexport function debounce(rate) {\n    const rateMs = intervalToMs(rate, 0);\n    async function* debounce(input) {\n        input = resolveToGen(input);\n        let elapsed = elapsedSince();\n        for await (const value of input) {\n            if (elapsed() < rateMs)\n                continue;\n            yield value;\n            elapsed = elapsedSince();\n        }\n    }\n    debounce._name = `debounce`;\n    return debounce;\n}\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * ```js\n * const ch = Chains.run(\n *  Chains.From.timestamp({ interval: 100 }),\n *  Chains.Links.tally()\n * );\n *\n * for await (const v of ch) {\n *   // Produces: 1, 2, 3 ... every 100ms\n * }\n * ```\n * This is different than {@link sum} which adds up numeric values.\n * By default it adds up individual array items\n * @returns\n */\nexport function tally(countArrayItems = true) {\n    async function* tally(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.tally(countArrayItems);\n        for await (const v of input) {\n            yield p(v);\n        }\n    }\n    tally._name = `tally`;\n    return tally;\n}\n/**\n * Returns the smallest value from the input.\n * Can work with numbers or number[] as input.\n * Non-numeric data is filtered out.\n * @returns\n */\nexport function min() {\n    async function* min(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.min();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    min._name = `min`;\n    return min;\n}\n/**\n * Returns the largest value from the input.\n * - Non-numeric data is filtered out.\n * - Looks inside of numeric arrays.\n * @returns\n */\nexport function max() {\n    async function* max(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.max();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    max._name = `max`;\n    return max;\n}\n// export function max(): Link<number | Array<number>, number> {\n//   async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n//     input = resolveToGen(input);\n//     let max = Number.MIN_SAFE_INTEGER;\n//     for await (const value of input) {\n//       const valueArray = Array.isArray(value) ? value : [ value ];\n//       for (const subValue of valueArray) {\n//         if (typeof subValue !== `number`) break;\n//         max = Math.max(subValue, max);\n//         yield max;\n//       }\n//     }\n//   }\n//   max._name = `max`;\n//   return max;\n// }\n/**\n * Emits the currently ranked 'highest' value from a stream. Only\n * values exceeding the current highest are emitted.\n *\n * eg, if we are ranking on numerical value, an input stream of:\n * ```\n * 4, 1, 6, 10, 2, 4\n * ```\n *\n * Results in the output stream of:\n * ```\n * 4, 6, 10\n * ```\n *\n * @example\n * ```js\n * // Rank based on a field\n * Chains.Links.rank((a,b) => {\n *  if (a.size > b.size) return `a`; // Signals the first param is highest\n *  if (a.size < b.size) return `b`; // Signals the second param is highest\n *  return `eq`;\n * });\n * ```\n * @param options\n * @returns\n */\nexport function rank(r, options = {}) {\n    async function* rank(input) {\n        input = resolveToGen(input);\n        //let best: In | undefined;\n        const p = BasicProcessors.rank(r, options);\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    rank._name = `rank`;\n    return rank;\n}\n/**\n * Emits the highest-ranked value from amongst an array of values.\n *\n * By default, it tracks the highest-ranked _between_ arrays.\n *\n * For example:\n * ```js\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Outputs:\n * [ 6 ]\n * ```\n *\n * This behaviour can be modified with an option to only compare _within_ arrays.\n * ```\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Output:\n * [ 6, 3 ]\n * ```\n *\n * Uses the `rank` option to determine which is more highly ranked.\n * ```js\n * Chains.Links.rankArray(\n *  (a, b) => {\n *    if (a > b) return `a`; // a is higher\n *    else if (b > a) return `b`; // b is higher\n *    return `eq`; // same\n *  }\n * )\n * ```\n * @param options\n * @returns\n */\nexport function rankArray(r, options = {}) {\n    const includeType = options.includeType;\n    const emitEqualRanked = options.emitEqualRanked ?? false;\n    const emitRepeatHighest = options.emitRepeatHighest ?? false;\n    const withinArrays = options.withinArrays ?? false;\n    async function* rankArray(input) {\n        input = resolveToGen(input);\n        let best;\n        for await (const value of input) {\n            let emit = false;\n            if (withinArrays)\n                best = undefined; // Reset\n            for (const subValue of value) {\n                if (includeType && typeof subValue !== includeType)\n                    continue;\n                if (best === undefined) {\n                    best = subValue;\n                    emit = true;\n                }\n                else {\n                    const result = r(subValue, best);\n                    if (result == `a`) {\n                        // New value is the current best\n                        best = subValue;\n                        emit = true;\n                    }\n                    else if (result === `eq` && emitEqualRanked) {\n                        // New value is same rank as previous, but we have flag on\n                        emit = true;\n                    }\n                    else if (emitRepeatHighest) {\n                        // Emit current highest due to flag\n                        emit = true;\n                    }\n                }\n            }\n            if (emit && best)\n                yield best;\n        }\n    }\n    rankArray._name = `rankArray`;\n    return rankArray;\n}\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns\n */\nexport function average() {\n    async function* average(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.average();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    average._name = `average`;\n    return average;\n}\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns\n */\nexport function sum() {\n    async function* total(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.sum();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    total._name = `total`;\n    return total;\n}\n/**\n * Chunks an input stream into `size` chunks.\n *\n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n *\n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size\n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns\n */\nexport function chunk(size, returnRemainders = true) {\n    resultThrow(integerTest(size, `aboveZero`, `size`));\n    async function* chunk(input) {\n        input = resolveToGen(input);\n        let buffer = [];\n        for await (const value of input) {\n            buffer.push(value);\n            if (buffer.length >= size) {\n                yield buffer;\n                buffer = [];\n            }\n        }\n        if (returnRemainders && buffer.length > 0)\n            yield buffer;\n    }\n    chunk._name = `chunk`;\n    return chunk;\n}\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n *\n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate\n * @returns\n */\nexport function filter(predicate) {\n    async function* filter(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            if (predicate(value)) {\n                yield value;\n            }\n        }\n    }\n    filter._name = `filter`;\n    return filter;\n}\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n *\n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate\n * @returns\n */\nexport function drop(predicate) {\n    async function* drop(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            if (!predicate(value)) {\n                yield value;\n            }\n        }\n    }\n    drop._name = `drop`;\n    return drop;\n}\n","import { sleep } from \"@ixfx/core\";\n/**\n * Creates a chain from an array, reading values at a given interval\n * @param it\n * @param delay\n * @returns\n */\nexport function array(it, delay = 5) {\n    async function* fromArray() {\n        for (const v of it) {\n            await sleep(delay);\n            yield v;\n        }\n    }\n    fromArray._name = `fromArray`;\n    fromArray._type = `GenFactoryNoInput`;\n    return fromArray;\n}\n","import { promiseFromEvent } from \"@ixfx/core\";\n/**\n * Create an iterable from an event\n * @param target Event source (eg HTML element)\n * @param name Name of event (eg. 'pointermove')\n * @returns\n */\nexport function event(target, name) {\n    async function* event() {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while (true) {\n            yield await promiseFromEvent(target, name);\n        }\n    }\n    event._name = `event`;\n    event._type = `GenFactoryNoInput`;\n    return event;\n}\n//https://stackoverflow.com/questions/51045136/how-can-i-use-a-event-emitter-as-an-async-generator\n","/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n *\n * ```js\n * const callback = () => Math.random();\n *\n * const f = Chains.From.func(callback);\n * for await (const v of f) {\n *  // v is a new random number\n * }\n * ```\n *\n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.From.func(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback\n * @returns\n */\nexport function func(callback) {\n    async function* fromFunction() {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while (true) {\n            const v = await callback();\n            if (typeof v === `undefined`)\n                break;\n            yield v;\n        }\n    }\n    fromFunction._name = `fromFunction`;\n    fromFunction._type = `GenFactoryNoInput`;\n    return fromFunction;\n}\n","/**\n * Creates a chain from an interable\n * @param it\n * @returns\n */\nexport function iterable(it) {\n    async function* fromIterable() {\n        for await (const v of it) {\n            yield v;\n        }\n    }\n    fromIterable._name = `fromIterable`;\n    fromIterable._type = `GenFactoryNoInput`;\n    return fromIterable;\n}\n","import { elapsedSince, intervalToMs, sleep } from \"@ixfx/core\";\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever.\n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n *\n * ```js\n * const c = Chains.From.timestamp({ interval: 1000 });\n * ```\n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options\n * @returns\n */\nexport function timestamp(options) {\n    const intervalMs = intervalToMs(options.interval, 0);\n    const asClockTime = options.asClockTime ?? false;\n    const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n    let looped = 0;\n    const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n    async function* ts() {\n        const elapsed = elapsedSince();\n        while (looped < loops && elapsed() < durationTime) {\n            yield asClockTime ? Date.now() : elapsed();\n            // Adjust sleep period so timing errors don't accumulate\n            const expectedTimeDiff = (looped * intervalMs) - elapsed();\n            await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n            looped++;\n        }\n    }\n    ts._name = `timestamp`;\n    ts._type = `GenFactoryNoInput`;\n    return ts;\n}\n","export * from './array.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterable.js';\nexport * from './ticks.js';\n","/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n *\n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap\n * @param array\n */\nexport async function addToArray(array, valueToWrap) {\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    for await (const value of outputType) {\n        array.push(value);\n    }\n}\n","import { toArray as AsyncToArray } from \"../async.js\";\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n *\n * If the chain is infinite, be sure to specify limits:\n * ```js\n * // Stop after we have five items\n * const values = await asArray(chain, { limit: 5 });\n * // Stop after 5 seconds has elapsed\n * const values = await asArray(chain, { elapsed: 5000 });\n * ```\n * @param valueToWrap\n * @returns\n */\nexport async function asArray(valueToWrap, options = {}) {\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    return AsyncToArray(outputType, options);\n}\n","/**\n * Calls `callback` whenever the chain/generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap\n * @param callback\n */\nexport async function asCallback(valueToWrap, callback, onDone) {\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    for await (const value of outputType) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\n","/**\n * Treats the chain/generator as a promise\n *\n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n *\n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap\n * @returns\n */\nexport function asPromise(valueToWrap) {\n    let lastValue;\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    async function asPromise() {\n        const v = await outputType.next();\n        if (v.done)\n            return;\n        lastValue = v.value;\n        return lastValue;\n    }\n    return asPromise;\n}\n","/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n *\n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n *\n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n *\n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns\n */\nexport function asValue(valueToWrap, initialValue) {\n    let lastValue = initialValue;\n    let awaiting = false;\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    function asValue() {\n        if (!awaiting) {\n            awaiting = true;\n            outputType.next().then(v => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                lastValue = v.value;\n                awaiting = false;\n            }).catch((error) => {\n                awaiting = false;\n                throw error;\n            });\n        }\n        return lastValue;\n    }\n    return asValue;\n}\n","import { isEqual } from \"@ixfx/arrays\";\nimport { resolveToGen } from \"./utility.js\";\n/**\n * Monitors sources, storing as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. The default is\n * 'break', meaning the whole combined stream stops.\n *\n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToArray(sources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const afterEmit = options.afterEmit ?? `last`;\n    const inputs = sources.map((source, index) => ({ waiting: undefined, index, gen: resolveToGen(source), done: false, lastValue: undefined }));\n    const isDone = () => !inputs.some(v => !v.done);\n    const isWaiting = () => inputs.some(v => v.waiting !== undefined);\n    const allEmpty = (d) => !d.some(v => v !== undefined);\n    let lastEmitted = [];\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n        const promises = [];\n        for (const input of inputs) {\n            //console.log(`  ${ input.index } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n            if (input.done)\n                continue;\n            if (input.waiting !== undefined) {\n                promises.push(input.waiting);\n                continue;\n            }\n            const p = Promise.resolve((async () => {\n                if (input.done)\n                    return input;\n                const v = await input.gen.next();\n                input.waiting = undefined;\n                if (v.done) {\n                    input.done = true;\n                    if (finalValue === `undefined`)\n                        input.lastValue = undefined;\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    input.lastValue = v.value;\n                }\n                return input;\n            })());\n            input.waiting = p;\n            promises.push(p);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const won = await Promise.race(promises);\n        if (`done` in won) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (won.done && onSourceDone === `break`)\n                break;\n        }\n        else {\n            throw new Error(`Missing 'done' property`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        const d = inputs.map(v => v.lastValue);\n        if (d.length === 0) {\n            return;\n        }\n        const dataEmpty = allEmpty(d);\n        if (dataEmpty && !isWaiting()) {\n            return;\n        }\n        if (!isEqual(lastEmitted, d) && !dataEmpty) {\n            lastEmitted = d;\n            yield d;\n        }\n        if (afterEmit === `undefined`) {\n            for (const input of inputs) {\n                if (input.waiting !== undefined)\n                    continue;\n                input.lastValue = undefined;\n            }\n        }\n        if (isDone()) {\n            break;\n        }\n    }\n}\n","import { isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport { resolveToGen } from \"./utility.js\";\nimport * as MapFns from \"@ixfx/core/maps\";\n/**\n * Monitors sources, storing as they happen to an object.\n * Whenever a new value is emitted, the object is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n *\n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToObject(sources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const afterEmit = options.afterEmit ?? `last`;\n    const states = new Map();\n    for (const [key, value] of Object.entries(sources)) {\n        states.set(key, {\n            gen: resolveToGen(value),\n            done: false,\n            lastValue: undefined,\n            waiting: undefined,\n            key\n        });\n    }\n    const isDone = () => !MapFns.some(states, v => !v.done);\n    const isWaiting = () => MapFns.some(states, v => v.waiting !== undefined);\n    const allEmpty = (d) => {\n        for (const v of Object.values(d)) {\n            if (v !== undefined)\n                return false;\n        }\n        return true;\n    };\n    const getData = () => {\n        const r = {};\n        for (const [key, state] of states) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            r[key] = state.lastValue;\n        }\n        return r;\n    };\n    let lastEmitted;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n        const promises = [];\n        for (const input of states.values()) {\n            //console.log(`  ${ input.key } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n            if (input.done)\n                continue;\n            if (input.waiting !== undefined) {\n                promises.push(input.waiting);\n                continue;\n            }\n            const p = Promise.resolve((async () => {\n                if (input.done)\n                    return input;\n                const v = await input.gen.next();\n                input.waiting = undefined;\n                if (v.done) {\n                    input.done = true;\n                    if (finalValue === `undefined`)\n                        input.lastValue = undefined;\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    input.lastValue = v.value;\n                }\n                return input;\n            })());\n            input.waiting = p;\n            promises.push(p);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const won = await Promise.race(promises);\n        if (`done` in won) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (won.done && onSourceDone === `break`)\n                break;\n        }\n        else {\n            throw new Error(`Result missing 'done' property`);\n        }\n        const d = getData();\n        //console.log(`d`, d);\n        // if (isEqualValueIgnoreOrder(d, {} as any)) {\n        //   console.log(`keys is empty`);\n        //   return;\n        // }\n        const dataEmpty = allEmpty(d);\n        if (dataEmpty && !isWaiting()) {\n            //console.log(`dataEmpty and not waiting`);\n            return;\n        }\n        if (!isEqualValueIgnoreOrder(lastEmitted, d) && !dataEmpty) {\n            //console.log(` -- emitting!`);\n            lastEmitted = d;\n            yield d;\n        }\n        if (afterEmit === `undefined`) {\n            for (const input of states.values()) {\n                if (input.waiting !== undefined)\n                    continue;\n                input.lastValue = undefined;\n            }\n        }\n        if (isDone()) {\n            break;\n        }\n    }\n}\n","import { func as fromFunction } from \"./from/function.js\";\nimport { isGenFactoryNoInput, resolveToAsyncGen } from \"./utility.js\";\nimport * as L from './links.js';\nimport { Async } from \"../index.js\";\nconst getLinkName = (c) => {\n    //return c._name;\n    return c._name ?? c.name;\n};\nexport function lazy() {\n    const chained = [];\n    let dataToUse;\n    const asGenerator = (data) => {\n        if (data === undefined)\n            data = dataToUse;\n        let d = resolveToAsyncGen(data);\n        for (const c of chained) {\n            if (d === undefined) {\n                if (isGenFactoryNoInput(c)) {\n                    d = c();\n                }\n                else {\n                    throw new Error(`Function '${getLinkName(c)}' requires input. Provide it to the function, or call 'input' earlier.`);\n                }\n            }\n            else {\n                d = c(d);\n            }\n        }\n        return d;\n    };\n    const w = {\n        rankArray: (r, options) => {\n            chained.push(L.rankArray(r, options));\n            return w;\n        },\n        rank: (r, options) => {\n            chained.push(L.rank(r, options));\n            return w;\n        },\n        transform: (transformer) => {\n            chained.push(L.transform(transformer));\n            return w;\n        },\n        reduce: (reducer) => {\n            chained.push(L.reduce(reducer));\n            return w;\n        },\n        drop: (predicate) => {\n            chained.push(L.drop(predicate));\n            return w;\n        },\n        delay: (options) => {\n            chained.push(L.delay(options));\n            return w;\n        },\n        duration: (elapsed) => {\n            chained.push(L.duration(elapsed));\n            return w;\n        },\n        debounce: (rate) => {\n            chained.push(L.debounce(rate));\n            return w;\n        },\n        fromFunction: (callback) => {\n            chained.push(fromFunction(callback));\n            return w;\n        },\n        take: (limit) => {\n            chained.push(L.take(limit));\n            return w;\n        },\n        chunk: (size, returnRemainders = true) => {\n            chained.push(L.chunk(size, returnRemainders));\n            return w;\n        },\n        filter: (predicate) => {\n            chained.push(L.filter(v => predicate(v)));\n            return w;\n        },\n        min: () => {\n            chained.push(L.min());\n            return w;\n        },\n        max: () => {\n            chained.push(L.max());\n            return w;\n        },\n        average: () => {\n            chained.push(L.average());\n            return w;\n        },\n        sum: () => {\n            chained.push(L.sum());\n            return w;\n        },\n        tally: (countArrayItems) => {\n            chained.push(L.tally(countArrayItems));\n            return w;\n        },\n        input(data) {\n            dataToUse = data;\n            return w;\n        },\n        asGenerator,\n        asAsync(data) {\n            let d = data ?? dataToUse;\n            for (const c of chained) {\n                if (d === undefined && isGenFactoryNoInput(c)) {\n                    d = c();\n                }\n                else if (d === undefined) {\n                    throw new Error(`Function '${getLinkName(c)}' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n                }\n                else {\n                    d = c(d);\n                }\n            }\n            return w;\n        },\n        asArray: async (data) => {\n            const g = asGenerator(data);\n            return await Async.toArray(g);\n        },\n        firstOutput: async (data) => {\n            const g = asGenerator(data);\n            const v = await g.next();\n            return v.value;\n        },\n        lastOutput: async (data) => {\n            const g = asGenerator(data);\n            let lastValue;\n            for await (const v of g) {\n                lastValue = v;\n            }\n            return lastValue;\n        },\n    };\n    return w;\n}\n","export class QueueMutable {\n    #store = [];\n    enqueue(data) {\n        this.#store.push(data);\n    }\n    dequeue() {\n        return this.#store.shift();\n    }\n}\n","import { sleep } from \"@ixfx/core\";\nimport { QueueMutable } from \"../util/queueMutable.js\";\nimport { resolveToAsyncGen } from \"./utility.js\";\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n *\n * Alternatively:\n * - {@link combineLatestToArray}/{@link combineLatestToObject} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link syncToArray}/{@link syncToObject} which releases a set of results when all inputs have emitted a value\n * @param sources\n */\nexport async function* mergeFlat(...sources) {\n    const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n    const buffer = new QueueMutable();\n    let completed = 0;\n    const schedule = async (source) => {\n        if (source === undefined) {\n            completed++;\n            return;\n        }\n        const x = await source.next();\n        if (x.done) {\n            completed++;\n        }\n        else {\n            buffer.enqueue(x.value);\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            setTimeout(() => schedule(source), 1);\n        }\n    };\n    for (const source of sourcesInput) {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        setTimeout(() => schedule(source), 1);\n    }\n    const loopSpeed = 10;\n    let loopFactor = 1;\n    while (completed < sourcesInput.length) {\n        const d = buffer.dequeue();\n        if (d === undefined) {\n            // Grow loop factor up to 10\n            loopFactor = Math.min(loopFactor + 1, 10);\n        }\n        else {\n            yield d;\n            // Reset loop factor\n            loopFactor = 1;\n        }\n        await sleep(loopSpeed * loopFactor);\n    }\n}\n","import { resolveToGen } from \"./utility.js\";\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n *\n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n *\n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n *\n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param functions\n * @returns\n */\nexport async function* runN(...functions) {\n    let input;\n    for (const fnOrData of functions) {\n        input = typeof fnOrData === `function` ? fnOrData(input ?? []) : resolveToGen(fnOrData);\n    }\n    if (input === undefined)\n        return;\n    for await (const v of input) {\n        yield v;\n    }\n}\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n *\n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n *\n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n *\n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param gen\n * @param l0\n * @param l1\n * @param l2\n * @param l3\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run(gen, l0, l1, l2, l3, l4, l5) {\n    let input;\n    // eslint-disable-next-line prefer-rest-params\n    const functions = arguments;\n    for (const fnOrData of functions) {\n        if (typeof fnOrData === `function`) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment\n            input = fnOrData(input ?? []);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            input = resolveToGen(fnOrData);\n        }\n    }\n    if (input === undefined)\n        return;\n    for await (const v of input) {\n        yield v;\n    }\n}\n","import { runN } from \"./run.js\";\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => Number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\nexport function prepare(...functions) {\n    const r = (source) => {\n        return runN(source, ...functions);\n    };\n    return r;\n}\n// const chain = combine(\n//   Chains.Links.transform(v => Number.parseInt(v)),\n//   Chains.Links.filter(v => v % 2 === 0)\n// );\n// const read = chain(Chains.From.array([ 1, 2, 3 ], 100));\n","/**\n * Input a single value to the chain, return a single result\n *\n *\n * ```js\n * // Create chain link\n * const f = Chains.Links.flatten<string, string>(data => data.join(`-`));\n * // Input a single value (an array)\n * const r1 = await Chains.single(f, [ `a`, `b`, `c` ]);\n * // r1 = `a-b-c`\n * ```\n * @param f\n * @param input\n * @returns\n */\nexport async function single(f, input) {\n    const iterator = await f([input]).next();\n    return iterator.value;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport * as Async from \"../async.js\";\nimport { resolveToGen } from \"./utility.js\";\n// export function syncToObject<const T extends Record<string, GenOrData<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): AsyncGenerator<GenValueTypeObject<T>> {\n//   const keys = Object.keys(reactiveSources)\n//   const values = Object.values(reactiveSources);\n//   const s = syncToArray(values, options);\n//   const st = transform(s, (streamValues) => {\n//     return zipKeyValue(keys, streamValues);\n//   });\n//   return st as AsyncGenerator<GenValueTypeObject<T>>;\n// }\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n *\n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n *\n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n *\n * Only complete results are sent. For example if source A & B finish and\n * source C is still producing values, synchronisation is not possible\n * because A & B stopped producing values. Thus the stream will terminate\n * after `maximumWait` (2 seconds). Newer values from C are lost.\n */\nexport async function* syncToArray(sources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    //const ac = new AbortController();\n    const maximumWaitMs = intervalToMs(options.maximumWait, 2000);\n    const finalValue = options.finalValue ?? `undefined`;\n    const inputs = sources.map(source => ({ seq: 0, lastValue: undefined, gen: resolveToGen(source), done: false }));\n    const nextWithTimeoutOpts = {\n        millis: maximumWaitMs\n    };\n    let seq = 0;\n    const isAllDone = () => !inputs.some(v => !v.done);\n    let go = true;\n    while (go) {\n        seq++;\n        for (const input of inputs) {\n            if (input.done) {\n                input.seq = seq;\n                continue;\n            }\n            // Read source, with a timeout\n            const v = await Async.nextWithTimeout(input.gen, nextWithTimeoutOpts);\n            // Input has finished\n            if (v.done) {\n                input.done = true;\n                input.seq = seq;\n                if (finalValue === `undefined`) {\n                    input.lastValue = undefined;\n                }\n                if (onSourceDone === `break`) {\n                    return;\n                }\n            }\n            else {\n                // Stash away value\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                input.lastValue = v.value;\n                input.seq = seq;\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (go) {\n            // Return the set of data\n            const d = inputs.filter(v => v.seq === seq).map(v => v.lastValue);\n            if (d.length === 0)\n                return;\n            if (!d.some(v => typeof v !== `undefined`))\n                return;\n            yield d;\n        }\n        if (isAllDone())\n            go = false;\n    }\n    // let somethingProduced = true;\n    // while (somethingProduced) {\n    //   let data = [];\n    //   for (let index = 0; index < sourcesInput.length; index++) {\n    //     // eslint-disable-next-line unicorn/no-null\n    //     data[ index ] = null;\n    //   }\n    //   somethingProduced = false;\n    //   // Request the next value from each source\n    //   for (const [ index, source ] of sourcesInput.entries()) {\n    //     const v = await source.next();\n    //     if (!v.done) {\n    //       data[ index ] = v.value;\n    //       somethingProduced = true;\n    //     }\n    //   }\n    //   if (somethingProduced) {\n    //     // Send data\n    //     yield data;\n    //     data = [];\n    //   }\n    // }\n}\n","export * as Dom from './dom.js';\nexport * as Links from './links.js';\nexport * as From from './from/index.js';\nexport * from './add-to-array.js';\nexport * from './as-array.js';\nexport * from './as-callback.js';\nexport * from './as-promise.js';\nexport * from './as-value.js';\nexport * from './combine-latest-to-array.js';\nexport * from './combine-latest-to-object.js';\nexport * from './lazy.js';\nexport * from './merge-flat.js';\nexport * from './prepare.js';\nexport * from './run.js';\nexport * from './single.js';\nexport * from './sync.js';\nexport * from './types.js';\nexport * from './utility.js';\n","import { compareIterableValuesShallow, isEqualDefault } from \"@ixfx/core\";\n/**\n * Returns the 'max' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const maxScore = (iterable, scorer) => {\n    let highestValue;\n    let highestScore = Number.MIN_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score >= highestScore) {\n            highestScore = score;\n            highestValue = value;\n        }\n    }\n    return highestValue;\n};\n/**\n * Returns the 'min' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const minScore = (iterable, scorer) => {\n    let lowestValue;\n    let lowestScore = Number.MAX_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score <= lowestScore) {\n            lowestScore = score;\n            lowestValue = value;\n        }\n    }\n    return lowestValue;\n};\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n *\n * Is NOT recursive.\n *\n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * hasEqualValuesShallow(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * hasEqualValuesShallow(a, b);\n * // True, since now we're comparing by value\n * hasEqualValuesShallow(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param iterableA First iterable to check\n * @param iterableB Iterable to compare against\n * @param eq Equality function, uses === by default\n */\nexport const hasEqualValuesShallow = (iterableA, iterableB, eq) => {\n    const returnValue = compareIterableValuesShallow(iterableA, iterableB, eq);\n    return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport { continuously } from \"@ixfx/core/continuously\";\n/**\n * Retrieve values from an iterator, passing them to a callback.\n * Allows iterator to be started, paused, or restarted and an optional delay between reading items from iterator.\n * @param options\n * @returns\n */\nexport const iteratorController = (options) => {\n    const delayMs = intervalToMs(options.delay, 10);\n    let gen;\n    const onValue = options.onValue;\n    let state = `stopped`;\n    const loop = continuously(async () => {\n        if (gen) {\n            const r = await gen.next();\n            if (r.done) {\n                state = `stopped`;\n                return false;\n            }\n            const r2 = onValue(r.value);\n            if (typeof r2 === `boolean`) {\n                if (!r2) {\n                    state = `stopped`;\n                }\n                return r2;\n            }\n            return true;\n        }\n        else {\n            state = `stopped`;\n            return false;\n        }\n    }, delayMs);\n    const cancel = () => {\n        if (state === `stopped`)\n            return;\n        gen = undefined;\n        loop.cancel();\n        state = `stopped`;\n    };\n    const pause = () => {\n        if (state === `paused`)\n            return;\n        loop.cancel();\n        state = `paused`;\n    };\n    const start = () => {\n        if (state === `running`)\n            return;\n        if (!gen) {\n            remake();\n        }\n        state = `running`;\n        loop.start();\n    };\n    const remake = () => {\n        if (options.iterator) {\n            gen = options.iterator();\n        }\n        else {\n            throw new Error(`No source iterator`);\n        }\n    };\n    const restart = () => {\n        remake();\n        start();\n    };\n    return {\n        start, cancel, restart, pause,\n        get state() {\n            return state;\n        }\n    };\n};\n","export const fromEvent = (eventSource, eventType) => {\n    const pullQueue = [];\n    const pushQueue = [];\n    let done = false;\n    const pushValue = (args) => {\n        if (pullQueue.length > 0) {\n            //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const resolver = pullQueue.shift();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            resolver(...args);\n        }\n        else {\n            pushQueue.push(args);\n        }\n    };\n    const pullValue = () => new Promise((resolve) => {\n        if (pushQueue.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arguments_ = pushQueue.shift();\n            // @ts-expect-error\n            resolve(...arguments_);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const handler = (...arguments_) => {\n        pushValue(arguments_);\n    };\n    eventSource.addEventListener(eventType, handler);\n    const r = {\n        next: async () => {\n            if (done)\n                return { done: true, value: undefined };\n            return {\n                done: false,\n                value: await pullValue(),\n            };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        return: async () => {\n            done = true;\n            eventSource.removeEventListener(eventType, handler);\n            return { done: true, value: undefined };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        throw: async (error) => {\n            done = true;\n            return {\n                done: true,\n                value: Promise.reject(new Error(error)),\n            };\n        },\n    };\n    return r;\n};\n","import { numberArrayCompute } from \"@ixfx/numbers\";\nimport { isIterable } from \"./guard.js\";\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * const v = [ 10, 2, 4.2, 99 ];\n * const mma = numbersCompute(v);\n * // Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link https://api.ixfx.fun/_ixfx/numbers/average/ @ixfx/numbers.average}, {@link https://api.ixfx.fun/_ixfx/numbers/max/ @ixfx/numbers.max}, {@link https://api.ixfx.fun/_ixfx/numbers/min/ @ixfx/numbers.min} or {@link https://api.ixfx.fun/_ixfx/numbers/total/ @ixfx/numers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * import { count } from '@ixfx/numbers';\n * numbersCompute(count(5,1)); // Averages 1,2,3,4,5\n * ```\n *\n * Returns `NaN` if the input data is empty.\n * @param data\n * @param options Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const numbersCompute = (data, options = {}) => {\n    if (typeof data === `undefined`)\n        throw new Error(`Param 'data' is undefined`);\n    if (Array.isArray(data)) {\n        return numberArrayCompute(data, options);\n    }\n    if (isIterable(data)) {\n        return numbersComputeIterable(data, options);\n    }\n    throw new Error(`Param 'data' is neither an array nor iterable`);\n};\nfunction numbersComputeIterable(data, options = {}) {\n    // if (typeof options.startIndex !== `undefined` || typeof options.endIndex !== `undefined`) {\n    //   data = slice(data, options.startIndex, options.endIndex);\n    // }\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let v of data) {\n        if (typeof v !== `number` || Number.isNaN(v)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof v}'`);\n            if (nonNumbers === `nan`)\n                v = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += v;\n        count++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n    }\n    return {\n        avg: total / count,\n        total, max, min, count\n    };\n}\nexport function computeAverage(data, options = {}) {\n    let count = 0;\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    for (let d of data) {\n        if (typeof d !== `number` || Number.isNaN(d)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof d}'`);\n            if (nonNumbers === `nan`)\n                d = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += d;\n        count++;\n    }\n    return total / count;\n}\n","import * as Async from './async.js';\nimport * as Sync from './sync.js';\nexport * as Async from './async.js';\nexport * as Sync from './sync.js';\nexport * as Chains from './chain/index.js';\nexport { combineLatestToArray } from './chain/combine-latest-to-array.js';\nexport { combineLatestToObject } from './chain/combine-latest-to-object.js';\nexport * from './compare-values.js';\nexport * from './controller.js';\nexport * from './from-event.js';\nexport * from './guard.js';\nexport * from './types.js';\nimport { isAsyncIterable } from './guard.js';\n//import * as Chains from './chain/index.js';\n// import type { Interval } from '../flow/IntervalType.js';\nimport { toStringDefault } from '@ixfx/core';\nexport * from './numbers-compute.js';\n/**\n * Returns a stream of minimum values.\n *\n * Streaming result: works with endless iterables.\n *\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n *\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile(it, f) {\n    return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n*\n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it, callback) {\n    if (isAsyncIterable(it)) {\n        return Async.until(it, callback);\n    }\n    else {\n        Sync.until(it, callback);\n    }\n}\n/**\n * Breaks an iterable into array chunks\n *\n * Streaming: works with infinite iterables.\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks(it, size) {\n    return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter(it, f) {\n    return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f);\n}\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n *\n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill(it, v) {\n    return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n/**\n * Return concatenation of iterators.\n *\n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat(...its) {\n    return isAsyncIterable(its[0]) ? Async.concat(...its) : Sync.concat(...its);\n}\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find(it, f) {\n    return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f);\n}\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n *\n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach(it, fn, options = {}) {\n    if (isAsyncIterable(it)) {\n        return Async.forEach(it, fn, options);\n    }\n    else {\n        Sync.forEach(it, fn);\n    }\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map(it, f) {\n    return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray(array, interval) {\n    return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten(it) {\n    return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some(it, f) {\n    return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f);\n}\n/**\n * Returns the last item of an iterable, or _undefined_ if it yields no results.\n * @param it\n * @returns\n */\nexport function last(it) {\n    return isAsyncIterable(it) ? Async.last(it) : Sync.last(it);\n}\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce(it, f, start) {\n    return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n/**\n * Returns a section from an iterable.\n *\n * 'end' is the end index, not the number of items.\n *\n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, start, end);\n}\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique(iterable) {\n    if (Array.isArray(iterable)) {\n        if (iterable.length === 0)\n            return Sync.fromArray([]);\n        return isAsyncIterable(iterable[0]) ? Async.unique(iterable) : Sync.unique(iterable);\n    }\n    else if (isAsyncIterable(iterable)) {\n        return Async.unique(iterable);\n    }\n    else {\n        return Sync.unique(iterable);\n    }\n}\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n *\n * Streaming: Works with unbounded iterables.\n *\n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n *\n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n *\n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n *\n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n *\n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n *\n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input\n * @param seen\n * @param toString\n */\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    yield* isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n *\n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every(it, f) {\n    return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f);\n}\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n    return as ? Async.equals(it1, it2, equality) : Sync.equals(it1, it2, equality);\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip(...its) {\n    if (its.length === 0)\n        return Sync.fromArray([]);\n    return isAsyncIterable(its[0]) ? Async.zip(...its) : Sync.zip(...its);\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport function fromIterable(iterable, interval) {\n    if (isAsyncIterable(iterable) || interval !== undefined)\n        return Async.fromIterable(iterable, interval);\n    return Sync.fromIterable(iterable);\n}\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction(callback) {\n    while (true) {\n        const v = callback();\n        yield v;\n    }\n}\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback\n */\nexport async function* fromFunctionAwaited(callback) {\n    while (true) {\n        const v = await callback();\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    if (isAsyncIterable(input)) {\n        return Async.asCallback(input, callback);\n    }\n    else {\n        Sync.asCallback(input, callback);\n        return;\n    }\n}\n","//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\nimport { defaultComparer } from './comparers.js';\nconst sorterByValueIndex = (index, reverse = false) => {\n    return (values) => {\n        const s = values.toSorted((a, b) => {\n            return defaultComparer(a[index], b[index]);\n        });\n        if (reverse)\n            return s.reverse();\n        return s;\n    };\n};\nexport const keyValueSorter = (sortStyle) => {\n    switch (sortStyle) {\n        case `value`: {\n            return sorterByValueIndex(1, false);\n        }\n        case `value-reverse`: {\n            return sorterByValueIndex(1, true);\n        }\n        case `key`: {\n            return sorterByValueIndex(0, false);\n        }\n        case `key-reverse`: {\n            return sorterByValueIndex(0, true);\n        }\n        default: {\n            throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, value-reverse, key or key-reverse`);\n        }\n    }\n};\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };\n","/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\n/**\n * Returns _true_ if `rx` has a last value\n *\n * Judged seeing if `.last()` exists on `rx`.\n * @param rx Reactive\n * @returns\n */\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n","export const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n","import { getOrGenerateSync } from \"./util.js\";\n/**\n * Returns a console logging function which prefixes messages. This is\n * useful for tracing messages from different components. Each prefix\n * is assigned a colour, further helping to distinguish messages.\n *\n * Use {@link logSet} to get a bundled set.\n *\n * ```\n * // Initialise once\n * const log = logger(`a`);\n * const error = logger(`a`, `error`);\n * const warn = logger(`a`, `warn);\n *\n * // And then use\n * log(`Hello`);    // console.log(`a Hello`);\n * error(`Uh-oh`);  // console.error(`a Uh-oh`);\n * warn(`Eek!`);    // console.warn(`a Eeek!`);\n * ```\n *\n * Provide the `colourKey` parameter to make log messages\n * be coloured the same, even though the prefix is different.\n * ```js\n * // Both loggers will use the same colour because they\n * // share the colour key `system`\n * const log = logger(`a`,`log`,`system`);\n * const log2 = logger(`b`, `log`, `system`);\n * ```\n * @param prefix\n * @param kind\n * @param colourKey Optional key to colour log lines by instead of prefix\n * @returns\n */\nexport const logger = (prefix, kind = `log`, colourKey) => (m) => {\n    if (m === undefined) {\n        m = `(undefined)`;\n    }\n    else if (typeof m === `object`) {\n        m = JSON.stringify(m);\n    }\n    const colour = colourKey ?? prefix;\n    switch (kind) {\n        case `log`: {\n            console.log(`%c${prefix} ${m}`, `color: ${logColours(colour)}`);\n            break;\n        }\n        case `warn`: {\n            console.warn(prefix, m);\n            break;\n        }\n        case `error`: {\n            console.error(prefix, m);\n            break;\n        }\n    }\n};\n/**\n* Returns a bundled collection of {@link logger}s\n*\n* ```js\n* const con = logSet(`a`);\n* con.log(`Hello`);  // console.log(`a Hello`);\n* con.warn(`Uh-oh`); // console.warn(`a Uh-oh`);\n* con.error(`Eek!`); // console.error(`a Eek!`);\n* ```\n*\n* By default each prefix is assigned a colour. To use\n* another logic, provide the `colourKey` parameter.\n*\n* ```js\n* // Both set of loggers will use same colour\n* const con = logSet(`a`, true, `system`);\n* const con2 = logSet(`b`, true, `system`);\n* ```\n* @param prefix Prefix for log messages\n* @param verbose True by default. If false, log() messages are a no-op\n* @param colourKey If specified, log messages will be coloured by this key instead of prefix (default)\n* @returns\n*/\nexport const logSet = (prefix, verbose = true, colourKey) => {\n    if (verbose) {\n        return {\n            log: logger(prefix, `log`, colourKey),\n            warn: logger(prefix, `warn`, colourKey),\n            error: logger(prefix, `error`, colourKey),\n        };\n    }\n    return {\n        log: (_) => {\n            /** no-op */\n        },\n        warn: logger(prefix, `warn`, colourKey),\n        error: logger(prefix, `error`, colourKey),\n    };\n};\n/**\n * Resolve a LogOption to a function\n * @param l\n * @returns\n */\nexport const resolveLogOption = (l, defaults = {}) => {\n    if (l === undefined || (typeof l === `boolean` && !l)) {\n        return (_) => {\n            /** no-op */\n        };\n    }\n    const defaultCat = defaults.category ?? ``;\n    const defaultKind = defaults.kind ?? undefined;\n    if (typeof l === `boolean`) {\n        return (messageOrString) => {\n            const m = typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;\n            const kind = m.kind ?? defaultKind;\n            const category = m.category ?? defaultCat;\n            let message = m.msg;\n            if (category)\n                message = `[${category}] ${message}`;\n            switch (kind) {\n                case `error`: {\n                    console.error(message);\n                    break;\n                }\n                case `warn`: {\n                    console.warn(message);\n                    break;\n                }\n                case `info`: {\n                    console.info(message);\n                    break;\n                }\n                default: {\n                    console.log(message);\n                }\n            }\n        };\n    }\n    return l;\n};\nlet logColourCount = 0;\nexport const logColours = getOrGenerateSync(new Map(), () => {\n    const hue = ++logColourCount * 137.508; // use golden angle approximation\n    return `hsl(${hue},50%,75%)`;\n});\n","/**\n * Calculates frames per second.\n *\n * Returns a function which needs to be called at the end of each frame.\n *\n * ```js\n * const fps = fpsCounter();\n *\n * function loop() {\n *  fps(); // Calculate fps\n *  window.requestAnimationFrame(loop);\n * }\n *\n * loop();\n * ```\n * @param autoDisplay If true (default), prints out the FPS to the console\n * @param computeAfterFrames Calculates after this many frames. Higher numbers smoothes the value somewhat\n * @returns\n */\nexport const fpsCounter = (autoDisplay = true, computeAfterFrames = 500) => {\n    let count = 0;\n    let lastFps = 0;\n    let countStart = performance.now();\n    return () => {\n        if (count++ >= computeAfterFrames) {\n            const elapsed = performance.now() - countStart;\n            countStart = performance.now();\n            count = 0;\n            lastFps = Math.floor((computeAfterFrames / elapsed) * 1000);\n            if (autoDisplay)\n                console.log(`fps: ${lastFps}`);\n        }\n        return lastFps;\n    };\n};\n","/**\n * Returns a string representation of an error\n * @param ex\n * @returns\n */\nexport const getErrorMessage = (ex) => {\n    if (typeof ex === `string`)\n        return ex;\n    if (ex instanceof Error) {\n        return ex.message;\n    }\n    return ex;\n};\n","export * from './types.js';\nexport * from './logger.js';\nexport * from './fps-counter.js';\nexport * from './error-message.js';\n","import { getErrorMessage } from \"@ixfx/debug\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n/**\n * Resolves the input to a concrete value.\n *\n * The input can be:\n * * primitive value (string, boolean, number, object)\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n *\n * Examples:\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n *\n * If the input is a function, any arguments given to `resolve` are passed to it as a spread.\n *\n * Resolve is not recursive. If the input is an object, it will be returned, even\n * though its properties may be resolvable. Use {@link resolveFields} if you want to handle this case.\n * @param resolvable Input to resolve\n * @param args Additional arguments to pass to function-resolvables.\n * @returns\n */\nexport async function resolve(resolvable, ...args) {\n    if (typeof resolvable === `object`) {\n        if (`next` in resolvable) {\n            const tag = resolvable[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = resolvable.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                const v = await resolvable.next();\n                //console.log(`  hasDone: ${ `done` in v } value:`, v);\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(resolvable)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (hasLast(resolvable))\n                return resolvable.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return resolvable;\n        }\n    }\n    else if (typeof resolvable === `function`) {\n        const v = await resolvable(...args);\n        return v;\n    }\n    else {\n        // Primitive value?\n        return resolvable;\n    }\n}\n/**\n * For the given input, attempts to 'resolve' it. See {@link resolve} for details and asynchronous version.\n * @param resolvable\n * @param args\n * @returns\n */\nexport function resolveSync(resolvable, ...args) {\n    if (typeof resolvable === `object`) {\n        if (`next` in resolvable) {\n            const tag = resolvable[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = resolvable.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                throw new Error(`resolveSync cannot work with an async generator`);\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(resolvable)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            if (hasLast(resolvable))\n                return resolvable.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return resolvable;\n        }\n    }\n    else if (typeof resolvable === `function`) {\n        return resolvable(...args);\n    }\n    else {\n        // Primitive value?\n        return resolvable;\n    }\n}\n/**\n * Resolves a value as per {@link resolve}, however f an error is thrown\n * or the resolution results in _undefined_\n * or NaN, the fallback value is returned instead.\n *\n * `null` is an allowed return value.\n *\n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n *\n * See also {@link resolveWithFallbackSync}\n * @param p Thing to resolve\n * @param options Fallback value if an error happens, undefined or NaN\n * @param args\n * @returns\n */\nexport async function resolveWithFallback(p, options, ...args) {\n    let errored = false;\n    let fallbackValue = options.value;\n    const overrideWithLast = options.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Param 'options.value' is undefined`);\n    try {\n        const r = await resolve(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\n/**\n * Resolves a 'resolvable', using a fallback value if it results to _undefined_ or _NaN_. _null_ is allowed.\n *\n * See also {@link resolveWithFallback} for the asynchronous version.\n *\n * Options:\n * * value: Fallback value\n * * overrideWithLast: If true, uses the previously-valid value as the replacement fallback (default: false)\n * @param p\n * @param options\n * @param args\n * @returns\n */\nexport function resolveWithFallbackSync(p, options, ...args) {\n    let errored = false;\n    let fallbackValue = options.value;\n    const overrideWithLast = options.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Param 'options.value' is undefined`);\n    try {\n        const r = resolveSync(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * A circular array keeps a maximum number of values, overwriting older values as needed. Immutable.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = new CircularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = new CircularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport class CircularArray extends Array {\n    #capacity;\n    #pointer;\n    constructor(capacity = 0) {\n        super();\n        // Allowed to create with capacity zero\n        resultThrow(integerTest(capacity, `positive`, `capacity`));\n        // Can't throw because .filter won't use ctor proprly\n        this.#capacity = capacity;\n        this.#pointer = 0;\n    }\n    /**\n     * Add to array\n     * @param value Thing to add\n     * @returns\n     */\n    add(value) {\n        const ca = CircularArray.from(this);\n        ca[this.#pointer] = value;\n        ca.#capacity = this.#capacity;\n        if (this.#capacity > 0) {\n            ca.#pointer =\n                this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n        }\n        else {\n            ca.#pointer = this.#pointer + 1;\n        }\n        return ca;\n    }\n    get pointer() {\n        return this.#pointer;\n    }\n    get isFull() {\n        if (this.#capacity === 0)\n            return false;\n        return this.length === this.#capacity;\n    }\n}\n","export const debug = (opts, message) => {\n    opts.debug ? console.log(`queue:${message}`) : undefined;\n};\nexport const trimQueue = (opts, queue, toAdd) => {\n    const potentialLength = queue.length + toAdd.length;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    const policy = opts.discardPolicy ?? `additions`;\n    // debug(\n    //   opts,\n    //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n    // );\n    // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n    switch (policy) {\n        // Only add what we can from toAdd\n        case `additions`: {\n            // debug(\n            //   opts,\n            //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n            //     potentialLength - capacity\n            //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n            // );\n            if (queue.length === 0)\n                return toAdd.slice(0, toAdd.length - toRemove);\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (queue.length === opts.capacity) {\n                return queue; // Completely full\n            }\n            else {\n                // Only add some from the new array (from the front)\n                return [...queue, ...toAdd.slice(0, toRemove - 1)];\n            }\n        }\n        // Remove from rear of queue (last index) before adding new things\n        case `newer`: {\n            if (toRemove >= queue.length) {\n                // New items will completely flush out old\n                //debug(opts, `slice start: ${toAdd.length - capacity}`);\n                if (queue.length === 0) {\n                    // Special case when queue starts off empty\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];\n                }\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n                //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n                //return tmp;\n            }\n            else {\n                // Keep some of the old\n                // const toAddFinal = toAdd.slice(\n                //   0,\n                //   Math.min(toAdd.length, capacity - toRemove + 1)\n                // );\n                // Cap 5, queue 5, toAdd: 10.\n                const countToAdd = Math.max(1, toAdd.length - queue.length);\n                const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n                const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n                // debug(\n                //   opts,\n                //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n                //     queue.length\n                //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n                //     toKeep\n                //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n                //     toAddFinal\n                //   )}`\n                // );\n                const t = [...toKeep, ...toAddFinal];\n                //debug(opts, `final: ${JSON.stringify(t)}`);\n                return t;\n            }\n        }\n        // Remove from the front of the queue (0 index). ie. older items are discarded\n        case `older`: {\n            // If queue is A, B and toAdd is C, D this yields A, B, C, D\n            return [...queue, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown overflow policy ${policy}`);\n        }\n    }\n};\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = (opts, queue, ...toAdd) => {\n    if (opts === undefined)\n        throw new Error(`opts parameter undefined`);\n    const potentialLength = queue.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimQueue(opts, queue, toAdd)\n        : [...queue, ...toAdd];\n    if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n        throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\n    }\n    if (!opts.capacity && toReturn.length !== potentialLength) {\n        throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\n    }\n    return toReturn;\n};\n// Remove from front of queue (0 index)\nexport const dequeue = (opts, queue) => {\n    if (queue.length === 0)\n        throw new Error(`Queue is empty`);\n    return queue.slice(1);\n};\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, queue) => queue[0];\nexport const isEmpty = (opts, queue) => queue.length === 0;\nexport const isFull = (opts, queue) => {\n    if (opts.capacity) {\n        return queue.length >= opts.capacity;\n    }\n    return false;\n};\n","import {} from './iqueue-mutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './queue-fns.js';\nimport {} from './queue-types.js';\nimport { isEqualDefault } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\n/**\n * Mutable queue that fires events when manipulated.\n *\n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n *\n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n *\n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @typeParam V - Data type of items\n */\nexport class QueueMutable extends SimpleEventEmitter {\n    options;\n    data;\n    eq;\n    constructor(opts = {}, data = []) {\n        super();\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.options = opts;\n        this.data = data;\n        this.eq = opts.eq ?? isEqualDefault;\n    }\n    clear() {\n        const copy = [...this.data];\n        this.data = [];\n        this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n        this.onClear();\n    }\n    /**\n     * Called when all data is cleared\n     */\n    onClear() {\n    }\n    at(index) {\n        if (index >= this.data.length)\n            throw new Error(`Index outside bounds of queue`);\n        const v = this.data.at(index);\n        if (v === undefined)\n            throw new Error(`Index appears to be outside range of queue`);\n        return v;\n    }\n    enqueue(...toAdd) {\n        this.data = enqueue(this.options, this.data, ...toAdd);\n        const length = this.data.length;\n        this.onEnqueue(this.data, toAdd);\n        return length;\n    }\n    onEnqueue(result, attemptedToAdd) {\n        this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n    }\n    dequeue() {\n        const v = peek(this.options, this.data);\n        if (v === undefined)\n            return;\n        /* eslint-disable-next-line functional/immutable-data */\n        this.data = dequeue(this.options, this.data);\n        this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n        this.onRemoved([v], this.data);\n        return v;\n    }\n    onRemoved(removed, finalData) {\n        this.fireEvent(`removed`, { removed, finalData });\n    }\n    /**\n     * Removes values that match `predicate`.\n     * @param predicate\n     * @returns Returns number of items removed.\n     */\n    removeWhere(predicate) {\n        const countPre = this.data.length;\n        const toRemove = this.data.filter(v => predicate(v));\n        if (toRemove.length === 0)\n            return 0;\n        this.data = this.data.filter((element) => !predicate(element));\n        this.onRemoved(toRemove, this.data);\n        return countPre - this.data.length;\n    }\n    /**\n   * Return a copy of the array\n   * @returns\n   */\n    toArray() {\n        return [...this.data];\n    }\n    get isEmpty() {\n        return isEmpty(this.options, this.data);\n    }\n    get isFull() {\n        return isFull(this.options, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n    get peek() {\n        return peek(this.options, this.data);\n    }\n}\n/**\n * Creates a new QueueMutable\n * @param options\n * @param startingItems\n * @returns\n */\nexport function mutable(options = {}, ...startingItems) {\n    return new QueueMutable({ ...options }, [...startingItems]);\n}\n","export const trimStack = (opts, stack, toAdd) => {\n    const potentialLength = stack.length + toAdd.length;\n    const policy = opts.discardPolicy ?? `additions`;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    if (opts.debug) {\n        console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);\n    }\n    switch (policy) {\n        case `additions`: {\n            if (opts.debug) {\n                console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`);\n            }\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (stack.length === opts.capacity) {\n                return stack; // Completely full\n            }\n            else {\n                // Only add some from the new array\n                return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];\n            }\n        }\n        case `newer`: {\n            if (toRemove >= stack.length) {\n                // New items will completely flush out old\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n            }\n            else {\n                // Keep some of the old (from 0)\n                //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n                if (opts.debug) {\n                    console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);\n                }\n                return [\n                    ...stack.slice(0, stack.length - toRemove),\n                    ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n                ];\n            }\n        }\n        case `older`: {\n            // Oldest item in stack is position 0\n            return [...stack, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown discard policy ${policy}`);\n        }\n    }\n};\n// Add to top (last index)\nexport const push = (opts, stack, ...toAdd) => {\n    // If stack is A, B and toAdd is C, D this yields A, B, C, D\n    //const mutated = [...stack, ...toAdd];\n    const potentialLength = stack.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimStack(opts, stack, toAdd)\n        : [...stack, ...toAdd];\n    return toReturn;\n};\n// Remove from top (last index)\nexport const pop = (opts, stack) => {\n    if (stack.length === 0)\n        throw new Error(`Stack is empty`);\n    return stack.slice(0, -1);\n};\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, stack) => stack.at(-1);\nexport const isEmpty = (opts, stack) => stack.length === 0;\nexport const isFull = (opts, stack) => {\n    if (opts.capacity) {\n        return stack.length >= opts.capacity;\n    }\n    return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable {\n    opts;\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    /**\n     * Push data onto the stack.\n     * If `toAdd` is empty, nothing happens\n     * @param toAdd Data to add\n     * @returns Length of stack\n     */\n    push(...toAdd) {\n        if (toAdd.length === 0)\n            return this.data.length;\n        this.data = push(this.opts, this.data, ...toAdd);\n        return this.data.length;\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    pop() {\n        const v = peek(this.opts, this.data);\n        this.data = pop(this.opts, this.data);\n        return v;\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = (opts = {}, ...startingItems) => new StackMutable({ ...opts }, [...startingItems]);\n","import { isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport * as TreeMutable from './tree-mutable.js';\nexport const compare = (a, b, eq = isEqualValueIgnoreOrder, parent) => {\n    const valueEqual = valueOrIdentityEqual(a, b, eq);\n    // if (!valueEqual) {\n    //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n    // }\n    const childrenCompare = compareChildren(a, b, eq);\n    const diff = {\n        valueChanged: !valueEqual, a, b,\n        added: childrenCompare.added,\n        removed: childrenCompare.removed,\n        childChanged: false\n    };\n    const diffNode = {\n        value: diff,\n        childrenStore: [],\n        parent\n    };\n    const childrenDiff = childrenCompare.identical.map(c => compare(c[0], c[1], eq, diffNode));\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value));\n    TreeMutable.setChildren(diffNode, childrenDiff);\n    //diffNode.childrenStore = childrenDiff;\n    diffNode.toString = () => toString(diffNode, 0);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    diffNode.value.childChanged = someChildChange;\n    TreeMutable.throwTreeTest(diffNode);\n    return diffNode;\n};\nconst hasChange = (vv) => {\n    if (vv === undefined)\n        return false;\n    if (vv.valueChanged)\n        return true;\n    if (vv.childChanged)\n        return true;\n    if (vv.added.length > 0)\n        return true;\n    if (vv.removed.length > 0)\n        return true;\n    return false;\n};\nconst compareChildren = (a, b, eq = isEqualValueIgnoreOrder) => {\n    const childrenOfA = [...a.children()];\n    const childrenOfB = [...b.children()];\n    const identical = [];\n    const removed = [];\n    for (const childA of childrenOfA) {\n        let foundIndex = -1;\n        for (const [index, childOfB] of childrenOfB.entries()) {\n            const d = valueOrIdentityEqual(childA, childOfB, eq);\n            if (d) {\n                identical.push([childA, childOfB]);\n                foundIndex = index;\n                break;\n            }\n        }\n        if (foundIndex === -1) {\n            // A's child not found in B's children\n            removed.push(childA);\n        }\n        else {\n            // Found, remove it from list of B's children\n            childrenOfB.splice(foundIndex, 1);\n        }\n    }\n    const added = [...childrenOfB];\n    return { added, identical, removed };\n};\nconst valueOrIdentityEqual = (a, b, eq) => {\n    if (a.getIdentity() === b.getIdentity())\n        return true;\n    if (eq(a.getValue(), b.getValue()))\n        return true;\n    return false;\n};\nconst toStringSingle = (n) => {\n    return JSON.stringify(n.getValue());\n};\nconst toString = (n, indent = 0) => {\n    if (n === undefined)\n        return `(undefined)`;\n    let t = toStringDiff(n.value, indent);\n    for (const c of n.childrenStore) {\n        t += toString(c, indent + 2);\n    }\n    return t;\n};\nconst toStringDiff = (n, indent) => {\n    const spaces = ` `.repeat(indent);\n    if (n === undefined)\n        return `${spaces}(undefined)`;\n    const t = [];\n    t.push(`a: ${toStringSingle(n.a)} b: ${toStringSingle(n.b)}`);\n    if (n.valueChanged)\n        t.push(`Value changed. Child changed: ${n.childChanged}`);\n    else\n        t.push(`Value unchanged. Child changed: ${n.childChanged}`);\n    if (n.added.length > 0) {\n        t.push(`Added:`);\n        for (const c of n.added) {\n            t.push(` - ` + toStringSingle(c));\n        }\n    }\n    if (n.removed.length > 0) {\n        t.push(`Removed: ${n.removed.length}`);\n        for (const c of n.removed) {\n            t.push(` - ` + toStringSingle(c));\n        }\n    }\n    t.push(`----\\n`);\n    return t.map(line => spaces + line).join(`\\n`);\n};\n","import { isEqualDefault } from \"@ixfx/core\";\nimport { without } from '@ixfx/arrays';\nimport { containsDuplicateInstances } from \"@ixfx/arrays\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { compare as treeCompare } from './compare.js';\nimport { toStringAbbreviate } from \"@ixfx/core/text\";\n/**\n * Compares two nodes.\n *\n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a\n * @param b\n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = (a, b, eq) => {\n    return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n};\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n *\n * Recursive: strips parentage of all children and so on too.\n * @param node\n * @returns\n */\nexport const stripParentage = (node) => {\n    const n = {\n        value: node.value,\n        childrenStore: node.childrenStore.map(c => stripParentage(c))\n    };\n    return n;\n};\nconst unwrapped = (node) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = (node) => (`wraps` in node) ? node : wrap(node);\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns\n */\nexport const wrap = (n) => {\n    return {\n        *children() {\n            for (const c of n.childrenStore) {\n                yield wrap(c);\n            }\n        },\n        getValue: () => n.value,\n        getIdentity: () => n,\n        *queryValue(value) {\n            for (const v of queryByValue(value, unwrapped(n))) {\n                yield wrap(v);\n            }\n        },\n        *queryParentsValue(child, value, eq) {\n            for (const v of queryParentsValue(unwrapped(child), value, eq)) {\n                yield wrap(v);\n            }\n        },\n        *parentsValues(child) {\n            yield* parentsValues(unwrapped(child));\n        },\n        findParentsValue(child, value, eq) {\n            const n = findParentsValue(child, value, eq);\n            if (n !== undefined)\n                return wrap(n);\n        },\n        getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n        hasParent: (parent) => {\n            return hasParent(n, unwrapped(parent));\n        },\n        hasAnyParent: (parent) => {\n            return hasAnyParent(n, unwrapped(parent));\n        },\n        hasChild: (child) => {\n            return hasChild(unwrapped(child), n);\n        },\n        hasAnyChild: (child) => {\n            return hasAnyChild(unwrapped(child), n);\n        },\n        remove: () => {\n            remove(n);\n        },\n        addValue: (value) => {\n            const nodeValue = addValue(value, n);\n            return wrap(nodeValue);\n        },\n        add: (child) => {\n            add(unwrapped(child), n);\n            return wrapped(child);\n        },\n        wraps: n\n    };\n};\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child\n * @returns\n */\nexport const remove = (child) => {\n    const p = child.parent;\n    if (p === undefined)\n        return;\n    child.parent = undefined;\n    p.childrenStore = without(p.childrenStore, child);\n};\n/**\n * Depth-first iteration of the children of `node`\n * @param node\n * @returns\n */\nexport function* depthFirst(node) {\n    if (!root)\n        return;\n    const stack = new StackMutable();\n    stack.push(...node.childrenStore);\n    let entry = stack.pop();\n    while (entry) {\n        yield entry;\n        if (entry) {\n            stack.push(...entry.childrenStore);\n        }\n        if (stack.isEmpty)\n            break;\n        entry = stack.pop();\n    }\n}\n/**\n * Breadth-first iteration of the children of `node`\n * @param node\n * @returns\n */\nexport function* breadthFirst(node) {\n    if (!node)\n        return;\n    const queue = new QueueMutable();\n    queue.enqueue(...node.childrenStore);\n    let entry = queue.dequeue();\n    while (entry) {\n        yield entry;\n        if (entry) {\n            queue.enqueue(...entry.childrenStore);\n        }\n        if (queue.isEmpty)\n            break;\n        entry = queue.dequeue();\n    }\n}\n/**\n * Validates the tree from `root` downwards.\n * @param root\n * @param seen\n * @returns\n */\nexport function treeTest(root, seen = []) {\n    if (root.parent === root)\n        return [false, `Root has itself as parent`, root];\n    if (seen.includes(root))\n        return [false, `Same node instance is appearing further in tree`, root];\n    seen.push(root);\n    if (containsDuplicateInstances(root.childrenStore))\n        return [false, `Children list contains duplicates`, root];\n    for (const c of root.childrenStore) {\n        if (c.parent !== root)\n            return [false, `Member of childrenStore does not have .parent set`, c];\n        if (hasAnyChild(root, c))\n            return [false, `Child has parent as its own child`, c];\n        const v = treeTest(c, seen);\n        if (!v[0])\n            return v;\n    }\n    return [true, ``, root];\n}\n/**\n * Throws an exception if `root` fails tree validation\n * @param root\n * @returns\n */\nexport function throwTreeTest(root) {\n    const v = treeTest(root);\n    if (v[0])\n        return;\n    throw new Error(`${v[1]} Node: ${toStringAbbreviate(v[2].value, 30)}`, { cause: v[2] });\n}\n/**\n * Iterate over direct children of `root`, yielding {@link TreeNode} instances.\n * Use {@link childrenValues} to iterate over child values\n * @param root\n */\nexport function* children(root) {\n    for (const c of root.childrenStore) {\n        yield c;\n    }\n}\n/**\n * Iterate over the value ofdirect children of `root`.\n * Use {@link children} if you want to iterate over {@link TreeNode} instances instead.\n * @param root\n */\nexport function* childrenValues(root) {\n    for (const c of root.childrenStore) {\n        if (typeof c.value !== `undefined`)\n            yield c.value;\n    }\n}\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root\n */\nexport function* parents(root) {\n    let p = root.parent;\n    while (p) {\n        yield p;\n        p = p.parent;\n    }\n}\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node\n * @returns\n */\nexport function nodeDepth(node) {\n    const p = [...parents(node)];\n    return p.length;\n}\nexport const hasChild = (child, parent) => {\n    for (const c of parent.childrenStore) {\n        if (c === child)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns the first immediate child of `parent` that matches `value`.\n *\n * Use {@link queryByValue} if you want all matching children.\n * @param value\n * @param parent\n * @param eq\n * @returns\n */\nexport const findChildByValue = (value, parent, eq = isEqualDefault) => {\n    for (const c of parent.childrenStore) {\n        if (eq(value, c.value))\n            return c;\n    }\n};\n/**\n * Yield all immediate children of `parent` that match `value`.\n *\n * Use {@link findChildByValue} if you only want the first matching child.\n * @param value\n * @param parent\n * @param eq\n */\nexport function* queryByValue(value, parent, eq = isEqualDefault) {\n    for (const c of parent.childrenStore) {\n        if (eq(value, c.value))\n            yield c;\n    }\n}\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n *\n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild\n * @param parent\n * @returns\n */\nexport const hasAnyChild = (prospectiveChild, parent) => {\n    for (const c of breadthFirst(parent)) {\n        if (c === prospectiveChild)\n            return true;\n    }\n    return false;\n};\nexport const findAnyChildByValue = (value, parent, eq = isEqualDefault) => {\n    for (const c of breadthFirst(parent)) {\n        if (eq(c.value, value))\n            return c;\n    }\n};\nexport const getRoot = (node) => {\n    if (node.parent)\n        return getRoot(node.parent);\n    return node;\n};\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n *\n * Use {@link hasParent} to only check immediate parent.\n * @param child\n * @param prospectiveParent\n * @returns\n */\nexport const hasAnyParent = (child, prospectiveParent) => {\n    for (const p of parents(child)) {\n        if (p === prospectiveParent)\n            return true;\n    }\n    return false;\n};\n/**\n * Yields the node value of each parent of `child`.\n * _undefined_ values are not returned.\n *\n * Use {@link queryParentsValue} to search for a particular value\n * @param child\n * @returns\n */\nexport function* parentsValues(child) {\n    for (const p of parents(child)) {\n        if (typeof p.value !== `undefined`) {\n            yield p.value;\n        }\n    }\n    return false;\n}\n/**\n * Yields all parents of `child` that have a given value.\n * Use {@link findParentsValue} to find the first match only.\n * @param child\n * @param value\n * @param eq\n * @returns\n */\nexport function* queryParentsValue(child, value, eq = isEqualDefault) {\n    for (const p of parents(child)) {\n        if (typeof p.value !== `undefined`) {\n            if (eq(p.value, value))\n                yield p;\n        }\n    }\n    return false;\n}\n/**\n * Returns the first parent that has a given value.\n * @param child\n * @param value\n * @param eq\n * @returns\n */\nexport function findParentsValue(child, value, eq = isEqualDefault) {\n    for (const p of queryParentsValue(child, value, eq)) {\n        return p;\n    }\n}\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n *\n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child\n * @param prospectiveParent\n * @returns\n */\nexport const hasParent = (child, prospectiveParent) => {\n    return child.parent === prospectiveParent;\n};\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root);\n * ```\n * @param node\n * @returns\n */\nexport const computeMaxDepth = (node) => {\n    return computeMaxDepthImpl(node, 0);\n};\nconst computeMaxDepthImpl = (node, startingDepth = 0) => {\n    let depth = startingDepth;\n    for (const c of node.childrenStore) {\n        depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n    }\n    return depth;\n};\nexport const add = (child, parent) => {\n    throwAttemptedChild(child, parent);\n    //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n    //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n    const p = child.parent;\n    parent.childrenStore = [...parent.childrenStore, child];\n    child.parent = parent;\n    if (p) {\n        p.childrenStore = without(p.childrenStore, child);\n    }\n};\nexport const addValue = (value, parent) => {\n    return createNode(value, parent);\n};\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value\n * @returns\n */\nexport const root = (value) => {\n    return createNode(value);\n};\nexport const fromPlainObject = (value, label = ``, parent, seen = []) => {\n    const entries = Object.entries(value);\n    parent = parent === undefined ? root() : addValue({ label, value }, parent);\n    for (const entry of entries) {\n        const value = entry[1];\n        // Avoid circular references\n        if (seen.includes(value))\n            continue;\n        seen.push(value);\n        if (typeof entry[1] === `object`) {\n            fromPlainObject(value, entry[0], parent, seen);\n        }\n        else {\n            addValue({ label: entry[0], value: value }, parent);\n        }\n    }\n    return parent;\n};\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link Trees.Mutable.root} alternatively.\n * @param value\n * @returns\n */\nexport const rootWrapped = (value) => {\n    return wrap(createNode(value));\n};\n/**\n * Creates a `TreeNode` instance with a given value and parent.\n * Parent node, if specified, has its `childrenStore` property changed to include new child.\n * @param value\n * @param parent\n * @returns\n */\nexport const createNode = (value, parent) => {\n    const n = {\n        childrenStore: [],\n        parent: parent,\n        value: value\n    };\n    if (parent !== undefined) {\n        parent.childrenStore = [...parent.childrenStore, n];\n    }\n    return n;\n};\nexport const childrenLength = (node) => {\n    return node.childrenStore.length;\n};\nexport const value = (node) => {\n    return node.value;\n};\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node\n * @returns\n */\nexport const asDynamicTraversable = (node) => {\n    const t = {\n        *children() {\n            for (const c of node.childrenStore) {\n                yield asDynamicTraversable(c);\n            }\n        },\n        getParent() {\n            if (node.parent === undefined)\n                return;\n            return asDynamicTraversable(node.parent);\n        },\n        getValue() {\n            return node.value;\n        },\n        getIdentity() {\n            return node;\n        },\n    };\n    return t;\n};\nconst throwAttemptedChild = (c, parent) => {\n    if (parent === c)\n        throw new Error(`Cannot add self as child`);\n    if (c.parent === parent)\n        return; // skip if it's already a child\n    if (hasAnyParent(parent, c))\n        throw new Error(`Child contains parent (1)`, { cause: c });\n    if (hasAnyParent(c, parent))\n        throw new Error(`Parent already contains child`, { cause: c });\n    if (hasAnyChild(parent, c))\n        throw new Error(`Child contains parent (2)`, { cause: c });\n};\nexport const setChildren = (parent, children) => {\n    // Verify children are legit\n    for (const c of children) {\n        throwAttemptedChild(c, parent);\n    }\n    parent.childrenStore = [...children];\n    for (const c of children) {\n        c.parent = parent;\n    }\n};\nexport const toStringDeep = (node, indent = 0) => {\n    const t = `${`  `.repeat(indent)} + ${node.value ? JSON.stringify(node.value) : `-`}`;\n    return node.childrenStore.length > 0 ? (t +\n        `\\n` +\n        node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)) : t;\n};\nexport function* followValue(root, continuePredicate, depth = 1) {\n    for (const c of root.childrenStore) {\n        const value = c.value;\n        if (value === undefined)\n            continue;\n        if (continuePredicate(value, depth)) {\n            yield c.value;\n            yield* followValue(c, continuePredicate, depth + 1);\n        }\n    }\n}\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }\n","import { toStringAbbreviate } from '@ixfx/core/text';\nimport { nullUndefTest, resultThrow } from '@ixfx/guards'; //'../../util/GuardEmpty.js';\nimport { last } from '@ixfx/iterables/sync';\nimport * as TreeArrayBacked from './tree-mutable.js';\nimport { isPrimitive } from '@ixfx/core'; //'../../util/IsPrimitive.js';\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link TraverseObjectEntry}.\n * @param entries\n * @returns\n */\nexport function prettyPrintEntries(entries) {\n    if (entries.length === 0)\n        return `(empty)`;\n    let t = ``;\n    for (const [index, entry] of entries.entries()) {\n        t += `  `.repeat(index);\n        t += entry.name + ` = ` + JSON.stringify(entry.leafValue) + `\\n`;\n    }\n    return t;\n}\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const prettyPrint = (node, indent = 0, options = {}) => {\n    resultThrow(nullUndefTest(node, `node`));\n    const defaultName = options.name ?? `node`;\n    const entry = getNamedEntry(node, defaultName);\n    const t = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.leafValue)}`;\n    const childrenAsArray = [...children(node, options)];\n    return childrenAsArray.length > 0 ? (t +\n        `\\n` +\n        childrenAsArray.map((d) => prettyPrint(d.leafValue, indent + 1, { ...options, name: d.name })).join(`\\n`)) : t;\n};\n/**\n * Returns a debug string representation of the node (recursive)\n * @param node\n * @param indent\n * @returns\n */\nexport const toStringDeep = (node, indent = 0) => {\n    let t = ` `.repeat(indent) + ` ${node.value?.name}`;\n    if (node.value !== undefined) {\n        if (`sourceValue` in node.value && `leafValue` in node.value) {\n            let sourceValue = toStringAbbreviate(node.value.sourceValue, 20);\n            const leafValue = toStringAbbreviate(node.value.leafValue, 20);\n            sourceValue = sourceValue === leafValue ? `` : `source: ` + sourceValue;\n            t += ` = ${leafValue} ${sourceValue}`;\n        }\n        else if (`sourceValue` in node.value && node.value.sourceValue !== undefined)\n            t += ` = ${node.value.sourceValue}`;\n        if (`ancestors` in node.value) {\n            t += ` (ancestors: ${(node.value.ancestors).join(`, `)})`;\n        }\n    }\n    t += `\\n`;\n    for (const c of node.childrenStore) {\n        t += toStringDeep(c, indent + 1);\n    }\n    return t;\n};\n/**\n * Yields the direct (ie. non-recursive) children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * To iterate recursively, consider {@link depthFirst}\n *\n * Each child is returned in an {@link TraverseObjectEntry} structure:\n * ```typescript\n * type Entry = Readonly<{\n *  // Property name\n *  name: string,\n *  // Value of property, as if you called `object[propertyName]`\n *  sourceValue: any,\n *  // Branch nodes will have _undefined_, leaf nodes will contain the value\n *  leafValue: any\n * }>;\n * ```\n *\n * For example, iterating over a flat object:\n * ```js\n * const verySimpleObject = { field: `hello`, flag: true }\n * const kids = [ ...children(verySimpleObject) ];\n * // Yields:\n * // [ { name: \"field\", sourceValue: `hello`, leafValue: `hello` },\n * //  { name: \"flag\", sourceValue: true, leafValue: true } ]\n * ```\n *\n * For objects containing objects:\n * ```js\n * const lessSimpleObject = { field: `hello`, flag: true, colour: { `red`, opacity: 0.5 } }\n * const kids = [ ...children(verySimpleObject) ];\n * // Yields as before, plus:\n * //  { name: \"colour\", sourceValue: { name: 'red', opacity: 0.5 }, leafValue: undefined }\n * ```\n *\n * Note that 'sourceValue' always contains the property value, as if you\n * access it via `object[propName]`. 'leafValue' only contains the value if it's a leaf\n * node.\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport function* children(node, options = {}) {\n    resultThrow(nullUndefTest(node, `node`));\n    const filteringOption = options.filter ?? `none`;\n    const filterByValue = (v) => {\n        if (filteringOption === `none`)\n            return [true, isPrimitive(v)];\n        else if (filteringOption === `leaves` && isPrimitive(v))\n            return [true, true];\n        else if (filteringOption === `branches` && !isPrimitive(v))\n            return [true, false];\n        return [false, isPrimitive(v)];\n    };\n    if (Array.isArray(node)) {\n        //if (options.name === undefined) defaultName = `array`;\n        for (const [index, element] of node.entries()) {\n            const f = filterByValue(element);\n            if (f[0]) {\n                yield { name: index.toString(), _kind: `entry`, sourceValue: element, leafValue: f[1] ? element : undefined };\n                //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, leafValue: f[ 1 ] ? element : undefined };\n            }\n        }\n    }\n    else if (typeof node === `object`) {\n        const entriesIter = (`entries` in node) ? node.entries() : Object.entries(node);\n        for (const [name, value] of entriesIter) {\n            //console.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n            const [filter, isPrimitive] = filterByValue(value);\n            if (filter) {\n                yield { name: name, _kind: `entry`, sourceValue: value, leafValue: isPrimitive ? value : undefined };\n            }\n        }\n    }\n}\nexport function* depthFirst(node, options = {}, ancestors = []) {\n    for (const c of children(node, options)) {\n        //onsole.log(`depthFirst name: ${ c.name } leafValue: ${ toStringAbbreviate(c.leafValue) }`)\n        yield { ...c, ancestors: [...ancestors], _kind: `entry-ancestors` };\n        yield* depthFirst(c.sourceValue, options, [...ancestors, c.name]);\n    }\n}\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName(name, node) {\n    for (const d of children(node)) {\n        if (d.name === name)\n            return d;\n    }\n}\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath(path, node, options = {}) {\n    //  Unit tested\n    const v = last(traceByPath(path, node, options));\n    if (!v)\n        throw new Error(`Could not trace path: ${path} `);\n    return v;\n}\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceByPath(path, node, options = {}) {\n    resultThrow(nullUndefTest(path, `path`), nullUndefTest(node, `node`));\n    const separator = options.separator ?? `.`;\n    // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n    const pathSplit = path.split(separator);\n    const ancestors = [];\n    for (const p of pathSplit) {\n        const entry = childByName(p, node);\n        //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n        // if (allowArrayIndexes) {\n        //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n        //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n        //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n        //   if (arrayIndex >= 0) {\n        //     // Get array by name without the []\n        //     entry = childByName(withoutBrackets, node);\n        //     //onsole.log(`  entry: ${ entry?.name }`);\n        //     if (entry && Array.isArray(entry.sourceValue)) {\n        //       // Result was array as expected\n        //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], leafValue: entry.sourceValue[ arrayIndex ] };\n        //     }\n        //   }\n        // }\n        if (!entry) {\n            yield { name: p, sourceValue: undefined, leafValue: undefined, ancestors, _kind: `entry-ancestors` };\n            return;\n        }\n        node = entry.sourceValue;\n        yield { ...entry, ancestors: [...ancestors], _kind: `entry-ancestors` };\n        ancestors.push(p);\n    }\n}\n/**\n * Returns a projection of `node` as a dynamic traversable.\n * This means that the tree structure is dynamically created as last-minute as possible.\n *\n * The type when calling `getValue()` is {@link TraverseObjectEntryStatic}:\n * ```typescript\n * type EntryStatic = Readonly<{\n *  name: string,\n *  value: any\n *  ancestors: string[]\n * }>\n * ```\n *\n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n *\n * ```js\n * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n *\n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n *\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n *\n * Instead .getIdentity() to get a stable identity:\n * ```js\n * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n *\n * @example\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const myObj = { name: `Pedro`, size: 45, colour: `orange` };\n * const root = Trees.FromObject.asDynamicTraversable(myObj);\n * for (const v of Trees.Traverse.breadthFirst(root)) {\n * // v.getValue() yields:\n * // { name: 'name', sourceValue: 'Pedro' ...},\n * // { name: 'size', sourceValue: 45 ... }\n * // ...\n * }\n * ```\n * @param node Object to read\n * @param options Options when creating traversable\n * @param ancestors Do not use\n * @param parent Do not use\n * @returns\n */\nexport const asDynamicTraversable = (node, options = {}, ancestors = [], parent) => {\n    const name = options.name ?? `object`;\n    const t = {\n        *children() {\n            for (const { name: childName, sourceValue, leafValue } of children(node, options)) {\n                yield asDynamicTraversable(sourceValue, { ...options, name: childName }, [...ancestors, name], t);\n            }\n        },\n        getParent() {\n            return parent;\n        },\n        getValue() {\n            return { name, sourceValue: node, ancestors, _kind: `entry-static` };\n        },\n        getIdentity() {\n            return node;\n        }\n    };\n    return t;\n};\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node\n * @param options\n * @returns\n */\nexport const createWrapped = (node, options) => {\n    return TreeArrayBacked.wrap(create(node, options));\n};\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure.\n * The structure is a snapshot of the object. If the object changes afterwards, the tree will\n * remain the same.\n *\n * Alternatively, consider {@link asDynamicTraversable} which reads the object dynamically.\n * @example\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const myObj = { name: `Pedro`, size: 45, colour: `orange` };\n * const root = Trees.FromObject.create(myObj);\n * for (const v of Trees.Traverse.breadthFirst(root)) {\n * // v.getValue() yields:\n * // { name: 'name', sourceValue: 'Pedro' ...},\n * // { name: 'size', sourceValue: 45 ... }\n * // ...\n * }\n * ```\n * @param node\n * @param options\n * @returns\n */\nexport const create = (node, options = {}) => {\n    const valuesAtLeaves = options.valuesAtLeaves ?? false;\n    const valueFor = valuesAtLeaves ? (v) => { if (isPrimitive(v))\n        return v; } : (v) => v;\n    return createImpl(node, valueFor(node), options, []);\n};\nconst createImpl = (sourceValue, leafValue, options = {}, ancestors) => {\n    const defaultName = options.name ?? `object_ci`;\n    //onsole.log(`createImpl name: ${ defaultName } leafValue: ${ JSON.stringify(leafValue) }`);\n    const r = TreeArrayBacked.root({ name: defaultName, sourceValue: leafValue, ancestors: [...ancestors], _kind: `entry-static` });\n    ancestors = [...ancestors, defaultName];\n    for (const c of children(sourceValue, options)) {\n        const v = options.valuesAtLeaves ? c.leafValue : c.sourceValue;\n        TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n    }\n    return r;\n};\n/**\n * Returns a copy of `node` with its (and all its children's) parent information removed.\n * @param node\n * @param options\n * @returns\n */\nexport const createSimplified = (node, options = {}) => {\n    return TreeArrayBacked.stripParentage(create(node, options));\n};\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry(node, defaultName = ``) {\n    if (`name` in node && `leafValue` in node && `sourceValue` in node)\n        return {\n            name: node.name,\n            _kind: `entry`,\n            leafValue: node.leafValue,\n            sourceValue: node.sourceValue\n        };\n    if (`name` in node) {\n        return { name: node.name, leafValue: node, sourceValue: node, _kind: `entry` };\n    }\n    return { name: defaultName, leafValue: node, sourceValue: node, _kind: `entry` };\n}\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }\n","import * as TreeArrayBacked from \"./tree-mutable.js\";\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n *\n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n *\n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n *\n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n *\n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts\n * @returns\n */\nexport const create = (pathOpts = {}) => {\n    let root;\n    const add = (value, path) => {\n        const n = addValueByPath(value, path, root, pathOpts);\n        if (root === undefined) {\n            root = TreeArrayBacked.getRoot(n);\n        }\n    };\n    const prettyPrint = () => {\n        if (root === undefined)\n            return `(empty)`;\n        return TreeArrayBacked.toStringDeep(root);\n    };\n    const getValue = (path) => {\n        if (root === undefined)\n            return;\n        return valueByPath(path, root, pathOpts);\n    };\n    const remove = (path) => {\n        if (root === undefined)\n            return false;\n        return removeByPath(path, root, pathOpts);\n    };\n    const hasPath = (path) => {\n        if (root === undefined)\n            return false;\n        const c = findChildByPath(path, root, pathOpts);\n        return c !== undefined;\n    };\n    const getNode = (path) => {\n        if (root === undefined)\n            return;\n        const c = findChildByPath(path, root, pathOpts);\n        return c;\n    };\n    const childrenLength = (path) => {\n        if (root === undefined)\n            return 0;\n        const c = findChildByPath(path, root, pathOpts);\n        if (c === undefined)\n            return 0;\n        return c.childrenStore.length;\n    };\n    const getValues = (path) => {\n        if (root === undefined)\n            return [];\n        return valuesByPath(path, root, pathOpts);\n    };\n    const getRoot = () => {\n        return root;\n    };\n    const clearValues = (path) => {\n        if (root === undefined)\n            return false;\n        return clearValuesByPath(path, root, pathOpts);\n    };\n    return { getRoot, add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues };\n};\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n *\n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = (value, path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n    const split = path.split(separator);\n    let count = 0;\n    for (const p of split) {\n        const lastEntry = count === split.length - 1;\n        //onsole.log(`p: ${ p }`);\n        const found = findChildByLabel(p, node);\n        if (found === undefined) {\n            //onsole.log(`  - not found`);\n            const labelled = {\n                value: (lastEntry ? value : undefined),\n                label: p\n            };\n            node = TreeArrayBacked.createNode(labelled, node);\n        }\n        else {\n            node = found;\n            if (lastEntry) {\n                switch (duplicatePath) {\n                    case `ignore`: {\n                        break;\n                    }\n                    case `allow`: {\n                        const existing = getValuesFromNode(node);\n                        node.value = {\n                            values: [...existing, value],\n                            label: p\n                        };\n                        break;\n                    }\n                    case `overwrite`: {\n                        node.value = {\n                            value,\n                            label: p\n                        };\n                        break;\n                    }\n                }\n            }\n            else {\n                //onsole.log(`  - found!`, found.value);\n                node = found;\n            }\n        }\n        count++;\n    }\n    if (node === undefined)\n        throw new Error(`Could not create tree`);\n    return node;\n};\nexport const removeByPath = (path, root, pathOpts = {}) => {\n    if (root === undefined)\n        return false;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined)\n        return false;\n    TreeArrayBacked.remove(c);\n    return true;\n};\nexport const clearValuesByPath = (path, root, pathOpts = {}) => {\n    if (root === undefined)\n        return false;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined)\n        return false;\n    c.value = {\n        label: c.value?.label ?? ``,\n        value: undefined\n    };\n    return true;\n};\nexport const childrenLengthByPath = (path, node, pathOpts = {}) => {\n    if (node === undefined)\n        return 0;\n    const c = findChildByPath(path, node, pathOpts);\n    if (c === undefined)\n        return 0;\n    return c.childrenStore.length;\n};\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = (label, node) => {\n    if (node === undefined)\n        return undefined;\n    if (label === undefined)\n        throw new Error(`Parameter 'label' cannot be undefined`);\n    if (node.value?.label === label)\n        return node;\n    for (const c of node.childrenStore) {\n        if (c.value?.label === label)\n            return c;\n    }\n};\nexport const valueByPath = (path, node, pathOpts = {}) => {\n    const values = valuesByPath(path, node, pathOpts);\n    if (values.length === 0)\n        return undefined;\n    if (values.length > 1)\n        throw new Error(`Multiple values at path. Use getValues instead`);\n    return values[0];\n};\nconst getValuesFromNode = (c) => {\n    if (c.value === undefined)\n        return [];\n    if (`values` in c.value)\n        return c.value.values;\n    if (`value` in c.value) {\n        if (c.value.value === undefined)\n            return [];\n        return [c.value.value];\n    }\n    return [];\n};\nconst findChildByPath = (path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const split = path.split(separator);\n    let c = node;\n    for (const p of split) {\n        c = findChildByLabel(p, c);\n        if (c === undefined) {\n            return;\n        }\n    }\n    return c;\n};\nexport const valuesByPath = (path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const split = path.split(separator);\n    let c = node;\n    for (const p of split) {\n        //onsole.log(`getValue p: ${ p }`);\n        c = findChildByLabel(p, c);\n        if (c === undefined) {\n            //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n            return [];\n        }\n    }\n    return getValuesFromNode(c);\n};\n","import { toStringAbbreviate } from \"@ixfx/core/text\";\nimport { isEqualDefault } from \"@ixfx/core\"; //\"../../util/IsEqual.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { isTraversable } from \"./index.js\";\nexport const childrenLength = (tree) => {\n    return [...tree.children()].length;\n};\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = (child, possibleParent, eq) => {\n    return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const hasAnyParentValue = (child, possibleParentValue, eq) => {\n    if (typeof child === `undefined`)\n        throw new TypeError(`Param 'child' is undefined`);\n    return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const findAnyParentByValue = (child, possibleParentValue, eq) => {\n    return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = (child, possibleParent, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    const isChildTrav = isTraversable(child);\n    const isParentTrav = isTraversable(possibleParent);\n    const p = (isChildTrav ? child.getParent() : child.parent);\n    if (typeof p === `undefined`)\n        return false;\n    if (eq(p, possibleParent))\n        return true;\n    const pId = isChildTrav ? p.getIdentity() : p.value;\n    const ppId = isParentTrav ? (possibleParent).getIdentity() : possibleParent.value;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    if (eq(pId, ppId))\n        return true;\n    //if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n    return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\n/**\n * Checks if a child node has a parent with a certain value\n * Note: by default only checks immediate parent. Set maxDepth to a large value to recurse\n *\n * Uses `getValue()` on the parent if that function exists.\n * @param child Node to start looking from\n * @param possibleParentValue Value to seek\n * @param eq Equality checker\n * @param maxDepth Defaults to 0, so it only checks immediate parent\n * @returns\n */\nexport const hasParentValue = (child, possibleParentValue, eq = (isEqualDefault), maxDepth = 0) => {\n    if (child === undefined)\n        throw new Error(`Param 'child' is undefined`);\n    if (maxDepth < 0) {\n        return false;\n    }\n    const p = `getParent` in child ? child.getParent() : child.parent;\n    if (p === undefined) {\n        return false;\n    }\n    const value = `getValue` in p ? p.getValue() : p.value;\n    if (eq(value, possibleParentValue))\n        return true;\n    return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\nexport const findParentByValue = (child, possibleParentValue, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return;\n    const p = (`getParent` in child ? child.getParent() : child.parent);\n    if (p === undefined)\n        return;\n    const value = `getValue` in p ? p.getValue() : p.value;\n    if (eq(value, possibleParentValue))\n        return p;\n    return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = (parent, prospectiveChild, eq = isEqualDefault) => {\n    if (eq(parent, prospectiveChild))\n        throw new Error(`Child equals parent`);\n    if (hasAnyChild(parent, prospectiveChild, eq)) {\n        throw new Error(`Circular. Parent already has child`);\n    }\n    if (hasAnyChild(prospectiveChild, parent, eq)) {\n        throw new Error(`Prospective child has parent as child relation`);\n    }\n};\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = (parent, possibleChild, eq = isEqualDefault) => {\n    return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const hasAnyChildValue = (parent, possibleChildValue, eq = isEqualDefault) => {\n    return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = (parent, possibleChild, eq = isEqualDefault, maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    if (eq(parent, possibleChild))\n        return true;\n    const pId = `getIdentity` in parent ? parent.getIdentity() : parent.value;\n    const pcId = `getIdentity` in possibleChild ? possibleChild.getIdentity() : possibleChild.value;\n    if (eq(pId, pcId))\n        return true;\n    for (const c of breadthFirst(parent, maxDepth)) {\n        const cId = `getIdentity` in c ? c.getIdentity() : c.value;\n        if (eq(c, possibleChild))\n            return true;\n        if (eq(cId, pcId))\n            return true;\n    }\n    return false;\n};\nexport const hasChildValue = (parent, possibleValue, eq = isEqualDefault, maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    if (eq(parent.getValue(), possibleValue))\n        return true;\n    for (const c of breadthFirst(parent, maxDepth)) {\n        const v = c.getValue();\n        if (eq(v, possibleValue))\n            return true;\n    }\n    return false;\n};\n/**\n * Iterates over siblings of `node`.\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns\n */\nexport function* siblings(node) {\n    const p = node.getParent();\n    if (p === undefined)\n        return;\n    for (const s of p.children()) {\n        if (s === node)\n            continue;\n        yield s;\n    }\n}\n// export function parents<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>>;\n// export function parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>>;\n/**\n * Iterates over parents of `node`, starting with immediate parent\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns\n */\nexport function* parents(node) {\n    if (isTraversable(node)) {\n        let p = node.getParent();\n        while (p !== undefined) {\n            yield p;\n            p = p.getParent();\n        }\n    }\n    else {\n        let p = node.parent;\n        while (p !== undefined) {\n            yield p;\n            p = p.parent;\n        }\n    }\n}\n// export function findAnyChildByValue<TValue>(parent: TraversableTree<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TraversableTree<TValue> | undefined;\n// export function findAnyChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TreeNode<TValue> | undefined;\n/**\n * Descends `parent`, breadth-first, looking for a particular value.\n * Returns _undefined_ if not found.\n * @param parent\n * @param possibleValue\n * @param eq\n * @returns\n */\nexport function findAnyChildByValue(parent, possibleValue, eq = isEqualDefault) {\n    return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n}\n;\n// export function findChildByValue<T extends TraversableTree<TV> | TreeNode<TV>, TV>(parent: T,\n//   possibleValue: TV,\n//   eq?: IsEqual<TV>,\n//   maxDepth?: number\n// ): TraversableTree<TV> | undefined;\n// export function findChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>,\n//   maxDepth?: number\n// ): TreeNode<TValue> | undefined;\n/**\n * Searches breadth-first for `possibleValue` under and including `parent`.\n * `maxDepth` sets he maximum level to which the tree is searched.\n * @param parent\n * @param possibleValue\n * @param eq\n * @param maxDepth\n * @returns\n */\nexport function findChildByValue(parent, possibleValue, eq = isEqualDefault, maxDepth = 0) {\n    if (maxDepth < 0)\n        return;\n    const isTraver = isTraversable(parent);\n    if (isTraver) {\n        if (eq(parent.getValue(), possibleValue))\n            return parent;\n    }\n    else {\n        if (eq(parent.value, possibleValue))\n            return parent;\n    }\n    for (const d of breadthFirst(parent, maxDepth)) {\n        // This child matches\n        if (isTraver) {\n            if (eq(d.getValue(), possibleValue))\n                return d;\n        }\n        else {\n            if (eq(d.value, possibleValue))\n                return d;\n        }\n    }\n    return;\n}\n;\n/**\n * Iterates over children of `root`, depth-first.\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @returns\n */\nexport function* depthFirst(root) {\n    if (!root)\n        return;\n    const stack = new StackMutable();\n    let entry = root;\n    while (entry) {\n        const entries = isTraversable(entry) ?\n            [...entry.children()] :\n            [...entry.childrenStore];\n        stack.push(...entries);\n        if (stack.isEmpty)\n            break;\n        entry = stack.pop();\n        if (entry)\n            yield entry;\n    }\n}\n//export function breadthFirst<T>(root: TraversableTree<T>, depth?: number): IterableIterator<TraversableTree<T>>;\n//export function breadthFirst<T>(root: TreeNode<T>, depth?: number): IterableIterator<TreeNode<T>>;\n/**\n * Iterates over the children of `root`, breadth-first\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n *\n * @example Traversing over a simple object\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const myObj = { name: `Pedro`, size: 45, colour: `orange` };\n * const root = Trees.FromObject.asDynamicTraversable(myObj);\n * for (const v of Trees.Traverse.breadthFirst(root)) {\n * // v.getValue() yields:\n * // { name: 'name', sourceValue: 'Pedro' ...},\n * // { name: 'size', sourceValue: 45 ... }\n * // ...\n * }\n * ```\n * @param root Root node\n * @param depth How many levels to traverse\n * @returns\n */\nexport function* breadthFirst(root, depth = Number.MAX_SAFE_INTEGER) {\n    if (!root)\n        return;\n    const isTrav = isTraversable(root);\n    const queue = isTrav ? new QueueMutable() : new QueueMutable();\n    let entry = root;\n    while (entry) {\n        if (depth < 0)\n            return;\n        if (entry !== undefined) {\n            const kids = `childrenStore` in entry ? entry.childrenStore : entry.children();\n            for (const c of kids) {\n                yield c;\n                queue.enqueue(c);\n            }\n        }\n        entry = queue.dequeue();\n        depth--;\n    }\n}\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root\n * @param predicate\n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns\n */\nexport function find(root, predicate, order = `breadth`) {\n    if (predicate(root))\n        return root;\n    const iter = order === `breadth` ? breadthFirst : depthFirst;\n    for (const c of iter(root)) {\n        if (predicate(c))\n            return c;\n    }\n}\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n *\n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root\n * @param predicate\n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns\n */\nexport function findByValue(root, predicate, order = `breadth`) {\n    if (predicate(root.getValue()))\n        return root;\n    const iter = order === `breadth` ? breadthFirst : depthFirst;\n    for (const c of iter(root)) {\n        if (predicate(c.getValue()))\n            return c;\n    }\n}\n/**\n * Search through children in a path-like manner.\n *\n * It finds the first child of `root` that matches `continuePredicate`.\n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n *\n * If it can't find a child, it stops.\n *\n * This is different to 'find' functions, which exhaustively search all possible child nodes, regardless of position in tree.\n *\n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n *\n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root\n * @param continuePredicate\n * @param depth\n */\nexport function* followValue(root, continuePredicate, depth = 1) {\n    for (const c of root.children()) {\n        if (continuePredicate(c.getValue(), depth)) {\n            yield c.getValue();\n            yield* followValue(c, continuePredicate, depth + 1);\n        }\n    }\n}\nexport function toStringDeep(node, depth = 0) {\n    if (node === undefined)\n        return `(undefined)`;\n    if (node === null)\n        return `(null)`;\n    const v = node.getValue();\n    let type = typeof v;\n    if (Array.isArray(v))\n        type = `array`;\n    let t = `  `.repeat(depth) + `value: ${JSON.stringify(v)} (${type})\\n`;\n    for (const n of node.children()) {\n        t += toStringDeep(n, depth + 1);\n    }\n    return t;\n}\nexport function toString(...nodes) {\n    let t = ``;\n    for (const node of nodes) {\n        const v = node.getValue();\n        const vString = toStringAbbreviate(v);\n        const children = [...node.children()];\n        const parent = node.getParent();\n        let type = typeof v;\n        if (Array.isArray(v))\n            type = `array`;\n        t += `value: ${vString} (${type}) kids: ${children.length} parented: ${parent ? `y` : `n`}\\n`;\n    }\n    return t;\n}\n","import { asDynamicTraversable as ObjectToTraversable } from './traverse-object.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './tree-mutable.js';\nexport * as Mutable from './tree-mutable.js';\nexport * as Pathed from './pathed.js';\nexport * as FromObject from './traverse-object.js';\nexport * as Traverse from './traversable-tree.js';\nexport * from './compare.js';\n/**\n * Makes a 'traversable' to move around a {@link TreeNode}, an existing {@link TraversableTree} or a plain object.\n *\n * @param node\n * @returns\n */\nexport const toTraversable = (node) => {\n    if (isTraversable(node))\n        return node;\n    if (isTreeNode(node))\n        return TreeNodeToTraversable(node);\n    if (typeof node === `object`)\n        return ObjectToTraversable(node);\n    throw new Error(`Parameter 'node' not convertible`);\n};\n/**\n * Checks whether `node` is of type {@link TreeNode}.\n *\n * Checks for: parent, childrenStore and value defined on `node`.\n * @param node\n * @returns\n */\nexport const isTreeNode = (node) => {\n    if (`parent` in node && `childrenStore` in node && `value` in node) {\n        if (Array.isArray(node.childrenStore))\n            return true;\n    }\n    return false;\n};\n/**\n * Checks if `node` is of type {@link TraversableTree}.\n *\n * Checks by looking for: children, getParent, getValue and getIdentity defined on `node`.\n * @param node\n * @returns\n */\nexport const isTraversable = (node) => {\n    return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n};\n","import { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nexport class StackImmutable {\n    opts;\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    push(...toAdd) {\n        return new StackImmutable(this.opts, push(this.opts, this.data, ...toAdd));\n    }\n    pop() {\n        return new StackImmutable(this.opts, pop(this.opts, this.data));\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = (options = {}, ...startingItems) => new StackImmutable({ ...options }, [...startingItems]);\n","export * from './IStack.js';\nexport * from './IStackMutable.js';\nexport * from './IStackImmutable.js';\nexport * from './StackImmutable.js';\nexport * from './StackMutable.js';\nexport * from './StackFns.js';\n","//  UNIT TESTED\nimport { defaultKeyer } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\nimport {} from './ISetMutable.js';\nimport {} from './Types.js';\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = (keyString) => new SetStringMutable(keyString);\n/**\n * Mutable string set\n */\nexport class SetStringMutable extends SimpleEventEmitter {\n    //  UNIT TESTED\n    /* eslint-disable functional/prefer-readonly-type */\n    store = new Map();\n    keyString;\n    /**\n     * Constructor\n     * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n     */\n    constructor(keyString) {\n        super();\n        this.keyString = keyString ?? (defaultKeyer);\n    }\n    /**\n     * Number of items stored in set\n     */\n    get size() {\n        return this.store.size;\n    }\n    /**\n     * Adds one or more items to set. `add` event is fired for each item\n     * @param values items to add\n     */\n    add(...values) {\n        //eslint-disable-next-line functional/no-let\n        let somethingAdded = false;\n        for (const value of values) {\n            const isUpdated = this.has(value);\n            this.store.set(this.keyString(value), value);\n            super.fireEvent(`add`, { value: value, updated: isUpdated });\n            if (!isUpdated)\n                somethingAdded = true;\n        }\n        return somethingAdded;\n    }\n    /**\n     * Returns values from set as an iterable\n     * @returns\n     */\n    //eslint-disable-next-line functional/prefer-tacit\n    values() {\n        return this.store.values();\n    }\n    /**\n     * Clear items from set\n     */\n    clear() {\n        this.store.clear();\n        super.fireEvent(`clear`, true);\n    }\n    /**\n     * Delete value from set.\n     * @param v Value to delete\n    * @returns _True_ if item was found and removed\n     */\n    delete(v) {\n        const isDeleted = this.store.delete(this.keyString(v));\n        if (isDeleted)\n            super.fireEvent(`delete`, v);\n        return isDeleted;\n    }\n    /**\n     * Returns _true_ if item exists in set\n     * @param v\n     * @returns\n     */\n    has(v) {\n        return this.store.has(this.keyString(v));\n    }\n    /**\n     * Returns array copy of set\n     * @returns Array copy of set\n     */\n    toArray() {\n        return [...this.store.values()];\n    }\n}\n","import { defaultKeyer, toStringDefault } from '@ixfx/core';\nimport {} from './ISetImmutable.js';\nexport class SetStringImmutable {\n    store;\n    keyString;\n    //eslint-disable-next-line functional/prefer-immutable-types\n    constructor(keyString, map) {\n        this.store = map ?? new Map();\n        this.keyString = keyString ?? (defaultKeyer);\n    }\n    get size() {\n        return this.store.size;\n    }\n    add(...values) {\n        const s = new Map(this.store);\n        for (const v of values) {\n            const key = this.keyString(v);\n            s.set(key, v);\n        }\n        return new SetStringImmutable(this.keyString, s);\n    }\n    delete(v) {\n        const s = new Map(this.store);\n        const key = this.keyString(v);\n        if (s.delete(key))\n            return new SetStringImmutable(this.keyString, s);\n        return this;\n    }\n    has(v) {\n        const key = this.keyString(v);\n        return this.store.has(key);\n    }\n    toArray() {\n        return [...this.store.values()];\n    }\n    *values() {\n        yield* this.store.values();\n    }\n}\n/**\n * Immutable set that uses a `keyString` function to determine uniqueness\n *\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`.\n * @returns\n */\nexport const immutable = (keyString = toStringDefault) => new SetStringImmutable(keyString);\n","/**\n * MassiveSet supports semantics similar to Set, but without the\n * limitation on how much data is stored.\n *\n * It only supports strings, and stores data in a hierarchy.\n *\n * ```js\n * const set = new MassiveSet(); // maxDepth=1 default\n * set.add(`test`);\n * set.add(`bloorp`);\n * ```\n *\n * In the above example, it will create a subtree for the first letter\n * of each key, putting the value underneath it. So we'd get a sub\n * MassiveSet for every key starting with 't' and every one starting with 'b'.\n *\n * If `maxDepth` was 2, we'd get the same two top-level nodes, but then\n * another sub-node based on the _second_ character of the value.\n *\n * It's not a very smart data-structure since it does no self-balancing\n * or tuning.\n */\nexport class MassiveSet {\n    #depth;\n    #maxDepth;\n    children = new Map();\n    values = [];\n    constructor(maxDepth = 1, depth = 0) {\n        this.#depth = depth;\n        this.#maxDepth = maxDepth;\n    }\n    /**\n     * Returns the number of values stored in just this level of the set\n     * @returns\n     */\n    sizeLocal() {\n        return this.values.length;\n    }\n    /**\n     * Returns the number of branches at this node\n     * Use {@link sizeChildrenDeep} to count all branches recursively\n     * @returns\n     */\n    sizeChildren() {\n        return [...this.children.values()].length;\n    }\n    sizeChildrenDeep() {\n        let t = this.sizeChildren();\n        for (const c of this.children.values()) {\n            t += c.sizeChildrenDeep();\n        }\n        return t;\n    }\n    /**\n     * Returns the total number of values stored in the set\n     */\n    size() {\n        let x = this.values.length;\n        for (const set of this.children.values()) {\n            x += set.size();\n        }\n        return x;\n    }\n    add(value) {\n        if (typeof value !== `string`)\n            throw new Error(`Param 'value' must be a string. Got: ${typeof value}`);\n        if (value.length === 0)\n            throw new Error(`Param 'value' is empty`);\n        const destination = this.#getChild(value, true);\n        if (destination === this) {\n            if (!this.hasLocal(value)) {\n                this.values.push(value);\n            }\n            return;\n        }\n        if (!destination)\n            throw new Error(`Could not create child set for: ${value}`);\n        destination.add(value);\n    }\n    remove(value) {\n        if (typeof value !== `string`)\n            throw new Error(`Param 'value' must be a string. Got: ${typeof value}`);\n        if (value.length === 0)\n            throw new Error(`Param 'value' is empty`);\n        const destination = this.#getChild(value, false);\n        if (destination === undefined)\n            return false;\n        if (destination === this) {\n            if (this.hasLocal(value)) {\n                this.values = this.values.filter(v => v !== value);\n                return true;\n            }\n            return false; // Not found\n        }\n        return destination.remove(value);\n    }\n    debugDump() {\n        const r = this.#dumpToArray();\n        for (const rr of r) {\n            console.log(rr);\n        }\n    }\n    #dumpToArray(depth = 0) {\n        const r = [];\n        r.push(`Depth: ${this.#depth} Max: ${this.#maxDepth}`);\n        for (const [key, value] of this.children.entries()) {\n            const dumped = value.#dumpToArray(depth + 1);\n            r.push(` key: ${key}`);\n            for (const d of dumped) {\n                r.push(` `.repeat(depth + 1) + d);\n            }\n        }\n        r.push(`Values: (${this.values.length})`);\n        for (const v of this.values) {\n            r.push(` ${v}`);\n        }\n        return r.map(line => ` `.repeat(depth) + line);\n    }\n    #getChild(value, create) {\n        if (value === undefined)\n            throw new Error(`Param 'value' undefined`);\n        if (this.#depth === this.#maxDepth)\n            return this;\n        if (value.length <= this.#depth)\n            return this;\n        const k = value[this.#depth];\n        if (k === undefined)\n            throw new Error(`Logic error. Depth: ${this.#depth} Len: ${value.length}`);\n        let child = this.children.get(k);\n        if (child === undefined && create) {\n            child = new MassiveSet(this.#maxDepth, this.#depth + 1);\n            this.children.set(k, child);\n        }\n        return child;\n    }\n    /**\n     * Returns _true_ if `value` stored on this node\n     * @param value\n     * @returns\n     */\n    hasLocal(value) {\n        for (const v of this.values) {\n            if (v === value)\n                return true;\n        }\n        return false;\n    }\n    has(value) {\n        if (typeof value !== `string`)\n            return false;\n        const destination = this.#getChild(value, false);\n        if (destination === undefined)\n            return false;\n        if (destination === this)\n            return this.hasLocal(value);\n        return destination.has(value);\n    }\n}\n","export * from './set-mutable.js';\nexport * from './SetImmutable.js';\nexport {} from './ISetMutable.js';\nexport {} from './ISetImmutable.js';\nexport * from './massive-set.js';\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { isEqualDefault } from \"@ixfx/core\";\nimport { max as IterablesMax, min as IterablesMin, last as IterablesLast } from \"@ixfx/iterables\";\nimport { QueueMutable } from \"./queue-mutable.js\";\n/**\n * Simple priority queue implementation.\n * Higher numbers mean higher priority.\n *\n * ```js\n * const pm = new PriorityMutable();\n *\n * // Add items with a priority (higher numeric value = higher value)\n * pm.enqueueWithPriority(`hello`, 4);\n * pm.enqueueWithPriotity(`there`, 1);\n *\n * ```\n */\nexport class PriorityMutable extends QueueMutable {\n    constructor(opts = {}) {\n        if (opts.eq === undefined) {\n            opts = {\n                ...opts,\n                eq: (a, b) => {\n                    return isEqualDefault(a.item, b.item);\n                }\n            };\n        }\n        super(opts);\n    }\n    /**\n     * Adds an item with a given priority\n     * @param item Item\n     * @param priority Priority (higher numeric value means higher priority)\n     */\n    enqueueWithPriority(item, priority) {\n        resultThrow(numberTest(priority, `positive`));\n        super.enqueue({ item, priority });\n    }\n    changePriority(item, priority, addIfMissing = false, eq) {\n        if (item === undefined)\n            throw new Error(`Item cannot be undefined`);\n        let toDelete;\n        for (const d of this.data) {\n            if (eq) {\n                if (eq(d.item, item)) {\n                    toDelete = d;\n                    break;\n                }\n            }\n            else {\n                if (this.eq(d, { item, priority: 0 })) {\n                    toDelete = d;\n                    break;\n                }\n            }\n        }\n        if (toDelete === undefined && !addIfMissing)\n            throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(item)}`);\n        if (toDelete !== undefined) {\n            this.removeWhere(item => toDelete === item);\n        }\n        this.enqueueWithPriority(item, priority);\n    }\n    dequeueMax() {\n        //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        this.removeWhere(item => item === m);\n        return m.item;\n    }\n    dequeueMin() {\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        //const m = IterablesLast(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        this.removeWhere(item => item.item === m);\n        return m.item;\n    }\n    peekMax() {\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n        if (m === undefined)\n            return;\n        return m.item;\n    }\n    peekMin() {\n        //const m = IterablesLast<V>(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n        const m = IterablesLast(IterablesMin(this.data, (a, b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        return m.item;\n    }\n}\n/**\n * Creates a {@link PriorityMutable} queue.\n *\n * Options:\n * * eq: Equality function\n * * capacity: limit on number of items\n * * discardPolicy: what to do if capacity is reached\n * @param opts\n * @returns\n */\nexport function priority(opts = {}) {\n    return new PriorityMutable(opts);\n}\n","import { peek, isFull, isEmpty, enqueue, dequeue } from './queue-fns.js';\nimport {} from './queue-types.js';\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable {\n    opts;\n    #data;\n    /**\n     * Creates an instance of Queue.\n     * @param {QueueOpts} opts Options foor queue\n     * @param {V[]} data Initial data. Index 0 is front of queue\n     */\n    constructor(opts = {}, data = []) {\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.opts = opts;\n        this.#data = data;\n    }\n    forEach(fn) {\n        //eslint-disable-next-line functional/no-let\n        for (let index = this.#data.length - 1; index >= 0; index--) {\n            fn(this.#data[index]);\n        }\n    }\n    forEachFromFront(fn) {\n        // From front of queue\n        this.#data.forEach(item => { fn(item); }); //(vv) => fn(vv));\n    }\n    enqueue(...toAdd) {\n        return new QueueImmutable(this.opts, enqueue(this.opts, this.#data, ...toAdd));\n    }\n    dequeue() {\n        return new QueueImmutable(this.opts, dequeue(this.opts, this.#data));\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.#data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.#data);\n    }\n    get length() {\n        return this.#data.length;\n    }\n    get peek() {\n        return peek(this.opts, this.#data);\n    }\n    toArray() {\n        return [...this.#data];\n    }\n}\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @typeParam V - Type of values stored\n * @param options\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = (options = {}, ...startingItems) => {\n    options = { ...options }; // Make a copy of options\n    return new QueueImmutable(options, [...startingItems]); // Make a copy of array so it can't be modified\n};\n","export * from './priority-mutable.js';\nexport { immutable, QueueImmutable } from './queue-immutable.js';\nexport { mutable, QueueMutable } from './queue-mutable.js';\n//export * from './Responsive.js';\nexport * from './queue-fns.js';\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { sortByValueProperty } from '@ixfx/core/maps';\nimport { intervalToMs } from '@ixfx/core';\nimport { integerTest, resultThrow } from '@ixfx/guards';\n/**\n * Create a ExpiringMap instance\n * @param options Options when creating map\n * @returns\n */\nexport const create = (options = {}) => new ExpiringMap(options);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using {@link touch}.\n *\n *\n * Events:\n * * 'expired': when an item is automatically removed.\n * * 'removed': when an item is manually or automatically removed.\n * * 'newKey': when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example\n * Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example\n * Automatically delete the oldest item if we reach a capacity limit\n * ```js\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n * @typeParam K - Type of keys\n * @typeParam V - Type of values\n */\nexport class ExpiringMap extends SimpleEventEmitter {\n    capacity;\n    store;\n    //private keyCount: number;\n    evictPolicy;\n    autoDeleteElapsedMs;\n    autoDeletePolicy;\n    autoDeleteTimer;\n    disposed = false;\n    constructor(opts = {}) {\n        super();\n        this.capacity = opts.capacity ?? -1;\n        resultThrow(integerTest(this.capacity, `nonZero`, `capacity`));\n        this.store = new Map();\n        //this.keyCount = 0;\n        if (opts.evictPolicy && this.capacity <= 0) {\n            throw new Error(`evictPolicy is set, but no capacity limit is set`);\n        }\n        this.evictPolicy = opts.evictPolicy ?? `none`;\n        this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n        this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n        if (this.autoDeleteElapsedMs > 0) {\n            this.autoDeleteTimer = setInterval(() => { this.#maintain(); }, Math.max(1000, this.autoDeleteElapsedMs * 2));\n        }\n    }\n    dispose() {\n        if (this.disposed)\n            return;\n        this.disposed = true;\n        if (this.autoDeleteTimer) {\n            clearInterval(this.autoDeleteTimer);\n            this.autoDeleteTimer = undefined;\n        }\n    }\n    /**\n     * Returns the number of keys being stored.\n     */\n    get keyLength() {\n        return this.store.size; // keyCount;\n    }\n    *entries() {\n        for (const entry of this.store.entries()) {\n            yield [entry[0], entry[1].value];\n        }\n    }\n    *values() {\n        for (const v of this.store.values()) {\n            yield v.value;\n        }\n    }\n    *keys() {\n        yield* this.store.keys();\n    }\n    /**\n     * Returns the elapsed time since `key`\n     * was set. Returns _undefined_ if `key`\n     * does not exist\n     */\n    elapsedSet(key) {\n        const v = this.store.get(key);\n        if (typeof v === `undefined`)\n            return;\n        return Date.now() - v.lastSet;\n    }\n    /**\n     * Returns the elapsed time since `key`\n     * was accessed. Returns _undefined_ if `key`\n     * does not exist\n     */\n    elapsedGet(key) {\n        const v = this.store.get(key);\n        if (typeof v === `undefined`)\n            return;\n        return Date.now() - v.lastGet;\n    }\n    /**\n     * Returns true if `key` is stored.\n     * Does not affect the key's last access time.\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.store.has(key);\n    }\n    /**\n     * Gets an item from the map by key, returning\n     * undefined if not present\n     * @param key Key\n     * @returns Value, or undefined\n     */\n    get(key) {\n        const v = this.store.get(key);\n        if (v) {\n            if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) {\n                this.store.set(key, {\n                    ...v,\n                    lastGet: performance.now(),\n                });\n            }\n            return v.value;\n        }\n    }\n    /**\n     * Deletes the value under `key`, if present.\n     *\n     * Returns _true_ if something was removed.\n     * @param key\n     * @returns\n     */\n    delete(key) {\n        const value = this.store.get(key);\n        if (!value)\n            return false;\n        const d = this.store.delete(key);\n        //this.keyCount = this.keyCount - 1;\n        this.fireEvent(`removed`, {\n            key,\n            value: value.value,\n        });\n        return d;\n    }\n    /**\n     * Clears the contents of the map.\n     * Note: does not fire `removed` event\n     */\n    clear() {\n        this.store.clear();\n    }\n    /**\n     * Updates the lastSet/lastGet time for a value\n     * under `k`.\n     *\n     * Returns false if key was not found\n     * @param key\n     * @returns\n     */\n    touch(key) {\n        const v = this.store.get(key);\n        if (!v)\n            return false;\n        this.store.set(key, {\n            ...v,\n            lastSet: Date.now(),\n            lastGet: Date.now(),\n        });\n        return true;\n    }\n    findEvicteeKey() {\n        if (this.evictPolicy === `none`)\n            return;\n        let sortBy = ``;\n        if (this.evictPolicy === `oldestGet`)\n            sortBy = `lastGet`;\n        else if (this.evictPolicy === `oldestSet`)\n            sortBy = `lastSet`;\n        else\n            throw new Error(`Unknown eviction policy ${this.evictPolicy}`);\n        const sorted = sortByValueProperty(this.store, sortBy);\n        return sorted[0][0];\n    }\n    #maintain() {\n        if (this.autoDeletePolicy === `none`)\n            return;\n        this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n    }\n    /**\n     * Deletes all values where elapsed time has past\n     * for get/set or either.\n     * ```js\n     * // Delete all keys (and associated values) not accessed for a minute\n     * em.deleteWithElapsed({mins:1}, `get`);\n     * // Delete things that were set 1s ago\n     * em.deleteWithElapsed(1000, `set`);\n     * ```\n     *\n     * @param interval Interval\n     * @param property Basis for deletion 'get','set' or 'either'\n     * @returns Items removed\n     */\n    deleteWithElapsed(interval, property) {\n        const entries = [...this.store.entries()];\n        const prune = [];\n        const intervalMs = intervalToMs(interval, 1000);\n        const now = performance.now();\n        for (const entry of entries) {\n            const elapsedGet = now - entry[1].lastGet;\n            const elapsedSet = now - entry[1].lastSet;\n            const elapsed = property === `get`\n                ? elapsedGet\n                : (property === `set`\n                    ? elapsedSet\n                    : Math.max(elapsedGet, elapsedSet));\n            if (elapsed >= intervalMs) {\n                prune.push([entry[0], entry[1].value]);\n            }\n        }\n        for (const entry of prune) {\n            this.store.delete(entry[0]);\n            //this.keyCount = this.keyCount - 1;\n            const eventArguments = {\n                key: entry[0],\n                value: entry[1],\n            };\n            this.fireEvent(`expired`, eventArguments);\n            this.fireEvent(`removed`, eventArguments);\n        }\n        return prune;\n    }\n    /**\n     * Sets the `key` to be `value`.\n     *\n     * If the key already exists, it is updated.\n     *\n     * If the map is full, according to its capacity,\n     * another value is selected for removal.\n     * @param key\n     * @param value\n     * @returns\n     */\n    set(key, value) {\n        const existing = this.store.get(key);\n        if (existing) {\n            // Update set time\n            this.store.set(key, {\n                ...existing,\n                lastSet: performance.now(),\n            });\n            return;\n        }\n        // New key\n        if (this.keyLength === this.capacity && this.capacity > 0) {\n            // Evict first\n            const key = this.findEvicteeKey();\n            if (!key) {\n                throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);\n            }\n            const existing = this.store.get(key);\n            this.store.delete(key);\n            //this.keyCount = this.keyCount - 1;\n            if (existing) {\n                const eventArguments = { key, value: existing.value };\n                this.fireEvent(`expired`, eventArguments);\n                this.fireEvent(`removed`, eventArguments);\n            }\n        }\n        //this.keyCount++;\n        this.store.set(key, {\n            lastGet: 0,\n            lastSet: performance.now(),\n            value: value,\n        });\n        this.fireEvent(`newKey`, { key, value });\n    }\n}\n","//  UNIT TESTED\nimport { isEqualDefault } from '@ixfx/core';\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = (map, predicate) => {\n    for (const e of map.entries()) {\n        const value = e[1];\n        for (const subValue of value) {\n            if (predicate(subValue, e[0]))\n                return e;\n        }\n    }\n};\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = (map) => {\n    //eslint-disable-next-line functional/no-let\n    let largest = ['', 0];\n    for (const e of map.keysAndCounts()) {\n        if (e[1] > largest[1]) {\n            largest = e;\n        }\n    }\n    return largest[1];\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const e of map.entries()) {\n        const value_ = e[1];\n        for (const subValue of value_) {\n            if (isEqual(subValue, value))\n                return e;\n        }\n    }\n};\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { firstEntryByValue } from './map-multi-fns.js';\nexport class MapOfSimpleBase {\n    map;\n    groupBy;\n    valueEq;\n    /**\n     * Constructor\n     * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n     * @param valueEq Compare values. By default uses JS logic for equality\n     */\n    constructor(groupBy = defaultKeyer, valueEq = (isEqualDefault), initial = []) {\n        this.groupBy = groupBy;\n        this.valueEq = valueEq;\n        this.map = new Map(initial);\n    }\n    /**\n     * Returns _true_ if `key` exists\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.map.has(key);\n    }\n    /**\n     * Returns _true_ if `value` exists under `key`.\n     * @param key Key\n     * @param value Value to seek under `key`\n     * @returns _True_ if `value` exists under `key`.\n     */\n    hasKeyValue(key, value) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        for (const v of values) {\n            if (this.valueEq(v, value))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Debug dump of contents\n     * @returns\n     */\n    debugString() {\n        let r = ``;\n        const keys = [...this.map.keys()];\n        keys.every((k) => {\n            const v = this.map.get(k);\n            if (v === undefined)\n                return;\n            r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\n        });\n        return r;\n    }\n    /**\n     * Return number of values stored under `key`.\n     * Returns 0 if `key` is not found.\n     * @param key\n     * @returns\n     */\n    count(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return 0;\n        return values.length;\n    }\n    /**\n   * Returns first key that contains `value`\n   * @param value\n   * @param eq\n   * @returns\n   */\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const entry = firstEntryByValue(this, value, eq);\n        if (entry)\n            return entry[0];\n    }\n    /**\n     * Iterate over all entries\n     */\n    *entriesFlat() {\n        for (const key of this.map.keys()) {\n            for (const value of this.map.get(key)) {\n                yield [key, value];\n            }\n        }\n    }\n    /**\n     * Iterate over keys and array of values for that key\n     */\n    *entries() {\n        for (const [k, v] of this.map.entries()) {\n            yield [k, [...v]];\n        }\n    }\n    /**\n     * Get all values under `key`\n     * @param key\n     * @returns\n     */\n    *get(key) {\n        const m = this.map.get(key);\n        if (!m)\n            return;\n        yield* m.values();\n    }\n    /**\n     * Iterate over all keys\n     */\n    *keys() {\n        yield* this.map.keys();\n    }\n    /**\n     * Iterate over all values (regardless of key).\n     * Use {@link values} to iterate over a set of values per key\n     */\n    *valuesFlat() {\n        for (const entries of this.map) {\n            yield* entries[1];\n        }\n    }\n    /**\n     * Yields the values for each key in sequence, returning an array.\n     * Use {@link valuesFlat} to iterate over all keys regardless of key.\n     */\n    *values() {\n        for (const entries of this.map) {\n            yield entries[1];\n        }\n    }\n    /**\n     * Iterate over keys and length of values stored under keys\n     */\n    *keysAndCounts() {\n        for (const entries of this.map) {\n            yield [entries[0], entries[1].length];\n        }\n    }\n    /**\n     * Returns the count of keys.\n     */\n    get lengthKeys() {\n        return this.map.size;\n    }\n    /**\n    * _True_ if empty\n    */\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        const existing = this.map.get(key);\n        if (existing === undefined) {\n            this.map.set(key, values);\n        }\n        else {\n            this.map.set(key, [...existing, ...values]);\n        }\n    }\n    /**\n     * Set `values` to `key`.\n     * Previous data stored under `key` is thrown away.\n     * @param key\n     * @param values\n     */\n    setValues(key, values) {\n        this.map.set(key, values);\n    }\n    /**\n     * Adds a value, automatically extracting a key via the\n     * `groupBy` function assigned in the constructor options.\n     * @param values Adds several values\n     */\n    addValue(...values) {\n        for (const v of values) {\n            const key = this.groupBy(v);\n            this.addKeyedValues(key, v);\n        }\n    }\n    /**\n     * Delete `value` under a particular `key`\n     * @param key\n     * @param value\n     * @returns _True_ if `value` was found under `key`\n     */\n    deleteKeyValue(key, value) {\n        const existing = this.map.get(key);\n        if (existing === undefined)\n            return false;\n        const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n        this.map.set(key, without);\n        return without.length < existing.length;\n    }\n    /**\n     * Deletes `value` regardless of key.\n     *\n     * Uses the constructor-defined equality function.\n     * @param value Value to delete\n     * @returns\n     */\n    deleteByValue(value) {\n        let del = false;\n        const entries = [...this.map.entries()];\n        for (const keyEntries of entries) {\n            for (const values of keyEntries[1]) {\n                if (this.valueEq(values, value)) {\n                    del = true;\n                    this.deleteKeyValue(keyEntries[0], value);\n                }\n            }\n        }\n        return del;\n    }\n    /**\n     * Deletes all values under `key`,\n     * @param key\n     * @returns _True_ if `key` was found and values stored\n     */\n    delete(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        if (values.length === 0)\n            return false;\n        this.map.delete(key);\n        return true;\n    }\n    /**\n     * Clear contents\n     */\n    clear() {\n        this.map.clear();\n    }\n}\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimpleMutable(groupBy, valueEq);\n","/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = (map, data) => {\n    const x = new Map(map.entries());\n    for (const d of data) {\n        if (d[0] === undefined)\n            throw new Error(`key cannot be undefined`);\n        if (d[1] === undefined)\n            throw new Error(`value cannot be undefined`);\n        x.set(d[0], d[1]);\n    }\n    return x;\n};\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = (map, data) => {\n    const x = new Map(map.entries());\n    for (const d of data) {\n        if (d.key === undefined)\n            throw new Error(`key cannot be undefined`);\n        if (d.value === undefined)\n            throw new Error(`value cannot be undefined`);\n        x.set(d.key, d.value);\n    }\n    return x;\n};\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = (map, key) => map.has(key);\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = (map, ...data) => {\n    if (map === undefined)\n        throw new Error(`map parameter is undefined`);\n    if (data === undefined)\n        throw new Error(`data parameter i.s undefined`);\n    if (data.length === 0)\n        return map;\n    const firstRecord = data[0];\n    const isObject = typeof firstRecord.key !==\n        `undefined` &&\n        typeof firstRecord.value !==\n            `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n    return isObject\n        ? addObjects(map, data)\n        : addArray(map, data);\n};\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = (map, key, value) => {\n    const x = new Map(map.entries());\n    x.set(key, value);\n    return x;\n};\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = (map, key) => {\n    const x = new Map(map.entries());\n    x.delete(key);\n    return x;\n};\n","import {} from '../types.js';\nimport { add, del, set } from './map-immutable-fns.js';\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = (dataOrMap) => {\n    if (dataOrMap === undefined)\n        return immutable([]);\n    if (Array.isArray(dataOrMap))\n        return immutable(add(new Map(), ...dataOrMap));\n    const data = dataOrMap;\n    return {\n        add: (...itemsToAdd) => {\n            const s = add(data, ...itemsToAdd);\n            return immutable(s);\n        },\n        set: (key, value) => {\n            const s = set(data, key, value);\n            return immutable(s);\n        },\n        get: (key) => data.get(key),\n        delete: (key) => immutable(del(data, key)),\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        clear: () => immutable(),\n        has: (key) => data.has(key),\n        entries: () => data.entries(),\n        values: () => data.values(),\n        isEmpty: () => data.size === 0,\n    };\n};\n","import {} from '../types.js';\nimport { add, del, set, has } from './map-immutable-fns.js';\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = (...data) => {\n    // eslint-disable-next-line functional/no-let\n    let m = add(new Map(), ...data);\n    return {\n        add: (...data) => {\n            m = add(m, ...data);\n        },\n        delete: (key) => {\n            m = del(m, key);\n        },\n        clear: () => {\n            m = add(new Map());\n        },\n        set: (key, value) => {\n            m = set(m, key, value);\n        },\n        get: (key) => m.get(key),\n        entries: () => m.entries(),\n        values: () => m.values(),\n        isEmpty: () => m.size === 0,\n        has: (key) => has(m, key),\n    };\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { toStringDefault } from '@ixfx/core';\n/**\n * @internal\n */\nexport class MapOfMutableImpl extends SimpleEventEmitter {\n    #map = new Map();\n    groupBy;\n    type;\n    constructor(type, opts = {}) {\n        super();\n        this.type = type;\n        this.groupBy = opts.groupBy ?? toStringDefault;\n    }\n    /**\n     * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n     */\n    get typeName() {\n        return this.type.name;\n    }\n    /**\n     * Returns the number of keys\n     */\n    get lengthKeys() {\n        return this.#map.size;\n    }\n    /**\n     * Returns the length of the longest child list\n     */\n    get lengthMax() {\n        let m = 0;\n        for (const v of this.#map.values()) {\n            m = Math.max(m, this.type.count(v));\n        }\n        return m;\n    }\n    debugString() {\n        const keys = [...this.#map.keys()];\n        let r = `Keys: ${keys.join(`, `)}\\r\\n`;\n        for (const k of keys) {\n            const v = this.#map.get(k);\n            if (v === undefined) {\n                r += ` - ${k} (undefined)\\r\\n`;\n            }\n            else {\n                const asArray = this.type.toArray(v);\n                if (asArray !== undefined) {\n                    r += ` - ${k} (${this.type.count(v)}) = ${JSON.stringify(asArray)}\\r\\n`;\n                }\n            }\n        }\n        ;\n        return r;\n    }\n    get isEmpty() {\n        return this.#map.size === 0;\n    }\n    clear() {\n        this.#map.clear();\n        super.fireEvent(`clear`, true);\n    }\n    addKeyedValues(key, ...values) {\n        const set = this.#map.get(key);\n        if (set === undefined) {\n            this.#map.set(key, this.type.addKeyedValues(undefined, values));\n            super.fireEvent(`addedKey`, { key: key });\n            super.fireEvent(`addedValues`, { values: values });\n        }\n        else {\n            this.#map.set(key, this.type.addKeyedValues(set, values));\n            super.fireEvent(`addedValues`, { values: values });\n        }\n    }\n    set(key, values) {\n        this.addKeyedValues(key, ...values);\n        return this;\n    }\n    addValue(...values) {\n        for (const v of values)\n            this.addKeyedValues(this.groupBy(v), v);\n    }\n    hasKeyValue(key, value, eq) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return false;\n        return this.type.has(m, value, eq);\n    }\n    has(key) {\n        return this.#map.has(key);\n    }\n    deleteKeyValue(key, value) {\n        const a = this.#map.get(key);\n        if (a === undefined)\n            return false;\n        return this.deleteKeyValueFromMap(a, key, value);\n    }\n    deleteKeyValueFromMap(map, key, value) {\n        const preCount = this.type.count(map);\n        const filtered = this.type.without(map, value);\n        const postCount = filtered.length;\n        this.#map.set(key, this.type.addKeyedValues(undefined, filtered));\n        return preCount > postCount;\n    }\n    deleteByValue(value) {\n        let something = false;\n        [...this.#map.keys()].filter((key) => {\n            const a = this.#map.get(key);\n            if (!a)\n                throw new Error(`Bug: map could not be accessed`);\n            if (this.deleteKeyValueFromMap(a, key, value)) {\n                something = true; // note that something was deleted\n                // If key is empty, delete it\n                if (this.count(key) === 0)\n                    this.delete(key);\n            }\n        });\n        return something;\n    }\n    delete(key) {\n        const a = this.#map.get(key);\n        if (a === undefined)\n            return false;\n        this.#map.delete(key);\n        this.fireEvent(`deleteKey`, { key: key });\n        return true;\n    }\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const keys = [...this.#map.keys()];\n        const found = keys.find((key) => {\n            const a = this.#map.get(key);\n            if (a === undefined)\n                throw new Error(`Bug: map could not be accessed`);\n            const r = this.type.has(a, value, eq);\n            return r;\n        });\n        return found;\n    }\n    count(key) {\n        const entry = this.#map.get(key);\n        if (entry === undefined)\n            return 0;\n        return this.type.count(entry);\n    }\n    /**\n     * Iterates over values stored under `key`\n     * An empty array is returned if there are no values\n     */\n    *get(key) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return;\n        yield* this.type.iterable(m);\n    }\n    /**\n     * Iterate over the values stored under `key`.\n     * If key does not exist, iteration is essentially a no-op\n     * @param key\n     * @returns\n     */\n    *valuesFor(key) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return;\n        yield* this.type.iterable(m);\n    }\n    getSource(key) {\n        return this.#map.get(key);\n    }\n    *keys() {\n        yield* this.#map.keys();\n        //return Array.from(this.#map.keys());\n    }\n    *entriesFlat() {\n        for (const entry of this.#map.entries()) {\n            for (const v of this.type.iterable(entry[1])) {\n                yield [entry[0], v];\n            }\n        }\n    }\n    *valuesFlat() {\n        for (const entry of this.#map.entries()) {\n            yield* this.type.iterable(entry[1]);\n        }\n    }\n    *entries() {\n        for (const [k, v] of this.#map.entries()) {\n            const temporary = [...this.type.iterable(v)];\n            yield [k, temporary];\n        }\n    }\n    *keysAndCounts() {\n        for (const key of this.keys()) {\n            yield [key, this.count(key)];\n        }\n    }\n    merge(other) {\n        for (const key of other.keys()) {\n            const data = other.get(key);\n            this.addKeyedValues(key, ...data);\n        }\n    }\n    get size() {\n        return this.#map.size;\n    }\n    get [Symbol.toStringTag]() {\n        return this.#map[Symbol.toStringTag];\n    }\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { without } from '@ixfx/arrays';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\nimport { hasAnyValue as mapHasAnyValue, toArray as mapToArray, findValue as mapFindValue, filterValues as mapFilterValues, addValue as mapAddValue } from '@ixfx/core/maps';\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is Util.ToString function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = ofSetMutable();\n * map.addKeyedValues(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = ofSetMutable({hash});\n * map.addValue({age:40, name: `Mary`});\n * map.addValue({age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param options\n * @returns\n */\nexport const ofSetMutable = (options) => {\n    const hash = options?.hash ?? toStringDefault;\n    const comparer = (a, b) => hash(a) === hash(b);\n    const t = {\n        get name() {\n            return `set`;\n        },\n        iterable: (source) => source.values(),\n        addKeyedValues: (dest, values) => mapAddValue(dest, hash, `skip`, ...values),\n        count: (source) => source.size,\n        find: (source, predicate) => mapFindValue(source, predicate),\n        filter: (source, predicate) => mapFilterValues(source, predicate),\n        toArray: (source) => mapToArray(source),\n        has: (source, value) => mapHasAnyValue(source, value, comparer),\n        without: (source, value) => without(mapToArray(source), value, comparer),\n    };\n    const m = new MapOfMutableImpl(t, options);\n    return m;\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { CircularArray } from '../circular-array.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param options\n * @returns\n */\nexport const ofCircularMutable = (options) => {\n    const comparer = isEqualDefault;\n    const t = {\n        get name() {\n            return `circular`;\n        },\n        addKeyedValues: (destination, values) => {\n            let ca = destination ?? new CircularArray(options.capacity);\n            for (const v of values) {\n                ca = ca.add(v);\n            }\n            return ca;\n        },\n        count: (source) => source.length,\n        find: (source, predicate) => source.find(predicate),\n        filter: (source, predicate) => source.filter(predicate),\n        toArray: (source) => source,\n        iterable: (source) => source.values(),\n        has: (source, value) => source.find((v) => comparer(v, value)) !== undefined,\n        without: (source, value) => source.filter((v) => !comparer(v, value)),\n    };\n    return new MapOfMutableImpl(t, options);\n};\n","/**\n * Simple map for numbers.\n *\n * Keys not present in map return the `defaultValue` given in the constructor\n * ```js\n * // All keys default to zero.\n * const map = new NumberMap();\n * map.get(`hello`); // 0\n * ```\n *\n * To check if a key is present, use `has`:\n * ```js\n * map.has(`hello`); // false\n * ```\n *\n * Math:\n * ```js\n * // Adds 1 by default to value of `hello`\n * map.add(`hello`);         // 1\n * map.multiply(`hello`, 2); // 2\n *\n * // Reset key to default value\n * map.reset(`hello`); // 0\n * ```\n *\n * Different default value:\n * ```js\n * const map = new NumberMap(10);\n * map.get(`hello`); // 10\n * ```\n *\n * Regular `set` works as well:\n * ```js\n * map.set(`hello`, 5);\n * map.add(`hello`, 2); // 7\n * ```\n */\nexport class NumberMap extends Map {\n    defaultValue;\n    constructor(defaultValue = 0) {\n        super();\n        this.defaultValue = defaultValue;\n    }\n    get(key) {\n        const v = super.get(key);\n        if (v === undefined)\n            return this.defaultValue;\n        return v;\n    }\n    reset(key) {\n        super.set(key, this.defaultValue);\n        return this.defaultValue;\n    }\n    multiply(key, amount) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value *= amount;\n        super.set(key, value);\n        return value;\n    }\n    add(key, amount = 1) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value += amount;\n        super.set(key, value);\n        return value;\n    }\n    subtract(key, amount = 1) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value -= amount;\n        super.set(key, value);\n        return value;\n    }\n}\n","import { isEqualDefault } from '@ixfx/core';\nimport {} from './imap-of-mutable-extended.js';\nimport {} from './map-multi.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: Util.ToString\n *\n * A custom Util.ToString function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param options Optiosn for mutable array\n * @typeParam V - Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = (options = {}) => {\n    // const toStringFunction = opts.toString === undefined ?  \n    // const comparer =\n    //   opts.comparer === undefined\n    //     ? (opts.toString === undefined\n    //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n    //       : isEqualDefault)\n    //     : opts.comparer;\n    // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n    //   const r = opts.convertToString(a) === opts.convertToString(b)\n    //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n    //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n    //   return r;\n    // };\n    const convertToString = options.convertToString;\n    const toStringFunction = typeof convertToString === `undefined` ? isEqualDefault : (a, b) => convertToString(a) === convertToString(b);\n    const comparer = options.comparer ?? toStringFunction;\n    const t = {\n        get name() {\n            return `array`;\n        },\n        addKeyedValues: (destination, values) => {\n            if (destination === undefined)\n                return [...values];\n            return [...destination, ...values];\n        },\n        iterable: (source) => source.values(),\n        count: (source) => source.length,\n        find: (source, predicate) => source.find(f => predicate(f)),\n        filter: (source, predicate) => source.filter(f => predicate(f)),\n        toArray: (source) => source,\n        has: (source, value) => source.some((v) => comparer(v, value)),\n        without: (source, value) => source.filter((v) => !comparer(v, value)),\n        //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n    };\n    const m = new MapOfMutableImpl(t, options);\n    return m;\n};\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * Simple immutable MapOf\n */\nexport class MapOfSimple extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        //const asEntries = values.map(v => [key, v]) as [string, V[]][];\n        //return this.addBatch(asEntries);\n        return this.addBatch([[key, values]]);\n    }\n    addValue(...values) {\n        const asEntries = values.map((v) => [this.groupBy(v), v]);\n        return this.addBatch(asEntries);\n    }\n    //eslint-disable-next-line functional/prefer-immutable-types\n    addBatch(entries) {\n        // Deep copy Map\n        const temporary = new Map([...this.map.entries()].map((e) => [e[0], [...e[1]]]));\n        for (const [key, list] of entries) {\n            // Does key exist already\n            const existingList = temporary.get(key);\n            if (typeof existingList === `undefined`) {\n                // No, use the batch input as the data for this key\n                // @ts-expect-error\n                temporary.set(key, list);\n            }\n            else {\n                // Yes\n                existingList.push(...list);\n            }\n        }\n        return new MapOfSimple(this.groupBy, this.valueEq, [...temporary.entries()]);\n    }\n    clear() {\n        return new MapOfSimple(this.groupBy, this.valueEq);\n    }\n    deleteKeyValue(_key, _value) {\n        throw new Error(`Method not implemented.`);\n    }\n    deleteByValue(value, eq) {\n        const entries = [...this.map.entries()];\n        const eqFunction = eq ?? this.valueEq;\n        const x = entries.map((entry) => {\n            const key = entry[0];\n            const values = entry[1].filter((vv) => !eqFunction(vv, value));\n            return [key, values];\n        });\n        return new MapOfSimple(this.groupBy, this.valueEq, x);\n    }\n    delete(key) {\n        const entries = [...this.map.entries()].filter((e) => e[0] !== key);\n        return new MapOfSimple(this.groupBy, this.valueEq, entries);\n    }\n}\n/**\n * A simple immutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * let m = mapSimple();\n * m = m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m = m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimple = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimple(groupBy, valueEq);\n","export { create as expiringMap, ExpiringMap } from './expiring-map.js';\nexport * from './map-of-simple-mutable.js';\nexport { immutable } from './map.js';\nexport { mutable } from './map-mutable.js';\nexport { ofSetMutable } from './map-of-set-mutable.js';\nexport { ofCircularMutable } from './map-of-circular-mutable.js';\nexport { NumberMap } from './number-map.js';\nexport * from './map-multi.js';\n// Re-export from core\nexport * from '@ixfx/core/maps';\n//export type { IDictionary as IMappish, IWithEntries } from '../../data/maps/IMappish.js';\n","import { resultIsError } from \"@ixfx/guards\";\n/**\n * Stores values in a table of rows (vertical) and columns (horizontal)\n */\nexport class Table {\n    rows = [];\n    rowLabels = [];\n    colLabels = [];\n    /**\n     * Keep track of widest row\n     */\n    columnMaxLength = 0;\n    /**\n     * Gets the label for a given column index,\n     * returning _undefined_ if not found.\n     *\n     * Case-sensitive\n     * @param label Label to seek\n     * @returns Index of column, or _undefined_ if not found\n     */\n    getColumnLabelIndex(label) {\n        for (const [index, l] of this.colLabels.entries()) {\n            if (l === label)\n                return index;\n        }\n    }\n    /**\n     * Gets the label for a given row index,\n     * returning _undefined_ if not found.\n     *\n     * Case-sensitive\n     * @param label Label to seek\n     * @returns Index of row, or _undefined_ if not found\n     */\n    getRowLabelIndex(label) {\n        for (const [index, l] of this.rowLabels.entries()) {\n            if (l === label)\n                return index;\n        }\n    }\n    /**\n     * Dumps the values of the table to the console\n     */\n    print() {\n        console.table([...this.rowsWithLabelsObject()]);\n    }\n    /**\n     * Return a copy of table as nested array\n     *\n     * ```js\n     * const t = new Table();\n     * // add stuff\n     * // ...\n     * const m = t.asArray();\n     * for (const row of m) {\n     *  for (const colValue of row) {\n     *    // iterate over all column values for this row\n     *  }\n     * }\n     * ```\n     *\n     * Alternative: get value at row Y and column X\n     * ```js\n     * const value = m[y][x];\n     * ```\n     * @returns\n     */\n    asArray() {\n        const r = [];\n        for (const row of this.rows) {\n            if (row === undefined)\n                r.push([]);\n            else\n                r.push([...row]);\n        }\n        return r;\n    }\n    /**\n     * Return the number of rows\n     */\n    get rowCount() {\n        return this.rows.length;\n    }\n    /**\n     * Return the maximum number of columns in any row\n     */\n    get columnCount() {\n        return this.columnMaxLength;\n        // const lengths = this.rows.map(row => row.length);\n        // return Math.max(...lengths);\n    }\n    /**\n     * Iterates over the table row-wise, in object format.\n     * @see {@link rowsWithLabelsArray} to get rows in array format\n     */\n    *rowsWithLabelsObject() {\n        for (let index = 0; index < this.rows.length; index++) {\n            const labelledRow = this.getRowWithLabelsObject(index);\n            yield labelledRow;\n        }\n    }\n    /**\n     * Iterates over each row, including the labels if available\n     * @see {@link rowsWithLabelsObject} to get rows in object format\n     */\n    *rowsWithLabelsArray() {\n        for (let index = 0; index < this.rows.length; index++) {\n            const labelledRow = this.getRowWithLabelsArray(index);\n            yield labelledRow;\n        }\n    }\n    /**\n     * Assign labels to columns\n     * @param labels\n     */\n    labelColumns(...labels) {\n        this.colLabels = labels;\n    }\n    /**\n     * Assign label to a specific column\n     * First column has an index of 0\n     * @param columnIndex\n     * @param label\n     */\n    labelColumn(columnIndex, label) {\n        this.colLabels[columnIndex] = label;\n    }\n    /**\n     * Label rows\n     * @param labels Labels\n     */\n    labelRows(...labels) {\n        this.rowLabels = labels;\n    }\n    /**\n     * Assign label to a specific row\n     * First row has an index of 0\n     * @param rowIndex\n     * @param label\n     */\n    labelRow(rowIndex, label) {\n        this.rowLabels[rowIndex] = label;\n    }\n    /**\n     * Adds a new row\n     * @param data Columns\n     */\n    appendRow(...data) {\n        this.columnMaxLength = Math.max(this.columnMaxLength, data.length);\n        this.rows.push(data);\n        return data;\n    }\n    /**\n     * Gets a row along with labels, as an array\n     * @param rowIndex\n     * @returns\n     */\n    getRowWithLabelsArray(rowIndex) {\n        const row = this.rows.at(rowIndex);\n        if (row === undefined)\n            return undefined;\n        return row.map((value, index) => [this.colLabels.at(index), value]);\n    }\n    /**\n     * Return a row of objects. Keys use the column labels.\n     *\n     * ```js\n     * const row = table.getRowWithLabelsObject(10);\n     * // eg:\n     * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n     * ```\n     * @param rowIndex\n     * @returns\n     */\n    getRowWithLabelsObject(rowIndex) {\n        const row = this.rows.at(rowIndex);\n        if (row === undefined)\n            return undefined;\n        const object = {};\n        for (let index = 0; index < this.colLabels.length; index++) {\n            const label = this.colLabels.at(index) ?? index.toString();\n            object[label] = row[index];\n        }\n        return object;\n    }\n    /**\n     * Gets or creates a row at given position\n     * @param row Index or label of row\n     * @returns\n     */\n    #getOrCreateRawRow(row) {\n        const index = typeof row === `number` ? row : this.getRowLabelIndex(row);\n        // Couldn't lookup label\n        if (index === undefined)\n            return { success: false, error: `row-label-notfound` };\n        // Bad index\n        if (index < 0)\n            return { success: false, error: `row-index-invalid` };\n        // Within existing set of rows\n        if (index < this.rows.length) {\n            return { success: true, value: this.rows[index] };\n        }\n        const newRow = [];\n        this.rows[index] = newRow;\n        return { success: true, value: newRow };\n    }\n    /**\n     * Gets a copy of values at given row, specified by index or label\n     * @param row\n     * @returns Returns row or throws an error if label or index not found\n     */\n    row(row) {\n        const r = this.#getRowRaw(row);\n        if (resultIsError(r)) {\n            throw new Error(r.error);\n        }\n        return [...r.value];\n    }\n    /**\n     * Set the value of row,columm.\n     * Row is created if it doesn't exist, with the other column values being _undefined_\n     * @param row Index or label\n     * @param column Column\n     * @param value Value to set at row,column\n     */\n    set(row, column, value) {\n        const result = this.#getOrCreateRawRow(row);\n        if (resultIsError(result))\n            throw new Error(result.error);\n        // Have an array that corresponds to row\n        const r = result.value;\n        const columnIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n        if (typeof columnIndex === `undefined`)\n            throw new Error(`Column label '${column}' not found or is invalid`);\n        if (columnIndex < 0)\n            throw new Error(`Column index invalid (less than zero)`);\n        // Already have needed columns\n        r[columnIndex] = value;\n    }\n    /**\n     * Gets the value at a specified row and column.\n     * Throws an error if coordinates are out of range or missing.\n     * @param row Row index or label\n     * @param column Column index or label\n     * @returns\n     */\n    get(row, column) {\n        const rowR = this.#getRowRaw(row);\n        if (resultIsError(rowR))\n            throw new Error(rowR.error);\n        const colR = this.#getColumnRaw(rowR.value, column);\n        if (resultIsError(colR))\n            throw new Error(colR.error);\n        return colR.value.value;\n    }\n    #getRowRaw(row) {\n        let index = 0;\n        if (typeof row === `number`) {\n            index = row;\n        }\n        else {\n            index = this.getRowLabelIndex(row);\n            if (typeof index !== `number`)\n                return { error: `row-label-notfound`, success: false };\n        }\n        if (typeof index !== `number`)\n            return { error: `row-invalid`, success: false };\n        if (index < 0 || index >= this.rows.length)\n            return { error: `row-index-out-of-range`, success: false };\n        return { success: true, value: this.rows[index] };\n    }\n    #getColumnRaw(row, column) {\n        const colIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n        if (typeof colIndex !== `number`)\n            return { success: false, error: `col-label-notfound` };\n        if (colIndex < 0 || colIndex >= row.length)\n            return { success: false, error: `col-index-out-of-range` };\n        return {\n            success: true, value: { index: colIndex, value: row[colIndex] }\n        };\n    }\n    /**\n     * Set all the columns of a row to a specified value.\n     *\n     * By default, sets the number of columns corresponding to\n     * the table's maximum column length. To set an arbitrary\n     * length of the row, use `length`\n     * @param row Index or label of row\n     * @param length How wide the row is. If unset, uses the current maximum width of rows.\n     * @param value Value to set\n     */\n    setRow(row, value, length) {\n        // Get or create a row\n        const rowResult = this.#getOrCreateRawRow(row);\n        if (resultIsError(rowResult))\n            throw new Error(rowResult.error);\n        // Set value within row\n        const r = rowResult.value;\n        const width = typeof length === `number` ? length : this.columnMaxLength;\n        for (let columnNumber = 0; columnNumber < width; columnNumber++) {\n            r[columnNumber] = value;\n        }\n        return r;\n    }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { PriorityMutable } from \"../queue/priority-mutable.js\";\nimport { immutable as immutableMap } from \"../map/map.js\";\nimport { NumberMap } from \"../map/number-map.js\";\nimport * as Sync from \"@ixfx/iterables/sync\";\nimport { Table } from \"../table.js\";\nimport { resultThrow, stringTest } from \"@ixfx/guards\";\n/**\n * Create a vertex with given id\n * @param id\n * @returns\n */\nexport const createVertex = (id) => {\n    return {\n        id,\n        out: []\n    };\n};\n/**\n * Returns _true_ if graph contains `key`.\n *\n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key\n * @returns\n */\nexport function hasKey(graph, key) {\n    resultThrow(graphTest(graph));\n    return graph.vertices.has(key);\n}\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n *\n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph\n * @param key\n * @returns\n */\nexport function get(graph, key) {\n    resultThrow(graphTest(graph));\n    resultThrow(stringTest(key, `non-empty`, `key`));\n    return graph.vertices.get(key);\n}\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph\n * @returns\n */\nexport function toAdjacencyMatrix(graph) {\n    resultThrow(graphTest(graph));\n    const v = [...graph.vertices.values()];\n    //const m: Array<Array<boolean>> = [];\n    const table = new Table();\n    table.labelColumns(...v.map(vv => vv.id));\n    table.labelRows(...v.map(vv => vv.id));\n    // const row: Array<boolean> = [];\n    // for (let index = 0; index < v.length; index++) {\n    //   row[ index ] = false;\n    // }\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (let i = 0; i < v.length; i++) {\n        //m[ i ] = [ ...row ];\n        table.setRow(i, false, v.length);\n        const ii = v[i];\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        for (const [j, jj] of v.entries()) {\n            if (ii.out.some(o => o.id === jj.id)) {\n                //m[ i ][ j ] = true;\n                table.set(i, j, true);\n            }\n        }\n    }\n    return table;\n}\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph\n * @returns\n */\nexport const dumpGraph = (graph) => {\n    const lines = debugGraphToArray(graph);\n    return lines.join(`\\n`);\n};\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph\n * @returns\n */\nconst debugGraphToArray = (graph) => {\n    const r = [];\n    const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n    for (const v of vertices) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const str = debugDumpVertex(v);\n        r.push(...str.map(line => ` ${line}`));\n    }\n    return r;\n};\n/**\n * Returns the weight of an edge, or 1 if undefined.\n * @param graph\n * @param edge\n * @returns\n */\nexport const distance = (graph, edge) => {\n    if (edge.weight !== undefined)\n        return edge.weight;\n    return 1;\n};\n/**\n * Iterate over all the edges in the graph\n * @param graph\n */\nexport function* edges(graph) {\n    resultThrow(graphTest(graph));\n    const vertices = [...graph.vertices.values()];\n    for (const vertex of vertices) {\n        for (const edge of vertex.out) {\n            yield edge;\n        }\n    }\n}\n/**\n * Iterate over all the vertices of the graph\n * @param graph\n */\nexport function* vertices(graph) {\n    resultThrow(graphTest(graph));\n    const vertices = [...graph.vertices.values()];\n    for (const vertex of vertices) {\n        yield vertex;\n    }\n}\nfunction graphTest(g, parameterName = `graph`) {\n    if (g === undefined)\n        return { success: false, error: `Param '${parameterName}' is undefined. Expected Graph` };\n    if (g === null)\n        return { success: false, error: `Param '${parameterName}' is null. Expected Graph` };\n    if (typeof g === `object`) {\n        if (!(`vertices` in g))\n            return {\n                success: false, error: `Param '${parameterName}.vertices' does not exist. Is it a Graph type?`\n            };\n    }\n    else {\n        return { success: false, error: `Param '${parameterName} is type '${typeof g}'. Expected an object Graph` };\n    }\n    return { success: true, value: g };\n}\n// function throwGraphTest(g: DirectedGraph, parameterName = `graph`) {\n//   const r = testGraph(g, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ] as string)\n// }\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns\n */\nexport function* adjacentVertices(graph, context) {\n    resultThrow(graphTest(graph));\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of vertex.out) {\n        const edgeV = graph.vertices.get(edge.id);\n        if (edgeV === undefined)\n            throw new Error(`Could not find vertex: ${edge.id}`);\n        yield edgeV;\n    }\n}\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n *\n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns\n */\nexport const vertexHasOut = (vertex, outIdOrVertex) => {\n    if (vertex === undefined)\n        return false;\n    const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n    return vertex.out.some(edge => edge.id === outId);\n};\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph\n * @param vertex\n * @returns\n */\nexport const hasNoOuts = (graph, vertex) => {\n    resultThrow(graphTest(graph));\n    const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n    if (context === undefined)\n        return false;\n    return context.out.length === 0;\n};\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph\n * @param vertex\n * @param outIdOrVertex\n * @returns\n */\nexport const hasOnlyOuts = (graph, vertex, ...outIdOrVertex) => {\n    resultThrow(graphTest(graph));\n    const context = resolveVertex(graph, vertex);\n    const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n    if (outs.length !== context.out.length) {\n        //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n        return false;\n    }\n    for (const out of outs) {\n        //console.log(`Testing ${ context.id } -> ${ out.id }`);\n        if (!hasOut(graph, context, out)) {\n            //console.log(`  no`);\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph\n * @param vertex\n * @param outIdOrVertex\n * @returns\n */\nexport const hasOut = (graph, vertex, outIdOrVertex) => {\n    resultThrow(graphTest(graph));\n    const context = resolveVertex(graph, vertex);\n    const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n    return context.out.some(edge => edge.id === outId);\n};\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph\n * @param id\n * @returns\n */\nexport const getOrCreate = (graph, id) => {\n    resultThrow(graphTest(graph));\n    const v = graph.vertices.get(id);\n    if (v !== undefined)\n        return { graph, vertex: v };\n    const vv = createVertex(id);\n    const gg = updateGraphVertex(graph, vv);\n    return { graph: gg, vertex: vv };\n};\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph\n * @param id\n * @returns\n */\nexport const getOrFail = (graph, id) => {\n    resultThrow(graphTest(graph));\n    const v = graph.vertices.get(id);\n    if (v === undefined)\n        throw new Error(`Vertex '${id}' not found in graph`);\n    return v;\n};\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns\n */\nexport const updateGraphVertex = (graph, vertex) => {\n    resultThrow(graphTest(graph));\n    const gr = {\n        ...graph,\n        vertices: graph.vertices.set(vertex.id, vertex)\n    };\n    return gr;\n};\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph\n * @param edge\n * @returns\n */\nexport const distanceDefault = (graph, edge) => {\n    if (edge.weight !== undefined)\n        return edge.weight;\n    return 1;\n};\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n *\n * If edge was not there, original graph is returned.\n * @param graph\n * @param from\n * @param to\n * @returns\n */\nexport function disconnect(graph, from, to) {\n    resultThrow(graphTest(graph));\n    const fromV = resolveVertex(graph, from);\n    const toV = resolveVertex(graph, to);\n    return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n        ...fromV,\n        out: fromV.out.filter(t => t.id !== toV.id)\n    }) : graph;\n}\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph\n * @param from\n * @param to\n * @param weight\n * @returns\n */\nexport function connectTo(graph, from, to, weight) {\n    resultThrow(graphTest(graph));\n    const fromResult = getOrCreate(graph, from);\n    graph = fromResult.graph;\n    const toResult = getOrCreate(graph, to);\n    graph = toResult.graph;\n    const edge = {\n        id: to,\n        weight\n    };\n    if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n        graph = updateGraphVertex(graph, {\n            ...fromResult.vertex,\n            // Add new edge to list of edges for this node\n            out: [...fromResult.vertex.out, edge]\n        });\n    }\n    return { graph, edge };\n}\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n *\n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n *\n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph\n * @param options\n * @returns\n */\nexport function connect(graph, options) {\n    if (typeof graph !== `object`)\n        throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof graph}`);\n    if (typeof options !== `object`)\n        throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof options}`);\n    const result = connectWithEdges(graph, options);\n    return result.graph;\n}\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well.\n *\n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n *\n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph\n * @param options\n * @returns\n */\nexport function connectWithEdges(graph, options) {\n    resultThrow(graphTest(graph));\n    const { to, weight, from } = options;\n    const bidi = options.bidi ?? false;\n    const toList = Array.isArray(to) ? to : [to];\n    const edges = [];\n    // Connect from -> to\n    for (const toSingle of toList) {\n        const result = connectTo(graph, from, toSingle, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    if (!bidi)\n        return { graph, edges };\n    // Bidirectional connection\n    // Connect to -> from\n    for (const toSingle of toList) {\n        const result = connectTo(graph, toSingle, from, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    return { graph, edges };\n}\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v\n * @returns\n */\nconst debugDumpVertex = (v) => {\n    const r = [\n        v.id\n    ];\n    const stringForEdge = (edge) => edge.weight === undefined ? edge.id : `${edge.id} (${edge.weight})`;\n    // for (const edge of v.in) {\n    //   r.push(` <- ${ stringForEdge(edge) }`);\n    // }\n    for (const edge of v.out) {\n        r.push(` -> ${stringForEdge(edge)}`);\n    }\n    if (v.out.length === 0)\n        r[0] += ` (terminal)`;\n    return r;\n};\n/**\n * Returns _true_ if a->b or b->a\n * @param graph\n * @param a\n * @param b\n * @returns\n */\nexport function areAdjacent(graph, a, b) {\n    resultThrow(graphTest(graph));\n    if (hasOut(graph, a, b.id))\n        return true;\n    if (hasOut(graph, b, a.id))\n        return true;\n}\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph\n * @param idOrVertex\n * @returns\n */\nfunction resolveVertex(graph, idOrVertex) {\n    resultThrow(graphTest(graph));\n    if (idOrVertex === undefined)\n        throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n    const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n    if (v === undefined)\n        throw new Error(`Id not found ${idOrVertex}`);\n    return v;\n}\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph\n * @param startIdOrVertex\n * @param targetIdOrVertex\n * @returns\n */\nexport function* bfs(graph, startIdOrVertex, targetIdOrVertex) {\n    resultThrow(graphTest(graph));\n    const start = resolveVertex(graph, startIdOrVertex);\n    const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n    const queue = new QueueMutable();\n    const seen = new Set();\n    queue.enqueue(start);\n    while (!queue.isEmpty) {\n        const v = queue.dequeue();\n        yield v;\n        if (target !== undefined && target === v)\n            return;\n        for (const edge of adjacentVertices(graph, v)) {\n            if (!seen.has(edge.id)) {\n                seen.add(edge.id);\n                queue.enqueue(resolveVertex(graph, edge.id));\n            }\n        }\n    }\n}\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph\n * @param startIdOrVertex\n */\nexport function* dfs(graph, startIdOrVertex) {\n    resultThrow(graphTest(graph));\n    const source = resolveVertex(graph, startIdOrVertex);\n    const s = new StackMutable();\n    const seen = new Set();\n    s.push(source);\n    while (!s.isEmpty) {\n        const v = s.pop();\n        if (v === undefined)\n            continue;\n        if (!seen.has(v.id)) {\n            seen.add(v.id);\n            yield v;\n            for (const edge of v.out) {\n                const destination = graph.vertices.get(edge.id);\n                if (destination) {\n                    s.push(destination);\n                }\n            }\n        }\n    }\n}\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph\n * @param sourceOrId\n * @returns\n */\nexport const pathDijkstra = (graph, sourceOrId) => {\n    resultThrow(graphTest(graph));\n    const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n    if (source === undefined)\n        throw new Error(`source vertex not found`);\n    const distances = new Map();\n    const previous = new Map();\n    distances.set(source.id, 0);\n    const pq = new PriorityMutable();\n    const vertices = [...graph.vertices.values()];\n    for (const v of vertices) {\n        if (v.id !== source.id) {\n            distances.set(v.id, Number.MAX_SAFE_INTEGER);\n            previous.set(v.id, null);\n        }\n        pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n    }\n    while (!pq.isEmpty) {\n        const u = pq.dequeueMin();\n        if (u === undefined)\n            throw new Error(`Bug. Queue unexpectedly empty`);\n        const vertexU = graph.vertices.get(u);\n        for (const neighbour of vertexU.out) {\n            //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n            const alt = distances.get(u) + distance(graph, neighbour);\n            if (alt < distances.get(neighbour.id)) {\n                distances.set(neighbour.id, alt);\n                previous.set(neighbour.id, vertexU);\n                pq.changePriority(neighbour.id, alt, true);\n            }\n        }\n    }\n    const pathTo = (id) => {\n        const path = [];\n        while (true) {\n            if (id === source.id)\n                break;\n            const v = previous.get(id);\n            if (v === undefined || v === null)\n                throw new Error(`Id not present: ${id}`);\n            path.push({ id, weight: distances.get(id) });\n            id = v.id;\n        }\n        return path;\n    };\n    return {\n        distances, previous, pathTo\n    };\n};\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph\n * @returns\n */\nexport const clone = (graph) => {\n    resultThrow(graphTest(graph));\n    const g = {\n        vertices: immutableMap([...graph.vertices.entries()])\n    };\n    return g;\n};\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n *\n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections\n * @returns\n */\nexport const graph = (...initialConnections) => {\n    let g = {\n        vertices: immutableMap()\n    };\n    for (const ic of initialConnections) {\n        g = connect(g, ic);\n    }\n    return g;\n};\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph\n */\nexport function isAcyclic(graph) {\n    resultThrow(graphTest(graph));\n    const cycles = getCycles(graph);\n    return cycles.length === 0;\n}\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph\n */\nexport function topologicalSort(graph) {\n    resultThrow(graphTest(graph));\n    const indegrees = new NumberMap(0);\n    // Increment indegrees for each edge leading to a vertex\n    for (const edge of edges(graph)) {\n        indegrees.add(edge.id, 1);\n    }\n    // Enqueue all vertices with an indegree of 0\n    const queue = new QueueMutable();\n    let vertexCount = 0;\n    for (const vertex of vertices(graph)) {\n        if (indegrees.get(vertex.id) === 0) {\n            queue.enqueue(vertex);\n        }\n        vertexCount++;\n    }\n    const topOrder = [];\n    while (!queue.isEmpty) {\n        // Add to topological order\n        const u = queue.dequeue();\n        topOrder.push(u);\n        // Iterate through neighbours\n        for (const neighbour of u.out) {\n            const result = indegrees.subtract(neighbour.id, 1);\n            if (result === 0) {\n                queue.enqueue(graph.vertices.get(neighbour.id));\n            }\n        }\n    }\n    if (topOrder.length !== vertexCount) {\n        throw new Error(`Graph contains cycles`);\n    }\n    return graphFromVertices(topOrder);\n}\n/**\n * Create a graph from an iterable of vertices\n * @param vertices\n * @returns\n */\nexport function graphFromVertices(vertices) {\n    const keyValues = Sync.map(vertices, f => {\n        return [f.id, f];\n    });\n    const m = immutableMap([...keyValues]);\n    return {\n        vertices: m\n    };\n}\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph\n * @returns\n */\nexport function getCycles(graph) {\n    resultThrow(graphTest(graph));\n    let index = 0;\n    const stack = new StackMutable();\n    const vertices = new Map();\n    const scc = [];\n    for (const v of graph.vertices.values()) {\n        vertices.set(v.id, {\n            ...v,\n            lowlink: Number.NaN,\n            index: Number.NaN,\n            onStack: false\n        });\n    }\n    const strongConnect = (vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index++;\n        stack.push(vertex);\n        vertex.onStack = true;\n        for (const edge of vertex.out) {\n            const edgeV = vertices.get(edge.id);\n            if (Number.isNaN(edgeV.index)) {\n                strongConnect(edgeV);\n                vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n            }\n            else if (edgeV.onStack) {\n                vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n            }\n        }\n        if (vertex.lowlink === vertex.index) {\n            const stronglyConnected = [];\n            let w;\n            while (vertex !== w) {\n                w = stack.pop();\n                w.onStack = false;\n                stronglyConnected.push({ id: w.id, out: w.out });\n            }\n            if (stronglyConnected.length > 1)\n                scc.push(stronglyConnected);\n        }\n    };\n    for (const v of vertices.values()) {\n        if (Number.isNaN(v.index)) {\n            strongConnect(v);\n        }\n    }\n    return scc;\n}\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph\n * @returns\n */\nexport function transitiveReduction(graph) {\n    resultThrow(graphTest(graph));\n    for (const u of vertices(graph)) {\n        for (const v of adjacentVertices(graph, u)) {\n            for (const v1 of dfs(graph, v)) {\n                if (v.id === v1.id)\n                    continue;\n                if (hasOut(graph, u, v1)) {\n                    const g = disconnect(graph, u, v1);\n                    return transitiveReduction(g);\n                }\n            }\n        }\n    }\n    return graph;\n}\n","import { immutable as immutableMap } from \"../map/map.js\";\nimport { Table } from \"../table.js\";\nexport const createVertex = (id) => {\n    return {\n        id\n    };\n};\nexport const updateGraphVertex = (graph, vertex) => {\n    const gr = {\n        ...graph,\n        vertices: graph.vertices.set(vertex.id, vertex)\n    };\n    return gr;\n};\nexport const getOrCreate = (graph, id) => {\n    const v = graph.vertices.get(id);\n    if (v !== undefined)\n        return { graph, vertex: v };\n    const vv = createVertex(id);\n    const gg = updateGraphVertex(graph, vv);\n    return { graph: gg, vertex: vv };\n};\nfunction resolveVertex(graph, idOrVertex) {\n    if (idOrVertex === undefined)\n        throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n    if (graph === undefined)\n        throw new Error(`Param 'graph' is undefined. Expected Graph`);\n    const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n    if (v === undefined)\n        throw new Error(`Id not found ${idOrVertex}`);\n    return v;\n}\n/**\n * Returns _true/false_ if there is a connection between `a` and `b` in `graph`.\n * Use {@link getConnection} if you want to the edge.\n * @param graph Graph to search\n * @param a\n * @param b\n * @returns _true_ if edge exists\n */\nexport const hasConnection = (graph, a, b) => {\n    const edge = getConnection(graph, a, b);\n    return edge !== undefined;\n};\n/**\n * Gets the connection, if it exists between `a` and `b` in `graph`.\n * If it doesn't exist, _undefined_ is returned.\n * Use {@link hasConnection} for a simple true/false if edge exists.\n * @param graph Graph\n * @param a\n * @param b\n * @returns\n */\nexport const getConnection = (graph, a, b) => {\n    if (a === undefined)\n        throw new Error(`Param 'a' is undefined. Expected string or Vertex`);\n    if (b === undefined)\n        throw new Error(`Param 'b' is undefined. Expected string or Vertex`);\n    if (graph === undefined)\n        throw new Error(`Param 'graph' is undefined. Expected Graph`);\n    const aa = resolveVertex(graph, a);\n    const bb = resolveVertex(graph, b);\n    for (const edge of graph.edges) {\n        if (edge.a == aa.id && edge.b === bb.id)\n            return edge;\n        if (edge.a == bb.id && edge.b === aa.id)\n            return edge;\n    }\n    return;\n};\n/**\n * Connects A with B, returning the changed graph and created edge.\n * If the connection already exists, the original graph & edge is returned.\n * @param graph\n * @param a\n * @param b\n * @param weight\n * @returns\n */\nexport function connectTo(graph, a, b, weight) {\n    const aResult = getOrCreate(graph, a);\n    graph = aResult.graph;\n    const bResult = getOrCreate(graph, b);\n    graph = bResult.graph;\n    let edge = getConnection(graph, a, b);\n    if (edge !== undefined)\n        return { graph, edge };\n    edge = {\n        a,\n        b,\n        weight\n    };\n    const graphChanged = {\n        ...graph,\n        edges: [...graph.edges, edge]\n    };\n    return { graph: graphChanged, edge };\n}\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connectWithEdges} but only the {@link Graph} is returned.\n *\n * ```js\n * let g = graph(); // Create an empty graph\n * // Make a connection between `red` and `orange`\n * g = connect(g, { a: `red`, b: `orange` });\n *\n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * g = connect(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connect(graph, options) {\n    const result = connectWithEdges(graph, options);\n    return result.graph;\n}\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connect} but graph and edges are returned.\n *\n * ```js\n * let g = graph(); // Create an empty graph\n *\n * // Make a connection between `red` and `orange`\n * result = connectWithEdges(g, { a: `red`, b: `orange` });\n *\n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * result = connectWithEdges(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connectWithEdges(graph, options) {\n    const { a, weight, b } = options;\n    const destinations = Array.isArray(b) ? b : [b];\n    const edges = [];\n    for (const destination of destinations) {\n        const result = connectTo(graph, a, destination, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    return { graph, edges };\n}\nexport const graph = (...initialConnections) => {\n    let g = {\n        vertices: immutableMap(),\n        edges: []\n    };\n    for (const ic of initialConnections) {\n        g = connect(g, ic);\n    }\n    return g;\n};\nexport function toAdjacencyMatrix(graph) {\n    const v = [...graph.vertices.values()];\n    const table = new Table();\n    table.labelColumns(...v.map(vv => vv.id));\n    table.labelRows(...v.map(vv => vv.id));\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (let i = 0; i < v.length; i++) {\n        table.setRow(i, false, v.length);\n        const ii = v[i];\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        for (const [j, jj] of v.entries()) {\n            const connected = hasConnection(graph, ii, jj);\n            if (connected) {\n                table.set(i, j, true);\n            }\n        }\n    }\n    return table;\n}\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph\n * @returns\n */\nexport const dumpGraph = (graph) => {\n    const lines = debugGraphToArray(graph);\n    return lines.join(`\\n`);\n};\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph\n * @returns\n */\nconst debugGraphToArray = (graph) => {\n    const r = [];\n    r.push(`Vertices: ${[...graph.vertices.values()].map(v => v.id).join(`, `)}`);\n    r.push(`Edges:`);\n    for (const edge of graph.edges) {\n        r.push(stringForEdge(edge));\n    }\n    return r;\n};\nconst stringForEdge = (edge) => {\n    const weight = edge.weight ? ` (${edge.weight})` : ``;\n    return `${edge.a} <-> ${edge.b}${weight}`;\n};\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns\n */\nexport function* adjacentVertices(graph, context) {\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of graph.edges) {\n        if (edge.a === context)\n            yield resolveVertex(graph, edge.b);\n        else if (edge.b === context)\n            yield resolveVertex(graph, edge.a);\n    }\n}\nexport function* edgesForVertex(graph, context) {\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of graph.edges) {\n        if (edge.a === context)\n            yield edge;\n        else if (edge.b === context)\n            yield edge;\n    }\n}\n","/**\n * Directed graphs\n *\n * Graph _vertices_ (ie. nodes) connect to each other along _edges_.\n * This is 'directed' in that connections are not necessarily mutual.\n * A can connect to B without B connecting to A.\n *\n * Connections can have an optional weight, defaulting to 1.\n *\n * @example Creating a directed graph A connects to B and C; B connects to C. C has edges.\n * ```js\n * let g = Directed.graph(\n *  { from: `a`, to: [`b`, `c`] },\n *  { from: `b`, to: `c` }\n*  );\n* ```\n*\n* Graphs do not store data directly, only the relation between vertices. Each vertex has an id,\n* so to associate data, use a map along with the graph.\n*\n*/\nexport * as Directed from './directed-graph.js';\n/**\n * Undirected graphs\n *\n * Graph _vertices_ (ie. nodes) connect to each other along _edges_.\n * Unlike a directed graph, nodes are always mutually connected.\n *\n * @example Creating an undirected graph where vertex 0 connects to 1, 2 & 3; 2 connects to 1\n * ```js\n * let g = Undirected.graph(\n *    { a: `0`, b: [ `1`, `2`, `3` ] },\n *    { a: `2`, b: `1` }\n *  );\n* ```\n*\n* Graphs do not store data directly, only the relation between vertices. Each vertex has an id,\n* so to associate data, use a map along with the graph.\n*\n*/\nexport * as Undirected from './undirected-graph.js';\n","export * from './circular-array.js';\n/**\n * A tree-like structure of branches and leaves.\n *\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const root = Trees.Mutable.rootWrapped(`root`);\n * // Add 'a' as the child of the root node\n * let a = root.addValue(`a`);\n * // Add `aa` as the child of `a`\n * let b = a.addValue(`aa`);\n * b.hasParent(a); // True\n * ```\n */\nexport * as Trees from './tree/index.js';\nexport * from './tree/types.js';\n/**\n * Stacks store items in order, like a stack of plates.\n *\n * ```js\n * import { Stacks } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * let s = Stacks.immutable();\n * s = s.push(`a`, `b`);   // Add two strings\n * // Peek looks at the top of the stack\n * // (ie most recently added)\n * s.peek; // `b`\n * // Remove item from top of stack\n * s = s.pop();\n * s.peek // `a`\n * ```\n */\nexport * as Stacks from './stack/index.js';\nexport { StackMutable } from './stack/StackMutable.js';\nexport { StackImmutable } from './stack/StackImmutable.js';\n/**\n * Sets store unique items.\n */\nexport * as Sets from './set/index.js';\nexport * from './set/Types.js';\nexport { SetStringMutable } from './set/set-mutable.js';\nexport { SetStringImmutable } from './set/SetImmutable.js';\nexport * from './set/ISetMutable.js';\n/**\n * Queues store items in the order in which they are added.\n */\nexport * as Queues from './queue/index.js';\nexport { QueueMutable } from './queue/queue-mutable.js';\nexport { QueueImmutable } from './queue/queue-immutable.js';\n/**\n * Maps associate keys with values.\n */\nexport * as Maps from './map/index.js';\nexport { ExpiringMap } from './map/expiring-map.js';\nexport { MapOfSimpleMutable } from './map/map-of-simple-mutable.js';\n/**\n * Undirected and directed graphs and associated algorithms.\n *\n * @example\n * ```js\n * import { Graphs } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const Dg = Graphs.Directed;\n * let g = Dg.graph();\n * g = Dg.connect(g, { from: `a`, to: `b` });\n * g = Dg.connect(g, { from: `b`, to: `c` });\n * g = Dg.connect(g, { from: `c`, to: `a` });\n * Dg.dumpGraph(g);\n * // A -> B, B -> C, C -> A\n * ```\n */\nexport * as Graphs from './graph/index.js';\nexport { Table } from './table.js';\n","const t = {\n    name: `root`,\n    seq: [\n        `walk_to_door`,\n        {\n            name: `door_locked`,\n            sel: [\n                `open_door`,\n                {\n                    name: `open_locked_door`,\n                    seq: [`unlock_door`, `open_door`]\n                },\n                `smash_door`\n            ]\n        },\n        `walk_through_door`,\n        `close_door`\n    ]\n};\nconst getName = (t, defaultValue = ``) => {\n    if (typeof t === `object` && `name` in t && t.name !== undefined)\n        return t.name;\n    return defaultValue;\n};\n//eslint-disable-next-line func-style\nexport function* iterateBreadth(t, pathPrefix) {\n    if (typeof pathPrefix === `undefined`) {\n        pathPrefix = getName(t);\n    }\n    for (const [index, n] of entries(t)) {\n        yield [n, pathPrefix];\n    }\n    for (const [index, n] of entries(t)) {\n        const name = getName(n, `?`);\n        const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n        yield* iterateBreadth(n, prefix);\n    }\n}\n//eslint-disable-next-line func-style\nexport function* iterateDepth(t, pathPrefix) {\n    if (typeof pathPrefix === `undefined`) {\n        pathPrefix = getName(t);\n    }\n    for (const [index, n] of entries(t)) {\n        yield [n, pathPrefix];\n        const name = getName(n, `?`);\n        const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n        yield* iterateBreadth(n, prefix);\n    }\n}\n//eslint-disable-next-line func-style\nfunction isSeqNode(n) {\n    return n.seq !== undefined;\n}\n//eslint-disable-next-line func-style\nfunction isSelNode(n) {\n    return n.sel !== undefined;\n}\n//eslint-disable-next-line func-style\nfunction* entries(n) {\n    if (isSeqNode(n)) {\n        yield* n.seq.entries();\n    }\n    else if (isSelNode(n)) {\n        yield* n.sel.entries();\n    }\n    else if (typeof n === `string`) {\n        // no-op\n    }\n    else {\n        throw new TypeError(`Unexpected shape of node. seq/sel missing`);\n    }\n}\n// for (const tn of iterateBreadth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n// console.log(`---`);\n// for (const tn of iterateDepth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n","import { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async (callback, \n//eslint-disable-next-line functional/prefer-immutable-types\noptsOrMillis) => {\n    const opts = typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n    const delayWhen = opts.delay ?? `before`;\n    if (delayWhen === `before` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    const r = Promise.resolve(await callback());\n    if (delayWhen === `after` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    return r;\n};\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//     // Yield value\n//     yield v;\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n *\n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n *\n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n *\n * The below example shows how to do this.\n *\n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n *\n * // Execution continues while loop also runs\n * ```\n *\n */\nasync function* delayAnimationLoop() {\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer = 0;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.requestAnimationFrame(callback);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        globalThis.cancelAnimationFrame(timer);\n    }\n}\n/**\n * Async generator that loops at a given interval.\n *\n * @example\n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n *\n * @example\n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport async function* delayLoop(timeout) {\n    const timeoutMs = intervalToMs(timeout);\n    if (typeof timeoutMs === `undefined`)\n        throw new Error(`timeout is undefined`);\n    if (timeoutMs < 0)\n        throw new Error(`Timeout is less than zero`);\n    if (timeoutMs === 0)\n        return yield* delayAnimationLoop();\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.setTimeout(callback, timeoutMs);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        if (timer !== undefined)\n            globalThis.clearTimeout(timer);\n        timer = undefined;\n    }\n}\n","import { integerTest, resultToError, resultIsError, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n *\n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (callback, interval) => {\n    if (callback === undefined) {\n        throw new Error(`callback parameter is undefined`);\n    }\n    const intervalMs = intervalToMs(interval);\n    resultThrow(integerTest(intervalMs, `aboveZero`, `interval`));\n    let timer;\n    let startedAt = 0;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let state = `idle`;\n    const clear = () => {\n        startedAt = 0;\n        globalThis.clearTimeout(timer);\n        state = `idle`;\n    };\n    const start = async (altInterval = interval, args) => {\n        const p = new Promise((resolve, reject) => {\n            startedAt = performance.now();\n            const altTimeoutMs = intervalToMs(altInterval);\n            const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n            if (resultIsError(it)) {\n                reject(resultToError(it));\n                return;\n            }\n            switch (state) {\n                case `scheduled`: {\n                    // Cancel other scheduled execution\n                    cancel();\n                    break;\n                }\n                case `running`: {\n                    //console.warn(`Timeout being rescheduled while task is already running`);\n                    break;\n                }\n            }\n            state = `scheduled`;\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            timer = globalThis.setTimeout(async () => {\n                if (state !== `scheduled`) {\n                    console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n                    clear();\n                    return;\n                }\n                const args_ = args ?? [];\n                startCount++;\n                startCountTotal++;\n                state = `running`;\n                await callback(performance.now() - startedAt, ...args_);\n                state = `idle`;\n                clear();\n                resolve();\n            }, altTimeoutMs);\n        });\n        return p;\n    };\n    const cancel = () => {\n        if (state === `idle`)\n            return;\n        clear();\n    };\n    return {\n        start,\n        cancel,\n        get runState() {\n            return state;\n        },\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        }\n    };\n};\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });\n","import { timeout, } from './timeout.js';\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param interval Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (callback, interval) => {\n    const t = timeout(callback, interval);\n    return (...args) => { t.start(undefined, args); };\n};\n","/**\n * Maintains a list of listeners to receive data\n *\n * ```js\n * const d = new DispatchList();\n *\n * // Eg: add a listener\n * d.add(v => {\n *  // Handle a value\n * });\n *\n * // Eg. send a value to all listeners\n * d.notify(`some value`);\n * ```\n */\nexport class DispatchList {\n    #handlers;\n    #counter = 0;\n    #id = Math.floor(Math.random() * 100);\n    constructor() {\n        this.#handlers = [];\n    }\n    /**\n     * Returns _true_ if list is empty\n     * @returns\n     */\n    isEmpty() {\n        return this.#handlers.length === 0;\n    }\n    /**\n     * Adds a handler. You get back an id which can be used\n     * to remove the handler later.\n     *\n     * Handlers can be added with 'once' flag set to _true_. This will\n     * automatically remove them after the first value is sent to them.\n     * @param handler\n     * @param options\n     * @returns\n     */\n    add(handler, options = {}) {\n        this.#counter++;\n        const once = options.once ?? false;\n        const wrap = {\n            id: `${this.#id} - ${this.#counter}`,\n            handler,\n            once\n        };\n        this.#handlers.push(wrap);\n        return wrap.id;\n    }\n    /**\n     * Remove a handler by its id.\n     * @param id\n     * @returns _True_ if handler was removed, _false_ if not found.\n     */\n    remove(id) {\n        const length = this.#handlers.length;\n        this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n        return this.#handlers.length !== length;\n    }\n    /**\n     * Emit a value to all handlers\n     * @param value\n     */\n    notify(value) {\n        for (const handler of this.#handlers) {\n            handler.handler(value);\n            if (handler.once) {\n                this.remove(handler.id);\n            }\n        }\n    }\n    /**\n     * Remove all handlers\n     */\n    clear() {\n        this.#handlers = [];\n    }\n}\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = (nth, callback) => {\n    resultThrow(integerTest(nth, `positive`, `nth`));\n    let counter = 0;\n    return (data) => {\n        counter++;\n        if (counter === nth) {\n            counter = 0;\n            if (callback)\n                callback(data);\n            return true;\n        }\n        return false;\n    };\n};\n","import { defaultComparer } from '@ixfx/core';\nimport { shuffle } from '@ixfx/arrays';\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = runSingle([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async (expressions, opts = {}, args) => {\n    const results = [];\n    const compareFunction = opts.rank ?? defaultComparer;\n    let expressionsArray = Array.isArray(expressions)\n        ? (expressions)\n        : [expressions];\n    if (opts.shuffle)\n        expressionsArray = shuffle(expressionsArray);\n    for (let index = 0; index < expressionsArray.length; index++) {\n        const exp = expressionsArray[index];\n        let r;\n        if (typeof exp === 'function') {\n            // @ts-ignore\n            r = await exp(args);\n        }\n        else {\n            r = exp;\n        }\n        if (r !== undefined) {\n            results.push(r);\n            results.sort(compareFunction);\n        }\n        if (typeof opts.stop !== 'undefined') {\n            if (opts.stop(r, results)) {\n                break;\n            }\n        }\n    }\n    if (opts.filter) {\n        return results.filter(opts.filter);\n    }\n    return results;\n};\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async (expressions, opts = {}, args) => {\n    const results = await run(expressions, opts, args);\n    if (!results)\n        return;\n    if (results.length === 0)\n        return;\n    const at = opts.at ?? -1;\n    return results.at(at);\n};\n","/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n *\n * By default waits a maximum of 1 minute.\n *\n * Automatically unsubscribes on success or failure (ie. timeout)\n *\n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns\n */\nexport const eventRace = (target, eventNames, options = {}) => {\n    const intervalMs = options.timeoutMs ?? 60_1000; //intervalToMs(options.timeout, 60 * 1000);\n    const signal = options.signal;\n    let triggered = false;\n    let disposed = false;\n    let timeout;\n    const promise = new Promise((resolve, reject) => {\n        const onEvent = (event) => {\n            if (`type` in event) {\n                if (eventNames.includes(event.type)) {\n                    triggered = true;\n                    resolve(event);\n                    dispose();\n                }\n                else {\n                    console.warn(`eventRace: Got event '${event.type}' that is not in race list`);\n                }\n            }\n            else {\n                console.warn(`eventRace: Event data does not have expected 'type' field`);\n                console.log(event);\n            }\n        };\n        for (const name of eventNames) {\n            target.addEventListener(name, onEvent);\n        }\n        const dispose = () => {\n            if (disposed)\n                return;\n            if (timeout !== undefined)\n                clearTimeout(timeout);\n            timeout = undefined;\n            disposed = true;\n            for (const name of eventNames) {\n                target.removeEventListener(name, onEvent);\n            }\n        };\n        timeout = setTimeout(() => {\n            if (triggered || disposed)\n                return;\n            dispose();\n            reject(new Error(`eventRace: Events not fired within interval. Events: ${JSON.stringify(eventNames)} Interval: ${intervalMs}`));\n        }, intervalMs);\n        signal?.addEventListener(`abort`, () => {\n            if (triggered || disposed)\n                return;\n            dispose();\n            reject(new Error(`Abort signal received ${signal.reason}`));\n        });\n    });\n    return promise;\n};\n","import { movingAverageLight } from \"@ixfx/numbers\";\nimport { rateMinimum } from \"@ixfx/flow\";\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n *\n * mat(); // Get current average\n * ```\n *\n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n *\n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options) => {\n    const average = movingAverageLight();\n    const rm = rateMinimum({\n        ...options,\n        whatToCall: (distance) => {\n            average(distance);\n        },\n        fallback() {\n            return options.default ?? 0;\n        }\n    });\n    return (v) => {\n        rm(v);\n        return average();\n    };\n};\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as Debug from '@ixfx/debug';\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser extends SimpleEventEmitter {\n    key;\n    resource;\n    _lastUpdate;\n    _pool;\n    _state;\n    _userExpireAfterMs;\n    /**\n     * Constructor\n     * @param key User key\n     * @param resource Resource being used\n     */\n    constructor(key, resource) {\n        super();\n        this.key = key;\n        this.resource = resource;\n        this._lastUpdate = performance.now();\n        this._pool = resource.pool;\n        this._userExpireAfterMs = this._pool.userExpireAfterMs;\n        this._state = `idle`;\n        this._pool.log.log(`PoolUser ctor key: ${this.key}`);\n    }\n    /**\n     * Returns a human readable debug string\n     * @returns\n     */\n    toString() {\n        if (this.isDisposed)\n            return `PoolUser. State: disposed`;\n        return `PoolUser. State: ${this._state} Elapsed: ${performance.now() - this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`;\n    }\n    /**\n     * Resets countdown for instance expiry.\n     * Throws an error if instance is disposed.\n     */\n    keepAlive() {\n        if (this._state === `disposed`)\n            throw new Error(`PoolItem disposed`);\n        this._lastUpdate = performance.now();\n    }\n    /**\n     * @internal\n     * @param reason\n     * @returns\n     */\n    _dispose(reason, data) {\n        if (this._state === `disposed`)\n            return;\n        const resource = this.resource;\n        //const data = resource.data;\n        this._state = `disposed`;\n        resource._release(this);\n        this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${reason}`);\n        this.fireEvent(`disposed`, { data, reason });\n        super.clearEventListeners();\n    }\n    /**\n     * Release this instance\n     * @param reason\n     */\n    release(reason) {\n        if (this.isDisposed)\n            throw new Error(`User disposed`);\n        const resource = this.resource;\n        const data = resource.data;\n        this._pool.log.log(`PoolUser release key: ${this.key} reason: ${reason}`);\n        this.fireEvent(`released`, { data, reason });\n        this._dispose(`release-${reason}`, data);\n    }\n    // #region Properties\n    get data() {\n        if (this.isDisposed)\n            throw new Error(`User disposed`);\n        return this.resource.data;\n    }\n    /**\n     * Returns true if this instance has expired.\n     * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n     */\n    get isExpired() {\n        if (this._userExpireAfterMs > 0) {\n            return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n        }\n        return false;\n    }\n    /**\n     * Returns elapsed time since last 'update'\n     */\n    get elapsed() {\n        return performance.now() - this._lastUpdate;\n    }\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed() {\n        return this._state === `disposed`;\n    }\n    /**\n     * Returns true if instance is neither disposed nor expired\n     */\n    get isValid() {\n        if (this.isDisposed || this.isExpired)\n            return false;\n        if (this.resource.isDisposed)\n            return false;\n        return true;\n    }\n}\n/**\n * A resource allocated in the Pool\n */\nexport class Resource {\n    pool;\n    #state;\n    #data;\n    #users;\n    #capacityPerResource;\n    #resourcesWithoutUserExpireAfterMs;\n    #lastUsersChange;\n    /**\n     * Constructor.\n     * @param pool Pool\n     * @param data Data\n     */\n    constructor(pool, data) {\n        this.pool = pool;\n        if (data === undefined)\n            throw new Error(`Parameter 'data' is undefined`);\n        if (pool === undefined)\n            throw new Error(`Parameter 'pool' is undefined`);\n        this.#data = data;\n        this.#lastUsersChange = 0;\n        this.#resourcesWithoutUserExpireAfterMs =\n            pool.resourcesWithoutUserExpireAfterMs;\n        this.#capacityPerResource = pool.capacityPerResource;\n        this.#users = [];\n        this.#state = `idle`;\n    }\n    /**\n     * Gets data associated with resource.\n     * Throws an error if disposed\n     */\n    get data() {\n        if (this.#state === `disposed`)\n            throw new Error(`Resource disposed`);\n        return this.#data;\n    }\n    /**\n     * Changes the data associated with this resource.\n     * Throws an error if disposed or `data` is undefined.\n     * @param data\n     */\n    updateData(data) {\n        if (this.#state === `disposed`)\n            throw new Error(`Resource disposed`);\n        if (data === undefined)\n            throw new Error(`Parameter 'data' is undefined`);\n        this.#data = data;\n    }\n    /**\n     * Returns a human-readable debug string for resource\n     * @returns\n     */\n    toString() {\n        return `Resource (expired: ${this.isExpiredFromUsers} users: ${this.#users.length}, state: ${this.#state}) data: ${JSON.stringify(this.data)}`;\n    }\n    /**\n     * Assigns a user to this resource.\n     * @internal\n     * @param user\n     */\n    _assign(user) {\n        const existing = this.#users.find((u) => u === user || u.key === user.key);\n        if (existing)\n            throw new Error(`User instance already assigned to resource`);\n        this.#users.push(user);\n        this.#lastUsersChange = performance.now();\n    }\n    /**\n     * Releases a user from this resource\n     * @internal\n     * @param user\n     */\n    _release(user) {\n        this.#users = this.#users.filter((u) => u !== user);\n        this.pool._release(user);\n        this.#lastUsersChange = performance.now();\n    }\n    /**\n     * Returns true if resource can have additional users allocated\n     */\n    get hasUserCapacity() {\n        return this.usersCount < this.#capacityPerResource;\n    }\n    /**\n     * Returns number of uses of the resource\n     */\n    get usersCount() {\n        return this.#users.length;\n    }\n    /**\n     * Returns true if automatic expiry is enabled, and that interval\n     * has elapsed since the users list has changed for this resource\n     */\n    get isExpiredFromUsers() {\n        if (this.#resourcesWithoutUserExpireAfterMs <= 0)\n            return false;\n        if (this.#users.length > 0)\n            return false;\n        return (performance.now() >\n            this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange);\n    }\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed() {\n        return this.#state === `disposed`;\n    }\n    /**\n     * Disposes the resource.\n     * If it is already disposed, it does nothing.\n     * @param reason\n     * @returns\n     */\n    dispose(reason) {\n        if (this.#state === `disposed`)\n            return;\n        const data = this.#data;\n        this.#state = `disposed`;\n        this.pool.log.log(`Resource disposed (${reason})`);\n        for (const u of this.#users) {\n            u._dispose(`resource-${reason}`, data);\n        }\n        this.#users = [];\n        this.#lastUsersChange = performance.now();\n        this.pool._releaseResource(this, reason);\n        if (this.pool.freeResource)\n            this.pool.freeResource(data);\n    }\n}\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'.\n * All resources in the Pool are meant to be the same kind of object.\n *\n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n *\n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n *\n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport class Pool {\n    _resources;\n    _users;\n    capacity;\n    userExpireAfterMs;\n    resourcesWithoutUserExpireAfterMs;\n    capacityPerResource;\n    fullPolicy;\n    generateResource;\n    freeResource;\n    log = Debug.logSet(`Pool`);\n    /**\n     * Constructor.\n     *\n     * By default, no capacity limit, one user per resource\n     * @param options Pool options\n     */\n    constructor(options = {}) {\n        this.capacity = options.capacity ?? -1;\n        this.fullPolicy = options.fullPolicy ?? `error`;\n        this.capacityPerResource = options.capacityPerResource ?? 1;\n        this.userExpireAfterMs = options.userExpireAfterMs ?? -1;\n        this.resourcesWithoutUserExpireAfterMs =\n            options.resourcesWithoutUserExpireAfterMs ?? -1;\n        this.generateResource = options.generate;\n        this.freeResource = options.free;\n        this._users = new Map();\n        this._resources = [];\n        this.log = Debug.logSet(`Pool`, options.debug ?? false);\n        // If we have a time-based expiry, set an interval to\n        // automatically do the housekeeping\n        const timer = Math.max(this.userExpireAfterMs, this.resourcesWithoutUserExpireAfterMs);\n        if (timer > 0) {\n            setInterval(() => {\n                this.maintain();\n            }, timer * 1.1);\n        }\n    }\n    /**\n     * Returns a debug string of Pool state\n     * @returns\n     */\n    dumpToString() {\n        let r = `Pool\n    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}\n    resources count: ${this._resources.length}`;\n        const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n        r += `\\r\\nResources:\\r\\n\\t` + resource;\n        r += `\\r\\nUsers: \\r\\n`;\n        for (const [k, v] of this._users.entries()) {\n            r += `\\tk: ${k} v: ${v.toString()}\\r\\n`;\n        }\n        return r;\n    }\n    /**\n     * Sorts users by longest elapsed time since update\n     * @returns\n     */\n    getUsersByLongestElapsed() {\n        return [...this._users.values()].sort((a, b) => {\n            const aa = a.elapsed;\n            const bb = b.elapsed;\n            if (aa === bb)\n                return 0;\n            if (aa < bb)\n                return 1;\n            return -1;\n        });\n    }\n    /**\n     * Returns resources sorted with least used first\n     * @returns\n     */\n    getResourcesSortedByUse() {\n        return [...this._resources].sort((a, b) => {\n            if (a.usersCount === b.usersCount)\n                return 0;\n            if (a.usersCount < b.usersCount)\n                return -1;\n            return 1;\n        });\n    }\n    /**\n     * Adds a shared resource to the pool\n     * @throws Error if the capacity limit is reached or resource is null\n     * @param resource\n     * @returns\n     */\n    addResource(resource) {\n        if (resource === undefined) {\n            throw new Error(`Cannot add undefined resource`);\n        }\n        if (resource === null)\n            throw new TypeError(`Cannot add null resource`);\n        if (this.capacity > 0 && this._resources.length === this.capacity) {\n            throw new Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);\n        }\n        this.log.log(`Adding resource: ${JSON.stringify(resource)}`);\n        const pi = new Resource(this, resource);\n        this._resources.push(pi);\n        return pi;\n    }\n    /**\n     * Performs maintenance, removing disposed/expired resources & users.\n     * This is called automatically when using a resource.\n     */\n    maintain() {\n        let changed = false;\n        // Find all disposed resources\n        const nuke = [];\n        for (const p of this._resources) {\n            if (p.isDisposed) {\n                this.log.log(`Maintain, disposed resource: ${JSON.stringify(p.data)}`);\n                nuke.push(p);\n            }\n            else if (p.isExpiredFromUsers) {\n                this.log.log(`Maintain, expired resource: ${JSON.stringify(p.data)}`);\n                nuke.push(p);\n            }\n        }\n        // Remove them\n        if (nuke.length > 0) {\n            for (const resource of nuke) {\n                resource.dispose(`diposed/expired`);\n            }\n            changed = true;\n        }\n        // Find 'users' to clean up\n        const userKeysToRemove = [];\n        for (const [key, user] of this._users.entries()) {\n            if (!user.isValid) {\n                this.log.log(`Maintain. Invalid user: ${user.key} (Disposed: ${user.isDisposed} Expired: ${user.isExpired} Resource disposed: ${user.resource.isDisposed})`);\n                userKeysToRemove.push(key);\n                user._dispose(`invalid`, user.data);\n            }\n        }\n        for (const userKey of userKeysToRemove) {\n            this._users.delete(userKey);\n            changed = true;\n        }\n        if (changed) {\n            this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`);\n        }\n    }\n    /**\n     * Iterate over resources in the pool.\n     * To iterate over the data associated with each resource, use\n     * `values`.\n     */\n    *resources() {\n        const resource = [...this._resources];\n        for (const r of resource) {\n            yield r;\n        }\n    }\n    /**\n     * Iterate over resource values in the pool.\n     * to iterate over the resources, use `resources`.\n     *\n     * Note that values may be returned even though there is no\n     * active user.\n     */\n    *values() {\n        const resource = [...this._resources];\n        for (const r of resource) {\n            yield r.data;\n        }\n    }\n    /**\n     * Unassociate a key with a pool item\n     * @param userKey\n     */\n    release(userKey, reason) {\n        const pi = this._users.get(userKey);\n        if (!pi)\n            return;\n        pi.release(reason ?? `Pool.release`);\n    }\n    /**\n     * @internal\n     * @param user\n     */\n    _release(user) {\n        this._users.delete(user.key);\n    }\n    /**\n     * @internal\n     * @param resource\n     * @param _\n     */\n    _releaseResource(resource, _) {\n        this._resources = this._resources.filter((v) => v !== resource);\n    }\n    /**\n     * Returns true if `v` has an associted resource in the pool\n     * @param resource\n     * @returns\n     */\n    hasResource(resource) {\n        const found = this._resources.find((v) => v.data === resource);\n        return found !== undefined;\n    }\n    /**\n     * Returns true if a given `userKey` is in use.\n     * @param userKey\n     * @returns\n     */\n    hasUser(userKey) {\n        return this._users.has(userKey);\n    }\n    /**\n     * @internal\n     * @param key\n     * @param resource\n     * @returns\n     */\n    _assign(key, resource) {\n        const u = new PoolUser(key, resource);\n        this._users.set(key, u);\n        resource._assign(u);\n        return u;\n    }\n    /**\n     * Allocates a resource for `userKey`\n     * @internal\n     * @param userKey\n     * @returns\n     */\n    #allocateResource(userKey) {\n        // Sort items by number of users per pool item\n        const sorted = this.getResourcesSortedByUse();\n        // for (let i=0;i<sorted.length;i++) {\n        //   console.log(i +`. users: ` + sorted[i].usersCount);\n        // }\n        if (sorted.length > 0 && sorted[0].hasUserCapacity) {\n            // No problem, resource has capacity\n            //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n            const u = this._assign(userKey, sorted[0]);\n            return u;\n        }\n        // If resource count is below capacity, can we generate more?\n        if (this.generateResource &&\n            (this.capacity < 0 || this._resources.length < this.capacity)) {\n            this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);\n            const resourceGenerated = this.addResource(this.generateResource());\n            const u = this._assign(userKey, resourceGenerated);\n            return u;\n        }\n    }\n    /**\n     * Return the number of users\n     */\n    get usersLength() {\n        return [...this._users.values()].length;\n    }\n    /**\n     * 'Uses' a resource, returning the value\n     * @param userKey\n     * @returns\n     */\n    useValue(userKey) {\n        const resource = this.use(userKey);\n        return resource.resource.data;\n    }\n    /**\n     * Gets a pool item based on a 'user' key.\n     *\n     * The same key should return the same pool item,\n     * for as long as it still exists.\n     *\n     * If a 'user' already has a resource, it will 'keep alive' their use.\n     * If a 'user' does not already have resource\n     *  - if there is capacity, a resource is allocated to user\n     *  - if pool is full\n     *    - fullPolicy = 'error': an error is thrown\n     *    - fullPolicy = 'evictOldestUser': evicts an older user\n     *    - Throw error\n     * @param userKey\n     * @throws Error If all resources are used and fullPolicy = 'error'\n     * @returns\n     */\n    use(userKey) {\n        const pi = this._users.get(userKey);\n        if (pi) {\n            pi.keepAlive();\n            return pi;\n        }\n        this.maintain();\n        const match = this.#allocateResource(userKey);\n        if (match)\n            return match;\n        // Throw an error if all items are being used\n        if (this.fullPolicy === `error`) {\n            //console.log(this.dumpToString());\n            throw new Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);\n        }\n        // Evict oldest user\n        if (this.fullPolicy === `evictOldestUser`) {\n            const users = this.getUsersByLongestElapsed();\n            if (users.length > 0) {\n                this.release(users[0].key, `evictedOldestUser`);\n                const match2 = this.#allocateResource(userKey);\n                if (match2)\n                    return match2;\n            }\n        }\n        // Evict newest user\n        // Evict from random pool item\n        throw new Error(`Pool is fully used (${this.fullPolicy})`);\n    }\n}\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport const create = (options = {}) => new Pool(options);\n","/**\n * Creates a new Promise, returning the promise\n * along with its resolve and reject functions.\n *\n * ```js\n * const { promise, resolve, reject } = promiseWithResolvers();\n *\n * setTimeout(() => {\n *  resolve();\n * }, 1000);\n *\n * await promise;\n * ```\n *\n * Promise would be passed somewhere that expects a promise,\n * and you're free to call `resolve` or `reject` when needed.\n * @returns\n */\nexport function promiseWithResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: resolve, reject: reject };\n}\n","import { timeout } from \"./timeout.js\";\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n *\n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n *\n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n *\n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ```\n *\n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n *\n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n *\n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n *\n * @param options\n * @returns\n */\nexport const rateMinimum = (options) => {\n    let disposed = false;\n    const t = timeout(() => {\n        if (disposed)\n            return;\n        t.start();\n        options.whatToCall(options.fallback());\n    }, options.interval);\n    if (options.abort) {\n        options.abort.addEventListener(`abort`, _ => {\n            disposed = true;\n            t.cancel();\n        });\n    }\n    t.start();\n    return (args) => {\n        if (disposed)\n            throw new Error(`AbortSignal has been fired`);\n        t.start();\n        options.whatToCall(args);\n    };\n};\n","import { resolve, resolveSync } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat(produce, opts) {\n    const signal = opts.signal ?? undefined;\n    const delayWhen = opts.delayWhen ?? `before`;\n    const count = opts.count ?? undefined;\n    const allowUndefined = opts.allowUndefined ?? false;\n    const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n    const whileFunction = opts.while;\n    let cancelled = false;\n    let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n    let started = performance.now();\n    const doDelay = async () => {\n        const elapsed = performance.now() - started;\n        if (typeof minIntervalMs !== `undefined`) {\n            sleepMs = Math.max(0, minIntervalMs - elapsed);\n        }\n        if (sleepMs) {\n            await sleep({ millis: sleepMs, signal });\n        }\n        started = performance.now();\n        if (signal?.aborted)\n            throw new Error(`Signal aborted ${signal.reason}`);\n    };\n    if (Array.isArray(produce))\n        produce = produce.values();\n    if (opts.onStart)\n        opts.onStart();\n    let errored = true;\n    let loopedTimes = 0;\n    try {\n        while (!cancelled) {\n            loopedTimes++;\n            if (delayWhen === `before` || delayWhen === `both`)\n                await doDelay();\n            const result = await resolve(produce);\n            if (typeof result === `undefined` && !allowUndefined) {\n                cancelled = true;\n            }\n            else {\n                yield result;\n                if (delayWhen === `after` || delayWhen === `both`)\n                    await doDelay();\n                if (count !== undefined && loopedTimes >= count)\n                    cancelled = true;\n            }\n            if (whileFunction) {\n                if (!whileFunction(loopedTimes)) {\n                    cancelled = true;\n                }\n            }\n        }\n        errored = false;\n    }\n    finally {\n        cancelled = true;\n        if (opts.onComplete)\n            opts.onComplete(errored);\n    }\n}\n;\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync(produce, opts) {\n    const signal = opts.signal ?? undefined;\n    const count = opts.count ?? undefined;\n    const allowUndefined = opts.allowUndefined ?? false;\n    let cancelled = false;\n    if (Array.isArray(produce))\n        produce = produce.values();\n    if (opts.onStart)\n        opts.onStart();\n    let errored = true;\n    let loopedTimes = 0;\n    try {\n        while (!cancelled) {\n            loopedTimes++;\n            const result = resolveSync(produce);\n            if (typeof result === `undefined` && !allowUndefined) {\n                cancelled = true;\n            }\n            else {\n                yield result;\n                if (count !== undefined && loopedTimes >= count)\n                    cancelled = true;\n                if (signal?.aborted)\n                    cancelled = true;\n            }\n        }\n        errored = false;\n    }\n    finally {\n        cancelled = true;\n        if (opts.onComplete)\n            opts.onComplete(errored);\n    }\n}\n;\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { continuously } from \"@ixfx/core\";\nimport { SimpleEventEmitter } from \"@ixfx/events\";\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n *\n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n *\n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n *\n *\n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id;\n *  }\n * });\n * ```\n *\n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id;\n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n *\n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport class RequestResponseMatch extends SimpleEventEmitter {\n    timeoutMs;\n    whenUnmatchedResponse;\n    keyRequest;\n    keyResponse;\n    #outgoing = new Map();\n    #maintainLoop;\n    constructor(options = {}) {\n        super();\n        if (typeof window === `undefined`) {\n            globalThis.window = {\n                setTimeout: setTimeout,\n                clearTimeout: clearTimeout\n            };\n        }\n        this.timeoutMs = options.timeoutMs ?? 1000;\n        this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;\n        this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);\n        if (options.key) {\n            if (options.keyRequest)\n                throw new Error(`Cannot set 'keyRequest' when 'key' is set `);\n            if (options.keyResponse)\n                throw new Error(`Cannot set 'keyResponse' when 'key' is set `);\n            this.keyRequest = options.key;\n            this.keyResponse = options.key;\n        }\n        else {\n            if (!options.keyRequest || !options.keyResponse) {\n                throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);\n            }\n            this.keyRequest = options.keyRequest;\n            this.keyResponse = options.keyResponse;\n        }\n    }\n    #maintain() {\n        const values = [...this.#outgoing.values()];\n        const now = Date.now();\n        for (const v of values) {\n            if (v.expiresAt <= now) {\n                if (v.promiseReject) {\n                    v.promiseReject(`Request timeout`);\n                }\n                const callback = v.callback;\n                if (callback) {\n                    setTimeout(() => {\n                        callback(true, `Request timeout`);\n                    }, 1);\n                }\n                this.fireEvent(`completed`, { request: v.req, response: `Request timeout`, success: false });\n                this.#outgoing.delete(v.id);\n            }\n        }\n        this.debugDump();\n        return this.#outgoing.size > 0;\n    }\n    debugDump() {\n        const values = [...this.#outgoing.values()];\n        const now = Date.now();\n        for (const v of values) {\n            const expire = now - v.expiresAt;\n            console.log(`${v.id} Expires in: ${Math.floor(expire / 1000).toString()}s`);\n        }\n    }\n    /**\n     * Makes a request.\n     * If `callback` is set, it's equivalent to calling `requestCallback`.\n     * If `callback` is not set, a promise is returned\n     * @param request\n     * @param callback\n     * @returns\n     */\n    request(request, callback) {\n        if (callback !== undefined) {\n            this.#requestCallback(request, callback);\n            return;\n        }\n        return this.#requestAwait(request);\n    }\n    /**\n     * Make a request and don't wait for the outcome.\n     * @param request\n     */\n    requestAndForget(request) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const r = {\n            expiresAt: Date.now() + this.timeoutMs,\n            id,\n            req: request\n        };\n        this.#outgoing.set(id, r);\n        this.#maintainLoop.start();\n    }\n    /**\n     * Make a request, returning a Promise for the outcome.\n     * Errors will throw an exception.\n     * @param request\n     * @returns\n     */\n    #requestAwait(request) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const p = new Promise((resolve, reject) => {\n            const r = {\n                expiresAt: Date.now() + this.timeoutMs,\n                id,\n                req: request,\n                promiseResolve: resolve,\n                promiseReject: reject\n            };\n            this.#outgoing.set(id, r);\n            this.#maintainLoop.start();\n        });\n        return p;\n    }\n    /**\n     * Make a request, and get notified of outcome with a callback\n     * @param request\n     * @param callback\n     */\n    #requestCallback(request, callback) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const r = {\n            expiresAt: Date.now() + this.timeoutMs,\n            id,\n            req: request,\n            callback\n        };\n        this.#outgoing.set(id, r);\n        this.#maintainLoop.start();\n    }\n    /**\n     * Response has been received\n     * @param response Response\n     * @returns _True_ if response matched a request\n     */\n    response(response, keepAlive) {\n        const id = this.keyResponse(response);\n        const request = this.#outgoing.get(id);\n        if (!request) {\n            if (this.whenUnmatchedResponse === `throw`)\n                throw new Error(`Unmatched response with id: '${id}'`, { cause: response });\n            // otherwise ignore\n            return false;\n        }\n        if (keepAlive) {\n            // Continue life of request\n            request.expiresAt = Date.now() + this.timeoutMs;\n        }\n        else {\n            this.#outgoing.delete(id);\n        }\n        if (request.promiseResolve) {\n            request.promiseResolve(response);\n        }\n        if (request.callback) {\n            request.callback(false, response);\n        }\n        this.fireEvent(`match`, { request: request.req, response: response });\n        if (!keepAlive) {\n            this.fireEvent(`completed`, { request: request.req, response: response, success: true });\n        }\n        return true;\n    }\n}\n","import { elapsedSince, sleep } from '@ixfx/core';\nimport { resolveLogOption } from '@ixfx/debug';\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { getErrorMessage } from '@ixfx/debug';\nimport { elapsedToHumanString } from '@ixfx/core';\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n *\n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n *\n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n *\n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n *\n * @param options\n * @returns\n */\nexport function* backoffGenerator(options = {}) {\n    const startAt = options.startAt ?? 1;\n    let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n    const limitValue = options.limitValue;\n    const power = options.power ?? 1.1;\n    let value = startAt;\n    resultThrow(integerTest(limitAttempts, `aboveZero`, `limitAttempts`), numberTest(startAt, ``, `startAt`), numberTest(limitAttempts, ``, `limitAttempts`), () => (limitValue !== undefined) ? numberTest(limitValue, ``, `limitValue`) : undefined, numberTest(power, ``, `power`));\n    while (limitAttempts > 0) {\n        // Value has climbed to the limit\n        if (limitValue && value >= limitValue)\n            return;\n        limitAttempts--;\n        yield value;\n        // Increase value for next iteration\n        value += Math.pow(value, power);\n    }\n}\n/**\n * Keeps calling `callback` until it returns something other than _undefined_.\n * There is an exponentially-increasing delay between each retry attempt.\n *\n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport const retryFunction = (callback, options = {}) => {\n    const task = {\n        async probe() {\n            try {\n                const v = await callback();\n                if (v === undefined)\n                    return { value: options.taskValueFallback, error: `Fallback`, success: false };\n                return { value: v, success: true };\n            }\n            catch (error) {\n                return { success: false, error: error };\n            }\n        },\n    };\n    return retryTask(task, options);\n};\n/**\n * Keeps trying to run `task`.\n *\n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *\n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n *\n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task\n * @param opts\n * @returns\n */\nexport const retryTask = async (task, opts = {}) => {\n    const signal = opts.abort;\n    const log = resolveLogOption(opts.log);\n    const predelayMs = opts.predelayMs ?? 0;\n    const startedAt = elapsedSince();\n    let attempts = 0;\n    const initialValue = opts.startAt ?? 1000;\n    const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n    const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n    if (initialValue <= 0)\n        throw new Error(`Param 'initialValue' must be above zero`);\n    if (predelayMs > 0) {\n        try {\n            await sleep({ millis: predelayMs, signal: signal });\n        }\n        catch (error) {\n            // Could happen due to abort signal\n            return {\n                success: false,\n                attempts,\n                value: opts.taskValueFallback,\n                elapsed: startedAt(),\n                message: getErrorMessage(error),\n            };\n        }\n    }\n    for (const t of backoffGen) {\n        attempts++;\n        // Run task\n        const result = await task.probe(attempts);\n        if (result.success) {\n            return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n        }\n        log({\n            msg: `retry attempts: ${attempts.toString()} t: ${elapsedToHumanString(t)}`,\n        });\n        // Did not succeed.\n        if (attempts >= limitAttempts) {\n            break; // Out of attempts, no point sleeping again\n        }\n        // Sleep\n        try {\n            await sleep({ millis: t, signal });\n        }\n        catch (error) {\n            // Eg if abort signal fires\n            return {\n                success: false,\n                attempts,\n                value: opts.taskValueFallback,\n                message: getErrorMessage(error),\n                elapsed: startedAt(),\n            };\n        }\n    }\n    return {\n        message: `Giving up after ${attempts.toString()} attempts.`,\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n    };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun) => {\n    let run = false;\n    let success = false;\n    return () => {\n        if (run)\n            return success;\n        run = true;\n        success = onRun();\n        return success;\n    };\n};\n","/**\n * Simple synchronisation. Supports only a single signal/waiter.\n * Expects one or more calls to .signal() for .forSignal() to resolve\n *\n * ```js\n * const sw = new SyncWait();\n * obj.addEventListener(`click`, () => {\n *  sw.signal();\n * });\n *\n * // Wait until click event\n * await sw.forSignal();\n * ```\n *\n * `forSignal` can also take a maximum time to wait. If the\n * time elapses, an exception is thrown.\n *\n * {@link didSignal} returns _true_/_false_ if signal happened rather\n * than throwing an exception.\n *\n */\nexport class SyncWait {\n    #resolve;\n    #reject;\n    #promise;\n    signal() {\n        if (this.#resolve) {\n            this.#resolve();\n            this.#resolve = undefined;\n        }\n        this.#promise = Promise.resolve();\n    }\n    /**\n     * Throw away any previous signalled state.\n     * This will cause any currently waiters to throw\n     */\n    flush() {\n        if (this.#reject) {\n            this.#reject(`Flushed`);\n            this.#reject = undefined;\n        }\n        this.#resolve = undefined;\n        this.#promise = undefined;\n    }\n    #initPromise() {\n        const p = new Promise((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n        this.#promise = p;\n        return p;\n    }\n    /**\n     * Call with `await` to wait until .signal() happens.\n     * If a wait period is specified, an exception is thrown if signal does not happen within this time.\n     * @param maximumWaitMs\n     */\n    async forSignal(maximumWaitMs) {\n        let p = this.#promise;\n        p ??= this.#initPromise();\n        if (maximumWaitMs) {\n            const reject = this.#reject;\n            setTimeout(() => {\n                if (reject) {\n                    reject(`Timeout elapsed ${maximumWaitMs.toString()}`);\n                }\n            }, maximumWaitMs);\n        }\n        await p;\n        this.#promise = undefined;\n        this.#resolve = undefined;\n        this.#reject = undefined;\n    }\n    /**\n     * An alternative to {@link forSignal}, returning _true_\n     * if signalled, or _false_ if wait period was exceeded\n     *\n     * ```js\n     * const s = await sw.didSignal(5000);\n     * ```\n     * @param maximumWaitMs\n     * @returns\n     */\n    async didSignal(maximumWaitMs) {\n        try {\n            await this.forSignal(maximumWaitMs);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { Queues } from '@ixfx/collections';\nimport { continuously } from '@ixfx/core';\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n *\n * The TaskQueueMutable is shared across your code,\n * so you don't create it directly. Rather, use:\n *\n * ```js\n * const queue = TaskQueueMutable.shared;\n * ```\n *\n * @example Usage\n * ```js\n * const queue = TaskQueueMutable.shared;\n * q.enqueue(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n *\n * You can listen to events from the TaskQueue:\n * ```js\n * TaskQueueMutable.shared.addEventListener(`started`, () => {\n *  // Queue was empty, now started processing\n * });\n *\n * TaskQueueMutable.shared.addEventListener(`empty`, () => {\n *  // Queue has finished processing all items\n * });\n * ```\n */\nexport class TaskQueueMutable extends SimpleEventEmitter {\n    static shared = new TaskQueueMutable();\n    _loop;\n    _queue;\n    constructor() {\n        super();\n        this._queue = Queues.mutable();\n        this._loop = continuously(() => {\n            return this.processQueue();\n        }, 100);\n    }\n    /**\n     * Adds a task. This triggers processing loop if not already started.\n     *\n     * ```js\n     * queue.add(async () => {\n     *  await sleep(1000);\n     * });\n     * ```\n     * @param task Task to run\n     */\n    enqueue(task) {\n        const length = this._queue.enqueue(task);\n        if (this._loop.runState === `idle`) {\n            this.fireEvent(`started`, {});\n            this._loop.start();\n        }\n        return length;\n    }\n    dequeue() {\n        return this._queue.dequeue();\n    }\n    async processQueue() {\n        const task = this._queue.dequeue();\n        if (task === undefined) {\n            this.fireEvent(`empty`, {});\n            return false;\n        }\n        try {\n            await task();\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }\n    /**\n     * Clears all tasks, and stops any scheduled processing.\n     * Currently running tasks will continue.\n     * @returns\n     */\n    clear() {\n        if (this._queue.length === 0)\n            return;\n        this._queue.clear();\n        this._loop.cancel();\n        this.fireEvent(`empty`, {});\n    }\n    /**\n    * Returns true if queue is empty\n    */\n    get isEmpty() {\n        return this._queue.isEmpty;\n    }\n    /**\n     * Number of items in queue\n     */\n    get length() {\n        return this._queue.length;\n    }\n}\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (callback, intervalMinMs) => {\n    let trigger = 0;\n    return async (...args) => {\n        const elapsed = performance.now() - trigger;\n        if (elapsed >= intervalMinMs) {\n            const r = callback(elapsed, ...args);\n            if (typeof r === `object`)\n                await r;\n            trigger = performance.now();\n        }\n    };\n};\n","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n *\n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n *\n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed) {\n    const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n    return () => t.isDone;\n}\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * const timer = Flow.ofTotal(1000);\n *\n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n *\n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(duration, opts = {}) {\n    const totalMs = intervalToMs(duration);\n    if (!totalMs)\n        throw new Error(`Param 'duration' not valid`);\n    const timerOpts = {\n        ...opts,\n        timer: elapsedMillisecondsAbsolute(),\n    };\n    let t;\n    return () => {\n        t ??= relative(totalMs, timerOpts);\n        return t.elapsed;\n    };\n}\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks, opts = {}) {\n    const timerOpts = {\n        ...opts,\n        timer: elapsedTicksAbsolute(),\n    };\n    let t;\n    return () => {\n        t ??= relative(totalTicks, timerOpts);\n        return t.elapsed;\n    };\n}\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns\n */\nexport const timerAlwaysDone = () => ({\n    elapsed: 1,\n    isDone: true,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reset() {\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    mod(amt) {\n    },\n});\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns\n */\nexport const timerNeverDone = () => ({\n    elapsed: 0,\n    isDone: false,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reset() {\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    mod() {\n    }\n});\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n *\n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n *\n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n *\n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (total, options = {}) => {\n    if (!Number.isFinite(total)) {\n        return timerAlwaysDone();\n    }\n    else if (Number.isNaN(total)) {\n        return timerNeverDone();\n    }\n    const clampValue = options.clampValue ?? false;\n    const wrapValue = options.wrapValue ?? false;\n    if (clampValue && wrapValue)\n        throw new Error(`clampValue and wrapValue cannot both be enabled`);\n    let modulationAmount = 1;\n    // Create and starts timer\n    const timer = options.timer ?? elapsedMillisecondsAbsolute();\n    // Keep track of value to avoid over-advancing the tick counter\n    let lastValue = 0;\n    const computeElapsed = (value) => {\n        lastValue = value;\n        let v = value / (total * modulationAmount);\n        if (clampValue)\n            v = clamp(v);\n        else if (wrapValue && v >= 1)\n            v = v % 1;\n        return v;\n    };\n    return {\n        mod(amt) {\n            modulationAmount = amt;\n        },\n        get isDone() {\n            //const tmp = computeElapsed();\n            //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n            return computeElapsed(lastValue) >= 1;\n        },\n        get elapsed() {\n            return computeElapsed(timer.elapsed);\n        },\n        reset: () => {\n            timer.reset();\n        }\n    };\n};\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (frequency, options = {}) => {\n    const timer = options.timer ?? elapsedMillisecondsAbsolute();\n    const cyclesPerSecond = frequency / 1000;\n    let modulationAmount = 1;\n    const computeElapsed = () => {\n        // Get position in a cycle\n        const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n        // Get fractional part\n        const f = v - Math.floor(v);\n        if (f < 0) {\n            throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v} f: ${f}`);\n        }\n        if (f > 1) {\n            throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v} f: ${f}`);\n        }\n        return f;\n    };\n    return {\n        mod: (amt) => {\n            modulationAmount = amt;\n        },\n        reset: () => {\n            timer.reset();\n        },\n        get isDone() {\n            return computeElapsed() >= 1;\n        },\n        get elapsed() {\n            return computeElapsed();\n        },\n    };\n};\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = () => {\n    let start = performance.now();\n    return {\n        /**\n         * Reset timer\n         */\n        reset: () => {\n            start = performance.now();\n        },\n        /**\n         * Returns elapsed time since start\n         */\n        get elapsed() {\n            return performance.now() - start;\n        }\n    };\n};\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n *\n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = () => {\n    let start = 0;\n    return {\n        /**\n         * Reset ticks to 0. The next call to `elapsed` will return 1.\n         */\n        reset: () => {\n            start = 0;\n        },\n        /**\n         * Get current ticks without incrementing.\n         */\n        get peek() {\n            return start;\n        },\n        /**\n         * Returns the number of elapsed ticks as well as\n         * incrementing the tick count.\n         *\n         * Minimum is 1\n         *\n         * Use {@link peek} to get the current ticks without incrementing.\n         */\n        get elapsed() {\n            return ++start;\n        }\n    };\n};\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n *\n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n *\n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n *\n * @param fn\n * @param timer\n * @returns\n */\nexport const timerWithFunction = (fn, timer) => {\n    if (typeof fn !== `function`)\n        throw new Error(`Param 'fn' should be a function. Got: ${typeof fn}`);\n    let startCount = 1;\n    return {\n        get elapsed() {\n            return timer.elapsed;\n        },\n        get isDone() {\n            return timer.isDone;\n        },\n        get runState() {\n            if (timer.isDone)\n                return `idle`;\n            return `scheduled`;\n        },\n        /**\n         * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n         */\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCount;\n        },\n        compute: () => {\n            const elapsed = timer.elapsed;\n            return fn(elapsed);\n        },\n        reset: () => {\n            timer.reset();\n            startCount++;\n        },\n    };\n};\n","import { intervalToMs } from \"@ixfx/core\";\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `interval` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. Its minimum value will be `interval`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `interval` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param interval Maximum age of cached result\n * @param updateFail `slow` by default\n * @typeParam V - Return type of `fn`\n * @returns Value\n */\nexport const updateOutdated = (fn, interval, updateFail = `slow`) => {\n    let lastRun = 0;\n    let lastValue;\n    let intervalMsCurrent = intervalToMs(interval, 1000);\n    return () => \n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    new Promise(async (resolve, reject) => {\n        const elapsed = performance.now() - lastRun;\n        if (lastValue === undefined || elapsed > intervalMsCurrent) {\n            try {\n                lastRun = performance.now();\n                lastValue = await fn(elapsed);\n                intervalMsCurrent = intervalToMs(interval, 1000);\n            }\n            catch (error) {\n                if (updateFail === `fast`) {\n                    lastValue = undefined;\n                    lastRun = 0;\n                }\n                else if (updateFail === `backoff`) {\n                    intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n                }\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(error);\n                return;\n            }\n        }\n        resolve(lastValue);\n    });\n};\n","import { promiseWithResolvers } from \"./promise-with-resolvers.js\";\n/**\n * Queue of a single item, only once, allows for simple synchronisation.\n *\n * It has a 'first write wins' behaviour\n *\n * ```js\n * const q = new WaitForValue(); // or singleItem();\n *\n * // In some part of the code add a value\n * const value = q.add(`some-val`);\n *\n * // Somewhere else, wait for value\n * await q.get(value);\n * ```\n *\n * It is not possible to `add` a second item (an exception will throw), however\n * it is possible to call `get` as many times as you need.\n *\n * The `.isUsed` property allows you to to check if a value\n * has been already added to the queue.\n *\n * Based on: https://2ality.com/2024/05/proposal-promise-with-resolvers.html\n */\nexport class WaitForValue {\n    #promise;\n    #resolve;\n    #written = false;\n    constructor() {\n        const { promise, resolve } = promiseWithResolvers();\n        this.#promise = promise;\n        this.#resolve = resolve;\n    }\n    /**\n     * Gets the promise\n     * ```js\n     * const wv = new WaitForValue();\n     *\n     * await wv.get();\n     * ```\n     * @returns\n     */\n    get() {\n        return this.#promise;\n    }\n    /**\n     * Adds a value, triggering promise resolution.\n     *\n     * Throws an exception if queue has already been used. Use {@link isUsed} to check.\n     * @param value\n     */\n    add(value) {\n        if (this.#written)\n            throw new Error(`QueueSingleUse has already been used`);\n        this.#written = true;\n        this.#resolve(value);\n    }\n    /**\n     * Returns _true_ if a value has been added\n     * and therefore no more values can be written\n     */\n    get isUsed() {\n        return this.#written;\n    }\n}\n/**\n * {@inheritDoc WaitForValue}\n */\nexport const singleItem = () => new WaitForValue();\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n *\n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n *\n * ```js\n * waitFor(1000,\n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n *\n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n *\n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n *\n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (timeoutMs, onAborted, onComplete) => {\n    let t;\n    let success = false;\n    const done = (error) => {\n        if (t !== undefined) {\n            window.clearTimeout(t);\n            t = undefined;\n        }\n        if (error) {\n            onAborted(error);\n        }\n        else {\n            success = true;\n        }\n        if (onComplete !== undefined)\n            onComplete(success);\n    };\n    t = globalThis.setTimeout(() => {\n        t = undefined;\n        try {\n            onAborted(`Timeout after ${timeoutMs}ms`);\n        }\n        finally {\n            if (onComplete !== undefined)\n                onComplete(success);\n        }\n    }, timeoutMs);\n    return done;\n};\n","import { unique } from '@ixfx/arrays';\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = (toClone) => {\n    return Object.freeze({\n        value: toClone.value,\n        visited: [...toClone.visited],\n        machine: toClone.machine,\n    });\n};\n/**\n * Initialises a state machine. [Read more in the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n *\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n *\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n *\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n *\n * StateMachine.isDone(sm); // false\n * StateMachine.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = (stateMachine, initialState) => {\n    const [machine, machineValidationError] = validateMachine(stateMachine);\n    if (!machine)\n        throw new Error(machineValidationError);\n    const state = \n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState) ?? Object.keys(machine.states)[0];\n    if (typeof machine.states[state] === `undefined`) {\n        throw new TypeError(`Initial state ('${state}') not found`);\n    }\n    // Normalise states\n    const transitions = validateAndNormaliseTransitions(machine.states);\n    if (transitions === undefined) {\n        throw new Error(`Could not normalise transitions`);\n    }\n    return Object.freeze({\n        value: state,\n        visited: [],\n        machine: Object.freeze(Object.fromEntries(transitions)),\n    });\n};\nexport const reset = (sm) => {\n    return init(sm.machine);\n};\nexport const validateMachine = (smOrTransitions) => {\n    if (typeof smOrTransitions === `undefined`) {\n        return [undefined, `Parameter undefined`];\n    }\n    if (smOrTransitions === null) {\n        return [undefined, `Parameter null`];\n    }\n    if (`states` in smOrTransitions) {\n        // Assume Machine type\n        return [smOrTransitions, ``];\n    }\n    if (typeof smOrTransitions === `object`) {\n        return [\n            {\n                states: smOrTransitions,\n            },\n            ``,\n        ];\n    }\n    return [\n        undefined,\n        `Unexpected type: ${typeof smOrTransitions}. Expected object`,\n    ];\n};\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = (sm) => {\n    return possible(sm).length === 0;\n};\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = (sm) => {\n    // Validate current state\n    validateMachineState(sm);\n    // get list of possible targets\n    const fromS = sm.machine[sm.value];\n    if (fromS.length === 1 && fromS[0].state === null)\n        return [];\n    return fromS;\n};\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = (sm) => {\n    const targets = possibleTargets(sm);\n    return targets.map((v) => v.state);\n};\nexport const normaliseTargets = (targets) => {\n    const normaliseSingleTarget = (target) => {\n        // Terminal target\n        if (target === null)\n            return { state: null };\n        // String is the target state\n        if (typeof target === `string`) {\n            return {\n                state: target,\n            };\n        }\n        else if (typeof target === `object` && `state` in target) {\n            const targetState = target.state;\n            if (typeof targetState !== `string`) {\n                throw new TypeError(`Target 'state' field is not a string. Got: ${typeof targetState}`);\n            }\n            if (`preconditions` in target) {\n                return {\n                    state: targetState,\n                    preconditions: target.preconditions,\n                };\n            }\n            return { state: targetState };\n        }\n        else {\n            throw new Error(`Unexpected type: ${typeof target}. Expected string or object with 'state' field.`);\n        }\n    };\n    // Array of targets (either strings or objects)\n    if (Array.isArray(targets)) {\n        let containsNull = false;\n        const mapResults = targets.map((t) => {\n            const r = normaliseSingleTarget(t);\n            if (!r)\n                throw new Error(`Invalid target`);\n            containsNull = containsNull || r.state === null;\n            return r;\n        });\n        if (containsNull && mapResults.length > 1) {\n            throw new Error(`Cannot have null as an possible state`);\n        }\n        return mapResults;\n    }\n    else {\n        const target = normaliseSingleTarget(targets);\n        if (!target)\n            return;\n        return [target];\n    }\n};\nconst validateAndNormaliseTransitions = (d) => {\n    const returnMap = new Map();\n    // 1. Index top-level states\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        if (typeof topLevelState === `undefined`) {\n            throw new TypeError(`Top-level undefined state`);\n        }\n        if (typeof topLevelTargets === `undefined`) {\n            throw new TypeError(`Undefined target state for ${topLevelState}`);\n        }\n        if (returnMap.has(topLevelState)) {\n            throw new Error(`State defined twice: ${topLevelState}`);\n        }\n        if (topLevelState.includes(` `)) {\n            throw new Error(`State names cannot contain spaces`);\n        }\n        returnMap.set(topLevelState, []);\n    }\n    // 2. Normalise target\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        const targets = normaliseTargets(topLevelTargets);\n        if (targets === undefined)\n            throw new Error(`Could not normalise target`);\n        if (targets !== null) {\n            // Check that they all exist as top-level states\n            const seenStates = new Set();\n            for (const target of targets) {\n                if (seenStates.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' already exists for '${topLevelState}'`);\n                }\n                seenStates.add(target.state);\n                if (target.state === null)\n                    continue;\n                if (!returnMap.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' is not defined as a top-level state. Defined under: '${topLevelState}'`);\n                }\n            }\n            returnMap.set(topLevelState, targets);\n        }\n    }\n    return returnMap;\n};\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = (state) => {\n    if (typeof state === `undefined`) {\n        throw new TypeError(`Param 'state' is undefined`);\n    }\n    if (typeof state.value !== `string`) {\n        throw new TypeError(`Existing state is not a string`);\n    }\n};\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n *\n * @example Attempts to transition to 'name-of-state'\n * ```js\n * const newState = StateMachine.to(currentState, `name-of-state`);\n * ```\n *\n * Note that 'currentState' is not changed.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = (sm, toState) => {\n    validateMachineState(sm); // throws if not OK\n    validateTransition(sm, toState); // throws if not OK\n    return Object.freeze({\n        value: toState,\n        machine: sm.machine,\n        visited: unique([sm.visited, [sm.value]]),\n    });\n};\nexport const next = (sm) => {\n    //validateMachineState(sm);\n    const first = possibleTargets(sm).at(0);\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (!first || first.state === null) {\n        throw new Error(`Not possible to move to a next state from '${sm.value}`);\n    }\n    return to(sm, first.state);\n};\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = (sm, toState) => {\n    try {\n        validateTransition(sm, toState);\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nexport const validateTransition = (sm, toState) => {\n    if (toState === null)\n        throw new Error(`Cannot transition to null state`);\n    if (typeof toState === `undefined`) {\n        throw new Error(`Cannot transition to undefined state`);\n    }\n    if (typeof toState !== `string`) {\n        throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof toState}`);\n    }\n    //const toS = sm.machine[toState];\n    //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n    const p = possible(sm);\n    if (p.length === 0)\n        throw new Error(`Machine is in terminal state`);\n    if (!p.includes(toState)) {\n        throw new Error(`Target state '${toState}' not available at current state '${sm.value}'. Possible states: ${p.join(`, `)}`);\n    }\n};\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n *\n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length <= 2)\n        throw new Error(`Expects at least two states`);\n    for (let index = 0; index < states.length; index++) {\n        const s = states[index];\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = (index === states.length - 1) ? null : states[index + 1];\n    }\n    return t;\n};\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n *\n * See also {@link fromList}.\n *\n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length < 2)\n        throw new Error(`Expects at least two states`);\n    for (const [index, s] of states.entries()) {\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = [];\n    }\n    for (let index = 0; index < states.length; index++) {\n        const v = t[states[index]];\n        if (index === states.length - 1) {\n            if (states.length > 1) {\n                v.push(states[index - 1]);\n            }\n            else {\n                t[states[index]] = null;\n            }\n        }\n        else {\n            v.push(states[index + 1]);\n            if (index > 0)\n                v.push(states[index - 1]);\n        }\n    }\n    return t;\n};\n","import * as Execute from '../execute.js';\nimport {} from './types.js';\nimport { defaultComparer } from '@ixfx/core';\nimport { randomElement } from '@ixfx/arrays';\nimport * as Debug from '@ixfx/debug';\nimport { init as machineInit, reset as machineReset, next as machineNext, to as machineTo } from './state-machine.js';\n// export type Prerequisite<V extends StateMachine.Transitions> =\n//   | readonly StateMachine.StateNames<V>[]\n//   | ((\n//       potentialState: StateMachine.StateNames<V>,\n//       state: StateMachine.MachineState<V>\n//     ) => boolean);\n// export type StatePrerequisites<V extends StateMachine.Transitions> = {\n//   readonly states:\n//     | readonly StateMachine.StateNames<V>[]\n//     | StateMachine.StateNames<V>;\n//   readonly condition?: Prerequisite<V>;\n// };\n// async function run<V extends StateMachine.Transitions>(\n//   machine: StateMachine.Machine<V>,\n//   handlers: readonly StatesHandler<V>[]\n// );\n/**\n * Drives a state machine.\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/driver/)\n *\n * Uses a 'handlers' structure to determine when to change\n * state and actions to take.\n *\n * The structure is a set of logical conditions: if we're in\n * this state, then move to this other state etc.\n *\n * ```js\n * const handlers = [\n *  {\n *    // If we're in the 'sleeping' state, move to next state\n *    if: 'sleeping',\n *    then: { next: true }\n *  },\n *  {\n *    // If we're in the 'waking' state, randomly either go to 'resting' or 'sleeping' state\n *    if: 'waking',\n *    then: [\n *      () => {\n *        if (Math.random() > 0.5) {\n *          return { next: 'resting' }\n *        } else {\n *          return { next: 'sleeping' }\n *        }\n *      }\n *    ]\n *   }\n * ];\n * ```\n *\n * Set up the driver, and call `run()` when you want to get\n * the machine to change state or take action:\n *\n * ```js\n * const driver = await StateMachine.driver(states, handlers);\n * setInterval(async () => {\n *  await driver.run(); // Note use of 'await' again\n * }, 1000);\n * ```\n *\n * Essentially, the 'handlers' structure gets run through each time `run()`\n * is called.\n *\n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\nexport async function driver(machine, handlersOrOpts) {\n    const opts = Array.isArray(handlersOrOpts)\n        ? {\n            handlers: handlersOrOpts,\n        }\n        : handlersOrOpts;\n    const debug = Debug.resolveLogOption(opts.debug, {\n        category: `StateMachineDriver`,\n    });\n    // Index handlers by state, making sure there are not multiple\n    // handlers for a given state.\n    const byState = new Map();\n    for (const h of opts.handlers) {\n        const ifBlock = Array.isArray(h.if) ? h.if : [h.if];\n        for (const state of ifBlock) {\n            if (typeof state !== `string`) {\n                throw new TypeError(`Expected single or array of strings for the 'if' field. Got: '${typeof state}'.`);\n            }\n            if (byState.has(state)) {\n                throw new Error(`Multiple handlers defined for state '${state}'. There should be at most one.`);\n            }\n            byState.set(state, h);\n        }\n    }\n    const runOpts = {\n        // Rank results by score\n        rank: (a, b) => {\n            return defaultComparer(a.score ?? 0, b.score ?? 0);\n        },\n        shuffle: opts.shuffleHandlers ?? false,\n    };\n    let sm = machineInit(machine);\n    // Check that all 'if' states are actually defined on machine\n    for (const [ifState] of byState) {\n        // Check if state is defined\n        if (typeof sm.machine[ifState] === `undefined` &&\n            ifState !== `__fallback`) {\n            throw new Error(`StateMachineDriver handler references a state ('${ifState}') which is not defined on the machine. Therefore this handler will never run.'`);\n        }\n    }\n    const run = async () => {\n        debug(`Run. State: ${sm.value}`);\n        const state = sm.value;\n        let handler = byState.get(state);\n        if (handler === undefined) {\n            debug(`  No handler for state '${state}', trying __fallback`);\n            // Is there a fallback?\n            handler = byState.get(`__fallback`);\n        }\n        if (handler === undefined) {\n            debug(`  No __fallback handler`);\n            return;\n        }\n        // If the `first` option is given, stop executing fns as soon as we get\n        // a valid result.\n        const runOptionsForHandler = handler.resultChoice === `first`\n            ? {\n                ...runOpts,\n                stop: (latest) => {\n                    if (!latest)\n                        return false;\n                    if (`reset` in latest)\n                        return true;\n                    if (`next` in latest && latest.next !== undefined)\n                        return true;\n                    return false;\n                },\n            }\n            : runOpts;\n        const results = await Execute.run(handler.then, runOptionsForHandler, sm);\n        debug(`  In state '${sm.value}' results: ${results.length}. Choice: ${handler.resultChoice}`);\n        // Apply selection logic\n        //eslint-disable-next-line functional/no-let\n        let r;\n        switch (handler.resultChoice ?? `highest`) {\n            case `highest`: {\n                r = results.at(-1);\n                break;\n            }\n            case `first`: {\n                r = results[0]; // Since we break on the first result\n                break;\n            }\n            case `lowest`: {\n                r = results.at(0);\n                break;\n            }\n            case `random`: {\n                r = randomElement(results);\n                break;\n            }\n            default: {\n                throw new Error(`Unknown 'resultChoice' option: ${handler.resultChoice}. Expected highest, first, lowest or random`);\n            }\n        }\n        debug(`  Chosen result: ${JSON.stringify(r)}`);\n        // Apply result\n        if (r?.reset) {\n            sm = machineReset(sm);\n        }\n        else if (r && r.next) {\n            if (typeof r.next === `boolean`) {\n                sm = machineNext(sm);\n            }\n            else {\n                debug(JSON.stringify(results));\n                sm = machineTo(sm, r.next);\n            }\n        }\n        return sm;\n    };\n    return {\n        reset: () => {\n            sm = machineReset(sm);\n        },\n        getValue: () => sm.value,\n        run,\n        to: (state) => {\n            sm = machineTo(sm, state);\n            return sm;\n        },\n    };\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n/**\n * A state machine that fires events when state changes.\n *\n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents extends SimpleEventEmitter {\n    #sm;\n    #smInitial;\n    #debug;\n    #isDoneNeedsFiring = false;\n    #isDone = false;\n    #changedAt = elapsedInfinity();\n    /**\n     * Create a state machine with initial state, description and options\n     * @param m Machine description\n     * @param opts Options for machine (defaults to `{debug:false}`)\n     */\n    constructor(m, opts = {}) {\n        super();\n        this.#debug = opts.debug ?? false;\n        this.#sm = StateMachine.init(m, opts.initial);\n        this.#smInitial = StateMachine.cloneState(this.#sm);\n    }\n    #setIsDone(v) {\n        if (this.#isDone === v)\n            return;\n        this.#isDone = v;\n        if (v) {\n            this.#isDoneNeedsFiring = true;\n            setTimeout(() => {\n                if (!this.#isDoneNeedsFiring)\n                    return;\n                this.#isDoneNeedsFiring = false;\n                //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n                this.fireEvent(`stop`, { state: this.#sm.value });\n            }, 2);\n        }\n        else {\n            this.#isDoneNeedsFiring = false;\n        }\n    }\n    /**\n     * Return a list of possible states from current state.\n     *\n     * If list is empty, no states are possible. Otherwise lists\n     * possible states, including 'null' for terminal\n     */\n    get statesPossible() {\n        return StateMachine.possible(this.#sm);\n    }\n    /**\n     * Return a list of all defined states\n     */\n    get statesDefined() {\n        return Object.keys(this.#sm.machine);\n    }\n    /**\n     * Moves to the next state if possible. If multiple states are possible, it will use the first.\n     * If machine is finalised, no error is thrown and null is returned.\n     *\n     * @returns {(string|null)} Returns new state, or null if machine is finalised\n     */\n    next() {\n        const p = StateMachine.possible(this.#sm);\n        if (p.length === 0)\n            return null;\n        this.state = p[0];\n        return p[0];\n    }\n    /**\n     * Returns _true_ if state machine is in its final state\n     *\n     * @returns\n     */\n    get isDone() {\n        return StateMachine.isDone(this.#sm);\n    }\n    /**\n     * Resets machine to initial state\n     */\n    reset() {\n        this.#setIsDone(false);\n        this.#sm = StateMachine.cloneState(this.#smInitial);\n        this.#changedAt = elapsedSince();\n    }\n    /**\n     * Throws if it's not valid to transition to `newState`\n     * @param newState\n     * @returns\n     */\n    validateTransition(newState) {\n        StateMachine.validateTransition(this.#sm, newState);\n    }\n    /**\n     * Returns _true_ if `newState` is valid transition from current state.\n     * Use {@link validateTransition} if you want an explanation for the _false_ results.\n     * @param newState\n     * @returns\n     */\n    isValid(newState) {\n        return StateMachine.isValidTransition(this.#sm, newState);\n    }\n    /**\n     * Gets or sets state. Throws an error if an invalid transition is attempted.\n     * Use `isValid()` to check validity without changing.\n     *\n     * If `newState` is the same as current state, the request is ignored silently.\n     */\n    set state(newState) {\n        const priorState = this.#sm.value;\n        if (newState === this.#sm.value)\n            return;\n        // Try to change state\n        this.#sm = StateMachine.to(this.#sm, newState);\n        if (this.#debug) {\n            console.log(`StateMachine: ${priorState} -> ${newState}`);\n        }\n        this.#changedAt = elapsedSince();\n        setTimeout(() => {\n            this.fireEvent(`change`, { newState: newState, priorState: priorState });\n        }, 1);\n        if (StateMachine.isDone(this.#sm))\n            this.#setIsDone(true);\n    }\n    get state() {\n        return this.#sm.value;\n    }\n    /**\n     * Returns timestamp when state was last changed.\n     * See also `elapsed`\n     */\n    get changedAt() {\n        return this.#changedAt();\n    }\n    /**\n     * Returns milliseconds elapsed since last state change.\n     * See also `changedAt`\n     */\n    get elapsed() {\n        return this.#changedAt();\n    }\n}\n","export * from './driver.js';\nexport * from './state-machine.js';\nexport * from './with-events.js';\n","export * from '@ixfx/core/continuously';\nexport * from './behaviour-tree.js';\nexport * from './delay.js';\nexport * from './debounce.js';\nexport * from './dispatch-list.js';\nexport * from './every.js';\nexport * from './execute.js';\nexport * from './event-race.js';\nexport * from './moving-average.js';\nexport * from './pool.js';\nexport * from './promise-with-resolvers.js';\nexport * from './rate-minimum.js';\nexport * from './repeat.js';\nexport * from './req-resp-match.js';\nexport * from './retry.js';\nexport * from './run-once.js';\nexport * from './sync-wait.js';\nexport * from './task-queue-mutable.js';\nexport * from './throttle.js';\nexport * from './timeout.js';\nexport * from './timer.js';\nexport * from './types.js';\nexport * from './update-outdated.js';\nexport * from './wait-for-value.js';\nexport * from './wait-for.js';\nexport { sleep } from '@ixfx/core';\n/**\n * Functions for creating and driving a state machine\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n */\nexport * as StateMachine from './state-machine/index.js';\n","import {} from \"./types.js\";\n/**\n* Returns a random number from 0..weightings.length, distributed by the weighting values.\n*\n* eg: produces 0 20% of the time, 1 50% of the time, 2 30% of the time\n* ```js\n* weightedIndex([0.2, 0.5, 0.3]);\n* ```\n* @param weightings\n* @param rand\n* @returns\n*/\nexport const weightedIndex = (weightings, rand = Math.random) => {\n    const precompute = [];\n    let total = 0;\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < weightings.length; index++) {\n        total += weightings[index];\n        precompute[index] = total;\n    }\n    if (total !== 1)\n        throw new Error(`Weightings should add up to 1. Got: ${total}`);\n    return () => {\n        const v = rand();\n        // eslint-disable-next-line unicorn/no-for-loop\n        for (let index = 0; index < precompute.length; index++) {\n            if (v <= precompute[index])\n                return index;\n        }\n        throw new Error(`Bug: weightedIndex could not select index`);\n    };\n};\n","import { arrayTest, resultThrow } from \"@ixfx/guards\";\nimport { weightedIndex } from \"./weighted-index.js\";\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = (array, rand = Math.random) => Math.floor(rand() * array.length);\n/**\n * Plucks a random value from an array, optionally mutating\n * the original array.\n *\n * @example Get a random element without modifying array\n * ```js\n * const { value, remainder } = randomPluck(inputArray);\n * ```\n *\n * @example Get a random element, removing it from original array\n * ```js\n * const value = randomPluck(inputArray, { mutate: true });\n * ```\n *\n * If the input array is empty, _undefined_ is returned as the value.\n * @typeParam V - Type of items in array\n * @param array Array to pluck item from\n * @param options Options. By default { mutate: false, source: Math.random }\n * @param rand Random generator. `Math.random` by default.\n *\n */\nexport function randomPluck(array, options = {}) {\n    if (typeof array === `undefined`)\n        throw new Error(`Param 'array' is undefined`);\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array`);\n    const mutate = options.mutate ?? false;\n    const rand = options.source ?? Math.random;\n    if (array.length === 0) {\n        if (mutate)\n            return undefined;\n        return { value: undefined, remainder: [] };\n    }\n    const index = randomIndex(array, rand);\n    if (mutate) {\n        // Return bare value\n        const v = array[index];\n        array.splice(index, 1);\n        return v;\n    }\n    else {\n        // Copy array, remove item from that\n        const inputCopy = [...array];\n        inputCopy.splice(index, 1);\n        return {\n            value: array[index],\n            remainder: inputCopy,\n        };\n    }\n}\n;\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = (array, rand = Math.random) => {\n    resultThrow(arrayTest(array, `array`));\n    return array[Math.floor(rand() * array.length)];\n};\n/**\n * Selects a random array index, biased by the provided `weightings`.\n *\n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ]\n * ```\n * @param array\n * @param weightings\n * @param randomSource\n */\nexport const randomElementWeightedSource = (array, weightings, randomSource = Math.random) => {\n    if (array.length !== weightings.length)\n        throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n    const r = weightedIndex(weightings, randomSource);\n    return () => {\n        const index = r();\n        return array[index];\n    };\n};\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = (dataToShuffle, rand = Math.random) => {\n    const array = [...dataToShuffle];\n    for (let index = array.length - 1; index > 0; index--) {\n        const index_ = Math.floor(rand() * (index + 1));\n        [array[index], array[index_]] = [array[index_], array[index]];\n    }\n    return array;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Chance of returning `a` or `b`, based on threshold `p`.\n *\n * `p` sets the threshold for picking `b`. The higher the value (up to 1),\n * the more likely `b` will be picked.\n *\n * ```js\n * // 50% of the time it will return 100, 50% 110\n * chance(0.5, 100, 110);\n * // 90% of the time it will yield 110, 10% it will yield 100\n * chance(0.9, 100, 110);\n * ```\n *\n * @param p Threshold to choose option B (value or function)\n * @param a Value or function for option A\n * @param b Value or function for option B\n * @param randomSource Source of random numbers\n * @returns\n */\nexport const chance = (p, a, b, randomSource) => {\n    const source = randomSource ?? Math.random;\n    const resolve = (x) => {\n        if (typeof x === `function`)\n            return x();\n        return x;\n    };\n    const pp = resolve(p);\n    resultThrow(numberTest(pp, `percentage`, `p`));\n    if (source() <= pp) {\n        return resolve(b);\n    }\n    else {\n        return resolve(a);\n    }\n};\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport {} from \"./types.js\";\n/**\n * Source for random bipolar values\n * ```js\n * const r = bipolarSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n *\n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * bipolarSource({ max: 0.5 });\n * ```\n *\n *\n * @param maxOrOptions Maximum value (number) or options for random generation\n * @returns\n */\nexport const bipolarSource = (maxOrOptions) => {\n    const source = floatSource(maxOrOptions);\n    return () => (source() * 2) - 1;\n};\n/**\n * Returns a random bipolar value\n * ```js\n * const r = bipolar(); // -1...1 random\n * ```\n *\n * Options can be provided, eg.\n * ```js\n * bipolar({ max: 0.5 }); // -0.5..0.5 random\n * ```\n *\n * Use {@link bipolarSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions\n * @returns\n */\nexport const bipolar = (maxOrOptions) => {\n    const source = bipolarSource(maxOrOptions);\n    return source();\n};\n/**\n * Returns a function that produces random float values.\n * Use {@link float} to produce a valued directly.\n *\n * Random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n *\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const r = floatSource();\n * r(); // Execute to produce random value\n *\n * // Random float between 0..100 (but not including 100)\n * const v = floatSource(100)();\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const r = floatSource({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const floatSource = (maxOrOptions = 1) => {\n    const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n    let max = options.max ?? 1;\n    let min = options.min ?? 0;\n    const source = options.source ?? Math.random;\n    resultThrow(numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (!options.min && max < 0) {\n        min = max;\n        max = 0;\n    }\n    if (min > max) {\n        throw new Error(`Min is greater than max. Min: ${min.toString()} max: ${max.toString()}`);\n    }\n    return () => source() * (max - min) + min;\n};\n/**\n * Returns a random float between `max` (exclusive) and 0 (inclusive).\n *\n * Max is 1 if unspecified.\n * Use {@link floatSource} to get a function that produces values. This is used internally.\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const v = float();\n * // Random float between 0..100 (but not including 100)\n * const v = float(100);\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const v = float({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const float = (maxOrOptions = 1) => floatSource(maxOrOptions)();\n","/**\n * Keeps generating a random number until\n * it's not 0\n * @param source Random number generator\n * @returns Non-zero number\n */\nexport const calculateNonZero = (source = Math.random) => {\n    let v = 0;\n    while (v === 0) {\n        v = source();\n    }\n    return v;\n};\n","import { calculateNonZero } from \"./non-zero.js\";\n/**\n * Returns a random number with gaussian (ie. bell-curved) distribution\n *\n * @example Random number between 0..1 with gaussian distribution\n * ```js\n * gaussian();\n * ```\n *\n * @example Distribution can be skewed\n * ```js\n * gaussian(10);\n * ```\n *\n * Use {@link gaussianSource} if you want a function with skew value baked-in.\n * @param skew Skew factor. Defaults to 1, no skewing. Above 1 will skew to left, below 1 will skew to right\n * @returns\n */\nexport const gaussian = (skew = 1) => gaussianSource(skew)();\n/**\n * Returns a function that generates a gaussian-distributed random number\n * @example\n * Random number between 0..1 with gaussian distribution\n * ```js\n * // Create function\n * const r = gaussianSource();\n *\n * // Generate random value\n * r();\n * ```\n *\n * @example\n * Pass the random number generator elsewhere\n * ```js\n * const r = gaussianSource(10);\n *\n * // Randomise array with gaussian distribution\n * Arrays.shuffle(r);\n * ```\n *\n * If you want to fit a value to a gaussian curve, see Modulation.gaussian instead.\n * @param skew\n * @returns\n */\nexport const gaussianSource = (skew = 1) => {\n    const min = 0;\n    const max = 1;\n    // Source: https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve\n    const compute = () => {\n        const u = calculateNonZero();\n        const v = calculateNonZero();\n        let result = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);\n        result = result / 10 + 0.5; // Translate to 0 -> 1\n        if (result > 1 || result < 0) {\n            result = compute(); //;gaussian(skew); // resample between 0 and 1 if out of range\n        }\n        else {\n            result = Math.pow(result, skew); // Skew\n            result *= max - min; // Stretch to fill range\n            result += min; // offset to min\n        }\n        return result;\n    };\n    return compute;\n};\n","/**\n * Generates a six-digit roughly unique id\n * ```js\n * const id = shortGuid();\n * ```\n * @param options Options.\n * @returns\n */\nexport const shortGuid = (options = {}) => {\n    const source = options.source ?? Math.random;\n    // Via Stackoverflow...\n    const firstPart = Math.trunc(source() * 46_656);\n    const secondPart = Math.trunc(source() * 46_656);\n    const firstPartString = `000${firstPart.toString(36)}`.slice(-3);\n    const secondPartString = `000${secondPart.toString(36)}`.slice(-3);\n    return firstPartString + secondPartString;\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount, offset = 0) {\n    resultThrow(integerTest(amount, ``, `amount`), integerTest(offset, ``, `offset`));\n    if (amount === 0)\n        return;\n    let index = 0;\n    do {\n        yield (amount < 0 ? -index + offset : index + offset);\n    } while (index++ < Math.abs(amount) - 1);\n}\n;\n","import { numberTest, integerTest, resultThrow } from \"@ixfx/guards\";\nimport { count } from \"./util/count.js\";\nimport { shuffle } from \"./arrays.js\";\n/**\n * Returns a function that produces a random integer between `max` (exclusive) and 0 (inclusive)\n * Use {@link integer} if you want a random number directly.\n *\n * Invoke directly:\n * ```js\n * integerSource(10)();  // Random number 0-9\n * ```\n *\n * Or keep a reference to re-compute:\n * ```js\n * const r = integerSource(10);\n * r(); // Produce a random integer\n * ```\n *\n * If a negative value is given, this is assumed to be the\n * minimum (inclusive), with 0 as the max (inclusive)\n * ```js\n * integerSource(-5)();  // Random number from -5 to 0\n * ```\n *\n * Specify options for a custom minimum or source of random:\n * ```js\n * integerSource({ max: 5,  min: 10 })();  // Random number 4-10\n * integerSource({ max: -5, min: -10 })(); // Random number from -10 to -6\n * integerSource({ max: 10, source: Math.random })(); // Random number between 0-9, with custom source of random\n * ```\n *\n * Throws an error if max & min are equal\n * @param maxOrOptions Max value (exclusive), or set of options\n * @returns Random integer\n */\nexport const integerSource = (maxOrOptions) => {\n    if (typeof maxOrOptions === `undefined`) {\n        throw new TypeError(`maxOrOptions is undefined`);\n    }\n    const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n    let max = Math.floor(options.max ?? 100);\n    let min = Math.floor(options.min ?? 0);\n    // If we just get -5 as the max, invert so\n    // max:1 and min: -5 instead for -5...0 range\n    if (!options.min && max < 0) {\n        max = 1;\n        min = options.max ?? 0;\n    }\n    const randomSource = options.source ?? Math.random;\n    if (min > max) {\n        throw new Error(`Min value is greater than max (min: ${min.toString()} max: ${max.toString()})`);\n    }\n    resultThrow(numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (max === min) {\n        throw new Error(`Max and min values cannot be the same (${max.toString()})`);\n    }\n    // Distance\n    const amt = Math.abs(max - min);\n    return () => Math.floor(randomSource() * amt) + min;\n};\n/**\n * Returns a random integer between `max` (exclusive) and 0 (inclusive)\n * Use {@link integerSource} to return a function instead.\n *\n * ```js\n * integer(10);  // Random number 0,1..9\n * ```\n *\n * If a negative value is given, this is assumed to be the\n * minimum (inclusive), with 0 as the max (inclusive)\n * ```js\n * integer(-5);  // Random number -5,-4,...0\n * ```\n *\n * Specify options for a custom minimum or source of random:\n * ```js\n * integer({ max: 5,  min: 10 });  // Random number 4-10\n * integer({ max: -5, min: -10 }); // Random number from -10 to -6\n * integer({ max: 10, source: Math.random }); // Random number between 0-9, with custom source of random\n * ```\n *\n * Throws an error if max & min are equal\n * @param maxOrOptions Max value (exclusive), or set of options\n * @returns Random integer\n */\nexport const integer = (maxOrOptions) => integerSource(maxOrOptions)();\n/**\n * Returns a generator over random unique integers, up to\n * but not including the given max value.\n *\n * @example 0..9 range\n * ```js\n * const rand = [ ...integerUniqueGen(10) ];\n * // eg: [2, 9, 6, 0, 8, 7, 3, 4, 5, 1]\n * ```\n *\n * @example Options can be provided:\n * ```js\n * // 5..9 range\n * const rand = [ ...integerUniqueGen({ min: 5, max: 10 })];\n * ```\n *\n * Range can be looped. Once the initial random walk through the number\n * range completes, it starts again in a new random way.\n *\n * ```js\n * for (const r of integerUniqueGen({ max: 10, loop: true })) {\n *  // Warning: loops forever\n * }\n * ```\n *\n * Behind the scenes, an array of numbers is created that captures the range, this is then\n * shuffled on the first run, and again whenever the iterator loops, if that's allowed.\n *\n * As a consequence, large ranges will consume larger amounts of memory.\n * @param maxOrOptions\n * @returns\n */\nexport function* integerUniqueGen(maxOrOptions) {\n    const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n    const min = options.min ?? 0;\n    const max = options.max ?? 100;\n    const source = options.source ?? Math.random;\n    const loop = options.loop ?? false;\n    resultThrow(integerTest(min, ``, `min`), integerTest(max, ``, `max`));\n    if (min > max) {\n        throw new Error(`Min value is greater than max. Min: ${min.toString()} Max: ${max.toString()}`);\n    }\n    const origRange = [...count(max - min, min)];\n    let numberRange = shuffle(origRange);\n    let index = 0;\n    while (true) {\n        if (index === numberRange.length) {\n            if (loop)\n                numberRange = shuffle(origRange, source);\n            else\n                return;\n        }\n        yield numberRange[index++];\n    }\n}\n","/**\n * Reproducible random values using the Merseene Twister algorithm.\n * With the same seed value, it produces the same series of random values.\n *\n * ```js\n * // Seed with a value of 100\n * const r = mersenneTwister(100);\n * r.float();         // 0..1\n * ```\n *\n * Integer values can also be produced. First parameter\n * is the maximum value (exclusive), the optional second\n * parameter is the minimum value (inclusive).\n * ```js\n * r.integer(10);     // 0..9\n * r.integer(10, 5);  // 5..9\n *\n * // Eg random array index:\n * r.integer(someArray.length);\n * ```\n *\n * Adapted from George MacKerron's implementation. MIT License.\n * https://github.com/jawj/mtwist/\n * @param seed Seed value 0..4294967295. Default: random seed.\n */\nexport function mersenneTwister(seed) {\n    if (!seed)\n        seed = Math.random() * 4294967295;\n    // Initialisation\n    let mt = new Array(624);\n    mt[0] = seed >>> 0;\n    const n1 = 1812433253;\n    for (let mti = 1; mti < 624; mti++) {\n        const n2 = mt[mti - 1] ^ (mt[mti - 1] >>> 30);\n        // uint32 multiplication, low 16 bits and high 16 bits multiplied separately and reassembled:\n        mt[mti] = ((((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) + mti) >>> 0;\n    }\n    let mti = 624;\n    const randomUint32 = () => {\n        let y;\n        if (mti >= 624) {\n            for (let i = 0; i < 227; i++) {\n                y = ((mt[i] & 0x80000000) | (mt[i + 1] & 0x7fffffff)) >>> 0;\n                mt[i] = (mt[i + 397] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;\n            }\n            for (let i = 227; i < 623; i++) {\n                y = ((mt[i] & 0x80000000) | (mt[i + 1] & 0x7fffffff)) >>> 0;\n                mt[i] = (mt[i - 227] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;\n            }\n            y = ((mt[623] & 0x80000000) | (mt[0] & 0x7fffffff)) >>> 0;\n            mt[623] = (mt[396] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;\n            mti = 0;\n        }\n        y = mt[mti++];\n        y = (y ^ (y >>> 11)) >>> 0;\n        y = (y ^ ((y << 7) & 0x9d2c5680)) >>> 0;\n        y = (y ^ ((y << 15) & 0xefc60000)) >>> 0;\n        y = (y ^ (y >>> 18)) >>> 0;\n        return y;\n    };\n    const float = () => randomUint32() / 4294967296; // 2^32\n    // Max is exclusive\n    const integer = (maxExclusive, minInclusive = 0) => {\n        if (maxExclusive < 1)\n            throw new Error(\"Upper bound must be greater than or equal to 1\");\n        if (maxExclusive > 4294967296)\n            throw new Error(\"Upper bound must not be greater than 4294967296\");\n        if (maxExclusive === 1)\n            return 0;\n        let range = maxExclusive - minInclusive;\n        const bitsNeeded = Math.ceil(Math.log2(range)), bitMask = (1 << bitsNeeded) - 1;\n        while (true) {\n            const int = randomUint32() & bitMask;\n            if (int < range)\n                return minInclusive + int;\n        }\n    };\n    return { integer, float };\n}\n","import {} from \"./types.js\";\n/**\n * Returns a string of random letters and numbers of a given `length`.\n *\n * ```js\n * string();  // Random string of length 5\n * string(4); // eg. `4afd`\n * ```\n * @param lengthOrOptions Length of random string, or options.\n * @returns Random string\n */\nexport const string = (lengthOrOptions = 5) => {\n    const options = typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;\n    const calculate = options.source ?? Math.random;\n    const length = options.length ?? 5;\n    let returnValue = ``;\n    while (returnValue.length < length) {\n        returnValue += calculate()\n            .toString(36)\n            .slice(2);\n    }\n    return returnValue.substring(0, length);\n};\n","import { integer, integerSource } from \"./integer.js\";\n/**\n * Returns a random number of minutes, with a unit of milliseconds.\n *\n * Max value is exclusive, defaulting to 5.\n * Use {@link minutesMs} to get a value directly, or {@link minutesMsSource} to return a function.\n *\n * @example Random value from 0 to one milli less than 5 * 60 * 1000\n * ```js\n * // Create function that returns value\n * const f = minutesMsSource(5);\n *\n * f(); // Generate value\n * ```\n *\n * @example Specified options:\n * ```js\n * // Random time between one minute and 5 minutes\n * const f = minutesMsSource({ max: 5, min: 1 });\n * f();\n * ```\n *\n * @remarks\n * It's a very minor function, but can make\n * code a little more literate:\n * ```js\n * // Random timeout of up to 5 mins\n * setTimeout(() => { ... }, minutesMsSource(5));\n * ```\n * @param maxMinutesOrOptions\n * @see {@link minutesMs}\n * @returns Function that produces a random value\n */\nexport const minutesMsSource = (maxMinutesOrOptions) => {\n    const options = typeof maxMinutesOrOptions === `number`\n        ? { max: maxMinutesOrOptions }\n        : maxMinutesOrOptions;\n    const min = (options.min ?? 0) * 60 * 1000;\n    const max = (options.max ?? 5) * 60 * 1000;\n    return integerSource({ ...options, max, min });\n};\n/**\n * Return a random time value in milliseconds, using minute values to set range.\n *\n * @example Random value from 0 to one milli less than 5 * 60 * 1000\n * ```js\n * // Random value from 0 to one milli less than 5*60*1000\n * minuteMs(5);\n * ```\n *\n * @example Specified options:\n * ```js\n * // Random time between one minute and 5 minutes\n * minuteMs({ max: 5, min: 1 });\n * ```\n *\n * @param maxMinutesOrOptions\n * @see {@link minutesMsSource}\n * @returns Milliseconds\n */\nexport const minutesMs = (maxMinutesOrOptions) => minutesMsSource(maxMinutesOrOptions)();\n/**\n * Returns function which produces a random number of seconds, with a unit of milliseconds.\n *\n * Maximum value is exclusive, defaulting to 5\n * Use {@link secondsMs} to return a random value directly, or {@link secondsMsSource} to return a function.\n *\n * @example Random milliseconds between 0..4999\n * ```js\n * // Create function\n * const f = secondsMsSource(5000);\n * // Produce a value\n * const value = f();\n * ```\n *\n * @example Options can be provided\n * ```js\n * // Random milliseconds between 1000-4999\n * const value = secondsMsSource({ max:5, min:1 })();\n * // Note the extra () at the end to execute the function\n * ```\n *\n * @remarks\n * It's a very minor function, but can make\n * code a little more literate:\n * ```js\n * // Random timeout of up to 5 seconds\n * setTimeout(() => { ...}, secondsMsSource(5));\n * ```\n * @param maxSecondsOrOptions Maximum seconds, or options.\n * @returns Milliseconds\n */\nexport const secondsMsSource = (maxSecondsOrOptions) => {\n    const options = typeof maxSecondsOrOptions === `number`\n        ? { max: maxSecondsOrOptions }\n        : maxSecondsOrOptions;\n    const min = (options.min ?? 0) * 1000;\n    const max = (options.max ?? 5) * 1000;\n    return () => integer({ ...options, max, min });\n};\n/**\n * Generate random time in milliseconds, using seconds to set the bounds\n *\n * @example Random milliseconds between 0..4999\n * ```js\n * secondsMs(5000);\n * ```\n *\n * @example Options can be provided\n * ```js\n * // Random milliseconds between 1000-4999\n * secondsMs({ max:5, min:1 });\n * ```\n * @param maxSecondsOrOptions\n * @returns\n */\nexport const secondsMs = (maxSecondsOrOptions) => secondsMsSource(maxSecondsOrOptions)();\n","export function clamp(v, min = 0, max = 1) {\n    if (v < min)\n        return min;\n    if (v > max)\n        return max;\n    return v;\n}\n","import {} from \"./types.js\";\nimport { clamp } from \"./util/clamp.js\";\n/**\n * Random integer, weighted according to an easing function.\n * Number will be inclusive of `min` and below `max`.\n *\n * @example 0..99\n * ```js\n * const r = Random.weightedIntegerFn(100);\n * r(); // Produce value\n * ```\n *\n * @example 20..29\n * ```js\n * const r = Random.weightedIntegerFn({ min: 20, max: 30 });\n * r(); // Produce value\n * ```\n *\n * @example  0..99 with 'quadIn' easing\n * ```js\n * const r = Random.weightedInteger({ max: 100, easing: `quadIn` });\n * ```\n *\n * Note: result from easing function will be clamped to\n * the min/max (by default 0-1);\n *\n * @param options Options. By default { max:1, min: 0 }\n * @returns Function that produces a random weighted integer\n */\nexport const weightedIntegerSource = (options) => {\n    const source = options.source ?? Math.random;\n    if (typeof options.easingFunction === `undefined`)\n        throw new Error(`Param 'easingFunction' is undefined`);\n    const max = options.max ?? 1;\n    const min = options.min ?? 0;\n    if (max === min)\n        throw new Error(`Param 'max' is the same as  'min'`);\n    if (max < min)\n        throw new Error(`Param 'max' should be greater than  'min'`);\n    const compute = () => {\n        const r = clamp(options.easingFunction(source()));\n        return Math.floor(r * (max - min)) + min;\n    };\n    return compute;\n};\n/**\n * Generate a weighted-random integer.\n *\n * @example 0..99\n * ```js\n * Random.weightedInteger(100);\n * ```\n *\n * @example 20..29\n * ```js\n * Random.weightedInteger({ min: 20, max: 30 });\n * ```\n *\n * @example  0..99 with 'quadIn' easing\n * ```js\n * Random.weightedInteger({ max: 100, easing: `quadIn` })\n * ```\n * @param options Options. Default: { max: 1, min: 0 }\n * @returns Random weighted integer\n */\nexport const weightedInteger = (options) => weightedIntegerSource(options)();\n","import {} from './types.js';\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * See @ixfx/modulation.weighted to use a named easing function.\n * Use {@link weightedSource} to return a function instead.\n *\n * @see {@link weightedSource} Returns a function rather than value\n * @returns Random number (0-1)\n */\nexport const weighted = (options) => weightedSource(options)();\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * See @ixfx/modulation.weighted to use a named easing function.\n * Use {@link weighted} to get a value directly.\n *\n * @see {@link weighted} Returns value instead of function\n * @returns Function which returns a weighted random value\n */\nexport const weightedSource = (options) => {\n    const source = options.source ?? Math.random;\n    if (typeof options.easing !== `undefined`)\n        throw new Error(`Param 'easingName' unavailable. Use @ixfx/modulation.weighted instead.`);\n    if (typeof options.easingFunction === `undefined`)\n        throw new Error(`Param 'easingFunction' is undefined`);\n    return () => options.easingFunction(source());\n};\n","export * from './arrays.js';\nexport * from './chance.js';\nexport * from './float-source.js';\nexport * from './gaussian.js';\nexport * from './guid.js';\nexport * from './integer.js';\nexport * from './non-zero.js';\nexport * from './seeded.js';\nexport * from './string.js';\nexport * from './time.js';\nexport * from './types.js';\nexport * from './weighted-index.js';\nexport * from './weighted-integer.js';\nexport * from './weighted.js';\n// export { randomElement as arrayElement } from '../data/arrays/Random.js';\n// export { randomHue as hue } from '../visual/colour/index.js';\n// export { randomIndex as arrayIndex } from '../data/arrays/Random.js';\n","/**\n * Run a function if a value changes\n * ```js\n * const r = handleChangeResult(trackNumberChange, (value) => {\n *  // Called when value changes\n * });\n * r(10);\n * ```\n * @param monitor\n * @param onChanged\n * @param onNotChanged\n * @returns\n */\nexport function handleChangeResult(monitor, onChanged, onNotChanged) {\n    return (v) => {\n        const r = monitor(v);\n        if (r.changed) {\n            onChanged(v, r.changes, r.total);\n        }\n        else if (typeof onNotChanged !== `undefined`) {\n            onNotChanged(v, r.identicalRun, r.total);\n        }\n    };\n}\n/**\n * Returns a function to monitor value changes.\n * ```js\n * const f = trackNumberChange(true);\n * f(10); // { changed: true, changesCount: 1 }\n * f(10); // { changed: false, changesCount: 1 }\n * ```\n *\n * Default options:\n * * nanHandling: error\n * * includeFirstValueInCount: false\n *\n * NaN handling:\n * * allow: use NaN value as a legal value and report a change\n * * skip: ignore NaN values, reporting back no change and use the same changes count\n * * error: throw an error if a NaN value is received\n *\n *\n * @returns\n */\nexport function trackNumberChange(options = {}) {\n    const nanHandling = options.nanHandling ?? `error`;\n    const includeFirstValueInCount = options.includeFirstValueInCount ?? false;\n    let lastValue = options.initial;\n    let changes = 0;\n    let total = 0;\n    let identicalRun = 0;\n    return (v) => {\n        if (typeof v !== `number`)\n            throw new TypeError(`Parameter should be number. Got type: ${typeof v}`);\n        if (Number.isNaN(v)) {\n            switch (nanHandling) {\n                case `error`:\n                    throw new Error(`Parameter is NaN`);\n                case `skip`:\n                    return { changed: false, changes, total, identicalRun };\n            }\n        }\n        total++;\n        let eq = lastValue === v;\n        // Because two NaNs don't equal (!?)\n        if (Number.isNaN(lastValue) && Number.isNaN(v))\n            eq = true;\n        if (!eq) {\n            identicalRun = 0;\n            if (lastValue !== undefined || includeFirstValueInCount) {\n                changes++;\n            }\n            lastValue = v;\n            return { changed: true, changes, total, identicalRun };\n        }\n        else {\n            identicalRun++;\n        }\n        return { changed: false, changes, total, identicalRun };\n    };\n}\n/**\n * Returns a function to track changes in a boolean value\n * ```js\n * const t = trackBooleanChange();\n * t(true); // { changed:false }\n * t(true); // { changed:false }\n * t(false); // { changed: true }\n * ```\n *\n * Default options:\n * * includeFirstValueInCount: false\n * @param options\n * @returns\n */\nexport function trackBooleanChange(options = {}) {\n    const includeFirstValueInCount = options.includeFirstValueInCount ?? false;\n    let lastValue = options.initial;\n    let changes = 0;\n    let total = 0;\n    let identicalRun = 0;\n    return (v) => {\n        if (typeof v !== `boolean`)\n            throw new TypeError(`Parameter should be boolean. Got type: ${typeof v}`);\n        total++;\n        if (lastValue !== v) {\n            identicalRun = 0;\n            if (lastValue !== undefined || includeFirstValueInCount) {\n                changes++;\n            }\n            lastValue = v;\n            return { changed: true, changes, total, identicalRun };\n        }\n        else {\n            identicalRun++;\n        }\n        return { changed: false, changes, total, identicalRun };\n    };\n}\n","import { keyValueSorter } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { numberArrayCompute } from '@ixfx/numbers';\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = new FrequencyTracker();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = new FrequencyTracker();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequency( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @typeParam V - Type of items\n */\nexport class FrequencyTracker extends SimpleEventEmitter {\n    #store;\n    #keyString;\n    /**\n     * Constructor\n     * @param keyString Function to key items. Uses JSON.stringify by default\n     */\n    constructor(keyString) {\n        super();\n        this.#store = new Map();\n        if (typeof keyString === `undefined`) {\n            keyString = (a) => {\n                if (a === undefined)\n                    throw new Error(`Cannot create key for undefined`);\n                return typeof a === `string` ? a : JSON.stringify(a);\n            };\n        }\n        this.#keyString = keyString;\n    }\n    /**\n     * Clear data. Fires `change` event\n     */\n    clear() {\n        this.#store.clear();\n        this.fireEvent(`change`, { context: this });\n    }\n    /**\n     * @returns Iterator over keys (ie. groups)\n     */\n    keys() {\n        return this.#store.keys();\n    }\n    /**\n     * @returns Iterator over frequency counts\n     */\n    values() {\n        return this.#store.values();\n    }\n    /**\n     * @returns Copy of entries as an array of `[key, count]`\n     */\n    toArray() {\n        return [...this.#store.entries()];\n    }\n    /**\n     * Returns a string with keys and counts, useful for debugging.\n     * @returns\n     */\n    debugString() {\n        let t = ``;\n        for (const [key, count] of this.#store.entries()) {\n            t += `${key}: ${count.toString()}, `;\n        }\n        if (t.endsWith(`, `))\n            return t.slice(0, Math.max(0, t.length - 2));\n        return t;\n    }\n    /**\n     *\n     * @param value Value to count\n     * @returns Frequency of value, or _undefined_ if it does not exist\n     */\n    frequencyOf(value) {\n        if (typeof value === `string`)\n            return this.#store.get(value);\n        const key = this.#keyString(value);\n        return this.#store.get(key);\n    }\n    /**\n     *\n     * @param value Value to count\n     * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n     */\n    relativeFrequencyOf(value) {\n        let freq;\n        if (typeof value === `string`)\n            freq = this.#store.get(value);\n        else {\n            const key = this.#keyString(value);\n            freq = this.#store.get(key);\n        }\n        if (freq === undefined)\n            return;\n        const mma = this.computeValues();\n        return freq / mma.total;\n    }\n    /**\n     * Returns copy of entries as an array\n     * @returns Copy of entries as an array\n     */\n    entries() {\n        return [...this.#store.entries()];\n    }\n    /**\n     * Calculate min,max,avg,total & count from values\n     * @returns Returns `{min,max,avg,total}`\n     */\n    computeValues() {\n        const valuesAsNumbers = [...this.values()];\n        return numberArrayCompute(valuesAsNumbers);\n    }\n    /**\n     * Return entries sorted\n     * @param sortStyle Sorting style (default: _value_, ie. count)\n     * @returns Sorted array of [key,frequency]\n     */\n    entriesSorted(sortStyle = `value`) {\n        const s = keyValueSorter(sortStyle);\n        return s(this.entries());\n    }\n    /**\n     * Add one or more values, firing _change_ event.\n     * @param values Values to add. Fires _change_ event after adding item(s)\n     */\n    add(...values) {\n        if (typeof values === `undefined`)\n            throw new Error(`Param 'values' undefined`);\n        const keys = values.map(v => this.#keyString(v));\n        //const key = this.#keyString(value);\n        for (const key of keys) {\n            const score = this.#store.get(key) ?? 0;\n            this.#store.set(key, score + 1);\n        }\n        this.fireEvent(`change`, { context: this });\n    }\n}\nexport const frequency = (keyString) => new FrequencyTracker(keyString);\n","/**\n * Base tracker class\n */\nexport class TrackerBase {\n    /**\n     * @ignore\n     */\n    seenCount;\n    /**\n     * @ignore\n     */\n    storeIntermediate;\n    /**\n     * @ignore\n     */\n    resetAfterSamples;\n    /**\n     * @ignore\n     */\n    sampleLimit;\n    id;\n    debug;\n    constructor(opts = {}) {\n        this.id = opts.id ?? `tracker`;\n        this.debug = opts.debug ?? false;\n        this.sampleLimit = opts.sampleLimit ?? -1;\n        this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n        this.storeIntermediate =\n            opts.storeIntermediate ??\n                (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n        this.seenCount = 0;\n        if (this.debug) {\n            console.log(`TrackerBase: sampleLimit: ${this.sampleLimit} resetAfter: ${this.resetAfterSamples} store: ${this.storeIntermediate}`);\n        }\n    }\n    /**\n     * Reset tracker\n     */\n    reset() {\n        this.seenCount = 0;\n        this.onReset();\n    }\n    /**\n     * Adds a value, returning computed result.\n     *\n     * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.\n     * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is\n     * called to take it down to sample limit, and `onTrimmed()` is called.\n     * @param p\n     * @returns\n     */\n    seen(...p) {\n        if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n            this.reset();\n        }\n        else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n            this.seenCount = this.trimStore(this.sampleLimit);\n            this.onTrimmed(`resize`);\n        }\n        this.seenCount += p.length;\n        const t = this.filterData(p);\n        return this.computeResults(t);\n    }\n}\n","import { TrackerBase } from \"./tracker-base.js\";\nexport class PrimitiveTracker extends TrackerBase {\n    values;\n    timestamps;\n    constructor(opts) {\n        super(opts);\n        this.values = [];\n        this.timestamps = [];\n    }\n    /**\n     * Reduces size of value store to `limit`. Returns\n     * number of remaining items\n     * @param limit\n     */\n    trimStore(limit) {\n        if (limit >= this.values.length)\n            return this.values.length;\n        this.values = this.values.slice(-limit);\n        this.timestamps = this.timestamps.slice(-limit);\n        return this.values.length;\n    }\n    onTrimmed(reason) {\n        // no-op\n    }\n    get last() {\n        return this.values.at(-1);\n    }\n    get initial() {\n        return this.values.at(0);\n    }\n    /**\n     * Returns number of recorded values (this can include the initial value)\n     */\n    get size() {\n        return this.values.length;\n    }\n    /**\n     * Returns the elapsed time, in milliseconds since the instance was created\n     */\n    get elapsed() {\n        if (this.values.length < 0)\n            throw new Error(`No values seen yet`);\n        return Date.now() - this.timestamps[0];\n    }\n    /**\n     * Returns the time, in milliseconds, covering the initial and last values.\n     * Returns NaN if either of these is missing.\n     */\n    get timespan() {\n        const oldest = this.timestamps.at(0);\n        const newest = this.timestamps.at(-1);\n        if (oldest === undefined)\n            return Number.NaN;\n        if (newest === undefined)\n            return Number.NaN;\n        return newest - oldest;\n    }\n    onReset() {\n        this.values = [];\n        this.timestamps = [];\n    }\n    /**\n     * Tracks a value\n     */\n    filterData(rawValues) {\n        const lastValue = rawValues.at(-1);\n        const last = { value: lastValue, at: performance.now() };\n        const values = rawValues.map(value => ({\n            at: performance.now(),\n            value: value\n        }));\n        //const now = Date.now();\n        if (this.storeIntermediate) {\n            this.values.push(...rawValues);\n            this.timestamps.push(...values.map(v => v.at));\n        }\n        else\n            switch (this.values.length) {\n                case 0: {\n                    // Add as initial value\n                    this.values.push(last.value);\n                    this.timestamps.push(last.at);\n                    break;\n                }\n                case 2: {\n                    // Replace last value\n                    this.values[1] = last.value;\n                    this.timestamps[1] = last.at;\n                    break;\n                }\n                case 1: {\n                    // Add last value\n                    this.values.push(last.value);\n                    this.timestamps.push(last.at);\n                    break;\n                }\n                // No default\n            }\n        return values;\n    }\n}\n","import { PrimitiveTracker } from \"./primitive-tracker.js\";\nimport { minFast, maxFast, totalFast } from \"@ixfx/numbers\";\nexport class NumberTracker extends PrimitiveTracker {\n    #total = 0;\n    #min = Number.MAX_SAFE_INTEGER;\n    #max = Number.MIN_SAFE_INTEGER;\n    /**\n     * Difference between last value and initial.\n     * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)\n     * If either of those is missing, undefined is returned\n     */\n    difference() {\n        if (this.last === undefined)\n            return;\n        if (this.initial === undefined)\n            return;\n        return this.last - this.initial;\n    }\n    /**\n     * Relative difference between last value and initial.\n     * Eg if last value was 10 and initial value was 5, 2 is returned (200%)\n     */\n    relativeDifference() {\n        if (this.last === undefined)\n            return;\n        if (this.initial === undefined)\n            return;\n        return this.last / this.initial;\n    }\n    onReset() {\n        this.#min = Number.MAX_SAFE_INTEGER;\n        this.#max = Number.MIN_SAFE_INTEGER;\n        this.#total = 0;\n        super.onReset();\n    }\n    /**\n     * When trimmed, recomputes to set total/min/max to be based on\n     * current values.\n     * @param reason\n     */\n    onTrimmed(reason) {\n        this.#min = minFast(this.values);\n        this.#max = maxFast(this.values);\n        this.#total = totalFast(this.values);\n    }\n    computeResults(values) {\n        if (values.some((v) => Number.isNaN(v)))\n            throw new Error(`Cannot add NaN`);\n        const numbers = values.map(value => value.value);\n        this.#total = numbers.reduce((accumulator, v) => accumulator + v, this.#total);\n        this.#min = Math.min(...numbers, this.#min);\n        this.#max = Math.max(...numbers, this.#max);\n        return {\n            max: this.#max,\n            min: this.#min,\n            total: this.#total,\n            avg: this.avg\n        };\n    }\n    getMinMaxAvg() {\n        return {\n            min: this.#min,\n            max: this.#max,\n            avg: this.avg,\n        };\n    }\n    get max() {\n        return this.#max;\n    }\n    get total() {\n        return this.#total;\n    }\n    get min() {\n        return this.#min;\n    }\n    get avg() {\n        return this.#total / this.seenCount;\n    }\n}\n/**\n * Keeps track of the total, min, max and avg in a stream of values. By default values\n * are not stored.\n *\n * Usage:\n *\n * ```js\n * import { number } from '@ixfx/trackers.js';\n *\n * const t = number();\n * t.seen(10);\n *\n * t.avg / t.min/ t.max\n * t.initial; // initial value\n * t.size;    // number of seen values\n * t.elapsed; // milliseconds since intialisation\n * t.last;    // last value\n * ```\n *\n * To get `{ avg, min, max, total }`\n * ```\n * t.getMinMax()\n * ```\n *\n * Use `t.reset()` to clear everything.\n *\n * Trackers can automatically reset after a given number of samples\n * ```\n * // reset after 100 samples\n * const t = number({ resetAfterSamples: 100 });\n * ```\n *\n * To store values, use the `storeIntermediate` option:\n *\n * ```js\n * const t = number({ storeIntermediate: true });\n * ```\n *\n * Difference between last value and initial value:\n * ```js\n * t.relativeDifference();\n * ```\n *\n * Get raw data (if it is being stored):\n * ```js\n * t.values; // array of numbers\n * t.timestampes; // array of millisecond times, indexes correspond to t.values\n * ```\n */\nexport const number = (opts = {}) => new NumberTracker(opts);\n","import { NumberTracker } from './number-tracker.js';\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n */\nexport class IntervalTracker extends NumberTracker {\n    lastMark = 0;\n    mark() {\n        if (this.lastMark > 0) {\n            this.seen(performance.now() - this.lastMark);\n        }\n        this.lastMark = performance.now();\n    }\n}\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { interval } from '@ixfx/trackers.js';\n *\n * const t = interval();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = interval({ resetAfterSamples: 100} );\n * ```\n * @param options Options for tracker\n * @returns New interval tracker\n */\nexport const interval = (options) => new IntervalTracker(options);\n","import { timeout } from \"@ixfx/flow\";\n/**\n * Tracks the rate of events.\n * It's also able to compute the min,max and average interval between events.\n *\n * @example\n * ```js\n * const clicks = Trackers.rate();\n *\n * // Mark when a click happens\n * document.addEventListener(`click`, () => clicks.mark());\n *\n * // Get details\n * clicks.perSecond; // How many clicks per second\n * clicks.perMinute; // How many clicks per minute\n * ```\n *\n * `timeoutInterval` is a useful option to make the tracker reset\n * after some period without `mark()` being called.\n *\n * Another useful option is `sampleLimit`, which sets an upper bound\n * for how many events to track. A smaller value means the results\n * will more accurately track, but it might be less smooth.\n *\n * ```js\n * // Eg reset tracker after 5 seconds of inactivity\n * const clicks = Trackers.rate({\n *  sampleLimit: 10,\n *  timeoutInterval: { secs: 5 }\n * });\n * ```\n */\nexport class RateTracker {\n    #events = [];\n    #fromTime;\n    #resetAfterSamples;\n    #sampleLimit;\n    #resetTimer;\n    constructor(opts = {}) {\n        this.#resetAfterSamples = opts.resetAfterSamples ?? Number.MAX_SAFE_INTEGER;\n        this.#sampleLimit = opts.sampleLimit ?? Number.MAX_SAFE_INTEGER;\n        if (opts.timeoutInterval) {\n            this.#resetTimer = timeout(() => {\n                this.reset();\n            }, opts.timeoutInterval);\n        }\n        this.#fromTime = performance.now();\n    }\n    /**\n     * Mark that an event has happened\n     */\n    mark() {\n        if (this.#events.length >= this.#resetAfterSamples) {\n            this.reset();\n        }\n        else if (this.#events.length >= this.#sampleLimit) {\n            this.#events = this.#events.slice(1);\n            this.#fromTime = this.#events[0];\n        }\n        this.#events.push(performance.now());\n        if (this.#resetTimer) {\n            this.#resetTimer.start();\n        }\n    }\n    /**\n     * Compute {min,max,avg} for the interval _between_ events.\n     * @returns\n     */\n    computeIntervals() {\n        const intervals = [];\n        let min = Number.MAX_SAFE_INTEGER;\n        let max = Number.MIN_SAFE_INTEGER;\n        let total = 0;\n        let count = 0;\n        let start = 0;\n        for (const event of this.#events) {\n            if (count > 0) {\n                const index = event - start;\n                min = Math.min(index, min);\n                max = Math.max(index, max);\n                total += index;\n                intervals.push(index);\n            }\n            start = event;\n            count++;\n        }\n        const avg = total / count;\n        return {\n            min, max, avg\n        };\n    }\n    /**\n     * Returns the time period (in milliseconds) that encompasses\n     * the data set. Eg, a result of 1000 means there's data that\n     * covers a one second period.\n     */\n    get elapsed() {\n        return performance.now() - this.#fromTime;\n    }\n    /**\n     * Resets the tracker.\n     */\n    reset() {\n        this.#events = [];\n        this.#fromTime = performance.now();\n    }\n    /**\n     * Get the number of events per second\n     */\n    get perSecond() {\n        return this.#events.length / (this.elapsed / 1000);\n    }\n    /**\n     * Get the number of events per minute\n     */\n    get perMinute() {\n        return this.#events.length / (this.elapsed / 1000 / 60);\n    }\n}\n/**\n * @inheritdoc RateTracker\n * @param opts\n * @returns\n */\nexport const rate = (opts = {}) => new RateTracker(opts);\n","import { TrackerBase } from './tracker-base.js';\n/**\n * A tracked value of type `V`.\n */\nexport class ObjectTracker extends TrackerBase {\n    values;\n    constructor(opts = {}) {\n        super(opts);\n        this.values = [];\n    }\n    onTrimmed(reason) {\n        // no-op\n    }\n    /**\n     * Reduces size of value store to `limit`.\n     * Returns number of remaining items\n     * @param limit\n     */\n    trimStore(limit) {\n        if (limit >= this.values.length)\n            return this.values.length;\n        // Index 0 will be the oldest\n        this.values = this.values.slice(-limit);\n        return this.values.length;\n    }\n    /**\n     * Allows sub-classes to be notified when a reset happens\n     * @ignore\n     */\n    onReset() {\n        this.values = [];\n    }\n    /**\n     * Tracks a value\n     * @ignore\n     */\n    filterData(p) {\n        // Make sure values have a timestamp\n        const ts = p.map((v) => `at` in v\n            ? v\n            : {\n                ...v,\n                at: Date.now(),\n            });\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const last = ts.at(-1);\n        if (this.storeIntermediate)\n            this.values.push(...ts);\n        else\n            switch (this.values.length) {\n                case 0: {\n                    // Add as initial value\n                    this.values.push(last);\n                    break;\n                }\n                case 1: {\n                    // Add last value\n                    this.values.push(last);\n                    break;\n                }\n                case 2: {\n                    // Replace last value\n                    this.values[1] = last;\n                    break;\n                }\n            }\n        return ts;\n    }\n    /**\n     * Last seen value. If no values have been added, it will return the initial value\n     */\n    get last() {\n        if (this.values.length === 1)\n            return this.values[0];\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.values.at(-1);\n    }\n    /**\n     * Returns the oldest value in the buffer\n     */\n    get initial() {\n        return this.values.at(0);\n    }\n    /**\n     * Returns number of recorded values (includes the initial value in the count)\n     */\n    get size() {\n        return this.values.length;\n    }\n    /**\n     * Returns the elapsed time, in milliseconds since the initial value\n     */\n    get elapsed() {\n        return Date.now() - this.values[0].at;\n    }\n    /**\n     * Returns the time, in milliseconds, covering the initial and last values.\n     * Returns NaN if either of these is missing.\n     */\n    get timespan() {\n        const oldest = this.initial;\n        const newest = this.last;\n        if (!oldest)\n            return Number.NaN;\n        if (!newest)\n            return Number.NaN;\n        return newest.at - oldest.at;\n    }\n}\n","import { getOrGenerate, getOrGenerateSync } from '@ixfx/core/maps';\nimport { TrackerBase } from './tracker-base.js';\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class PointsTracker extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap {\n    store;\n    gog;\n    constructor(creator) {\n        this.store = new Map();\n        this.gog = getOrGenerateSync(this.store, creator);\n    }\n    /**\n     * Number of named values being tracked\n     */\n    get size() {\n        return this.store.size;\n    }\n    /**\n     * Returns _true_ if `id` is stored\n     * @param id\n     * @returns\n     */\n    has(id) {\n        return this.store.has(id);\n    }\n    /**\n     * For a given id, note that we have seen one or more values.\n     * @param id Id\n     * @param values Values(s)\n     * @returns Information about start to last value\n     */\n    seen(id, ...values) {\n        const trackedValue = this.getTrackedValue(id, ...values);\n        // Pass it over to the TrackedValue\n        const result = trackedValue.seen(...values);\n        return result;\n    }\n    /**\n     * Creates or returns a TrackedValue instance for `id`.\n     * @param id\n     * @param values\n     * @returns\n     */\n    getTrackedValue(id, ...values) {\n        if (id === null)\n            throw new Error(`id parameter cannot be null`);\n        if (id === undefined)\n            throw new Error(`id parameter cannot be undefined`);\n        // Create or recall TrackedValue by id\n        const trackedValue = this.gog(id, values[0]);\n        return trackedValue;\n    }\n    /**\n     * Remove a tracked value by id.\n     * Use {@link reset} to clear them all.\n     * @param id\n     */\n    delete(id) {\n        this.store.delete(id);\n    }\n    /**\n     * Remove all tracked values.\n     * Use {@link delete} to remove a single value by id.\n     */\n    reset() {\n        this.store = new Map();\n    }\n    /**\n     * Enumerate ids\n     */\n    *ids() {\n        yield* this.store.keys();\n    }\n    /**\n     * Enumerate tracked values\n     */\n    *tracked() {\n        yield* this.store.values();\n    }\n    /**\n     * Iterates TrackedValues ordered with oldest first\n     * @returns\n     */\n    *trackedByAge() {\n        const tp = [...this.store.values()];\n        tp.sort((a, b) => {\n            const aa = a.elapsed;\n            const bb = b.elapsed;\n            if (aa === bb)\n                return 0;\n            if (aa > bb)\n                return -1;\n            return 1;\n        });\n        for (const t of tp) {\n            yield t;\n        }\n    }\n    /**\n     * Iterates underlying values, ordered by age (oldest first)\n     * First the named values are sorted by their `elapsed` value, and then\n     * we return the last value for that group.\n     */\n    *valuesByAge() {\n        for (const tb of this.trackedByAge()) {\n            yield tb.last;\n        }\n    }\n    /**\n     * Enumerate last received values\n     *\n     * @example Calculate centroid of latest-received values\n     * ```js\n     * const pointers = pointTracker();\n     * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n     * ```\n     */\n    *last() {\n        for (const p of this.store.values()) {\n            yield p.last;\n        }\n    }\n    /**\n     * Enumerate starting values\n     */\n    *initialValues() {\n        for (const p of this.store.values()) {\n            yield p.initial;\n        }\n    }\n    /**\n     * Returns a tracked value by id, or undefined if not found\n     * @param id\n     * @returns\n     */\n    get(id) {\n        return this.store.get(id);\n    }\n}\n","export * from './changes.js';\nexport * from './frequency-mutable.js';\nexport * from './interval-tracker.js';\nexport * from './number-tracker.js';\nexport * from './rate-tracker.js';\nexport * from \"./object-tracker.js\";\nexport * from './primitive-tracker.js';\nexport * from \"./tracked-value.js\";\nexport * from './tracker-base.js';\nexport * from './types.js';\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x' + y')^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z') + (z'x\" - z\"x') + (x'y\" - x\"y'))\n    //   k(t) = -------------------------------------------------------\n    //                     (x' + y' + z')^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","export const piPi = Math.PI * 2;","import { piPi } from './pi.js';\nimport type { Point } from './point/point-type.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: readonly number[]): readonly number[];\n\n\nexport function degreeToRadian(angleInDegrees: number | readonly number[]): number | readonly number[] {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians \n * @returns \n */\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\nexport function degreeToGradian(angleInDegrees: number) {\n  return angleInDegrees * 1.111111\n}\n\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians \n * @param wrap \n * @returns \n */\nexport function gradianToDegree(angleInGradians: number, wrap = true) {\n  if (wrap) return (angleInGradians * 0.9) % 360;\n  return angleInGradians * 0.9;\n}\n\n\nexport function radianToGradian(angleInRadians: number) {\n  return angleInRadians * 63.6619772368; // 200/pi\n}\n\nexport function gradianToRadian(angleInGradian: number) {\n  return angleInGradian * 0.0157079633; // pi/200\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: readonly number[]): readonly number[];\n\n\nexport function radianToDegree(angleInRadians: number | readonly number[]): number | readonly number[] {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start: number, amount: number, clockwise = true) => {\n  if (clockwise) {\n    let x = start + amount;\n    if (x >= piPi) x = x % piPi;\n    return x;\n  } else {\n    const x = start - amount;\n    if (x < 0) {\n      return piPi + x;\n    }\n    return x;\n  }\n}\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n * \n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start: number, amount: number, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n * \n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n * \n * See {@link degreeArc} to operate in degrees.\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start: number, end: number, clockwise = true) => {\n  let s = start;\n  if (end < s) {\n    s = 0;\n    end = piPi - start + end;\n  }\n  let d = end - s;\n  if (clockwise) d = piPi - d;\n  if (d >= piPi) return d % piPi;\n  return d;\n}\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n * \n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n * \n * See {@link radianArc} to operate in radians.\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start: number, end: number, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));\n\n\nexport type Angle = {\n  value: number\n  unit: `deg` | `rad` | `turn` | `grad`\n}\n\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n * \n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n * \n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n * \n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value \n * @returns \n */\nexport const angleParse = (value: string | number | Angle): Angle => {\n  if (isAngle(value)) return value;\n\n  if (typeof value === `number`) {\n    return {\n      value, unit: `deg`\n    }\n  }\n  value = value.toLowerCase();\n  let unit = `deg`;\n  let numberValue = Number.NaN;\n  if (value.endsWith(`grad`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n    unit = `grad`;\n  } else if (value.endsWith(`rad`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n    unit = `rad`;\n  } else if (value.endsWith(`turn`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n    unit = `turn`;\n  } else if (value.endsWith(`deg`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n    unit = `deg`;\n  } else {\n    numberValue = Number.parseFloat(value);\n  }\n\n  if (Number.isNaN(numberValue)) throw new Error(`Invalid angle (bad value?)`);\n  if (unit.length === 0) throw new Error(`Invalid angle (no unit)`);\n  return {\n    value: numberValue,\n    unit: unit as `deg` | `grad` | `turn` | `rad`\n  }\n}\n\nconst isAngle = (v: any): v is Angle => {\n  if (typeof v !== `object`) return false;\n  if (`unit` in v && `value` in v) {\n    if (typeof v.unit !== `string`) return false;\n    if (typeof v.value !== `number`) return false;\n    return true;\n  }\n  return false;\n}\n\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n * \n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n * \n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n * \n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees \n * @param destination \n * @returns \n */\nexport const angleConvert = (angleOrDegrees: Angle | number | string, destination: Angle[ `unit` ]): Angle => {\n  const angle = typeof angleOrDegrees === `object` ? angleOrDegrees : angleParse(angleOrDegrees);\n  switch (destination) {\n    case `deg`:\n      if (angle.unit === `deg`) return angle;\n      if (angle.unit === `rad`) return { value: radianToDegree(angle.value), unit: `deg` };\n      if (angle.unit === `grad`) return { value: gradianToDegree(angle.value), unit: `deg` };\n      if (angle.unit === `turn`) return { value: turnToDegree(angle.value), unit: `deg` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `grad`:\n      if (angle.unit === `deg`) return { value: degreeToGradian(angle.value), unit: `grad` };\n      if (angle.unit === `rad`) return { value: radianToGradian(angle.value), unit: `grad` };\n      if (angle.unit === `grad`) return angle;\n      if (angle.unit === `turn`) return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `rad`:\n      if (angle.unit === `deg`) return { value: degreeToRadian(angle.value), unit: `rad` };\n      if (angle.unit === `rad`) return angle;\n      if (angle.unit === `grad`) return { value: gradianToRadian(angle.value), unit: `rad` };\n      if (angle.unit === `turn`) return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `turn`:\n      if (angle.unit === `deg`) return { value: degreeToTurn(angle.value), unit: `turn` };\n      if (angle.unit === `rad`) return { value: radianToTurn(angle.value), unit: `turn` };\n      if (angle.unit === `grad`) return { value: radianToTurn(gradianToRadian(angle.value)), unit: `turn` };\n      if (angle.unit === `turn`) return angle;\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    default:\n      throw new Error(`Destination unit unknown ('${ destination }). Expects: deg, grad, rad or turn`);\n  }\n}\n\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so \n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns \n * @param wrap \n * @returns \n */\nexport const turnToDegree = (turns: number, wrap = true) => {\n  if (wrap) return (turns * 360) % 360;\n  return turns * 360;\n}\n\nexport const turnToRadian = (turns: number) => turns * piPi;\nexport const degreeToTurn = (degrees: number) => degrees / 360;\nexport const radianToTurn = (radians: number) => radians / piPi","import type { Point, Point3d } from \"./point-type.js\";\nimport { errorResult, numberTest, resultThrow, type Result } from '@ixfx/guards';\n\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport const isNull = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== null) return false;\n  }\n  return p.x === null && p.y === null;\n}\n\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport const isNaN = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) || Number.isNaN(p.y)\n}\n\nexport function test(p: Point, name = `Point`, extraInfo = ``): Result<Point, string> {\n  if (p === undefined) {\n    return errorResult(`'${ name }' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`, extraInfo);\n  }\n  if (p === null) {\n    return errorResult(\n      `'${ name }' is null. Expected {x,y} got ${ JSON.stringify(p) }`, extraInfo\n    );\n  }\n  if (typeof p !== `object`) return errorResult(\n    `'${ name }' is type '${ typeof p }'. Expected object.`, extraInfo\n  );\n  if (p.x === undefined) {\n    return errorResult(\n      `'${ name }.x' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`, extraInfo\n    );\n  }\n  if (p.y === undefined) {\n    return errorResult(\n      `'${ name }.y' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`, extraInfo\n    );\n  }\n  if (typeof p.x !== `number`) {\n    return errorResult(`'${ name }.x' must be a number. Got ${ typeof p.x }`, extraInfo);\n  }\n  if (typeof p.y !== `number`) {\n    return errorResult(`'${ name }.y' must be a number. Got ${ typeof p.y }`, extraInfo);\n  }\n  if (p.z !== undefined) {\n    if (typeof p.z !== `number`) return errorResult(`${ name }.z must be a number. Got: ${ typeof p.z }`, extraInfo)\n    if (Number.isNaN(p.z)) return errorResult(`'${ name }.z' is NaN. Got: ${ JSON.stringify(p) }`, extraInfo);\n  }\n\n  if (p.x === null) return errorResult(`'${ name }.x' is null`, extraInfo);\n  if (p.y === null) return errorResult(`'${ name }.y' is null`, extraInfo);\n\n  if (Number.isNaN(p.x)) return errorResult(`'${ name }.x' is NaN`, extraInfo);\n  if (Number.isNaN(p.y)) return errorResult(`'${ name }.y' is NaN`, extraInfo);\n\n  return { success: true, value: p }\n}\n\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p: Point, name = `Point`, info?: string) {\n  resultThrow(test(p, name, info))\n  // if (p === undefined) {\n  //   throw new Error(\n  //     `'${ name }' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n  //   );\n  // }\n  // if (p === null) {\n  //   throw new Error(\n  //     `'${ name }' is null. Expected {x,y} got ${ JSON.stringify(p) }`\n  //   );\n  // }\n  // if (p.x === undefined) {\n  //   throw new Error(\n  //     `'${ name }.x' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n  //   );\n  // }\n  // if (p.y === undefined) {\n  //   throw new Error(\n  //     `'${ name }.y' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n  //   );\n  // }\n  // if (typeof p.x !== `number`) {\n\n  //   throw new TypeError(`'${ name }.x' must be a number. Got ${ typeof p.x }`);\n  // }\n  // if (typeof p.y !== `number`) {\n\n  //   throw new TypeError(`'${ name }.y' must be a number. Got ${ typeof p.y }`);\n  // }\n  // if (p.z !== undefined) {\n  //   if (typeof p.z !== `number`) throw new TypeError(`${ name }.z must be a number. Got: ${ typeof p.z }`)\n  //   if (Number.isNaN(p.z)) throw new Error(`'${ name }.z' is NaN. Got: ${ JSON.stringify(p) }`);\n  // }\n\n  // if (p.x === null) throw new Error(`'${ name }.x' is null`);\n  // if (p.y === null) throw new Error(`'${ name }.y' is null`);\n\n  // if (Number.isNaN(p.x)) throw new Error(`'${ name }.x' is NaN`);\n  // if (Number.isNaN(p.y)) throw new Error(`'${ name }.y' is NaN`);\n}\n\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt: Point | Point3d, name = `pt`) => {\n  guard(pt, name);\n  resultThrow(\n    numberTest(pt.x, `nonZero`, `${ name }.x`),\n    numberTest(pt.y, `nonZero`, `${ name }.y`),\n    () => {\n      if (typeof pt.z !== `undefined`) {\n        return numberTest(pt.z, `nonZero`, `${ name }.z`);\n      }\n    }\n  );\n  return true;\n};\n\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p: number | unknown): p is Point {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point).x === undefined) return false;\n  if ((p as Point).y === undefined) return false;\n  return true;\n}\n\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p: Point | unknown): p is Point3d => {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point3d).x === undefined) return false;\n  if ((p as Point3d).y === undefined) return false;\n  if ((p as Point3d).z === undefined) return false;\n  return true;\n};\n\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== 0) return false;\n  }\n  return p.x === 0 && p.y === 0\n\n}\n\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) && Number.isNaN(p.y);\n}\n","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function getTwoPointParameters(a: Point, b: Point): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, b: Point3d): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a: Point, x: number, y: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number) {\n  if (isPoint3d(a1) && isPoint3d(ab2)) return [ a1, ab2 ];\n  if (isPoint(a1) && isPoint(ab2)) return [ a1, ab2 ];\n  if (isPoint3d(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3,\n      z: ab4\n    }\n    if (!isPoint3d(b)) throw new Error(`Expected x, y & z parameters`);\n    return [ a1, b ];\n  }\n  if (isPoint(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3\n    }\n    if (!isPoint(b)) throw new Error(`Expected x & y parameters`);\n    return [ a1, b ];\n  }\n\n  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n    const a = {\n      x: a1,\n      y: ab2,\n      z: ab3\n    };\n    const b = {\n      x: ab4,\n      y: ab5,\n      z: ab6\n    }\n    if (!isPoint3d(a)) throw new Error(`Expected x,y,z for first point`);\n    if (!isPoint3d(b)) throw new Error(`Expected x,y,z for second point`);\n    return [ a, b ];\n  }\n\n  const a = {\n    x: a1,\n    y: ab2\n  };\n  const b = {\n    x: ab3,\n    y: ab4\n  }\n  if (!isPoint(a)) throw new Error(`Expected x,y for first point`);\n  if (!isPoint(b)) throw new Error(`Expected x,y for second point`);\n  return [ a, b ];\n\n}\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from './point-type.js';\nimport { getPointParameter } from \"./get-point-parameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored. To force 2D distance, use {@link distance2d}\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n\n/**\n * As {@distance} but always compares by x,y only.\n * @param a\n * @param xOrB \n * @param y \n * @param z \n * @returns \n */\nexport function distance2d(\n  a: Point,\n  xOrB?: Point | number,\n  y?: number\n): number {\n  const pt = getPointParameter(xOrB, y);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function findMinimum(\n  comparer: (a: Point, b: Point) => Point,\n  ...points: ReadonlyArray<Point>\n): Point;\n\nexport function findMinimum(\n  comparer: (a: Point3d, b: Point3d) => Point3d,\n  ...points: ReadonlyArray<Point3d>\n): Point3d;\n\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport function findMinimum(\n  comparer: ((a: Point, b: Point) => Point)|((a: Point3d, b: Point3d) => Point3d),\n  ...points: ReadonlyArray<Point|Point3d>\n): Point|Point3d  {\n  if (points.length === 0) throw new Error(`No points provided`);\n  let min = points[ 0 ];\n  for (const p of points) {\n    if (isPoint3d(min) && isPoint3d(p)) {\n      min = comparer(min, p);\n    } else {\n      min = comparer(min as any, p as any);\n    }\n  }\n  return min;\n};","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (\n  topLeft: Point,\n  topRight: Point,\n  bottomRight: Point,\n  bottomLeft: Point\n): RectPositioned => {\n  if (topLeft.y > bottomRight.y) {\n    throw new Error(`topLeft.y greater than bottomRight.y`);\n  }\n  if (topLeft.y > bottomLeft.y) {\n    throw new Error(`topLeft.y greater than bottomLeft.y`);\n  }\n\n  const w1 = topRight.x - topLeft.x;\n  const w2 = bottomRight.x - bottomLeft.x;\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\n  const h2 = Math.abs(bottomRight.y - topRight.y);\n  return {\n    x: Math.min(topLeft.x, bottomLeft.x),\n    y: Math.min(topRight.y, topLeft.y),\n    width: Math.max(w1, w2),\n    height: Math.max(h1, h2),\n  };\n};\n","import type { Rect3dPositioned, RectPositioned } from \"../rect/rect-types.js\";\nimport { findMinimum } from \"./find-minimum.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points: ReadonlyArray<Point>): RectPositioned => {\n  const leftMost = findMinimum((a, b) => {\n    return a.x < b.x ? a : b;\n  }, ...points);\n  const rightMost = findMinimum((a, b) => {\n    return a.x > b.x ? a : b;\n  }, ...points);\n  const topMost = findMinimum((a, b) => {\n    return a.y < b.y ? a : b;\n  }, ...points);\n  const bottomMost = findMinimum((a, b) => {\n    return a.y > b.y ? a : b;\n  }, ...points);\n\n  const topLeft = { x: leftMost.x, y: topMost.y };\n  const topRight = { x: rightMost.x, y: topMost.y };\n  const bottomRight = { x: rightMost.x, y: bottomMost.y };\n  const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n  return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\n\nexport const bbox3d = (...points: ReadonlyArray<Point3d>): Rect3dPositioned => {\n  const box = bbox(...points);\n  const zMin = findMinimum((a: Point3d, b: Point3d) => {\n    return a.z < b.z ? a : b\n  }, ...points);\n  const zMax = findMinimum((a: Point3d, b: Point3d) => {\n    return a.z > b.z ? a : b\n  }, ...points);\n\n  return {\n    ...box,\n    z: zMin.z,\n    depth: zMax.z - zMin.z\n  }\n}","import type { Coord } from \"./types.js\";\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};","import { guard } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { degreeToRadian } from '../angles.js';\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c: Coord, amountRadian: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n  });\n\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p: Coord): Coord => {\n  guard(p, `c`);\n  return Object.freeze({\n    ...p,\n    angleRadian: p.angleRadian - Math.PI,\n  });\n};\n\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  if (a.distance !== b.distance) return false;\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === b.angleRadian;\n};\n\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c: Coord, amountDeg: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n  });\n\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function subtract(a: Point, b: Point): Point;\nexport function subtract(a: Point3d, b: Point3d): Point3d;\nexport function subtract(a: Point, x: number, y: number): Point;\nexport function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n * \n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x - ptB.x,\n    y: ptA.y - ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 } as const;\n\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 } as const;\n\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 } as const;\n\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 } as const;","import type { Point } from \"../point/point-type.js\";\nimport { guard, isPolarCoord } from \"./guard.js\";\nimport type { Coord, PolarToCartesian } from \"./types.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n\n/**\n * Converts a polar coordinate to a Line.\n * \n * ```js\n * const line = toLine({ angleRadian: Math.Pi, distance: 0.5 }, { x: 0.2, y: 0.1 });\n * // Yields { a: { x, y}, b: { x, y } }\n * ```\n * \n * The 'start' parameter is taken to be the origin of the Polar coordinate.\n * @param c \n * @param start \n * @returns \n */\nexport const toLine = (c: Coord, start: Point) => {\n  const b = toCartesian(c, start);\n  return { a: start, b }\n}\n\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: PolarToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (typeof b === `undefined`) b = EmptyPoint;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (typeof c === `undefined`) c = EmptyPoint;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  if (typeof point === `undefined`) throw new Error(`Param 'point' missing. Expecting a Point`);\n  if (typeof origin === `undefined`) throw new Error(`Param 'origin' missing. Expecting a Point`);\n\n  point = subtractPoint(point, origin);\n\n  const angle = Math.atan2(point.y, point.x);\n  const distance = Math.hypot(point.x, point.y);\n\n  const polar = {\n    ...point,\n    angleRadian: angle,\n    distance,\n  };\n  delete (polar as any).x;\n  delete (polar as any).y;\n  return Object.freeze(polar);\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = EmptyPoint\n): Point => {\n  guardPoint(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyPoint): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};","import { guard } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { numberTest, resultThrow } from \"@ixfx/guards\"\n\nexport const normalise = (c: Coord): Coord => {\n  //guard(v, `v`);\n  if (c.distance === 0) throw new Error(`Cannot normalise vector of length 0`);\n  return Object.freeze({\n    ...c,\n    distance: 1,\n  });\n};\n\n\n\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v: Coord, max = 1, min = 0): Coord => {\n  let mag = v.distance;\n  if (mag > max) mag = max;\n  if (mag < min) mag = min;\n  return Object.freeze({\n    ...v,\n    distance: mag,\n  });\n};\n\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Coord, b: Coord): number => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n\n\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v: Coord, amt: number): Coord => {\n  guard(v);\n  resultThrow(numberTest(amt, ``, `amt`));\n  return Object.freeze({\n    ...v,\n    distance: v.distance * amt,\n  });\n};\n\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v: Coord, amt: number): Coord => {\n  guard(v);\n  resultThrow(numberTest(amt, ``, `amt`));\n  return Object.freeze({\n    ...v,\n    distance: v.distance / amt,\n  });\n};\n","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}\n\n/**\n * Return the angle of a wedge, defined by a, b and C points, where 'b'\n * could be thought of as the origin or pivot.\n * \n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianThreePoint = (a: Point, b: Point, c: Point) => {\n  const ab = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n  const bc = Math.sqrt(Math.pow(b.x - c.x, 2) + Math.pow(b.y - c.y, 2));\n  const ac = Math.sqrt(Math.pow(c.x - a.x, 2) + Math.pow(c.y - a.y, 2));\n  return Math.acos((bc * bc + ab * ab - ac * ac) / (2 * bc * ab));\n}","import { guard } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (\n  pt: Point,\n  rounder: (x: number) => number = Math.round\n): Point => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    x: rounder(pt.x),\n    y: rounder(pt.y),\n  });\n};\n\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt \n * @returns \n */\nexport const to2d = (pt: Point): Point => {\n  guard(pt, `pt`);\n  let copy = {\n    ...pt\n  };\n  delete copy.z;\n  return Object.freeze(copy);\n}\n\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns \n */\nexport const to3d = (pt: Point, z: number = 0): Point3d => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    ...pt,\n    z\n  });\n}\n\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p: Point, digits?: number): string {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n  guard(p, `pt`);\n\n  const x = digits ? p.x.toFixed(digits) : p.x;\n  const y = digits ? p.y.toFixed(digits) : p.y;\n\n  if (p.z === undefined) {\n    return `(${ x },${ y })`;\n  } else {\n    const z = digits ? p.z.toFixed(digits) : p.z;\n    return `(${ x },${ y },${ z })`;\n  }\n}","import { type Line } from \"../line/line-type.js\";\nimport { type Point } from '../point/point-type.js';\nimport { distance } from '../point/distance.js';\nimport { angleRadian } from '../point/angle.js';\nimport { toString as pointToString } from '../point/To.js';\nimport { type PolarRay } from \"./types.js\";\nimport { toCartesian as polarToCartesian } from \"./conversions.js\";\n\n/**\n * Converts a ray to a Line in cartesian coordinates.\n * \n * By default, the ray's origin is taken to be 0,0.\n * Passing in an origin will override this default, or whatever\n * the ray's origin property is.\n * @param ray Ray\n * @param origin Override or provide origin point\n * @returns \n */\nexport const toCartesian = (ray: PolarRay, origin?: Point): Line => {\n  const o = getOrigin(ray, origin);\n  const a = polarToCartesian(ray.offset, ray.angleRadian, o);\n  const b = polarToCartesian(ray.offset + ray.length, ray.angleRadian, o);\n  return { a, b }\n}\n\nconst getOrigin = (ray: PolarRay, origin?: Point): Point => {\n  if (origin !== undefined) return origin;\n  if (ray.origin !== undefined) return ray.origin;\n  return { x: 0, y: 0 };\n}\n\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray \n * @param origin \n * @returns \n */\n// const withOrigin = (ray: PolarRay, origin?: Point): PolarRayWithOrigin => {\n//   if (origin) {\n//     return {\n//       ...ray,\n//       origin\n//     };\n//   }\n//   if (ray.origin !== undefined) return { ...ray } as PolarRayWithOrigin;\n//   return {\n//     ...ray,\n//     origin: { x: 0, y: 0 }\n//   }\n// }\n\n\n\n// function getAngle(a: Point, b: Point) {\n//   const angle = Math.atan2(b.y - a.y, b.x - a.x);// * (180 / Math.PI) + 90;\n//   return angle;//return (angle < 0) ? scale(angle, -90, 0, 0, piPi) : angle;\n// }\n\n/**\n * Returns a string representation of the ray, useful for debugging.\n * \n * ```\n * \"PolarRay(angle: ... offset: ... len: ... origin: ...)\"\n * ```\n * @param ray \n * @returns \n */\nexport const toString = (ray: PolarRay): string => {\n  let basic = `PolarRay(angle: ${ ray.angleRadian } offset: ${ ray.offset } len: ${ ray.length }`;\n  if (ray.origin) {\n    basic += ` origin: ${ pointToString(ray.origin) }`;\n  }\n  basic += `)`;\n  return basic;\n}\n\n/**\n * Returns a PolarRay based on a line and origin.\n * \n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * Otherwise, the origin value is used to determine the 'offset' of the ray.\n * @param line \n * @param origin \n * @returns \n */\nexport const fromLine = (line: Line, origin?: Point): PolarRay => {\n  const o = origin ?? line.a;\n  return {\n    angleRadian: angleRadian(line.b, o),\n    offset: distance(line.a, o),\n    length: distance(line.b, line.a),\n    origin: o\n  }\n}\n\n","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\n\nimport type { Coord } from \"./types.js\";\n\nexport function* spiral(\n  smoothness: number,\n  zoom: number\n): IterableIterator<Coord & { readonly step: number }> {\n  let step = 0;\n\n  while (true) {\n    const a = smoothness * step++;\n    yield {\n      distance: zoom * a,\n      angleRadian: a,\n      step: step,\n    };\n  }\n}\n\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (\n  step: number,\n  smoothness: number,\n  zoom: number\n): Coord => {\n  const a = smoothness * step;\n  return Object.freeze({\n    distance: zoom * a,\n    angleRadian: a,\n  });\n};","// import { degreeToRadian, radianToDegree } from '../Angles.js';\n\n// import type { Point } from '../point/PointType.js';\n// import { subtract } from '../point/Subtract.js';\n// import { Empty } from '../point/Empty.js';\n// import { isPoint, guard as PointGuard } from '../point/Guard.js';\n// import type { Coord } from './Types.js';\n\n//const EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nexport type * from './types.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js'\n\n\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import { degreeToRadian, radianArc, radiansSum } from '../angles.js';\nimport { guard as guardPoint, isPoint } from '../point/guard.js';\nimport { distance as pointsDistance } from '../point/distance.js';\nimport { bbox as pointsBbox } from '../point/bbox.js';\nimport { toCartesian } from '../polar/index.js';\nimport type { Point } from '../point/point-type.js';\nimport type { Line } from '../line/line-type.js';\nimport type { Path } from '../path/path-type.js';\nimport type { Rect, RectPositioned } from '../rect/rect-types.js';\nimport { fromPoints as LinesFromPoints } from '../line/from-points.js';\nimport type { Arc, ArcInterpolate, ArcPositioned, ArcSvgOpts, ArcToSvg } from './arc-type.js';\nimport type { CirclePositioned } from '../circle/circle-type.js';\nimport { piPi } from '../pi.js';\n\nexport type * from './arc-type.js';\n\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns \n */\nexport const isArc = (p: unknown): p is Arc => typeof (p as Arc).startRadian !== `undefined` && typeof (p as Arc).endRadian !== `undefined` && typeof (p as Arc).clockwise !== `undefined`;\n\n/**\n * Returns true if parameter has a positioned (x,y) \n * @param p Point, Arc or ArcPositiond\n * @returns \n */\nexport const isPositioned = (p: Point | Arc | ArcPositioned): p is Point => typeof (p as Point).x !== `undefined` && typeof (p as Point).y !== `undefined`;\n\n//const piPi = Math.PI * 2;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean): Arc;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */export function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin: Point): ArcPositioned\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin?: Point): Arc | ArcPositioned {\n  const a: Arc = {\n    radius,\n    startRadian: degreeToRadian(startDegrees),\n    endRadian: degreeToRadian(endDegrees),\n    clockwise\n  };\n  if (isPoint(origin)) {\n    guardPoint(origin);\n    const ap: ArcPositioned = {\n      ...a,\n      x: origin.x,\n      y: origin.y\n    };\n    return Object.freeze(ap);\n  } else {\n    return Object.freeze(a);\n  }\n}\n\n/**\n * Returns a {@link Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc: ArcPositioned): Line => LinesFromPoints(\n  point(arc, arc.startRadian),\n  point(arc, arc.endRadian)\n);\n\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n * \n * See also: \n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc \n * @param origin \n * @returns \n */\nexport const getStartEnd = (arc: ArcPositioned | Arc, origin?: Point): [ start: Point, end: Point ] => {\n  guard(arc);\n  const start = point(arc, arc.startRadian, origin);\n  const end = point(arc, arc.endRadian, origin);\n  return [ start, end ];\n}\n\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n * \n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate \n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point): Point => {\n\n  if (typeof origin === `undefined`) {\n    origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n    y: (Math.sin(angleRadian) * arc.radius) + origin.y\n  };\n};\n\n/**\n * Throws an error if arc instance is invalid\n * @param arc \n */\nexport const guard = (arc: Arc | ArcPositioned) => {\n  if (typeof arc === `undefined`) throw new TypeError(`Arc is undefined`);\n  if (isPositioned(arc)) {\n    guardPoint(arc, `arc`);\n  }\n  if (typeof arc.radius === `undefined`) throw new TypeError(`Arc radius is undefined (${ JSON.stringify(arc) })`);\n  if (typeof arc.radius !== `number`) throw new TypeError(`Radius must be a number`);\n  if (Number.isNaN(arc.radius)) throw new TypeError(`Radius is NaN`);\n  if (arc.radius <= 0) throw new TypeError(`Radius must be greater than zero`);\n\n  if (typeof arc.startRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);\n  if (typeof arc.endRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);\n  if (Number.isNaN(arc.endRadian)) throw new TypeError(`Arc endRadian is NaN`);\n  if (Number.isNaN(arc.startRadian)) throw new TypeError(`Arc endRadian is NaN`);\n\n  if (typeof arc.clockwise === `undefined`) throw new TypeError(`Arc is missing 'clockwise field`);\n  if (arc.startRadian >= arc.endRadian) throw new TypeError(`startRadian is expected to be les than endRadian`);\n};\n\n\n\n\n/**\n * Compute relative position on arc.\n * \n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns \n */\nexport const interpolate: ArcInterpolate = (amount: number, arc: ArcPositioned | Arc, allowOverflow?: boolean, origin?: Point): Point => {\n  guard(arc);\n  const overflowOk = allowOverflow ?? false;\n  if (!overflowOk) {\n    if (amount < 0) throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);\n    if (amount > 1) throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);\n  }\n  const span = angularSize(arc); // angular size\n  const rel = span * amount;\n  const angle = radiansSum(arc.startRadian, rel, arc.clockwise);\n  //console.log(`interpolate span: ${ span.toFixed(2) } rel: ${ rel.toFixed(2) } angle: ${ angle.toFixed(2) } amt: ${ amount.toFixed(2) } cw: ${ arc.clockwise } start: ${ arc.startRadian }`);\n  return point(arc, angle, origin);\n  //return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc \n */\nexport const angularSize = (arc: Arc) => radianArc(arc.startRadian, arc.endRadian, arc.clockwise)\n\n/**\n * Creates a {@link Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc \n * @returns Path\n */\nexport const toPath = (arc: ArcPositioned): Path => {\n  guard(arc);\n\n  return Object.freeze({\n    ...arc,\n    nearest: (_point: Point) => { throw new Error(`not implemented`); },\n    interpolate: (amount: number) => interpolate(amount, arc),\n    bbox: () => bbox(arc) as RectPositioned,\n    length: () => length(arc),\n    toSvgString: () => toSvg(arc),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `arc`\n  });\n};\n\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns \n */\nexport const fromCircle = (circle: CirclePositioned, startRadian: number, endRadian: number, clockwise = true): ArcPositioned => {\n  const a: ArcPositioned = Object.freeze({\n    ...circle,\n    endRadian,\n    startRadian,\n    clockwise\n  });\n  return a;\n}\n\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns \n */\nexport const fromCircleAmount = (circle: CirclePositioned, startRadian: number, sizeRadian: number, clockwise = true): ArcPositioned => {\n  const endRadian = radiansSum(startRadian, sizeRadian, clockwise);\n  return fromCircle(circle, startRadian, endRadian)\n}\n\n\n/**\n * Calculates the length of the arc\n * @param arc \n * @returns Length\n */\nexport const length = (arc: Arc): number => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n\n/**\n * Calculates a {@link Rect} bounding box for arc.\n * @param arc \n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc: ArcPositioned | Arc): RectPositioned | Rect => {\n  if (isPositioned(arc)) {\n    const middle = interpolate(0.5, arc);\n    const asLine = toLine(arc);\n    return pointsBbox(middle, asLine.a, asLine.b);\n  } else {\n    return {\n      width: arc.radius * 2,\n      height: arc.radius * 2\n    };\n  }\n};\n\n\n\n\n\n/**\n * Creates an SV path snippet for arc\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg: ArcToSvg = (a: Point | Arc | ArcPositioned, b?: number | Point | ArcSvgOpts, c?: number | ArcSvgOpts, d?: number, e?: ArcSvgOpts) => {\n  if (isArc(a)) {\n    if (isPositioned(a)) {\n      if (isPoint(b)) {\n        // Passing in a origin override\n        return toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as ArcSvgOpts)\n      } else {\n        // Using origin in arc\n        return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b as ArcSvgOpts);\n      }\n    } else {\n      return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as ArcSvgOpts) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n    }\n  } else {\n    if (c === undefined) throw new Error(`startAngle undefined`);\n    if (d === undefined) throw new Error(`endAngle undefined`);\n\n    if (isPoint(a)) {\n      if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n        return toSvgFull(a, b, c, d, e);\n      } else {\n        throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n      }\n    } else {\n      throw new Error(`Expected (point, number, number, number). Missing first point.`);\n    }\n  }\n};\n\n\n\nconst toSvgFull = (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: ArcSvgOpts): readonly string[] => {\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n  // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n  // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n\n  if (opts === undefined || typeof opts !== `object`) opts = {};\n\n  const isFullCircle = endRadian - startRadian === 360;\n  const start = toCartesian(radius, endRadian - 0.01, origin);\n  const end = toCartesian(radius, startRadian, origin);\n\n  const { largeArc = false, sweep = false } = opts;\n\n  const d = [ `\n    M ${ start.x } ${ start.y }\n    A ${ radius } ${ radius } 0 ${ largeArc ? `1` : `0` } ${ sweep ? `1` : `0` } ${ end.x } ${ end.y },\n  `];\n\n  if (isFullCircle) d.push(`z`);\n\n  return d;\n};\n\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b \n * @returns Distance \n */\nexport const distanceCenter = (a: ArcPositioned, b: ArcPositioned): number => pointsDistance(a, b);\n\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a: Arc | ArcPositioned, b: Arc | ArcPositioned): boolean => {\n  if (a.radius !== b.radius) return false;\n  if (a.endRadian !== b.endRadian) return false;\n  if (a.startRadian !== b.startRadian) return false;\n  if (a.clockwise !== b.clockwise) return false;\n\n  if (isPositioned(a) && isPositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return true;\n};","import { isPoint } from \"../point/guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/point-type.js\";\nimport { isLine } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/point-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n\n/**\n * Returns the length between two points\n * ```js\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point, force2d?: boolean): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine, force2d?: boolean): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n\nexport function length(aOrLine: Point | Line | PolyLine, pointBOrForce2d?: Point | boolean, force2d?: boolean): number {\n  if (isPolyLine(aOrLine)) {\n    const _force2d = typeof pointBOrForce2d === `boolean` ? pointBOrForce2d : false;\n    const sum = aOrLine.reduce((accumulator, v) => length(v, _force2d) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = typeof pointBOrForce2d === `object` ? getPointParameter(aOrLine, pointBOrForce2d) : getPointParameter(aOrLine);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  const _force2d = typeof pointBOrForce2d === `boolean` ? pointBOrForce2d :\n    typeof force2d === `boolean` ? force2d : false;\n  if (!_force2d && a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { guard } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\n\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line \n * @returns \n */\nexport function reverse(line: Line): Line {\n  guard(line, `line`);\n  return { a: line.b, b: line.a };\n}","import { numberTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n\n  if (!allowOverflow) resultThrow(percentTest(amount, `amount`));\n  else resultThrow(numberTest(amount, ``, `amount`));\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns \n */\nexport function pointAtDistance(line: Line, distance: number, fromA = true): Point {\n  if (!fromA) line = reverse(line);\n\n  const dx = line.b.x - line.a.x;\n  const dy = line.b.y - line.a.y;\n  const theta = Math.atan2(dy, dx);\n  const xp = distance * Math.cos(theta);\n  const yp = distance * Math.sin(theta);\n  return { x: xp + line.a.x, y: yp + line.a.y };\n}","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d \n * @param name \n */\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n * \n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *  \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect \n * @param name \n */\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect \n * @returns \n */\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\n\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect \n * @returns \n */\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  rect: Point | Rect | RectPositioned\n): rect is Point =>\n  (rect as Point).x !== undefined && (rect as Point).y !== undefined;\n\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect: unknown): rect is Rect => {\n  if (rect === undefined) return false;\n  if ((rect as Rect).width === undefined) return false;\n  if ((rect as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (\n  rect: any\n): rect is RectPositioned => isRect(rect) && isPositioned(rect);\n","import type { Point } from \"../point/point-type.js\";\nimport { guardDim } from \"./guard.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import { guard as guardPoint } from '../point/guard.js';\nimport type { Point } from '../point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle-type.js';\n\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle \n * @param parameterName \n */\nexport const guard = (circle: CirclePositioned | Circle, parameterName = `circle`) => {\n  if (isCirclePositioned(circle)) {\n    guardPoint(circle, `circle`);\n  }\n\n  if (Number.isNaN(circle.radius)) throw new Error(`${ parameterName }.radius is NaN`);\n  if (circle.radius <= 0) throw new Error(`${ parameterName }.radius must be greater than zero`);\n};\n\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle \n * @param parameterName \n * @returns \n */\nexport const guardPositioned = (circle: CirclePositioned, parameterName = `circle`) => {\n  if (!isCirclePositioned(circle)) throw new Error(`Expected a positioned circle with x,y`);\n  guard(circle, parameterName);\n};\n\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a: Circle | CirclePositioned): boolean => {\n  if (Number.isNaN(a.radius)) return true;\n  if (isCirclePositioned(a)) {\n    if (Number.isNaN(a.x)) return true;\n    if (Number.isNaN(a.y)) return true;\n  }\n  return false;\n};\n\n\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n * \n * ```js\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n * \n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns \n */\nexport const isPositioned = (p: Circle | Point): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n\nexport const isCircle = (p: any): p is Circle => (p as Circle).radius !== undefined;\n\nexport const isCirclePositioned = (p: any): p is CirclePositioned => isCircle(p) && isPositioned(p);","import type { Circle } from \"./circle-type.js\";\nimport { guard } from \"./guard.js\";\n\n/**\n * Returns the area of `circle`.\n * @param circle \n * @returns \n */\nexport const area = (circle: Circle) => {\n  guard(circle);\n  return Math.PI * circle.radius * circle.radius;\n};","import { type RectPositioned } from \"./rect-types.js\";\n\nimport type { Point } from \"../point/point-type.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { guardDim } from \"./guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  PointsGuard(origin, `origin`);\n\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n\n  const halfW = width / 2;\n  const halfH = height / 2;\n  return {\n    x: origin.x - halfW,\n    y: origin.y - halfH,\n    width: width,\n    height: height,\n  };\n};","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/from-center.js';\nimport type { RectPositioned } from \"../rect/rect-types.js\";\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns \n */\nexport const bbox = (circle: CirclePositioned | Circle): RectPositioned => {\n  return isCirclePositioned(circle) ?\n    RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n    { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\n\n/**\n * Returns the center of a circle\n * \n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n * \n * ```js\n * const circle = { radius: 5, x: 10, y: 10};\n * \n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n * \n * It's a trivial function, but can make for more understandable code\n * @param circle \n * @returns Center of circle\n */\nexport const center = (circle: CirclePositioned | Circle) => {\n  return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};","import type { CirclePositioned } from \"./circle-type.js\";\nimport { distance as pointsDistance } from '../point/distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns the distance between two circle centers.\n * \n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a \n * @param b \n * @returns Distance\n */\nexport const distanceCenter = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    guardPositioned(b, `b`);\n  }\n  return pointsDistance(a, b);\n};\n","import type { CirclePositioned } from \"./circle-type.js\";\nimport { distanceCenter } from \"./distance-center.js\";\nimport { isPoint as PointsIsPoint } from \"../point/guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n * \n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b \n */\nexport const distanceFromExterior = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n  } else if (PointsIsPoint(b)) {\n    const distribution = PointsDistance(a, b);\n    if (distribution < a.radius) return 0;\n    return distribution;\n  } else throw new Error(`Second parameter invalid type`);\n};","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\n\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n * \n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const { x, y, radius } = circle;\n\n  let xx = radius;\n  let yy = 0;\n  let radiusError = 1 - x;\n  while (xx >= yy) {\n    yield { x: xx + x, y: yy + y };\n    yield { x: yy + x, y: xx + y };\n    yield { x: -xx + x, y: yy + y };\n    yield { x: -yy + x, y: xx + y };\n    yield { x: -xx + x, y: -yy + y };\n    yield { x: -yy + x, y: -xx + y };\n    yield { x: xx + x, y: -yy + y };\n    yield { x: yy + x, y: -xx + y }\n    yy++;\n    if (radiusError < 0) {\n      radiusError += 2 * yy + 1;\n    } else {\n      xx--;\n      radiusError += 2 * (yy - xx + 1);\n    }\n  }\n}\n\n","import type { CirclePositioned } from \"./circle-type.js\";\nimport { distance } from \"../point/distance.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns all integer points contained within `circle`.\n * \n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const xMin = circle.x - circle.radius;\n  const xMax = circle.x + circle.radius;\n  const yMin = circle.y - circle.radius;\n  const yMax = circle.y + circle.radius;\n  for (let x = xMin; x < xMax; x++) {\n    for (let y = yMin; y < yMax; y++) {\n      const r = Math.abs(distance(circle, x, y));\n      if (r <= circle.radius) yield { x, y };\n    }\n  }\n}","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport { guard, isCirclePositioned } from \"./guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\nconst piPi = Math.PI * 2;\n\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n * \n * ```js\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n * \n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle: CirclePositioned | readonly CirclePositioned[], point: Point): Point => {\n  const n = (a: CirclePositioned): Point => {\n    const l = Math.sqrt(Math.pow(point.x - a.x, 2) + Math.pow(point.y - a.y, 2));\n    const x = a.x + (a.radius * ((point.x - a.x) / l));\n    const y = a.y + (a.radius * ((point.y - a.y) / l));\n    return { x, y };\n  };\n\n  if (Array.isArray(circle)) {\n    const pts = circle.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(circle as CirclePositioned));\n  }\n};\n\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n * \n * ```js\n * // Circle without position\n * const circleA = { radius: 5 };\n * \n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n * \n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point): Point => {\n  if (origin === undefined) {\n    origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n    y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n  };\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle \n * @returns \n */\nexport const circumference = (circle: Circle): number => {\n  guard(circle);\n  return piPi * circle.radius;\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle \n * @returns \n */\nexport const length = (circle: Circle): number => circumference(circle);\n","import type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport { pointOnPerimeter } from \"./perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n * \n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * \n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle \n * @param t Position, 0-1\n * @returns \n */\nexport const interpolate = (circle: CirclePositioned, t: number): Point => pointOnPerimeter(circle, t * piPi);\n","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\n\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n * \n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n * \n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: CirclePositioned | Circle, b: CirclePositioned | Circle): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isCirclePositioned(a) && isCirclePositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return false;\n};","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { isEqual } from \"./is-equal.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { subtract as PointsSubtract } from \"../point/subtract.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Line } from \"../line/line-type.js\";\n\n/**\n * Returns the point(s) of intersection between a circle and line.\n * \n * ```js\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle \n * @param line \n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle: CirclePositioned, line: Line): readonly Point[] => {\n  const v1 = {\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n  };\n  const v2 = {\n    x: line.a.x - circle.x,\n    y: line.a.y - circle.y\n  };\n\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n  if (Number.isNaN(d)) return []; // no intercept\n\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  const u2 = (b + d) / c;\n\n  const returnValue: Point[] = [];\n  if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment\n    returnValue.push({\n      x: line.a.x + v1.x * u1,\n      y: line.a.y + v1.y * u1\n    });\n  }\n  if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\n    returnValue.push({\n      x: line.a.x + v1.x * u2,\n      y: line.a.y + v1.y * u2\n    });\n  }\n  return returnValue;\n};\n\n\n/**\n * \n * Returns the points of intersection betweeen `a` and `b`.\n * \n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a: CirclePositioned, b: CirclePositioned): readonly Point[] => {\n  const vector = PointsSubtract(b, a);\n  const centerD = Math.hypot((vector.y), (vector.x));\n\n  // Do not intersect\n  if (centerD > a.radius + b.radius) return [];\n\n  // Circle contains another\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\n\n  // Circles are the same\n  if (isEqual(a, b)) return [];\n\n  const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n  const centroid = {\n    x: a.x + (vector.x * centroidD / centerD),\n    y: a.y + (vector.y * centroidD / centerD)\n  };\n\n  const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n\n  const intersection = {\n    x: -vector.y * (centroidIntersectionD / centerD),\n    y: vector.x * (centroidIntersectionD / centerD)\n  };\n  return [\n    PointsSum(centroid, intersection),\n    PointsSubtract(centroid, intersection)\n  ];\n};\n","import { intersections as circleIntersections } from \"./circle/intersections.js\";\nimport type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { RectPositioned } from \"./rect/index.js\";\n\nexport const circleRect = (a: CirclePositioned, b: RectPositioned) => {\n  // https://yal.cc/rectangle-circle-intersection-test/\n  const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n  const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n  return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\n\nexport const circleCircle = (a: CirclePositioned, b: CirclePositioned) => circleIntersections(a, b).length === 2;","import { isPoint } from \"../point/guard.js\";\nimport { distanceCenter } from \"./distance-center.js\";\nimport { isCircle } from \"./guard.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n * \n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n * \n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a: CirclePositioned, b: CirclePositioned | Point, c?: number): boolean => {\n  const d = distanceCenter(a, b);\n  if (isCircle(b)) {\n    return (d < Math.abs(a.radius - b.radius));\n  } else if (isPoint(b)) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (c === undefined) {\n      return d <= a.radius;\n    } else {\n      // Defining a circle\n      return (d < Math.abs(a.radius - c));\n    }\n  } else throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import type { Point } from \"./point-type.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import type { CirclePositioned } from \"./circle-type.js\";\nimport * as Intersects from '../intersects.js';\nimport { isContainedBy } from \"./is-contained-by.js\";\nimport { isCircle } from \"./guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\nimport type { Point } from '../point/point-type.js';\nimport { isPoint } from '../point/guard.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n * \n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number): boolean => {\n  if (PointsIsEqual(a, b)) return true;\n  if (isContainedBy(a, b, c)) return true;\n  if (isCircle(b)) {\n    return Intersects.circleCircle(a, b);\n  } else if (isRectPositioned(b)) {\n    return Intersects.circleRect(a, b);\n  } else if (isPoint(b) && c !== undefined) {\n    return Intersects.circleCircle(a, { ...b, radius: c });\n  }\n  return false;\n};","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function multiply(a: Point, b: Point): Point;\nexport function multiply(a: Point3d, b: Point3d): Point3d;\nexport function multiply(a: Point, x: number, y: number): Point;\nexport function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x * ptB.x,\n    y: ptA.y * ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/multiply.js';\n\nexport function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport function multiplyScalar(a: Circle, value: number): Circle;\n\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n * \n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n * \n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a: Circle | CirclePositioned, value: number): Circle | CirclePositioned {\n  if (isCirclePositioned(a)) {\n    const pt = PointsMultiplyScalar(a, value);\n    return Object.freeze({\n      ...a,\n      ...pt,\n      radius: a.radius * value\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      radius: a.radius * value\n    });\n  }\n}\n\n","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/index.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n * \n * By default creates a uniform distribution.\n * \n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n * \n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns \n */\nexport const randomPoint = (within: Circle | CirclePositioned, opts: Partial<CircleRandomPointOpts> = {}): Point => {\n  const offset: Point = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n  const strategy = opts.strategy ?? `uniform`;\n  const margin = opts.margin ?? 0;\n  const radius = within.radius - margin;\n  const rand = opts.randomSource ?? Math.random;\n  switch (strategy) {\n    case `naive`: {\n      return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n    }\n    case `uniform`: {\n      return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n    }\n    default: {\n\n      throw new Error(`Unknown strategy '${ strategy }'. Expects 'uniform' or 'naive'`);\n    }\n  }\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleToSvg } from \"./circle-type.js\";\nimport { isCircle, isCirclePositioned } from \"./guard.js\";\n\n\n\n\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns \n */\nexport const toSvg: CircleToSvg = (a: CirclePositioned | number | Circle, sweep: boolean, origin?: Point): readonly string[] => {\n  if (isCircle(a)) {\n    if (origin !== undefined) {\n      return toSvgFull(a.radius, origin, sweep);\n    }\n    if (isCirclePositioned(a)) {\n      return toSvgFull(a.radius, a, sweep);\n    } else throw new Error(`origin parameter needed for non-positioned circle`);\n  } else {\n    if (origin === undefined) { throw new Error(`origin parameter needed`); } else {\n      return toSvgFull(a, origin, sweep);\n    }\n  }\n};\n\nconst toSvgFull = (radius: number, origin: Point, sweep: boolean): readonly string[] => {\n  // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n  const { x, y } = origin;\n  const s = sweep ? `1` : `0`;\n  return `\n    M ${ x }, ${ y }\n    m -${ radius }, 0\n    a ${ radius },${ radius } 0 1,${ s } ${ radius * 2 },0\n    a ${ radius },${ radius } 0 1,${ s } -${ radius * 2 },0\n  `.split(`\\n`);\n};\n","import type { Point } from \"../point/point-type.js\";\nimport { bbox } from \"./bbox.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { CircularPath } from \"./circular-path.js\";\nimport { guard } from \"./guard.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport { nearest } from \"./perimeter.js\";\nimport { toSvg } from \"./svg.js\";\nimport { circumference } from \"./perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle: CirclePositioned): CircularPath => {\n  guard(circle);\n\n  return {\n    ...circle,\n    nearest: (point: Point) => nearest(circle, point),\n    /**\n     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n     * @param {t} Relative (0.0-1.0) point\n     * @returns {Point} X,y\n     */\n    interpolate: (t: number) => interpolate(circle, t),\n    bbox: () => bbox(circle),\n    length: () => circumference(circle),\n    toSvgString: (sweep = true) => toSvg(circle, sweep),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `circular`\n  };\n};","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport type { Point } from '../point/point-type.js';\nimport { getPointParameter } from \"../point/get-point-parameter.js\";\n\n\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle \n * @param defaultPositionOrX \n * @param y \n * @returns \n */\nexport const toPositioned = (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number): CirclePositioned => {\n  if (isCirclePositioned(circle)) return circle;\n\n  // Returns 0,0 if params are undefined\n  const pt = getPointParameter(defaultPositionOrX, y);\n  return Object.freeze({\n    ...circle,\n    ...pt\n  });\n};","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport type * from './circle-type.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n\n","import type { Grid, GridCell } from \"./types.js\";\n\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid: Grid, cell: GridCell): boolean => {\n  if (cell.x < 0 || cell.y < 0) return false;\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\n  return true;\n};\n\n\n","import { inside } from \"./inside.js\";\nimport type { GridCell, Grid } from \"./types.js\";\n\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell: GridCell | undefined): cell is GridCell => {\n  if (cell === undefined) return false;\n  return `x` in cell && `y` in cell;\n};\n\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (\n  cell: GridCell,\n  parameterName = `Param`,\n  grid?: Grid\n) => {\n  if (cell === undefined) {\n    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n  }\n  if (cell.x === undefined) throw new Error(parameterName + `.x is undefined`);\n  if (cell.y === undefined) throw new Error(parameterName + `.y is undefined`);\n  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);\n  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);\n  if (!Number.isInteger(cell.x)) {\n    throw new TypeError(parameterName + `.x is non-integer`);\n  }\n  if (!Number.isInteger(cell.y)) {\n    throw new TypeError(parameterName + `.y is non-integer`);\n  }\n  if (grid !== undefined && !inside(grid, cell)) {\n    throw new Error(\n      `${ parameterName } is outside of grid. Cell: ${ cell.x },${ cell.y } Grid: ${ grid.cols }, ${ grid.rows }`\n    );\n  }\n};\n\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid: Grid, parameterName = `Param`) => {\n  if (grid === undefined) {\n    throw new Error(`${ parameterName } is undefined. Expecting grid.`);\n  }\n  if (!(`rows` in grid)) throw new Error(`${ parameterName }.rows is undefined`);\n  if (!(`cols` in grid)) throw new Error(`${ parameterName }.cols is undefined`);\n\n  if (!Number.isInteger(grid.rows)) {\n    throw new TypeError(`${ parameterName }.rows is not an integer`);\n  }\n  if (!Number.isInteger(grid.cols)) {\n    throw new TypeError(`${ parameterName }.cols is not an integer`);\n  }\n};","import { clampIndex } from \"@ixfx/numbers\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport type { GridBoundsLogic, GridCell, Grid } from \"./types.js\";\n\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid \n * @param cell \n * @param wrap \n * @returns \n */\nexport const applyBounds = function (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  guardGrid(grid, `grid`);\n  guardCell(cell, `cell`);\n\n  let x = cell.x;\n  let y = cell.y;\n  switch (wrap) {\n    case `wrap`: {\n      x = x % grid.cols;\n      y = y % grid.rows;\n      if (x < 0) x = grid.cols + x;\n      else if (x >= grid.cols) {\n        x -= grid.cols;\n      }\n      if (y < 0) y = grid.rows + y;\n      else if (y >= grid.rows) {\n        y -= grid.rows;\n      }\n      x = Math.abs(x);\n      y = Math.abs(y);\n      break;\n    }\n    case `stop`: {\n      x = clampIndex(x, grid.cols);\n      y = clampIndex(y, grid.rows);\n      break;\n    }\n    case `undefined`: {\n      if (x < 0 || y < 0) return;\n      if (x >= grid.cols || y >= grid.rows) return;\n      break;\n    }\n    case `unbounded`: {\n      break;\n    }\n    default: {\n      throw new Error(`Unknown BoundsLogic '${ wrap }'. Expected: wrap, stop, undefined or unbounded`);\n    }\n  }\n  return Object.freeze({ x, y });\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { indexFromCell } from \"./index.js\";\nimport type { GridCellAccessor, GridCell, GridBoundsLogic, Grid, GridCellSetter, GridReadable, GridWritable, GridArray1d } from \"./types.js\";\n\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n * \n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array \n * @param cols \n * @returns \n */\nexport const access = <V>(\n  array: readonly V[],\n  cols: number\n): GridCellAccessor<V> => {\n  const grid = gridFromArrayDimensions(array, cols);\n\n  const fn: GridCellAccessor<V> = (\n    cell: GridCell,\n    wrap: GridBoundsLogic = `undefined`\n  ): V | undefined => accessWithGrid(grid, array, cell, wrap);\n  return fn;\n};\n\nconst accessWithGrid = <T>(grid: Grid, array: readonly T[] | T[], cell: GridCell, wrap: GridBoundsLogic) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) return undefined;\n  return array[ index ];\n}\n\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n * \n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array \n * @param cols \n * @returns \n */\nexport const setMutate = <V>(\n  array: V[],\n  cols: number\n): GridCellSetter<V> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setMutateWithGrid = <V>(\n  grid: Grid,\n  array: V[],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  array[ index ] = value;\n  return array;\n}\n\nexport const set = <V>(\n  array: readonly V[],\n  cols: number\n) => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic) => setWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setWithGrid = <V>(\n  grid: Grid,\n  array: readonly V[],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  const copy = [ ...array ];\n  copy[ index ] = value;\n  array = copy;\n  return copy;\n}\n\n/**\n * Creates a {@link Grid} from the basis of an array and a given number of columns\n * @param array \n * @param cols \n * @returns \n */\nconst gridFromArrayDimensions = <T>(array: readonly T[] | T[], cols: number): Grid => {\n  const grid = { cols, rows: Math.ceil(array.length / cols) };\n  return grid;\n}\n\n\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *  \n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n * \n * Use {@link wrap} for an immutable version.\n * \n * @param array Array to wrap\n * @param cols Width of grid\n * @returns \n */\nexport const wrapMutable = <T>(array: T[], cols: number): GridArray1d<T> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return {\n    ...grid,\n    get: access(array, cols),\n    set: setMutate(array, cols),\n    get array() {\n      return array;\n    }\n  }\n}\n\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n * \n * ```js\n * const myArray = [\n *    `a`, `b`, `c`, \n *    `d`, `e`, `f` \n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n * \n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n * \n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns \n */\nexport const wrap = <T>(array: T[], cols: number): GridArray1d<T> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return {\n    ...grid,\n    get: (cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n    set: (value: T, cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => {\n      array = setWithGrid(grid, array, value, cell, boundsLogic);\n      return wrap(array, cols);\n    },\n    get array() {\n      return array;\n    }\n  }\n}\n\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n * \n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n * \n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport const createArray = <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number): T[] => {\n  const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n  if (!cols) throw new Error(`Parameter 'columns' missing`);\n  resultThrow(\n    integerTest(rows, `aboveZero`, `rows`),\n    integerTest(cols, `aboveZero`, `cols`)\n  );\n\n  const t: T[] = [];\n  const total = rows * cols;\n  for (let index = 0; index < total; index++) {\n    t[ index ] = initialValue;\n  }\n  return t;\n}\n\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n * \n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue \n * @param rowsOrGrid \n * @param columns \n * @returns \n */\nexport const createMutable = <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number): GridArray1d<T> => {\n  const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n  if (!cols) throw new Error(`Parameter 'columns' missing`);\n  const array = createArray(initialValue, rows, cols);\n  return wrapMutable(array, cols);\n}\n","import { applyBounds } from \"./apply-bounds.js\";\nimport type { GridBoundsLogic, GridCell, GridCellAccessor, GridCellSetter, Grid, GridReadable, GridWritable } from \"./types.js\";\n\nexport type ArrayGrid<T> = GridReadable<T> & GridWritable<T> & {\n  array: T[][]\n}\n\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array \n * @returns \n */\nexport const create = <T>(array: ReadonlyArray<T[]> | Array<T[]>): Grid => {\n  let colLen = NaN;\n  for (const row of array) {\n    if (Number.isNaN(colLen)) {\n      colLen = row.length;\n    } else {\n      if (colLen !== row.length) throw new Error(`Array does not have uniform column length`);\n    }\n  }\n\n  return { rows: array.length, cols: colLen };\n}\n\nexport const setMutate = <V>(\n  array: V[][]\n): GridCellSetter<V> => {\n  const grid = create(array);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n}\n\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.Array2d.setMutateWithGrid(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\nconst setMutateWithGrid = <V>(\n  grid: Grid,\n  array: V[][],\n  value: V, cell: GridCell, bounds: GridBoundsLogic\n) => {\n  let boundCell = applyBounds(grid, cell, bounds);\n  if (boundCell === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  array[ boundCell.y ][ boundCell.x ] = value;\n  return array;\n}\n// export const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n//   const fn = (v: V, position: Cell) => {\n//     const pos = cellAtPoint(grid, position);\n//     if (pos === undefined) {\n//       throw new Error(\n//         `Position does not exist. Pos: ${ JSON.stringify(\n//           position\n//         ) } Grid: ${ JSON.stringify(grid) }`\n//       );\n//     }\n//     array[ pos.y ][ pos.x ] = v;\n//   };\n//   return fn;\n// };\n\nexport const access = <T>(\n  array: ReadonlyArray<T[]>\n): GridCellAccessor<T> => {\n  const grid = create(array);\n\n  const fn: GridCellAccessor<T> = (\n    cell: GridCell,\n    wrap: GridBoundsLogic = `undefined`\n  ): T | undefined => accessWithGrid(grid, array, cell, wrap);\n  return fn;\n};\n\nconst accessWithGrid = <T>(grid: Grid, array: ReadonlyArray<T[]> | Array<T[]>, cell: GridCell, wrap: GridBoundsLogic) => {\n  let boundCell = applyBounds(grid, cell, wrap);\n  if (boundCell === undefined) return undefined;\n  return array[ boundCell.y ][ boundCell.x ];\n}\n\nexport const wrapMutable = <T>(array: T[][]): ArrayGrid<T> => {\n  const grid = create(array);\n  return {\n    ...grid,\n    get: access(array),\n    set: setMutate(array),\n    get array() {\n      return array;\n    }\n  }\n}\n\nexport const set = <V>(\n  array: readonly V[][]\n) => {\n  const grid = create(array);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic) => setWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setWithGrid = <V>(\n  grid: Grid,\n  array: readonly V[][],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  let boundCell = applyBounds(grid, cell, wrap);\n  if (boundCell === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  let copyWhole = [ ...array ];\n  let copyRow = [ ...copyWhole[ boundCell.y ] ];\n  copyRow[ boundCell.x ] = value;\n  copyWhole[ boundCell.y ] = copyRow;\n  array = copyWhole;\n  return copyWhole;\n}\n\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n * \n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n * \n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns \n */\nexport const wrap = <T>(array: T[][]): ArrayGrid<T> => {\n  const grid = create(array);\n  return {\n    ...grid,\n    get: (cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n    set: (value: T, cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => {\n      array = setWithGrid(grid, array, value, cell, boundsLogic);\n      return wrap(array);\n    },\n    get array() {\n      return array;\n    }\n  }\n}","import type { GridReadable, GridCell, GridBoundsLogic } from \"./types.js\";\n\n\nexport function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell>): Generator<T>\nexport function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell[]>): Generator<T[]>\n\n/**\n * Converts an 1D or 2D array of cell coordinates into values\n * \n * ```js\n * // 1D (ie an array of coordinates)\n * const cells = Grid.As.cells(grid);\n * for (const v of Grid.values(grid, cells)) {\n * \n * }\n * ```\n * ```js\n * // 2D (ie an array of rows)\n * const rows = Grid.As.rows(grid);\n * for (const v of Grid.values(grid, rows)) {\n * }\n * ```\n * @param grid \n * @param iter \n */\nexport function* values<T>(grid: GridReadable<T>, iter: Iterable<GridCell> | Iterable<GridCell[]>) {\n  for (const d of iter) {\n    if (Array.isArray(d)) {\n      yield d.map(v => grid.get(v, `undefined`));\n    } else {\n      yield grid.get(d, `undefined`);\n    }\n  }\n}\n\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell[]>, wrap?: BoundsLogic): Generator<T[]>\n\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell>, wrap?: BoundsLogic): Generator<T>\n\n// /**\n//  * Visits the values of a readable grid\n//  * @param readable Readable grid\n//  * @param visitor Visitor\n//  * @param wrap Wrapping logic, defaultign to 'undefined'\n//  */\n// export function* visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell | Cell[]>, wrap: BoundsLogic = `undefined`) {\n//   for (const cellOrCells of visitor) {\n//     if (Array.isArray(cellOrCells)) {\n//       yield cellOrCells.map(cell => readable.accessor(cell, wrap));\n//     } else {\n//       yield readable.accessor(cellOrCells, wrap);\n//     }\n//   }\n// }","import { guardGrid, guardCell } from \"../guards.js\";\nimport type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../types.js\";\nimport { values } from \"../values.js\";\n\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n * \n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n * \n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n * \n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n * \n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid: Grid, start?: GridCell, wrap = true) {\n  if (!start) start = { x: 0, y: 0 }\n\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  let { x, y } = start;\n  let canMove = true;\n  do {\n    yield { x, y };\n    x++;\n    if (x === grid.cols) {\n      y++;\n      x = 0;\n    }\n    if (y === grid.rows) {\n      if (wrap) {\n        y = 0;\n        x = 0;\n      } else {\n        canMove = false;\n      }\n    }\n    if (x === start.x && y === start.y) canMove = false; // Complete\n  } while (canMove);\n};\n\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n * \n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true) {\n  yield* values(grid, cells(grid, start, wrap));\n}\n\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true): Generator<GridCellAndValue<T>> {\n  for (const cell of cells(grid, start, wrap)) {\n    yield { cell, value: grid.get(cell) }\n  }\n}","import type { GridCell, Grid, GridReadable } from \"./types.js\";\nimport { cells } from \"./enumerators/cells.js\";\n\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n * \n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 }\n  let row = start.y;\n  let rowCells: Array<GridCell> = [];\n\n  for (const c of cells(grid, start)) {\n    if (c.y === row) {\n      rowCells.push(c);\n    } else {\n      yield rowCells;\n      rowCells = [ c ];\n      row = c.y;\n    }\n  }\n  if (rowCells.length > 0) yield rowCells;\n};\n\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n * \n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n * \n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid \n * @param start \n */\nexport function* columns(grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 };\n  for (let x = start.x; x < grid.cols; x++) {\n    let colCells: Array<GridCell> = [];\n    for (let y = start.y; y < grid.rows; y++) {\n      colCells.push({ x, y });\n    }\n    yield colCells;\n  }\n}","//import { clampIndex } from '@ixfx/numbers';\nimport { applyBounds } from './apply-bounds.js';\n//import { guardCell, guardGrid } from './guards.js';\nimport type { Grid, GridCell, GridBoundsLogic } from './types.js';\n\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n * \n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (\n  grid: Grid,\n  start: GridCell,\n  vector: GridCell,\n  bounds: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  return applyBounds(grid, {\n    x: start.x + vector.x,\n    y: start.y + vector.y\n  }, bounds)\n  // guardCell(start, `start`, grid);\n  // guardCell(vector);\n  // guardGrid(grid, `grid`);\n\n  // // eslint-disable-next-line functional/no-let\n  // let x = start.x;\n  // // eslint-disable-next-line functional/no-let\n  // let y = start.y;\n  // switch (bounds) {\n  //   case `wrap`: {\n  //     x += vector.x % grid.cols;\n  //     y += vector.y % grid.rows;\n  //     if (x < 0) x = grid.cols + x;\n  //     else if (x >= grid.cols) {\n  //       x -= grid.cols;\n  //     }\n  //     if (y < 0) y = grid.rows + y;\n  //     else if (y >= grid.rows) {\n  //       y -= grid.rows;\n  //     }\n  //     break;\n  //   }\n  //   case `stop`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     x = clampIndex(x, grid.cols);\n  //     y = clampIndex(y, grid.rows);\n  //     break;\n  //   }\n  //   case `undefined`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     if (x < 0 || y < 0) return;\n  //     if (x >= grid.cols || y >= grid.rows) return;\n  //     break;\n  //   }\n  //   case `unbounded`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     break;\n  //   }\n  //   default: {\n  //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n  //   }\n  // }\n  // return Object.freeze({ x, y });\n};\n\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport type { GridBoundsLogic, GridCardinalDirection, GridCardinalDirectionOptional, GridCell, Grid, GridNeighbours } from \"./types.js\";\nimport { offset } from \"./offset.js\";\n\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n  `n`,\n  `ne`,\n  `nw`,\n  `e`,\n  `s`,\n  `se`,\n  `sw`,\n  `w`,\n]) as readonly GridCardinalDirection[];\n\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n  `n`,\n  `e`,\n  `s`,\n  `w`,\n]) as readonly GridCardinalDirection[];\n\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (\n  grid: Grid,\n  start: GridCell,\n  steps: number,\n  bounds: GridBoundsLogic = `stop`\n): GridNeighbours => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  resultThrow(integerTest(steps, `aboveZero`, `steps`));\n\n  const directions = allDirections;\n  const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n  const cells = directions.map((d, index) =>\n    offset(grid, start, vectors[ index ], bounds)\n  );\n\n  return zipKeyValue(directions, cells) as GridNeighbours;\n};\n\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (\n  cardinal: GridCardinalDirectionOptional,\n  multiplier = 1\n): GridCell => {\n  let v;\n  switch (cardinal) {\n    case `n`: {\n      v = { x: 0, y: -1 * multiplier };\n      break;\n    }\n    case `ne`: {\n      v = { x: 1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    case `e`: {\n      v = { x: 1 * multiplier, y: 0 };\n      break;\n    }\n    case `se`: {\n      v = { x: 1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `s`: {\n      v = { x: 0, y: 1 * multiplier };\n      break;\n    }\n    case `sw`: {\n      v = { x: -1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `w`: {\n      v = { x: -1 * multiplier, y: 0 };\n      break;\n    }\n    case `nw`: {\n      v = { x: -1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    default: {\n      v = { x: 0, y: 0 };\n    }\n  }\n  return Object.freeze(v);\n};","//import type { Cell, GridReadable } from '../Types.js';\n\nexport * from './cells.js';\n\n// export function* withValues<T>(grid: GridReadable<T>, iter: IterableIterator<Cell>) {\n//   for (const cell of iter) {\n//     yield { cell, value: grid.get(cell, `undefined`) };\n//   }\n// }","import { guardCell } from \"./guards.js\";\nimport type { GridCell } from \"./types.js\";\n\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start: GridCell, end: GridCell): ReadonlyArray<GridCell> => {\n  // https://stackoverflow.com/a/4672319\n  guardCell(start);\n  guardCell(end);\n\n  let startX = start.x;\n  let startY = start.y;\n  const dx = Math.abs(end.x - startX);\n  const dy = Math.abs(end.y - startY);\n  const sx = startX < end.x ? 1 : -1;\n  const sy = startY < end.y ? 1 : -1;\n  let error = dx - dy;\n\n  const cells:GridCell[] = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    cells.push(Object.freeze({ x: startX, y: startY }));\n    if (startX === end.x && startY === end.y) break;\n    const error2 = 2 * error;\n    if (error2 > -dy) {\n      error -= dy;\n      startX += sx;\n    }\n    if (error2 < dx) {\n      error += dx;\n      startY += sy;\n    }\n  }\n  return cells;\n};\n\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (\n  start: GridCell,\n  end: GridCell,\n  endInclusive = false\n): ReadonlyArray<GridCell> {\n  const cells: Array<GridCell> = [];\n  if (start.x === end.x) {\n    // Vertical\n    const lastY = endInclusive ? end.y + 1 : end.y;\n    for (let y = start.y; y < lastY; y++) {\n      cells.push({ x: start.x, y: y });\n    }\n  } else if (start.y === end.y) {\n    // Horizontal\n    const lastX = endInclusive ? end.x + 1 : end.x;\n    for (let x = start.x; x < lastX; x++) {\n      cells.push({ x: x, y: start.y });\n    }\n  } else {\n    throw new Error(\n      `Only does vertical and horizontal: ${ start.x },${ start.y } - ${ end.x },${ end.y }`\n    );\n  }\n  return cells;\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\nimport type { Grid, GridCell, GridBoundsLogic } from \"./types.js\";\n\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic\n): number | undefined => {\n  guardGrid(grid, `grid`);\n\n  if (cell.x < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        //cell = { ...cell, x: grid.cols + cell.x };\n        cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`)!;\n        break;\n      }\n    }\n  }\n  if (cell.y < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: grid.rows + cell.y };\n        break;\n      }\n    }\n  }\n  if (cell.x >= grid.cols) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: grid.cols - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, x: cell.x % grid.cols };\n        break;\n      }\n    }\n  }\n  if (cell.y >= grid.rows) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: grid.rows - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: cell.y % grid.rows };\n        break;\n      }\n    }\n  }\n\n  const index = cell.y * grid.cols + cell.x;\n\n  return index;\n};\n\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (\n  colsOrGrid: number | Grid,\n  index: number\n): GridCell => {\n  let cols = 0;\n  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n  resultThrow(integerTest(cols, `aboveZero`, `colsOrGrid`));\n\n  return {\n    x: index % cols,\n    y: Math.floor(index / cols),\n  };\n};","import type { GridCell, Grid, GridVisual } from \"./types.js\";\n\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (\n  a: Grid | GridVisual,\n  b: Grid | GridVisual\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  if (`rows` in a && `cols` in a) {\n    if (`rows` in b && `cols` in b) {\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\n    } else return false;\n  }\n  if (`size` in a) {\n    if (`size` in b) {\n      if (a.size !== b.size) return false;\n    } else return false;\n  }\n  return true;\n};\n\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (\n  a: GridCell | undefined,\n  b: GridCell | undefined\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  return a.x === b.x && a.y === b.y;\n};","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { allDirections, getVectorFromCardinal } from \"./directions.js\";\nimport type { GridBoundsLogic, GridCardinalDirection, GridCell, Grid, GridNeighbour, GridNeighbourMaybe, GridNeighbours } from \"./types.js\";\nimport { randomElement } from \"@ixfx/random\";\nimport { offset } from \"./offset.js\";\n\nexport const randomNeighbour = (nbos: readonly GridNeighbour[]) => randomElement(nbos); // .filter(isNeighbour));\n\n/**\n * Returns _true_ if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (\n  n: GridNeighbour | GridNeighbourMaybe | undefined\n): n is GridNeighbour => {\n  if (n === undefined) return false;\n  if (n[ 1 ] === undefined) return false;\n  return true;\n};\n\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n * \n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n * \n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions \n * @param bounds Bounds\n * @returns \n */\nexport const neighbourList = (\n  grid: Grid,\n  cell: GridCell,\n  directions: readonly GridCardinalDirection[],\n  bounds: GridBoundsLogic\n): readonly GridNeighbour[] => {\n  // Get neighbours for cell\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\n\n  // Filter out undefined cells\n  const entries = Object.entries(cellNeighbours);\n  return (entries as GridNeighbourMaybe[]).filter(n => isNeighbour(n));\n};\n\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (\n  grid: Grid,\n  cell: GridCell,\n  bounds: GridBoundsLogic = `undefined`,\n  directions?: readonly GridCardinalDirection[]\n): GridNeighbours => {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  return zipKeyValue<GridCell>(directories, points) as GridNeighbours;\n};","\n/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\n\nimport type { Grid } from \"./types.js\";\n\nexport const toArray2d = <V>(grid: Grid, initialValue?: V): V[][] => {\n  const returnValue:V[][] = [];\n  for (let row = 0; row < grid.rows; row++) {\n    returnValue[ row ] = Array.from<V>({ length: grid.cols });\n    if (initialValue) {\n      for (let col = 0; col < grid.cols; col++) {\n        returnValue[ row ][ col ] = initialValue;\n      }\n    }\n  }\n  return returnValue;\n};","import type { GridCell } from \"./types.js\";\n\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v: GridCell): string => `Cell{${ v.x },${ v.y }}`;\n","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport { guardCell } from \"./guards.js\";\nimport type { GridCell, GridVisual } from \"./types.js\";\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from \"../point/point-type.js\";\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { cells } from \"./enumerators/cells.js\";\n\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(\n  grid: GridVisual\n): IterableIterator<RectPositioned> {\n  for (const c of cells(grid)) {\n    yield rectangleForCell(grid, c);\n  }\n}\n\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (\n  grid: GridVisual,\n  position: Point\n): GridCell | undefined => {\n  const size = grid.size;\n  resultThrow(numberTest(size, `positive`, `grid.size`));\n  if (position.x < 0 || position.y < 0) return;\n  const x = Math.floor(position.x / size);\n  const y = Math.floor(position.y / size);\n  if (x >= grid.cols) return;\n  if (y >= grid.rows) return;\n  return { x, y };\n};\n\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (\n  grid: GridVisual,\n  cell: GridCell\n): RectPositioned => {\n  guardCell(cell);\n  const size = grid.size;\n  const x = cell.x * size;\n  const y = cell.y * size;\n  const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n  return r;\n};\n\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid: GridVisual, cell: GridCell): Point => {\n  guardCell(cell);\n\n  const size = grid.size;\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n  return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};","import type { Grid, GridCell, GridVisitorOpts, GridNeighbourSelectionLogic } from \"../types.js\";\n//import { visitor } from \"./Visitor.js\";\n\n// export const visitorBreadth = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos[ 0 ],\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const breadthLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (nbos) => nbos[ 0 ],\n  }\n}","import { allDirections } from \"../directions.js\";\nimport { neighbourList } from \"../neighbour.js\";\nimport type { GridNeighbour, GridNeighbourSelectionLogic } from \"../types.js\";\n\n// export function* cellNeigbours(\n//   grid: Grid,\n//   cell: Cell,\n//   bounds: BoundsLogic = `undefined`,\n//   directions?: ReadonlyArray<CardinalDirection>\n// ) {\n//   const dirs = directions ?? allDirections;\n//   const points = dirs.map((c) =>\n//     offset(grid, cell, getVectorFromCardinal(c), bounds)\n//   );\n//   for (const pt of points) {\n//     if (pt !== undefined) yield pt;\n//   }\n// }\n\nexport const neighboursLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (neighbours: readonly GridNeighbour[]) => {\n      return neighbours.at(0);\n    },\n    getNeighbours: (grid, cell) => {\n      return neighbourList(grid, cell, allDirections, `undefined`)\n    }\n  }\n}\n","import type { GridNeighbour, GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n\n/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport const columnLogic = (opts: Partial<GridVisitorOpts> = {}): GridNeighbourSelectionLogic => {\n  const reversed = opts.reversed ?? false;\n  return {\n    select: (nbos) => nbos.find((n) => n[ 0 ] === (reversed ? `n` : `s`)),\n    getNeighbours: (grid, cell): ReadonlyArray<GridNeighbour> => {\n      if (reversed) {\n        // WALK UP COLUMN, RIGHT-TO-LEFT\n        if (cell.y > 0) {\n          // Easy case\n          cell = { x: cell.x, y: cell.y - 1 };\n        } else {\n          // Top of column\n          if (cell.x === 0) {\n            // Top-left corner, need to wrap\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          } else {\n            cell = { x: cell.x - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n        if (cell.y < grid.rows - 1) {\n          // Easy case, move down by one\n          cell = { x: cell.x, y: cell.y + 1 };\n        } else {\n          // End of column\n          if (cell.x < grid.cols - 1) {\n            // Move to next column and start at top\n            cell = { x: cell.x + 1, y: 0 };\n          } else {\n            // Move to start of grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `n` : `s`, cell ] ];\n    }\n  }\n}","import type { GridNeighbourSelectionLogic } from \"../types.js\";\n\n// export const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos.at(-1),\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const depthLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (nbos) => nbos.at(-1)\n  }\n}","import { randomNeighbour } from \"../neighbour.js\";\nimport type { GridNeighbour, GridNeighbourSelectionLogic } from \"../types.js\";\nimport { cells } from \"../enumerators/cells.js\";\n\n// export const visitorRandom = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const randomLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    getNeighbours: (grid, cell) => {\n      const t: Array<GridNeighbour> = [];\n      for (const c of cells(grid, cell)) {\n        t.push([ `n`, c ]);\n      }\n      return t;\n    },\n    select: randomNeighbour,\n  }\n}","import { randomNeighbour } from \"../neighbour.js\";\nimport type { GridNeighbourSelectionLogic } from \"../types.js\";\n\n// export const visitorRandomContiguous = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomContiguousLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: randomNeighbour,\n  }\n}","import type { GridCell, Grid, GridNeighbour, GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n\n/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport const rowLogic = (opts: Partial<GridVisitorOpts> = {}): GridNeighbourSelectionLogic => {\n  const reversed = opts.reversed ?? false;\n  return {\n    select: (nbos: ReadonlyArray<GridNeighbour>) =>\n      nbos.find((n) => n[ 0 ] === (reversed ? `w` : `e`)),\n    getNeighbours: (\n      grid: Grid,\n      cell: GridCell\n    ): ReadonlyArray<GridNeighbour> => {\n      if (reversed) {\n        // WALKING BACKWARD ALONG ROW\n        if (cell.x > 0) {\n          // All fine, step to the left\n          cell = { x: cell.x - 1, y: cell.y };\n        } else {\n          // At the beginning of a row\n          if (cell.y > 0) {\n            // Wrap to next row up\n            cell = { x: grid.cols - 1, y: cell.y - 1 };\n          } else {\n            // Wrap to end of grid\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        /*\n         * WALKING FORWARD ALONG ROWS\n         */\n        if (cell.x < grid.rows - 1) {\n          // All fine, step to the right\n          cell = { x: cell.x + 1, y: cell.y };\n        } else {\n          // At the end of a row\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.y < grid.rows - 1) {\n            // More rows available, wrap to next row down\n            cell = { x: 0, y: cell.y + 1 };\n          } else {\n            // No more rows available, wrap to start of the grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `w` : `e`, cell ] ];\n    }\n  }\n}","import { mutable } from '@ixfx/collections/set';\nimport { crossDirections } from \"../directions.js\";\nimport { guardGrid, guardCell, isCell } from \"../guards.js\";\nimport { cellEquals } from \"../is-equal.js\";\nimport { neighbourList } from '../neighbour.js';\nimport { cellKeyString } from \"../to-string.js\";\nimport type { GridNeighbourSelectionLogic, Grid, GridCell, GridVisitorOpts, GridNeighbour } from \"../types.js\";\n\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a @ixfx/collections.Sets.ISetMutable instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport function* visitByNeighbours(\n  logic: GridNeighbourSelectionLogic,\n  grid: Grid,\n  opts: Partial<GridVisitorOpts> = {}\n): Generator<GridCell> {\n  guardGrid(grid, `grid`);\n  const start = opts.start ?? { x: 0, y: 0 };\n\n  guardCell(start, `opts.start`, grid);\n\n  const v = opts.visited ?? mutable<GridCell>(cellKeyString);\n  const possibleNeighbours = logic.getNeighbours ?? ((g: Grid, c: GridCell) => neighbourList(g, c, crossDirections, `undefined`));\n\n  let cellQueue: GridCell[] = [ start ];\n  let moveQueue: GridNeighbour[] = [];\n  let current: GridCell | undefined = undefined;\n\n  while (cellQueue.length > 0) {\n    if (current === undefined) {\n      const nv = cellQueue.pop();\n      if (nv === undefined) {\n        break;\n      }\n      current = nv;\n    }\n\n    if (!v.has(current)) {\n      v.add(current);\n      yield current;\n\n      const nextSteps = possibleNeighbours(grid, current).filter(\n        (step) => {\n          if (step[ 1 ] === undefined) return false;\n          return !v.has(step[ 1 ])\n        }\n      );\n\n      if (nextSteps.length === 0) {\n        // No more moves for this cell\n        if (current !== undefined) {\n          cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n        }\n      } else {\n        for (const n of nextSteps) {\n          if (n === undefined) continue;\n          if (n[ 1 ] === undefined) continue;\n          moveQueue.push(n);\n        }\n      }\n    }\n\n    // Remove steps already made\n    moveQueue = moveQueue.filter((step) => !v.has(step[ 1 ]));\n\n    if (moveQueue.length === 0) {\n      current = undefined;\n    } else {\n      // Pick move\n      const potential = logic.select(moveQueue);\n      if (potential !== undefined) {\n        cellQueue.push(potential[ 1 ]);\n        current = potential[ 1 ];\n      }\n    }\n  }\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"../guards.js\";\nimport type { Grid, GridCell, GridCreateVisitor } from \"../types.js\";\n\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n * \n * // Step by 10\n * stepper(10); // GridCell {x,y}\n * \n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport const stepper = (\n  grid: Grid,\n  createVisitor: GridCreateVisitor,\n  start: GridCell = { x: 0, y: 0 },\n  resolution = 1\n) => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  resultThrow(integerTest(resolution, ``, `resolution`));\n\n  // Create a list of steps\n  const steps: GridCell[] = [];\n  let count = 0;\n  let position = 0;\n  for (const c of createVisitor(grid, { start, boundsWrap: `undefined` })) {\n    count++;\n    if ((count % resolution) !== 0) continue;\n    steps.push(c);\n  }\n\n  return (step: number, fromStart = false) => {\n    resultThrow(integerTest(step, ``, `step`));\n    if (fromStart) position = step;\n    else position += step;\n    //position = position % steps.length;\n    return steps.at(position % steps.length);\n\n  }\n}\n\n// export const step = (\n//   grid: Grid,\n//   start: Cell,\n//   steps: number,\n//   createVisitor: CreateVisitor\n// ): Cell => {\n//   throwIntegerTest(steps, ``, `steps`);\n\n//   const opts: Partial<VisitorOpts> = {\n//     reversed: steps < 0,\n//     start\n//   };\n//   steps = Math.abs(steps);\n\n//   let c = start;\n//   let v = createVisitor(grid, opts);\n//   v.next(); // Burn up starting cell\n\n//   let stepsMade = 0;\n\n//   while (stepsMade < steps) {\n//     stepsMade++;\n//     const { value } = v.next();\n//     if (value) {\n//       c = value;\n//       if (opts.debug) {\n//         console.log(\n//           `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n//         );\n//       }\n//     } else {\n//       if (steps >= grid.cols * grid.rows) {\n//         steps -= grid.cols * grid.rows;\n//         stepsMade = 0;\n//         v = createVisitor(grid, opts);\n//         v.next();\n//         c = start;\n//         if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n//       } else throw new Error(`Value not received by visitor`);\n//     }\n//   }\n//   return c;\n// };\n","import type { GridCell, GridCreateVisitor, Grid, GridReadable, GridNeighbourSelectionLogic, GridVisitorOpts } from '../types.js';\nimport { breadthLogic } from './breadth.js';\nimport { neighboursLogic } from './cell-neighbours.js';\nimport { columnLogic } from './columns.js';\nimport { depthLogic } from './depth.js';\nimport { randomLogic } from './random.js';\nimport { randomContiguousLogic } from './random-contiguous.js';\nimport { rowLogic } from './rows.js';\nimport { visitByNeighbours } from './visitor.js';\n\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\n\nexport type VisitorTypes = `row` | `column` | `neighbours` | `breadth` | `depth` | `random` | `random-contiguous`\n\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type \n * @param opts \n * @returns \n */\nexport const create = (type: VisitorTypes, opts: Partial<GridVisitorOpts> = {}) => {\n  switch (type) {\n    case `random-contiguous`:\n      return withLogic(randomContiguousLogic(), opts);\n    case `random`:\n      return withLogic(randomLogic(), opts);\n    case `depth`:\n      return withLogic(depthLogic(), opts);\n    case `breadth`:\n      return withLogic(breadthLogic(), opts);\n    case `neighbours`:\n      return withLogic(neighboursLogic(), opts);\n    case `row`:\n      return withLogic(rowLogic(opts), opts);\n    case `column`:\n      return withLogic(columnLogic(opts), opts);\n    default:\n      throw new TypeError(`Param 'type' unknown. Value: ${ type }`);\n  }\n}\n\nexport const withLogic = (logic: GridNeighbourSelectionLogic, options: Partial<GridVisitorOpts> = {}) => {\n  return (grid: Grid, optionsOverride: Partial<GridVisitorOpts> = {}) => {\n    return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n  }\n}\n\nfunction isIterator<T>(v: any): v is Generator<T> {\n  if (typeof v !== `object`) return false;\n  if (!(`next` in v)) return false;\n  if (!(`throw` in v)) return false;\n  if (!(`return` in v)) return false;\n  return true;\n\n}\n\n\n// export function* withValues<T>(createOrIter: CreateVisitor | Generator<Cell>, grid: GridReadable<T>, opts: Partial<VisitorOpts>) {\n//   const iter = isIterator(createOrIter) ? createOrIter : createOrIter(grid, opts)();\n//   for (const cell of iter) {\n//     yield { cell, value: grid.accessor(cell, `undefined`) }\n//   }\n// }\n\n// export const byCells = (grid: Grid, options: Partial<VisitorOpts> = {}) => {\n//   return (logic: NeighbourSelectionLogic, optionsOverride: Partial<VisitorOpts> = {}) => {\n//     return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n//   }\n// }\n\n// export const byCellsLeftToRightTopToBottom = ():CreateVisitor => {\n//   return (grid) => {\n//     return cells(grid)\n//   }\n// }","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport type * from './types.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n\n\n\n\n\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport { isRect } from \"../rect/guard.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Normalises a point by a given width and height\n * \n * ```js\n * normaliseByRect({ x: 10, y: 10 }, 20, 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport function normaliseByRect(\n  point: Point,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point by a given rect's width and height\n * \n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param pt \n * @param rect \n */\nexport function normaliseByRect(pt: Point, rect: Rect): Point;\n\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n * \n * ```js\n * normaliseByRect(10, 10, 20, 40); // { x: 0.5, y: 0.2 }\n * ```\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function normaliseByRect(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point so it is on a 0..1 scale\n * \n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); \n * normaliseByRect({ x: 10, y: 10 }, 20, 40); \n * normaliseByRect(10, 10, 20, 40);\n * ```\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(\n  a: Point | number,\n  b: number | Rect,\n  c?: number,\n  d?: number\n): Point {\n  if (isPoint(a)) {\n    if (typeof b === `number` && c !== undefined) {\n      resultThrow(\n        numberTest(b, `positive`, `width`),\n        numberTest(c, `positive`, `height`)\n      );\n    } else {\n      if (!isRect(b)) {\n        throw new Error(`Expected second parameter to be a rect`);\n      }\n      c = b.height;\n      b = b.width;\n    }\n    return Object.freeze({\n      x: a.x / b,\n      y: a.y / c,\n    });\n  } else {\n    resultThrow(numberTest(a, `positive`, `x`));\n    if (typeof b !== `number`) {\n      throw new TypeError(`Expecting second parameter to be a number (width)`);\n    }\n    if (typeof c !== `number`) {\n      throw new TypeError(`Expecting third parameter to be a number (height)`);\n    }\n\n    resultThrow(numberTest(b, `positive`, `y`));\n    resultThrow(numberTest(c, `positive`, `width`));\n    if (d === undefined) throw new Error(`Expected height parameter`);\n    resultThrow(numberTest(d, `positive`, `height`));\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n * \n * ```js\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line: Line | readonly Line[], point: Point): Point => {\n\n  const n = (line: Line): Point => {\n    const { a, b } = line;\n    const atob = { x: b.x - a.x, y: b.y - a.y };\n    const atop = { x: point.x - a.x, y: point.y - a.y };\n    const length = atob.x * atob.x + atob.y * atob.y;\n\n\n    let dot = atop.x * atob.x + atop.y * atob.y;\n    const t = Math.min(1, Math.max(0, dot / length));\n    dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n    return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n  };\n\n  if (Array.isArray(line)) {\n    const pts = line.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(line as Line));\n  }\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard } from './guard.js';\nimport { guard as guardPoint } from '../point/guard.js';\nimport { length } from \"./length.js\";\nimport { nearest } from \"./nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n * \n * ```js\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns \n */\nexport const distanceSingleLine = (line: Line, point: Point): number => {\n  guard(line, `line`);\n  guardPoint(point, `point`);\n\n  if (length(line) === 0) {\n    // Line is really a point\n    return length(line.a, point);\n  }\n\n  const near = nearest(line, point);\n  return length(near, point);\n};","import { interpolate } from \"./interpolate.js\";\nimport type { Line } from \"./line-type.js\";\nimport { length } from \"./length.js\";\nimport type { Point } from \"../point/point-type.js\";\n\nconst directionVector = (line: Line): Point => ({\n  x: line.b.x - line.a.x,\n  y: line.b.y - line.a.y\n});\n\n\n\nconst directionVectorNormalised = (line: Line): Point => {\n  const l = length(line);\n  const v = directionVector(line);\n  return {\n    x: v.x / l,\n    y: v.y / l\n  };\n};\n\n/**\n * Returns a parallel line to `line` at `distance`.\n * \n * ```js\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance \n */\nexport const parallel = (line: Line, distance: number): Line => {\n  const dv = directionVector(line);\n  const dvn = directionVectorNormalised(line);\n  const a = {\n    x: line.a.x - dvn.y * distance,\n    y: line.a.y + dvn.x * distance\n  };\n  return {\n    a,\n    b: {\n      x: a.x + dv.x,\n      y: a.y + dv.y\n    }\n  };\n};\n\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line: Line, distance: number, amount = 0) => {\n  const origin = interpolate(amount, line);\n  const dvn = directionVectorNormalised(line);\n  return {\n    x: origin.x - dvn.y * distance,\n    y: origin.y + dvn.x * distance\n  };\n};\n","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Line } from \"./line-type.js\";\nimport { bbox as PointsBbox } from \"../point/bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n * \n * ```js\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line: Line): RectPositioned => PointsBbox(line.a, line.b);\n","\nimport { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  const pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | number[], b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | number[],\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { divide as PointDivide } from '../point/divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param line \n * @param point \n * @returns \n */\nexport const divide = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointDivide(line.a, point),\n  b: PointDivide(line.b, point)\n});\n\n","import { fromPoints } from \"./from-points.js\";\nimport type { Line } from \"./line-type.js\";\n\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n * \n * ```js\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1 \n * @param y1 \n * @param x2 \n * @param y2 \n * @returns \n */\nexport const fromNumbers = (x1: number, y1: number, x2: number, y2: number): Line => {\n  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);\n  if (Number.isNaN(x2)) throw new Error(`x2 is NaN`);\n  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);\n  if (Number.isNaN(y2)) throw new Error(`y2 is NaN`);\n\n  const a = { x: x1, y: y1 };\n  const b = { x: x2, y: y2 };\n  return fromPoints(a, b);\n};","import { fromNumbers } from \"./from-numbers.js\";\nimport type { Line } from \"./line-type.js\";\n\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n * \n * See {@link toFlatArray} to create an array from a line.\n * \n * ```js\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array: readonly number[]): Line => {\n  if (!Array.isArray(array)) throw new Error(`arr parameter is not an array`);\n  if (array.length !== 4) throw new Error(`array is expected to have length four`);\n  return fromNumbers(array[ 0 ], array[ 1 ], array[ 2 ], array[ 3 ]);\n};","import type { Point } from \"../point/point-type.js\"\nimport * as Polar from \"../polar/index.js\";\nimport { radianInvert } from \"../angles.js\";\n\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n * \n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n * \n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line. \n * * Angle of 45deg will be angled downwards.\n * \n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin: Point = { x: 0.5, y: 0.5 }, length: number = 1, angleRadian: number = 0, balance: number = 0.5) => {\n  const left = length * balance;\n  const right = length * (1 - balance);\n  const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n  const b = Polar.toCartesian(right, angleRadian, origin);\n  return Object.freeze({\n    a, b\n  });\n}","import type { Point } from \"../point/point-type.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport type { Line } from \"./line-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\n\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n * \n * ```js\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine \n * @param pointB \n * @returns \n */\nexport const midpoint = (aOrLine: Point | Line, pointB?: Point): Point => {\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  return interpolate(0.5, a, b);\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { length } from \"./length.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line \n * @param pt \n */\nexport const relativePosition = (line: Line, pt: Point): number => {\n  const fromStart = PointsDistance(line.a, pt);\n  const total = length(line);\n  return fromStart / total;\n}","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { sum as PointsSum } from '../point/sum.js';\n\n/**\n * Adds both start and end points by given x,y\n * ```js\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const sum = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSum(line.a, point),\n  b: PointsSum(line.b, point)\n});","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function abs(pt: Point3d): Point3d;\nexport function abs(pt: Point): Point;\n\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt: Point): Point {\n  if (isPoint3d(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y),\n      z: Math.abs(pt.z)\n    });\n  } else if (isPoint(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y)\n    });\n  } else throw new TypeError(`Param 'pt' is not a point`);\n};","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n// type PointFields = `x` | `y`;\n// type Point3dFields = PointFields & 'z';\n\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\n\nexport function apply(pt: Point3d, fn: Point3dApplyFn): Point3d\nexport function apply(pt: Point, fn: PointApplyFn): Point;\n\n/**\n * Applies `fn` on x,y & z (if present) fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport function apply(\n  pt: Point,\n  fn: Point3dApplyFn | PointApplyFn\n): Point {\n  guard(pt, `pt`);\n  if (isPoint3d(pt)) {\n    return Object.freeze<Point3d>({\n      ...pt,\n      x: fn(pt.x, `x`),\n      y: fn(pt.y, `y`),\n      z: (fn as Point3dApplyFn)(pt.z, `z`)\n    });\n  }\n  return Object.freeze<Point>({\n    ...pt,\n    x: fn(pt.x, `x`),\n    y: fn(pt.y, `y`),\n  });\n}","import { movingAverageLight as mal } from \"@ixfx/numbers\"\nimport { isPoint3d } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n\n\n/**\n * Keeps track of average x, y and z values.\n * \n * When calling, you have to specify the averaging technique. At the moment\n * only 'moving-average-light' is supported. This uses @ixfx/numbers.movingAverageLight\n * under-the-hood.\n * \n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n * \n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n * \n * @param kind Averaging strategy\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns \n */\nexport function averager(kind: `moving-average-light`, opts: Partial<{ scaling: number }>): PointAverager;\n\nexport function averager(kind: PointAverageKinds, opts: Partial<{ scaling: number }> = {}): PointAverager {\n  let x: (v: number) => number;\n  let y: (v: number) => number;\n  let z: (v: number) => number;\n  switch (kind) {\n    case `moving-average-light`:\n      {\n        const scaling = opts.scaling ?? 3;\n        x = mal(scaling);\n        y = mal(scaling);\n        z = mal(scaling);\n        break;\n      }\n    default:\n      throw new Error(`Unknown averaging kind '${ kind }'. Expected: 'moving-average-light'`);\n  }\n\n  return (point: Point) => {\n    const ax = x(point.x);\n    const ay = y(point.y);\n    if (isPoint3d(point)) {\n      const az = z(point.z);\n      return Object.freeze({\n        x: ax,\n        y: ay,\n        z: az\n      })\n    } else {\n      return Object.freeze({\n        x: ax,\n        y: ay\n      })\n    }\n  }\n}","import { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over. Calculation and return value is 2D.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: readonly (Point | undefined)[]): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import { clamp as clampNumber } from '@ixfx/numbers';\nimport { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function clamp(a: Point, min?: number, max?: number): Point;\nexport function clamp(a: Point3d, min?: number, max?: number): Point3d;\n\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(\n  a: Point,\n  min = 0,\n  max = 1\n): Point {\n\n  if (isPoint3d(a)) {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n      z: clampNumber(a.z, min, max)\n    });\n  } else {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n    });\n  }\n}\n","import type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * \n * Return values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}\n\n/**\n * Compares points based on Z value. XY values are ignored.\n * \n * Return values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a: Point3d, b: Point3d): number => {\n  if (a.z === b.z) return 0;\n  if (a.z < b.z) return -1;\n  return 1;\n}","import { compareByX } from \"./compare.js\";\nimport { isEqual } from \"./is-equal.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts: ReadonlyArray<Point>): ReadonlyArray<Point> => {\n  const sorted = [ ...pts ].sort(compareByX);\n  if (sorted.length === 1) return sorted;\n\n  const x = (points: Array<Point>) => {\n    const v: Array<Point> = [];\n    for (const p of points) {\n      while (v.length >= 2) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const q = v.at(-1)!;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const r = v.at(-2)!;\n        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n          //eslint-disable-next-line functional/immutable-data\n          v.pop();\n        } else break;\n      }\n      //eslint-disable-next-line functional/immutable-data\n      v.push(p);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    v.pop();\n    return v;\n  };\n\n  const upper = x(sorted);\n  //eslint-disable-next-line functional/immutable-data\n  const lower = x(sorted.reverse());\n\n  if (upper.length === 1 && lower.length === 1 && isEqual(lower[ 0 ], upper[ 0 ])) {\n    return upper;\n  }\n  return [ ...upper, ...lower ];\n};","import { guard } from \"./guard.js\";\nimport { isPositioned, isRectPositioned } from \"./guard.js\";\nimport { isCirclePositioned } from '../circle/guard.js';\nimport * as Intersects from '../intersects.js';\nimport { isPoint } from \"../point/guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"../circle/circle-type.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  point: Point\n): boolean;\n\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  x: number,\n  y: number\n): boolean;\n\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  a: Point | number,\n  b?: number\n): boolean {\n  guard(rect, `rect`);\n  let x = 0;\n  let y = 0;\n  if (typeof a === `number`) {\n    if (b === undefined) throw new Error(`x and y coordinate needed`);\n    x = a;\n    y = b;\n  } else {\n    x = a.x;\n    y = a.y;\n  }\n  if (isPositioned(rect)) {\n    if (x - rect.x > rect.width || x < rect.x) return false;\n    if (y - rect.y > rect.height || y < rect.y) return false;\n  } else {\n    // Assume 0,0\n    if (x > rect.width || x < 0) return false;\n    if (y > rect.height || y < 0) return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (\n  a: RectPositioned,\n\n  b: CirclePositioned | Point\n): boolean => {\n  if (!isRectPositioned(a)) {\n    throw new Error(`a parameter should be RectPositioned`);\n  }\n\n  if (isCirclePositioned(b)) {\n    return Intersects.circleRect(b, a);\n  } else if (isPoint(b)) {\n    return intersectsPoint(a, b);\n  }\n  throw new Error(`Unknown shape for b: ${ JSON.stringify(b) }`);\n};","import { isPoint } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { getRectPositioned, guard } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the center of a rectangle as a {@link Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): Point => {\n  guard(rect);\n  if (origin === undefined && isPoint(rect)) origin = rect;\n  else if (origin === undefined) origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n\n  const r = getRectPositioned(rect, origin);\n  return Object.freeze({\n    x: origin.x + rect.width / 2,\n    y: origin.y + rect.height / 2,\n  });\n};","import { guardPositioned } from \"./guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./center.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { type Point } from '../point/point-type.js';\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { distance as PointsDistance } from '../point/distance.js';\n\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (\n  rect: RectPositioned,\n  pt: Point\n): number => {\n  guardPositioned(rect, `rect`);\n  PointsGuard(pt, `pt`);\n  if (intersectsPoint(rect, pt)) return 0;\n  const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n  const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n  return Math.hypot(dx, dy);\n};\n\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (\n  rect: RectPositioned,\n  pt: Point\n): number => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\nimport { distance } from \"./distance.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport type { Point } from \"./point-type.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/shape-type.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distance } from \"./distance.js\";\nimport { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p: Point): ReadonlyArray<number> => [ p.x, p.y ];\n","import { dotProduct as ArraysDotProduct } from '@ixfx/numbers';\nimport type { Point } from './point-type.js';\nimport { toArray } from './to-array.js';\n\nexport const dotProduct = (...pts: readonly Point[]): number => {\n  const a = pts.map(p => toArray(p));\n  return ArraysDotProduct(a);\n};","import { guard } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function from(x: number, y: number, z: number): Point3d;\nexport function from(x: number, y: number): Point;\nexport function from(array: [ x: number, y: number, z: number ]): Point3d;\nexport function from(array: [ x: number, y: number ]): Point;\n\n/**\n * Returns a point from two or three coordinates or an array of [x,y] or [x,y,z].\n * @example\n * ```js\n * let p = from([10, 5]);    // yields {x:10, y:5}\n * let p = from([10, 5, 2]); // yields: {x:10, y:5, z:2}\n * let p = from(10, 5);      // yields {x:10, y:5}\n * let p = from(10, 5, 2);   // yields: {x:10, y:5, z:2}\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport function from(\n  xOrArray?: number | readonly number[],\n  y?: number,\n  z?: number\n): Point {\n  if (Array.isArray(xOrArray)) {\n    if (xOrArray.length === 3) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n        z: xOrArray[ 2 ]\n      });\n    } else if (xOrArray.length === 2) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n      });\n    } else {\n      throw new Error(`Expected array of length two or three, got ${ xOrArray.length }`);\n    }\n  } else {\n    if (xOrArray === undefined) throw new Error(`Requires an array of [x,y] or x,y parameters at least`)\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\n    if (y === undefined) throw new Error(`Param 'y' is missing`);\n    else if (Number.isNaN(y)) throw new Error(`y is NaN`);\n    if (z === undefined) {\n      return Object.freeze({ x: xOrArray as number, y: y });\n    } else {\n      return Object.freeze({ x: xOrArray as number, y, z })\n    }\n  }\n};\n\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n * \n * Throws an error if `str` is not a string.\n * \n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n * \n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param string_ \n */\nexport const fromString = (string_: string): Point => {\n  if (typeof string_ !== `string`) throw new TypeError(`Param 'str' ought to be a string. Got: ${ typeof string_ }`);\n  const comma = string_.indexOf(`,`);\n  const x = Number.parseFloat(string_.substring(0, comma));\n  const nextComma = string_.indexOf(',', comma + 1);\n  if (nextComma > 0) {\n    // z component\n    const y = Number.parseFloat(string_.substring(comma + 1, nextComma - comma + 2));\n    const z = Number.parseFloat(string_.substring(nextComma + 1));\n    return { x, y, z };\n  } else {\n    const y = Number.parseFloat(string_.substring(comma + 1));\n    return { x, y };\n  }\n}\n\n\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (\n  ...coords: readonly (readonly number[])[] | readonly number[]\n): readonly Point[] => {\n  const pts: Point[] = [];\n\n  if (Array.isArray(coords[ 0 ])) {\n    // [[x,y],[x,y]...]\n    for (const coord of (coords as number[][])) {\n      if (!(coord.length % 2 === 0)) {\n        throw new Error(`coords array should be even-numbered`);\n      }\n      pts.push(Object.freeze({ x: coord[ 0 ], y: coord[ 1 ] }));\n    }\n  } else {\n    // [x,y,x,y,x,y]\n    if (coords.length % 2 !== 0) {\n      throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n    }\n\n    for (let index = 0; index < coords.length; index += 2) {\n      pts.push(\n        Object.freeze({ x: coords[ index ] as number, y: coords[ index + 1 ] as number })\n      );\n    }\n  }\n  return pts;\n};\n","import type { Point } from \"./point-type.js\";\nimport { interpolate as lineInterpolate } from '../line/interpolate.js';\n\n/**\n * Returns a relative point between two points.\n * \n * ```js\n * interpolate(0.5, { x:0, y:0 }, { x:10, y:10 }); // Halfway { x, y }\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { findMinimum } from \"./find-minimum.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * \n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: readonly ((pt: Point) => Point)[]\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: readonly ((pt: Point) => Point)[]) =>\n    (pt: Point) =>\n\n      pipeline.reduce((previous, current) => current(previous), pt);\n","import type { Line } from './line/line-type.js';\nimport type { Point } from './point/point-type.js';\nimport { normalise as PointsNormalise } from './point/normalise.js';\nimport { isPoint } from './point/guard.js';\nimport * as Polar from './polar/index.js';\nimport { divide as PointDivide } from './point/divider.js';\nimport { guard as LinesGuard } from './line/guard.js';\nimport { sum as PointsSum } from './point/sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/dot-product.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/magnitude.js';\nimport { distance as PointsDistance } from './point/distance.js';\nimport { Empty as PointEmpty } from './point/empty.js';\n\nexport type Vector = Point | Polar.Coord;\n\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\n\nexport const fromRadians = (radians: number) => {\n  return Object.freeze({\n    x: Math.cos(radians),\n    y: Math.sin(radians)\n  });\n}\n\nexport const toRadians = (point: Point) => {\n  return Math.atan2(point.y, point.x);\n}\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2\n * if `bipolar` normalisation is used, direction will be fixed to -...\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (\n  pt: Point,\n  angleNormalisation: `` | `unipolar` | `bipolar` = ``,\n  origin: Point = EmptyCartesian\n): Polar.Coord => {\n  pt = PointsSubtract(pt, origin);\n\n  let direction = Math.atan2(pt.y, pt.x);\n  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi;\n  else if (angleNormalisation === `bipolar`) {\n    if (direction > pi) direction -= piPi;\n    else if (direction <= -pi) direction += piPi;\n  }\n\n  return Object.freeze({\n    distance: PointsDistance(pt),\n    angleRadian: direction,\n  });\n};\n\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line: Line): Point =>\n  PointsSubtract(line.b, line.a);\n\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line: Line): Polar.Coord => {\n  LinesGuard(line, `line`);\n  const pt = PointsSubtract(line.b, line.a);\n  return fromPointPolar(pt);\n};\n\nconst isPolar = (v: Vector): v is Polar.Coord => {\n  if (Polar.isPolarCoord(v)) return true;\n  return false;\n};\n\nconst isCartesian = (v: Vector): v is Point => {\n  if (isPoint(v)) return true;\n  return false;\n};\n\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v: Vector): Vector => {\n  if (isPolar(v)) {\n    return Polar.normalise(v);\n  } else if (isCartesian(v)) {\n    return PointsNormalise(v);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\nexport const quadrantOffsetAngle = (p: Point): number => {\n  if (p.x >= 0 && p.y >= 0) return 0; // Q1\n  if (p.x < 0 && p.y >= 0) return pi; // Q2\n  if (p.x < 0 && p.y < 0) return pi; // Q3\n  return piPi; // Q4\n};\n\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v: Vector, origin = PointEmpty): Polar.Coord => {\n  if (isPolar(v)) {\n    return v;\n  } else if (isCartesian(v)) {\n    return Polar.fromCartesian(v, origin);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v: Vector): Point => {\n  if (isPolar(v)) {\n    return Polar.toPoint(v);\n  } else if (isCartesian(v)) {\n    return v;\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v: Vector, digits?: number) => {\n  if (isPolar(v)) {\n    return Polar.toString(v, digits);\n  } else if (isCartesian(v)) {\n    return PointsToString(v, digits);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Vector, b: Vector) => {\n  if (isPolar(a) && isPolar(b)) {\n    return Polar.dotProduct(a, b);\n  } else if (isCartesian(a) && isCartesian(b)) {\n    return PointsDotProduct(a, b);\n  }\n  throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v: Vector, max = 1, min = 0) => {\n  if (isPolar(v)) {\n    return Polar.clampMagnitude(v, max, min);\n  } else if (isCartesian(v)) {\n    return PointsClampMagnitude(v, max, min);\n  }\n  throw new Error(`Expected either polar or Cartesian vector`);\n};\n\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSum(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSubtract(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsMultiply(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointDivide(a, b);\n  return polar ? toPolar(c) : c;\n};\n","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: readonly Point[]): PolyLine => {\n  const lines: Line[] = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { angleRadian } from \"./angle.js\";\nimport { centroid } from \"./centroid.js\";\nimport { distance } from \"./distance.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport type { PointRelation } from \"./point-relation-types.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link PointsTracker}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angleRadian(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","import {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from '@ixfx/trackers';\nimport { ObjectTracker } from '@ixfx/trackers';\nimport { length as LineLength } from '../line/length.js';\nimport * as Vectors from '../vector.js';\nimport { Empty as LinesEmpty } from '../line/index.js';\nimport type { Coord as PolarCoord } from '../polar/index.js';\nimport type { Line, PolyLine } from '../line/line-type.js';\nimport type { Point, Point3d } from './point-type.js';\nimport type { PointRelation } from './point-relation-types.js';\nimport { joinPointsToLines } from '../line/join-points-to-lines.js';\nimport type { TrimReason } from '@ixfx/trackers';\nimport type { PointRelationResult } from \"./point-relation-types.js\";\nimport { relation } from './relation.js';\nimport { distance, distance2d } from './distance.js';\nimport { subtract } from './subtract.js';\nimport { angleRadian } from './angle.js';\nimport { Placeholder as PointsPlaceholder } from './point-type.js';\n/**\n * Information about seen points\n */\nexport type PointTrack = PointRelationResult & {\n  // readonly speedFromInitial:number\n};\n\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = Readonly<{\n  /**\n   * Relation of last point to previous point\n   */\n  fromLast: PointTrack;\n  /**\n   * Relation of last point to 'initial' point.\n   * This will be the oldest point in the buffer of the tracker.\n   */\n  fromInitial: PointTrack;\n  /**\n   * Relation of last point to a 'mark' point,\n   * which is manually set.\n   * \n   * Will give _undefined_ if `.mark()` has not been called on tracker.\n   */\n  fromMark: PointTrack | undefined;\n  values: readonly Point[];\n}>;\n\n\n\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link PointsTracker}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n * \n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport class PointTracker<TPoint extends Point = Point> extends ObjectTracker<TPoint, PointTrackerResults> {\n  initialRelation: PointRelation | undefined;\n  markRelation: PointRelation | undefined;\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  /**\n   * Notification that buffer has been knocked down to `sampleLimit`.\n   * \n   * This will reset the `initialRelation`, which will use the new oldest value.\n   */\n  onTrimmed(_reason: TrimReason): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n    this.markRelation = undefined\n  }\n\n\n\n  /**\n   * Makes a 'mark' in the tracker, allowing you to compare values\n   * to this point.\n   */\n  mark() {\n    this.markRelation = relation(this.last);\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: TimestampedObject<Point>[]\n  ): PointTrackerResults {\n    const currentLast = this.last;\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      // Use the oldest point in the buffer (this.initial)\n      this.initialRelation = relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? relation(currentLast) : relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const markRel: PointTrack | undefined = (this.markRelation !== undefined) ? this.markRelation(currentLast) : undefined;\n\n    const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast, true) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      fromMark: markRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return LinesEmpty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length. Use {@link lengthTotal} for that.\n   * @param force2d If _true_ distance is calculated only in 2d\n   * @returns Distance\n   */\n  distanceFromStart(force2d = false): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ?\n      force2d ? distance2d(initial, this.last) : distance(initial, this.last)\n      : 0;\n  }\n\n  /**\n   * Returns the speed (over milliseconds) based on accumulated travel distance.\n   * \n   * If there's no initial point, 0 is returned.\n   * @param force2d If _true_, speed is calculated with x,y only\n   * @returns \n   */\n  speedFromStart(force2d = false): number {\n    const d = this.lengthTotal(force2d);\n    const t = this.timespan;\n    if (Number.isNaN(t)) return 0;\n    if (d === 0) return 0;\n    return Math.abs(d) / t;\n  }\n\n  speedFromLast(force2d = false): number {\n    const l = this.lastResult;\n    if (!l) return 0;\n    return l.fromLast.speed;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x,y & z.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Point | Point3d {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? subtract(this.last, initial) : PointsPlaceholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return angleRadian(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total distance from accumulated points.\n   * Returns 0 if points were not saved, or there's only one.\n   * \n   * Use {@link lengthAverage} to get the average length for all segments\n   * @param force2d If _true_ length is calculated using x&y only\n   */\n  lengthTotal(force2d = false): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return LineLength(l, force2d);\n  }\n\n  /**\n   * Adds up the accumulated length of all points (using {@link lengthTotal})\n   * dividing by the total number of points.\n   * @param force2d \n   * @returns \n   */\n  lengthAverage(force2d = false): number {\n    return this.lengthTotal(force2d) / this.values.length;\n  }\n\n  /**\n * Returns the last x coord\n */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * Returns the last z coord (or _undefined_ if not available)\n   */\n  get z() {\n    return this.last.z;\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class PointsTracker<TPoint extends Point = Point> extends TrackedValueMap<\n  TPoint,\n  PointTracker<TPoint>,\n  PointTrackerResults\n> {\n\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker<TPoint>({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  get(id: string) {\n    const v = super.get(id);\n    return v as PointTracker<TPoint> | undefined\n  }\n}\n\nexport class UserPointerTracker extends PointTracker {\n  /**\n   * Adds a PointerEvent along with its\n   * coalesced events, if available.\n   * @param p \n   * @returns \n   */\n  seenEvent(p: PointerEvent | MouseEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      return this.seen({ x: (p).clientX, y: (p).clientY });\n    }\n  }\n}\n\nexport class UserPointersTracker extends TrackedValueMap<\n  Point,\n  PointTracker,\n  PointTrackerResults\n> {\n\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new UserPointerTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  get(id: string) {\n    const v = super.get(id);\n    return v as UserPointerTracker | undefined\n  }\n  /**\n * Track a PointerEvent\n * @param event\n */\n  seenEvent(event: PointerEvent): Promise<PointTrackerResults[]> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}","\nimport { isPoint3d } from \"./guard.js\";\nimport type { Point3d, Point } from \"./point-type.js\";\nimport { subtract } from \"./subtract.js\";\n\n/**\n * Computes the progress between two waypoints, given `position`.\n * \n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns \n */\nexport const progressBetween = (\n  position: Point | Point3d,\n  waypointA: Point | Point3d,\n  waypointB: Point | Point3d\n) => {\n  // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n  // from -> current\n  const a = subtract(position, waypointA);\n\n  // from -> to\n  const b = subtract(waypointB, waypointA);\n\n  return isPoint3d(a) && isPoint3d(b) ? (\n    (a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)\n  ) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin: Point, distance: number, angle: number) => {\n  const x = Math.cos(angle) * distance + origin.x;\n  const y = Math.sin(angle) * distance + origin.y;\n  return { x, y };\n};","import { quantiseEvery as quantiseEveryNumber } from '@ixfx/numbers';\nimport { guard, isPoint3d } from './guard.js';\nimport type { Point, Point3d } from './point-type.js';\n\nexport function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n\n/**\n * Quantises a point.\n * @param pt \n * @param snap \n * @param middleRoundsUp \n * @returns \n */\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp = true): Point {\n  guard(pt, `pt`);\n  guard(snap, `snap`);\n  if (isPoint3d(pt)) {\n    if (!isPoint3d(snap)) throw new TypeError(`Param 'snap' is missing 'z' field`);\n    return Object.freeze({\n      x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n      y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n      z: quantiseEveryNumber(pt.z, snap.z, middleRoundsUp)\n    });\n  }\n\n  return Object.freeze({\n    x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n    y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n  });\n}","import { type RandomSource } from '@ixfx/random';\nimport type { Point, Point3d } from './point-type.js';\n\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): Point => {\n  if (typeof rando === `undefined`) rando = Math.random;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n  });\n};\n\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random3d = (rando?: RandomSource): Point3d => {\n  if (typeof rando === `undefined`) rando = Math.random;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    z: rando()\n  });\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (\n  pts: ReadonlyArray<Point>,\n  fn: (p: Point, accumulated: Point) => Point,\n  initial?: Point\n): Point => {\n  if (initial === undefined) initial = { x: 0, y: 0 }\n  let accumulator = initial;\n  for (const p of pts) {\n    accumulator = fn(p, accumulator);\n  };\n  return accumulator;\n};","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"./point-type.js\";\nimport { guard } from \"./guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../polar/index.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../polar/index.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport function rotate(\n  pt: readonly Point[],\n  amountRadian: number,\n  origin?: Point\n): readonly Point[];\n\nexport function rotate(\n  pt: Point | readonly Point[],\n  amountRadian: number,\n  origin?: Point\n): Point | readonly Point[] {\n  if (typeof origin === `undefined`) origin = { x: 0, y: 0 };\n  guard(origin, `origin`);\n  resultThrow(numberTest(amountRadian, ``, `amountRadian`));\n  const arrayInput = Array.isArray(pt);\n\n  // no-op\n  if (amountRadian === 0) return pt;\n\n  if (!arrayInput) {\n    pt = [ pt as Point ];\n  }\n\n  const ptAr = pt as readonly Point[];\n  for (const [ index, p ] of ptAr.entries()) guard(p, `pt[${ index }]`);\n\n  const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n  const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n  const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n  return arrayInput ? asCartesisan : asCartesisan[ 0 ];\n}","\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (\n  v: ReadonlyArray<ReadonlyArray<number>>,\n  amountRadian: number\n): Array<Array<number>> => {\n  const mat = [\n    [ Math.cos(amountRadian), -Math.sin(amountRadian) ],\n    [ Math.sin(amountRadian), Math.cos(amountRadian) ],\n  ];\n  const result:number[][] = [];\n  for (const [ index, element ] of v.entries()) {\n    result[ index ] = [\n      mat[ 0 ][ 0 ] * element[ 0 ] + mat[ 0 ][ 1 ] * element[ 1 ],\n      mat[ 1 ][ 0 ] * element[ 0 ] + mat[ 1 ][ 1 ] * element[ 1 ],\n    ];\n  }\n  return result;\n};","import { round as roundNumber } from '@ixfx/numbers';\nimport { getPointParameter } from './get-point-parameter.js';\nimport type { Point } from './point-type.js';\n\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX \n * @param yOrDigits \n * @param digits \n * @returns \n */\nexport const round = (ptOrX: Point | number, yOrDigits?: number, digits?: number): Point => {\n  const pt = getPointParameter(ptOrX, yOrDigits);\n  digits = digits ?? yOrDigits;\n  digits = digits ?? 2;\n  return Object.freeze({\n    ...pt,\n    x: roundNumber(digits, pt.x),\n    y: roundNumber(digits, pt.y)\n  })\n}","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"./point-type.js\";\nimport { guard } from \"./guard.js\";\n\n/**\n * Returns true if two points are within a specified range on both axes.\n * \n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (\n  a: Point,\n  b: Point,\n  maxRange: Point | number\n): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n\n  if (typeof maxRange === `number`) {\n    resultThrow(numberTest(maxRange, `positive`, `maxRange`));\n    maxRange = { x: maxRange, y: maxRange };\n  } else {\n    guard(maxRange, `maxRange`);\n  }\n  const x = Math.abs(b.x - a.x);\n  const y = Math.abs(b.y - a.y);\n  return x <= maxRange.x && y <= maxRange.y;\n};","import { wrap as wrapNumber } from '@ixfx/numbers';\nimport { guard } from './guard.js';\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (\n  pt: Point,\n  ptMax?: Point,\n  ptMin?: Point\n): Point => {\n\n  if (ptMax === undefined) ptMax = { x: 1, y: 1 };\n  if (ptMin === undefined) ptMin = { x: 0, y: 0 };\n\n  //  Unit tested\n  guard(pt, `pt`);\n  guard(ptMax, `ptMax`);\n  guard(ptMin, `ptMin`);\n\n  return Object.freeze({\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n  });\n};\n","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\nexport type { Point, Point3d } from './point-type.js';\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./interpolate.js\";\n\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n * \n * ```js\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n * \n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n * \n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n * \n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns \n */\nexport const rotate = (line: Line, amountRadian?: number, origin?: Point | number): Line => {\n  if (typeof amountRadian === `undefined` || amountRadian === 0) return line;\n  if (typeof origin === `undefined`) origin = 0.5;\n  if (typeof origin === `number`) {\n    origin = interpolate(origin, line.a, line.b);\n  }\n  return Object.freeze({\n    ...line,\n    a: PointRotate(line.a, amountRadian, origin),\n    b: PointRotate(line.b, amountRadian, origin)\n  });\n};","import type { Line } from \"./line-type.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n * \n * ```js\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a: Line, b: Line): boolean => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);","import type { Line } from \"./line-type.js\";\nimport { multiply as PointsMultiply, type Point } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n * \n * ```js\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const multiply = (line: Line, point: Point): Line => (Object.freeze({\n  ...line,\n  a: PointsMultiply(line.a, point),\n  b: PointsMultiply(line.b, point)\n}));","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { subtract as PointsSubtract } from \"../point/subtract.js\";\n\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const subtract = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSubtract(line.a, point),\n  b: PointsSubtract(line.b, point)\n});","import type { Point } from \"../point/point-type.js\";\nimport { guard, isLine } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of two points\n * ```js\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport function toString(a: Point, b: Point): string;\n\n/**\n * Returns a string representation of a line \n * ```js\n * Lines.toString(line);\n * ```\n * @param line \n */\nexport function toString(line: Line): string;\n\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b \n * @returns \n */\n\nexport function toString(a: Point | Line, b?: Point): string {\n  if (isLine(a)) {\n    guard(a, `a`);\n    b = a.b;\n    a = a.a;\n  } else if (b === undefined) throw new Error(`Expect second point if first is a point`);\n  return PointsToString(a) + `-` + PointsToString(b);\n}\n\n","import type { LinePath } from \"./line-path-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { length } from \"./length.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { parallel, perpendicularPoint } from \"./angles.js\";\nimport { midpoint } from \"./midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./bbox.js\";\nimport { relativePosition } from \"./relative-position.js\";\nimport { sum } from \"./sum.js\";\nimport { divide } from \"./divide.js\";\nimport { rotate } from \"./rotate.js\";\nimport { nearest } from \"./nearest.js\";\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isEqual } from \"./is-equal.js\";\nimport { multiply } from \"./multiply.js\";\nimport { subtract } from \"./subtract.js\";\nimport { toString } from \"./to-string.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n * \n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n * \n * ```js\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n * \n * // Now we can use it...\n * l.length();\n * \n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line \n * @returns \n */\nexport const toPath = (line: Line): LinePath => {\n  const { a, b } = line;\n  return Object.freeze({\n    ...line,\n    length: () => length(a, b),\n    interpolate: (amount: number) => interpolate(amount, a, b),\n    relativePosition: (point: Point) => relativePosition(line, point),\n    bbox: () => bbox(line),\n    toString: () => toString(a, b),\n    toFlatArray: () => toFlatArray(a, b),\n    toSvgString: () => toSvgString(a, b),\n    toPoints: () => [ a, b ],\n    rotate: (amountRadian: number, origin: Point) => toPath(rotate(line, amountRadian, origin)),\n    nearest: (point: Point) => nearest(line, point),\n    sum: (point: Point) => toPath(sum(line, point)),\n    divide: (point: Point) => toPath(divide(line, point)),\n    multiply: (point: Point) => toPath(multiply(line, point)),\n    subtract: (point: Point) => toPath(subtract(line, point)),\n    midpoint: () => midpoint(a, b),\n    distanceToPoint: (point: Point) => distanceSingleLine(line, point),\n    parallel: (distance: number) => parallel(line, distance),\n    perpendicularPoint: (distance: number, amount?: number) => perpendicularPoint(line, distance, amount),\n    slope: () => slope(line),\n    withinRange: (point: Point, maxRange: number) => withinRange(line, point, maxRange),\n    isEqual: (otherLine: Line) => isEqual(line, otherLine),\n    apply: (fn: (point: Point) => Point) => toPath(apply(line, fn)),\n    kind: `line`\n  });\n};","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { LinePath } from \"./line-path-type.js\";\nimport { toPath } from \"./to-path.js\";\n\n/**\n * Returns a {@link LinePath} from two points\n * \n * ```js\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const fromPointsToPath = (a: Point, b: Point): LinePath => toPath(fromPoints(a, b));\n","import type { Point } from '../point/point-type.js';\nimport type { Line } from './line-type.js';\n//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/normalise-by-rect.js';\nimport { minFast } from '@ixfx/numbers';\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isLine } from './guard.js';\nimport { length } from './length.js';\nimport { interpolate } from './interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/guard.js';\n\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport type * from './line-path-type.js';\nexport type * from './line-type.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\n\n\nexport const Empty = Object.freeze({\n  a: Object.freeze({ x: 0, y: 0 }),\n  b: Object.freeze({ x: 0, y: 0 })\n});\n\n\nexport const Placeholder = Object.freeze({\n  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n  b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l \n * @returns \n */\nexport const isEmpty = (l: Line): boolean => PointIsEmpty(l.a) && PointIsEmpty(l.b);\n\nexport const isPlaceholder = (l: Line): boolean => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n\n\n\n\n/**\n * Applies `fn` to both start and end points.\n * \n * ```js\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n * \n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n * \n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns \n */\nexport const apply = (line: Line, fn: (p: Point) => Point) => Object.freeze<Line>(\n  {\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n  }\n);\n\n\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint \n * @param b \n * @returns \n */\nexport const angleRadian = (lineOrPoint: Line | Point, b?: Point): number => {\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b point must be provided`);\n  }\n  return Math.atan2(b.y - a.y, b.x - a.x);\n};\n\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n * \n * ```js\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line \n * @param width\n * @param height \n * @returns \n */\nexport const normaliseByRect = (line: Line, width: number, height: number): Line => Object.freeze({\n  ...line,\n  a: PointsNormaliseByRect(line.a, width, height),\n  b: PointsNormaliseByRect(line.b, width, height)\n});\n\n\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n * \n * ```js\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange \n * @returns True if point is within range\n */\nexport const withinRange = (line: Line, point: Point, maxRange: number): boolean => {\n  const calculatedDistance = distance(line, point);\n  return calculatedDistance <= maxRange;\n};\n\n\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n * \n * @example\n * ```js\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns \n */\nexport const slope = (lineOrPoint: Line | Point, b?: Point): number => {\n\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b parameter required`);\n  }\n  if (b === undefined) {\n    throw new TypeError(`Second point missing`)\n  } else {\n    return (b.y - a.y) / (b.x - a.x);\n  }\n};\n\n\n/**\n * Scales a line from its midpoint\n * \n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor \n */\nexport const scaleFromMidpoint = (line: Line, factor: number): Line => {\n  const a = interpolate(factor / 2, line);\n  const b = interpolate(0.5 + factor / 2, line);\n  return { a, b };\n};\n\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line: Line, x: number): Point => {\n  const y = line.a.y + (x - line.a.x) * slope(line);\n  return Object.freeze({ x: x, y });\n};\n\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line: Line, distance: number): Line => {\n  const calculatedLength = length(line);\n  return Object.freeze({\n    ...line,\n    a: line.a,\n    b: Object.freeze({\n      x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n      y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n    })\n  });\n};\n\n/**\n * Yields every integer point along `line`. \n * \n * @example Basic usage\n * ```js\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n * \n * Some precision is lost as start and end\n * point is also returned as an integer.\n * \n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\n\nexport function* pointsOf(line: Line): Generator<Point> {\n  // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n  const { a, b } = line;\n  let x0 = Math.floor(a.x);\n  let y0 = Math.floor(a.y);\n  const x1 = Math.floor(b.x);\n  const y1 = Math.floor(b.y);\n  const dx = Math.abs(x1 - x0);\n  const dy = -Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1;\n  const sy = y0 < y1 ? 1 : -1;\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  let err = dx + dy;\n\n  while (true) {\n    yield { x: x0, y: y0 };\n    if (x0 === x1 && y0 === y1) break;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const e2 = 2 * err;\n    if (e2 >= dy) {\n      err += dy;\n      x0 += sx;\n    }\n    if (e2 <= dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n}\n\n/**\n * Returns the distance of `point` to the \n * nearest point on `line`.\n * \n * ```js\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line: Line | readonly Line[], point: Point): number => {\n  if (Array.isArray(line)) {\n    const distances = line.map(l => distanceSingleLine(l, point));\n    return minFast(distances);\n  } else {\n    return distanceSingleLine(line as Line, point);\n  }\n};\n\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n * \n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a: Point | Line, b: Point): readonly number[] => {\n  if (isLine(a)) {\n    return [ a.a.x, a.a.y, a.b.x, a.b.y ];\n  } else if (isPoint(a) && isPoint(b)) {\n    return [ a.x, a.y, b.x, b.y ];\n  } else {\n    throw new Error(`Expected single line parameter, or a and b points`);\n  }\n};\n\n/**\n * Yields all the points of all the lines.\n * \n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines \n */\n\nexport function* asPoints(lines: Iterable<Line>) {\n  for (const l of lines) {\n    yield l.a;\n    yield l.b;\n  }\n}\n\n/**\n * Returns an SVG description of line\n * ```\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const toSvgString = (a: Point, b: Point): readonly string[] => [ `M${ a.x } ${ a.y } L ${ b.x } ${ b.y }` ];\n","import { type Point } from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): readonly Point[] => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import { isQuadraticBezier } from \"../bezier/guard.js\";\nimport { isLine } from \"../line/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Path } from \"./path-type.js\";\n\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.a;\n  else if (isLine(path)) return path.a;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.b;\n  else if (isLine(path)) return path.b;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};","import { bbox as PointsBbox } from '../point/bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\nimport type { Point } from '../point/point-type.js';\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { sortByNumericProperty } from '@ixfx/arrays';\nimport { getEnd, getStart } from './start-end.js';\nimport type { CompoundPath, Dimensions, Path } from './path-type.js';\nimport type { RectPositioned } from '../rect/rect-types.js';\n\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Path): CompoundPath => {\n  const existing = [ ...compoundPath.segments ];\n  //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n  existing[ index ] = path;\n  return fromPaths(...existing);\n};\n\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths: readonly Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n\n  // Expected value to land on\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n  let soFar = 0;\n\n  // Use widths or lengths?\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\n  for (const [ index, element ] of l.entries()) {\n    if (soFar + element >= expected) {\n      const relative = expected - soFar;\n      let amt = relative / element;\n      if (amt > 1) amt = 1;\n      return paths[ index ].interpolate(amt);\n    } else soFar += element;\n  }\n  return { x: 0, y: 0 };\n};\n\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths \n * @param point \n * @returns \n */\nexport const distanceToPoint = (paths: readonly Path[], point: Point): number => {\n  if (paths.length === 0) return 0;\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length === 0) throw new Error(`Could not look up distances`);\n  return distances[ 0 ].distance;\n}\n\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold \n * @param dimensions Pre-computed dimensions\n * @returns \n */\nexport const relativePosition = (paths: readonly Path[], point: Point, intersectionThreshold: number, dimensions?: Dimensions): number => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length < 0) throw new Error(`Point does not intersect with path`);\n  const d = distances[ 0 ];\n  if (d.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${ d.distance }, threshold: ${ intersectionThreshold }`);\n\n  const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n\n  // Add up distances\n  let accumulated = 0;\n  for (let index = 0; index < d.index; index++) {\n    // Add up length of paths before closest path segment\n    accumulated += dimensions.lengths[ index ];\n  }\n\n  // Add up partial amount of closest path\n  accumulated += dimensions.lengths[ d.index ] * relativePositionOnPath;\n  const accumulatedRel = accumulated / dimensions.totalLength;\n  console.log(`acc: ${ accumulated } rel: ${ accumulatedRel } on path: ${ relativePositionOnPath } path: ${ d.index }`);\n  return accumulatedRel;\n}\n\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths: readonly Path[]): Dimensions => {\n  const widths = paths.map(l => l.bbox().width);\n  const lengths = paths.map(l => l.length());\n  let totalLength = 0;\n  let totalWidth = 0;\n  for (const length of lengths) {\n    totalLength += length;\n  }\n  for (const width of widths) {\n    totalWidth += width;\n  }\n\n  return { totalLength, totalWidth, widths, lengths };\n};\n\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths: readonly Path[]): RectPositioned => {\n  const boxes = paths.map(p => p.bbox());\n  const corners = boxes.flatMap(b => RectsCorners(b));\n\n  return PointsBbox(...corners);\n};\n\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths: readonly Path[]): string => paths.map(p => p.toString()).join(`, `);\n\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths: readonly Path[]) => {\n  let lastPos = getEnd(paths[ 0 ]);\n  for (let index = 1; index < paths.length; index++) {\n    const start = getStart(paths[ index ]);\n    if (!PointsIsEqual(start, lastPos)) throw new Error(`Path index ${ index } does not start at prior path end. Start: ${ start.x },${ start.y } expected: ${ lastPos.x },${ lastPos.y }`);\n    lastPos = getEnd(paths[ index ]);\n  }\n};\n\nexport const toSvgString = (paths: readonly Path[]): readonly string[] => paths.flatMap(p => p.toSvgString());\n\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths: readonly Path[]): CompoundPath => {\n  guardContinuous(paths); // Throws an error if paths are not connected\n  const dims = computeDimensions(paths);\n\n  return Object.freeze({\n    segments: paths,\n    length: () => dims.totalLength,\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    interpolate: (t: number, useWidth = false) => interpolate(paths, t, useWidth, dims),\n    relativePosition: (point: Point, intersectionThreshold: number) => relativePosition(paths, point, intersectionThreshold, dims),\n    distanceToPoint: (point: Point) => distanceToPoint(paths, point),\n    bbox: () => bbox(paths),\n    toString: () => toString(paths),\n    toSvgString: () => toSvgString(paths),\n    kind: `compound`\n  });\n};\n","export * from './compound-path.js';\nexport type * from './path-type.js';\nexport * from './start-end.js';\n\n","import { guard } from \"./guard.js\";\nimport type { Rect } from \"./rect-types.js\";\n\n/**\n * Returns the area of `rect`\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect: Rect): number => {\n  guard(rect);\n  return rect.height * rect.width;\n};","import { guard } from \"./guard.js\";\nimport type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./guard.js\";\n\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number\n\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number\n\nexport function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\n\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth \n * @param heightValue \n * @returns \n */\nexport function applyFields(op: ApplyFieldOp, rectOrWidth: RectPositioned | Rect | number, heightValue?: number): RectPositioned | Rect {\n  let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n  let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n  if (width === undefined) throw new Error(`Param 'width' undefined`);\n  if (height === undefined) throw new Error(`Param 'height' undefined`);\n\n  width = op(width, `width`);\n  height = op(height, `height`);\n\n  if (typeof rectOrWidth === `object`) {\n    if (isPositioned(rectOrWidth)) {\n      const x = op(rectOrWidth.x, `x`);\n      const y = op(rectOrWidth.y, `y`);\n      return { ...rectOrWidth, width, height, x, y };\n    } else {\n      return {\n        ...rectOrWidth, width, height\n      }\n    }\n  }\n  return { width, height };\n}\n\nexport function applyMerge(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op \n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function applyMerge(\n  op: ApplyMergeOp,\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  guard(a, `a`);\n\n  if (isRect(b)) {\n    // Math op by another rectangle\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b.width),\n      y: op(a.y, b.height),\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    });\n  } else {\n    // Math op with a series of values\n    if (typeof b !== `number`) {\n      throw new TypeError(\n        `Expected second parameter of type Rect or number. Got ${ JSON.stringify(\n          b\n        ) }`\n      );\n    }\n    if (typeof c !== `number`) throw new Error(`Expected third param as height. Got ${ JSON.stringify(c) }`);\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b),\n      y: op(a.y, c),\n      width: op(a.width, b),\n      height: op(a.height, c),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b),\n      height: op(a.height, c),\n    });\n  }\n}\n\n/**\n * Uses `op` with `param` to width and height.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  parameter: number\n): RectPositioned;\n\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return isPositioned(rect) ? Object.freeze({\n    ...rect,\n    x: op(rect.x, parameter),\n    y: op(rect.y, parameter),\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  }) : Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}\n\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op \n * @param rect \n * @param parameter \n * @returns \n */\nexport function applyDim(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}","import type { RectPositioned } from \"./rect-types.js\";\nimport type { GridCardinalDirection } from '../grid/index.js';\nimport type { Point } from \"../point/point-type.js\";\n\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (\n  rect: RectPositioned,\n  card: GridCardinalDirection | `center`\n): Point => {\n  const { x, y, width, height } = rect;\n  switch (card) {\n    case `nw`: {\n      return Object.freeze({ x, y });\n    }\n    case `n`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y,\n      });\n    }\n    case `ne`: {\n      return Object.freeze({\n        x: x + width,\n        y,\n      });\n    }\n    case `sw`: {\n      return Object.freeze({ x, y: y + height });\n    }\n    case `s`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height,\n      });\n    }\n    case `se`: {\n      return Object.freeze({\n        x: x + width,\n        y: y + height,\n      });\n    }\n    case `w`: {\n      return Object.freeze({ x, y: y + height / 2 });\n    }\n    case `e`: {\n      return Object.freeze({ x: x + width, y: y + height / 2 });\n    }\n    case `center`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height / 2,\n      });\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown direction: ${ card }`);\n    }\n  }\n};","import type { Point } from \"../point/point-type.js\";\nimport { center } from \"./center.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * Perform basic point translation using a rectangle where its center is the origin.\n * \n * Thus the relative coordinate { x: 0, y: 0} corresponds to the absolute middle of the\n * rectangle.\n * \n * The relative coordinate { x: -1, y: -1 } corresponds to the rectangle's {x,y} properties, and so on.\n * @param rectAbsolute \n * @returns \n */\nexport const centerOrigin = (rectAbsolute: RectPositioned) => {\n  const c = center(rectAbsolute);\n  const w = rectAbsolute.width / 2;\n  const h = rectAbsolute.height / 2;\n\n  const relativeToAbsolute = (point: Point) => {\n    return {\n      ...point,\n      x: point.x * w + c.x,\n      y: point.y * h + c.y\n    }\n  }\n\n  const absoluteToRelative = (point: Point) => {\n    return {\n      ...point,\n      x: ((point.x - rectAbsolute.x) / w) - 1,\n      y: ((point.y - rectAbsolute.y) / h) - 1\n    }\n  }\n\n  return { relativeToAbsolute, absoluteToRelative }\n}","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./apply.js\";\n\nconst divideOp = (a: number, b: number) => a / b;\n\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n * x & y value of second parameter are ignored\n * ```js\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport function divide(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport function divide(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Divides rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function divide(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(divideOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(divideOp, rect, amount);\n}\n\nexport function divideDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(divideOp, rect, amount);\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { guard } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/join-points-to-lines.js';\n\nimport type { Point } from '../point/point-type.js';\nimport { corners } from \"./corners.js\";\nimport type { Line } from \"../line/line-type.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): readonly Line[] => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n});","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect \n * @param points \n * @returns \n */\nexport const encompass = (rect: RectPositioned, ...points: Point[]): RectPositioned => {\n  const x = points.map(p => p.x);\n  const y = points.map(p => p.y);\n\n  let minX = Math.min(...x, rect.x);\n  let minY = Math.min(...y, rect.y);\n  let maxX = Math.max(...x, rect.x + rect.width);\n  let maxY = Math.max(...y, rect.y + rect.height);\n\n  let rectW = Math.max(rect.width, maxX - minX);\n  let rectH = Math.max(rect.height, maxY - minY);\n\n  return Object.freeze({\n    ...rect,\n    x: minX,\n    y: minY,\n    width: rectW,\n    height: rectH\n  })\n} ","import type { Rect } from \"./rect-types.js\";\n\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el: HTMLElement): Rect => ({\n  width: el.clientWidth,\n  height: el.clientHeight,\n});","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport function fromNumbers(width: number, height: number): Rect;\n\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function fromNumbers(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): RectPositioned;\n\n/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n\nexport function fromNumbers(\n  xOrWidth: number,\n  yOrHeight: number,\n  width?: number,\n  height?: number\n): Rect | RectPositioned {\n  if (width === undefined || height === undefined) {\n    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);\n    if (typeof yOrHeight !== `number`) {\n      throw new TypeError(`height is not an number`);\n    }\n    return Object.freeze({ width: xOrWidth, height: yOrHeight });\n  }\n  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);\n  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);\n  if (typeof width !== `number`) throw new Error(`width is not an number`);\n  if (typeof height !== `number`) throw new Error(`height is not an number`);\n\n  return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { isRect, isRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a \n * @param b \n * @param c \n * @param d \n * @returns \n */\nexport function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned {\n  if (typeof a === `number`) {\n    if (typeof b === `number`) {\n      if (typeof c === `number` && typeof d === `number`) {\n        return { x: a, y: b, width: c, height: d }\n      } else if (isRect(c)) {\n        return { x: a, y: b, width: c.width, height: c.height }\n      } else {\n        throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n      }\n    } else {\n      throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n    }\n  } else if (isRectPositioned(a)) {\n    return a;\n  } else if (isRect(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { width: a.width, height: a.height, x: b, y: c };\n    } else if (isPoint(b)) {\n      return { width: a.width, height: a.height, x: b.x, y: b.y };\n    } else {\n      throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n    }\n  } else if (isPoint(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { x: a.x, y: a.y, width: b, height: c };\n    } else if (isRect(b)) {\n      return { x: a.x, y: a.y, width: b.width, height: b.height };\n    } else {\n      throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n    }\n  }\n  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n\n","import { isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a: Rect, b: Rect): boolean => {\n  if (a === undefined) throw new Error(`a undefined`);\n  if (b === undefined) throw new Error(`b undefined`);\n  return a.width === b.width && a.height === b.height;\n};\n\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (\n  a: Rect | RectPositioned,\n  b: Rect | RectPositioned\n): boolean => {\n  if (isPositioned(a) && isPositioned(b)) {\n    if (!PointsIsEqual(a, b)) return false;\n    return a.width === b.width && a.height === b.height;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    return a.width === b.width && a.height === b.height;\n  } else {\n    // One param is positioned, the other is not\n    return false;\n  }\n};","import { length as LinesLength } from '../line/length.js';\n\nimport { edges } from './edges.js';\nimport { guardPositioned } from './guard.js';\nimport type { RectPositioned } from './rect-types.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect: RectPositioned): readonly number[] => {\n  guardPositioned(rect, `rect`);\n  return edges(rect).map((l) => LinesLength(l));\n};\n","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./apply.js\";\n\nconst multiplyOp = (a: number, b: number) => a * b;\n\n\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n * x/y value of second parameter are ignored.\n * ```js\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport function multiply(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function multiply(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(multiplyOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * \n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n\n\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n * \n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns \n */\nexport function multiplyDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect \n * @param p \n * @returns \n */\nexport const nearestInternal = (rect: RectPositioned, p: Point): Point => {\n  let { x, y } = p;\n  if (x < rect.x) x = rect.x;\n  else if (x > rect.x + rect.width) x = rect.x + rect.width;\n  if (y < rect.y) y = rect.y;\n  else if (y > rect.y + rect.height) y = rect.y + rect.height;\n  return Object.freeze({ ...p, x, y });\n}","export const Placeholder = Object.freeze({\n  width: Number.NaN,\n  height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n  x: Number.NaN,\n  y: Number.NaN,\n  width: Number.NaN,\n  height: Number.NaN,\n});\n","import { guard } from \"./guard.js\";\nimport type { Rect } from \"./rect-types.js\";\n\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const perimeter = (rect: Rect): number => {\n  guard(rect);\n  return rect.height + rect.height + rect.width + rect.width;\n};\n","import { isPoint, isPoint3d } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\"\nimport type { Rect } from \"./rect-types.js\"\n\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n * \n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect \n * @returns \n */\nexport const dividerByLargestDimension = (rect: Rect) => {\n  const largest = Math.max(rect.width, rect.height);\n  return (value: number | Point) => {\n    if (typeof value === `number`) {\n      return value / largest;\n    } else if (isPoint3d(value)) {\n      return Object.freeze({\n        ...value,\n        x: value.x / largest,\n        y: value.y / largest,\n        z: value.x / largest\n      });\n    } else if (isPoint(value)) {\n      return Object.freeze({\n        ...value,\n        x: value.x / largest,\n        y: value.y / largest\n      });\n    } else throw new Error(`Param 'value' is neither number nor Point`);\n  }\n}","import { type RandomSource } from '@ixfx/random';\nimport { sum as PointsSum } from '../point/sum.js';\nimport type { Point } from '../point/point-type.js';\nimport { isPositioned } from './guard.js';\nimport type { Rect, RectPositioned } from './rect-types.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): RectPositioned => {\n  rando ??= Math.random;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    width: rando(),\n    height: rando(),\n  });\n};\n\nexport type RectRandomPointOpts = {\n  readonly strategy?: `naive`;\n  readonly randomSource?: RandomSource;\n  readonly margin?: { readonly x: number; readonly y: number };\n};\n\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (\n  within: Rect | RectPositioned,\n  options: RectRandomPointOpts = {}\n): Point => {\n  // TODO: Does not implement uniform distribution\n  // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n  const rand = options.randomSource ?? Math.random;\n  const margin = options.margin ?? { x: 0, y: 0 };\n\n  const x = rand() * (within.width - margin.x - margin.x);\n  const y = rand() * (within.height - margin.y - margin.y);\n\n  const pos = { x: x + margin.x, y: y + margin.y };\n  return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};","import { applyMerge } from \"./apply.js\";\nimport { isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\nconst subtractOp = (a: number, b: number) => a - b;\n\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * x,y of second parameter is ignored.\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function subtract(a: Rect, b: Rect | RectPositioned): Rect;\nexport function subtract(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * const rect = { width: 100, height: 100 };\n * Rects.subtract(rect, 200, 200);\n * // Yields: { width: -100, height: -100 }\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport function subtract(a: Rect, width: number, height: number): Rect;\n\nexport function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a: Rect | undefined, b: RectPositioned | Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return applyMerge(subtractOp, a, b, c);\n}\n\n/**\n * Subtracts a width & height from `a`. Leaves x & y as-is.\n * ```js\n * const rect = { x: 10, y: 20, width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { x:10, y: 20, width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport function subtractSize(a: RectPositioned, b: Rect | number, c?: number): RectPositioned;\n\n\n/**\n * Subtracts a width & height from `a`.\n * ```js\n * const rect = { width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport function subtractSize(a: Rect, b: Rect | number, c?: number): Rect;\n\n\n\nexport function subtractSize(a: Rect | RectPositioned, b: Rect | number, c?: number): Rect | RectPositioned {\n  const w = typeof b === `number` ? b : b.width;\n  const h = typeof b === `number` ? c : b.height;\n  if (h === undefined) throw new Error(`Expected height as third parameter`);\n  const r = {\n    ...a,\n    width: a.width - w,\n    height: a.height - h\n  };\n  return r;\n}\n\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 }, \n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a \n * @param b \n * @returns \n */\nexport function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x - xB,\n    y: y - yB,\n    width: a.width - b.width,\n    height: a.height - b.height\n  })\n}","import { applyMerge } from \"./apply.js\";\nimport { getRectPositioned, isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\nconst sumOp = (a: number, b: number) => a + b;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * x/y of second parameter are ignored\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function sum(a: Rect, b: Rect | RectPositioned): Rect;\n\n/**\n * Sums width/height of `b` with `a`, returning result.\n * \n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n * \n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a \n * @param b \n */\nexport function sum(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Sums width/height of `rect` with `width` and `height`\n * \n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n\nexport function sum(a: Rect, b: RectPositioned | Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return applyMerge(sumOp, a, b, c);\n}\n\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a \n * @param b \n * @returns \n */\nexport function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x + xB,\n    y: y + yB,\n    width: a.width + b.width,\n    height: a.height + b.height\n  })\n}","import { isPositioned, isRect } from \"./guard.js\";\nimport type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./rect-types.js\";\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: Rect): RectArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: RectPositioned): RectPositionedArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n\nexport function toArray(\n  rect: Rect | RectPositioned\n): RectArray | RectPositionedArray {\n  if (isPositioned(rect)) {\n    return [ rect.x, rect.y, rect.width, rect.height ];\n  } else if (isRect(rect)) {\n    return [ rect.width, rect.height ];\n  } else {\n    throw new Error(\n      `Param 'rect' is not a rectangle. Got: ${ JSON.stringify(rect) }`\n    );\n  }\n}\n","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center-origin.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\nexport type * from './rect-types.js';","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { project as PointsProject } from \"../point/project.js\";\n// import { guard as PointGuard } from \"../point/Guard.js\";\n// import { throwNumberTest } from \"@ixfx/guards\";\n// import { piPi } from \"../pi.js\";\n\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\n\nexport const Empty = Object.freeze({\n  a: { x: 0, y: 0 },\n  b: { x: 0, y: 0 },\n  c: { x: 0, y: 0 },\n});\n\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\n\nexport const Placeholder = Object.freeze({\n  a: { x: Number.NaN, y: Number.NaN },\n  b: { x: Number.NaN, y: Number.NaN },\n  c: { x: Number.NaN, y: Number.NaN },\n});\n\n\n\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (\n  origin?: Point,\n  length = 10,\n  angleRadian: number = Math.PI / 2\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const a = PointsProject(origin, length, Math.PI - -angleRadian / 2);\n  const c = PointsProject(origin, length, Math.PI - angleRadian / 2);\n  return { a, b: origin, c };\n};","import type { Point } from \"../point/point-type.js\";\nimport { equilateralFromVertex } from \"../triangle/create.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { rotate as PointsRotate } from \"../point/rotate.js\";\nexport type ArrowOpts = {\n  readonly arrowSize?: number;\n  readonly tailLength?: number;\n  readonly tailThickness?: number;\n  readonly angleRadian?: number;\n};\n\n\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (\n  origin: Point,\n  from: `tip` | `tail` | `middle`,\n  opts: ArrowOpts = {}\n): ReadonlyArray<Point> => {\n  const tailLength = opts.tailLength ?? 10;\n  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n  const angleRadian = opts.angleRadian ?? 0;\n  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n\n  const triAngle = Math.PI / 2;\n\n  let tri: Triangle;\n  let tailPoints: ReadonlyArray<Point>;\n\n  if (from === `tip`) {\n    tri = equilateralFromVertex(origin, arrowSize, triAngle);\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n  } else if (from === `middle`) {\n    const midX = tailLength + arrowSize / 2;\n    const midY = tailThickness / 2;\n    tri = equilateralFromVertex(\n      {\n        x: origin.x + arrowSize * 1.2,\n        y: origin.y,\n      },\n      arrowSize,\n      triAngle\n    );\n\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x - midX, y: origin.y - midY },\n        tailLength + arrowSize,\n        tailThickness\n      )\n    );\n  } else {\n    //const midY = origin.y - tailThickness/2;\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n    tri = equilateralFromVertex(\n      { x: origin.x + tailLength + arrowSize * 0.7, y: origin.y },\n      arrowSize,\n      triAngle\n    );\n  }\n\n  const arrow = PointsRotate(\n    [\n      tailPoints[ 0 ],\n      tailPoints[ 1 ],\n      tri.a,\n      tri.b,\n      tri.c,\n      tailPoints[ 2 ],\n      tailPoints[ 3 ],\n    ],\n    angleRadian,\n    origin\n  );\n\n  return arrow;\n};","import type { Triangle } from \"./triangle-type.js\";\nimport { isPoint, guard as PointsGuard, isPlaceholder as PointsIsPlaceholder, isEmpty as PointsIsEmpty } from '../point/guard.js'\nimport { isEqual as PointsIsEqual} from \"../point/is-equal.js\";\n\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t: Triangle, name = `t`) => {\n  if (t === undefined) throw new Error(`{$name} undefined`);\n  PointsGuard(t.a, name + `.a`);\n  PointsGuard(t.b, name + `.b`);\n  PointsGuard(t.c, name + `.c`);\n};\n\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p: unknown): p is Triangle => {\n  if (p === undefined) return false;\n  const tri = p as Triangle;\n  if (!isPoint(tri.a)) return false;\n  if (!isPoint(tri.b)) return false;\n  if (!isPoint(tri.c)) return false;\n  return true;\n};\n\n\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t: Triangle): boolean =>\n  PointsIsEmpty(t.a) && PointsIsEmpty(t.b) && PointsIsEmpty(t.c);\n\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t: Triangle): boolean =>\n  PointsIsPlaceholder(t.a) &&\n  PointsIsPlaceholder(t.b) &&\n  PointsIsPlaceholder(t.c);\n\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: Triangle, b: Triangle): boolean =>\n  PointsIsEqual(a.a, b.a) &&\n  PointsIsEqual(a.b, b.b) &&\n  PointsIsEqual(a.c, b.c);","import type { Point } from \"../point/point-type.js\";\nimport { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t: Triangle): Point => {\n  guard(t);\n  const total = PointsReduce(\n    [ t.a, t.b, t.c ],\n    (p: Point, accumulator: Point) => ({\n      x: p.x + accumulator.x,\n      y: p.y + accumulator.y,\n    })\n  );\n  const div = {\n    x: total.x / 3,\n    y: total.y / 3,\n  };\n  return div;\n};","import type { RandomSource } from \"@ixfx/random\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport { isCircle, isCirclePositioned } from \"../circle/guard.js\";\nimport { isRect, isRectPositioned } from \"../rect/guard.js\";\nimport { randomPoint as circleRandomPoint } from '../circle/random.js';\nimport { randomPoint as rectRandomPoint } from '../rect/random.js';\nimport type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport type { Circle } from \"../circle/circle-type.js\";\nimport { center as circleCenter } from '../circle/center.js';\nimport { isTriangle } from \"../triangle/guard.js\";\nimport { centroid as triangleCentroid } from \"../triangle/centroid.js\";\nimport { center as rectCenter } from '../rect/center.js';\n\nexport type ShapeRandomPointOpts = {\n  readonly randomSource: RandomSource;\n};\n\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * @param shape \n * @param opts \n * @returns \n */\nexport const randomPoint = (\n  shape: ShapePositioned,\n  opts: Partial<ShapeRandomPointOpts> = {}\n): Point => {\n  if (isCirclePositioned(shape)) {\n    return circleRandomPoint(shape, opts);\n  } else if (isRectPositioned(shape)) {\n    return rectRandomPoint(shape, opts);\n  }\n  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n\n// }\n\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (\n  shape?: Rect | Triangle | Circle\n): Point => {\n  if (shape === undefined) {\n    return Object.freeze({ x: 0.5, y: 0.5 });\n  } else if (isRect(shape)) {\n    return rectCenter(shape);\n  } else if (isTriangle(shape)) {\n    return triangleCentroid(shape);\n  } else if (isCircle(shape)) {\n    return circleCenter(shape);\n  } else {\n    throw new Error(`Unknown shape: ${ JSON.stringify(shape) }`);\n  }\n};\n","import { isCirclePositioned } from \"../circle/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/intersecting.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\n\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (\n  a: ShapePositioned,\n  b: ShapePositioned | Point\n): boolean => {\n  if (isCirclePositioned(a)) {\n    return CirclesIsIntersecting(a, b);\n  } else if (isRectPositioned(a)) {\n    return RectsIsIntersecting(a, b);\n  }\n  throw new Error(\n    `a or b are unknown shapes. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`\n  );\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { toCartesian } from \"../polar/conversions.js\";\nimport { Empty as PointEmpty } from \"../point/empty.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (\n  outerRadius: number,\n  points = 5,\n  innerRadius?: number,\n  origin: Point = PointEmpty,\n  opts?: { readonly initialAngleRadian?: number }\n): readonly Point[] => {\n  resultThrow(integerTest(points, `positive`, `points`));\n  const angle = (Math.PI * 2) / points;\n  const angleHalf = angle / 2;\n\n  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n  if (innerRadius === undefined) innerRadius = outerRadius / 2;\n\n  let a = initialAngle;\n  const pts: Point[] = [];\n\n  for (let index = 0; index < points; index++) {\n    const peak = toCartesian(outerRadius, a, origin);\n    const left = toCartesian(innerRadius, a - angleHalf, origin);\n    const right = toCartesian(innerRadius, a + angleHalf, origin);\n\n    pts.push(left, peak);\n    if (index + 1 < points) pts.push(right);\n    a += angle;\n  }\n  return pts;\n};\n","export type * from './shape-type.js';\nexport * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';","import type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Path } from \"./path/path-type.js\";\nimport type { Point } from \"./point/point-type.js\";\nimport { joinPointsToLines } from './line/join-points-to-lines.js';\nimport { toPath } from './line/to-path.js';\nimport { distance as PointsDistance } from \"./point/distance.js\";\nimport { sortByNumericProperty } from \"@ixfx/arrays\";\n\nexport type Waypoint = CirclePositioned;\n\nexport type WaypointOpts = {\n  readonly maxDistanceFromLine: number;\n  readonly enforceOrder: boolean;\n};\n\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints \n * @param opts \n * @returns \n */\nexport const fromPoints = (\n  waypoints: readonly Point[],\n  opts: Partial<WaypointOpts> = {}\n) => {\n  const lines = joinPointsToLines(...waypoints);\n  return init(\n    lines.map((l) => toPath(l)),\n    opts\n  );\n};\n\n/**\n * Result \n */\nexport type WaypointResult = {\n  /**\n   * Path being compared against\n   */\n  path: Path\n  /**\n   * Index of this path in original `paths` array\n   */\n  index: number\n  /**\n   * Nearest point on path. See also {@link distance}\n   */\n  nearest: Point\n  /**\n   * Closest distance to path. See also {@link nearest}\n   */\n  distance: number\n  /**\n   * Rank of this result, 0 being highest.\n   */\n  rank: number\n  /**\n   * Relative position on this path segment\n   * 0 being start, 0.5 middle and so on.\n   */\n  positionRelative: number\n}\n\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => WaypointResult[]\n\n/**\n * Initialise\n * \n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths \n * @param opts \n * @returns \n */\nexport const init = (paths: readonly Path[], opts: Partial<WaypointOpts> = {}): Waypoints => {\n  //const enforceOrder = opts.enforceOrder ?? true;\n  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n\n  const checkUnordered = (pt: Point): WaypointResult[] => {\n    const results = paths.map((p, index) => {\n      const nearest = p.nearest(pt);\n      const distance = PointsDistance(pt, nearest);\n\n      // Relative position of nearest point on this path segment\n      const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);;\n      return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n    });\n\n    const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n    const sorted = sortByNumericProperty(filtered, `distance`);\n\n    // Assign ranks\n\n    for (let rank = 0; rank < sorted.length; rank++) {\n      sorted[ rank ].rank = rank;\n    }\n    return sorted;\n  };\n\n  // const checkUnordered = (p:Point) => {\n  //   // Calculate progress of pointer between all the waypoint lines\n  //   const progresses = lines.map((line, index) => (\n  //     {\n  //       index,\n  //       score: Points.progressBetween(p, line.a, line.b)\n  //     }));\n  //   // Sort by closest\n  //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n  // };\n  return checkUnordered;\n};\n","import { sortByNumericProperty } from \"@ixfx/arrays\";\nimport type { RandomSource } from \"@ixfx/random\";\nimport { randomPoint as ShapesRandomPoint, type ShapePositioned } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/intersecting.js\";\nimport type { Circle, CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Point } from \"./point/point-type.js\";\n\nexport type RandomOpts = {\n  readonly attempts?: number\n  readonly randomSource?: RandomSource\n}\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles: readonly Circle[], container: ShapePositioned, opts: RandomOpts = {}) => {\n  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);\n  const attempts = opts.attempts ?? 2000;\n\n  const sorted = sortByNumericProperty(circles, `radius`);\n  const positionedCircles: CirclePositioned[] = [];\n\n  const willHit = (b: Point, radius: number) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n\n  while (sorted.length > 0) {\n    //eslint-disable-next-line functional/immutable-data\n    const circle = sorted.pop();\n    if (!circle) break;\n\n    const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < attempts; index++) {\n      const position = ShapesRandomPoint(container, randomPointOpts);\n      if (!willHit(position, circle.radius)) {\n        //eslint-disable-next-line functional/immutable-data\n        positionedCircles.push(Object.freeze({ ...circle, ...position }));\n        break;\n      }\n    }\n  }\n\n  return positionedCircles;\n};","export * as CirclePacking from './circle-packing.js';","\nimport type { Point } from './point/point-type.js';\nimport { degreeToRadian } from './angles.js';\nimport type { Path } from './path/index.js';\n\n/**\n * An ellipse\n */\nexport type Ellipse = {\n  readonly radiusX: number\n  readonly radiusY: number\n  /**\n   * Rotation, in radians\n   */\n  readonly rotation?: number\n  readonly startAngle?: number\n  readonly endAngle?: number\n}\n\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse\n\n\nexport const fromDegrees = (radiusX: number, radiusY: number, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360): Ellipse => ({\n  radiusX, radiusY,\n  rotation: degreeToRadian(rotationDeg),\n  startAngle: degreeToRadian(startAngleDeg),\n  endAngle: degreeToRadian(endAngleDeg)\n});\n\nexport type EllipticalPath = Ellipse & Path & {\n  readonly kind: `elliptical`\n};","import type { Point } from \"./point/point-type.js\";\nimport { distance } from \"./point/distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpShortestDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = distanceFromPointToLine(points[ index_ ], firstPoint, lastPoint);\n\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpShortestDistance(l1, epsilon);\n    const r2 = rdpShortestDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];//concat(r2);\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpPerpendicularDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = findPerpendicularDistance(points[ index_ ], firstPoint, lastPoint);\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpPerpendicularDistance(l1, epsilon);\n    const r2 = rdpPerpendicularDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n\nfunction findPerpendicularDistance(p: Point, p1: Point, p2: Point) {\n  // if start and end point are on the same x the distance is the difference in X.\n  let result;\n  let slope;\n  let intercept;\n  if (p1.x == p2.x) {\n    result = Math.abs(p.x - p1.x);\n  } else {\n    slope = (p2.y - p1.y) / (p2.x - p1.x);\n    intercept = p1.y - (slope * p1.x);\n    result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n  }\n\n  return result;\n}\n\n\nconst distanceFromPointToLine = (p: Point, index: Point, index_: Point) => {\n  const lineLength = distance(index, index_);//First, we need the length of the line segment.\n  if (lineLength == 0) {\t//if it's 0, the line is actually just a point.\n    return distance(p, index);\n  }\n  const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n\n  //t is very important. t is a number that essentially compares the individual coordinates\n  //distances between the point and each point on the line.\n\n  if (t < 0) {\t//if t is less than 0, the point is behind i, and closest to i.\n    return distance(p, index);\n  }\t//if greater than 1, it's closest to j.\n  if (t > 1) {\n    return distance(p, index_);\n  }\n  return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n}\n\n\n","import { type TraversableTree } from '@ixfx/collections';\nimport * as Shapes from './shape/index.js';\nimport type { Point } from './point/point-type.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/from-top-left.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/from.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/rect-types.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n  /**\n   * Maximum items per node\n   */\n  readonly maxItems: number;\n  /**\n   * Maximum level of sub-division\n   */\n  readonly maxLevels: number;\n};\n\n/**\n * Direction\n */\nexport enum Direction {\n  Nw,\n  Ne,\n  Sw,\n  Se,\n}\n\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds: RectPositioned, initialData: readonly QuadTreeItem[] = [], opts: Partial<QuadTreeOpts> = {}): QuadTreeNode => {\n  const o: QuadTreeOpts = {\n    maxItems: opts.maxItems ?? 4,\n    maxLevels: opts.maxLevels ?? 4\n  };\n\n  const n = new QuadTreeNode(undefined, bounds, 0, o);\n  for (const d of initialData) {\n    n.add(d);\n  }\n  return n;\n};\n\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n * \n */\nexport class QuadTreeNode implements TraversableTree<QuadTreeItem[]> {\n  #items: QuadTreeItem[] = [];\n  #children: QuadTreeNode[] = [];\n  #parent: QuadTreeNode | undefined;\n  /**\n   * Constructor\n   * @param boundary\n   * @param level\n   * @param opts\n   */\n  constructor(\n    parent: QuadTreeNode | undefined,\n    readonly boundary: RectPositioned,\n    readonly level: number,\n    readonly opts: QuadTreeOpts\n  ) {\n    this.#parent = parent;\n  }\n\n  getLengthChildren(): number {\n    return this.#children.length;\n  }\n\n  *parents(): IterableIterator<QuadTreeNode> {\n    //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n    let n: QuadTreeNode | undefined = this;\n    while (n.#parent !== undefined) {\n      yield n.#parent;\n      n = n.#parent;\n    }\n  }\n\n  getParent() {\n    return this.#parent;\n  }\n\n  /**\n   * Iterates over immediate children\n   */\n  *children(): IterableIterator<QuadTreeNode> {\n    for (const c of this.#children) {\n      yield c;\n    }\n  }\n\n  /**\n   * Array of QuadTreeItem\n   * @returns\n   */\n  getValue() {\n    return this.#items;\n  }\n\n  getIdentity() {\n    return this;\n  }\n  /**\n   * Get a descendant node in a given direction\n   * @param d\n   * @returns\n   */\n  direction(d: Direction): QuadTreeNode | undefined {\n    return this.#children[ d ] as QuadTreeNode | undefined;\n  }\n\n  /**\n   * Add an item to the quadtree\n   * @param p\n   * @returns False if item is outside of boundary, True if item was added\n   */\n  add(p: QuadTreeItem): boolean {\n    if (!Shapes.isIntersecting(this.boundary, p)) return false;\n\n    if (this.#children.length > 0) {\n      for (const d of this.#children) (d).add(p);\n      return true;\n    }\n\n    this.#items.push(p);\n\n    if (\n      this.#items.length > this.opts.maxItems &&\n      this.level < this.opts.maxLevels\n    ) {\n      if (this.#children.length === 0) {\n        this.#subdivide();\n      }\n\n      // Add to child\n      for (const item of this.#items) {\n        for (const d of this.#children) (d).add(item);\n      }\n      //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n      this.#items = [];\n    }\n    return true;\n  }\n\n  /**\n   * Returns true if point is inside node's boundary\n   * @param p\n   * @returns\n   */\n  couldHold(p: Point) {\n    return RectsIntersectsPoint(this.boundary, p);\n  }\n\n  #subdivide() {\n    const w = this.boundary.width / 2;\n    const h = this.boundary.height / 2;\n    const x = this.boundary.x;\n    const y = this.boundary.y;\n\n    // top-left corners of each of the four new sections\n    const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n    const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n    // rects.forEach((r, index) => {\n    //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n    // });\n    this.#children = rects.map(\n      (r) => new QuadTreeNode(this, r, this.level + 1, this.opts)\n    );\n  }\n}\n","\nimport type { Point } from './point/point-type.js';\nimport type { Rect } from './rect/index.js';\nimport { isPoint } from './point/index.js';\nimport { isRect } from './rect/guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/placeholder.js';\n\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (\n  a: number | Point,\n  b?: number | Rect,\n  c?: number | Rect,\n  d?: number\n) => Point;\n\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n  /**\n   * Relative to absolute coordinates\n   */\n  readonly abs: Scaler;\n  /**\n   * Absolute to relative coordintes\n   */\n  readonly rel: Scaler;\n\n  readonly width: number;\n\n  readonly height: number;\n\n  computeScale(): Point\n};\n\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (\n  scaleBy: ScaleBy = `both`,\n  defaultRect?: Rect\n): ScalerCombined => {\n  const defaultBounds = defaultRect ?? PlaceholderRect;\n\n  let sw = 1;\n  let sh = 1;\n  let s = { x: 1, y: 1 };\n\n  const computeScale = () => {\n    switch (scaleBy) {\n      case `height`: {\n        return { x: sh, y: sh };\n      }\n      case `width`: {\n        return { x: sw, y: sw };\n      }\n      case `min`: {\n        return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n      }\n      case `max`: {\n        return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n      }\n      default: {\n        return { x: sw, y: sh };\n      }\n    }\n  };\n\n  const normalise = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): [ x: number, y: number, w: number, h: number ] => {\n    let inX = Number.NaN;\n    let inY = Number.NaN;\n    let outW = defaultBounds.width;\n    let outH = defaultBounds.height;\n\n    if (typeof a === `number`) {\n      inX = a;\n      if (typeof b === `number`) {\n        inY = b;\n        if (c === undefined) return [ inX, inY, outW, outH ];\n        if (isRect(c)) {\n          outW = c.width;\n          outH = c.height;\n        } else if (typeof c === `number`) {\n          outW = c;\n          if (typeof d === `number`) {\n            outH = d;\n          } else {\n            throw new TypeError(`Missing final height value`);\n          }\n        } else throw new Error(`Missing valid output range`);\n      } else if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else {\n        throw new Error(\n          `Expected input y or output Rect to follow first number parameter`\n        );\n      }\n    } else if (isPoint(a)) {\n      inX = a.x;\n      inY = a.y;\n      if (b === undefined) return [ inX, inY, outW, outH ];\n      if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else if (typeof b === `number`) {\n        outW = b;\n        if (typeof c === `number`) {\n          outH = c;\n        } else {\n          throw new TypeError(\n            `Expected height as third parameter after Point and output width`\n          );\n        }\n      } else {\n        throw new TypeError(\n          `Expected Rect or width as second parameter when first parameter is a Point`\n        );\n      }\n    } else {\n      throw new Error(`Expected input Point or x value as first parameter`);\n    }\n    return [ inX, inY, outW, outH ];\n  };\n\n  const scaleAbs = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(true, ...n);\n  };\n\n  const scaleRel = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(false, ...n);\n  };\n\n  const scaleNormalised = (\n    abs: boolean,\n    x: number,\n    y: number,\n    w: number,\n    h: number\n  ): Point => {\n    if (Number.isNaN(w)) throw new Error(`Output width range missing`);\n    if (Number.isNaN(h)) throw new Error(`Output height range missing`);\n\n    // If output dimensions has changed since last, create a new scale\n    if (w !== sw || h !== sh) {\n      sw = w;\n      sh = h;\n      s = computeScale();\n    }\n\n    return abs ? {\n      x: x * s.x,\n      y: y * s.y,\n    } : {\n      x: x / s.x,\n      y: y / s.y,\n    };\n  };\n\n  return {\n    computeScale,\n    rel: scaleRel,\n    abs: scaleAbs,\n    width: defaultBounds.width,\n    height: defaultBounds.height\n  };\n};\n\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }","import type { Point, Point3d } from './point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle/circle-type.js';\nimport type { Sphere } from './shape/index.js';\n\nimport { toPositioned as circleToPositioned } from './circle/to-positioned.js';\nimport { scale, linearSpace } from '@ixfx/numbers';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n  /**\n   * Upper limit of points to produce.\n   * By default, 5000.\n   */\n  readonly maxPoints?: number;\n  /**\n   * Density value (0..1) which determines spacing of points.\n   * This is useful because it scales with whatever circle radius is given\n   * Use this parameter OR the `spacing` parameter.\n   */\n  readonly density?: number;\n  /**\n   * Spacing between points.\n   * Use this option OR the density value.\n   */\n  readonly spacing?: number;\n  /**\n   * Rotation offset to apply, in radians. 0 by default\n   */\n  readonly rotation?: number;\n};\n\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(\n  circle?: Circle,\n  opts: VogelSpiralOpts = {}\n): IterableIterator<Point> {\n  const maxPoints = opts.maxPoints ?? 5000;\n  const density = opts.density ?? 0.95;\n  const rotationOffset = opts.rotation ?? 0;\n\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const max = c.radius;\n  //eslint-disable-next-line functional/no-let\n  let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n  if (opts.spacing) spacing = opts.spacing;\n\n  //eslint-disable-next-line functional/no-let\n  let radius = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n  //eslint-disable-next-line functional/no-let\n  let angle = 0;\n  while (count < maxPoints && radius < max) {\n    radius = spacing * count ** 0.5;\n    angle = rotationOffset + (count * 2 * pi) / goldenSection;\n    yield Object.freeze({\n      x: c.x + radius * cos(angle),\n      y: c.y + radius * sin(angle),\n    });\n    count++;\n  }\n}\n\nexport type CircleRingsOpts = {\n  readonly rings?: number;\n  /**\n   * Rotation offset, in radians\n   */\n  readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(\n  circle?: Circle | CirclePositioned,\n  opts: CircleRingsOpts = {}\n): IterableIterator<Point> {\n  const rings = opts.rings ?? 5;\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const ringR = 1 / rings;\n  const rotationOffset = opts.rotation ?? 0;\n\n  //eslint-disable-next-line functional/no-let\n  let ringCount = 1;\n\n  // Origin\n  yield Object.freeze({ x: c.x, y: c.y });\n\n  //eslint-disable-next-line functional/no-let\n  for (let r = ringR; r <= 1; r += ringR) {\n    const n = Math.round(pi / asin(1 / (2 * ringCount)));\n    for (const theta of linearSpace(0, piPi, n + 1)) {\n      yield Object.freeze({\n        x: c.x + r * cos(theta + rotationOffset) * c.radius,\n        y: c.y + r * sin(theta + rotationOffset) * c.radius,\n      });\n    }\n    ringCount++;\n  }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(\n  samples = 100,\n  rotationRadians = 0,\n  sphere?: Sphere\n): IterableIterator<Point3d> {\n  const offset = 2 / samples;\n  const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n\n  for (let index = 0; index < samples; index++) {\n    const y = index * offset - 1 + offset / 2;\n    const r = sqrt(1 - pow(y, 2));\n    const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n    const x = cos(a) * r;\n    const z = sin(a) * r;\n    //eslint-disable-next-line functional/immutable-data\n    yield Object.freeze({\n      x: s.x + x * s.radius,\n      y: s.y + y * s.radius,\n      z: s.z + z * s.radius,\n    });\n  }\n}\n","import type { Triangle } from \"./triangle-type.js\";\nimport { angleRadian as PointsAngleRadian } from '../point/angle.js';\nimport { guard } from \"./guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    PointsAngleRadian(t.a, t.b),\n    PointsAngleRadian(t.b, t.c),\n    PointsAngleRadian(t.c, t.a),\n  ];\n};\n\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return radianToDegree(angles(t));\n};","\nimport type { Triangle } from \"./triangle-type.js\";\nimport type { PolyLine } from \"../line/line-type.js\";\nimport { joinPointsToLines } from \"../line/join-points-to-lines.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t: Triangle): PolyLine => {\n  guard(t);\n  return joinPointsToLines(t.a, t.b, t.c, t.a);\n};","import { guard } from \"./guard.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t: Triangle): number => {\n  guard(t, `t`);\n\n  // Get length of edges\n  const lengths = edges(t).map((l) => LinesLength(l));\n\n  // Add up length of edges, halve\n  const p = (lengths[ 0 ] + lengths[ 1 ] + lengths[ 2 ]) / 2;\n  return Math.sqrt(p * (p - lengths[ 0 ]) * (p - lengths[ 1 ]) * (p - lengths[ 2 ]));\n};","import { getPointParameter } from \"../point/get-point-parameter.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { guard } from \"./guard.js\";\nimport type { BarycentricCoord, Triangle } from \"./triangle-type.js\";\n\n\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): BarycentricCoord => {\n  const pt = getPointParameter(a, b);\n\n  const ab = (x: number, y: number, pa: Point, pb: Point) =>\n    (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n\n  const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n  const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n  const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n\n  return {\n    a: alpha,\n    b: theta,\n    c: gamma,\n  };\n};\n\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (\n  t: Triangle,\n  bc: BarycentricCoord\n): Point => {\n  guard(t);\n  const { a, b, c } = t;\n\n  const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n  const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n\n  if (a.z && b.z && c.z) {\n    const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n    return Object.freeze({ x, y, z });\n  } else {\n    return Object.freeze({ x, y });\n  }\n};\n","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t: Triangle, inflation = 0): RectPositioned => {\n  const { a, b, c } = t;\n  const xMin = Math.min(a.x, b.x, c.x) - inflation;\n  const xMax = Math.max(a.x, b.x, c.x) + inflation;\n  const yMin = Math.min(a.y, b.y, c.y) - inflation;\n  const yMax = Math.max(a.y, b.y, c.y) + inflation;\n\n  const r: RectPositioned = {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin,\n  };\n  return r;\n};","import type { Point } from \"../point/point-type.js\";\nimport { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t: Triangle): ReadonlyArray<Point> => {\n  guard(t);\n  return [ t.a, t.b, t.c ];\n};","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { fromNumbers as PointsFromNumbers } from \"../point/from.js\";\nimport { guard as PointGuard } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { piPi } from \"../pi.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/conversions.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (\n  origin: Point,\n  radius: number,\n  opts: { readonly initialAngleRadian?: number } = {}\n): Triangle => {\n  resultThrow(numberTest(radius, `positive`, `radius`));\n  PointGuard(origin, `origin`);\n\n  const initialAngleRadian = opts.initialAngleRadian ?? 0;\n\n  const angles = [\n    initialAngleRadian,\n    initialAngleRadian + (piPi * 1) / 3,\n    initialAngleRadian + (piPi * 2) / 3,\n  ];\n  const points = angles.map((a) => PolarToCartesian(radius, a, origin));\n  return fromPoints(points);\n};\n\n\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords: readonly number[]): Triangle => {\n  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);\n  if (coords.length !== 6) {\n    throw new Error(\n      `coords array expected with 6 elements. Got ${ coords.length }`\n    );\n  }\n  return fromPoints(PointsFromNumbers(...coords));\n};\n\n\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points: readonly Point[]): Triangle => {\n  if (!Array.isArray(points)) throw new Error(`points expected as array`);\n  if (points.length !== 3) {\n    throw new Error(\n      `points array expected with 3 elements. Got ${ points.length }`\n    );\n  }\n  const t: Triangle = {\n    a: points[ 0 ],\n    b: points[ 1 ],\n    c: points[ 2 ],\n  };\n  return t;\n};\n","import { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\n\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t: Triangle): number => {\n  guard(t);\n  return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport { area } from \"./area.js\";\nimport { centroid } from \"./centroid.js\";\nimport { perimeter } from \"./perimeter.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t: Triangle): CirclePositioned => {\n  const c = centroid(t);\n  const p = perimeter(t) / 2;\n  const a = area(t);\n  const radius = a / p;\n  return { radius, ...c };\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { getPointParameter } from \"../point/get-point-parameter.js\";\nimport { bbox } from \"./bbox.js\";\nimport { intersectsPoint as RectsIntersectsPoint } from '../rect/Intersects.js';\nimport { barycentricCoord } from \"./barycentric.js\";\n\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport const intersectsPoint = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): boolean => {\n  const box = bbox(t);\n\n  const pt = getPointParameter(a, b);\n\n  // If it's not in the bounding box, can return false straight away\n  if (!RectsIntersectsPoint(box, pt)) return false;\n\n  const bc = barycentricCoord(t, pt);\n\n  return (\n    0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1\n  );\n};\n","import { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { distance } from \"../point/distance.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    distance(t.a, t.b),\n    distance(t.b, t.c),\n    distance(t.c, t.a),\n  ];\n};","import { angles } from \"./angles.js\";\nimport { guard } from \"./guard.js\";\nimport { lengths } from \"./lengths.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t: Triangle): boolean => {\n  guard(t);\n  const [ a, b, c ] = lengths(t);\n  return a === b && b === c;\n};\n\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t: Triangle): boolean => {\n  const [ a, b, c ] = lengths(t);\n  if (a === b) return true;\n  if (b === c) return true;\n  if (c === a) return true;\n  return false;\n};\n\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t: Triangle): boolean =>\n  angles(t).includes(Math.PI / 2);\n\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t: Triangle): boolean => !isRightAngle(t);\n\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t: Triangle): boolean =>\n  !angles(t).some((v) => v >= Math.PI / 2);\n\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t: Triangle): boolean =>\n  angles(t).some((v) => v > Math.PI / 2);\n","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport const apply = (\n  t: Triangle,\n  fn: (p: Point, label?: string) => Point\n) =>\n  Object.freeze<Triangle>({\n    ...t,\n    a: fn(t.a, `a`),\n    b: fn(t.b, `b`),\n    c: fn(t.c, `c`),\n  });","import { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\nimport { centroid } from './centroid.js';\nimport type { Triangle } from \"./triangle-type.js\";\nimport type { CirclePositioned } from '../circle/circle-type.js';\n\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t: Triangle): CirclePositioned => {\n  const [ a, b, c ] = edges(t).map((l) => LinesLength(l));\n  const cent = centroid(t);\n  const radius =\n    (a * b * c) /\n    Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n  return {\n    radius,\n    ...cent,\n  };\n};","import type { Point } from \"../point/point-type.js\";\nimport { centroid } from \"./centroid.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * \n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport const rotate = (\n  triangle: Triangle,\n  amountRadian?: number,\n  origin?: Point\n): Triangle => {\n  if (amountRadian === undefined || amountRadian === 0) return triangle;\n  if (origin === undefined) origin = centroid(triangle);\n  return Object.freeze({\n    ...triangle,\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};\n\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n * \n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport const rotateByVertex = (\n  triangle: Triangle,\n  amountRadian: number,\n  vertex: `a` | `b` | `c` = `b`\n): Triangle => {\n  const origin =\n    vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n  return Object.freeze({\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};","import { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport const toFlatArray = (t: Triangle): readonly number[] => {\n  guard(t);\n  return [ t.a.x, t.a.y, t.b.x, t.b.y, t.c.x, t.c.y ];\n};","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\nconst pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\n\nexport type TriangleEquilateral =\n  | {\n    readonly length: number;\n  }\n  | number;\n\nconst resolveLength = (t: TriangleEquilateral): number => {\n  if (typeof t === `number`) return t;\n  return t.length;\n};\n\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * *  0: a and c on vertical, b at the tip\n * *  Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * *  Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * *  Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (\n  t: TriangleEquilateral,\n  origin?: Point,\n  rotationRad?: number\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t) / Math.sqrt(3);\n  const rot = rotationRad ?? Math.PI * 1.5;\n  const b = {\n    x: r * Math.cos(rot) + origin.x,\n    y: r * Math.sin(rot) + origin.y,\n  };\n  const a = {\n    x: r * Math.cos(rot + pi4over3) + origin.x,\n    y: r * Math.sin(rot + pi4over3) + origin.y,\n  };\n  const c = {\n    x: r * Math.cos(rot + pi2over3) + origin.x,\n    y: r * Math.sin(rot + pi2over3) + origin.y,\n  };\n\n  return Object.freeze({ a, b, c });\n};\n\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (\n  t: TriangleEquilateral,\n  ptA?: Point\n): Point => {\n  if (!ptA) ptA = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n  return {\n    x: ptA.x + r / 2,\n    y: ptA.y - radius,\n  };\n};\n\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (\n  t: TriangleEquilateral,\n  ptB?: Point\n): Point => {\n  if (!ptB) ptB = Object.freeze({ x: 0, y: 0 })\n\n  const { radius } = incircle(t);\n  return {\n    x: ptB.x,\n    y: ptB.y + radius * 2,\n  };\n};\n\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (\n  t: TriangleEquilateral,\n  ptC?: Point\n): Point => {\n  if (!ptC) ptC = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n\n  return {\n    x: ptC.x - r / 2,\n    y: ptC.y - radius,\n  };\n};\n\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t: TriangleEquilateral): number =>\n  (Math.sqrt(3) / 2) * resolveLength(t);\n\nexport const perimeter = (t: TriangleEquilateral): number =>\n  resolveLength(t) * 3;\n\nexport const area = (t: TriangleEquilateral): number =>\n  (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Right = {\n  readonly adjacent?: number;\n  readonly hypotenuse?: number;\n  readonly opposite?: number;\n};\n\nexport type DefinedRight = {\n  readonly adjacent: number;\n  readonly hypotenuse: number;\n  readonly opposite: number;\n};\n\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x + seg[ 1 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x - seg[ 0 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - seg[ 1 ], y: origin.y + h };\n  const b = { x: origin.x + seg[ 0 ], y: origin.y + h };\n  return { a, b, c };\n};\n\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t: Right): DefinedRight => {\n  const a = t.adjacent;\n  const o = t.opposite;\n  const h = t.hypotenuse;\n\n  if (a !== undefined && o !== undefined) {\n    return {\n      ...t,\n      adjacent: a,\n      opposite: o,\n      hypotenuse: Math.hypot(a, o),\n    };\n  } else if (a && h) {\n    return {\n      ...t,\n      adjacent: a,\n      hypotenuse: h,\n      opposite: h * h - a * a,\n    };\n  } else if (o && h) {\n    return {\n      ...t,\n      hypotenuse: h,\n      opposite: o,\n      adjacent: h * h - o * o,\n    };\n  } else if (t.opposite && t.hypotenuse && t.adjacent) {\n    return t as DefinedRight;\n  }\n  throw new Error(`Missing at least two edges`);\n};\n\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t: Right): number => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return Math.sqrt(p * q);\n};\n\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (\n  t: Right\n): readonly [ p: number, q: number ] => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return [ p, q ];\n};\n\nexport const perimeter = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\n\nexport const area = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return (tt.opposite * tt.adjacent) / 2;\n};\n\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.adjacent * tt.adjacent +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.opposite * tt.opposite) /\n    (2 * tt.adjacent * tt.hypotenuse)\n  );\n};\n\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.opposite * tt.opposite +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.adjacent * tt.adjacent) /\n    (2 * tt.opposite * tt.hypotenuse)\n  );\n};\n\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (\n  t: Right\n): readonly [ a: number, b: number, c: number ] => {\n  const tt = resolveLengths(t);\n  const b = tt.adjacent * tt.adjacent;\n  const c = tt.hypotenuse * tt.hypotenuse;\n  const a = tt.opposite * tt.opposite;\n\n  return [\n    Math.sqrt(2 * (b + c) - a) / 2,\n    Math.sqrt(2 * (c + a) - b) / 2,\n    Math.sqrt(2 * (a + b) - c) / 2,\n  ];\n};\n\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return { radius: tt.hypotenuse / 2 };\n};\n\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return {\n    radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n  };\n};\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (\n  angleRad: number,\n  adjacent: number\n): number => Math.tan(angleRad) * adjacent;\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (\n  angleRad: number,\n  hypotenuse: number\n): number => Math.sin(angleRad) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport const adjacentFromHypotenuse = (\n  angleRadian: number,\n  hypotenuse: number\n): number => Math.cos(angleRadian) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.tan(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const hypotenuseFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.sin(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (\n  angleRadian: number,\n  adjacent: number\n): number => adjacent / Math.cos(angleRadian);\n","\nimport type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Isosceles = {\n  readonly legs: number;\n  readonly base: number;\n};\n\nexport const baseAngle = (t: Isosceles): number =>\n  Math.acos(t.base / (2 * t.legs));\n\nexport const apexAngle = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.acos((2 * aa - cc) / (2 * aa));\n};\n\nexport const height = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.sqrt((4 * aa - cc) / 4);\n};\n\nexport const legHeights = (t: Isosceles): number => {\n  const b = baseAngle(t);\n  return t.base * Math.sin(b);\n};\n\nexport const perimeter = (t: Isosceles): number => 2 * t.legs + t.base;\n\nexport const area = (t: Isosceles): number => {\n  const h = height(t);\n  return (h * t.base) / 2;\n};\n\nexport const circumcircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  const hh = h * h;\n  const cc = t.base * t.base;\n  return { radius: (4 * hh + cc) / (8 * h) };\n};\n\nexport const incircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\n\nexport const medians = (\n  t: Isosceles\n): readonly [ a: number, b: number, c: number ] => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n  const medianC = Math.sqrt(4 * aa - cc) / 2;\n  return [ medianAB, medianAB, medianC ];\n};\n\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const incircleR = incircle(t).radius;\n  const verticalToApex = h - incircleR;\n\n  const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n  const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n  const c = { x: origin.x, y: origin.y - verticalToApex };\n  return { a, b, c };\n};\n\nexport const fromA = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + t.base, y: origin.y };\n  const c = { x: origin.x + t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromB = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base, y: origin.y };\n  const c = { x: origin.x - t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromC = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base / 2, y: origin.y + h };\n  const b = { x: origin.x + t.base / 2, y: origin.y + h };\n  return { a, b, c };\n};\n","export type * from './triangle-type.js';\nexport * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './inner-circle.js';\nexport * from './intersects.js';\nexport * from './kinds.js';\nexport * from './lengths.js';\nexport * from './math.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\nexport * from './to.js';\nexport * from './guard.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\n\nexport * as Isosceles from './isosceles.js';\n\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n\n\n","import type { PoseData } from \"./index\";\nimport type { Landmark, NormalizedLandmark } from \"../index\";\n\nconst posePoints: PoseLandmarks[] = [ \"nose\", \"left_eye_inner\", \"left_eye\", \"left_eye_outer\", \"right_eye_inner\", \"right_eye\", \"right_eye_outer\", \"left_ear\", \"right_ear\", \"mouth_left\", \"mouth_right\", \"left_shoulder\", \"right_shoulder\", \"left_elbow\", \"right_elbow\", \"left_wrist\", \"right_wrist\", \"left_pinky\", \"right_pinky\", \"left_index\", \"right_index\", \"left_thumb\", \"right_thumb\", \"left_hip\", \"right_hip\", \"left_knee\", \"right_knee\", \"left_ankle\", \"right_ankle\", \"left_heel\", \"right_heel\", \"left_foot_index\", \"right_foot_index\" ];\n\nexport type PoseLandmarks = \"nose\" | \"left_eye_inner\" | \"left_eye\" | \"left_eye_outer\" | \"right_eye_inner\" | \"right_eye\" | \"right_eye_outer\" | \"left_ear\" | \"right_ear\" | \"mouth_left\" | \"mouth_right\" | \"left_shoulder\" | \"right_shoulder\" | \"left_elbow\" | \"right_elbow\" | \"left_wrist\" | \"right_wrist\" | \"left_pinky\" | \"right_pinky\" | \"left_index\" | \"right_index\" | \"left_thumb\" | \"right_thumb\" | \"left_hip\" | \"right_hip\" | \"left_knee\" | \"right_knee\" | \"left_ankle\" | \"right_ankle\" | \"left_heel\" | \"right_heel\" | \"left_foot_index\" | \"right_foot_index\"\n\n/**\n * Returns indexes for right foot: ankle, heel, index\n */\nexport const footRightIndexes = [ 27, 29, 31 ]\n\n/**\n * Returns indexes for left foot: ankle, heel, index\n */\nexport const footLeftIndexes = [ 28, 30, 32 ]\n\n/**\n * Returns indexes for right shoulder, elbow, wrist (but not pinky, index & thumb)\n */\nexport const armRightIndexes = [ 12, 14, 16 ]\n\n/**\n * Returns indexes for left wrist, pinky, index & thumb\n */\nexport const armHandRightIndexes = [ 16, 18, 20, 22 ]\n\n\n/**\n * Returns indexes for left shoulder, elbow, wrist (but not pinky, index & thumb)\n */\nexport const armLeftIndexes = [ 11, 13, 15 ]\n\n/**\n * Returns indexes for left wrist, pinky, index & thumb\n */\nexport const armHandLeftIndexes = [ 15, 17, 19, 21 ]\n\n\n\n/**\n * Returns indexes for nose, eyes, ears & mouth\n */\nexport const faceIndexes = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 9 ]\n\n/**\n * Returns indexes for shoulders and hips\n */\nexport const torsoIndexes = [ 12, 11, 23, 24 ]\n\n/**\n * Returns indexes for left hip, knee, ankle (but not foot)\n */\nexport const legLeftIndexes = [ 23, 25, 27 ]\n\n/**\n * Returns indexes for right hip, knee, ankle (but not foot)\n */\nexport const legRightIndexes = [ 24, 26, 28 ]\n\n\n/**\n * Returns landmark index by name, or _undefined_ if not found\n * @param name \n * @returns \n */\nexport const getLandmarkIndexByName = (name: PoseLandmarks | string): number | undefined => {\n  for (let i = 0; i < posePoints.length; i++) {\n    if (posePoints[ i ] === name) return i;\n  }\n}\n\n/**\n * Returns landmark name by index, throws if 'index' out of range.\n * @param index \n * @returns \n */\nexport const getLandmarkNameByIndex = (index: number): PoseLandmarks => {\n  if (typeof index !== `number`) throw new Error(`Expected numeric index. Got: ${ typeof index }`);\n  if (index < 0) throw new Error(`Index should be at least 0`);\n  if (index >= posePoints.length) throw new Error(`Index is higher than expected (${ index })`);\n  return posePoints[ index ];\n}\n\nexport const getLandmark = (pose: PoseData, indexOrName: number | PoseLandmarks): NormalizedLandmark | undefined => {\n  if (typeof indexOrName === `number`) {\n    return pose.landmarks[ indexOrName ];\n  } else {\n    const index = getLandmarkIndexByName(indexOrName);\n    if (!index) return;\n    return pose.landmarks[ index ];\n  }\n}\n\nexport const getWorldLandmark = (pose: PoseData, indexOrName: number | PoseLandmarks): Landmark | undefined => {\n  if (typeof indexOrName === `number`) {\n    return pose.world[ indexOrName ];\n  } else {\n    const index = getLandmarkIndexByName(indexOrName);\n    if (!index) return;\n    return pose.world[ index ];\n  }\n}","import { Lines, type Line, Points } from 'ixfx/geometry.js';\nimport { getLandmark, type PoseLandmarks } from './landmarks.js';\nimport type { PoseData } from './index.js';\n\n/**\n * Sorts raw `poses` by horziontal.\n * Leftmost pose will be first.\n */\nexport const horizontalSort = (poses: PoseData[]) => {\n  const withCentroids = poses.map(p => ({\n    ...p,\n    centroid: centroid(p)\n  }));\n  withCentroids.sort((a, b) => a.centroid.x - b.centroid.x);\n  return withCentroids;\n};\n\n/**\n * Return centroid of Pose based on landmarks.\n * \n */\nexport const centroid = (pose: PoseData) => Points.centroid(...pose.landmarks);\n\n\n/**\n * Return centroid of pose based on world landmarks\n */\nexport const centroidWorld = (pose: PoseData) => Points.centroid(...pose.world);\n\n/**\n * Returns a line between two named/indexed landmarks.\n * If either of the two points are not found, _undefined_ is returned.\n * @param pose Pose data \n * @param a Landmark A\n * @param b Landmark B\n */\nexport const lineBetween = (pose: PoseData, a: PoseLandmarks | number, b: PoseLandmarks | number): Line | undefined => {\n  if (pose === undefined) throw new TypeError(`Param 'pose' is undefined. Expected PoseData`);\n  if (a === undefined) throw new TypeError(`Param 'a' is undefined, expected landmark name or index.`);\n  if (b === undefined) throw new TypeError(`Param 'b' is undefined, expected landmark name or index.`);\n\n  const ptA = getLandmark(pose, a);\n  const ptB = getLandmark(pose, b);\n  if (ptA === undefined) return;\n  if (ptB === undefined) return;\n  return Object.freeze({\n    a: ptA,\n    b: ptB\n  });\n};\n\n/**\n * Returns the rough center of a pose, based on\n * the chest coordinates\n */\nexport const roughCenter = (pose: PoseData) => {\n  if (pose === undefined) throw new Error(`Param 'pose' is undefined. Expected PoseData`);\n  const a = lineBetween(pose, `left_shoulder`, `right_hip`);\n  const b = lineBetween(pose, `right_shoulder`, `left_hip`);\n  if (a === undefined) return;\n  if (b === undefined) return;\n\n  // Get halfway of each line\n  const halfA = Lines.interpolate(0.5, a);\n  const halfB = Lines.interpolate(0.5, b);\n\n  // Add them up\n  const sum = Points.sum(halfA, halfB);\n\n  // Divide to get avg\n  return Points.divide(sum, 2, 2);\n};\n","import { arrayTest, throwIfFailed } from \"@ixfx/guards\";\n\n/**\n * Returns a function that cycles through the contents of an array. By default starts at index 0.\n * \n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n * \n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n * \n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n * \n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over \n * @returns \n */\nexport const cycle = <T>(options: readonly T[] | T[]) => {\n  throwIfFailed(arrayTest(options, `options`));\n  const opts = [ ...options ];\n  let index = 0;\n  const next = () => {\n    index++;\n    if (index === opts.length) index = 0;\n    return value();\n  }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  const prev = () => {\n    index--;\n    if (index === -1) index = opts.length - 1;\n    return value();\n  }\n\n  const value = (): typeof opts[ number ] => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return opts.at(index)!;\n  }\n\n  const select = (indexOrValue: number | typeof opts[ number ]) => {\n    if (typeof indexOrValue === `number`) {\n      index = indexOrValue;\n    } else {\n      const found = opts.indexOf(indexOrValue);\n      if (found === -1) throw new Error(`Could not find value`);\n      index = found;\n    }\n  }\n\n  const toArray = () => [ ...opts ];\n  return { toArray, next, prev, get current() { return value() }, select }\n}","import { numberTest, resultThrow } from \"@ixfx/guards\"\n\n/**\n * Similar to Javascript's in-built Array.at function, but allows offsets\n * to wrap.\n * \n * @remarks\n * ```js\n * const test = [1,2,3,4,5,6];\n * atWrap(0);   // 1\n * atWrap(-1);  // 6\n * atWrap(-6);  // 1\n * ```\n * \n * These values would return _undefined_ using Array.at since its beyond\n * the length of the array\n * ```js\n * atWrap(6);   // 1\n * atWrap(-7);  // 6\n * ```\n * @param array Array\n * @param index Index\n * @returns \n */\nexport const atWrap = <V>(array: V[], index: number) => {\n  resultThrow(numberTest(index, ``, `index`));\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array`);\n\n  index = index % array.length;\n  return array.at(index) as V;\n}","\n/**\n * Return `array` broken up into chunks of `size` values\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param array\n * @param size\n * @returns\n */\n\nimport { arrayTest, integerTest, throwIfFailed } from \"@ixfx/guards\";\n\nexport function chunks<V>(\n  array: readonly V[],\n  size: number\n) {\n  throwIfFailed(\n    integerTest(size, \"aboveZero\", `size`),\n    arrayTest(array, `array`)\n  );\n\n  // https://surma.github.io/underdash/\n  const output: V[][] = [];\n  for (let index = 0; index < array.length; index += size) {\n    output.push(array.slice(index, index + size));\n  }\n  return output;\n}","/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\n// export const toStringOrdered = (itemToMakeStringFor: unknown) => {\n//   if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n//   const allKeys = new Set<string>();\n\n//   JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n//   return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n// }\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  //  UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string, unknown>, b: Record<string, unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string, unknown>, valueB as Record<string, unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\n// export const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n//   //  UNIT TESTED\n//   if (a === b) return true; // Object references are the same, or string values are the same\n//   return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n// };\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b` are equal based on their JSON representations.\n * `path` parameter is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n\n\n/**\n * Returns _true_ if all value in `needles` is contained in `haystack`.\n * \n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * \n * If `needles` is empty, `contains` will return true.\n * @param haystack Array to search\n * @param needles Things to look for\n * @param eq\n */\nexport const contains = <V>(\n  haystack: ArrayLike<V>,\n  needles: ArrayLike<V>,\n  eq = isEqualDefault<V>\n) => {\n  if (!Array.isArray(haystack)) {\n    throw new TypeError(`Expects haystack parameter to be an array`);\n  }\n  if (!Array.isArray(needles)) {\n    throw new TypeError(`Expects needles parameter to be an array. Got: ${ typeof needles }`);\n  }\n\n  for (const needle of needles) {\n    let found = false;\n    for (const element of haystack) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      if (eq(needle, element)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n * \n * Uses JSON.toString() by default to compare values.\n * \n * See also:\n * * {@link unique}: Get unique set of values in an array\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link containsDuplicateValues}: Returns _true_ if every item in array is the same\n * @param data Array to examine\n * @param keyFunction Function to generate key string for object, uses JSON.stringify by default.\n * @returns\n */\nexport const containsDuplicateValues = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>\n): boolean => {\n  if (typeof data !== `object`) throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${ typeof data }`);\n  const set = new Set<string>();\n  for (const v of data) {\n    const string_ = keyFunction(v);\n    if (set.has(string_)) return true;\n    set.add(string_);\n  }\n  return false;\n};\n\n/**\n * Returns _true_ if array contains duplicate instances based on `===` equality checking\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array \n * @returns \n */\nexport const containsDuplicateInstances = <V>(array: V[] | readonly V[]): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  for (let index = 0; index < array.length; index++) {\n    for (let x = 0; x < array.length; x++) {\n      if (index === x) continue;\n      if (array[ index ] === array[ x ]) return true;\n    }\n  }\n  return false;\n}","\nexport function ensureLength<V>(\n  data: readonly V[] | V[],\n  length: number,\n  expand: `repeat` | `first` | `last`,\n  truncate?: `from-end` | `from-start`\n): (V)[];\n\nexport function ensureLength<V>(\n  data: readonly V[] | V[],\n  length: number,\n  expand?: `undefined`,\n  truncate?: `from-end` | `from-start`\n): (V | undefined)[];\n\n/**\n * Returns a copy of an array with specified length - padded or truncated as needed.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with _undefined_ (default)\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * Truncate:\n * ```js\n * ensureLength([1,2,3], 2); // [1,2]\n * ```\n * \n * Padded:\n * ```js\n * ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expandStrategy Expand strategy\n * @param truncateStrategy Truncation strategy. By default removes from end ('from-end')\n * @typeParam V Type of array\n */\nexport function ensureLength<V>(\n  data: readonly V[] | V[],\n  length: number,\n  expandStrategy: `undefined` | `repeat` | `first` | `last` = `undefined`,\n  truncateStrategy: `from-end` | `from-start` = `from-end`\n): (V | undefined)[] {\n  if (data === undefined) throw new Error(`Data undefined`);\n  if (!Array.isArray(data)) throw new Error(`data is not an array`);\n  if (data.length === length) return [ ...data ];\n  if (data.length > length) {\n    if (truncateStrategy === `from-end`) {\n      return data.slice(0, length);\n    } else {\n      return data.slice(data.length - length);\n    }\n  }\n  const d = [ ...data ];\n  const add = length - d.length;\n\n  for (let index = 0; index < add; index++) {\n    switch (expandStrategy) {\n      case `undefined`: {\n        // @ts-expect-error all fine .....\n        d.push(undefined);\n        break;\n      }\n      case `repeat`: {\n        d.push(data[ index % data.length ]);\n        break;\n      }\n      case `first`: {\n        d.push(data[ 0 ]);\n        break;\n      }\n      case `last`: {\n        // @ts-expect-error all fine .....\n        d.push(data.at(-1));\n        break;\n      }\n      // No default\n    }\n  }\n  return d;\n};\n","import { isEqualDefault, isEqualValueDefault, type IsEqual } from \"./util/is-equal.js\";\nimport { arrayTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Returns _true_ if the two arrays have the same items at same indexes. \n * \n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n * \n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n * \n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n * \n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA \n * @param arrayB \n * @param equality Function to compare values\n */\nexport const isEqual = <V>(arrayA: V[], arrayB: V[], equality = isEqualDefault<V>): boolean => {\n  // TODO: 'eq' function could be a key-generating function too\n  resultThrow(\n    arrayTest(arrayA, `arrayA`),\n    arrayTest(arrayB, `arrayB`)\n  );\n\n  if (arrayA.length !== arrayB.length) return false;\n\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    if (!(equality(arrayA[ indexA ], arrayB[ indexA ]))) return false;\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if all values in the array are the same. Uses value-based equality checking by default.\n * \n * @example Using default equality function\n * ```js\n * const a1 = [ 10, 10, 10 ];\n * containsIdenticalValues(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * containsIdenticalValues(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * containsIdenticalValues(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const containsIdenticalValues = <V>(\n  array: readonly V[] | V[],\n  equality?: IsEqual<V>\n): boolean => {\n  // TODO: 'equality' function could be a key-generating function too\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","\nimport { arrayIndexTest, arrayTest, resultThrow } from \"@ixfx/guards\";\n\n\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. \n * \n * Same idea as the in-built Array.filter, but that only returns values for one case.\n * \n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: readonly V[],\n  filter: (a: V) => boolean\n): [ a: V[], b: V[] ] => {\n  const a: V[] = [];\n  const b: V[] = [];\n  for (const datum of data) {\n    if (filter(datum)) a.push(datum);\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween<V>(\n  array: readonly V[] | V[],\n  predicate: (\n    value: V,\n    index: number,\n    array: readonly V[] | V[]\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Generator<V> {\n  resultThrow(arrayTest(array, `array`));\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n\n  resultThrow(arrayIndexTest(array, startIndex, `startIndex`));\n  resultThrow(arrayIndexTest(array, endIndex - 1, `endIndex`));\n\n  for (let index = startIndex; index < endIndex; index++) {\n    if (predicate(array[ index ], index, array)) yield array[ index ];//t.push(array[ index ]);\n  }\n};\n\n","/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array: ReadonlyArray<any> | Array<any>): Array<any> =>\n  [ ...array ].flat();","\n/**\n * Returns the array.map() output, or a value if `array`\n * is not an array or empty.\n * \n * ```js\n * mapWithEmptyFallback([1,2,3], v => v+2, 100); // Yields: [3,4,5]\n * mapWithEmptyFallback([], v=>v+2, 100); // Yields: [100]\n * mapWithEmptyFallback({}, v=>v+2, [100]); // Yields: [100]\n * ```\n * \n * If the fallback value is an array, it is returned as an\n * array if needed. If it's a single value, it is wrapped as an array.\n * @param array Array of values\n * @param fn Function to use for mapping values\n * @param fallback Fallback single value or array of values\n * @returns \n */\nexport const mapWithEmptyFallback = <TValue, TReturn>(array: TValue[], fn: (value: TValue) => TReturn, fallback: TReturn | TReturn[]): TReturn[] => {\n  if (typeof array !== `object` || !Array.isArray(array) || array.length === 0) {\n    if (Array.isArray(fallback)) return fallback;\n    return [ fallback ];\n  }\n  return array.map(fn);\n}","/**\n * Computes the frequency of values by a grouping function.\n * \n * ```js\n * const data = [1,2,3,4,5,6,7,8,9,10];\n * // Returns 'odd' or 'even' for an input value\n * \n * const groupBy = v => v % 2 === 0 ? `even`:`odd`;\n * \n * const data = frequencyByGroup(groupBy, data);\n * // Yields map with:\n * //  key: 'even', value: 5\n * //  key: 'odd', value: 5\n * @param groupBy \n * @param data \n * @returns \n */\nexport const frequencyByGroup = <TValue, TGroup extends string | number>(groupBy: ((value: TValue) => TGroup), data: TValue[]): Map<TGroup, number> => {\n  if (!Array.isArray(data)) throw new TypeError(`Param 'array' is expected to be an array. Got type: '${ typeof data }'`);\n  const store = new Map<TGroup, number>();\n\n  for (const value of data) {\n    const group = groupBy(value);\n    if (typeof group !== `string` && typeof group !== `number`) {\n      throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${ typeof group }' for value: '${ value }'`);\n    }\n    let groupValue = store.get(group);\n    groupValue ??= 0;\n    groupValue++;\n    store.set(group, groupValue);\n  }\n  return store;\n}","\n/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * const data = [\n *  { age: 39, city: `London` },\n *  { age: 14, city: `Copenhagen` },\n *  { age: 23, city: `Stockholm` },\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = Arrays.groupBy(data, item => item.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = <K, V>(\n  array: Iterable<V>,\n  grouper: (item: V) => K\n) => {\n  const map = new Map<K, V[]>();\n\n  for (const a of array) {\n    const key = grouper(a);\n    let existing = map.get(key);\n    if (!existing) {\n      existing = [];\n      map.set(key, existing);\n    }\n    existing.push(a);\n  }\n  return map;\n};","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses Javascript's default equality checking\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * Iterables.additionalValues: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  comparer = isEqualDefault<V>\n): V[] => {\n  const t: V[] = [];\n  const contains = (v: V) => {\n    for (const tValue of t) {\n      if (comparer(tValue, v)) return true;\n    }\n    return false;\n  }\n\n  const flattened = arrays.flat(10) as V[];\n\n  for (const v of flattened) {\n    if (!contains(v)) t.push(v);\n  }\n  return t;\n};\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n * \n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * Iterables.additionalValues: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays Array (or array of arrays) to examine\n * @param toString Function to convert values to a string for comparison purposes. By default uses JSON formatting.\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  toString = toStringDefault\n): V[] => {\n  const matching = new Set<string>();\n  const t: V[] = [];\n  const flattened = arrays.flat(10) as V[];\n  for (const a of flattened) {\n    const stringRepresentation = toString(a);\n    if (matching.has(stringRepresentation)) continue;\n    matching.add(stringRepresentation);\n    t.push(a);\n  }\n  return t;\n}","import { arrayIndexTest, arrayTest, integerTest, throwIfFailed } from \"@ixfx/guards\";\n\n/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down and returning changed result.\n * \n * Does not modify the input array.\n * \n * ```js\n * const data = [ 1, 2, 3 ]\n * \n * // Inserts 20,30,40 at index 1\n * Arrays.insertAt(data, 1, 20, 30, 40);\n * \n * // Yields: 1, 20, 30, 40, 2, 3\n * ```\n * @param data \n * @param index \n * @param values \n * @returns \n */\nexport const insertAt = <V>(\n  data: readonly V[] | V[],\n  index: number,\n  ...values: V[]\n): V[] => {\n  throwIfFailed(\n    arrayTest(data, `data`),\n    arrayIndexTest(data, index, `index`)\n  );\n\n  // Adding at end\n  if (index === data.length - 1) {\n    return [ ...data, ...values ];\n  }\n  // Adding at beginning\n  if (index === 0) {\n    return [ ...values, ...data ];\n  }\n  return [ ...data.slice(0, index), ...values, ...data.slice(index) ];\n};","import { containsIdenticalValues } from \"./equality.js\";\n\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = Arrays.interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = <V>(\n  ...arrays: readonly (readonly V[])[] | V[][]\n): V[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map(a => (a as V[]).length);\n  if (!containsIdenticalValues(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue: V[] = [];\n  const length = lengths[ 0 ];\n  for (let index = 0; index < length; index++) {\n    for (const array of arrays) {\n      returnValue.push(array[ index ]);\n    }\n  }\n  return returnValue;\n};\n","import { isEqualDefault, type IsEqual } from \"./util/is-equal.js\";\n\n\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n * \n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also: \n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA \n * @param arrayB \n * @param equality \n * @returns \n */\nexport const intersection = <V>(\n  arrayA: readonly V[] | V[],\n  arrayB: readonly V[] | V[],\n  equality: IsEqual<V> = isEqualDefault\n) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n","import type { MergeReconcile } from \"./types.js\";\n\n/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also Core.Maps.mergeByKey if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFunction Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = <V>(\n  keyFunction: (value: V) => string,\n  reconcile: MergeReconcile<V>,\n  ...arrays: readonly (readonly V[])[]\n): V[] => {\n  const result = new Map<string, V>();\n  for (const m of arrays) {\n    for (const mv of m) {\n      if (mv === undefined) continue;\n      const mk = keyFunction(mv);\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return [ ...result.values() ];\n};\n","import { resultThrow, arrayTest } from \"@ixfx/guards\";\n\n/**\n * Yields pairs made up of overlapping items from the input array.\n * \n * Throws an error if there are less than two entries.\n * \n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [ [1,2], [2,3], [3,4], [4,5] ]\n * ```\n * @param values \n */\nexport function* pairwise<T>(values: T[]) {\n  resultThrow(arrayTest(values, `values`));\n\n  if (values.length < 2) throw new Error(`Array needs to have at least two entries. Length: ${ values.length }`);\n\n  for (let index = 1; index < values.length; index++) {\n    yield [ values[ index - 1 ], values[ index ] ];\n  }\n}\n\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = <V, X>(\n  array: readonly V[],\n  reducer: (accumulator: X, a: V, b: V) => X,\n  initial: X\n) => {\n  resultThrow(arrayTest(array, `arr`));\n  if (array.length < 2) return initial;\n  for (let index = 0; index < array.length - 1; index++) {\n    initial = reducer(initial, array[ index ], array[ index + 1 ]);\n  }\n  return initial;\n};\n","import { arrayTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * \n * It can be useful to randomly access each item from an array exactly once:\n * ```js\n * for (const value of shuffle(inputArray)) {\n *  // Do something with the value...\n * }\n * ```\n * @param dataToShuffle Input array\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: readonly V[],\n  rand: () => number = Math.random\n): V[] => {\n  resultThrow(arrayTest(dataToShuffle, `dataToShuffle`));\n\n  const array = [ ...dataToShuffle ];\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};\n\n/**\n * Returns a random element of an array\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Note that repeated calls might yield the same value\n * multiple times. If you want to random unique values, consider using {@link shuffle}.\n * \n * See also:\n * * {@link randomIndex} if you want a random index rather than value.\n * \n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: () => number = Math.random\n): V => {\n  resultThrow(arrayTest(array, `array`));\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: () => number = Math.random\n): number => Math.floor(rand() * array.length);\n","import { arrayIndexTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = <V>(\n  data: readonly V[] | V[],\n  index: number\n): V[] => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`'data' parameter should be an array`);\n  }\n  resultThrow(arrayIndexTest(data, index, `index`));\n\n  return [ ...data.slice(0, index), ...data.slice(index + 1) ];\n};","import { resultThrow, integerTest } from '@ixfx/guards';\n/**\n * Samples values from an array. \n * \n * If `amount` is less or equal to 1, it's treated as a percentage to sample.\n * Otherwise it's treated as every _n_th value to sample.\n *\n * @example \n * By percentage - get half of the items\n * ```\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example\n * By steps - every third value\n * ```\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = <V>(array: ArrayLike<V>, amount: number): V[] => {\n  if (!Array.isArray(array)) throw new TypeError(`Param 'array' is not actually an array. Got type: ${ typeof array }`);\n  let subsampleSteps = 1;\n  if (amount <= 1) {\n    // Subsample based on a percentage\n    const numberOfItems = array.length * amount;\n    subsampleSteps = Math.round(array.length / numberOfItems);\n  } else {\n    subsampleSteps = amount;\n  }\n\n  resultThrow(integerTest(subsampleSteps, `positive`, `amount`));\n  if (subsampleSteps > array.length - 1) {\n    throw new Error(`Subsample steps exceeds array length`);\n  }\n  const r: V[] = [];\n  for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n    r.push(array[ index ]);\n  }\n  return r;\n};","import { arrayTest, resultThrow } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  resultThrow(arrayTest(data, `data`));\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});\n\n/**\n * Sorts an array of objects by some named property.\n * \n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * sortByProperty(data, `colour`);\n * \n * Yields [\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n *  { size: 10, colour: `red` },\n * ]\n * ```\n * \n * You can also provide a custom comparer that is passed property values.\n * This function should return 0 if values are equal, 1 if `a > b` and -1 if `a < b`.\n * @param data \n * @param propertyName \n * @returns \n */\nexport const sortByProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K,\n  comparer?: (a: any, b: any) => number\n) => [ ...data ].sort((a, b) => {\n  resultThrow(arrayTest(data, `data`));\n\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (comparer === undefined) {\n    if (av < bv) return -1;\n    if (av > bv) return 1;\n    return 0;\n  } else {\n    return comparer(av, bv);\n  }\n});","/**\n * Yields all items in the input array, stopping when `predicate` returns _true_.\n * \n * @example Yield values until we hit 3\n * ```js\n * const data = [ 1, 2, 3, 4, 5 ];\n * until(data, v => v === 3)\n * // [ 1, 2 ]\n * ```\n */\nexport function until<V>(\n  data: readonly V[] | V[],\n  predicate: (v: V) => boolean\n): Generator<V>;\n\n/**\n * Yields all items in the input array, stopping when `predicate` returns _true_.\n * This version allows a value to be 'accumulated' somehow\n * \n * @example Yield values until a total of 4\n * ```js\n * const data = [ 1, 2, 3, 4, 5 ];\n * until(data, (v, accumulated) => [accumulated >= 6, accumulated + v ]);\n * // [ 1, 2, 3 ]\n * ```\n */\nexport function until<V, A>(\n  data: readonly V[] | V[],\n  predicate: (v: V, accumulator: A) => readonly [ stop: boolean, acc: A ],\n  initial: A\n): Generator<V>;\n\n/**\n * Yields all items in the input array for as long as `predicate` returns true.\n *\n * `predicate` yields arrays of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = [...until([1,2,3,4,5], v => v === 3];\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total, using 0 as initial value\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport function* until<V, A>(\n  data: readonly V[] | V[],\n  predicate: (v: V, accumulator?: A) => boolean | (readonly [ stop: boolean, acc: A ]),\n  initial?: A\n): Generator<V> {\n  let total = initial;\n  for (const datum of data) {\n    const r = predicate(datum, total);\n    if (typeof r === `boolean`) {\n      if (r) break;\n    } else {\n      const [ stop, accumulator ] = r;\n      if (stop) break;\n      total = accumulator;\n    }\n    yield datum;\n  }\n};","import { isEqualDefault, type IsEqual } from \"./util/is-equal.js\";\n\n/**\n * Returns a copy of an input array with _undefined_ values removed.\n * @param data \n * @returns \n */\nexport const withoutUndefined = <V>(data: readonly V[] | V[]): V[] => {\n  return data.filter(v => v !== undefined);\n}\n\n/**\n * Returns an array with value(s) omitted. \n * \n * If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * const data = [100, 20, 40];\n * const filtered = without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * const data = [{ name: `Alice` }, { name:`Sam` }];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * without(data, { name: `Alice` });\n *\n * // So instead we can use a value comparer:\n * without(data, { name:`Alice` }, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * const data = [ { name: `Alice` }, { name:`Sam` }];\n * without(data, { name:`ALICE` }, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  sourceArray: readonly V[] | V[],\n  toRemove: V | V[],\n  comparer: IsEqual<V> = isEqualDefault\n): V[] => {\n  if (Array.isArray(toRemove)) {\n    const returnArray: V[] = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}","import { containsIdenticalValues } from \"./equality.js\";\n\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (\n  ...arrays: any[][] | readonly any[][] | readonly (readonly any[])[]\n): any[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => (a as any[]).length);\n  if (!containsIdenticalValues(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue: any[] = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n * \n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object \n * @param apply \n * @returns \n */\nexport const applyToValues = <T extends Record<string, any>>(object: T, apply: (v: number) => number): T => {\n  const o: T = { ...object };\n  for (const [ key, value ] of Object.entries(object)) {\n    if (typeof value === `number`) {\n      // Run number through function\n      //eslint-disable-next-line functional/immutable-data\n      (o as any)[ key ] = apply(value);\n    } else {\n      // Copy value\n      //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n      (o as any)[ key ] = value;\n    }\n  }\n  return o;\n}","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (\n  data: number[] | readonly number[],\n  fn?: (relativePos: number) => number\n): number[] => {\n  if (!Array.isArray(data)) throw new TypeError(`Param 'data' is expected to be an array. Got type: ${ typeof data }`);\n  const weightingFunction = fn ?? ((x: number) => x);\n  return data.map(\n    (value: number, index: number) => {\n      if (typeof value !== `number`) throw new TypeError(`Param 'data' contains non-number at index: '${ index }'. Type: '${ typeof value }' value: '${ value }'`);\n      const relativePos = index / (data.length - 1);\n      const weightForPosition = weightingFunction(relativePos);\n      if (typeof weightForPosition !== `number`) throw new TypeError(`Weighting function returned type '${ typeof weightForPosition }' rather than number for input: '${ relativePos }'`);\n      const finalResult = value * weightForPosition;\n      //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n      return finalResult;\n    }\n  );\n};\n\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data: readonly number[]) =>\n  data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (\n  values: readonly (readonly number[])[]\n): number => {\n  let r = 0;\n  const length = values[ 0 ].length;\n\n  for (let index = 0; index < length; index++) {\n    let t = 0;\n    for (const [ p, value ] of values.entries()) {\n      if (p === 0) t = value[ index ];\n      else {\n        t *= value[ index ];\n      }\n    }\n    r += t;\n  }\n  return r;\n};\n\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link numberArrayCompute} if you want min, max and total as well.\n *\n * @example\n * ```js\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data: readonly number[]): number => {\n  //  UNIT TESTED\n  if (data === undefined) throw new Error(`data parameter is undefined`);\n  const valid = validNumbers(data);\n  const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n  return total / valid.length;\n};\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data: readonly number[]): number =>\n  Math.min(...validNumbers(data));\n\n/**\n * Returns the index of the largest value.\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data: readonly number[]): number =>\n\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value > array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data: readonly number[]): number =>\n\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value < array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data: readonly number[]): number =>\n  Math.max(...validNumbers(data));\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data: readonly number[]): number =>\n  data.reduce((previous, current) => {\n    if (typeof current !== `number`) return previous;\n    if (Number.isNaN(current)) return previous;\n    if (!Number.isFinite(current)) return previous;\n    return previous + current;\n  }, 0);\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data: readonly number[] | Float32Array): number => {\n  let m = Number.MIN_SAFE_INTEGER;\n  for (const datum of data) {\n    m = Math.max(m, datum);\n  }\n  return m;\n};\n\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data: readonly number[] | Float32Array): number => {\n  let m = 0;\n  for (const datum of data) {\n    m += datum;\n  }\n  return m;\n};\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data: readonly number[] | Float32Array): number => {\n  let m = Number.MIN_SAFE_INTEGER;\n  for (const datum of data) {\n    m = Math.min(m, datum);\n  }\n  return m;\n};\n","import { zip } from '@ixfx/arrays';\nimport { weight } from './numeric-arrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * averageWeighted[1,2,3], Random.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * const data = [1,2,3];\n * const w = weight(data, Random.gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (\n  data: number[] | readonly number[],\n  weightings: number[] | readonly number[] | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n  const ww = zip(data, weightings);\n  const [ totalV, totalW ] = ww.reduce(\n    (accumulator: number[], v: number[]) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link https://api.ixfx.fun/_ixfx/geometry/Points/clamp/ @ixfx/geometry/Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value: number, min = 0, max = 1) => {\n  //  UNIT TESTED\n  if (Number.isNaN(value)) throw new Error(`Param 'value' is NaN`);\n  if (Number.isNaN(min)) throw new Error(`Param 'min' is NaN`);\n  if (Number.isNaN(max)) throw new Error(`Param 'max' is NaN`);\n\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n};\n\n/**\n * Returns a function that clamps values.\n * \n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport const clamper = (min = 0, max = 1) => {\n  if (Number.isNaN(min)) throw new Error(`Param 'min' is NaN`);\n  if (Number.isNaN(max)) throw new Error(`Param 'max' is NaN`);\n  return (v: number) => {\n    if (v > max) return max;\n    if (v < min) return min;\n    return v;\n  }\n}\n\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport const clampIndex = (\n  v: number,\n  arrayOrLength: number | readonly any[]\n): number => {\n  //  UNIT TESTED\n  if (!Number.isInteger(v)) {\n    throw new TypeError(`v parameter must be an integer (${ v })`);\n  }\n  const length = Array.isArray(arrayOrLength)\n    ? arrayOrLength.length\n    : (arrayOrLength as number);\n\n  if (!Number.isInteger(length)) {\n    throw new TypeError(\n      `length parameter must be an integer (${ length }, ${ typeof length })`\n    );\n  }\n  v = Math.round(v);\n  if (v < 0) return 0;\n  if (v >= length) return length - 1;\n  return v;\n};\n\n\n/**\n * Returns the largest value, ignoring the sign of numbers\n * \n * ```js\n * maxAbs(1, 5);    // 5\n * maxAbs(-10, 5);  // -10 (since sign is ignored)\n * ```\n * @param values \n * @returns \n */\nexport const maxAbs = (...values: number[]) => {\n  let index = -1;\n  let maxA = Number.MIN_SAFE_INTEGER;\n  for (let index_ = 0; index_ < values.length; index_++) {\n    const vA = Math.abs(values[ index_ ]);\n    if (vA > maxA) {\n      maxA = vA;\n      index = index_;\n    }\n  }\n  return values[ index ];\n}","import { integerTest, resultThrow } from \"@ixfx/guards\"\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount: number, offset = 0): Generator<number, void, void> {\n  resultThrow(\n    integerTest(amount, ``, `amount`),\n    integerTest(offset, ``, `offset`)\n  )\n  if (amount === 0) return;\n\n  let index = 0;\n  do {\n    yield (amount < 0 ? -index + offset : index + offset);\n  } while (index++ < Math.abs(amount) - 1);\n};","export type DifferenceKind = `numerical` | `relative` | `relativeSigned` | `absolute`\n\n/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n * \n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n * \n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n * \n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport const differenceFromFixed = (initial: number, kind: DifferenceKind = `absolute`) => (value: number) => differenceFrom(kind, value, initial);\n\n\n/**\n * Returns a function which yields difference compared to last value.\n * \n * If no initial value is provided, the first difference will be returned as 0.\n * \n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n * \n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n * \n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n * \n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n * \n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n * \n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value \n * @returns \n */\nexport const differenceFromLast = (kind: DifferenceKind = `absolute`, initialValue = Number.NaN): (v: number) => number => {\n  let lastValue = initialValue;\n  return (value: number) => {\n    const x = differenceFrom(kind, value, lastValue);\n    lastValue = value;\n    return x;\n  }\n}\n//   const compute = (v: number) => {\n//     if (Number.isNaN(lastValue)) {\n//       lastValue = v;\n//       return 0;\n//     }\n//     const d = v - lastValue;\n//     let r = 0;\n//     if (kind === `absolute`) {\n//       r = Math.abs(d);\n//     } else if (kind === `numerical`) {\n//       r = d;\n//     } else if (kind === `relative`) {\n//       r = Math.abs(d / lastValue);\n//     } else if (kind === `relativeSigned`) {\n//       r = d / lastValue;\n//     } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n//     lastValue = v;\n//     return r;\n//   }\n//   return compute;\n// }\n\nconst differenceFrom = (kind: DifferenceKind = `absolute`, value: number, from: number) => {\n  if (Number.isNaN(from)) {\n    return 0;\n  }\n  const d = value - from;\n  let r = 0;\n  if (kind === `absolute`) {\n    r = Math.abs(d);\n  } else if (kind === `numerical`) {\n    r = d;\n  } else if (kind === `relative`) {\n    r = Math.abs(d / from);\n  } else if (kind === `relativeSigned`) {\n    r = d / from;\n  } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n  return r;\n}","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber: unknown) => {\n  if (typeof possibleNumber !== `number`) return false;\n  if (Number.isNaN(possibleNumber)) return false;\n  return true;\n};","import { isValid } from './guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filterIterable(data)) {\n *  // 10\n * }\n * ```\n * @param it\n */\nexport function* filterIterable(it: Iterable<unknown>) {\n  for (const v of it) {\n    if (isValid(v)) yield v;\n  }\n}\n\n/**\n * Returns a function that yields _true_ if a value\n * is at least `threshold`\n * ```js\n * const t = thresholdAtLeast(50);\n * t(50); // true\n * t(0);  // false\n * t(55); // true\n * ```\n * @param threshold \n * @returns \n */\nexport const thresholdAtLeast = (threshold: number) => {\n  return (v: number) => {\n    return v >= threshold;\n  };\n};\n\n/**\n * Returns a function that yields _true_\n * if a number is at least _min_ and no greater than _max_\n * \n * ```js\n * const t = rangeInclusive(50, 100);\n * t(40); // false\n * t(50); // true\n * t(60); // true\n * t(100); // true\n * t(101);  // false\n * ```\n * @param min \n * @param max \n * @returns \n */\nexport const rangeInclusive = (min: number, max: number) => {\n  return (v: number) => {\n    return v >= min && v <= max;\n  };\n};","import { numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v: number | (() => number)) => {\n  if (typeof v === `function`) v = v();\n  resultThrow(numberTest(v, `percentage`, `v`));\n  return 1 - v;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (typeof end === `undefined`) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  resultThrow(numberTest(interval, `nonZero`));\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval.toString() } will never go from ${ start.toString() } to ${ end.toString() }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval.toString() } will never go from ${ start.toString() } to ${ end.toString() }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n\n\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  resultThrow(\n    numberTest(interval, `percentage`, `interval`),\n    numberTest(start, `percentage`, `start`),\n    numberTest(end, `percentage`, `end`)\n  );\n  return numericRange(interval, start, end, repeating);\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\n\nexport function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number | boolean, roundUp?: boolean) {\n  resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n\n  const up = (typeof b === `boolean`) ? b : (roundUp ?? false)\n  let rounder: ((v: number) => number) | undefined;\n  if (a === 0) {\n    rounder = Math.round;\n  } else {\n    const p = Math.pow(10, a);\n    if (up) {\n      rounder = (v: number) => Math.ceil(v * p) / p;\n    } else {\n      rounder = (v: number) => Math.floor(v * p) / p;\n    }\n  }\n  if (typeof b === `number`) return rounder(b);\n  return rounder;\n}\n\n","import { numberTest, resultThrow, type Result } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n\n/**\n * Returns a function that checks if a value is within range of a base value\n * ```js\n * const tenPercent = isApprox(0.1);\n * // Check if 101 is within 10% range of 100\n * tenPercent(100, 101); \n * ```\n * @param rangePercent \n */\nexport function isApprox(\n  rangePercent: number\n): (baseValue: number, value: number) => boolean;\n\n/**\n * Returns a function to check if a value is within range of a base value\n * ```js\n * const close = isApprox(0.1, 100);\n * // Check if 101 is within 10% range of 100\n * close(101);\n * ```\n * @param rangePercent \n * @param baseValue \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n): (value: number) => boolean;\n\n/**\n * Returns _true/false_ if `value` is within `rangePercent` of `baseValue`.\n * \n * ```js\n * isApprox(0.1, 100, 101);\n * ```\n * @param rangePercent \n * @param baseValue \n * @param value \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n  value: number\n): boolean;\n\n\n/**\n * Checks if a value is within range of a base value\n * \n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n * \n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n * \n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n * \n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent \n * @param baseValue \n * @param v \n * @returns \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue?: number,\n  v?: number\n) {\n  resultThrow(numberTest(rangePercent, `percentage`, `rangePercent`));\n\n  // Round percentages to avoid floating point nonsense\n  const range = Math.floor(rangePercent * 100);\n  const test = (base: number, value: number): boolean => {\n    try {\n      if (typeof value !== `number`) return false;\n      if (Number.isNaN(value)) return false;\n      if (!Number.isFinite(value)) return false;\n\n      // Round value\n      const diff = Math.abs(value - base)\n      const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n      //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n      return relative <= range;\n    } catch {\n      return false;\n    }\n  };\n\n  if (baseValue === undefined) return test;\n  resultThrow(numberTest(baseValue, ``, `baseValue`));\n  if (v === undefined) {\n    return (value: number) => test(baseValue, value);\n  } else {\n    return test(baseValue, v);\n  }\n}\n\n// export const isCloseTo = (a: number, b: number, precision = 3):Result<number,string> => {\n//   const aa = a.toPrecision(precision);\n//   const bb = b.toPrecision(precision);\n//   if (aa !== bb) return [ false, `A is not close enough to B. A: ${ a } B: ${ b } Precision: ${ precision }` ];\n//   else return [ true ];\n// }\n\n/**\n * Yields a function that checks if a value is close to any target value\n * ```js\n * const c = isCloseToAny(1, 10, 20, 30, 40);\n * c(11); // True - within 1 range of 10\n * c(19); // True - within 1 range of 20\n * c(0);  // False\n * ```\n * \n * Returned function accepts multiple values, returning\n * _true_ if any of them are within range\n * ```js\n * c(0, 1, 11); // Would return true based on 11\n * ```\n * @param allowedRangeAbsolute \n * @param targets \n * @returns \n */\nexport const isCloseToAny = (allowedRangeAbsolute: number, ...targets: number[]) => {\n  const targetsMin = targets.map(t => t - allowedRangeAbsolute);\n  const targetsMax = targets.map(t => t + allowedRangeAbsolute);\n\n  return (...values: number[]) => {\n    for (const v of values) {\n      for (let index = 0; index < targets.length; index++) {\n        if (v >= targetsMin[ index ] && v <= targetsMax[ index ]) return true;\n      }\n    }\n    return false;\n  }\n}","//import { floatSource,type RandomOptions, type RandomSource } from '@ixfx/random';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { interpolate, scaler as numberScaler, scale as numberScale } from '@ixfx/numbers';\nimport type { BipolarWrapper } from './types.js';\n\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n * \n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n * \n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n * \n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns \n */\nexport const immutable = (startingValueOrBipolar: number | BipolarWrapper = 0): BipolarWrapper => {\n  if (typeof startingValueOrBipolar === `undefined`) throw new Error(`Start value is undefined`)\n  const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n\n  if (startingValue > 1) throw new Error(`Start value cannot be larger than 1`);\n  if (startingValue < -1) throw new Error(`Start value cannot be smaller than -1`);\n  if (Number.isNaN(startingValue)) throw new Error(`Start value is NaN`);\n\n  const v = startingValue;\n  return {\n    [ Symbol.toPrimitive ](hint: string) {\n      if (hint === `number`) return v;\n      else if (hint === `string`) return v.toString();\n      return true;\n    },\n    value: v,\n    towardZero: (amt: number) => {\n      return immutable(towardZero(v, amt));\n    },\n    add: (amt: number) => {\n      return immutable(clamp(v + amt));\n    },\n    multiply: (amt: number) => {\n      return immutable(clamp(v * amt));\n    },\n    inverse: () => {\n      return immutable(-v);\n    },\n    interpolate: (amt: number, b: number) => {\n      return immutable(clamp(interpolate(amt, v, b)));\n    },\n    asScalar: (max = 1, min = 0) => {\n      return toScalar(v, max, min);\n    }\n  }\n}\n\n/**\n * Converts bipolar value to a scalar. That is, converts from\n * -1..1 range to 0..1.\n * \n * ```js\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n * \n * Range can be changed:\n * ```js\n * Bipolar.toScalar(0, 100); // Uses 0..100 scale, so output is 50\n * Bipolar.toScalar(0, 100, 50); // Uses 50..1000 scale, so output is 75\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue: number, max = 1, min = 0) => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);\n  return numberScale(bipolarValue, -1, 1, min, max);\n}\n\n/**\n * Makes a scalar into a bipolar value.\n * \n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n * \n * Throws an error if `scalarValue` is outside 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue: number) => {\n  resultThrow(numberTest(scalarValue, `percentage`, `v`));\n  return (scalarValue * 2) - 1;\n};\n\n/**\n * Scale & clamp value to bipolar range (-1..1).\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue: number, inMin: number, inMax: number) => {\n  return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n}\n\n/**\n * Scale a number to bipolar range (-1..1). Not clamped, so we might exceed range.\n * \n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scaleUnclamped(100, 0, 100); // 1\n * Bipolar.scaleUnclamped(50, 0, 100);  // 0\n * Bipolar.scaleUnclamped(0, 0, 100);   // -1\n * ```\n * \n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleUnclamped = (inputValue: number, inMin: number, inMax: number) => {\n  return numberScaler(inMin, inMax, -1, 1)(inputValue);\n}\n\n\n/**\n * Clamp a bipolar value\n * ```js\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Param 'bipolarValue' must be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Param 'bipolarValue' is NaN`);\n  if (bipolarValue > 1) return 1;\n  if (bipolarValue < -1) return -1;\n  return bipolarValue;\n}\n\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n * \n * ```js\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n * \n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue: number, amount: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${ typeof bipolarValue }`);\n  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${ typeof amount }`);\n  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);\n  if (bipolarValue < 0) {\n    bipolarValue += amount;\n    if (bipolarValue > 0) bipolarValue = 0;\n  } else if (bipolarValue > 0) {\n    bipolarValue -= amount;\n    if (bipolarValue < 0) bipolarValue = 0;\n  }\n  return bipolarValue;\n}","/* eslint-disable unicorn/prevent-abbreviations */\nimport { numberTest, integerTest, resultThrow } from '@ixfx/guards';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min = 0, max = 360) => {\n  resultThrow(\n    integerTest(v, undefined, `v`),\n    integerTest(min, undefined, `min`),\n    integerTest(max, undefined, `max`)\n  );\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min = 0, max = 1) => {\n  resultThrow(\n    numberTest(v, ``, `min`),\n    numberTest(min, ``, `min`),\n    numberTest(max, ``, `max`)\n  );\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  let r = 0;\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","export const piPi= Math.PI*2;","import { wrap } from './wrap.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type BasicInterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  transform: (v: number) => number\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<BasicInterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<BasicInterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<BasicInterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link https://api.ixfx.fun/_ixfx/modulation/interpolatorInterval/} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<BasicInterpolateOptions>, pos3?: number | Partial<BasicInterpolateOptions>, pos4?: Partial<BasicInterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: BasicInterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    resultThrow(\n      numberTest(_a, ``, `a`),\n      numberTest(_b, ``, `b`),\n      numberTest(_amt, ``, `amount`)\n    );\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<BasicInterpolateOptions> = {}) => {\n    if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    resultThrow(numberTest(amount, ``, `amount`));\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link https://api.ixfx.fun/_ixfx/modulation/interpolatorInterval/}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<BasicInterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<BasicInterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(\n  start: number,\n  end: number,\n  steps: number,\n  precision?: number\n): IterableIterator<number> {\n\n  resultThrow(\n    numberTest(start, ``, `start`),\n    numberTest(end, ``, `end`),\n    numberTest(steps, ``, `steps`)\n  );\n  const r = precision ? round(precision) : (v: number) => v;\n  const step = (end - start) / (steps - 1);\n\n  resultThrow(numberTest(step, ``, `step`));\n  if (!Number.isFinite(step)) {\n    throw new TypeError(`Calculated step value is infinite`);\n  }\n\n  for (let index = 0; index < steps; index++) {\n    const v = start + step * index;\n    yield r(v);\n  }\n}\n","export class BasicQueueMutable<V> {\n  #store: V[] = [];\n\n  enqueue(data: V) {\n    this.#store.push(data);\n  }\n\n  dequeue(): V | undefined {\n    return this.#store.shift();\n  }\n\n  get data() {\n    return this.#store;\n  }\n  get size() {\n    return this.#store.length;\n  }\n}","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  resultThrow(numberTest(scaling, `aboveZero`, `scaling`));\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r.success && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n};\n\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n * \n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from '@ixfx/numbers.js';\n * import { gaussian } from '@ixfx/modulation.js';\n * \n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  const q = new BasicQueueMutable<number>();\n  return (v?: number) => {\n    const r = numberTest(v);\n    if (r.success && v !== undefined) {\n      q.enqueue(v);\n      while (q.size > samples) {\n        q.dequeue();\n      }\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n};\n\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    timestamp ??= performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { clamp, clamper } from './clamp.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport type { NumberScaler, NumberScalerTwoWay } from './types.js';\n\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => scaler(inMin, inMax, outMin, outMax, easing)(v);\n\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number,\n  clamped?: boolean\n): NumberScaler => {\n\n  resultThrow(\n    numberTest(inMin, `finite`, `inMin`),\n    numberTest(inMax, `finite`, `inMax`)\n  );\n  const oMax = outMax ?? 1;\n  const oMin = outMin ?? 0;\n  const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n\n  return (v: number): number => {\n    if (inMin === inMax) return oMax;\n\n    let a = (v - inMin) / (inMax - inMin);\n    if (easing !== undefined) a = easing(a);\n    const x = a * (oMax - oMin) + oMin;\n    if (clampFunction) return clampFunction(x);\n    return x;\n  };\n};\n\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns \n */\nexport const scalerNull = (): NumberScaler => (v: number) => v;\n\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => {\n  if (typeof outMax === `undefined`) outMax = 1;\n  if (typeof outMin === `undefined`) outMin = 0;\n  if (inMin === inMax) return outMax;\n\n  const x = scale(v, inMin, inMax, outMin, outMax, easing);\n  return clamp(x, outMin, outMax);\n};\n\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (\n  percentage: number,\n  outMin: number,\n  outMax = 1\n): number => {\n  resultThrow(\n    numberTest(percentage, `percentage`, `v`),\n    numberTest(outMin, `percentage`, `outMin`),\n    numberTest(outMax, `percentage`, `outMax`)\n  );\n  return scale(percentage, 0, 1, outMin, outMax);\n};\n\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (\n  v: number,\n  outMin: number,\n  outMax: number\n): number => scalerPercent(outMin, outMax)(v);\n\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin: number, outMax: number) => {\n  return (v: number) => {\n    resultThrow(numberTest(v, `percentage`, `v`));\n    return scale(v, 0, 1, outMin, outMax);\n  };\n};\n\n\n\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n * \n * // Scale from input to output\n * s.out(50); // 0.5\n * \n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin \n * @param inMax \n * @param outMin \n * @param outMax \n * @returns \n */\nexport const scalerTwoWay = (inMin: number, inMax: number, outMin = 0, outMax = 1, clamped = false, easing?: (v: number) => number): NumberScalerTwoWay => {\n  const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n  const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n  return { out: toOut, in: toIn };\n}","import type { NumbersComputeOptions, NumbersComputeResult } from \"./types.js\";\n\n/**\n * Calculate the min, max, total, average and count of input array `data`.\n * ```js\n * const { total, min, max, avg, count } = numberArrayCompute([ 1, 2, 3 ]);\n * ```\n * @param data \n * @param opts \n * @returns \n */\nexport const numberArrayCompute = (data: (number | undefined)[] | readonly (number | undefined)[], opts: NumbersComputeOptions = {}): NumbersComputeResult => {\n  if (data.length === 0) {\n    return {\n      total: Number.NaN,\n      min: Number.NaN,\n      max: Number.NaN,\n      avg: Number.NaN,\n      count: Number.NaN\n    };\n  }\n  const nonNumbers = opts.nonNumbers ?? `throw`;\n\n  let total = 0;\n  let min = Number.MAX_SAFE_INTEGER;\n  let max = Number.MIN_SAFE_INTEGER;\n  let count = 0;\n  for (let index = 0; index < data.length; index++) {\n    let value = data[ index ];\n    if (typeof value !== `number`) {\n      if (nonNumbers === `ignore`) continue;\n      if (nonNumbers === `throw`) throw new Error(`Param 'data' contains a non-number at index: ${ index.toString() }`);\n      if (nonNumbers === `nan`) value = Number.NaN;\n    }\n    if (Number.isNaN(value)) continue;\n    if (value !== undefined) {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n      total += value;\n      count++;\n    }\n  }\n  return {\n    total, max, min, count,\n    avg: total / count\n  }\n}","\nimport { scale } from './scale.js';\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { clamp } from './clamp.js';\nimport { numberArrayCompute } from './number-array-compute.js';\nimport type { NormaliseStreamContext } from './types.js';\n\n/**\n * A more advanced form of {@link stream}.\n * \n * With this version\n * @example\n * ```js\n * const s = Normalise.streamWithContext();\n * s.seen(2);    // 1 (because 2 is highest seen)\n * s.seen(1);    // 0 (because 1 is the lowest so far)\n * s.seen(1.5);  // 0.5 (50% of range 1-2)\n * s.seen(0.5);  // 0 (because it's the new lowest)\n * ```\n * \n * And the more advanced features\n * ```js\n * s.min / s.max / s.range\n * s.reset();\n * s.reset(10, 100);\n * ```\n * @returns\n */\nexport const streamWithContext = (minDefault?: number, maxDefault?: number): NormaliseStreamContext => {\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  resultThrow(\n    numberTest(min),\n    numberTest(max)\n  );\n  return {\n    seen: (v: number): number => {\n      resultThrow(numberTest(v));\n      min = Math.min(min, v);\n      max = Math.max(max, v);\n      return scale(v, min, max);\n    },\n    reset: (minDefault?: number, maxDefault?: number) => {\n      min = minDefault ?? Number.MAX_SAFE_INTEGER;\n      max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n    },\n    get min() {\n      return min;\n    },\n    get max() {\n      return max;\n    },\n    get range() {\n      return Math.abs(max - min);\n    }\n  }\n};\n\n/**\n * Normalises numbers, adjusting min/max as new values are processed. Return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * Use {@link streamWithContext} if you want to be able to check the min/max or reset the normaliser.\n * \n * @example\n * ```js\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number): (value: number) => number => {\n  const c = streamWithContext(minDefault, maxDefault);\n  return c.seen;\n}\n\n/**\n * Normalises an array.\n * \n * This version returns additional context of the normalisation, alternatively use {@link array}\n *\n * ```js\n * const c = arrayWithContext(someValues);\n * c.values;    // Array of normalised values\n * c.original;  // Original input array\n * c.min / c.max / c.range\n * ```\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const arrayWithContext = (values: readonly number[],\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(`Param 'values' should be an array. Got: ${ typeof values }`);\n  }\n  const mma = numberArrayCompute(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return {\n    values: values.map((v: number) => clamp(scale(v, min, max))),\n    original: values,\n    min, max,\n    range: Math.abs(max - min)\n  }\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. \n * \n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * Use {@link arrayWithContext} to get back the min/max/range and original values\n * \n * ```js\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values: readonly number[],\n  minForced?: number,\n  maxForced?: number\n) => {\n  const c = arrayWithContext(values, minForced, maxForced);\n  return c.values;\n}","import { numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * \n * The utility of this function is that it sanity-checks that\n * both parameters are in the 0..1 scale.\n * \n * Parameters can also be a function that takes no parameters\n * and returns a number. It will be invoked when `proportion` is called.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (\n  v: number | (() => number),\n  t: number | (() => number)\n) => {\n  if (typeof v === `function`) v = v();\n  if (typeof t === `function`) t = t();\n\n  resultThrow(\n    numberTest(v, `percentage`, `v`),\n    numberTest(t, `percentage`, `t`)\n  );\n  return v * t;\n};\n","import { integerTest, numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyString = every.toString();\n  const decimal = everyString.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    const d = everyString.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n\n  resultThrow(\n    numberTest(v, ``, `v`),\n    integerTest(every, ``, `every`)\n  );\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { scaler } from \"./scale.js\";\nimport type { NumericRange } from \"./types.js\";\n\n\n/**\n * Computes min/max based on a new value and previous range.\n * Returns existing object reference if value is within existing range.\n * \n * If `value` is not a number, by default it will be ignored. Use the 'nonNumberHandling' param to set it\n * to throw an error instead if you want to catch that\n * @param value Value to compare against range\n * @param previous Previous range\n * @param nonNumberHandling 'skip' (default), non numbers are ignored; 'error' an error is thrown\n * @returns \n */\nexport function rangeMergeValue(value: number | undefined, previous: NumericRange, nonNumberHandling: `skip` | `error` = `skip`): NumericRange {\n  if (typeof value === `number`) {\n    if (Number.isNaN(value) || !Number.isFinite(value)) {\n      if (nonNumberHandling === `error`) throw new TypeError(`Param 'value' is NaN or infinite, and nonNumberHandling is set to 'error'`);\n      return previous;\n    }\n\n    // Skip creating an object if it's in range\n    if (value >= previous.min && value <= previous.max) return previous;\n\n    // Return new range\n    return {\n      min: Math.min(value, previous.min),\n      max: Math.max(value, previous.max),\n    }\n  } else if (nonNumberHandling === `error`) {\n    throw new TypeError(`Param 'value' is not a number (type: '${ typeof value }') and nonNumberHandling is set to 'error'`);\n  }\n  return previous;\n}\n\n/**\n * Returns a function that scales values in a range, by default on 0..1 scale.\n * ```js\n * const range = { min: 10, max: 20 }\n * const s = rangeScaler(range);\n * s(15); // 0.5\n * ```\n * @param range Range to scale on\n * @param outMax Output range max. Default: 1\n * @param outMin Output range min. Default: 0\n * @param easing Easing function: Default: none\n * @param clamped Whether input values should be clamped if they exceed range. Default: true\n * @returns \n */\nexport function rangeScaler(range: NumericRange, outMax = 1, outMin = 0, easing?: (v: number) => number, clamped = true) {\n  return scaler(range.min, range.max, outMin, outMax, easing, clamped)\n}\n\n/**\n * Expands a range to encompass a new range.\n * Returns `existingRange` if `newRange` is within it.\n * @param newRange \n * @param existingRange \n * @returns \n */\nexport function rangeMergeRange(newRange: NumericRange, existingRange: NumericRange): NumericRange {\n  if (newRange.max <= existingRange.max && newRange.min >= existingRange.min) return existingRange;\n  return {\n    min: Math.min(newRange.min, existingRange.min),\n    max: Math.max(newRange.max, existingRange.max)\n  }\n}\n\n/**\n * Returns an empty range:\n * ```js\n * { \n *  min: Number.MAX_SAFE_INTEGER, \n *  max: Number.MIN_SAFE_INTEGER \n * }\n * ```\n * @returns \n */\nexport const rangeInit = (): NumericRange => ({ min: Number.MAX_SAFE_INTEGER, max: Number.MIN_SAFE_INTEGER });\n\n/**\n * Returns _true_ if ranges `a` and `b` have identical min/max values.\n * Returns _false_ if not, or if either/both values are _undefined_\n * @param a \n * @param b \n * @returns \n */\nexport const rangeIsEqual = (a: NumericRange | undefined, b: NumericRange | undefined) => {\n  if (typeof a === `undefined`) return false;\n  if (typeof b === `undefined`) return false;\n  return (a.max === b.max && a.min === b.min);\n}\n\n/**\n * Returns _true_ if range 'a' is within or same as range 'b'.\n * Returns _false_ if not or if either/both ranges are _undefined_\n * @param a \n * @param b \n * @returns \n */\nexport const rangeIsWithin = (a: NumericRange | undefined, b: NumericRange | undefined) => {\n  if (typeof a === `undefined`) return false\n  if (typeof b === `undefined`) return false\n  if (a.min >= b.min && a.max <= b.max) return true;\n  return false;\n}\n\n/**\n * Keeps track of min/max values.\n * \n * ```js\n * const s = rangeStream();\n * s.seen(10);  // { min: 10, max: 10}\n * s.seen(5);   // { min:5, max: 10}\n * ```\n * \n * When calling `seen`, non-numbers, or non-finite numbers are silently ignored.\n * \n * ```js\n * s.reset();   // Reset\n * s.min/s.max; // Current min/max\n * s.range;     // Current { min, max }\n * ```\n * @param initWith \n * @returns \n */\nexport const rangeStream = (initWith: NumericRange = rangeInit()) => {\n  let { min, max } = initWith;\n  const seen = (v: any) => {\n    if (typeof v === `number`) {\n      if (!Number.isNaN(v) && Number.isFinite(v)) {\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n      }\n    }\n    return { min, max }\n  }\n  const reset = () => {\n    min = Number.MAX_SAFE_INTEGER;\n    max = Number.MIN_SAFE_INTEGER;\n  }\n\n  return {\n    seen, reset,\n    get range() {\n      return { min, max }\n    },\n    get min() {\n      return min;\n    },\n    get max() {\n      return max;\n    }\n  }\n}\n\n/**\n * Iterates over `values` finding the min/max.\n * By default non-numbers, as well as NaN and infinite values are skipped.\n * @param values \n * @param nonNumberHandling \n * @returns \n */\nexport function rangeCompute(values: Iterable<any>, nonNumberHandling: `skip` | `error` = `skip`): NumericRange {\n  let min = Number.MAX_SAFE_INTEGER;\n  let max = Number.MIN_SAFE_INTEGER;\n  let position = 0;\n  for (const v of values) {\n    if (typeof v === `number`) {\n      if (Number.isNaN(v) || !Number.isFinite(v)) {\n        if (nonNumberHandling === `error`) throw new Error(`Value NaN or infinite at position: ${ position }`);\n        continue;\n      }\n    } else {\n      if (nonNumberHandling === `error`) throw new Error(`Contains non number value. Type: '${ typeof v }' Position: ${ position }`);\n      continue;\n    }\n    if (v < min) min = v;\n    if (v > max) max = v;\n    position++;\n  }\n  return { min, max };\n}\n","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits \n * @returns \n */\nexport const softmax = (logits: number[]) => {\n\n  const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n  const scores = logits.map((l) => Math.exp(l - maxLogit));\n  const denom = scores.reduce((a, b) => a + b);\n  return scores.map((s) => s / denom);\n}","export const trackSimple = () => {\n  let count = 0;\n  let min = Number.MAX_SAFE_INTEGER;\n  let max = Number.MIN_SAFE_INTEGER;\n  let total = 0;\n\n  const seen = (v: number) => {\n    min = Math.min(v, min);\n    max = Math.max(v, max);\n    total += v;\n    count++;\n  }\n\n  const reset = () => {\n    count = 0;\n    min = Number.MAX_SAFE_INTEGER;\n    max = Number.MIN_SAFE_INTEGER;\n    total = 0;\n  }\n\n  const rangeToString = (digits = 2) => {\n    return `${ min.toFixed(2) } - ${ max.toFixed(2) }`\n  }\n  return {\n    seen, reset, rangeToString,\n    get avg() {\n      return total / count\n    },\n    get min() {\n      return min;\n    },\n    get max() {\n      return max;\n    },\n    get total() {\n      return total;\n    },\n    get count() {\n      return count;\n    }\n  }\n}","import { Points, PointsTracker, PointTracker, Rects, type Point, type RectPositioned } from 'ixfx/geometry.js';\nimport type { PoseData } from './index.js';\nimport { getLandmarkNameByIndex, type PoseLandmarks } from './landmarks.js';\nimport { centroid } from './geometry.js';\nimport type { TrackedValueOpts } from 'ixfx/trackers.js';\nimport * as Arrays from 'ixfx/arrays.js';\nimport { numberArrayCompute, type NumbersComputeResult } from 'ixfx/numbers.js';\nimport { type Landmark, type NormalizedLandmark } from '../../types-mp.js';\n\nexport type { TrackedValueOpts }\n/**\n * PoseTracker keeps track of a landmarks for a single pose. \n * This is useful for tracking the movement of a pose or its landmarks over time.\n * It does this by making a PointTracker for each keypoint of a pose.\n * \n * Note: You probably don't want to create this yourself! Rather, use a {@link PosesTracker} to access.\n * \n * @example\n * ```js\n * // Create a tracker (fromId is the id of sender, poseId is the id of the pose)\n * const pt = new PoseTracker(fromId, poseId, options);\n * // ...and whenever there is data, call .seen()\n * pt.seen(pose);\n * ```\n * \n * When creating, the most useful tuning options are `sampleLimit` which governs\n * how many of the most recent samples to keep, and `storeIntermediate` (true/false)\n * to store intermediate data.\n * \n * ## Accessing keypoints\n *  You can get the raw keypoint data from the pose\n * ```js\n * // Get a single point\n * const nosePoint = pose.landmarkValue(`nose`); // { x, y, score, name }\n * // Get all points\n * for (const kp of poses.landmarkValues()) {\n * // { x, y, score, name }\n * }\n * ```\n * But the real power comes from getting the [PointTracker](https://api.ixfx.fun/_ixfx/geometry/PointTracker/) for a keypoint, since it keeps track of not just the last data, but a whole trail of historical data for a given keypoint.\n * ```js\n * const noseTracker = pose.landmark(`nose`); // PointTracker\n * ```\n * Once we have the PointTracker, there are a _lot_ of things to access:\n * \n */\nexport class PoseTracker {\n  #fromId;\n  #poseId;\n  #guid;\n  #seen = 0;\n  #boxNormalised: RectPositioned | undefined;\n  #boxWorld: RectPositioned | undefined;\n  #data: PoseData | undefined;\n  #normalisedLandmarks: PointsTracker<NormalizedLandmark>;\n  #worldLandmarks: PointsTracker<Landmark>;\n  #hue: number;\n  #zNormalisedRange: NumbersComputeResult = { count: 0, min: 0, max: 0, avg: 0, total: 0 }\n  #zWorldRange: NumbersComputeResult = { count: 0, min: 0, max: 0, avg: 0, total: 0 }\n\n  /**\n   * Creates a PoseTracker\n   * \n   * Defaults:\n   * * sampleLimit: 10\n   * * storeIntermediate: false\n   * @param fromId Data source for pose (ie device)\n   * @param poseId Id of pose from TFjs\n   * @param options \n   */\n  constructor(fromId: string, poseId: string, options: TrackedValueOpts = {}) {\n    this.#poseId = poseId;\n    this.#fromId = fromId;\n    this.#guid = fromId + `-` + poseId;\n    this.#hue = Math.random() * 360;\n    const opts: TrackedValueOpts = {\n      id: poseId,\n      debug: options.debug ?? false,\n      sampleLimit: 10,\n      storeIntermediate: false,\n      ...options\n    }\n    this.#normalisedLandmarks = new PointsTracker<NormalizedLandmark>(opts);\n    this.#worldLandmarks = new PointsTracker<Landmark>(opts);\n  }\n\n  /**\n   * Reset stored data for the tracker\n   */\n  reset() {\n    this.#normalisedLandmarks.reset();\n    this.#worldLandmarks.reset();\n  }\n\n  /**\n   * Returns a [PointTracker](https://api.ixfx.fun/_ixfx/geometry/PointTracker/) for a given\n   * normalised landmark by name or index.\n   * \n   * ```js\n   * // Eg. get tracker for the 'nose' landmark\n   * const nose = pose.landmark(`nose`);\n   * \n   * // Get the angle of nose movement since the start\n   * const a = nose.angleFromStart();\n   * \n   * // Get the distance of nose since start\n   * const d = nose.distanceFromStart();\n   * ```\n   * @param nameOrIndex \n   * @returns \n   */\n  landmark(nameOrIndex: PoseLandmarks | number): PointTracker<NormalizedLandmark> | undefined {\n    if (nameOrIndex === undefined) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    if (typeof nameOrIndex === `number`) {\n      return this.#normalisedLandmarks.get(getLandmarkNameByIndex(nameOrIndex)) as PointTracker<NormalizedLandmark> | undefined;\n    } else {\n      return this.#normalisedLandmarks.get(nameOrIndex) as PointTracker<NormalizedLandmark> | undefined;\n    }\n  }\n\n  /**\n * Returns a [PointTracker](https://api.ixfx.fun/_ixfx/geometry/PointTracker/) for a given\n * normalised landmark by name or index.\n * \n * ```js\n * // Eg. get tracker for the 'nose' landmark\n * const nose = pose.landmark(`nose`);\n * \n * // Get the angle of nose movement since the start\n * const a = nose.angleFromStart();\n * \n * // Get the distance of nose since start\n * const d = nose.distanceFromStart();\n * ```\n * @param nameOrIndex \n * @returns \n */\n  worldLandmark(nameOrIndex: PoseLandmarks | number): PointTracker<Landmark> | undefined {\n    if (nameOrIndex === undefined) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    if (typeof nameOrIndex === `number`) {\n      return this.#worldLandmarks.get(getLandmarkNameByIndex(nameOrIndex)) as PointTracker<Landmark> | undefined;\n    } else {\n      return this.#worldLandmarks.get(nameOrIndex) as PointTracker<Landmark> | undefined;\n    }\n  }\n\n  /**\n   * Returns the last position for a given landmark.\n   * ```js\n   * const pos = pose.landmarkValue(`nose`); // { x, y }\n   * ```\n   * \n   * Throws an error if `nameOrIndex` does not exist.\n   * @param nameOrIndex\n   * @returns \n   */\n  landmarkValue(nameOrIndex: PoseLandmarks | number): NormalizedLandmark {\n    if (nameOrIndex === undefined) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    const name = typeof nameOrIndex === `string` ? nameOrIndex : getLandmarkNameByIndex(nameOrIndex);\n    const t = this.#normalisedLandmarks.get(name);\n    if (t === undefined) throw new Error(`Point '${ name }' is not tracked`);\n    const pt = t.last;\n    if (pt === undefined) throw new Error(`No data for point '${ name }'`);\n    return pt;\n  }\n\n  /**\n * Returns the last position for a given landmark.\n * ```js\n * const pos = pose.landmarkValue(`nose`); // { x, y }\n * ```\n * \n * Throws an error if `nameOrIndex` does not exist.\n * @param nameOrIndex\n * @returns \n */\n  worldLandmarkValue(nameOrIndex: PoseLandmarks | number): Landmark {\n    if (nameOrIndex === undefined) throw new TypeError(`Param 'nameOrIndex' is undefined. Expected landmark name or numerical index`);\n    const name = typeof nameOrIndex === `string` ? nameOrIndex : getLandmarkNameByIndex(nameOrIndex);\n    const t = this.#worldLandmarks.get(name);\n    if (t === undefined) throw new Error(`Point '${ name }' is not tracked`);\n    const pt = t.last;\n    if (pt === undefined) throw new Error(`No data for point '${ name }'`);\n    return pt;\n  }\n\n\n  /**\n   * Update this pose with new information\n   * @param pose \n   */\n  seen(pose: PoseData) {\n    this.#seen = Date.now();\n    this.#data = pose;\n    let zNormalisedValues: number[] = [];\n    let zWorldValues: number[] = [];\n\n    for (let i = 0; i < pose.landmarks.length; i++) {\n      const lm = pose.landmarks[ i ];\n      zNormalisedValues.push(lm.z);\n      const name = getLandmarkNameByIndex(i);\n      this.#normalisedLandmarks.seen(name, lm);\n    }\n\n    for (let i = 0; i < pose.world.length; i++) {\n      const lm = pose.landmarks[ i ];\n      zWorldValues.push(lm.z);\n      const name = getLandmarkNameByIndex(i);\n      this.#worldLandmarks.seen(name, lm);\n    }\n\n    this.#zNormalisedRange = numberArrayCompute(zNormalisedValues);\n    this.#zWorldRange = numberArrayCompute(zWorldValues);\n  }\n\n  /**\n   * Returns all the [PointTrackers](https://api.ixfx.fun/_ixfx/geometry/PointTracker/) (ie. landmark) for this pose.\n   * \n   * ```js\n   * for (const pt of pose.landmarks()) {\n   *  // Do something with 'pt' (which tracks one individual landmark)\n   * }\n   * ```\n   * \n   * Or provide a list of landmark indexes or name:\n   * ```js\n   * // Get landmarks for right arm\n   * for (const pt of pose.landmarks(11, 13, 15)) {\n   * }\n   * ```\n   */\n  *landmarks(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (namesOrIds.length > 0) {\n      for (const ni of namesOrIds) {\n        const l = this.landmark(ni);\n        if (l) yield l;\n      }\n    } else {\n      yield* this.#worldLandmarks.store.values();\n    }\n  }\n\n  *worldLandmarks(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (namesOrIds.length > 0) {\n      for (const ni of namesOrIds) {\n        const l = this.worldLandmark(ni);\n        if (l) yield l;\n      }\n    } else {\n      yield* this.#worldLandmarks.store.values();\n    }\n  }\n\n  /**\n   * Returns the raw landmarks\n   * \n   * ```js\n   * for (const kp of pose.landmarkValues()) {\n   *  // { x, y, z?, score, name }\n   * }\n   * ```\n   */\n  *landmarkValues(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (namesOrIds.length > 0) {\n      for (const ni of namesOrIds) {\n        const pt = this.landmark(ni);\n        if (pt) yield pt.last;\n      }\n    } else {\n      for (const v of this.#normalisedLandmarks.store.values()) {\n        yield v.last;\n      }\n    }\n  }\n\n  *worldLandmarkValues(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (namesOrIds.length > 0) {\n      for (const ni of namesOrIds) {\n        const pt = this.landmark(ni);\n        if (pt) yield pt.last;\n      }\n    } else {\n      for (const v of this.#worldLandmarks.store.values()) {\n        yield v.last;\n      }\n    }\n  }\n\n  /**\n   * Returns the 2D centroid of all the pose points (uses normalised landmarks)\n   * ```js\n   * pose.centroid(); // { x, y }\n   * ```\n   * \n   * Or you can pass in the names/indexes of landmarks:\n   * ```js\n   * pose.centroid(`left_shoulder`, `right_shoulder`);\n   * ```\n   * \n   * Returns `{ x: 0.5, y: 0.5 }` is data is missing\n   */\n  centroid(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (!this.#data) return { x: 0.5, y: 0.5 };\n    if (namesOrIds.length === 0) {\n      return centroid(this.#data);\n    } else {\n      const pts = [ ...this.landmarkValues(...namesOrIds) ];\n      return Points.centroid(...pts);\n    }\n  }\n\n  /**\n   * Returns PointTrackers, sorted by their last X value\n   * @param namesOrIds \n   * @returns \n   */\n  getSortedByX(...namesOrIds: (PoseLandmarks | number)[]) {\n    const lm = [ ...this.landmarks(...namesOrIds) ];\n    if (lm.length === 0) throw new Error(`No landmarks found per filter`);\n    return Arrays.sortByNumericProperty(lm, `x`);\n  }\n\n  /**\n   * Gets the leftmost (by camera frame coords) of any of the listed landmarks\n   * \n   * Eg get whichever wrist is the most left of the camera frame\n   * ```js\n   * pose.getLeftmost(`left_wrist`,`right_wrist`);\n   * ```\n   * @param namesOrIds \n   * @returns \n   */\n  getLeftmost(...namesOrIds: (PoseLandmarks | number)[]) {\n    const s = this.getSortedByX(...namesOrIds);\n    if (s.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return s[ 0 ];\n  }\n\n  /**\n   * Gets the rightmost (by camera frame coords) of any of the listed landmarks\n   * \n   * Eg get whichever wrist is the most right of the camera frame\n   * ```js\n   * pose.getRightmost(`left_wrist`,`right_wrist`);\n   * ```\n   * @param namesOrIds \n   * @returns \n   */\n  getRightmost(...namesOrIds: (PoseLandmarks | number)[]) {\n    const s = this.getSortedByX(...namesOrIds);\n    if (s.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return s[ s.length - 1 ];\n  }\n\n  /**\n   * Gets the highest (by camera frame coords) of any of the listed landmarks\n   * \n   * Eg get whichever wrist is the highest in the camera frame\n   * ```js\n   * pose.getHighest(`left_wrist`,`right_wrist`);\n   * ```\n   * @param namesOrIds \n   * @returns \n   */\n  getHighest(...namesOrIds: (PoseLandmarks | number)[]) {\n    const s = this.getSortedByY(...namesOrIds);\n    if (s.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return s[ 0 ];\n  }\n\n  /**\n   * Returns landmarks in order of distance from the given point.\n   * \n   * The point should be the same coordinates as poses.\n   * @param point Point to compare to\n   * @param use2d If _true_, Z coordinate is ignored.\n   */\n  getByDistanceFromPoint(point: Points.Point, use2d: boolean = true) {\n    const withDistance = [ ...this.landmarks() ].map(lm => {\n      return {\n        distance: use2d ? Points.distance2d(lm.last, point) : Points.distance(lm.last, point),\n        landmark: lm,\n        raw: lm.last as NormalizedLandmark\n      }\n    });\n    withDistance.sort((a, b) => {\n      return a.distance - b.distance;\n    });\n    return withDistance;\n  }\n\n  /**\n   * Returns the closest landmark to `point`\n   * @param point \n   * @param use2d If _true_ only x,y coordinates are used for distance calculation\n   * @returns \n   */\n  getClosestLandmarkToPoint(point: Points.Point, use2d: boolean) {\n    const sorted = this.getByDistanceFromPoint(point, use2d);\n    if (sorted.length === 0) return;\n    return sorted[ 0 ].landmark;\n  }\n\n  /**\n   * Gets the lowest (by camera frame coords) of any of the listed landmarks\n   * \n   * Eg get whichever wrist is the lowest in the camera frame\n   * ```js\n   * pose.getLowest(`left_wrist`,`right_wrist`);\n   * ```\n   * @param namesOrIds \n   * @returns \n   */\n  getLowest(...namesOrIds: (PoseLandmarks | number)[]) {\n    const s = this.getSortedByX(...namesOrIds);\n    if (s.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return s[ s.length - 1 ];\n  }\n\n\n  /**\n   * Gets the nearest (by camera frame coords) of any of the listed landmarks\n   * \n   * Eg get whichever wrist is the nearest in the camera frame\n   * ```js\n   * pose.getNearest(`left_wrist`,`right_wrist`);\n   * ```\n   * @param namesOrIds \n   * @returns \n   */\n  getNearest(...namesOrIds: (PoseLandmarks | number)[]) {\n    const s = this.getSortedByZ(...namesOrIds);\n    if (s.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return s[ 0 ];\n  }\n\n  /**\n   * Gets the furtherest (by camera frame coords) of any of the listed landmarks\n   * \n   * Eg get whichever wrist is the furtherest in the camera frame\n   * ```js\n   * pose.getFurtherest(`left_wrist`,`right_wrist`);\n   * ```\n   * @param namesOrIds \n   * @returns \n   */\n  getFurtherest(...namesOrIds: (PoseLandmarks | number)[]) {\n    const s = this.getSortedByZ(...namesOrIds);\n    if (s.length === 0) throw new Error(`No landmarks found per filter`);\n    return s[ s.length - 1 ];\n  }\n\n  /**\n   * Returns PointTrackers, sorted by their last Y value\n   * @param namesOrIds \n   * @returns \n   */\n  getSortedByY(...namesOrIds: (PoseLandmarks | number)[]) {\n    const lm = [ ...this.landmarks(...namesOrIds) ];\n    if (lm.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return Arrays.sortByNumericProperty(lm, `y`);\n  }\n\n  /**\n   * Returns PointTrackers, sorted by their last Z value\n   * @param namesOrIds \n   * @returns \n   */\n  getSortedByZ(...namesOrIds: (PoseLandmarks | number)[]) {\n    const lm = [ ...this.landmarks(...namesOrIds) ];\n    if (lm.length === 0) throw new Error(`No landmarks found per filter`);\n\n    return Arrays.sortByNumericProperty(lm, `z`);\n  }\n\n  /**\n   * Gets the bounding box of the pose, computed using the normalised landmarks.\n   * ```js\n   * pose.box(); // { x, y, width, height }\n   * ````\n   * \n   * Returns an empty rectangle if there's no data.\n   * \n   * You can also provide a list of landmark names/indexes to compute the bounding box\n   * for just those:\n   * \n   * ```js\n   * // Get bounding box of torso\n   * pose.box(`left_shoulder`, `right_shoulder`, `left_hip`, `right_`hip`);\n   * ```\n   * \n   * See also {@link boxWorld} for same behaviour but using world coordinates.\n   */\n  box(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (!this.#data) return Rects.EmptyPositioned;\n\n    if (namesOrIds.length === 0) {\n      if (this.#boxNormalised) return this.#boxNormalised;\n      this.#boxNormalised = Points.bbox(...this.#data.landmarks);\n      return this.#boxNormalised;\n    } else {\n      return Points.bbox(...this.landmarkValues(...namesOrIds));\n    }\n  }\n\n  boxWorld(...namesOrIds: (PoseLandmarks | number)[]) {\n    if (!this.#data) return Rects.EmptyPositioned;\n\n    if (namesOrIds.length === 0) {\n      if (this.#boxWorld) return this.#boxWorld;\n      this.#boxWorld = Points.bbox(...this.#data.world);\n      return this.#boxWorld;\n    } else {\n      return Points.bbox(...this.worldLandmarkValues(...namesOrIds));\n    }\n  }\n\n  /**\n   * Returns height of bounding box (normalised coordinates)\n   */\n  get height() {\n    return this.box().height;\n  }\n\n  get heightWorld() {\n    return this.boxWorld().height;\n  }\n\n  /**\n   * Return width of bounding box (normalised coordinates)\n   */\n  get width() {\n    return this.box().width;\n  }\n\n  get widthWorld() {\n    return this.boxWorld().width;\n  }\n\n  /**\n   * Returns the id of the sender\n   */\n  get peerId() {\n    return this.#fromId;\n  }\n\n  /**\n   * Returns the middle of the pose bounding box using normalised coordinates\n   * ```js\n   * pose.middle; // { x, y }\n   * ```\n   * @returns \n   */\n  get middle() {\n    const box = this.box();\n    if (Rects.isEmpty(box)) return Points.Empty;\n    return Rects.center(box);\n  }\n\n  get middleWorld() {\n    const box = this.boxWorld();\n    if (Rects.isEmpty(box)) return Points.Empty;\n    return Rects.center(box);\n  }\n\n  /**\n   * Returns the randomly-assigned hue (0..360)\n   */\n  get hue() {\n    return this.#hue;\n  }\n\n  /**\n   * Returns a CSS colour: hsl() based on\n   * the randomly-assigned hue\n   */\n  get hsl() {\n    return `hsl(${ this.#hue }, 70%, 50%)`;\n  }\n\n  /**\n   * Returns the globally unique id of this pose\n   * (fromId-poseId)\n   */\n  get guid() {\n    return this.#guid;\n  }\n\n  /**\n   * Returns the original pose id from TFjs\n   * Warning: this may not be unique if there are multiple senders\n   */\n  get poseId() {\n    return this.#poseId;\n  }\n  /**\n   * Returns the id of the sender of this pose\n   */\n  get fromId() {\n    return this.#fromId;\n  }\n\n  /**\n   * Gets the min/max Z range of all landmarks (normalised)\n   */\n  get zRange() {\n    return this.#zNormalisedRange;\n  }\n\n  /**\n   * Gets the min/max Z range of all landmarks (world coordinates)\n   */\n  get zRangeWorld() {\n    return this.#zWorldRange;\n  }\n\n  /**\n   * Returns how long since pose was updated\n   */\n  get elapsed() {\n    return Date.now() - this.#seen;\n  }\n\n  /**\n   * Returns the last pose data in raw format\n   */\n  get last() {\n    return this.#data;\n  }\n}","import type { TrackedValueOpts } from \"ixfx/trackers.js\";\nimport type { PoseData } from \"./index.js\";\nimport { PoseTracker } from \"./pose-tracker.js\";\nimport { getLandmarkIndexByName, type PoseLandmarks } from \"./landmarks.js\";\nimport { Points } from \"ixfx/geometry.js\";\n\nexport type PosesTrackerOptions = TrackedValueOpts & {\n  maxAgeMs: number\n}\n\n/**\n * Tracks several poses (ie. bodies)\n * \n * Events:\n * - expired: Tracked pose has not been seen for a while\n * - added: A new pose id\n */\nexport class PosesTracker extends EventTarget {\n  /** \n   * PoseTrackers, keyed by 'sender-poseid'\n   **/\n  #data = new Map<string, PoseTracker>();\n  #options: PosesTrackerOptions;\n\n  /**\n   * Constructor\n   * @param {Partial<PosesTrackerOptions>} options \n   */\n  constructor(options = {}) {\n    super();\n    this.#options = {\n      maxAgeMs: 10_000,\n      sampleLimit: 100,\n      storeIntermediate: false,\n      ...options\n    };\n    setInterval(() => {\n      // Delete expired poses\n      const expired = [ ...this.#data.entries() ].filter(entry => entry[ 1 ].elapsed > this.#options.maxAgeMs);\n      for (const entry of expired) {\n        this.#data.delete(entry[ 0 ]);\n\n        //this.fireEvent(`expired`, { pose: entry[ 1 ] });\n        this.dispatchEvent(new CustomEvent(`expired`, { detail: entry[ 1 ] }));\n      }\n    }, 1000);\n  }\n\n  /**\n   * Enumerates each of the PoseTrackers, sorted by age.\n   * The most recent pose will be at position 0.\n   * (ie. one for each body).\n   * Use getRawPosesByAge() to enumerate raw pose data\n   */\n  *getByAge() {\n    const trackers = [ ...this.#data.values() ];\n    trackers.sort((a, b) => a.elapsed - b.elapsed);\n    yield* trackers.values();\n  }\n\n  /**\n   * Enumerates PoseTrackers, sorting by the horizontal middle position.\n   * Leftmost pose will be at position 0.\n   */\n  *getByHorizontal() {\n    const trackers = [ ...this.#data.values() ];\n    trackers.sort((a, b) => a.middle.x - b.middle.x);\n    yield* trackers;\n  }\n\n  /**\n   * Returns poses in order of distance (as judged by their centroid property)\n   * from the given point. Since centroid is 2D, distance is also calculated using x,y only.\n   * \n   * The point should be the same coordinates as poses.\n   * @param point Point to compare to \n   */\n  getByDistanceFromPoint(point: Points.Point) {\n    const withDistance = [ ...this.#data.values() ].map(pt => {\n      return {\n        distance: Points.distance2d(pt.centroid(), point),\n        tracker: pt\n      }\n    });\n    withDistance.sort((a, b) => {\n      return a.distance - b.distance;\n    });\n    return withDistance;\n  }\n\n  /**\n   * Returns the closest pose to `point`, as judged by its centroid property\n   * @param point \n   * @returns \n   */\n  getClosestPoseToPoint(point: Points.Point) {\n    const sorted = this.getByDistanceFromPoint(point);\n    if (sorted.length === 0) return;\n    return sorted[ 0 ].tracker;\n  }\n\n  /**\n   * Enumerates PoseTrackers, sorting by the vertical middle position.\n   * Highest pose will be at position 0.\n   */\n  *getByVertical() {\n    const trackers = [ ...this.#data.values() ];\n    trackers.sort((a, b) => a.middle.y - b.middle.y);\n    yield* trackers;\n  }\n\n  /**\n   * Enumerates PoseTrackers, sorting by the average Z value.\n   * Closest pose will be at position 0.\n   */\n  *getByDistance() {\n    const trackers = [ ...this.#data.values() ];\n    trackers.sort((a, b) => {\n      const az = a.zRange ? a.zRange.avg : 0;\n      const bz = b.zRange ? b.zRange.avg : 0;\n      return az - bz;\n    });\n    yield* trackers;\n  }\n\n  /**\n   * Enumerate all PoseTracker instances\n   */\n  *get() {\n    const trackers = [ ...this.#data.values() ];\n    yield* trackers.values();\n  }\n\n  /**\n   * Enumerate the last set of raw pose data for\n   * each of the PoseTrackers.\n   */\n  *getRawPosesByAge() {\n    for (const tracker of this.getByAge()) {\n      yield tracker.last;\n    }\n  }\n\n  *getRawPoses(): Generator<PoseData> {\n    const values = [ ...this.#data.values() ];\n    for (const tracker of values) {\n      const last = tracker.last;\n      if (!last) continue;\n      yield last;\n    }\n\n  }\n\n  /**\n   * Get a raw landmark by name across all poses\n   * \n   * @example Get the 'nose' landmark for all bodies\n   * ````js\n   * for (const n of poses.landmarkValues(`nose`)) {\n   *  // Yields: { x, y, z?, score, name }\n   * }\n   * ```\n   * \n   * @param namesOrIds Name or index of landmark to get data for\n   */\n  *landmarkValues(...namesOrIds: (PoseLandmarks | number)[]) {\n    for (const pose of this.get()) {\n      yield* pose.landmarkValues(...namesOrIds);\n    }\n  }\n\n  /**\n   * Enumerates all [PointTrackers](https://api.ixfx.fun/classes/Trackers.PointTracker) for a given landmark id.\n   * \n   * ```js\n   * // Return all landmarks for all poses\n   * for (const pt of poses.landmarks()) {\n   * }\n   * ```\n   * \n   * eg. to get the PointTracker for 'nose' across all poses currently seen:\n   * \n   * ```js\n   * for (const pt of poses.landmarks(`nose`)) {\n   *  // do something with tracker...\n   * }\n   * ```\n   * \n   * @param namesOrIds List of indexes or landmark names to filter by\n   */\n  *landmarks(...namesOrIds: (PoseLandmarks | number)[]) {\n    for (const tracker of this.get()) {\n      yield* tracker.landmarks(...namesOrIds);\n    }\n  }\n\n\n  /**\n   * Returns all [PointTrackers](https://api.ixfx.fun/classes/Trackers.PointTracker) from a particular sender\n   * \n   * ```js\n   * for (const pt of poses.getFromSender(`mobile`)) {\n   *  // Do something with tracker...\n   * }\n   * ```\n   * \n   * @param senderId Id of sender\n   */\n  *getFromSender(senderId: string) {\n    const values = [ ...this.#data.values() ];\n    for (const tracker of values) {\n      if (tracker.fromId === senderId) yield tracker;\n    }\n  }\n\n\n  /**\n   * Enumerate the set of unique sender ids\n   * ```js\n   * for (const sender of poses.getSenderIds()) {\n   *  // Do something with sender (string)\n   * }\n   * ```\n   */\n  *getSenderIds() {\n    const set = new Set();\n    const values = [ ...this.#data.values() ];\n    for (const entry of values) {\n      set.add(entry.fromId);\n    }\n    yield* set.values();\n  }\n\n  /**\n   * Returns the PoseTracker for this pose id.\n   * \n   * ```js\n   * const pose = poses.getByPoseId(`123`);\n   * pose.middle; // { x, y }\n   * ```\n   * \n   * Warning: Pose ids are not unique if there are multiple data sources.\n   * Prefer using guids.\n   * \n   * @param id Id of pose\n   */\n  getByPoseId(id: string) {\n    for (const entry of this.#data.values()) {\n      if (entry.poseId === id) return entry;\n    }\n  }\n\n  /**\n   * Returns the last raw pose data for this pose id.\n   * \n   * ```js\n   * const pose = poses.getRawPoseByPoseId(`123`);\n   * pose.landmark; // array of landmarks { x, y, z?, score, name }\n   * pose.score; // score of this pose\n   * pose.box;  // bounding box\n   * ```\n   * \n   * Warning: Pose ids are not unique if there are multiple data sources.\n   * Prefer using guids.\n   * \n   * @param id Id of pose\n   */\n  getRawPoseByPoseId(id: string) {\n    for (const entry of this.#data.values()) {\n      if (entry.poseId === id) return entry.last;\n    }\n  }\n\n  /**\n   * Enumerate the set of globally-unique ids of poses\n   */\n  *getGuids() {\n    for (const t of this.#data.values()) {\n      yield t.guid;\n    }\n  }\n\n  /**\n   * Get the PoseTracker for unique id (based on sender and pose)\n   * ```js\n   * const pt = poses.getByGuid(`123-123`);\n   * pt.middle; // { x, y }\n   * ```\n   * \n   * Alternatively: {@link getRawPoseByGuid} to get raw data\n   * @param guid Combined id of sender-poseid\n   */\n  getByGuid(guid: string | undefined) {\n    if (!guid) return;\n    return this.#data.get(guid);\n  }\n\n  /**\n   * Returns _true_ if a PoseTracker for `guid` is found.\n   * @param guid \n   */\n  hasPoseGuid(guid: string | undefined) {\n    if (!guid) return false;\n    return this.#data.has(guid);\n  }\n\n\n\n  /**\n   * Returns the raw pose data for a unique id\n   * ```js\n   * const pose = poses.getRawPoseByGuide(`123-123`);\n   * pose.landmark; // array of { x, y, z?, score, name }\n   * pose.score;     // score of pose\n   * ```\n   * \n   * Alternatively: {@link getByGuid} to get a tracker for pose\n   * @param guid Combined sender-pose\n   * @returns \n   */\n  getRawPoseByGuid(guid: string) {\n    return this.#data.get(guid)?.last;\n  }\n\n  /**\n   * Track a pose.\n   * Fires `added` event if it is a new pose.\n   * Returns the globally-unique id for this pose\n   * @param pose New pose data\n   * @param from Sender id\n   */\n  seen(from: string, pose: PoseData) {\n    if (from === undefined) throw new Error(`Param 'from' is undefined`);\n    if (pose === undefined) throw new Error(`Param 'pose' is undefined`);\n\n    // Construct globally-unique id for this pose\n    const id = (pose.poseid ?? 0).toString();\n    const nsId = from + `-` + id;\n\n    // Does it exist already?\n    let tp = this.#data.get(nsId);\n\n    // Nope, make a new PoseTracker\n    if (tp === undefined) {\n      tp = new PoseTracker(from, id, this.#options);\n      this.#data.set(nsId, tp);\n      tp.seen(pose);\n      //this.fireEvent(`added`, { pose: tp });\n      this.dispatchEvent(new CustomEvent(`added`, { detail: tp }));\n    } else {\n      // Got it, update with latest pose\n      tp.seen(pose);\n    }\n    return nsId;\n  }\n\n  /**\n   * Return number of tracked poses\n   */\n  get size() {\n    return this.#data.size;\n  }\n\n  /**\n   * Clear all data\n   */\n  clear() {\n    this.#data.clear();\n  }\n\n}\n","export type * from '../../types-mp.js';\nexport type * from '../../types.js';"],"mappings":"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","names":["centroid","__defProp","__export","__defProp","value","min","max","array","t","value","value","entries","value","interval","offset","map","value","values","isEqual","entries","t","interval","reset","resolve","value","t","max","value","min","t","total","tally","next","value","toArray","array","toStringDefault","isEqualDefault","set","length","add","filter","groupBy","map","t","contains","toString","values","lengths","mergeByKey","total","apply","average","min","max","offset","from","interval","round","test","relative","clamp","numberScale","scale","numberScaler","#store","count","smoothingFactor","timestamp","max$1","min$1","minDefault","maxDefault","every","reset","chunk","slice","reduce","uniqueByValue","toString","asCallback","value","last","chunks","concat","dropWhile","until","equals","every","fill","forEach","filter","find","flatten","map","max","min","some","repeat","count","unique","iterable","zip","fromIterable","toArray","fromArray","array","#store","values","#disposed","#listeners","interval","delay","key","perValue","query","transform","take","duration","elapsed","rate","debounce","tally","rank","rankArray","average","sum","total","chunk","drop","event","fromFunction","AsyncToArray","asPromise","asValue","isDone","resolve","reverse","values","getOrGenerateSync","map","value","count","getErrorMessage","CircularArray","#capacity","#pointer","value","t","QueueMutable","length","mutable","peek","isEmpty","isFull","toString","compare","treeCompare","asDynamicTraversable","wrap","n","hasParent","hasAnyParent","hasChild","hasAnyChild","remove","addValue","add","depthFirst","breadthFirst","root","children","parents","findChildByValue","findAnyChildByValue","entries","childrenLength","toStringDeep","followValue","filter","isPrimitive","create","prettyPrint","getRoot","count","values","find","TreeNodeToTraversable","ObjectToTraversable","StackImmutable","immutable","SetStringImmutable","map","MassiveSet","#depth","#maxDepth","set","#getChild","#dumpToArray","priority","item","IterablesLast","IterablesMax","IterablesMin","QueueImmutable","#data","#maintain","interval","key","existing","isEqual","groupBy","without","del","data","#map","asArray","mapAddValue","mapFindValue","mapFilterValues","mapToArray","mapHasAnyValue","MapOfSimple","#getRowRaw","#getOrCreateRawRow","#getColumnRaw","createVertex","graph","toAdjacencyMatrix","dumpGraph","debugGraphToArray","vertices","adjacentVertices","resolveVertex","getOrCreate","updateGraphVertex","from","to","connectTo","weight","connect","connectWithEdges","edges","edges$1","stringForEdge","immutableMap","delay","resolve","timeout","debounce","#handlers","#counter","#id","run","event","average","distance","#lastUsersChange","#resourcesWithoutUserExpireAfterMs","#capacityPerResource","#users","#state","r","pi","#allocateResource","repeat","#maintainLoop","#outgoing","#requestCallback","#requestAwait","getErrorMessage","#resolve","#promise","#reject","#initPromise","TaskQueueMutable","duration","total","frequency","#written","next","first","debug","machineInit","machineReset","machineNext","machineTo","#debug","#sm","#smInitial","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt","total","randomIndex","array","randomElement","shuffle","resolve","max","min","count","offset","mti","float","integer","length","max$1","min$1","clamp","#store","#keyString","t","value","values","last","#min","#max","#total","#resetAfterSamples","#sampleLimit","#resetTimer","#fromTime","#events","event","pi","sqrt","abs","sum","point","bbox","intersections","cos","sin","reduce","a","b","c","d","v1","q","acos","PolyBezier","Bezier","ls","le","segments","tlen","alen","piPi","angleInDegrees: number | readonly number[]","angleInRadians: number","angleInRadians: number | readonly number[]","start: number","amount: number","piPi","start: number","end: number","piPi","p: Point","isNaN","guard","info?: string","pt: Point | Point3d","p: number | unknown","p: Point | unknown","isEmpty","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","b","a","a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>","b?: number | boolean","c?: number","distance","a: Point | Point3d","xOrB?: Point | Point3d | number","y?: number","z?: number","a: Point","xOrB?: Point | number","comparer: ((a: Point, b: Point) => Point)|((a: Point3d, b: Point3d) => Point3d)","min","topLeft: Point","topRight: Point","bottomRight: Point","bottomLeft: Point","bbox","RectsMaxFromCorners","a: Point3d","b: Point3d","p: unknown","p: Coord","rotate","c: Coord","amountRadian: number","invert","a: Coord","b: Coord","amountDeg: number","subtract","pt: Writeable<Point>","toLine","start: Point","toCartesian: PolarToCartesian","a: Coord | number","b?: Point | number","c?: Point","EmptyPoint","point: Point","origin: Point","point","subtractPoint","distance: number","angleRadians: number","guardPoint","toString","digits?: number","v: Coord","normalise","clampMagnitude","max","dotProduct","multiply","amt: number","divide","Placeholder","b?: Point","piPi","b: Point","c: Point","pt: Point","rounder: (x: number) => number","z: number","toCartesian","ray: PolarRay","origin?: Point","polarToCartesian","pointToString","line: Line","smoothness: number","zoom: number","step: number","fromPoints","isPositioned","p: Point | Arc | ArcPositioned","fromDegrees","radius: number","startDegrees: number","endDegrees: number","clockwise: boolean","a: Arc","ap: ArcPositioned","arc: ArcPositioned","LinesFromPoints","arc: ArcPositioned | Arc","arc: Arc | ArcPositioned","angleRadian: number","angleRadian","interpolate: ArcInterpolate","amount: number","allowOverflow?: boolean","arc: Arc","toPath","_point: Point","interpolate","length","toSvg","_intersectionThreshold: number","circle: CirclePositioned","startRadian: number","endRadian: number","a: ArcPositioned","sizeRadian: number","pointsBbox","toSvg: ArcToSvg","a: Point | Arc | ArcPositioned","b?: number | Point | ArcSvgOpts","c?: number | ArcSvgOpts","d?: number","e?: ArcSvgOpts","toSvgFull","opts?: ArcSvgOpts","distanceCenter","b: ArcPositioned","pointsDistance","isEqual","a: Arc | ArcPositioned","b: Arc | ArcPositioned","p: any","getPointParameter","aOrLine: Point | Line","aOrLine: Point | Line | PolyLine","pointBOrForce2d?: Point | boolean","force2d?: boolean","_force2d","sum","pointBOrAllowOverflow?: Point | boolean","fromA","d: number","rect: Rect","PointsGuard","rect: Rect | RectPositioned","rect: RectPositioned","isPlaceholder","rect: Point | Rect | RectPositioned","rect: unknown","rect: any","width: number","height: number","height","path: Path | QuadraticBezier | CubicBezier","path: Path | CubicBezier | QuadraticBezier","end: Point","LinesInterpolate","q: QuadraticBezier | CubicBezier","BezierLibrary","handle: Point","cubicOrQuadratic: CubicBezier | QuadraticBezier","cubic1: Point","cubic2: Point","cubic: CubicBezier","cubic","t: number","t","_: Point","RectsFromTopLeft","quadraticBezier: QuadraticBezier","quadratic","circle: CirclePositioned | Circle","guardPositioned","a: Circle | CirclePositioned","p: Circle | Point","area","circle: Circle","fromCenter","RectsFromCenter","a: CirclePositioned","b: CirclePositioned | Point","distanceFromExterior","PointsIsPoint","PointsDistance","nearest","circle: CirclePositioned | readonly CirclePositioned[]","circle: Circle | CirclePositioned","a: CirclePositioned | Circle","b: CirclePositioned | Circle","returnValue: Point[]","b: CirclePositioned","PointsSubtract","centroid","intersection","PointsSum","b: RectPositioned","circleIntersections","b: CirclePositioned | Point | RectPositioned","PointsIsEqual","multiplyScalar","v: number","value: number","PointsMultiplyScalar","value","randomPoint","within: Circle | CirclePositioned","opts: Partial<CircleRandomPointOpts>","offset: Point","offset","PolarToCartesian","toSvg: CircleToSvg","a: CirclePositioned | number | Circle","sweep: boolean","defaultPositionOrX?: Point | number","grid: Grid","cell: GridCell","cell: GridCell | undefined","grid?: Grid","wrap: GridBoundsLogic","wrap","access","array: readonly V[]","cols: number","array","fn: GridCellAccessor<V>","accessWithGrid","array: readonly T[] | T[]","setMutate","array: V[]","value: V","setMutateWithGrid","set","setWithGrid","wrapMutable","array: T[]","boundsLogic: GridBoundsLogic","value: T","initialValue: T","rowsOrGrid: number | Grid","columns?: number","rows","columns","t: T[]","total","create","array: ReadonlyArray<T[]> | Array<T[]>","array: V[][]","bounds: GridBoundsLogic","array: ReadonlyArray<T[]>","fn: GridCellAccessor<T>","array: T[][]","array: readonly V[][]","grid: GridReadable<T>","iter: Iterable<GridCell> | Iterable<GridCell[]>","start?: GridCell","rowCells: Array<GridCell>","colCells: Array<GridCell>","start: GridCell","vector: GridCell","steps: number","cells","cardinal: GridCardinalDirectionOptional","cardinal","end: GridCell","cells:GridCell[]","cells: Array<GridCell>","colsOrGrid: number | Grid","index: number","a: Grid | GridVisual","b: Grid | GridVisual","a: GridCell | undefined","b: GridCell | undefined","nbos: readonly GridNeighbour[]","randomElement","n: GridNeighbour | GridNeighbourMaybe | undefined","directions: readonly GridCardinalDirection[]","entries","directions?: readonly GridCardinalDirection[]","initialValue?: V","returnValue:V[][]","v: GridCell","grid: GridVisual","position: Point","neighbours: readonly GridNeighbour[]","neighbours","opts: Partial<GridVisitorOpts>","t: Array<GridNeighbour>","nbos: ReadonlyArray<GridNeighbour>","logic: GridNeighbourSelectionLogic","g: Grid","c: GridCell","cellQueue: GridCell[]","moveQueue: GridNeighbour[]","current: GridCell | undefined","createVisitor: GridCreateVisitor","steps: GridCell[]","count","type: VisitorTypes","options: Partial<GridVisitorOpts>","optionsOverride: Partial<GridVisitorOpts>","a: Point | number","b: number | Rect","line: Line | readonly Line[]","line","PointsBbox","a: Point3d | Point | number | number[]","b?: number","aa: Point3d | Point | number | number[]","bb?: number","cc?: number","PointDivide","fromNumbers","x1: number","y1: number","x2: number","y2: number","fromFlatArray","array: readonly number[]","length: number","balance: number","pointB?: Point","relativePosition","abs","apply","fn: Point3dApplyFn | PointApplyFn","kind: PointAverageKinds","opts: Partial<{ scaling: number }>","x: (v: number) => number","y: (v: number) => number","z: (v: number) => number","mal","clamp","clampNumber","compare","points: Array<Point>","v: Array<Point>","isIntersecting","a: RectPositioned","center","rect: RectPositioned | Rect","shape: PointCalculableShape","rectDistanceFromExterior","circleDistanceFromExterior","toArray","ArraysDotProduct","xOrArray?: number | readonly number[]","string_: string","pts: Point[]","lineInterpolate","what: `both` | `x` | `y` | `z`","ptOrX: Point | number","pipeline","pi","radians: number","angleNormalisation: `` | `unipolar` | `bipolar`","LinesGuard","v: Vector","PointsNormalise","PointEmpty","PointsToString","a: Vector","b: Vector","PointsDotProduct","PointsClampMagnitude","PointsMultiply","lines: Line[]","aa: Point | number","opts: TrackOpts","_reason: TrimReason","_p: TimestampedObject<Point>[]","initialRel: PointTrack","markRel: PointTrack | undefined","LineLength","lastRel: PointTrack","r: PointTrackerResults","LinesEmpty","PointsPlaceholder","id: string","p: PointerEvent | MouseEvent","asPoints","event","event: PointerEvent","position: Point | Point3d","waypointA: Point | Point3d","waypointB: Point | Point3d","angle: number","quantiseEvery","snap: Point","quantiseEveryNumber","random","rando?: RandomSource","reduce","pts: ReadonlyArray<Point>","fn: (p: Point, accumulated: Point) => Point","initial?: Point","pt: Point | readonly Point[]","PolarFromCartesian","PolarRotate","v: ReadonlyArray<ReadonlyArray<number>>","result:number[][]","round","yOrDigits?: number","roundNumber","withinRange","maxRange: Point | number","ptMax?: Point","ptMin?: Point","wrapNumber","amountRadian?: number","origin?: Point | number","PointRotate","a: Line","b: Line","a: Point | Line","toFlatArray","toSvgString","amount?: number","maxRange: number","otherLine: Line","fn: (point: Point) => Point","Empty","l: Line","PointIsEmpty","PointIsPlaceholder","fn: (p: Point) => Point","lineOrPoint: Line | Point","normaliseByRect","PointsNormaliseByRect","factor: number","x: number","lines: Iterable<Line>","corners","path: Path","compoundPath: CompoundPath","paths: readonly Path[]","useWidth?: boolean","dimensions?: Dimensions","relative","intersectionThreshold: number","lengths","RectsCorners","op: ApplyFieldOp","rectOrWidth: RectPositioned | Rect | number","heightValue?: number","op: ApplyMergeOp","a: RectPositioned | Rect","b: Rect | number","parameter: number","card: GridCardinalDirection | `center`","rectAbsolute: RectPositioned","a: number","b: number","edges","LinesJoinPointsToLines","edge: `right` | `bottom` | `left` | `top`","el: HTMLElement","xOrWidth: number","yOrHeight: number","width?: number","height?: number","a: number | Point | Rect | RectPositioned","b?: Rect | number | Point","c?: number | Rect","a: Rect","b: Rect","a: Rect | RectPositioned","b: Rect | RectPositioned","LinesLength","perimeter","value: number | Point","within: Rect | RectPositioned","options: RectRandomPointOpts","a: Rect | undefined","b: RectPositioned | Rect | number","b: RectPositioned | Rect","PointsProject","from: `tip` | `tail` | `middle`","opts: ArrowOpts","tri: Triangle","tailPoints: ReadonlyArray<Point>","from","arrow","PointsRotate","t: Triangle","PointsIsEmpty","PointsIsPlaceholder","a: Triangle","b: Triangle","PointsReduce","accumulator: Point","shape: ShapePositioned","opts: Partial<ShapeRandomPointOpts>","circleRandomPoint","rectRandomPoint","shape?: Rect | Triangle | Circle","rectCenter","triangleCentroid","circleCenter","a: ShapePositioned","b: ShapePositioned | Point","CirclesIsIntersecting","RectsIsIntersecting","outerRadius: number","innerRadius?: number","opts?: { readonly initialAngleRadian?: number }","waypoints: readonly Point[]","opts: Partial<WaypointOpts>","init","rank","circles: readonly Circle[]","container: ShapePositioned","opts: RandomOpts","positionedCircles: CirclePositioned[]","ShapesRandomPoint","radiusX: number","radiusY: number","epsilon","p1: Point","p2: Point","slope","index: Point","index_: Point","bounds: RectPositioned","initialData: readonly QuadTreeItem[]","opts: Partial<QuadTreeOpts>","o: QuadTreeOpts","QuadTreeNode","parent: QuadTreeNode | undefined","boundary: RectPositioned","level: number","opts: QuadTreeOpts","#parent","#children","n: QuadTreeNode | undefined","#items","d: Direction","p: QuadTreeItem","#subdivide","RectsIntersectsPoint","PointsFromNumbers","cos","sin","sqrt","pow","pi","piPi","circle?: Circle","opts: VogelSpiralOpts","circleToPositioned","max","count","circle?: Circle | CirclePositioned","opts: CircleRingsOpts","sphere?: Sphere","offset","t: Triangle","t","PointsAngleRadian","edges","area","lengths","LinesLength","a: Point | number","b?: number","x: number","y: number","pa: Point","pb: Point","bc: BarycentricCoord","r: RectPositioned","origin: Point","radius: number","opts: { readonly initialAngleRadian?: number }","PointGuard","angles","PolarToCartesian","coords: readonly number[]","PointsFromNumbers","points: readonly Point[]","perimeter","intersectsPoint","RectsIntersectsPoint","distance","fn: (p: Point, label?: string) => Point","rotate","triangle: Triangle","amountRadian?: number","origin?: Point","PointsRotate","amountRadian: number","vertex: `a` | `b` | `c`","t: TriangleEquilateral","fromCenter","rotationRad?: number","ptA?: Point","incircle","ptB?: Point","ptC?: Point","height","circumcircle","fromA","t: Right","fromB","fromC","medians","angleRad: number","adjacent: number","hypotenuse: number","angleRadian: number","angleRadian","opposite: number","t: Isosceles","centroid","sum","sortByNumericProperty","data: readonly V[] | V[]","propertyName: K","clamp","value: number","min","max","value","clamper","v: number","immutable","startingValueOrBipolar: number | BipolarWrapper","hint: string","amt: number","towardZero","clamp","b: number","max","min","toScalar","bipolarValue: number","numberScale","fromScalar","scalarValue: number","scale","inputValue: number","inMin: number","inMax: number","numberScaler","scaleUnclamped","amount: number","piPi","PiPi","scale","v: number","inMin: number","inMax: number","outMin?: number","outMax?: number","easing?: (v: number) => number","scaler","clamped?: boolean","clamper","numberArrayCompute","data: (number | undefined)[] | readonly (number | undefined)[]","opts: NumbersComputeOptions","total","min","max","count","value","max$1","min$1","streamWithContext","minDefault?: number","maxDefault?: number","v: number","scale","minDefault","maxDefault","stream","arrayWithContext","values: readonly number[]","minForced?: number","maxForced?: number","values","clamp","array","t","numberArrayCompute","centroid","sortByNumericProperty","point","point","values","last","set","t","from"]}