{"version":3,"file":"types-CcY4GIC4.d.ts","names":["ToString","V","StringOrNumber","Primitive","PrimitiveOrObject","BasicType","KeyValue","Interval","IDictionary","K","IWithEntries","IterableIterator","RankArrayOptions","RankOptions","RankFunction","T"],"sources":["../../core/dist/src/types.d.ts"],"sourcesContent":["export type ToString<V> = (itemToMakeStringFor: V) => string;\nexport type StringOrNumber = string | number | bigint;\nexport type Primitive = string | number | bigint | boolean;\nexport type PrimitiveOrObject = Primitive | object;\nexport type BasicType = StringOrNumber | object | boolean;\nexport type KeyValue = readonly [key: string, value: StringOrNumber];\n/**\n * Interval types allows for more expressive coding, rather than embedding millisecond values.\n *\n * That is, we can use `{ mins: 5 }` to mean 5 minutes rather than `5*60*1000`\n * or worse, 300000, for the same value.\n *\n * @example\n * ```js\n * { hours: 1 };  // 1 hour\n * { mins: 5 };   // 5 mins\n * { secs: 5 };   // 5 secs\n * { millis: 5 }; // 5 milliseconds\n * ```\n *\n * If several fields are used, this sums their value\n * ```js\n * { secs: 2, millis: 1 }; // equal 2001 milliseconds.\n * ```\n *\n * Wherever ixfx takes an `Interval`, you can also just provide a number instead.\n * This will be taken as a millisecond value.\n *\n * @see {@link intervalToMs} to convert to milliseconds.\n * @see {@link isInterval} check whether input is an Interval type\n * @see {@link elapsedToHumanString} render interval in human-friendly form\n */\nexport type Interval = number | {\n    readonly millis?: number;\n    readonly secs?: number;\n    readonly hours?: number;\n    readonly mins?: number;\n};\nexport type IDictionary<K, V> = {\n    get(key: K): V | undefined;\n    set(key: K, value: V): void;\n};\nexport type IWithEntries<K, V> = {\n    entries(): IterableIterator<readonly [K, V]>;\n};\nexport type RankArrayOptions = RankOptions & {\n    /**\n     * If _true_, it's only the highest _within_ an array that is considered,\n     * rather than tracking the higest between arrays\n     * Default: _false_\n     */\n    withinArrays?: boolean;\n};\n/**\n * A rank function that compares A and B.\n * Returns the highest value, 'a' or 'b'.\n * Returns 'eq' if values are equal\n */\nexport type RankFunction<T> = (a: T, b: T) => `a` | `b` | `eq`;\nexport type RankOptions = {\n    /**\n     * If set, only values with this JS type are included\n     */\n    includeType?: `string` | `number` | `object` | `boolean`;\n    /**\n     * If _true_, also emits values when they rank equal with current highest.\n     * _false_ by default\n     */\n    emitEqualRanked?: boolean;\n    /**\n     * If _true_, emits the current highest value even if it hasn't changed.\n     * This means it will match the tempo of the incoming stream.\n     */\n    emitRepeatHighest?: boolean;\n};\n//# sourceMappingURL=types.d.ts.map"],"mappings":";KAAYA,oCAAoCC;AAApCD,KACAE,cAAAA,GADqC,MAAA,GAAA,MAAA,GAAA,MAAA;AACrCA,KACAC,SAAAA,GADc,MAAA,GAAA,MAAA,GAAA,MAAA,GAAA,OAAA;AACdA,KACAC,iBAAAA,GAAoBD,SADX,GAAA,MAAA;AACTC,KACAC,SAAAA,GAAYH,cADQC,GAAAA,MAAS,GAAA,OAAA;AAC7BE,KACAC,QAAAA,GADS,SAAGJ,CAAAA,GAAAA,EAAAA,MAAc,EAAA,KAAA,EACeA,cADf,CAAA;AACtC;AA2BA;AAMA;;;;;;AAEwB;AAExB;;;;;AAC+B;AAE/B;AAaA;;;;AAAyC;AACzC;;;;;KA3BYK,QAAAA;;;;;;KAMAC;WACCC,IAAIR;WACJQ,UAAUR;;KAEXS;aACGC,2BAA2BF,GAAGR;;KAEjCW,gBAAAA,GAAmBC;;;;;;;;;;;;;KAanBC,sBAAsBC,MAAMA;KAC5BF,WAAAA"}