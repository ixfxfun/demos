{"version":3,"file":"index-D-YGqcwN.d.ts","names":["Point","Point3d","Placeholder","Readonly","Placeholder3d","Point","Point3d","abs","Point","angleRadian","angleRadianCircle","Point","Point3d","PointApplyFn","Point3dApplyFn","apply","Point","PointAverager","PointAverageKinds","averager","Partial","Point","Point3d","RectArray","RectPositionedArray","Rect","Rect3d","RectPositioned","Rect3dPositioned","Rect3dPositioned","RectPositioned","Point","Point3d","bbox","ReadonlyArray","bbox3d","Point","centroid","ReadonlyArray","Point","Point3d","clamp","Point","Point3d","compare","compareByX","compareByY","compareByZ","Point","convexHull","ReadonlyArray","Point","distance","Point","Circle","CircleToSvg","CirclePositioned","CircleRandomPointOpts","Point","Line","PolyLine","ReadonlyArray","CirclePositioned","Line","PolyLine","Point","Point3d","RectPositioned","ShapePositioned","ContainsResult","Sphere","PointCalculableShape","Point","ArrowOpts","arrow","ReadonlyArray","Point","Triangle","BarycentricCoord","RandomSource","ShapePositioned","Point","Rect","Triangle","Circle","ShapeRandomPointOpts","randomPoint","Partial","center","Point","ShapePositioned","isIntersecting","Point","starburst","Point","PointCalculableShape","distanceToCenter","Point","PointCalculableShape","distanceToExterior","Point","Point3d","divide","divider","Point","dotProduct","Empty","Unit","Empty3d","Unit3d","Point","Point3d","findMinimum","ReadonlyArray","Point","Point3d","from","fromString","fromNumbers","Point","Point3d","getTwoPointParameters","getPointParameter","Array","ReadonlyArray","Point","Point3d","isNull","isNaN","guard","guardNonZeroPoint","isPoint","isPoint3d","isEmpty","isPlaceholder","Point","interpolate","Point","Point3d","invert","Point","isEqual","ReadonlyArray","Point","clampMagnitude","Point","leftmost","ReadonlyArray","rightmost","Point","Point3d","multiply","multiplyScalar","Point","normalise","Rect","Point","normaliseByRect","Point","pipelineApply","ReadonlyArray","pipeline","Point","PointRelation","PointRelationResult","Point","PolarToCartesian","Coord","PolarRay","Readonly","PolarRayWithOrigin","Coord","rotate","invert","isOpposite","isParallel","isAntiParallel","rotateDegrees","Point","Coord","PolarToCartesian","toLine","toCartesian","fromCartesian","toString","toPoint","Coord","isPolarCoord","guard","Coord","normalise","clampMagnitude","dotProduct","multiply","divide","Line","Point","PolarRay","toCartesian","toString","fromLine","Coord","spiral","IterableIterator","spiralRaw","Ray","TrackedValueMap","TrackedValueOpts","TrackOpts","TimestampedObject","ObjectTracker","Coord","PolarCoord","Line","PolyLine","Point","Point3d","PointRelation","TrimReason","PointRelationResult","PointTrack","PointTrackerResults","Readonly","PointTracker","PointerEvent","MouseEvent","PointsTracker","Promise","Point3d","Point","progressBetween","Point","project","Point","Point3d","quantiseEvery","RandomSource","Point","Point3d","random","random3d","Point","reduce","ReadonlyArray","PointRelation","Point","relation","Point","rotate","rotatePointArray","ReadonlyArray","Array","Point","round","Point","Point3d","subtract","Point","Point3d","sum","Point","Point3d","toIntegerValues","to2d","to3d","toString","Point","toArray","ReadonlyArray","Point","withinRange","Point","wrap","Point","Point3d","Rect","area","RectPositioned","Rect","ApplyMergeOp","ApplyFieldOp","applyFields","applyMerge","applyScalar","applyDim","ISetMutable","GridVisual","Grid","GridCell","GridNeighbours","GridCardinalDirection","GridCardinalDirectionOptional","GridArray1d","T","GridReadable","GridWritable","GridBoundsLogic","GridNeighbourSelectionLogic","GridIdentifyNeighbours","GridNeighbourSelector","GridVisitorOpts","Readonly","GridCreateVisitor","Partial","Generator","GridCellAndValue","GridNeighbourMaybe","GridNeighbour","GridCellAccessor","TValue","GridCellSetter","GridBoundsLogic","GridCell","Grid","applyBounds","GridCellAccessor","GridCell","GridBoundsLogic","Grid","GridCellSetter","GridArray1d","access","V","setMutate","set","wrapMutable","T","wrap","createArray","createMutable","GridBoundsLogic","GridCell","GridCellAccessor","GridCellSetter","Grid","GridReadable","GridWritable","ArrayGrid","T","create","ReadonlyArray","Array","setMutate","V","access","wrapMutable","set","wrap","GridCell","Grid","rows","Generator","columns","GridBoundsLogic","GridCardinalDirection","GridCardinalDirectionOptional","GridCell","Grid","GridNeighbours","allDirections","crossDirections","offsetCardinals","getVectorFromCardinal","Grid","GridCell","GridCellAndValue","GridReadable","cells","Generator","cellValues","T","cellsAndValues","GridCell","getLine","ReadonlyArray","simpleLine","GridCell","Grid","isCell","guardCell","guardGrid","Grid","GridCell","GridBoundsLogic","indexFromCell","cellFromIndex","Grid","GridCell","inside","GridCell","Grid","GridVisual","isEqual","cellEquals","GridBoundsLogic","GridCardinalDirection","GridCell","Grid","GridNeighbour","GridNeighbours","randomNeighbour","neighbourList","neighbours","Grid","GridCell","GridBoundsLogic","offset","Grid","toArray2d","V","GridCell","cellKeyString","RectPositioned","GridCell","GridVisual","Point","asRectangles","IterableIterator","cellAtPoint","rectangleForCell","cellMiddle","GridReadable","GridCell","values","T","Iterable","Generator","GridNeighbourSelectionLogic","breadthLogic","GridNeighbourSelectionLogic","neighboursLogic","GridNeighbourSelectionLogic","GridVisitorOpts","columnLogic","Partial","GridNeighbourSelectionLogic","depthLogic","Grid","GridCell","GridCreateVisitor","stepper","GridNeighbourSelectionLogic","randomLogic","GridNeighbourSelectionLogic","randomContiguousLogic","GridNeighbourSelectionLogic","GridVisitorOpts","rowLogic","Partial","GridNeighbourSelectionLogic","Grid","GridCell","GridVisitorOpts","visitByNeighbours","Partial","Generator","GridCell","Grid","GridNeighbourSelectionLogic","GridVisitorOpts","VisitorTypes","create","Partial","Generator","withLogic","Array1d","Array2d","As","By","Visit","RectPositioned","GridCardinalDirection","Point","cardinal","Point","RectPositioned","centerOrigin","Point","Rect","RectPositioned","center","Point","Rect","RectPositioned","corners","RectPositioned","Point","distanceFromExterior","distanceFromCenter","RectPositioned","Rect","divide","divideScalar","divideDim","Rect","RectPositioned","Point","Line","edges","getEdgeX","getEdgeY","Empty","Readonly","EmptyPositioned","Point","RectPositioned","encompass","RectPositioned","Point","fromCenter","Rect","fromElement","HTMLElement","RectPositioned","Rect","fromNumbers","Point","RectPositioned","fromTopLeft","Point","Rect","RectPositioned","getRectPositionedParameter","RectPositioned","Rect","Point","guardDim","guard","getRectPositioned","guardPositioned","isEmpty","isPlaceholder","isPositioned","isRect","isRectPositioned","Rect","RectPositioned","Point","CirclePositioned","intersectsPoint","isIntersecting","Rect","RectPositioned","isEqualSize","isEqual","RectPositioned","lengths","Point","RectPositioned","maxFromCorners","RectPositioned","Rect","multiply","multiplyScalar","multiplyDim","Point","RectPositioned","nearestInternal","Placeholder","Readonly","PlaceholderPositioned","Rect","perimeter","Point","Rect","dividerByLargestDimension","Readonly","RandomSource","Point","Rect","RectPositioned","random","RectRandomPointOpts","randomPoint","Rect","RectPositioned","subtract","subtractSize","subtractOffset","Rect","RectPositioned","sum","sumOffset","Rect","RectArray","RectPositioned","RectPositionedArray","toArray","Point","RectPositioned","Path","ReadonlyArray","WithBeziers","CompoundPath","Dimensions","Point","Arc","ArcPositioned","ArcInterpolate","ArcToSvg","ArcSvgOpts","Point","Line","Path","Rect","RectPositioned","Arc","ArcInterpolate","ArcPositioned","ArcToSvg","CirclePositioned","isArc","isPositioned","fromDegrees","toLine","getStartEnd","point","guard","interpolate","angularSize","toPath","fromCircle","fromCircleAmount","length","bbox","toSvg","distanceCenter","isEqual","Path","Point","QuadraticBezier","QuadraticBezierPath","CubicBezier","CubicBezierPath","Path","QuadraticBezier","CubicBezier","isQuadraticBezier","isCubicBezier","Point","CubicBezier","CubicBezierPath","QuadraticBezier","QuadraticBezierPath","quadraticSimple","interpolator","quadraticToSvgString","ReadonlyArray","toPath","cubic","quadratic","Circle","area","CirclePositioned","Circle","RectPositioned","bbox","CirclePositioned","Circle","center","Readonly","Point","CompoundPath","Dimensions","Path","RectPositioned","setSegment","interpolate","distanceToPoint","relativePosition","computeDimensions","bbox","toString","guardContinuous","toSvgString","fromPaths","Point","Path","getStart","getEnd","Path","Circle","CircularPath","CirclePositioned","Point","distanceCenter","CirclePositioned","Point","distanceFromExterior","Point","CirclePositioned","exteriorIntegerPoints","IterableIterator","Point","Circle","CirclePositioned","guard","guardPositioned","isNaN","isPositioned","isCircle","isCirclePositioned","CirclePositioned","Point","interiorIntegerPoints","IterableIterator","Point","CirclePositioned","interpolate","CirclePositioned","Point","RectPositioned","isIntersecting","Point","CirclePositioned","Line","intersectionLine","intersections","CirclePositioned","Point","isContainedBy","Circle","CirclePositioned","isEqual","CirclePositioned","Circle","multiplyScalar","Point","Circle","CirclePositioned","nearest","pointOnPerimeter","circumference","length","Point","Circle","CirclePositioned","CircleRandomPointOpts","randomPoint","Partial","CircleToSvg","toSvg","CirclePositioned","CircularPath","toPath","Circle","CirclePositioned","Point","toPositioned","Line","parallel","perpendicularPoint","RectPositioned","Line","bbox","Point","Line","distanceSingleLine","Point","Line","divide","Line","fromFlatArray","Line","fromNumbers","Point","Line","fromPoints","Point","fromPivot","Readonly","Path","Point","Line","LinePath","ReadonlyArray","Point","LinePath","fromPointsToPath","Point","Line","getPointParameter","Line","PolyLine","isLine","isPolyLine","guard","Point","Line","interpolate","pointAtDistance","Line","isEqual","Point","PolyLine","joinPointsToLines","Point","Line","PolyLine","length","Point","Line","midpoint","Line","Point","multiply","Point","Line","nearest","Point","Line","relativePosition","Line","reverse","Point","Line","rotate","Point","Line","subtract","Point","Line","sum","LinePath","Line","toPath","Point","Line","toString","Point","Line","Empty","Readonly","Placeholder","isEmpty","isPlaceholder","apply","angleRadian","normaliseByRect","withinRange","slope","scaleFromMidpoint","pointAtX","extendFromA","pointsOf","Generator","distance","toFlatArray","asPoints","Iterable","toSvgString","CirclePositioned","Path","Point","Waypoint","WaypointOpts","fromPoints","Partial","Waypoints","WaypointResult","init","RandomSource","ShapePositioned","Circle","CirclePositioned","RandomOpts","random","CirclePacking","Point","Path","Ellipse","EllipsePositioned","fromDegrees","EllipticalPath","Point","degreeToRadian","radianInvert","degreeToGradian","gradianToDegree","radianToGradian","gradianToRadian","radianToDegree","radiansFromAxisX","radiansSum","degreesSum","radianArc","degreeArc","Angle","angleParse","angleConvert","turnToDegree","turnToRadian","degreeToTurn","radianToTurn","Point","rdpShortestDistance","Array","rdpPerpendicularDistance","TraversableTree","Point","ShapePositioned","RectPositioned","QuadTreeOpts","Direction","QuadTreeItem","quadTree","Partial","QuadTreeNode","IterableIterator","Point","Rect","Scaler","ScalerCombined","ScaleBy","scaler","Line","Point","Polar","Vector","Coord","fromRadians","Readonly","toRadians","fromPointPolar","fromLineCartesian","fromLinePolar","normalise","quadrantOffsetAngle","toPolar","toCartesian","toString","dotProduct","clampMagnitude","sum","subtract","multiply","divide","Point","Point3d","Circle","CirclePositioned","Sphere","VogelSpiralOpts","circleVogelSpiral","IterableIterator","CircleRingsOpts","circleRings","sphereFibonacci","Triangle","angles","ReadonlyArray","anglesDegrees","Triangle","area","Point","BarycentricCoord","Triangle","barycentricCoord","barycentricToCartestian","RectPositioned","Triangle","bbox","Point","Triangle","centroid","Point","Triangle","corners","ReadonlyArray","Point","Triangle","Empty","Readonly","Placeholder","equilateralFromVertex","Triangle","PolyLine","edges","Triangle","Point","fromRadius","fromFlatArray","fromPoints","CirclePositioned","Triangle","innerCircle","Point","Triangle","intersectsPoint","Triangle","isEquilateral","isIsosceles","isRightAngle","isOblique","isAcute","isObtuse","Triangle","lengths","ReadonlyArray","Point","Triangle","apply","Readonly","Triangle","CirclePositioned","outerCircle","Triangle","perimeter","Point","Triangle","rotate","rotateByVertex","Triangle","toFlatArray","Triangle","guard","isTriangle","isEmpty","isPlaceholder","isEqual","Circle","Point","Triangle","TriangleEquilateral","fromCenter","centerFromA","centerFromB","centerFromC","height","perimeter","area","circumcircle","incircle","Circle","Point","Triangle","Right","DefinedRight","fromA","fromB","fromC","resolveLengths","height","hypotenuseSegments","perimeter","area","angleAtPointA","angleAtPointB","medians","circumcircle","incircle","oppositeFromAdjacent","oppositeFromHypotenuse","adjacentFromHypotenuse","adjacentFromOpposite","hypotenuseFromOpposite","hypotenuseFromAdjacent","Circle","Point","Triangle","Isosceles","baseAngle","apexAngle","height","legHeights","perimeter","area","circumcircle","incircle","medians","fromCenter","fromA","fromB","fromC","Equilateral","Right","Isosceles","Arcs","Beziers","Circles","Grids","Lines","Paths","Points","Polar","Rects","Shapes","Waypoints","Layouts","Compound","Ellipses","CurveSimplification","QuadTree","Vectors","SurfacePoints","Triangles"],"sources":["../../geometry/dist/src/point/point-type.d.ts","../../geometry/dist/src/point/abs.d.ts","../../geometry/dist/src/point/angle.d.ts","../../geometry/dist/src/point/apply.d.ts","../../geometry/dist/src/point/averager.d.ts","../../geometry/dist/src/rect/rect-types.d.ts","../../geometry/dist/src/point/bbox.d.ts","../../geometry/dist/src/point/centroid.d.ts","../../geometry/dist/src/point/clamp.d.ts","../../geometry/dist/src/point/compare.d.ts","../../geometry/dist/src/point/convex-hull.d.ts","../../geometry/dist/src/point/distance.d.ts","../../geometry/dist/src/circle/circle-type.d.ts","../../geometry/dist/src/line/line-type.d.ts","../../geometry/dist/src/shape/shape-type.d.ts","../../geometry/dist/src/shape/arrow.d.ts","../../geometry/dist/src/triangle/triangle-type.d.ts","../../geometry/dist/src/shape/etc.d.ts","../../geometry/dist/src/shape/is-intersecting.d.ts","../../geometry/dist/src/shape/starburst.d.ts","../../geometry/dist/src/shape/index.d.ts","../../geometry/dist/src/point/distance-to-center.d.ts","../../geometry/dist/src/point/distance-to-exterior.d.ts","../../geometry/dist/src/point/divider.d.ts","../../geometry/dist/src/point/dot-product.d.ts","../../geometry/dist/src/point/empty.d.ts","../../geometry/dist/src/point/find-minimum.d.ts","../../geometry/dist/src/point/from.d.ts","../../geometry/dist/src/point/get-point-parameter.d.ts","../../geometry/dist/src/point/guard.d.ts","../../geometry/dist/src/point/interpolate.d.ts","../../geometry/dist/src/point/invert.d.ts","../../geometry/dist/src/point/is-equal.d.ts","../../geometry/dist/src/point/magnitude.d.ts","../../geometry/dist/src/point/most.d.ts","../../geometry/dist/src/point/multiply.d.ts","../../geometry/dist/src/point/normalise.d.ts","../../geometry/dist/src/point/normalise-by-rect.d.ts","../../geometry/dist/src/point/pipeline.d.ts","../../geometry/dist/src/point/point-relation-types.d.ts","../../geometry/dist/src/polar/types.d.ts","../../geometry/dist/src/polar/angles.d.ts","../../geometry/dist/src/polar/conversions.d.ts","../../geometry/dist/src/polar/guard.d.ts","../../geometry/dist/src/polar/math.d.ts","../../geometry/dist/src/polar/ray.d.ts","../../geometry/dist/src/polar/spiral.d.ts","../../geometry/dist/src/polar/index.d.ts","../../geometry/dist/src/point/point-tracker.d.ts","../../geometry/dist/src/point/progress-between.d.ts","../../geometry/dist/src/point/project.d.ts","../../geometry/dist/src/point/quantise.d.ts","../../geometry/dist/src/point/random.d.ts","../../geometry/dist/src/point/reduce.d.ts","../../geometry/dist/src/point/relation.d.ts","../../geometry/dist/src/point/rotate.d.ts","../../geometry/dist/src/point/rotate-point-array.d.ts","../../geometry/dist/src/point/round.d.ts","../../geometry/dist/src/point/subtract.d.ts","../../geometry/dist/src/point/sum.d.ts","../../geometry/dist/src/point/To.d.ts","../../geometry/dist/src/point/to-array.d.ts","../../geometry/dist/src/point/within-range.d.ts","../../geometry/dist/src/point/wrap.d.ts","../../geometry/dist/src/point/index.d.ts","../../geometry/dist/src/rect/area.d.ts","../../geometry/dist/src/rect/apply.d.ts","../../geometry/dist/src/grid/types.d.ts","../../geometry/dist/src/grid/apply-bounds.d.ts","../../geometry/dist/src/grid/array-1d.d.ts","../../geometry/dist/src/grid/array-2d.d.ts","../../geometry/dist/src/grid/as.d.ts","../../geometry/dist/src/grid/directions.d.ts","../../geometry/dist/src/grid/enumerators/cells.d.ts","../../geometry/dist/src/grid/enumerators/index.d.ts","../../geometry/dist/src/grid/geometry.d.ts","../../geometry/dist/src/grid/guards.d.ts","../../geometry/dist/src/grid/indexing.d.ts","../../geometry/dist/src/grid/inside.d.ts","../../geometry/dist/src/grid/is-equal.d.ts","../../geometry/dist/src/grid/neighbour.d.ts","../../geometry/dist/src/grid/offset.d.ts","../../geometry/dist/src/grid/to-array.d.ts","../../geometry/dist/src/grid/to-string.d.ts","../../geometry/dist/src/grid/visual.d.ts","../../geometry/dist/src/grid/values.d.ts","../../geometry/dist/src/grid/visitors/breadth.d.ts","../../geometry/dist/src/grid/visitors/cell-neighbours.d.ts","../../geometry/dist/src/grid/visitors/columns.d.ts","../../geometry/dist/src/grid/visitors/depth.d.ts","../../geometry/dist/src/grid/visitors/step.d.ts","../../geometry/dist/src/grid/visitors/random.d.ts","../../geometry/dist/src/grid/visitors/random-contiguous.d.ts","../../geometry/dist/src/grid/visitors/rows.d.ts","../../geometry/dist/src/grid/visitors/visitor.d.ts","../../geometry/dist/src/grid/visitors/index.d.ts","../../geometry/dist/src/grid/index.d.ts","../../geometry/dist/src/rect/cardinal.d.ts","../../geometry/dist/src/rect/center-origin.d.ts","../../geometry/dist/src/rect/center.d.ts","../../geometry/dist/src/rect/corners.d.ts","../../geometry/dist/src/rect/distance.d.ts","../../geometry/dist/src/rect/divide.d.ts","../../geometry/dist/src/rect/edges.d.ts","../../geometry/dist/src/rect/empty.d.ts","../../geometry/dist/src/rect/encompass.d.ts","../../geometry/dist/src/rect/from-center.d.ts","../../geometry/dist/src/rect/from-element.d.ts","../../geometry/dist/src/rect/from-numbers.d.ts","../../geometry/dist/src/rect/from-top-left.d.ts","../../geometry/dist/src/rect/get-rect-positionedparameter.d.ts","../../geometry/dist/src/rect/guard.d.ts","../../geometry/dist/src/rect/Intersects.d.ts","../../geometry/dist/src/rect/is-equal.d.ts","../../geometry/dist/src/rect/lengths.d.ts","../../geometry/dist/src/rect/max.d.ts","../../geometry/dist/src/rect/multiply.d.ts","../../geometry/dist/src/rect/nearest.d.ts","../../geometry/dist/src/rect/placeholder.d.ts","../../geometry/dist/src/rect/perimeter.d.ts","../../geometry/dist/src/rect/normalise-by-rect.d.ts","../../geometry/dist/src/rect/random.d.ts","../../geometry/dist/src/rect/subtract.d.ts","../../geometry/dist/src/rect/sum.d.ts","../../geometry/dist/src/rect/to-array.d.ts","../../geometry/dist/src/rect/index.d.ts","../../geometry/dist/src/path/path-type.d.ts","../../geometry/dist/src/arc/arc-type.d.ts","../../geometry/dist/src/arc/index.d.ts","../../geometry/dist/src/bezier/bezier-type.d.ts","../../geometry/dist/src/bezier/guard.d.ts","../../geometry/dist/src/bezier/index.d.ts","../../geometry/dist/src/circle/area.d.ts","../../geometry/dist/src/circle/bbox.d.ts","../../geometry/dist/src/circle/center.d.ts","../../geometry/dist/src/path/compound-path.d.ts","../../geometry/dist/src/path/start-end.d.ts","../../geometry/dist/src/path/index.d.ts","../../geometry/dist/src/circle/circular-path.d.ts","../../geometry/dist/src/circle/distance-center.d.ts","../../geometry/dist/src/circle/distance-from-exterior.d.ts","../../geometry/dist/src/circle/exterior-points.d.ts","../../geometry/dist/src/circle/guard.d.ts","../../geometry/dist/src/circle/interior-points.d.ts","../../geometry/dist/src/circle/interpolate.d.ts","../../geometry/dist/src/circle/intersecting.d.ts","../../geometry/dist/src/circle/intersections.d.ts","../../geometry/dist/src/circle/is-contained-by.d.ts","../../geometry/dist/src/circle/is-equal.d.ts","../../geometry/dist/src/circle/multiply.d.ts","../../geometry/dist/src/circle/perimeter.d.ts","../../geometry/dist/src/circle/random.d.ts","../../geometry/dist/src/circle/svg.d.ts","../../geometry/dist/src/circle/to-path.d.ts","../../geometry/dist/src/circle/to-positioned.d.ts","../../geometry/dist/src/circle/index.d.ts","../../geometry/dist/src/line/angles.d.ts","../../geometry/dist/src/line/bbox.d.ts","../../geometry/dist/src/line/distance-single-line.d.ts","../../geometry/dist/src/line/divide.d.ts","../../geometry/dist/src/line/from-flat-array.d.ts","../../geometry/dist/src/line/from-numbers.d.ts","../../geometry/dist/src/line/from-points.d.ts","../../geometry/dist/src/line/from-pivot.d.ts","../../geometry/dist/src/line/line-path-type.d.ts","../../geometry/dist/src/line/from-points-to-path.d.ts","../../geometry/dist/src/line/get-points-parameter.d.ts","../../geometry/dist/src/line/guard.d.ts","../../geometry/dist/src/line/interpolate.d.ts","../../geometry/dist/src/line/is-equal.d.ts","../../geometry/dist/src/line/join-points-to-lines.d.ts","../../geometry/dist/src/line/length.d.ts","../../geometry/dist/src/line/midpoint.d.ts","../../geometry/dist/src/line/multiply.d.ts","../../geometry/dist/src/line/nearest.d.ts","../../geometry/dist/src/line/relative-position.d.ts","../../geometry/dist/src/line/reverse.d.ts","../../geometry/dist/src/line/rotate.d.ts","../../geometry/dist/src/line/subtract.d.ts","../../geometry/dist/src/line/sum.d.ts","../../geometry/dist/src/line/to-path.d.ts","../../geometry/dist/src/line/to-string.d.ts","../../geometry/dist/src/line/index.d.ts","../../geometry/dist/src/waypoint.d.ts","../../geometry/dist/src/circle-packing.d.ts","../../geometry/dist/src/layout.d.ts","../../geometry/dist/src/ellipse.d.ts","../../geometry/dist/src/angles.d.ts","../../geometry/dist/src/curve-simplification.d.ts","../../geometry/dist/src/quad-tree.d.ts","../../geometry/dist/src/scaler.d.ts","../../geometry/dist/src/vector.d.ts","../../geometry/dist/src/surface-points.d.ts","../../geometry/dist/src/triangle/angles.d.ts","../../geometry/dist/src/triangle/area.d.ts","../../geometry/dist/src/triangle/barycentric.d.ts","../../geometry/dist/src/triangle/bbox.d.ts","../../geometry/dist/src/triangle/centroid.d.ts","../../geometry/dist/src/triangle/corners.d.ts","../../geometry/dist/src/triangle/create.d.ts","../../geometry/dist/src/triangle/edges.d.ts","../../geometry/dist/src/triangle/from.d.ts","../../geometry/dist/src/triangle/inner-circle.d.ts","../../geometry/dist/src/triangle/intersects.d.ts","../../geometry/dist/src/triangle/kinds.d.ts","../../geometry/dist/src/triangle/lengths.d.ts","../../geometry/dist/src/triangle/math.d.ts","../../geometry/dist/src/triangle/outer-circle.d.ts","../../geometry/dist/src/triangle/perimeter.d.ts","../../geometry/dist/src/triangle/rotate.d.ts","../../geometry/dist/src/triangle/to.d.ts","../../geometry/dist/src/triangle/guard.d.ts","../../geometry/dist/src/triangle/equilateral.d.ts","../../geometry/dist/src/triangle/right.d.ts","../../geometry/dist/src/triangle/isosceles.d.ts","../../geometry/dist/src/triangle/index.d.ts","../../geometry/dist/src/index.d.ts"],"sourcesContent":["/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n    readonly x: number;\n    readonly y: number;\n    readonly z?: number;\n};\nexport type Point3d = Point & {\n    readonly z: number;\n};\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\nexport declare const Placeholder: Readonly<{\n    x: number;\n    y: number;\n}>;\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport declare const Placeholder3d: Readonly<{\n    x: number;\n    y: number;\n    z: number;\n}>;\n//# sourceMappingURL=point-type.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function abs(pt: Point3d): Point3d;\nexport declare function abs(pt: Point): Point;\n//# sourceMappingURL=abs.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n *\n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadian: (a: Point, b?: Point, c?: Point) => number;\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadianCircle: (a: Point, b?: Point, c?: Point) => number;\n//# sourceMappingURL=angle.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\nexport declare function apply(pt: Point3d, fn: Point3dApplyFn): Point3d;\nexport declare function apply(pt: Point, fn: PointApplyFn): Point;\n//# sourceMappingURL=apply.d.ts.map","import type { Point } from \"./point-type.js\";\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n/**\n * Uses =@ixfx/numbers#movingAverageLight to keep track of\n * average x, y and z values.\n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n *\n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns\n */\nexport declare function averager(kind: `moving-average-light`, opts: Partial<{\n    scaling: number;\n}>): PointAverager;\n//# sourceMappingURL=averager.d.ts.map","import type { Point, Point3d } from \"../point/point-type.js\";\n/**\n * Rectangle as array: `[width, height]`\n */\nexport type RectArray = readonly [width: number, height: number];\n/**\n * Positioned rectangle as array: `[x, y, width, height]`\n */\nexport type RectPositionedArray = readonly [\n    x: number,\n    y: number,\n    width: number,\n    height: number\n];\nexport type Rect = {\n    readonly width: number;\n    readonly height: number;\n};\nexport type Rect3d = Rect & {\n    readonly depth: number;\n};\nexport type RectPositioned = Point & Rect;\nexport type Rect3dPositioned = Point3d & Rect3d;\n//# sourceMappingURL=rect-types.d.ts.map","import type { Rect3dPositioned, RectPositioned } from \"../rect/rect-types.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport declare const bbox: (...points: ReadonlyArray<Point>) => RectPositioned;\nexport declare const bbox3d: (...points: ReadonlyArray<Point3d>) => Rect3dPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport declare const centroid: (...points: ReadonlyArray<Point | undefined>) => Point;\n//# sourceMappingURL=centroid.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function clamp(a: Point, min?: number, max?: number): Point;\nexport declare function clamp(a: Point3d, min?: number, max?: number): Point3d;\n//# sourceMappingURL=clamp.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport declare const compare: (a: Point, b: Point) => number;\n/**\n * Compares points based on x value. Y value is ignored.\n *\n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n *\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByX: (a: Point, b: Point) => number;\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByY: (a: Point, b: Point) => number;\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByZ: (a: Point3d, b: Point3d) => number;\n//# sourceMappingURL=compare.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport declare const convexHull: (...pts: ReadonlyArray<Point>) => ReadonlyArray<Point>;\n//# sourceMappingURL=convex-hull.d.ts.map","import type { Point } from './point-type.js';\nexport declare function distance(a: Point, b?: Point): number;\nexport declare function distance(a: Point, x: number, y: number): number;\n//# sourceMappingURL=distance.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * A circle\n */\nexport type Circle = {\n    readonly radius: number;\n};\nexport type CircleToSvg = {\n    (circleOrRadius: Circle | number, sweep: boolean, origin: Point): readonly string[];\n    (circle: CirclePositioned, sweep: boolean): readonly string[];\n};\n/**\n * A {@link Circle} with position\n */\nexport type CirclePositioned = Point & Circle;\nexport type CircleRandomPointOpts = {\n    /**\n     * Algorithm to calculate random values.\n     * Default: 'uniform'\n     */\n    readonly strategy: `naive` | `uniform`;\n    /**\n     * Random number source.\n     * Default: Math.random\n     */\n    readonly randomSource: () => number;\n    /**\n     * Margin within shape to start generating random points\n     * Default: 0\n     */\n    readonly margin: number;\n};\n//# sourceMappingURL=circle-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * A line, which consists of an `a` and `b` {@link Point}.\n */\nexport type Line = {\n    readonly a: Point;\n    readonly b: Point;\n};\n/**\n * A PolyLine, consisting of more than one line.\n */\nexport type PolyLine = ReadonlyArray<Line>;\n//# sourceMappingURL=line-type.d.ts.map","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport type { Line, PolyLine } from \"../line/line-type.js\";\nimport type { Point, Point3d } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\nexport type ShapePositioned = CirclePositioned | RectPositioned;\nexport type ContainsResult = `none` | `contained`;\nexport type Sphere = Point3d & {\n    readonly radius: number;\n};\nexport type PointCalculableShape = PolyLine | Line | RectPositioned | Point | CirclePositioned;\n//# sourceMappingURL=shape-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\nexport type ArrowOpts = {\n    readonly arrowSize?: number;\n    readonly tailLength?: number;\n    readonly tailThickness?: number;\n    readonly angleRadian?: number;\n};\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport declare const arrow: (origin: Point, from: `tip` | `tail` | `middle`, opts?: ArrowOpts) => ReadonlyArray<Point>;\n//# sourceMappingURL=arrow.d.ts.map","import type { Point } from \"../point/point-type.js\";\nexport type Triangle = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly c: Point;\n};\nexport type BarycentricCoord = {\n    readonly a: number;\n    readonly b: number;\n    readonly c: number;\n};\n//# sourceMappingURL=triangle-type.d.ts.map","import type { RandomSource } from \"@ixfx/random\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport type { Circle } from \"../circle/circle-type.js\";\nexport type ShapeRandomPointOpts = {\n    readonly randomSource: RandomSource;\n};\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * @param shape\n * @param opts\n * @returns\n */\nexport declare const randomPoint: (shape: ShapePositioned, opts?: Partial<ShapeRandomPointOpts>) => Point;\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport declare const center: (shape?: Rect | Triangle | Circle) => Point;\n//# sourceMappingURL=etc.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { ShapePositioned } from \"./shape-type.js\";\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport declare const isIntersecting: (a: ShapePositioned, b: ShapePositioned | Point) => boolean;\n//# sourceMappingURL=is-intersecting.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport declare const starburst: (outerRadius: number, points?: number, innerRadius?: number, origin?: Point, opts?: {\n    readonly initialAngleRadian?: number;\n}) => readonly Point[];\n//# sourceMappingURL=starburst.d.ts.map","export type * from './shape-type.js';\nexport * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';\n//# sourceMappingURL=index.d.ts.map","import type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport declare const distanceToCenter: (a: Point, shape: PointCalculableShape) => number;\n//# sourceMappingURL=distance-to-center.d.ts.map","import type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/shape-type.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport declare const distanceToExterior: (a: Point, shape: PointCalculableShape) => number;\n//# sourceMappingURL=distance-to-exterior.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function divide(a: Point, b: Point): Point;\nexport declare function divide(a: Point3d, b: Point3d): Point3d;\nexport declare function divide(a: Point, x: number, y: number): Point;\nexport declare function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\nexport declare function divider(a: Point3d | Point | number | number[], b?: number, c?: number): (aa: Point3d | Point | number | number[], bb?: number, cc?: number) => Point;\n//# sourceMappingURL=divider.d.ts.map","import type { Point } from './point-type.js';\nexport declare const dotProduct: (...pts: readonly Point[]) => number;\n//# sourceMappingURL=dot-product.d.ts.map","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport declare const Empty: {\n    readonly x: 0;\n    readonly y: 0;\n};\n/**\n * Returns { x:1, y:1 }\n */\nexport declare const Unit: {\n    readonly x: 1;\n    readonly y: 1;\n};\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport declare const Empty3d: {\n    readonly x: 0;\n    readonly y: 0;\n    readonly z: 0;\n};\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport declare const Unit3d: {\n    readonly x: 1;\n    readonly y: 1;\n    readonly z: 1;\n};\n//# sourceMappingURL=empty.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function findMinimum(comparer: (a: Point, b: Point) => Point, ...points: ReadonlyArray<Point>): Point;\nexport declare function findMinimum(comparer: (a: Point3d, b: Point3d) => Point3d, ...points: ReadonlyArray<Point3d>): Point3d;\n//# sourceMappingURL=find-minimum.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function from(x: number, y: number, z: number): Point3d;\nexport declare function from(x: number, y: number): Point;\nexport declare function from(array: [x: number, y: number, z: number]): Point3d;\nexport declare function from(array: [x: number, y: number]): Point;\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n *\n * Throws an error if `str` is not a string.\n *\n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n *\n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param string_\n */\nexport declare const fromString: (string_: string) => Point;\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport declare const fromNumbers: (...coords: readonly (readonly number[])[] | readonly number[]) => readonly Point[];\n//# sourceMappingURL=from.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function getTwoPointParameters(a: Point, b: Point): [a: Point, b: Point];\nexport declare function getTwoPointParameters(a: Point3d, b: Point3d): [a: Point3d, b: Point3d];\nexport declare function getTwoPointParameters(a: Point, x: number, y: number): [a: Point, b: Point];\nexport declare function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [a: Point3d, b: Point3d];\nexport declare function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [a: Point, b: Point];\nexport declare function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [a: Point3d, b: Point3d];\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport declare function getPointParameter(a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>, b?: number | boolean, c?: number): Point | Point3d;\n//# sourceMappingURL=get-point-parameter.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport declare const isNull: (p: Point) => boolean;\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport declare const isNaN: (p: Point) => boolean;\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport declare function guard(p: Point, name?: string): void;\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport declare const guardNonZeroPoint: (pt: Point | Point3d, name?: string) => boolean;\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p\n * @returns\n */\nexport declare function isPoint(p: number | unknown): p is Point;\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p\n * @returns\n */\nexport declare const isPoint3d: (p: Point | unknown) => p is Point3d;\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport declare const isEmpty: (p: Point) => boolean;\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport declare const isPlaceholder: (p: Point) => boolean;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns a relative point between two points.\n *\n * ```js\n * interpolate(0.5, { x:0, y:0 }, { x:10, y:10 }); // Halfway { x, y }\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport declare const interpolate: (amount: number, a: Point, b: Point, allowOverflow?: boolean) => Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport declare const invert: (pt: Point | Point3d, what?: `both` | `x` | `y` | `z`) => Point;\n//# sourceMappingURL=invert.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport declare const isEqual: (...p: ReadonlyArray<Point>) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport declare const clampMagnitude: (pt: Point, max?: number, min?: number) => Point;\n//# sourceMappingURL=magnitude.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport declare const leftmost: (...points: ReadonlyArray<Point>) => Point;\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport declare const rightmost: (...points: ReadonlyArray<Point>) => Point;\n//# sourceMappingURL=most.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function multiply(a: Point, b: Point): Point;\nexport declare function multiply(a: Point3d, b: Point3d): Point3d;\nexport declare function multiply(a: Point, x: number, y: number): Point;\nexport declare function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport declare const multiplyScalar: (pt: Point | Point3d, v: number) => Point | Point3d;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport declare const normalise: (ptOrX: Point | number, y?: number) => Point;\n//# sourceMappingURL=normalise.d.ts.map","import type { Rect } from \"../rect/rect-types.js\";\nimport type { Point } from \"./point-type.js\";\n/**\n * Normalises a point by a given width and height\n *\n * ```js\n * normaliseByRect({ x: 10, y: 10 }, 20, 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport declare function normaliseByRect(point: Point, width: number, height: number): Point;\n/**\n * Normalises a point by a given rect's width and height\n *\n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param pt\n * @param rect\n */\nexport declare function normaliseByRect(pt: Point, rect: Rect): Point;\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n *\n * ```js\n * normaliseByRect(10, 10, 20, 40); // { x: 0.5, y: 0.2 }\n * ```\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport declare function normaliseByRect(x: number, y: number, width: number, height: number): Point;\n//# sourceMappingURL=normalise-by-rect.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport declare const pipelineApply: (point: Point, ...pipelineFns: ReadonlyArray<(pt: Point) => Point>) => Point;\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport declare const pipeline: (...pipeline: ReadonlyArray<(pt: Point) => Point>) => (pt: Point) => Point;\n//# sourceMappingURL=pipeline.d.ts.map","import type { Point } from \"./point-type.js\";\nexport type PointRelation = (a: Point | number, b?: number) => PointRelationResult;\nexport type PointRelationResult = {\n    /**\n     * Angle from start\n     */\n    readonly angle: number;\n    /**\n     * Distance from start\n     */\n    readonly distanceFromStart: number;\n    /**\n     * Distance from last compared point\n     */\n    readonly distanceFromLast: number;\n    /**\n     * Center point from start\n     */\n    readonly centroid: Point;\n    /**\n     * Average of all points seen\n     * This is calculated by summing x,y and dividing by total points\n     */\n    readonly average: Point;\n    /**\n     * Speed. Distance/millisecond from one sample to the next.\n     */\n    readonly speed: number;\n};\n//# sourceMappingURL=point-relation-types.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Converts to Cartesian coordiantes\n */\nexport type PolarToCartesian = {\n    (point: Coord, origin?: Point): Point;\n    (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * A polar ray is allows you to express a line in polar coordinates\n *\n * It consists of an angle (in radians) with a given offset and length.\n *\n * * angleRadian: Angle of line\n * * Offset: distance from the polar origin (default: 0)\n * * Length: length of ray\n * * Origin: Start Cartesian coordinate of line\n */\nexport type PolarRay = Readonly<{\n    /**\n     * Angle of ray\n     */\n    angleRadian: number;\n    /**\n     * Starting point of a ray, defined as an\n     * offset from the polar origin.\n     */\n    offset: number;\n    /**\n     * Length of ray\n     */\n    length: number;\n    /**\n     * Optional origin point of ray (ie start)\n     */\n    origin?: Point;\n}>;\nexport type PolarRayWithOrigin = PolarRay & Readonly<{\n    origin: Point;\n}>;\n/**\n * Polar coordinate, made up of a distance and angle in radians.\n * Most computations involving PolarCoord require an `origin` as well.\n */\nexport type Coord = {\n    readonly distance: number;\n    readonly angleRadian: number;\n};\n//# sourceMappingURL=types.d.ts.map","import type { Coord } from \"./types.js\";\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport declare const rotate: (c: Coord, amountRadian: number) => Coord;\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport declare const invert: (p: Coord) => Coord;\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport declare const isOpposite: (a: Coord, b: Coord) => boolean;\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport declare const isParallel: (a: Coord, b: Coord) => boolean;\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport declare const isAntiParallel: (a: Coord, b: Coord) => boolean;\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport declare const rotateDegrees: (c: Coord, amountDeg: number) => Coord;\n//# sourceMappingURL=angles.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Coord, PolarToCartesian } from \"./types.js\";\n/**\n * Converts a polar coordinate to a Line.\n *\n * ```js\n * const line = toLine({ angleRadian: Math.Pi, distance: 0.5 }, { x: 0.2, y: 0.1 });\n * // Yields { a: { x, y}, b: { x, y } }\n * ```\n *\n * The 'start' parameter is taken to be the origin of the Polar coordinate.\n * @param c\n * @param start\n * @returns\n */\nexport declare const toLine: (c: Coord, start: Point) => {\n    a: Point;\n    b: Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const toCartesian: PolarToCartesian;\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport declare const fromCartesian: (point: Point, origin: Point) => Coord;\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport declare const toString: (p: Coord, digits?: number) => string;\nexport declare const toPoint: (v: Coord, origin?: {\n    readonly x: 0;\n    readonly y: 0;\n}) => Point;\n//# sourceMappingURL=conversions.d.ts.map","import type { Coord } from \"./types.js\";\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport declare const isPolarCoord: (p: unknown) => p is Coord;\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport declare const guard: (p: Coord, name?: string) => void;\n//# sourceMappingURL=guard.d.ts.map","import type { Coord } from \"./types.js\";\nexport declare const normalise: (c: Coord) => Coord;\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport declare const clampMagnitude: (v: Coord, max?: number, min?: number) => Coord;\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport declare const dotProduct: (a: Coord, b: Coord) => number;\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport declare const multiply: (v: Coord, amt: number) => Coord;\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport declare const divide: (v: Coord, amt: number) => Coord;\n//# sourceMappingURL=math.d.ts.map","import { type Line } from \"../line/line-type.js\";\nimport { type Point } from '../point/point-type.js';\nimport { type PolarRay } from \"./types.js\";\n/**\n * Converts a ray to a Line in cartesian coordinates.\n *\n * By default, the ray's origin is taken to be 0,0.\n * Passing in an origin will override this default, or whatever\n * the ray's origin property is.\n * @param ray Ray\n * @param origin Override or provide origin point\n * @returns\n */\nexport declare const toCartesian: (ray: PolarRay, origin?: Point) => Line;\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray\n * @param origin\n * @returns\n */\n/**\n * Returns a string representation of the ray, useful for debugging.\n *\n * ```\n * \"PolarRay(angle: ... offset: ... len: ... origin: ...)\"\n * ```\n * @param ray\n * @returns\n */\nexport declare const toString: (ray: PolarRay) => string;\n/**\n * Returns a PolarRay based on a line and origin.\n *\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * Otherwise, the origin value is used to determine the 'offset' of the ray.\n * @param line\n * @param origin\n * @returns\n */\nexport declare const fromLine: (line: Line, origin?: Point) => PolarRay;\n//# sourceMappingURL=ray.d.ts.map","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\nimport type { Coord } from \"./types.js\";\nexport declare function spiral(smoothness: number, zoom: number): IterableIterator<Coord & {\n    readonly step: number;\n}>;\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport declare const spiralRaw: (step: number, smoothness: number, zoom: number) => Coord;\n//# sourceMappingURL=spiral.d.ts.map","export type * from './types.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js';\n//# sourceMappingURL=index.d.ts.map","import { TrackedValueMap, type TrackedValueOpts as TrackOpts, type TimestampedObject } from '@ixfx/trackers';\nimport { ObjectTracker } from '@ixfx/trackers';\nimport type { Coord as PolarCoord } from '../polar/index.js';\nimport type { Line, PolyLine } from '../line/line-type.js';\nimport type { Point, Point3d } from './point-type.js';\nimport type { PointRelation } from './point-relation-types.js';\nimport type { TrimReason } from '@ixfx/trackers';\nimport type { PointRelationResult } from \"./point-relation-types.js\";\n/**\n * Information about seen points\n */\nexport type PointTrack = PointRelationResult & {};\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = Readonly<{\n    /**\n     * Relation of last point to previous point\n     */\n    fromLast: PointTrack;\n    /**\n     * Relation of last point to 'initial' point.\n     * This will be the oldest point in the buffer of the tracker.\n     */\n    fromInitial: PointTrack;\n    /**\n     * Relation of last point to a 'mark' point,\n     * which is manually set.\n     *\n     * Will give _undefined_ if `.mark()` has not been called on tracker.\n     */\n    fromMark: PointTrack | undefined;\n    values: readonly Point[];\n}>;\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link PointsTracker}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport declare class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n    initialRelation: PointRelation | undefined;\n    markRelation: PointRelation | undefined;\n    lastResult: PointTrackerResults | undefined;\n    constructor(opts?: TrackOpts);\n    /**\n     * Notification that buffer has been knocked down to `sampleLimit`.\n     *\n     * This will reset the `initialRelation`, which will use the new oldest value.\n     */\n    onTrimmed(_reason: TrimReason): void;\n    /**\n     * @ignore\n     */\n    onReset(): void;\n    /**\n     * Adds a PointerEvent along with its\n     * coalesced events, if available.\n     * @param p\n     * @returns\n     */\n    seenEvent(p: PointerEvent | MouseEvent): PointTrackerResults;\n    /**\n     * Makes a 'mark' in the tracker, allowing you to compare values\n     * to this point.\n     */\n    mark(): void;\n    /**\n     * Tracks a point, returning data on its relation to the\n     * initial point and the last received point.\n     *\n     * Use {@link seenEvent} to track a raw `PointerEvent`.\n     *\n     * @param _p Point\n     */\n    computeResults(_p: TimestampedObject<Point>[]): PointTrackerResults;\n    /**\n     * Returns a polyline representation of stored points.\n     * Returns an empty array if points were not saved, or there's only one.\n     */\n    get line(): PolyLine;\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a polar coordinate\n     */\n    get vectorPolar(): PolarCoord;\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a Cartesian coordinate\n     */\n    get vectorCartesian(): Point;\n    /**\n     * Returns a line from initial point to last point.\n     *\n     * If there are less than two points, Lines.Empty is returned\n     */\n    get lineStartEnd(): Line;\n    /**\n     * Returns distance from latest point to initial point.\n     * If there are less than two points, zero is returned.\n     *\n     * This is the direct distance from initial to last,\n     * not the accumulated length.\n     * @returns Distance\n     */\n    distanceFromStart(): number;\n    /**\n     * Difference between last point and the initial point, calculated\n     * as a simple subtraction of x,y & z.\n     *\n     * `Points.Placeholder` is returned if there's only one point so far.\n     */\n    difference(): Point | Point3d;\n    /**\n     * Returns angle (in radians) from latest point to the initial point\n     * If there are less than two points, undefined is return.\n     * @returns Angle in radians\n     */\n    angleFromStart(): number | undefined;\n    /**\n     * Returns the total length of accumulated points.\n     * Returns 0 if points were not saved, or there's only one\n     */\n    get length(): number;\n    /**\n   * Returns the last x coord\n   */\n    get x(): number;\n    /**\n     * Returns the last y coord\n     */\n    get y(): number;\n    /**\n     * Returns the last z coord (or _undefined_ if not available)\n     */\n    get z(): number | undefined;\n}\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport declare class PointsTracker extends TrackedValueMap<Point, PointTracker, PointTrackerResults> {\n    constructor(opts?: TrackOpts);\n    /**\n     * Track a PointerEvent\n     * @param event\n     */\n    seenEvent(event: PointerEvent): Promise<PointTrackerResults[]>;\n}\n//# sourceMappingURL=point-tracker.d.ts.map","import type { Point3d, Point } from \"./point-type.js\";\n/**\n * Computes the progress between two waypoints, given `position`.\n *\n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns\n */\nexport declare const progressBetween: (position: Point | Point3d, waypointA: Point | Point3d, waypointB: Point | Point3d) => number;\n//# sourceMappingURL=progress-between.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport declare const project: (origin: Point, distance: number, angle: number) => {\n    x: number;\n    y: number;\n};\n//# sourceMappingURL=project.d.ts.map","import type { Point, Point3d } from './point-type.js';\nexport declare function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport declare function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n//# sourceMappingURL=quantise.d.ts.map","import { type RandomSource } from '@ixfx/random';\nimport type { Point, Point3d } from './point-type.js';\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random: (rando?: RandomSource) => Point;\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random3d: (rando?: RandomSource) => Point3d;\n//# sourceMappingURL=random.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport declare const reduce: (pts: ReadonlyArray<Point>, fn: (p: Point, accumulated: Point) => Point, initial?: Point) => Point;\n//# sourceMappingURL=reduce.d.ts.map","import type { PointRelation } from \"./point-relation-types.js\";\nimport type { Point } from \"./point-type.js\";\n/**\n * Tracks the relation between two points.\n *\n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n *\n * It computes angle, average, centroid, distance and speed.\n *\n * ```js\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n *\n * Or with destructuring:\n *\n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link PointsTracker}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport declare const relation: (a: Point | number, b?: number) => PointRelation;\n//# sourceMappingURL=relation.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport declare function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport declare function rotate(pt: readonly Point[], amountRadian: number, origin?: Point): readonly Point[];\n//# sourceMappingURL=rotate.d.ts.map","export declare const rotatePointArray: (v: ReadonlyArray<ReadonlyArray<number>>, amountRadian: number) => Array<Array<number>>;\n//# sourceMappingURL=rotate-point-array.d.ts.map","import type { Point } from './point-type.js';\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX\n * @param yOrDigits\n * @param digits\n * @returns\n */\nexport declare const round: (ptOrX: Point | number, yOrDigits?: number, digits?: number) => Point;\n//# sourceMappingURL=round.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function subtract(a: Point, b: Point): Point;\nexport declare function subtract(a: Point3d, b: Point3d): Point3d;\nexport declare function subtract(a: Point, x: number, y: number): Point;\nexport declare function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n//# sourceMappingURL=subtract.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function sum(a: Point, b: Point): Point;\nexport declare function sum(a: Point3d, b: Point3d): Point3d;\nexport declare function sum(a: Point, x: number, y: number): Point;\nexport declare function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n//# sourceMappingURL=sum.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport declare const toIntegerValues: (pt: Point, rounder?: (x: number) => number) => Point;\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt\n * @returns\n */\nexport declare const to2d: (pt: Point) => Point;\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns\n */\nexport declare const to3d: (pt: Point, z?: number) => Point3d;\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport declare function toString(p: Point, digits?: number): string;\n//# sourceMappingURL=To.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport declare const toArray: (p: Point) => ReadonlyArray<number>;\n//# sourceMappingURL=to-array.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns true if two points are within a specified range on both axes.\n *\n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport declare const withinRange: (a: Point, b: Point, maxRange: Point | number) => boolean;\n//# sourceMappingURL=within-range.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport declare const wrap: (pt: Point, ptMax?: Point, ptMin?: Point) => Point;\n//# sourceMappingURL=wrap.d.ts.map","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\nexport type { Point, Point3d } from './point-type.js';\n//# sourceMappingURL=index.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Returns the area of `rect`\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const area: (rect: Rect) => number;\n//# sourceMappingURL=area.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number;\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number;\nexport declare function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport declare function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport declare function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\nexport declare function applyMerge(op: ApplyMergeOp, rect: RectPositioned, width: number, height?: number): RectPositioned;\nexport declare function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport declare function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport declare function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n/**\n * Uses `op` with `param` to width and height.\n * @param op\n * @param rect\n * @param parameter\n */\nexport declare function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op\n * @param rect\n * @param parameter\n */\nexport declare function applyScalar(op: ApplyMergeOp, rect: RectPositioned, parameter: number): RectPositioned;\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op\n * @param rect\n * @param parameter\n * @returns\n */\nexport declare function applyDim(op: ApplyMergeOp, rect: Rect | RectPositioned, parameter: number): Rect | RectPositioned;\n//# sourceMappingURL=apply.d.ts.map","import type { ISetMutable } from \"@ixfx/collections\";\nexport type GridVisual = Grid & {\n    readonly size: number;\n};\nexport type Grid = {\n    readonly rows: number;\n    readonly cols: number;\n};\nexport type GridCell = {\n    readonly x: number;\n    readonly y: number;\n};\nexport type GridNeighbours = {\n    readonly n: GridCell | undefined;\n    readonly e: GridCell | undefined;\n    readonly s: GridCell | undefined;\n    readonly w: GridCell | undefined;\n    readonly ne: GridCell | undefined;\n    readonly nw: GridCell | undefined;\n    readonly se: GridCell | undefined;\n    readonly sw: GridCell | undefined;\n};\nexport type GridCardinalDirection = `n` | `ne` | `e` | `se` | `s` | `sw` | `w` | `nw`;\nexport type GridCardinalDirectionOptional = GridCardinalDirection | ``;\nexport type GridArray1d<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[];\n};\n/**\n * Bounds logic\n * * Unbounded: attempts to read beyond limits\n * * Undefined: returns _undefined_ when reading beyond limits\n * * Stop: returns cell value at edge of limits\n * * Wrap: Wrap-around cell positions\n *\n */\nexport type GridBoundsLogic = \n/**\n * Unbounded: attempts to read beyond limits\n */\n`unbounded` | \n/**\n * Undefined: returns _undefined_ when reading beyond limits\n */\n`undefined` | \n/**\n * Stop: returns cell value at edge of limits\n */\n`stop` | \n/**\n * Wrap-around cell positions\n */\n`wrap`;\n/**\n * Logic to select the next cell based on a list of neighbours\n */\nexport type GridNeighbourSelectionLogic = {\n    /**\n     * Returns neighbours for a given cell in a grid\n     */\n    readonly getNeighbours?: GridIdentifyNeighbours;\n    /**\n     * Select a neighbour from given list\n     */\n    readonly select: GridNeighbourSelector;\n};\nexport type GridVisitorOpts = Readonly<{\n    start: GridCell;\n    visited: ISetMutable<GridCell>;\n    reversed: boolean;\n    debug: boolean;\n    boundsWrap: GridBoundsLogic;\n}>;\nexport type GridCreateVisitor = (grid: Grid, opts?: Partial<GridVisitorOpts>) => Generator<GridCell>;\nexport type GridCellAndValue<T> = {\n    cell: GridCell;\n    value: T | undefined;\n};\nexport type GridNeighbourMaybe = readonly [keyof GridNeighbours, GridCell | undefined];\nexport type GridNeighbour = readonly [keyof GridNeighbours, GridCell];\n/**\n * A function that returns a value (or _undefined_) based on a _cell_\n *\n * Implementations:\n * * {@link Grids.Array1d.access}: For accessing a single-dimension array as a grid\n * * {@link Grids.Array2d.access}: For accessing a two-dimension array as a grid\n *\n */\nexport type GridCellAccessor<TValue> = (cell: GridCell, wrap?: GridBoundsLogic) => TValue | undefined;\n/**\n * A function that sets the value of a cell.\n */\nexport type GridCellSetter<TValue> = (value: TValue, cell: GridCell, wrap?: GridBoundsLogic) => void;\n/**\n * Shape of a grid and a function to read values from it, based on\n * cell location.\n *\n * These functions create a GridReadable:\n * * {@link Grids.Array1d.wrap}: wrap an array and read as a grid\n * * {@link Grids.Array1d.wrapMutable}: wrap and modify an array as a grid\n * * {@link Grids.Array2d.wrap}: wrap a two-dimensional grid\n * * {@link Grids.Array2d.wrapMutable}\n */\nexport type GridReadable<T> = Grid & {\n    get: GridCellAccessor<T>;\n};\nexport type GridWritable<T> = Grid & {\n    set: GridCellSetter<T>;\n};\n/**\n * Neighbour selector logic. For a given set of `neighbours` pick one to visit next.\n */\nexport type GridNeighbourSelector = (neighbours: readonly GridNeighbour[]) => GridNeighbour | undefined;\n/**\n * Identify neighbours logic. For a given `grid` and `origin`, return a list of neighbours\n */\nexport type GridIdentifyNeighbours = (grid: Grid, origin: GridCell) => readonly GridNeighbour[];\n//# sourceMappingURL=types.d.ts.map","import type { GridBoundsLogic, GridCell, Grid } from \"./types.js\";\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid\n * @param cell\n * @param wrap\n * @returns\n */\nexport declare const applyBounds: (grid: Grid, cell: GridCell, wrap?: GridBoundsLogic) => GridCell | undefined;\n//# sourceMappingURL=apply-bounds.d.ts.map","import type { GridCellAccessor, GridCell, GridBoundsLogic, Grid, GridCellSetter, GridArray1d } from \"./types.js\";\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n *\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport declare const access: <V>(array: readonly V[], cols: number) => GridCellAccessor<V>;\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n *\n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport declare const setMutate: <V>(array: V[], cols: number) => GridCellSetter<V>;\nexport declare const set: <V>(array: readonly V[], cols: number) => (value: V, cell: GridCell, wrap: GridBoundsLogic) => V[];\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *\n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n *\n * Use {@link wrap} for an immutable version.\n *\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport declare const wrapMutable: <T>(array: T[], cols: number) => GridArray1d<T>;\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * const myArray = [\n *    `a`, `b`, `c`,\n *    `d`, `e`, `f`\n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n *\n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport declare const wrap: <T>(array: T[], cols: number) => GridArray1d<T>;\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n *\n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n *\n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport declare const createArray: <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number) => T[];\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n *\n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue\n * @param rowsOrGrid\n * @param columns\n * @returns\n */\nexport declare const createMutable: <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number) => GridArray1d<T>;\n//# sourceMappingURL=array-1d.d.ts.map","import type { GridBoundsLogic, GridCell, GridCellAccessor, GridCellSetter, Grid, GridReadable, GridWritable } from \"./types.js\";\nexport type ArrayGrid<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[][];\n};\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array\n * @returns\n */\nexport declare const create: <T>(array: ReadonlyArray<T[]> | Array<T[]>) => Grid;\nexport declare const setMutate: <V>(array: V[][]) => GridCellSetter<V>;\nexport declare const access: <T>(array: ReadonlyArray<T[]>) => GridCellAccessor<T>;\nexport declare const wrapMutable: <T>(array: T[][]) => ArrayGrid<T>;\nexport declare const set: <V>(array: readonly V[][]) => (value: V, cell: GridCell, wrap: GridBoundsLogic) => V[][];\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns\n */\nexport declare const wrap: <T>(array: T[][]) => ArrayGrid<T>;\n//# sourceMappingURL=array-2d.d.ts.map","import type { GridCell, Grid } from \"./types.js\";\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n *\n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport declare const rows: (grid: Grid, start?: GridCell) => Generator<GridCell[], void, unknown>;\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n *\n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n *\n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport declare function columns(grid: Grid, start?: GridCell): Generator<GridCell[], void, unknown>;\n//# sourceMappingURL=as.d.ts.map","import type { GridBoundsLogic, GridCardinalDirection, GridCardinalDirectionOptional, GridCell, Grid, GridNeighbours } from \"./types.js\";\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport declare const allDirections: readonly GridCardinalDirection[];\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport declare const crossDirections: readonly GridCardinalDirection[];\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport declare const offsetCardinals: (grid: Grid, start: GridCell, steps: number, bounds?: GridBoundsLogic) => GridNeighbours;\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport declare const getVectorFromCardinal: (cardinal: GridCardinalDirectionOptional, multiplier?: number) => GridCell;\n//# sourceMappingURL=directions.d.ts.map","import type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../types.js\";\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n *\n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n *\n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n *\n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n *\n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport declare function cells(grid: Grid, start?: GridCell, wrap?: boolean): Generator<{\n    x: number;\n    y: number;\n}, void, unknown>;\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n *\n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport declare function cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap?: boolean): Generator<T, void, any>;\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport declare function cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap?: boolean): Generator<GridCellAndValue<T>>;\n//# sourceMappingURL=cells.d.ts.map","export * from './cells.js';\n//# sourceMappingURL=index.d.ts.map","import type { GridCell } from \"./types.js\";\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport declare const getLine: (start: GridCell, end: GridCell) => ReadonlyArray<GridCell>;\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport declare const simpleLine: (start: GridCell, end: GridCell, endInclusive?: boolean) => ReadonlyArray<GridCell>;\n//# sourceMappingURL=geometry.d.ts.map","import type { GridCell, Grid } from \"./types.js\";\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport declare const isCell: (cell: GridCell | undefined) => cell is GridCell;\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport declare const guardCell: (cell: GridCell, parameterName?: string, grid?: Grid) => void;\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport declare const guardGrid: (grid: Grid, parameterName?: string) => void;\n//# sourceMappingURL=guards.d.ts.map","import type { Grid, GridCell, GridBoundsLogic } from \"./types.js\";\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport declare const indexFromCell: (grid: Grid, cell: GridCell, wrap: GridBoundsLogic) => number | undefined;\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport declare const cellFromIndex: (colsOrGrid: number | Grid, index: number) => GridCell;\n//# sourceMappingURL=indexing.d.ts.map","import type { Grid, GridCell } from \"./types.js\";\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport declare const inside: (grid: Grid, cell: GridCell) => boolean;\n//# sourceMappingURL=inside.d.ts.map","import type { GridCell, Grid, GridVisual } from \"./types.js\";\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport declare const isEqual: (a: Grid | GridVisual, b: Grid | GridVisual) => boolean;\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport declare const cellEquals: (a: GridCell | undefined, b: GridCell | undefined) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { GridBoundsLogic, GridCardinalDirection, GridCell, Grid, GridNeighbour, GridNeighbours } from \"./types.js\";\nexport declare const randomNeighbour: (nbos: readonly GridNeighbour[]) => GridNeighbour;\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n *\n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n *\n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions\n * @param bounds Bounds\n * @returns\n */\nexport declare const neighbourList: (grid: Grid, cell: GridCell, directions: readonly GridCardinalDirection[], bounds: GridBoundsLogic) => readonly GridNeighbour[];\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport declare const neighbours: (grid: Grid, cell: GridCell, bounds?: GridBoundsLogic, directions?: readonly GridCardinalDirection[]) => GridNeighbours;\n//# sourceMappingURL=neighbour.d.ts.map","import type { Grid, GridCell, GridBoundsLogic } from './types.js';\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n *\n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport declare const offset: (grid: Grid, start: GridCell, vector: GridCell, bounds?: GridBoundsLogic) => GridCell | undefined;\n//# sourceMappingURL=offset.d.ts.map","/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\nimport type { Grid } from \"./types.js\";\nexport declare const toArray2d: <V>(grid: Grid, initialValue?: V) => V[][];\n//# sourceMappingURL=to-array.d.ts.map","import type { GridCell } from \"./types.js\";\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport declare const cellKeyString: (v: GridCell) => string;\n//# sourceMappingURL=to-string.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { GridCell, GridVisual } from \"./types.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport declare function asRectangles(grid: GridVisual): IterableIterator<RectPositioned>;\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport declare const cellAtPoint: (grid: GridVisual, position: Point) => GridCell | undefined;\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport declare const rectangleForCell: (grid: GridVisual, cell: GridCell) => RectPositioned;\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport declare const cellMiddle: (grid: GridVisual, cell: GridCell) => Point;\n//# sourceMappingURL=visual.d.ts.map","import type { GridReadable, GridCell } from \"./types.js\";\nexport declare function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell>): Generator<T>;\nexport declare function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell[]>): Generator<T[]>;\n//# sourceMappingURL=values.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const breadthLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=breadth.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const neighboursLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=cell-neighbours.d.ts.map","import type { GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport declare const columnLogic: (opts?: Partial<GridVisitorOpts>) => GridNeighbourSelectionLogic;\n//# sourceMappingURL=columns.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const depthLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=depth.d.ts.map","import type { Grid, GridCell, GridCreateVisitor } from \"../types.js\";\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n *\n * // Step by 10\n * stepper(10); // GridCell {x,y}\n *\n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport declare const stepper: (grid: Grid, createVisitor: GridCreateVisitor, start?: GridCell, resolution?: number) => (step: number, fromStart?: boolean) => GridCell | undefined;\n//# sourceMappingURL=step.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const randomLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=random.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const randomContiguousLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=random-contiguous.d.ts.map","import type { GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport declare const rowLogic: (opts?: Partial<GridVisitorOpts>) => GridNeighbourSelectionLogic;\n//# sourceMappingURL=rows.d.ts.map","import type { GridNeighbourSelectionLogic, Grid, GridCell, GridVisitorOpts } from \"../types.js\";\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a @ixfx/collections.Sets.ISetMutable instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport declare function visitByNeighbours(logic: GridNeighbourSelectionLogic, grid: Grid, opts?: Partial<GridVisitorOpts>): Generator<GridCell>;\n//# sourceMappingURL=visitor.d.ts.map","import type { GridCell, Grid, GridNeighbourSelectionLogic, GridVisitorOpts } from '../types.js';\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\nexport type VisitorTypes = `row` | `column` | `neighbours` | `breadth` | `depth` | `random` | `random-contiguous`;\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type\n * @param opts\n * @returns\n */\nexport declare const create: (type: VisitorTypes, opts?: Partial<GridVisitorOpts>) => (grid: Grid, optionsOverride?: Partial<GridVisitorOpts>) => Generator<GridCell, any, any>;\nexport declare const withLogic: (logic: GridNeighbourSelectionLogic, options?: Partial<GridVisitorOpts>) => (grid: Grid, optionsOverride?: Partial<GridVisitorOpts>) => Generator<GridCell, any, any>;\n//# sourceMappingURL=index.d.ts.map","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport type * from './types.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n//# sourceMappingURL=index.d.ts.map","import type { RectPositioned } from \"./rect-types.js\";\nimport type { GridCardinalDirection } from '../grid/index.js';\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport declare const cardinal: (rect: RectPositioned, card: GridCardinalDirection | `center`) => Point;\n//# sourceMappingURL=cardinal.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Perform basic point translation using a rectangle where its center is the origin.\n *\n * Thus the relative coordinate { x: 0, y: 0} corresponds to the absolute middle of the\n * rectangle.\n *\n * The relative coordinate { x: -1, y: -1 } corresponds to the rectangle's {x,y} properties, and so on.\n * @param rectAbsolute\n * @returns\n */\nexport declare const centerOrigin: (rectAbsolute: RectPositioned) => {\n    relativeToAbsolute: (point: Point) => {\n        x: number;\n        y: number;\n        z?: number;\n    };\n    absoluteToRelative: (point: Point) => {\n        x: number;\n        y: number;\n        z?: number;\n    };\n};\n//# sourceMappingURL=center-origin.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns the center of a rectangle as a {@link Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport declare const center: (rect: RectPositioned | Rect, origin?: Point) => Point;\n//# sourceMappingURL=center.d.ts.map","import { type Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport declare const corners: (rect: RectPositioned | Rect, origin?: Point) => readonly Point[];\n//# sourceMappingURL=corners.d.ts.map","import type { RectPositioned } from \"./rect-types.js\";\nimport { type Point } from '../point/point-type.js';\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport declare const distanceFromExterior: (rect: RectPositioned, pt: Point) => number;\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport declare const distanceFromCenter: (rect: RectPositioned, pt: Point) => number;\n//# sourceMappingURL=distance.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n * x & y value of second parameter are ignored\n * ```js\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport declare function divide(rect: RectPositioned, width: number, height?: number): RectPositioned;\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport declare function divide(rect: Rect, width: number, height: number): Rect;\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function divide(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Divides rect `a` by width and height of rect `b`.\n *\n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function divide(a: Rect, b: Rect): Rect;\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function divideScalar(rect: Rect, amount: number): Rect;\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function divideScalar(rect: RectPositioned, amount: number): RectPositioned;\nexport declare function divideDim(rect: Rect | RectPositioned, amount: number): Rect | RectPositioned;\n//# sourceMappingURL=divide.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { Line } from \"../line/line-type.js\";\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport declare const edges: (rect: RectPositioned | Rect, origin?: Point) => readonly Line[];\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport declare const getEdgeX: (rect: RectPositioned | Rect, edge: `right` | `bottom` | `left` | `top`) => number;\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport declare const getEdgeY: (rect: RectPositioned | Rect, edge: `right` | `bottom` | `left` | `top`) => number;\n//# sourceMappingURL=edges.d.ts.map","export declare const Empty: Readonly<{\n    width: 0;\n    height: 0;\n}>;\nexport declare const EmptyPositioned: Readonly<{\n    x: 0;\n    y: 0;\n    width: 0;\n    height: 0;\n}>;\n//# sourceMappingURL=empty.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect\n * @param points\n * @returns\n */\nexport declare const encompass: (rect: RectPositioned, ...points: Point[]) => RectPositioned;\n//# sourceMappingURL=encompass.d.ts.map","import { type RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport declare const fromCenter: (origin: Point, width: number, height: number) => RectPositioned;\n//# sourceMappingURL=from-center.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport declare const fromElement: (el: HTMLElement) => Rect;\n//# sourceMappingURL=from-element.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport declare function fromNumbers(width: number, height: number): Rect;\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport declare function fromNumbers(x: number, y: number, width: number, height: number): RectPositioned;\n//# sourceMappingURL=from-numbers.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport declare const fromTopLeft: (origin: Point, width: number, height: number) => RectPositioned;\n//# sourceMappingURL=from-top-left.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport declare function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned;\n//# sourceMappingURL=get-rect-positionedparameter.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d\n * @param name\n */\nexport declare const guardDim: (d: number, name?: string) => void;\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n *\n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n *\n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport declare const guard: (rect: Rect, name?: string) => void;\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n *\n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n *\n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *\n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect\n * @param origin\n * @returns\n */\nexport declare const getRectPositioned: (rect: Rect | RectPositioned, origin?: Point) => RectPositioned;\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect\n * @param name\n */\nexport declare const guardPositioned: (rect: RectPositioned, name?: string) => void;\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect\n * @returns\n */\nexport declare const isEmpty: (rect: Rect) => boolean;\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect\n * @returns\n */\nexport declare const isPlaceholder: (rect: Rect) => boolean;\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport declare const isPositioned: (rect: Point | Rect | RectPositioned) => rect is Point;\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport declare const isRect: (rect: unknown) => rect is Rect;\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport declare const isRectPositioned: (rect: any) => rect is RectPositioned;\n//# sourceMappingURL=guard.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"../circle/circle-type.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport declare function intersectsPoint(rect: Rect | RectPositioned, point: Point): boolean;\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport declare function intersectsPoint(rect: Rect | RectPositioned, x: number, y: number): boolean;\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport declare const isIntersecting: (a: RectPositioned, b: CirclePositioned | Point) => boolean;\n//# sourceMappingURL=Intersects.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqualSize: (a: Rect, b: Rect) => boolean;\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: Rect | RectPositioned, b: Rect | RectPositioned) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { RectPositioned } from './rect-types.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const lengths: (rect: RectPositioned) => readonly number[];\n//# sourceMappingURL=lengths.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport declare const maxFromCorners: (topLeft: Point, topRight: Point, bottomRight: Point, bottomLeft: Point) => RectPositioned;\n//# sourceMappingURL=max.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n * x/y value of second parameter are ignored.\n * ```js\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport declare function multiply(rect: RectPositioned, width: number, height?: number): RectPositioned;\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport declare function multiply(rect: Rect, width: number, height: number): Rect;\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function multiply(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n *\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function multiply(a: Rect, b: Rect): Rect;\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function multiplyScalar(rect: Rect, amount: number): Rect;\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function multiplyScalar(rect: RectPositioned, amount: number): RectPositioned;\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n *\n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns\n */\nexport declare function multiplyDim(rect: Rect | RectPositioned, amount: number): Rect | RectPositioned;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect\n * @param p\n * @returns\n */\nexport declare const nearestInternal: (rect: RectPositioned, p: Point) => Point;\n//# sourceMappingURL=nearest.d.ts.map","export declare const Placeholder: Readonly<{\n    width: number;\n    height: number;\n}>;\nexport declare const PlaceholderPositioned: Readonly<{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}>;\n//# sourceMappingURL=placeholder.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const perimeter: (rect: Rect) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"./rect-types.js\";\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n *\n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect\n * @returns\n */\nexport declare const dividerByLargestDimension: (rect: Rect) => (value: number | Point) => number | Readonly<{\n    x: number;\n    y: number;\n    z?: number;\n}>;\n//# sourceMappingURL=normalise-by-rect.d.ts.map","import { type RandomSource } from '@ixfx/random';\nimport type { Point } from '../point/point-type.js';\nimport type { Rect, RectPositioned } from './rect-types.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random: (rando?: RandomSource) => RectPositioned;\nexport type RectRandomPointOpts = {\n    readonly strategy?: `naive`;\n    readonly randomSource?: RandomSource;\n    readonly margin?: {\n        readonly x: number;\n        readonly y: number;\n    };\n};\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport declare const randomPoint: (within: Rect | RectPositioned, options?: RectRandomPointOpts) => Point;\n//# sourceMappingURL=random.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * x,y of second parameter is ignored.\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport declare function subtract(a: Rect, b: Rect | RectPositioned): Rect;\nexport declare function subtract(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * const rect = { width: 100, height: 100 };\n * Rects.subtract(rect, 200, 200);\n * // Yields: { width: -100, height: -100 }\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport declare function subtract(a: Rect, width: number, height: number): Rect;\nexport declare function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts a width & height from `a`. Leaves x & y as-is.\n * ```js\n * const rect = { x: 10, y: 20, width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { x:10, y: 20, width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport declare function subtractSize(a: RectPositioned, b: Rect | number, c?: number): RectPositioned;\n/**\n * Subtracts a width & height from `a`.\n * ```js\n * const rect = { width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport declare function subtractSize(a: Rect, b: Rect | number, c?: number): Rect;\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 },\n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a\n * @param b\n * @returns\n */\nexport declare function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned;\n//# sourceMappingURL=subtract.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * x/y of second parameter are ignored\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport declare function sum(a: Rect, b: Rect | RectPositioned): Rect;\n/**\n * Sums width/height of `b` with `a`, returning result.\n *\n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n *\n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a\n * @param b\n */\nexport declare function sum(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport declare function sum(rect: Rect, width: number, height: number): Rect;\n/**\n * Sums width/height of `rect` with `width` and `height`\n *\n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport declare function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a\n * @param b\n * @returns\n */\nexport declare function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned;\n//# sourceMappingURL=sum.d.ts.map","import type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./rect-types.js\";\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport declare function toArray(rect: Rect): RectArray;\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport declare function toArray(rect: RectPositioned): RectPositionedArray;\n//# sourceMappingURL=to-array.d.ts.map","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center-origin.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\nexport type * from './rect-types.js';\n//# sourceMappingURL=index.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\nexport type Path = {\n    /**\n     * Length of path\n     */\n    length(): number;\n    /**\n     * Returns a point at a relative (0.0-1.0) position along the path\n     *\n     * Inverse of {@link relativePosition}.\n     * @param {number} t Relative position (0.0-1.0)\n     * @returns {Point} Point\n     */\n    interpolate(t: number): Point;\n    /**\n     * Returns relative position of `point` along path.\n     * If `pt` is same as start, result will be 0, if it's the same as end, it will be 1.\n     *\n     * Inverse of {@link interpolate}.\n     * @param point\n     * @param intersectionThreshold\n     */\n    relativePosition(point: Point, intersectionThreshold: number): number;\n    /**\n     * Gets smallest box that encloses path\n     */\n    bbox(): RectPositioned;\n    /**\n     * Returns the nearest point on path to `point`\n     * @param point\n     */\n    nearest(point: Point): Point;\n    /**\n     * Distance from start of path to this point.\n     * If path is closed (eg. a circle) it may have some arbitary 'start' point\n     * @param point\n     */\n    distanceToPoint(point: Point): number;\n    /**\n     * Returns a string representation of pth values\n     */\n    toString(): string;\n    /**\n     * Returns an array of SVG segments that can render path\n     */\n    toSvgString(): ReadonlyArray<string>;\n    /**\n     * Well-known path kind\n     */\n    readonly kind: `compound` | `elliptical` | `circular` | `arc` | `bezier/cubic` | `bezier/quadratic` | `line`;\n};\nexport type WithBeziers = {\n    getBeziers(): ReadonlyArray<Path>;\n};\nexport type CompoundPath = Path & {\n    readonly segments: ReadonlyArray<Path>;\n    readonly kind: `compound`;\n};\nexport type Dimensions = {\n    /**\n     * Width of each path (based on bounding box)\n     */\n    readonly widths: ReadonlyArray<number>;\n    /**\n     * Length of each path\n     */\n    readonly lengths: ReadonlyArray<number>;\n    /**\n     * Total length of all paths\n     */\n    readonly totalLength: number;\n    /**\n     * Total width of all paths\n     */\n    readonly totalWidth: number;\n};\n//# sourceMappingURL=path-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Arc, defined by radius, start and end point in radians and direction\n */\nexport type Arc = {\n    /**\n     * Radius of arc\n     */\n    readonly radius: number;\n    /**\n     * Start radian\n     */\n    readonly startRadian: number;\n    /**\n     * End radian\n     */\n    readonly endRadian: number;\n    /**\n     * If true, arc runs in clockwise direction\n     */\n    readonly clockwise: boolean;\n};\n/**\n * An {@link Arc} that also has a center position, given in x, y\n */\nexport type ArcPositioned = Point & Arc;\n/**\n * Function which can interpolate along an {@link Arc} or {@link ArcPositioned}.\n */\nexport type ArcInterpolate = {\n    (amount: number, arc: Arc, allowOverflow: boolean, origin: Point): Point;\n    (amount: number, arc: ArcPositioned, allowOverflow?: boolean): Point;\n};\n/**\n * Function to convert an arc to SVG segments\n */\nexport type ArcToSvg = {\n    /**\n     * SVG path for arc description\n     * @param origin Origin of arc\n     * @param radius Radius\n     * @param startRadian Start\n     * @param endRadian End\n     */\n    (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: ArcSvgOpts): readonly string[];\n    /**\n     * SVG path for non-positioned arc.\n     * If `arc` does have a position, `origin` will override it.\n     */\n    (arc: Arc, origin: Point, opts?: ArcSvgOpts): readonly string[];\n    /**\n     * SVG path for positioned arc\n     */\n    (arc: ArcPositioned, opts?: ArcSvgOpts): readonly string[];\n};\nexport type ArcSvgOpts = {\n    /**\n     * \"If the arc should be greater or less than 180 degrees\"\n     * ie. tries to maximise arc length\n     */\n    readonly largeArc?: boolean;\n    /**\n     * \"If the arc should begin moving at positive angles\"\n     * ie. the kind of bend it makes to reach end point\n     */\n    readonly sweep?: boolean;\n};\n//# sourceMappingURL=arc-type.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Line } from '../line/line-type.js';\nimport type { Path } from '../path/path-type.js';\nimport type { Rect, RectPositioned } from '../rect/rect-types.js';\nimport type { Arc, ArcInterpolate, ArcPositioned, ArcToSvg } from './arc-type.js';\nimport type { CirclePositioned } from '../circle/circle-type.js';\nexport type * from './arc-type.js';\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns\n */\nexport declare const isArc: (p: unknown) => p is Arc;\n/**\n * Returns true if parameter has a positioned (x,y)\n * @param p Point, Arc or ArcPositiond\n * @returns\n */\nexport declare const isPositioned: (p: Point | Arc | ArcPositioned) => p is Point;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport declare function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean): Arc;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */ export declare function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin: Point): ArcPositioned;\n/**\n * Returns a {@link Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport declare const toLine: (arc: ArcPositioned) => Line;\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc\n * @param origin\n * @returns\n */\nexport declare const getStartEnd: (arc: ArcPositioned | Arc, origin?: Point) => [start: Point, end: Point];\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate\n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport declare const point: (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point) => Point;\n/**\n * Throws an error if arc instance is invalid\n * @param arc\n */\nexport declare const guard: (arc: Arc | ArcPositioned) => void;\n/**\n * Compute relative position on arc.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns\n */\nexport declare const interpolate: ArcInterpolate;\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc\n */\nexport declare const angularSize: (arc: Arc) => number;\n/**\n * Creates a {@link Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc\n * @returns Path\n */\nexport declare const toPath: (arc: ArcPositioned) => Path;\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns\n */\nexport declare const fromCircle: (circle: CirclePositioned, startRadian: number, endRadian: number, clockwise?: boolean) => ArcPositioned;\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns\n */\nexport declare const fromCircleAmount: (circle: CirclePositioned, startRadian: number, sizeRadian: number, clockwise?: boolean) => ArcPositioned;\n/**\n * Calculates the length of the arc\n * @param arc\n * @returns Length\n */\nexport declare const length: (arc: Arc) => number;\n/**\n * Calculates a {@link Rect} bounding box for arc.\n * @param arc\n * @returns Rectangle encompassing arc.\n */\nexport declare const bbox: (arc: ArcPositioned | Arc) => RectPositioned | Rect;\n/**\n * Creates an SV path snippet for arc\n * @returns\n */\nexport declare const toSvg: ArcToSvg;\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b\n * @returns Distance\n */\nexport declare const distanceCenter: (a: ArcPositioned, b: ArcPositioned) => number;\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport declare const isEqual: (a: Arc | ArcPositioned, b: Arc | ArcPositioned) => boolean;\n//# sourceMappingURL=index.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nexport type QuadraticBezier = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly quadratic: Point;\n};\nexport type QuadraticBezierPath = Path & QuadraticBezier;\nexport type CubicBezier = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly cubic1: Point;\n    readonly cubic2: Point;\n};\nexport type CubicBezierPath = Path & CubicBezier;\n//# sourceMappingURL=bezier-type.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\nexport declare const isQuadraticBezier: (path: Path | QuadraticBezier | CubicBezier) => path is QuadraticBezier;\nexport declare const isCubicBezier: (path: Path | CubicBezier | QuadraticBezier) => path is CubicBezier;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n *\n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport declare const quadraticSimple: (start: Point, end: Point, bend?: number) => QuadraticBezier;\n/**\n * Returns a relative point on a simple quadratic\n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n *\n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q\n * @returns\n */\nexport declare const interpolator: (q: QuadraticBezier | CubicBezier) => (amount: number) => Point;\nexport declare const quadraticToSvgString: (start: Point, end: Point, handle: Point) => ReadonlyArray<string>;\nexport declare const toPath: (cubicOrQuadratic: CubicBezier | QuadraticBezier) => CubicBezierPath | QuadraticBezierPath;\nexport declare const cubic: (start: Point, end: Point, cubic1: Point, cubic2: Point) => CubicBezier;\nexport declare const quadratic: (start: Point, end: Point, handle: Point) => QuadraticBezier;\n//# sourceMappingURL=index.d.ts.map","import type { Circle } from \"./circle-type.js\";\n/**\n * Returns the area of `circle`.\n * @param circle\n * @returns\n */\nexport declare const area: (circle: Circle) => number;\n//# sourceMappingURL=area.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns\n */\nexport declare const bbox: (circle: CirclePositioned | Circle) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\n/**\n * Returns the center of a circle\n *\n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n *\n * ```js\n * const circle = { radius: 5, x: 10, y: 10};\n *\n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n *\n * It's a trivial function, but can make for more understandable code\n * @param circle\n * @returns Center of circle\n */\nexport declare const center: (circle: CirclePositioned | Circle) => Readonly<{\n    x: number;\n    y: number;\n}>;\n//# sourceMappingURL=center.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CompoundPath, Dimensions, Path } from './path-type.js';\nimport type { RectPositioned } from '../rect/rect-types.js';\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport declare const setSegment: (compoundPath: CompoundPath, index: number, path: Path) => CompoundPath;\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport declare const interpolate: (paths: readonly Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => Point;\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths\n * @param point\n * @returns\n */\nexport declare const distanceToPoint: (paths: readonly Path[], point: Point) => number;\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold\n * @param dimensions Pre-computed dimensions\n * @returns\n */\nexport declare const relativePosition: (paths: readonly Path[], point: Point, intersectionThreshold: number, dimensions?: Dimensions) => number;\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport declare const computeDimensions: (paths: readonly Path[]) => Dimensions;\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport declare const bbox: (paths: readonly Path[]) => RectPositioned;\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport declare const toString: (paths: readonly Path[]) => string;\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport declare const guardContinuous: (paths: readonly Path[]) => void;\nexport declare const toSvgString: (paths: readonly Path[]) => readonly string[];\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport declare const fromPaths: (...paths: readonly Path[]) => CompoundPath;\n//# sourceMappingURL=compound-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Path } from \"./path-type.js\";\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport declare const getStart: (path: Path) => Point;\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport declare const getEnd: (path: Path) => Point;\n//# sourceMappingURL=start-end.d.ts.map","export * from './compound-path.js';\nexport type * from './path-type.js';\nexport * from './start-end.js';\n//# sourceMappingURL=index.d.ts.map","import type { Path } from \"../path/index.js\";\nimport type { Circle } from \"./circle-type.js\";\nexport type CircularPath = Circle & Path & {\n    readonly kind: `circular`;\n};\n//# sourceMappingURL=circular-path.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns the distance between two circle centers.\n *\n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a\n * @param b\n * @returns Distance\n */\nexport declare const distanceCenter: (a: CirclePositioned, b: CirclePositioned | Point) => number;\n//# sourceMappingURL=distance-center.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n *\n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b\n */\nexport declare const distanceFromExterior: (a: CirclePositioned, b: CirclePositioned | Point) => number;\n//# sourceMappingURL=distance-from-exterior.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n *\n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport declare function exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point>;\n//# sourceMappingURL=exterior-points.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle-type.js';\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle\n * @param parameterName\n */\nexport declare const guard: (circle: CirclePositioned | Circle, parameterName?: string) => void;\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle\n * @param parameterName\n * @returns\n */\nexport declare const guardPositioned: (circle: CirclePositioned, parameterName?: string) => void;\n/***\n * Returns true if radius, x or y are NaN\n */\nexport declare const isNaN: (a: Circle | CirclePositioned) => boolean;\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n *\n * ```js\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n *\n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns\n */\nexport declare const isPositioned: (p: Circle | Point) => p is Point;\nexport declare const isCircle: (p: any) => p is Circle;\nexport declare const isCirclePositioned: (p: any) => p is CirclePositioned;\n//# sourceMappingURL=guard.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns all integer points contained within `circle`.\n *\n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport declare function interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point>;\n//# sourceMappingURL=interior-points.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\n/**\n * Computes relative position along circle perimeter\n *\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n *\n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle\n * @param t Position, 0-1\n * @returns\n */\nexport declare const interpolate: (circle: CirclePositioned, t: number) => Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n *\n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport declare const isIntersecting: (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number) => boolean;\n//# sourceMappingURL=intersecting.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Line } from \"../line/line-type.js\";\n/**\n * Returns the point(s) of intersection between a circle and line.\n *\n * ```js\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle\n * @param line\n * @returns Point(s) of intersection, or empty array\n */\nexport declare const intersectionLine: (circle: CirclePositioned, line: Line) => readonly Point[];\n/**\n *\n * Returns the points of intersection betweeen `a` and `b`.\n *\n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport declare const intersections: (a: CirclePositioned, b: CirclePositioned) => readonly Point[];\n//# sourceMappingURL=intersections.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n *\n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n *\n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport declare const isContainedBy: (a: CirclePositioned, b: CirclePositioned | Point, c?: number) => boolean;\n//# sourceMappingURL=is-contained-by.d.ts.map","import type { Circle, CirclePositioned } from \"./circle-type.js\";\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n *\n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n *\n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: CirclePositioned | Circle, b: CirclePositioned | Circle) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nexport declare function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport declare function multiplyScalar(a: Circle, value: number): Circle;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned } from \"./circle-type.js\";\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n *\n * ```js\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n *\n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport declare const nearest: (circle: CirclePositioned | readonly CirclePositioned[], point: Point) => Point;\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n *\n * ```js\n * // Circle without position\n * const circleA = { radius: 5 };\n *\n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n *\n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport declare const pointOnPerimeter: (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point) => Point;\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle\n * @returns\n */\nexport declare const circumference: (circle: Circle) => number;\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle\n * @returns\n */\nexport declare const length: (circle: Circle) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./circle-type.js\";\n/**\n * Returns a random point within a circle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n *\n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns\n */\nexport declare const randomPoint: (within: Circle | CirclePositioned, opts?: Partial<CircleRandomPointOpts>) => Point;\n//# sourceMappingURL=random.d.ts.map","import type { CircleToSvg } from \"./circle-type.js\";\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns\n */\nexport declare const toSvg: CircleToSvg;\n//# sourceMappingURL=svg.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { CircularPath } from \"./circular-path.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport declare const toPath: (circle: CirclePositioned) => CircularPath;\n//# sourceMappingURL=to-path.d.ts.map","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle\n * @param defaultPositionOrX\n * @param y\n * @returns\n */\nexport declare const toPositioned: (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number) => CirclePositioned;\n//# sourceMappingURL=to-positioned.d.ts.map","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport type * from './circle-type.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n//# sourceMappingURL=index.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a parallel line to `line` at `distance`.\n *\n * ```js\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance\n */\nexport declare const parallel: (line: Line, distance: number) => Line;\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport declare const perpendicularPoint: (line: Line, distance: number, amount?: number) => {\n    x: number;\n    y: number;\n};\n//# sourceMappingURL=angles.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n *\n * ```js\n * const rect = Lines.bbox(line);\n * ```\n */\nexport declare const bbox: (line: Line) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n *\n * ```js\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns\n */\nexport declare const distanceSingleLine: (line: Line, point: Point) => number;\n//# sourceMappingURL=distance-single-line.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Divides both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n *\n * Dividing by zero will give Infinity for that dimension.\n * @param line\n * @param point\n * @returns\n */\nexport declare const divide: (line: Line, point: Point) => Line;\n//# sourceMappingURL=divide.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n *\n * See {@link toFlatArray} to create an array from a line.\n *\n * ```js\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport declare const fromFlatArray: (array: readonly number[]) => Line;\n//# sourceMappingURL=from-flat-array.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n *\n * ```js\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns\n */\nexport declare const fromNumbers: (x1: number, y1: number, x2: number, y2: number) => Line;\n//# sourceMappingURL=from-numbers.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a line from two points\n *\n * ```js\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns\n */\nexport declare const fromPoints: (a: Point, b: Point) => Line;\n//# sourceMappingURL=from-points.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n *\n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n *\n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line.\n * * Angle of 45deg will be angled downwards.\n *\n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport declare const fromPivot: (origin?: Point, length?: number, angleRadian?: number, balance?: number) => Readonly<{\n    a: Point;\n    b: Point;\n}>;\n//# sourceMappingURL=from-pivot.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nexport type LinePath = Line & Path & {\n    toFlatArray(): ReadonlyArray<number>;\n    toPoints(): ReadonlyArray<Point>;\n    rotate(amountRadian: number, origin: Point): LinePath;\n    sum(point: Point): LinePath;\n    divide(point: Point): LinePath;\n    multiply(point: Point): LinePath;\n    subtract(point: Point): LinePath;\n    apply(fn: (point: Point) => Point): LinePath;\n    midpoint(): Point;\n    parallel(distance: number): Line;\n    perpendicularPoint(distance: number, amount?: number): Point;\n    slope(): number;\n    withinRange(point: Point, maxRange: number): boolean;\n    isEqual(otherLine: Line): boolean;\n};\n//# sourceMappingURL=line-path-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { LinePath } from \"./line-path-type.js\";\n/**\n * Returns a {@link LinePath} from two points\n *\n * ```js\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const fromPointsToPath: (a: Point, b: Point) => LinePath;\n//# sourceMappingURL=from-points-to-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine\n * @param b\n * @returns\n */\nexport declare const getPointParameter: (aOrLine: Point | Line, b?: Point) => readonly [Point, Point];\n//# sourceMappingURL=get-points-parameter.d.ts.map","import type { Line, PolyLine } from \"./line-type.js\";\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport declare const isLine: (p: any) => p is Line;\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p\n * @returns\n */\nexport declare const isPolyLine: (p: any) => p is PolyLine;\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n *\n * Does not validate points\n * @param line\n * @param name\n */\nexport declare const guard: (line: Line, name?: string) => void;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n *\n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n *\n * ```js\n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n *\n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport declare function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n/**\n * Calculates a point in-between `line`'s start and end points.\n *\n * ```js\n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n *\n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1\n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport declare function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns\n */\nexport declare function pointAtDistance(line: Line, distance: number, fromA?: boolean): Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n *\n * ```js\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport declare const isEqual: (a: Line, b: Line) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { PolyLine } from \"./line-type.js\";\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n *\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n *\n * ```js\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points\n * @returns\n */\nexport declare const joinPointsToLines: (...points: readonly Point[]) => PolyLine;\n//# sourceMappingURL=join-points-to-lines.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n/**\n * Returns the length between two points\n * ```js\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns\n */\nexport declare function length(a: Point, b: Point): number;\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n *\n * ```js\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport declare function length(line: Line | PolyLine): number;\n//# sourceMappingURL=length.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n *\n * ```js\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine\n * @param pointB\n * @returns\n */\nexport declare const midpoint: (aOrLine: Point | Line, pointB?: Point) => Point;\n//# sourceMappingURL=midpoint.d.ts.map","import type { Line } from \"./line-type.js\";\nimport { type Point } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const multiply: (line: Line, point: Point) => Line;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n *\n * ```js\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport declare const nearest: (line: Line | readonly Line[], point: Point) => Point;\n//# sourceMappingURL=nearest.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line\n * @param pt\n */\nexport declare const relativePosition: (line: Line, pt: Point) => number;\n//# sourceMappingURL=relative-position.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line\n * @returns\n */\nexport declare function reverse(line: Line): Line;\n//# sourceMappingURL=reverse.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n *\n * ```js\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n *\n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n *\n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n *\n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns\n */\nexport declare const rotate: (line: Line, amountRadian?: number, origin?: Point | number) => Line;\n//# sourceMappingURL=rotate.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const subtract: (line: Line, point: Point) => Line;\n//# sourceMappingURL=subtract.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Adds both start and end points by given x,y\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const sum: (line: Line, point: Point) => Line;\n//# sourceMappingURL=sum.d.ts.map","import type { LinePath } from \"./line-path-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n *\n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n *\n * ```js\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n *\n * // Now we can use it...\n * l.length();\n *\n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line\n * @returns\n */\nexport declare const toPath: (line: Line) => LinePath;\n//# sourceMappingURL=to-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a string representation of two points\n * ```js\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare function toString(a: Point, b: Point): string;\n/**\n * Returns a string representation of a line\n * ```js\n * Lines.toString(line);\n * ```\n * @param line\n */\nexport declare function toString(line: Line): string;\n//# sourceMappingURL=to-string.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Line } from './line-type.js';\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport type * from './line-path-type.js';\nexport type * from './line-type.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\nexport declare const Empty: Readonly<{\n    a: Readonly<{\n        x: 0;\n        y: 0;\n    }>;\n    b: Readonly<{\n        x: 0;\n        y: 0;\n    }>;\n}>;\nexport declare const Placeholder: Readonly<{\n    a: Readonly<{\n        x: number;\n        y: number;\n    }>;\n    b: Readonly<{\n        x: number;\n        y: number;\n    }>;\n}>;\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l\n * @returns\n */\nexport declare const isEmpty: (l: Line) => boolean;\nexport declare const isPlaceholder: (l: Line) => boolean;\n/**\n * Applies `fn` to both start and end points.\n *\n * ```js\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n *\n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n *\n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns\n */\nexport declare const apply: (line: Line, fn: (p: Point) => Point) => Readonly<Line>;\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint\n * @param b\n * @returns\n */\nexport declare const angleRadian: (lineOrPoint: Line | Point, b?: Point) => number;\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line\n * @param width\n * @param height\n * @returns\n */\nexport declare const normaliseByRect: (line: Line, width: number, height: number) => Line;\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n *\n * ```js\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange\n * @returns True if point is within range\n */\nexport declare const withinRange: (line: Line, point: Point, maxRange: number) => boolean;\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n *\n * @example\n * ```js\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns\n */\nexport declare const slope: (lineOrPoint: Line | Point, b?: Point) => number;\n/**\n * Scales a line from its midpoint\n *\n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor\n */\nexport declare const scaleFromMidpoint: (line: Line, factor: number) => Line;\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport declare const pointAtX: (line: Line, x: number) => Point;\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport declare const extendFromA: (line: Line, distance: number) => Line;\n/**\n * Yields every integer point along `line`.\n *\n * @example Basic usage\n * ```js\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n *\n * Some precision is lost as start and end\n * point is also returned as an integer.\n *\n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\nexport declare function pointsOf(line: Line): Generator<Point>;\n/**\n * Returns the distance of `point` to the\n * nearest point on `line`.\n *\n * ```js\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport declare const distance: (line: Line | readonly Line[], point: Point) => number;\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n *\n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport declare const toFlatArray: (a: Point | Line, b: Point) => readonly number[];\n/**\n * Yields all the points of all the lines.\n *\n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines\n */\nexport declare function asPoints(lines: Iterable<Line>): Generator<Point, void, unknown>;\n/**\n * Returns an SVG description of line\n * ```\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const toSvgString: (a: Point, b: Point) => readonly string[];\n//# sourceMappingURL=index.d.ts.map","import type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Path } from \"./path/path-type.js\";\nimport type { Point } from \"./point/point-type.js\";\nexport type Waypoint = CirclePositioned;\nexport type WaypointOpts = {\n    readonly maxDistanceFromLine: number;\n    readonly enforceOrder: boolean;\n};\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints\n * @param opts\n * @returns\n */\nexport declare const fromPoints: (waypoints: readonly Point[], opts?: Partial<WaypointOpts>) => Waypoints;\n/**\n * Result\n */\nexport type WaypointResult = {\n    /**\n     * Path being compared against\n     */\n    path: Path;\n    /**\n     * Index of this path in original `paths` array\n     */\n    index: number;\n    /**\n     * Nearest point on path. See also {@link distance}\n     */\n    nearest: Point;\n    /**\n     * Closest distance to path. See also {@link nearest}\n     */\n    distance: number;\n    /**\n     * Rank of this result, 0 being highest.\n     */\n    rank: number;\n    /**\n     * Relative position on this path segment\n     * 0 being start, 0.5 middle and so on.\n     */\n    positionRelative: number;\n};\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => WaypointResult[];\n/**\n * Initialise\n *\n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths\n * @param opts\n * @returns\n */\nexport declare const init: (paths: readonly Path[], opts?: Partial<WaypointOpts>) => Waypoints;\n//# sourceMappingURL=waypoint.d.ts.map","import type { RandomSource } from \"@ixfx/random\";\nimport { type ShapePositioned } from \"./shape/index.js\";\nimport type { Circle, CirclePositioned } from \"./circle/circle-type.js\";\nexport type RandomOpts = {\n    readonly attempts?: number;\n    readonly randomSource?: RandomSource;\n};\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport declare const random: (circles: readonly Circle[], container: ShapePositioned, opts?: RandomOpts) => CirclePositioned[];\n//# sourceMappingURL=circle-packing.d.ts.map","export * as CirclePacking from './circle-packing.js';\n//# sourceMappingURL=layout.d.ts.map","import type { Point } from './point/point-type.js';\nimport type { Path } from './path/index.js';\n/**\n * An ellipse\n */\nexport type Ellipse = {\n    readonly radiusX: number;\n    readonly radiusY: number;\n    /**\n     * Rotation, in radians\n     */\n    readonly rotation?: number;\n    readonly startAngle?: number;\n    readonly endAngle?: number;\n};\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse;\nexport declare const fromDegrees: (radiusX: number, radiusY: number, rotationDeg?: number, startAngleDeg?: number, endAngleDeg?: number) => Ellipse;\nexport type EllipticalPath = Ellipse & Path & {\n    readonly kind: `elliptical`;\n};\n//# sourceMappingURL=ellipse.d.ts.map","import type { Point } from './point/point-type.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees\n * @returns\n */\nexport declare function degreeToRadian(angleInDegrees: number): number;\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees\n */\nexport declare function degreeToRadian(angleInDegrees: readonly number[]): readonly number[];\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians\n * @returns\n */\nexport declare function radianInvert(angleInRadians: number): number;\nexport declare function degreeToGradian(angleInDegrees: number): number;\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians\n * @param wrap\n * @returns\n */\nexport declare function gradianToDegree(angleInGradians: number, wrap?: boolean): number;\nexport declare function radianToGradian(angleInRadians: number): number;\nexport declare function gradianToRadian(angleInGradian: number): number;\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns\n */\nexport declare function radianToDegree(angleInRadians: number): number;\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians\n */\nexport declare function radianToDegree(angleInRadians: readonly number[]): readonly number[];\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point\n * @returns\n */\nexport declare const radiansFromAxisX: (point: Point) => number;\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport declare const radiansSum: (start: number, amount: number, clockwise?: boolean) => number;\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n *\n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport declare const degreesSum: (start: number, amount: number, clockwise?: boolean) => number;\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n *\n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n *\n * See {@link degreeArc} to operate in degrees.\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport declare const radianArc: (start: number, end: number, clockwise?: boolean) => number;\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n *\n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n *\n * See {@link radianArc} to operate in radians.\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport declare const degreeArc: (start: number, end: number, clockwise?: boolean) => number;\nexport type Angle = {\n    value: number;\n    unit: `deg` | `rad` | `turn` | `grad`;\n};\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n *\n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n *\n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n *\n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value\n * @returns\n */\nexport declare const angleParse: (value: string | number | Angle) => Angle;\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n *\n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n *\n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n *\n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees\n * @param destination\n * @returns\n */\nexport declare const angleConvert: (angleOrDegrees: Angle | number | string, destination: Angle[`unit`]) => Angle;\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so\n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns\n * @param wrap\n * @returns\n */\nexport declare const turnToDegree: (turns: number, wrap?: boolean) => number;\nexport declare const turnToRadian: (turns: number) => number;\nexport declare const degreeToTurn: (degrees: number) => number;\nexport declare const radianToTurn: (radians: number) => number;\n//# sourceMappingURL=angles.d.ts.map","import type { Point } from \"./point/point-type.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport declare const rdpShortestDistance: (points: Array<Point>, epsilon?: number) => Array<Point>;\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport declare const rdpPerpendicularDistance: (points: Array<Point>, epsilon?: number) => Array<Point>;\n//# sourceMappingURL=curve-simplification.d.ts.map","import { type TraversableTree } from '@ixfx/collections';\nimport type { Point } from './point/point-type.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/rect-types.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n    /**\n     * Maximum items per node\n     */\n    readonly maxItems: number;\n    /**\n     * Maximum level of sub-division\n     */\n    readonly maxLevels: number;\n};\n/**\n * Direction\n */\nexport declare enum Direction {\n    Nw = 0,\n    Ne = 1,\n    Sw = 2,\n    Se = 3\n}\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport declare const quadTree: (bounds: RectPositioned, initialData?: readonly QuadTreeItem[], opts?: Partial<QuadTreeOpts>) => QuadTreeNode;\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n *\n */\nexport declare class QuadTreeNode implements TraversableTree<QuadTreeItem[]> {\n    #private;\n    readonly boundary: RectPositioned;\n    readonly level: number;\n    readonly opts: QuadTreeOpts;\n    /**\n     * Constructor\n     * @param boundary\n     * @param level\n     * @param opts\n     */\n    constructor(parent: QuadTreeNode | undefined, boundary: RectPositioned, level: number, opts: QuadTreeOpts);\n    getLengthChildren(): number;\n    parents(): IterableIterator<QuadTreeNode>;\n    getParent(): QuadTreeNode | undefined;\n    /**\n     * Iterates over immediate children\n     */\n    children(): IterableIterator<QuadTreeNode>;\n    /**\n     * Array of QuadTreeItem\n     * @returns\n     */\n    getValue(): QuadTreeItem[];\n    getIdentity(): this;\n    /**\n     * Get a descendant node in a given direction\n     * @param d\n     * @returns\n     */\n    direction(d: Direction): QuadTreeNode | undefined;\n    /**\n     * Add an item to the quadtree\n     * @param p\n     * @returns False if item is outside of boundary, True if item was added\n     */\n    add(p: QuadTreeItem): boolean;\n    /**\n     * Returns true if point is inside node's boundary\n     * @param p\n     * @returns\n     */\n    couldHold(p: Point): boolean;\n}\n//# sourceMappingURL=quad-tree.d.ts.map","import type { Point } from './point/point-type.js';\nimport type { Rect } from './rect/index.js';\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (a: number | Point, b?: number | Rect, c?: number | Rect, d?: number) => Point;\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n    /**\n     * Relative to absolute coordinates\n     */\n    readonly abs: Scaler;\n    /**\n     * Absolute to relative coordintes\n     */\n    readonly rel: Scaler;\n    readonly width: number;\n    readonly height: number;\n    computeScale(): Point;\n};\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport declare const scaler: (scaleBy?: ScaleBy, defaultRect?: Rect) => ScalerCombined;\n//# sourceMappingURL=scaler.d.ts.map","import type { Line } from './line/line-type.js';\nimport type { Point } from './point/point-type.js';\nimport * as Polar from './polar/index.js';\nexport type Vector = Point | Polar.Coord;\nexport declare const fromRadians: (radians: number) => Readonly<{\n    x: number;\n    y: number;\n}>;\nexport declare const toRadians: (point: Point) => number;\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2\n * if `bipolar` normalisation is used, direction will be fixed to -...\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport declare const fromPointPolar: (pt: Point, angleNormalisation?: `` | `unipolar` | `bipolar`, origin?: Point) => Polar.Coord;\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport declare const fromLineCartesian: (line: Line) => Point;\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport declare const fromLinePolar: (line: Line) => Polar.Coord;\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport declare const normalise: (v: Vector) => Vector;\nexport declare const quadrantOffsetAngle: (p: Point) => number;\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport declare const toPolar: (v: Vector, origin?: {\n    readonly x: 0;\n    readonly y: 0;\n}) => Polar.Coord;\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport declare const toCartesian: (v: Vector) => Point;\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport declare const toString: (v: Vector, digits?: number) => string;\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport declare const dotProduct: (a: Vector, b: Vector) => number;\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport declare const clampMagnitude: (v: Vector, max?: number, min?: number) => Point | Polar.Coord;\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport declare const sum: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport declare const subtract: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport declare const multiply: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport declare const divide: (a: Vector, b: Vector) => Point | Polar.Coord;\n//# sourceMappingURL=vector.d.ts.map","import type { Point, Point3d } from './point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle/circle-type.js';\nimport type { Sphere } from './shape/index.js';\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n    /**\n     * Upper limit of points to produce.\n     * By default, 5000.\n     */\n    readonly maxPoints?: number;\n    /**\n     * Density value (0..1) which determines spacing of points.\n     * This is useful because it scales with whatever circle radius is given\n     * Use this parameter OR the `spacing` parameter.\n     */\n    readonly density?: number;\n    /**\n     * Spacing between points.\n     * Use this option OR the density value.\n     */\n    readonly spacing?: number;\n    /**\n     * Rotation offset to apply, in radians. 0 by default\n     */\n    readonly rotation?: number;\n};\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport declare function circleVogelSpiral(circle?: Circle, opts?: VogelSpiralOpts): IterableIterator<Point>;\nexport type CircleRingsOpts = {\n    readonly rings?: number;\n    /**\n     * Rotation offset, in radians\n     */\n    readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport declare function circleRings(circle?: Circle | CirclePositioned, opts?: CircleRingsOpts): IterableIterator<Point>;\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport declare function sphereFibonacci(samples?: number, rotationRadians?: number, sphere?: Sphere): IterableIterator<Point3d>;\n//# sourceMappingURL=surface-points.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport declare const angles: (t: Triangle) => ReadonlyArray<number>;\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport declare const anglesDegrees: (t: Triangle) => ReadonlyArray<number>;\n//# sourceMappingURL=angles.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport declare const area: (t: Triangle) => number;\n//# sourceMappingURL=area.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { BarycentricCoord, Triangle } from \"./triangle-type.js\";\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport declare const barycentricCoord: (t: Triangle, a: Point | number, b?: number) => BarycentricCoord;\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport declare const barycentricToCartestian: (t: Triangle, bc: BarycentricCoord) => Point;\n//# sourceMappingURL=barycentric.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport declare const bbox: (t: Triangle, inflation?: number) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport declare const centroid: (t: Triangle) => Point;\n//# sourceMappingURL=centroid.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport declare const corners: (t: Triangle) => ReadonlyArray<Point>;\n//# sourceMappingURL=corners.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\nexport declare const Empty: Readonly<{\n    a: {\n        x: number;\n        y: number;\n    };\n    b: {\n        x: number;\n        y: number;\n    };\n    c: {\n        x: number;\n        y: number;\n    };\n}>;\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\nexport declare const Placeholder: Readonly<{\n    a: {\n        x: number;\n        y: number;\n    };\n    b: {\n        x: number;\n        y: number;\n    };\n    c: {\n        x: number;\n        y: number;\n    };\n}>;\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport declare const equilateralFromVertex: (origin?: Point, length?: number, angleRadian?: number) => Triangle;\n//# sourceMappingURL=create.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { PolyLine } from \"../line/line-type.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport declare const edges: (t: Triangle) => PolyLine;\n//# sourceMappingURL=edges.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport declare const fromRadius: (origin: Point, radius: number, opts?: {\n    readonly initialAngleRadian?: number;\n}) => Triangle;\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport declare const fromFlatArray: (coords: readonly number[]) => Triangle;\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport declare const fromPoints: (points: readonly Point[]) => Triangle;\n//# sourceMappingURL=from.d.ts.map","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport declare const innerCircle: (t: Triangle) => CirclePositioned;\n//# sourceMappingURL=inner-circle.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport declare const intersectsPoint: (t: Triangle, a: Point | number, b?: number) => boolean;\n//# sourceMappingURL=intersects.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport declare const isEquilateral: (t: Triangle) => boolean;\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport declare const isIsosceles: (t: Triangle) => boolean;\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport declare const isRightAngle: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport declare const isOblique: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport declare const isAcute: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport declare const isObtuse: (t: Triangle) => boolean;\n//# sourceMappingURL=kinds.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport declare const lengths: (t: Triangle) => ReadonlyArray<number>;\n//# sourceMappingURL=lengths.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport declare const apply: (t: Triangle, fn: (p: Point, label?: string) => Point) => Readonly<Triangle>;\n//# sourceMappingURL=math.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { CirclePositioned } from '../circle/circle-type.js';\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport declare const outerCircle: (t: Triangle) => CirclePositioned;\n//# sourceMappingURL=outer-circle.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport declare const perimeter: (t: Triangle) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n *\n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport declare const rotate: (triangle: Triangle, amountRadian?: number, origin?: Point) => Triangle;\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport declare const rotateByVertex: (triangle: Triangle, amountRadian: number, vertex?: `a` | `b` | `c`) => Triangle;\n//# sourceMappingURL=rotate.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport declare const toFlatArray: (t: Triangle) => readonly number[];\n//# sourceMappingURL=to.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport declare const guard: (t: Triangle, name?: string) => void;\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport declare const isTriangle: (p: unknown) => p is Triangle;\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport declare const isEmpty: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport declare const isPlaceholder: (t: Triangle) => boolean;\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: Triangle, b: Triangle) => boolean;\n//# sourceMappingURL=guard.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type TriangleEquilateral = {\n    readonly length: number;\n} | number;\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * *  0: a and c on vertical, b at the tip\n * *  Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * *  Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * *  Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport declare const fromCenter: (t: TriangleEquilateral, origin?: Point, rotationRad?: number) => Triangle;\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport declare const centerFromA: (t: TriangleEquilateral, ptA?: Point) => Point;\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport declare const centerFromB: (t: TriangleEquilateral, ptB?: Point) => Point;\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport declare const centerFromC: (t: TriangleEquilateral, ptC?: Point) => Point;\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport declare const height: (t: TriangleEquilateral) => number;\nexport declare const perimeter: (t: TriangleEquilateral) => number;\nexport declare const area: (t: TriangleEquilateral) => number;\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport declare const circumcircle: (t: TriangleEquilateral) => Circle;\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport declare const incircle: (t: TriangleEquilateral) => Circle;\n//# sourceMappingURL=equilateral.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Right = {\n    readonly adjacent?: number;\n    readonly hypotenuse?: number;\n    readonly opposite?: number;\n};\nexport type DefinedRight = {\n    readonly adjacent: number;\n    readonly hypotenuse: number;\n    readonly opposite: number;\n};\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromA: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromB: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromC: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport declare const resolveLengths: (t: Right) => DefinedRight;\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport declare const height: (t: Right) => number;\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport declare const hypotenuseSegments: (t: Right) => readonly [p: number, q: number];\nexport declare const perimeter: (t: Right) => number;\nexport declare const area: (t: Right) => number;\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport declare const angleAtPointA: (t: Right) => number;\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport declare const angleAtPointB: (t: Right) => number;\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport declare const medians: (t: Right) => readonly [a: number, b: number, c: number];\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport declare const circumcircle: (t: Right) => Circle;\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport declare const incircle: (t: Right) => Circle;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport declare const oppositeFromAdjacent: (angleRad: number, adjacent: number) => number;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport declare const oppositeFromHypotenuse: (angleRad: number, hypotenuse: number) => number;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport declare const adjacentFromHypotenuse: (angleRadian: number, hypotenuse: number) => number;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport declare const adjacentFromOpposite: (angleRadian: number, opposite: number) => number;\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport declare const hypotenuseFromOpposite: (angleRadian: number, opposite: number) => number;\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport declare const hypotenuseFromAdjacent: (angleRadian: number, adjacent: number) => number;\n//# sourceMappingURL=right.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Isosceles = {\n    readonly legs: number;\n    readonly base: number;\n};\nexport declare const baseAngle: (t: Isosceles) => number;\nexport declare const apexAngle: (t: Isosceles) => number;\nexport declare const height: (t: Isosceles) => number;\nexport declare const legHeights: (t: Isosceles) => number;\nexport declare const perimeter: (t: Isosceles) => number;\nexport declare const area: (t: Isosceles) => number;\nexport declare const circumcircle: (t: Isosceles) => Circle;\nexport declare const incircle: (t: Isosceles) => Circle;\nexport declare const medians: (t: Isosceles) => readonly [a: number, b: number, c: number];\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromCenter: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromA: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromB: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromC: (t: Isosceles, origin?: Point) => Triangle;\n//# sourceMappingURL=isosceles.d.ts.map","export type * from './triangle-type.js';\nexport * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './inner-circle.js';\nexport * from './intersects.js';\nexport * from './kinds.js';\nexport * from './lengths.js';\nexport * from './math.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\nexport * from './to.js';\nexport * from './guard.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\nexport * as Isosceles from './isosceles.js';\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n//# sourceMappingURL=index.d.ts.map","/**\n * Arcs are a angle-limited circle. Essentially describing a wedge.\n */\nexport * as Arcs from './arc/index.js';\nexport type * from './arc/arc-type.js';\nexport * as Beziers from './bezier/index.js';\nexport type * from './bezier/bezier-type.js';\n/**\n * A circle is defined as having a radius\n */\nexport * as Circles from './circle/index.js';\nexport type * from './circle/circle-type.js';\nexport * as Grids from './grid/index.js';\nexport type * from './grid/types.js';\nexport * as Lines from './line/index.js';\nexport type * from './line/line-path-type.js';\nexport type * from './line/line-type.js';\nexport * as Paths from './path/index.js';\nexport type * from './path/path-type.js';\nexport * as Points from './point/index.js';\nexport type * from './point/point-type.js';\nexport type * from './point/point-relation-types.js';\n/**\n * Work with Polar coordinates.\n * A {@link Polar.Coord} is just `{ angleRadians:number, distance: number }`.\n *\n * Conversion: {@link toCartesian}, {@link fromCartesian}, {@link toString}\n *\n * Math: {@link divide}, {@link invert}, {@link multiply}, {@link dotProduct}\n *\n * Geometric manipulations: {@link rotate}, {@link rotateDegrees}\n *\n * Cleaning: {@link clampMagnitude}, {@link normalise}\n *\n * Debugging: {@link toString}\n *\n * Comparisons: {@link isAntiParallel}, {@link isOpposite}, {@link isParallel}, {@link isPolarCoord}\n */\nexport * as Polar from './polar/index.js';\nexport type * from './polar/types.js';\nexport * as Rects from './rect/index.js';\nexport type * from './rect/rect-types.js';\n/**\n * Generate a few basic geometric shapes\n * Overview:\n * * {@link arrow}\n * * {@link starburst}\n */\nexport * as Shapes from './shape/index.js';\nexport type * from './shape/shape-type.js';\nexport * as Waypoints from './waypoint.js';\nexport * as Layouts from './layout.js';\nexport * from './point/point-tracker.js';\nexport * as Compound from './path/compound-path.js';\nexport * as Ellipses from './ellipse.js';\nexport * from './angles.js';\nexport * as CurveSimplification from './curve-simplification.js';\n/**\n * Quad tree is a datastructure for efficiently determining whether\n * a point/shape is at a location\n * - {@link quadTree}: Create a quad tree\n */\nexport * as QuadTree from './quad-tree.js';\nexport * from './scaler.js';\n/**\n * Helper functions for working with vectors, which can either be a {@link Points.Point} or Polar {@link Polar.Coord}.\n * While most of the functionality is provided in either of those modules, the Vector module lets you cleanly\n * interoperate between these two coordinates.\n */\nexport * as Vectors from './vector.js';\n/**\n * Functions for producing points within a shape.\n * Useful for creating patterns.\n *\n * Overview:\n * * {@link sphereFibonacci}: Generate points on a sphere\n * * {@link circleVogelSpiral}: Generate a sunflower-esque pattern of points in a circle\n */\nexport * as SurfacePoints from './surface-points.js';\n/**\n * Triangle processing.\n *\n * Helpers for creating:\n * - {@link Triangles.fromFlatArray}: Create from `[ aX, aY, bX, bY, cX, cY ]`\n * - {@link Triangles.fromPoints}: Create from an array of three Points.\n * - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n *\n * There are sub-modules for dealing with particular triangles:\n * - {@link Triangles.Equilateral}: Equilateral triangls\n * - {@link Triangles.Right}: Right-angled triangles\n * - {@link Triangles.Isosceles}: Iscosceles triangles\n *\n * Calculations\n * - {@link angles}: Internal angles in radians. {@link anglesDegrees} for degrees.\n * - {@link area}: Area of triangle\n * - {@link bbox}: Bounding box\n * - {@link centroid}: Centroid of triangle\n * - {@link perimeter}: Calculate perimeter\n * - {@link lengths}: Return array lengths of triangle's edges\n * - {@link rotate}, {@link rotateByVertex}\n *\n * Conversions\n * - {@link edges}: Edges of triangle as {@link Lines.Line}\n * - {@link corners}: Corner positions\n * - {@link innerCircle}: Largest circle to fit within triangle\n * - {@link outerCircle}: Largest circle to enclose triangle\n * - {@link toFlatArray}: Returns an array of coordinates: `[aX, aY, bX, bY, cX, cY]`\n *\n * Comparisons\n * - {@link intersectsPoint}: Whether a point intersects triangle\n * - {@link isEqual}: Check whether two triangles have equal values\n * - {@link isAcute}, {@link isEquilateral}, {@link isIsosceles}, {@link isRightAngle}\n * - {@link isTriangle}: Returns true if object has expected properties of a triangle\n */\nexport * as Triangles from './triangle/index.js';\nexport type * from './triangle/triangle-type.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}