{"version":3,"file":"maps-a_ogDHUT.js","names":[],"sources":["../../core/dist/src/maps.js"],"sourcesContent":["import { defaultComparer } from './comparers.js';\nimport { isEqualDefault } from './is-equal.js';\nimport { toStringDefault, } from './to-string.js';\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (data, target) => {\n    target = Math.round(target);\n    if (data.has(target)) {\n        return target;\n    }\n    else {\n        let offset = 1;\n        while (offset < 1000) {\n            if (data.has(target - offset))\n                return target - offset;\n            else if (data.has(target + offset))\n                return target + offset;\n            offset++;\n        }\n        throw new Error(`Could not find target ${target.toString()}`);\n    }\n};\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = findBySomeKey(data, keys);\n * ```\n * @param data\n * @param keys\n * @returns\n */\nexport const findBySomeKey = (data, keys) => {\n    for (const key of keys) {\n        if (data.has(key))\n            return data.get(key);\n    }\n};\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match. By default uses === comparison.\n * @returns True if key is found\n */\nexport const hasKeyValue = (map, key, value, comparer = isEqualDefault) => {\n    if (!map.has(key))\n        return false;\n    const values = [...map.values()];\n    return values.some((v) => comparer(v, value));\n};\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueCompareMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer Uses === equality by default. Use isEqualValueDefault to compare by value\n */\nexport const deleteByValueCompareMutate = (map, value, comparer = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (comparer(entry[1], value)) {\n            map.delete(entry[0]);\n        }\n    }\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link findEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const findEntryByPredicate = (map, predicate) => {\n    for (const entry of map.entries()) {\n        if (predicate(entry[1], entry[0]))\n            return entry;\n    }\n};\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * Uses JS's === comparison by default. Consider using `isEqualValueDefault` to match by value.\n * An alternative is {@link findEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const findEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (isEqual(entry[1], value))\n            return entry;\n    }\n};\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n * Returns a copy of the input map.\n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\n// export const addKeepingExisting = <V>(\n//   set: ReadonlyMap<string, V> | undefined,\n//   hasher: ToString<V>,\n//   ...values: readonly V[]\n// ) => {\n//   const s = set === undefined ? new Map() : new Map(set);\n//   for (const v of values) {\n//     const hashResult = hasher(v);\n//     if (s.has(hashResult)) continue;\n//     s.set(hashResult, v);\n//   }\n//   return s;\n// };\n/**\n * Mutates `map`, adding each value to it using a\n * function to produce a key. Use {@link addValue} for an immutable version.\n * ```\n * const map = new Map();\n * addValueMutate(map, v=>v.name, { name:`Jane`, size:10 }, { name:`Bob`, size: 9 });\n * // Map consists of entries:\n * // [ `Jane`, { name:`Jane`, size:10 } ],\n * // [ `Bob` { name:`Bob`, size: 9 } ]\n * ```\n *\n * Uses {@link addValueMutator} under the hood.\n * @param map Map to modify. If _undefined_, a new map is created\n * @param hasher Function to generate a string key for a given object value\n * @param values Values to add\n * @param collisionPolicy What to do if the key already exists\n * @returns Map instance\n */\nexport const addValueMutate = (map, hasher, collisionPolicy, ...values) => {\n    const m = map ?? new Map();\n    const f = addValueMutator(m, hasher, collisionPolicy);\n    f(...values);\n    return m;\n};\n/**\n * Adds values to a map, returning a new, modified copy and leaving the original\n * intact.\n *\n * Use {@link addValueMutate} for a mutable\n * @param map Map to start with, or _undefined_ to automatically create a map\n * @param hasher Function to create keys for values\n * @param collisionPolicy What to do if a key already exists\n * @param values Values to add\n * @returns A new map containing values\n */\nexport const addValue = (map, hasher, collisionPolicy, ...values) => {\n    const m = map === undefined ? new Map() : new Map(map);\n    for (const v of values) {\n        const hashResult = hasher(v);\n        if (collisionPolicy !== `overwrite`) {\n            if (m.has(hashResult)) {\n                if (collisionPolicy === `throw`)\n                    throw new Error(`Key '${hashResult}' already in map`);\n                if (collisionPolicy === `skip`)\n                    continue;\n            }\n        }\n        m.set(hashResult, v);\n    }\n    return m;\n};\n/**\n * Returns a function that adds values to a map, using a hashing function to produce a key.\n * Use {@link addValueMutate} if you don't need a reusable function.\n *\n * ```js\n * const map = new Map(); // Create map\n * const mutate = addValueMutator(map, v=>v.name); // Create a mutator using default 'overwrite' policy\n * mutate( { name:`Bob`, size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( {name: `Bob`, size: 11 }); // Change the value stored under key `Bob`.\n * map.get(`Bob`); // { name: `Bob`, size: 11 }\n * ```\n *\n * The 'collision policy' determines what to do if the key already exists. The default behaviour\n * is to overwrite the key, just as Map.set would.\n * ```js\n * const map = new Map();\n * const mutate = addValueMutator(map, v=>v.name, `skip`);\n * mutate( { name:`Bob`,size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( { name:`Bob`, size: 20 }); // This value would be skipped because map already contains 'Bob'\n * map.get(`Bob`); // { name: `Bob`, size: 10 }\n * ```\n *\n * @param map Map to modify\n * @param hasher Hashing function to make a key for a value\n * @param collisionPolicy What to do if a value is already stored under a key\n * @returns Function\n */\nexport const addValueMutator = (map, hasher, collisionPolicy = `overwrite`) => {\n    return (...values) => {\n        for (const v of values) {\n            const hashResult = hasher(v);\n            if (collisionPolicy !== `overwrite`) {\n                if (map.has(hashResult)) {\n                    if (collisionPolicy === `throw`)\n                        throw new Error(`Key '${hashResult}' already in map`);\n                    if (collisionPolicy === `skip`)\n                        continue;\n                }\n            }\n            map.set(hashResult, v);\n        }\n        return map;\n    };\n};\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = (map, comparer) => {\n    const f = comparer ?? defaultComparer;\n    return [...map.entries()].sort((a, b) => f(a[1], b[1]));\n};\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = sortByValueProperty(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = (map, property, compareFunction) => {\n    const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n    return [...map.entries()].sort((aE, bE) => {\n        const a = aE[1];\n        const b = bE[1];\n        return cfn(a[property], b[property]);\n    });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = (map, value, comparer) => {\n    const entries = [...map.entries()];\n    return entries.some((kv) => comparer(kv[1], value));\n};\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filterValues(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filterValues(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\nexport function* filterValues(map, predicate) {\n    for (const v of map.values()) {\n        if (predicate(v))\n            yield v;\n    }\n}\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = (map) => [...map.values()];\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` },\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = fromIterable(data, v => v.fruit);\n * map.get(`granny-smith`); // { fruit: `granny-smith`, family: `apple`, colour: `green` }\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param collisionPolicy By default, values with same key overwrite previous (`overwrite`)\n * @returns\n */\nexport const fromIterable = (data, keyFunction = (toStringDefault), collisionPolicy = `overwrite`) => {\n    const m = new Map();\n    for (const d of data) {\n        const key = keyFunction(d);\n        if (m.has(key)) {\n            if (collisionPolicy === `throw`)\n                throw new Error(`Key '${key}' is already used and new data will overwrite it. `);\n            if (collisionPolicy === `skip`)\n                continue;\n        }\n        m.set(key, d);\n    }\n    return m;\n};\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectEntriesMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = (data) => {\n    const map = new Map();\n    if (Array.isArray(data)) {\n        for (const d of data)\n            addObjectEntriesMutate(map, d);\n    }\n    else {\n        addObjectEntriesMutate(map, data);\n    }\n    return map;\n};\n/**\n * Adds an object to an existing map, mutating it.\n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObjectEntriesMutate(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectEntriesMutate = (map, data) => {\n    const entries = Object.entries(data);\n    for (const [key, value] of entries) {\n        map.set(key, value);\n    }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n * To get an entry see {@link findEntryByPredicate}\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = findValue(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const findValue = (map, predicate) => [...map.values()].find(v => predicate(v));\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link findValue} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map\n * @param predicate\n * @returns\n */\nexport const some = (map, predicate) => [...map.values()].some(v => predicate(v));\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = (m, valueTransform) => [...m].reduce((object, [key, value]) => {\n    const t = valueTransform(value);\n    object[key] = t;\n    return object;\n}, {});\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = (keys, values) => {\n    if (keys.length !== values.length) {\n        throw new Error(`Keys and values arrays should be same length`);\n    }\n    return Object.fromEntries(keys.map((k, index) => [k, values[index]]));\n};\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = (source, transformer) => new Map(Array.from(source, (v) => [v[0], transformer(v[1], v[0])]));\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = (m) => [...m].reduce((object, [key, value]) => {\n    object[key] = value;\n    return object;\n}, {});\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * const person = { age: 29, name: `John`};\n * map.set(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = (m, transformer) => [...m.entries()].map((x) => transformer(x[0], x[1]));\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also @ixfx/arrays/mergeByKey if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 1 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = (reconcile, ...maps) => {\n    const result = new Map();\n    for (const m of maps) {\n        for (const [mk, mv] of m) {\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return result;\n};\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate = (map, fn) => async (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value; //Promise.resolve(value);\n    value = await fn(key, args);\n    if (value === undefined)\n        throw new Error(`fn returned undefined`);\n    map.set(key, value);\n    return value;\n};\n"],"mappings":"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"}