{"version":3,"file":"index-Br1u4-CP.d.ts","names":["Interval","InitStreamOptions","SyncOptions","SwitcherOptions","TransformOpts","ChunkOptions","DebounceOptions","FilterPredicate","In","ThrottleOptions","SplitOptions","FieldOptions","TSource","TValue","SingleFromArrayOptions","V","OpAsAnnotation","OpMathOptions","Partial","IsEqual","Interval","IsEqualContext","CombineLatestOptions","InitLazyStreamOptions","Lazy","UpstreamOptions","TriggerValue","TTriggerValue","CountOptions","AbortSignal","FunctionFunction","T","Promise","ArrayOptions","PingedFunctionFunction","TSource","TriggerFunction","TriggerGenerator","IterableIterator","Trigger","TimeoutPingOptions","TimeoutValueOptions","ObjectOptions","Record","V","ValueToPingOptions","TUpstream","PingedFunctionOptions","ArrayObjectOptions","FunctionOptions","Partial","GeneratorOptions","EventSourceOptions","EventSourceTriggerOptions","EventPluckedFieldOptions","EventPluckedFieldOptions2","TValueDestination","TDomSource","DerivedFunction","TOutput","DerivedOptions","TResult","ReactiveOrSource","SetHtmlOptionsQuery","SetHtmlOptionsElement","HTMLElement","SetHtmlOptions","setHtmlText","___types_js3","Unsubscriber","Reactive","ReactiveOrSource","OpAsAnnotation","OpMathOptions","RankFunction","RankOptions","max","min","average","sum","TallyOptions","tally","Partial","TIn","rank","Interval","Primitive","ChunkOptions","DebounceOptions","FieldOptions","FilterPredicate","SplitOptions","SyncOptions","SwitcherOptions","TransformOpts","ThrottleOptions","OpMathOptions","TimeoutPingOptions","TimeoutValueOptions","SetHtmlOptions","Processors","TallyOptions","ChangeRecord","RecursivePartial","Pathed","CombineLatestOptions","Optional","T","Partial","K","Pick","Omit","symbol","SignalKinds","Passed","V","PassedSignal","PassedValue","UpstreamOptions","Lazy","In","UpstreamInitialOptions","Wrapped","TIn","Reactive","TAnnotation","TOut","ReactiveOp","TSource","TFieldType","InitStreamOptions","ReactiveOrSource","RxValueTypes","Record","RxValueTypeObject","TRec","TLabel","T2","T3","T4","T5","T6","ReactiveWritable","TTriggerValue","ToArrayOptions","Promise","InitLazyStreamOptions","InitLazyStreamInitedOptions","IterableIterator","AsyncIterableIterator","Generator","AsyncGenerator","Unsubscriber","ReactivePingable","ReactiveNonInitial","ReactiveInitial","ReactiveFinite","ReactiveArray","ObjectFieldHandler","ReactiveDiff","PathDataChange","ReactiveStream","ReactiveInitialStream","PipeSet","WithValueOptions","ResolveOptions","ReactiveOpInit","TOpts","ReactiveOpLinks","Out","RxValueTypeObjectOrUndefined","RxValueTypeRx","PrimitiveValueTypeObject","ReactiveOrSource","Reactive","ReactiveOp","TransformOpts","annotate","In","TAnnotation","Partial","annotateWithOp","ReactiveOrSource","Reactive","ChunkOptions","chunk","V","Partial","ReactiveOrSource","cloneFromFields","In","___types_js4","Reactive","ReactiveOrSource","CombineLatestOptions","Reactive","RxValueTypes","combineLatestToArray","T","Partial","ReactiveOrSource","CombineLatestOptions","RxValueTypeObject","ReactiveInitial","RxValueTypeRx","ReactiveDiff","CombineLatestToObject","Record","T","Extract","Partial","combineLatestToObject","ReactiveOrSource","ReactivePingable","computeWithPrevious","TIn","ReactiveOp","DebounceOptions","debounce","Partial","V","ReactiveOrSource","elapsed","In","___types_js0","Reactive","ReactiveOrSource","Reactive","FieldOptions","field","TIn","TFieldType","Partial","ReactiveOrSource","InitStreamOptions","Reactive","FilterPredicate","filter","In","Partial","drop","ReactiveOrSource","ReactivePingable","InterpolateOptions","OpInterpolateOptions","interpolate","Partial","PipeSet","Reactive","pipe","TInput","TOutput","ReactiveOrSource","Reactive","SingleFromArrayOptions","singleFromArray","V","Partial","ReactiveOrSource","ReactiveStream","Reactive","SplitOptions","split","T","Partial","splitLabelled","PropertyKey","K","Record","ReactiveOrSource","Reactive","FilterPredicate","SwitcherOptions","switcher","TValue","Record","TRec","Partial","TLabel","ReactiveOrSource","Reactive","RxValueTypes","SyncOptions","syncToArray","T","Partial","ReactiveOrSource","Reactive","RxValueTypeObject","SyncOptions","syncToObject","Record","T","Partial","Processors","ReactiveOrSource","Reactive","ReactiveWritable","ReactiveOp","tapProcess","In","T2","T3","T4","T5","T6","tapStream","tapOps","TIn","TOut","ReactiveOrSource","Reactive","ThrottleOptions","throttle","V","Partial","ReactiveOrSource","Reactive","TimeoutValueOptions","timeoutValue","TSource","TTriggerValue","ReactiveOrSource","Reactive","TimeoutPingOptions","timeoutPing","TSource","Reactive","ReactiveOrSource","TransformOpts","transform","In","Out","Partial","ValueToPingOptions","Reactive","ReactiveOrSource","ReactivePingable","valueToPing","TSource","TTarget","Partial","ReactiveOrSource","WithValueOptions","ReactiveInitial","withValue","In","Reactive","ReactiveFinite","ReactiveInitial","ArrayOptions","of","V","Iterable","Partial","array","ReactiveInitial","ReactiveArray","ArrayObjectOptions","arrayObject","V","Partial","ReactiveWritable","ReactiveInitial","ReactiveNonInitial","boolean","CountOptions","count","Partial","___types_js5","ReactiveStream","CombineLatestToObject","ReactiveNonInitial","ReactiveOrSource","RxValueTypeObject","DerivedOptions","derived","Record","T","TResult","Partial","Reactive","ReactiveInitial","FieldOptions","EventSourceOptions","EventSourceTriggerOptions","eventField","EventTarget","TFieldValue","Partial","event","Record","TEventArgs","TriggerData","eventTrigger","ReactivePingable","FunctionFunction","FunctionOptions","func","V","Partial","Reactive","GeneratorOptions","iterator","V","IterableIterator","AsyncIterableIterator","Generator","AsyncGenerator","Partial","InitLazyStreamOptions","Reactive","merged","T","mergedWithOptions","Partial","ReactiveWritable","ReactiveInitial","ReactiveNonInitial","number","ReactiveDiff","ReactiveInitial","ReactiveNonInitial","ObjectOptions","object","Record","V","Partial","symbol","ReactiveArray","ReactiveDiff","ReactiveInitial","ReactiveProxied","V","objectProxy","arrayProxy","T","objectProxySymbol","Reactive","ReactiveWritable","observable","V","observableWritable","ReactiveWritable","ReactiveInitial","ReactiveNonInitial","string","IQueueMutableWithEvents","asResponsive","T","___types_js0","Passed","Unsubscriber","Reactive","prepare","Record","V","ReactiveOrSource","ToArrayOptions","toArray","V","Partial","Promise","toArrayOrThrow","ReactiveOrSource","toGenerator","V","AsyncGenerator","Passed","PassedSignal","PassedValue","Reactive","ReactiveDiff","ReactiveInitial","ReactiveOrSource","ReactivePingable","ReactiveWritable","Wrapped","Trigger","TriggerValue","TriggerFunction","TriggerGenerator","messageIsSignal","V","messageIsDoneSignal","messageHasValue","isPingable","hasLast","isReactive","isWritable","isWrapped","T","opify","TIn","TRxOut","isTriggerValue","isTriggerFunction","isTriggerGenerator","isTrigger","ResolveTriggerValue","ResolveTriggerDone","resolveTriggerValue","ReactiveOrSource","Wrapped","wrap","TIn","GeneratorOptions","FunctionOptions","Reactive","ReactiveOrSource","ResolveSourceOptions","resolveSource","V","Partial","Reactive","CacheStream","T","CacheStreamInitial","cache","TValue","RT","InitLazyStreamInitedOptions","InitLazyStreamOptions","InitStreamOptions","ReactiveInitialStream","ReactiveOrSource","ReactiveStream","UpstreamOptions","initUpstream","In","Partial","Out","initLazyStreamWithInitial","V","initLazyStream","initStream","Reactive","ReactiveOrSource","ReactiveWritable","ReactiveOp","InitStreamOptions","WithValueOptions","CombineLatestOptions","RxValueTypes","RxValueTypeObject","ReactivePingable","ChunkOptions","FieldOptions","SingleFromArrayOptions","SplitOptions","FilterPredicate","SwitcherOptions","SyncOptions","ThrottleOptions","RankFunction","RankOptions","TimeoutPingOptions","TimeoutValueOptions","Interval","SinkFns","OpFns","From","Collections","run","writable","TIn","TOut","manual","Partial","V","Sinks","SetHtmlOptions","Ops","TAnnotation","In","TAnnotation_1","T","Record","CombineLatestToObject","TSource","TFieldType","OpInterpolateOptions","OpMathOptions","TallyOptions","TInput","__types_js1","ReactiveStream","TValue","TRec","TLabel","Out","TTriggerValue","TransformOpts","takeNextValue","Promise","to","TA","TB","Unsubscriber"],"sources":["../../rx/dist/src/ops/types.d.ts","../../rx/dist/src/from/types.d.ts","../../rx/dist/src/sinks/dom.d.ts","../../rx/dist/src/ops/math.d.ts","../../rx/dist/src/types.d.ts","../../rx/dist/src/ops/annotate.d.ts","../../rx/dist/src/ops/chunk.d.ts","../../rx/dist/src/ops/clone-from-fields.d.ts","../../rx/dist/src/ops/combine-latest-to-array.d.ts","../../rx/dist/src/ops/combine-latest-to-object.d.ts","../../rx/dist/src/ops/compute-with-previous.d.ts","../../rx/dist/src/ops/debounce.d.ts","../../rx/dist/src/ops/elapsed.d.ts","../../rx/dist/src/ops/field.d.ts","../../rx/dist/src/ops/filter.d.ts","../../rx/dist/src/ops/interpolate.d.ts","../../rx/dist/src/ops/pipe.d.ts","../../rx/dist/src/ops/single-from-array.d.ts","../../rx/dist/src/ops/split.d.ts","../../rx/dist/src/ops/switcher.d.ts","../../rx/dist/src/ops/sync-to-array.d.ts","../../rx/dist/src/ops/sync-to-object.d.ts","../../rx/dist/src/ops/tap.d.ts","../../rx/dist/src/ops/throttle.d.ts","../../rx/dist/src/ops/timeout-value.d.ts","../../rx/dist/src/ops/timeout-ping.d.ts","../../rx/dist/src/ops/transform.d.ts","../../rx/dist/src/ops/value-to-ping.d.ts","../../rx/dist/src/ops/with-value.d.ts","../../rx/dist/src/from/array.d.ts","../../rx/dist/src/from/array-object.d.ts","../../rx/dist/src/from/boolean.d.ts","../../rx/dist/src/from/count.d.ts","../../rx/dist/src/from/derived.d.ts","../../rx/dist/src/from/event.d.ts","../../rx/dist/src/from/function.d.ts","../../rx/dist/src/from/iterator.d.ts","../../rx/dist/src/from/merged.d.ts","../../rx/dist/src/from/number.d.ts","../../rx/dist/src/from/object.d.ts","../../rx/dist/src/from/object-proxy.d.ts","../../rx/dist/src/from/observable.d.ts","../../rx/dist/src/from/string.d.ts","../../rx/dist/src/from/index.d.ts","../../rx/dist/src/collections/responsive-queue.d.ts","../../rx/dist/src/collections/index.d.ts","../../rx/dist/src/graph.d.ts","../../rx/dist/src/to-array.d.ts","../../rx/dist/src/to-generator.d.ts","../../rx/dist/src/util.d.ts","../../rx/dist/src/wrap.d.ts","../../rx/dist/src/resolve-source.d.ts","../../rx/dist/src/cache.d.ts","../../rx/dist/src/init-stream.d.ts","../../rx/dist/src/index.d.ts"],"sourcesContent":["import type { Interval } from '@ixfx/core';\nimport type { InitStreamOptions } from '../types.js';\nexport type SyncOptions = {\n    /**\n     * How to handle when a source completes.\n     * * 'allow' means we continue synchronising with remaining alive sources. Use 'finalValue' option to control what data is returned for completed sources\n     * * 'break' means we stop the stream, because synchronisation across all sources is no longer possible.\n     *\n     * Default: 'break'.\n     */\n    onSourceDone: `allow` | `break`;\n    /**\n     * Maximum time to wait for synchronisation to happen.\n     * If interval is exceeded, stream closes.\n     * Default: 2s\n     */\n    maximumWait: Interval;\n    /**\n     * If we continue synchronisation when a source is done (via `onSourceDone:'allow'`),\n     * what source should be returned for a completed source?\n     * * 'undefined': _undefined_\n     * * 'last': the last received value, or _undefined_\n     *\n     * Default: 'undefined'\n     */\n    finalValue: `undefined` | `last`;\n};\n/**\n * Switcher options.\n *\n * match (default: 'first')\n * * 'first': Outputs to first case where predicate is _true_\n * * 'all': Outputs to all cases where predicate is _true_\n */\nexport type SwitcherOptions = {\n    match: `first` | `all`;\n};\n/**\n * Transform options\n */\nexport type TransformOpts = InitStreamOptions & {\n    traceInput: boolean;\n    traceOutput: boolean;\n};\nexport type ChunkOptions = InitStreamOptions & {\n    /**\n     * If _true_ (default) remaining results are yielded\n     * if source closes. If _false_, only chunks that meet\n     * `elapsed` or `quantity` are emitted.\n     */\n    returnRemainder: boolean;\n    /**\n     * Amount of time to gather results for a chunk.\n     * 'elapsed' and 'quantity' is ORed. Meaning a chunk will the minimum of\n     * 'elapsed' and 'quantity'\n     */\n    elapsed: Interval;\n    /**\n     * Number of items to gather for a chunk.\n     * 'elapsed' and 'quantity' is ORed. Meaning a chunk will the minimum of\n     * 'elapsed' and 'quantity'\n     */\n    quantity: number;\n};\nexport type DebounceOptions = InitStreamOptions & {\n    /**\n     * Minimum time between events. Default 50ms\n     */\n    elapsed: Interval;\n};\nexport type FilterPredicate<In> = (value: In) => boolean;\nexport type ThrottleOptions = InitStreamOptions & {\n    elapsed: Interval;\n};\nexport type SplitOptions = {\n    quantity: number;\n};\nexport type FieldOptions<TSource, TValue> = InitStreamOptions & {\n    /**\n     * If `field` is missing on a value, it is query from this object instead.\n     * If this also is missing, `fallbackFieldValue` is attempted.\n     */\n    fallbackObject: TSource;\n    /**\n     * If `field` is missing on a value and `fallbackObject` (if specified),\n     * this value is used in its place.\n     * If not set, no value is emitted when the field is missing.\n     */\n    fallbackFieldValue: TValue;\n};\nexport type SingleFromArrayOptions<V> = {\n    /**\n     * Function to select a single value from array\n     * @param value\n     * @returns\n     */\n    predicate: (value: V) => boolean;\n    /**\n     * `default`: leave array in same order (default option)\n     * `random`: shuffles array before further processing\n     * function: function that sorts values\n     */\n    order: `default` | `random` | ((a: V, b: V) => number);\n    /**\n     * Selects an index from array. 0 being first, 1 being second.\n     * Reverse indexing also works: -1 being last, -2 being second last...\n     *\n     * If index exceeds length of array, _undefined_ is returned\n     */\n    at: number;\n};\nexport type OpAsAnnotation = {\n    annotate: true;\n};\nexport type OpMathOptions = Partial<InitStreamOptions> & {\n    annotate?: boolean;\n    /**\n     * If _true_ (default) operations that return _undefined_ do not emit a value.\n     * If _false_, _undefined_ is potentially emitted\n     */\n    skipUndefined?: boolean;\n    /**\n     * If _true_ (default) operations only emit a value if it has changed.\n     * In the case of `max()`, for example, a stream of '1, 2, 3, 2, 1' would emit '1, 2, 3'.\n     * If _false_ was used, same input would emit '1, 2, 3, 3, 3'\n     */\n    skipIdentical?: boolean;\n};\n//# sourceMappingURL=types.d.ts.map","import type { IsEqual, Interval, IsEqualContext } from \"@ixfx/core\";\nimport type { CombineLatestOptions, InitLazyStreamOptions, Lazy, UpstreamOptions } from '../types.js';\nexport type TriggerValue<TTriggerValue> = {\n    value: TTriggerValue;\n};\n/**\n * Options for the 'count' source.\n */\nexport type CountOptions = {\n    /**\n     * Determines when counting starts\n     * @defaultValue 'initial'\n     */\n    lazy: Lazy;\n    /**\n     * Amount to increment by\n     * @defaultValue 1\n     */\n    amount: number;\n    /**\n     * Where to begin counting\n     * @defaultValue 0\n     */\n    offset: number;\n    /**\n     * How long to wait before incrementing.\n     * @defaultValue 1 second\n     */\n    interval: Interval;\n    /**\n     * Abort signal to trigger the source to close.\n     */\n    signal: AbortSignal;\n};\n/**\n * Function which returns a result. Or promised result.\n *\n * `abort` value is a callback to exit out of looped execution.\n */\nexport type FunctionFunction<T> = ((abort: (reason: string) => void) => T) | ((abort: (reason: string) => void) => Promise<T>);\nexport type ArrayOptions = {\n    /**\n     * Interval between each item being read. Default: 5ms.\n     */\n    interval: Interval;\n    lazy: Lazy;\n    /**\n     * Behaviour when reactive stops, for example due to having no subscribers\n     * * continue: iteration continues through array where it left off\n     * * reset: iteration begins from start of array\n     */\n    whenStopped: `continue` | `reset`;\n    debugLifecycle: boolean;\n    signal: AbortSignal;\n};\n/**\n * Function which returns a result. Or promised result.\n * Takes a `value` as first parameter, and callback to signal an abort as the second.\n */\nexport type PingedFunctionFunction<T, TSource> = ((value: TSource, abort: (reason: string) => void) => T) | ((value: TSource, abort: (reason: string) => void) => Promise<T>);\n/**\n * Trigger that calls a `fn`.\n * If `fn` returns _undefined_, it means the trigger is complete\n */\nexport type TriggerFunction<TTriggerValue> = {\n    fn: () => TTriggerValue;\n};\nexport type TriggerGenerator<TTriggerValue> = {\n    gen: IterableIterator<TTriggerValue>;\n};\n/**\n * A trigger can be a value, a function or generator. Value triggers never complete.\n *\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n */\nexport type Trigger<TTriggerValue> = TriggerValue<TTriggerValue> | TriggerFunction<TTriggerValue> | TriggerGenerator<TTriggerValue>;\nexport type TimeoutPingOptions = Interval & {\n    /**\n     * If abort signals, it will disable\n     */\n    abort?: AbortSignal;\n};\nexport type TimeoutValueOptions<TTriggerValue> = Trigger<TTriggerValue> & {\n    /**\n     * Whether to repeatedly trigger even if upstream source doesn't emit values.\n     * When _false_ (default) it will emit a max of one value after a source value if `interval` is reached.\n     * When _true_, it will continue emitting values at `interval`.\n     * Default: false\n     */\n    repeat?: boolean;\n    /**\n     * Interval before emitting trigger value\n     * Default: 1s\n     */\n    interval: Interval;\n    /**\n     * If _true_ (default) start the timeout\n     * immediately, even before the first value.\n     * If _false_, it won't timeout until the first\n     * upstream value happens.\n     */\n    immediate?: boolean;\n};\n/**\n * Options when creating a reactive object.\n */\nexport type ObjectOptions<V extends Record<string, unknown>> = {\n    /**\n     * _false_ by default.\n     * If _true_, inherited fields are included. This is necessary for event args, for example.\n     */\n    deepEntries: boolean;\n    /**\n     * Uses JSON.stringify() by default.\n     * Fn that returns _true_ if two values are equal, given a certain path.\n     */\n    eq: IsEqualContext<V>;\n};\nexport type ValueToPingOptions<TUpstream> = {\n    /**\n     * If set, this function acts as a threshold gate.\n     * If the function returns _true_ the upstream value will trigger a ping\n     * Otherwise the value won't trigger a ping.\n     *\n     * By default all values trigger a ping.\n     * @param value\n     * @returns\n     */\n    gate: (value: TUpstream) => boolean;\n    /**\n     * Laziness\n     * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n     * * very: only begins on first subscriber. Stops looping if there are no subscribers\n     * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n     */\n    lazy: Lazy;\n    /**\n      * If specified, signal is checked to prevent function execution.\n      * Also used for aborting a looped fromFunction.\n    */\n    signal: AbortSignal;\n};\nexport type PingedFunctionOptions = {\n    /**\n     * If _true_, stream closes if function throws an error.\n     * If _false_, errors are emitted as signals, but stream is not closed.\n     * Default: _true_\n     */\n    closeOnError: boolean;\n    /**\n     * Laziness\n     * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n     * * very: only begins on first subscriber. Stops looping if there are no subscribers\n     * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n     */\n    lazy: Lazy;\n    /**\n      * If specified, a time before invoking function.\n      * If `repeat` is used, this is in addition to `interval` time.\n      */\n    predelay: Interval;\n    /***\n  * If specified, signal is checked to prevent function execution.\n  * Also used for aborting a looped fromFunction.\n  */\n    signal: AbortSignal;\n};\n/**\n * Options when creating a reactive object.\n */\nexport type ArrayObjectOptions<V> = {\n    /**\n     * Uses JSON.stringify() by default.\n     * Fn that returns _true_ if two values are equal, given a certain path.\n     */\n    eq: IsEqual<V>;\n};\nexport type FunctionOptions = Partial<InitLazyStreamOptions> & {\n    /**\n     * If _true_, stream closes if function throws an error.\n     * If _false_, errors are emitted as signals, but stream is not closed.\n     * Default: _true_\n     */\n    closeOnError: boolean;\n    /**\n     * Laziness\n     * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n     * * very: only begins on first subscriber. Stops looping if there are no subscribers\n     * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n     */\n    lazy: Lazy;\n    /**\n     * If _true_, no automatic calling of function will happen, it will only\n     * be executed if the reactive gets a ping\n     * When this is set, 'interval' is ignored. 'maximumRepeats' and 'predelay' still apply.\n     * Default: _false_\n    */\n    manual: boolean;\n    /**\n     * If specified, sets an upper limit of how many times we loop\n     * (if this is also enabled)\n     */\n    maximumRepeats: number;\n    /**\n     * If specified, function is called repeatedly with this delay\n     */\n    interval: Interval;\n    /**\n     * If specified, a time before invoking function.\n     * If `repeat` is used, this is in addition to `interval` time.\n     */\n    predelay: Interval;\n    /***\n     * If specified, signal is checked to prevent function execution.\n     * Also used for aborting a looped fromFunction.\n     */\n    signal: AbortSignal;\n};\nexport type GeneratorOptions = {\n    traceLifecycle: boolean;\n    /**\n     * Wait between reading from generator\n     * Default: 5ms\n     */\n    readInterval: Interval;\n    /**\n     * Timeout when waiting for a value\n     * Default: `{ mins: 5 }`\n     */\n    readTimeout: Interval;\n    /**\n     * If _true_, only accesses the generator if there is a subscriber.\n     * Default: true\n     */\n    lazy: Lazy;\n    signal: AbortSignal;\n    /**\n     * Behaviour when reactive stops, for example due to having no subscribers\n     * * continue: iteration continues through array where it left off\n     * * reset: iteration begins from start of array\n     */\n    whenStopped: `continue` | `reset`;\n};\nexport type EventSourceOptions = {\n    /**\n     * If true, behaves like Source.object where event\n     * properties are compared and source only\n     * emits where there is a change.\n     *\n     * Default: _false_\n     */\n    diff?: boolean;\n    lazy?: Lazy;\n    /**\n     * If true, log messages are emitted\n     * when event handlers are added/removed\n     */\n    debugLifecycle?: boolean;\n    /**\n     * If true, log messages are emitted\n     * when the source event fires\n     */\n    debugFiring?: boolean;\n};\nexport type EventSourceTriggerOptions = EventSourceOptions & {\n    /**\n     * If _true_ sends an initial trigger when starting\n     * Default: false\n     */\n    fireInitial: boolean;\n};\nexport type EventPluckedFieldOptions<T> = {\n    lazy?: Lazy;\n    initialValue: T;\n};\nexport type EventPluckedFieldOptions2<TDomSource, TValueDestination> = {\n    lazy?: Lazy;\n    initialValue: TValueDestination;\n    domToValue: (value: TDomSource | undefined) => TValueDestination | undefined;\n    valueToDom: (value: TValueDestination) => TDomSource;\n};\nexport type DerivedFunction<TOutput> = (...args: unknown[]) => TOutput;\nexport type DerivedOptions<TResult, T> = {\n    ignoreIdentical: boolean;\n    eq: (a: TResult, b: TResult) => boolean;\n} & CombineLatestOptions & UpstreamOptions<T>;\n//# sourceMappingURL=types.d.ts.map","import type { ReactiveOrSource } from \"../types.js\";\nexport type SetHtmlOptionsQuery = {\n    query: string;\n};\nexport type SetHtmlOptionsElement = {\n    el: HTMLElement;\n};\nexport type SetHtmlOptions = (SetHtmlOptionsQuery | SetHtmlOptionsElement) & {\n    /**\n     * If _true_ .innerHTML is used\n     * If _false_ (default) .textContent is used\n     */\n    asHtml?: boolean;\n};\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource\n * @param optionsOrElementOrQuery\n */\nexport declare const setHtmlText: (rxOrSource: ReactiveOrSource<any>, optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement) => import(\"../types.js\").Unsubscriber;\n//# sourceMappingURL=dom.d.ts.map","import type { Reactive, ReactiveOrSource } from \"../types.js\";\nimport type { OpAsAnnotation, OpMathOptions } from \"./types.js\";\nimport type { RankFunction, RankOptions } from \"@ixfx/core\";\nexport declare function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport declare function max(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{\n    value: number;\n    max: number;\n}>;\nexport declare function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport declare function min(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{\n    value: number;\n    min: number;\n}>;\nexport declare function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport declare function average(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{\n    value: number;\n    average: number;\n}>;\nexport declare function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport declare function sum(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{\n    value: number;\n    sum: number;\n}>;\nexport type TallyOptions = OpMathOptions & {\n    countArrayItems: boolean;\n};\nexport declare function tally(input: ReactiveOrSource<any>, options: Partial<TallyOptions>): Reactive<number>;\nexport declare function tally<TIn>(input: ReactiveOrSource<TIn>, options: OpAsAnnotation & Partial<TallyOptions>): Reactive<{\n    value: TIn;\n    tally: number;\n}>;\nexport declare function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn>;\nexport declare function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: OpAsAnnotation & Partial<RankOptions & OpMathOptions>): Reactive<{\n    value: TIn;\n    rank: TIn;\n}>;\n//# sourceMappingURL=math.d.ts.map","import type { Interval, Primitive } from '@ixfx/core';\nimport type { ChunkOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/types.js';\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './from/types.js';\nimport type { SetHtmlOptions } from './sinks/dom.js';\nimport type { Processors } from '@ixfx/process';\nimport type { TallyOptions } from './ops/math.js';\nimport type { ChangeRecord } from '@ixfx/core/records';\nimport type { RecursivePartial } from '@ixfx/core';\nimport { Pathed } from '@ixfx/core';\nexport type CombineLatestOptions = {\n    /**\n     * If _true_, disposes all the merged sources when the merged reactive closes.\n     * Default: _true_.\n     */\n    disposeSources: boolean;\n    /**\n     * How to handle when a source ends.\n     * * 'allow': continue combined stream, last value for done stream will kept\n     * * 'break': stop combined stream\n     *\n     * Default: 'break'\n     */\n    onSourceDone: `allow` | `break`;\n    /**\n     * If _true_ (default), emits a value when initialised.\n     */\n    emitInitial: boolean;\n};\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\nexport declare const symbol: unique symbol;\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n    value: V | undefined;\n    signal?: SignalKinds;\n    context?: string;\n};\nexport type PassedSignal = Passed<any> & {\n    value: undefined;\n    signal: SignalKinds;\n    context: string;\n};\nexport type PassedValue<V> = Passed<V> & {\n    value: V;\n};\nexport type UpstreamOptions<In> = {\n    lazy: Lazy;\n    /**\n     * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n     */\n    disposeIfSourceDone: boolean;\n    onValue: (v: In) => void;\n    /**\n     * Called just before we subscribe to source\n     * @returns\n     */\n    onStart: () => void;\n    /**\n     * Called after we unsubscribe from source\n     * @returns\n     */\n    onStop: () => void;\n    debugLabel: string;\n    onDispose: (reason: string) => void;\n};\nexport type UpstreamInitialOptions<In> = UpstreamOptions<In> & {\n    initialValue: In;\n};\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n    enacts: {\n        setHtmlText: (options: SetHtmlOptions) => () => void;\n    };\n    source: Reactive<TIn>;\n    /**\n     * Annotate values with output from the `annotation` function.\n     * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n     * @param transformer\n     * @returns\n     */\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{\n        value: TIn;\n        annotation: TAnnotation;\n    }>;\n    annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>) => Wrapped<{\n        value: TIn;\n        annotation: TOut;\n    }>;\n    /**\n    * Accumulate a chunk of values, emitted as an array\n    * @param options\n    * @returns\n    */\n    chunk: (options: Partial<ChunkOptions>) => Wrapped<TIn[]>;\n    debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>;\n    /**\n     * Pluck and emit a single field from values\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>;\n    /**\n     * Throws away values that don't match `predicate`\n     * @param predicate\n     * @param options\n     * @returns\n     */\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>;\n    combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>;\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: {\n        name: string;\n    } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>;\n    min: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    max: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    average: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    sum: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    tally: (options?: Partial<TallyOptions>) => Wrapped<number>;\n    /**\n     * Converts one source stream into two, with values being emitted by both\n     * @param options\n     * @returns\n     */\n    split: (options?: Partial<SplitOptions>) => Wrapped<TIn>[];\n    /**\n   * Emits values when this stream and any additional streams produce a value. The resulting stream is\n   * thus an array of values, each source at a given index.\n   * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n   * the slowest stream.\n   * @returns\n   */\n    syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[TIn, ...RxValueTypes<T>]>;\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: {\n        name?: string;\n    } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>;\n    /**\n     * Creates new streams for each case, sending values to the stream if they match the filter predicate\n     * @param cases\n     * @param options\n     * @returns\n     */\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>;\n    /**\n     * Creates new streams for each case\n     * @param labels\n     * @returns\n     */\n    splitLabelled: <K extends keyof TIn>(...labels: K[]) => Record<K, Wrapped<TIn>>;\n    /**\n     * Taps the stream, passing values to one or more 'processor' functions.\n     * This processing essentially happens in parallel, not affecting the main stream.\n     *\n     * ```js\n     * // Stream of pointermove events with {x:0,y:0} as default\n     * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n     * // Wrap it for fluent access\n     * const ptr = Rx.wrap(move)\n     *  .tapProcess(\n     *    // Create a string representation\n     *    v => `${v.x},${v.y}`\n     *    // Set to DOM\n     *    v => {\n     *      document.getElementById(`coords`).innerText = v;\n     *    }\n     *   )\n     *  .onValue(value => {\n     *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n     *    // not affecting stream\n     *  });\n     * ```\n     * @param processors One-five processing functions\n     * @returns\n     */\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>;\n    tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>;\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<TIn, TOut>[]) => Wrapped<TIn>;\n    /**\n     * Transforms all values\n     * @param transformer\n     * @param options\n     * @returns\n     */\n    transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>;\n    /**\n     * Only allow values through if a minimum of time has elapsed. Throws away values.\n     * Ie. converts a fast stream into a slower one.\n     * @param options\n     * @returns\n     */\n    throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>;\n    /**\n     * Emits a value if `source` does not emit a value after `interval`\n     * has elapsed. This can be useful to reset a reactive to some\n     * 'zero' state if nothing is going on.\n     *\n     * If `source` emits faster than the `interval`, it won't get triggered.\n     *\n     * Default for 'timeout': 1000s.\n     *\n     * ```js\n     * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n     * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n     * ```\n     *\n     * Can also emit results from a function or generator\n     * ```js\n     * // Emits a random number if 'source' doesn't emit a value after 500ms\n     * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n     * ```\n     *\n     * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n     * Otherwise it won't start until it observes the first value from `source`.\n     * @param options\n     */\n    timeoutValue: <TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>;\n    /**\n     * 'Pings' reactive (if it supports it) if a value is not received within a given interval.\n     * Behaviour can be stopped using an abort signal.\n     * @param options\n     * @returns\n     */\n    timeoutPing: (options: TimeoutPingOptions) => Wrapped<TIn>;\n    /**\n     * Copies values from source into an array, throwing\n     * an error if expected number of items is not reached\n     * @param options\n     * @returns\n     */\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<TIn[]>;\n    /**\n     * Copies values from source into an array.\n     * @param options\n     * @returns\n     */\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<(TIn | undefined)[]>;\n    /**\n     * Listen for values\n     * @param callback\n     * @returns\n     */\n    onValue: (callback: (value: TIn) => void) => void;\n};\nexport type ToArrayOptions<V> = {\n    /**\n     * Maximim time to wait for `limit` to be reached. 10s by default.\n     */\n    maximumWait: Interval;\n    /**\n     * Number of items to read\n     */\n    limit: number;\n    /**\n     * Behaviour if threshold is not reached.\n     * partial: return partial results\n     * throw: throw an error\n     * fill: fill remaining array slots with `fillValue`\n     */\n    underThreshold: `partial` | `throw` | `fill`;\n    /**\n     * Value to fill empty slots with if `underThreshold = 'fill'`.\n     */\n    fillValue: V;\n};\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`;\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n    lazy?: Lazy;\n    debugLabel?: string;\n    onStart: () => void;\n    onStop: () => void;\n};\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n    initialValue: T;\n};\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | V[] | (() => V);\n/**\n * A Reactive\n */\nexport type Reactive<V> = {\n    /**\n     * Subscribes to a reactive. Receives\n     * data as well as signals. Use `onValue` if you\n     * just care about values.\n     *\n     * Return result unsubscribes.\n     *\n     * ```js\n     * const unsub = someReactive.on(msg => {\n     *    // Do something with msg.value\n     * });\n     *\n     * unsub(); // Unsubscribe\n     * ```\n     * @param handler\n     */\n    on(handler: (value: Passed<V>) => void): Unsubscriber;\n    /**\n     * Subscribes to a reactive's values.\n     * Returns a function that unsubscribes.\n     * @param handler\n     */\n    onValue(handler: (value: V) => void): Unsubscriber;\n    /**\n     * Disposes the reactive, providing a reason for debug tracing\n     * @param reason\n     */\n    dispose(reason: string): void;\n    /**\n     * Returns _true_ if Reactive is disposed\n     */\n    isDisposed(): boolean;\n    /**\n     * Optional 'set' to write a value. Use {@link ReactiveWritable} if you want this non-optional\n     * @param value\n     */\n    set?(value: V): void;\n};\n/**\n * A reactive that can be 'pinged' to produce a value.\n *\n * Use {@link isPingable} to check if a reactive is pingable.\n *\n * Pingable reactives are returned from\n * * interpolate\n * * computeWithPrevious\n * * valueToPing\n */\nexport type ReactivePingable<V> = Reactive<V> & {\n    ping(): void;\n};\nexport type Unsubscriber = () => void;\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n    last(): V | undefined;\n};\n/**\n * A stream that can be written to\n */\nexport type ReactiveWritable<TIn, TOut = TIn> = Reactive<TOut> & {\n    /**\n     * Sets a value\n     * @param value Value to write\n     */\n    set(value: TIn): void;\n};\nexport type ReactiveInitial<V> = Reactive<V> & {\n    last(): V;\n};\nexport type ReactiveFinite = {\n    isDone(): boolean;\n};\nexport type ReactiveArray<V> = ReactiveWritable<V[]> & {\n    push(value: V): void;\n    deleteAt(index: number): void;\n    deleteWhere(filter: (value: V) => boolean): number;\n    setAt(index: number, value: V): void;\n    insertAt(index: number, value: V): void;\n    onArray(handler: (changes: Passed<ChangeRecord<number>[]>) => void): () => void;\n};\nexport type ObjectFieldHandler = {\n    value: any;\n    fieldName: string;\n    pattern: string;\n};\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n    /**\n     * Notifies when the value of `fieldName` is changed.\n     *\n     * Use the returned function to unsubscribe.\n     * @param fieldName\n     * @param handler\n     */\n    onField(fieldName: string, handler: (result: ObjectFieldHandler) => void): () => void;\n    /**\n     * Notifies of which field(s) were changed.\n     * If you just care about the whole, changed data use the `value` event.\n     *\n     * Use the returned function to unsubscribe.\n     * @param changes\n     */\n    onDiff(changes: (changes: Pathed.PathDataChange<any>[]) => void): () => void;\n    /**\n     * Updates the reactive with some partial key-value pairs.\n     * Keys omitted are left the same as the current value.\n     * @param changedPart\n     * @returns Returns new value\n     */\n    update(changedPart: RecursivePartial<V>): V;\n    /**\n     * Updates a particular field by its path\n     * @param field\n     * @param value\n     */\n    updateField(field: string, value: any): void;\n};\n/**\n * A reactive stream which can be read and written to\n */\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n    /**\n     * Removes all the subscribers from this stream.\n     */\n    removeAllSubscribers(): void;\n    /**\n     * Dispatches a signal\n     * @param signal\n     * @param context\n     */\n    signal(signal: SignalKinds, context?: string): void;\n};\nexport type ReactiveInitialStream<V> = ReactiveStream<V> & ReactiveInitial<V>;\nexport type PipeSet<In, Out> = [\n    Reactive<In>,\n    ...(Reactive<any> & ReactiveWritable<any>)[]\n];\nexport type InitStreamOptions = {\n    /**\n     * Optional label to associate with this stream. Useful for debugging.\n     */\n    debugLabel: string;\n    /**\n     * Called when there is a subscriber after there were no subscribers.\n     * Useful for 'startup' types of things that we want to run only when someone is actually listening.\n     *\n     * During the lifeycle of a stream, this could be called multiple times. Eg if all subscribers are removed\n     * next time someone subscribes it will get called again.\n     * @returns\n     */\n    onFirstSubscribe: () => void;\n    /**\n     * Called when there are no longer any subscribers. Useful for shutting down\n     * activities now that no-one is listening.\n     *\n     * During the lifecycle of a stream, this could be called multiple times.\n     * @returns\n     */\n    onNoSubscribers: () => void;\n    /**\n     * Called whenever the stream disposes. Useful for cleaning up.\n     * @param reason\n     * @returns\n     */\n    onDispose: (reason: string) => void;\n};\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n    /**\n     * Initial value\n     */\n    initial: V;\n    /**\n     * Laziness\n     */\n    lazy?: Lazy;\n};\nexport type ResolveOptions = {\n    /**\n     * How many times to return value or call function.\n     * If _infinite_ is set to true, this value is ignored\n     */\n    loops: number;\n    /**\n     * If _true_ loops forever\n     */\n    infinite: boolean;\n    /**\n     * Delay before value\n     */\n    interval: Interval;\n    lazy: Lazy;\n};\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>;\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>;\nexport type ReactiveOpLinks<In, Out> = [\n    ReactiveOrSource<In>,\n    ...ReactiveOp<any, any>[],\n    ReactiveOp<any, Out>\n];\nexport type RxValueTypes<T extends readonly ReactiveOrSource<any>[]> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? V | undefined : T[K] extends Wrapped<infer V> ? V | undefined : T[K] extends Generator<infer V> ? V | undefined : T[K] extends AsyncGenerator<infer V> ? V | undefined : T[K] extends IterableIterator<infer V> ? V | undefined : T[K] extends AsyncIterableIterator<infer V> ? V | undefined : T[K] extends (infer V)[] ? V | undefined : never;\n};\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? V : T[K] extends Wrapped<infer V> ? V : T[K] extends Generator<infer V> ? V : T[K] extends AsyncGenerator<infer V> ? V : T[K] extends IterableIterator<infer V> ? V : T[K] extends AsyncIterableIterator<infer V> ? V : T[K] extends (infer V)[] ? V : never;\n};\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? V | undefined : T[K] extends Wrapped<infer V> ? V | undefined : T[K] extends Generator<infer V> ? V | undefined : T[K] extends AsyncGenerator<infer V> ? V | undefined : T[K] extends IterableIterator<infer V> ? V | undefined : T[K] extends AsyncIterableIterator<infer V> ? V | undefined : T[K] extends (infer V)[] ? V | undefined : never;\n};\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? Reactive<V> : T[K] extends Wrapped<infer V> ? Reactive<V> : T[K] extends Generator<infer V> ? Reactive<V> : T[K] extends AsyncGenerator<infer V> ? Reactive<V> : T[K] extends IterableIterator<infer V> ? Reactive<V> : T[K] extends AsyncIterableIterator<infer V> ? Reactive<V> : T[K] extends (infer V)[] ? Reactive<V> : never;\n};\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> = {\n    [K in keyof T]: T[K] extends number ? number | undefined : T[K] extends string ? string | undefined : T[K] extends boolean ? boolean | undefined : T[K] extends bigint ? bigint | undefined : never;\n};\n//# sourceMappingURL=types.d.ts.map","import type { ReactiveOrSource, Reactive, ReactiveOp } from \"../types.js\";\nimport type { TransformOpts } from \"./types.js\";\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n *\n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n *\n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport declare function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, annotator: (value: In) => TAnnotation, options?: Partial<TransformOpts>): Reactive<{\n    value: In;\n    annotation: TAnnotation;\n}>;\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n *\n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns\n */\nexport declare function annotateWithOp<In, TAnnotation>(input: ReactiveOrSource<In>, annotatorOp: ReactiveOp<In, TAnnotation>): Reactive<{\n    value: In;\n    annotation: TAnnotation;\n}>;\n//# sourceMappingURL=annotate.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { ChunkOptions } from \"./types.js\";\n/**\n * Queue from `source`, emitting when thresholds are reached.\n * The resulting Reactive produces arrays.\n *\n * Can use a combination of elapsed time or number of data items.\n *\n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport declare function chunk<V>(source: ReactiveOrSource<V>, options?: Partial<ChunkOptions>): Reactive<V[]>;\n//# sourceMappingURL=chunk.d.ts.map","import type { ReactiveOrSource } from \"../types.js\";\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source\n * @returns\n */\nexport declare const cloneFromFields: <In>(source: ReactiveOrSource<In>) => import(\"../types.js\").Reactive<In>;\n//# sourceMappingURL=clone-from-fields.d.ts.map","import type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../types.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n *\n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n *\n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport declare function combineLatestToArray<const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options?: Partial<CombineLatestOptions>): Reactive<RxValueTypes<T>>;\n//# sourceMappingURL=combine-latest-to-array.d.ts.map","import type { ReactiveOrSource, CombineLatestOptions, RxValueTypeObject, ReactiveInitial, RxValueTypeRx, ReactiveDiff } from \"../types.js\";\nexport type CombineLatestToObject<T extends Record<string, ReactiveOrSource<any>>> = {\n    hasSource: (field: string) => boolean;\n    replaceSource: (field: Extract<keyof T, string>, source: ReactiveOrSource<any>) => void;\n    /**\n     * Reactive sources being combined\n     */\n    sources: RxValueTypeRx<T>;\n    /**\n     * Updates writable sources with values.\n     * @param data\n     * @returns Keys and values set to writable source(s)\n     */\n    setWith: (data: Partial<RxValueTypeObject<T>>) => Partial<RxValueTypeObject<T>>;\n} & ReactiveDiff<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>>;\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n *\n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n *\n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport declare function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<CombineLatestOptions>): CombineLatestToObject<T>;\n//# sourceMappingURL=combine-latest-to-object.d.ts.map","import type { ReactiveOrSource, ReactivePingable } from \"../types.js\";\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n *\n * `fn` is provided the previous value as well as the most recent value.\n *\n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input\n * @param fn\n * @returns\n */\nexport declare function computeWithPrevious<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, current: TIn) => TIn): ReactivePingable<TIn>;\n//# sourceMappingURL=compute-with-previous.d.ts.map","import type { ReactiveOp } from \"../types.js\";\nimport type { DebounceOptions } from \"./types.js\";\nexport declare function debounce<V>(options: Partial<DebounceOptions>): ReactiveOp<V, V>;\n//# sourceMappingURL=debounce.d.ts.map","import type { ReactiveOrSource } from \"../types.js\";\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input\n * @returns\n */\nexport declare const elapsed: <In>(input: ReactiveOrSource<In>) => import(\"../types.js\").Reactive<number>;\n//# sourceMappingURL=elapsed.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { FieldOptions } from \"./types.js\";\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n *\n * If a source value doesn't have that field, it is skipped.\n *\n * @returns\n */\nexport declare function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options?: Partial<FieldOptions<TIn, TFieldType>>): Reactive<TFieldType>;\n//# sourceMappingURL=field.d.ts.map","import type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../types.js\";\nimport type { FilterPredicate } from \"./types.js\";\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport declare function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In>;\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport declare function drop<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In>;\n//# sourceMappingURL=filter.d.ts.map","import type { ReactiveOrSource, ReactivePingable } from \"../types.js\";\nimport { type InterpolateOptions } from \"@ixfx/modulation\";\nexport type OpInterpolateOptions = InterpolateOptions & {\n    amount: number;\n    /**\n     * Percentage of value that we consider 'done'.\n     * Since interpolation can never converge to target exactly, this allows us to snap to completion.\n     * Default: 0.99, meaning if value gets to within 99%, return the target.\n     */\n    snapAt: number;\n};\n/**\n * Interpolates to the source value.\n *\n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n *\n * Options can specify an easing name or custom transform of easing progress.\n * @param input\n * @param options\n * @returns\n */\nexport declare function interpolate(input: ReactiveOrSource<number>, options?: Partial<OpInterpolateOptions>): ReactivePingable<number>;\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n//# sourceMappingURL=interpolate.d.ts.map","import type { PipeSet, Reactive } from \"../types.js\";\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n *\n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams\n * @returns\n */\nexport declare const pipe: <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>) => Reactive<TOutput>;\n//# sourceMappingURL=pipe.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { SingleFromArrayOptions } from \"./types.js\";\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n *\n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n *\n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, {\n *  predicate: v => v % 2 === 0\n * });\n *\n * // Selects a random value from source\n * singleFromArray(source, {\n *  order: `random`,\n *  at: 0\n * });\n * ```\n *\n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns\n */\nexport declare function singleFromArray<V>(source: ReactiveOrSource<V[]>, options?: Partial<SingleFromArrayOptions<V>>): Reactive<V>;\n//# sourceMappingURL=single-from-array.d.ts.map","import type { ReactiveOrSource, ReactiveStream, Reactive } from \"../types.js\";\nimport type { SplitOptions } from \"./types.js\";\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n *\n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource\n * @param options\n * @returns\n */\nexport declare const split: <T>(rxOrSource: ReactiveOrSource<T>, options?: Partial<SplitOptions>) => ReactiveStream<T>[];\n/**\n * Splits `source` into several duplicated streams.\n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n *\n * See also {@link split} to get an unlabelled split\n * @param rxOrSource\n * @param labels\n * @returns\n */\nexport declare const splitLabelled: <T, K extends PropertyKey>(rxOrSource: ReactiveOrSource<T>, labels: K[]) => Record<K, Reactive<T>>;\n//# sourceMappingURL=split.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./types.js\";\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n *\n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n *\n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n *\n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n *\n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource\n * @param cases\n * @param options\n * @returns\n */\nexport declare const switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options?: Partial<SwitcherOptions>) => Record<TLabel, Reactive<TValue>>;\n//# sourceMappingURL=switcher.d.ts.map","import type { ReactiveOrSource, Reactive, RxValueTypes } from \"../types.js\";\nimport type { SyncOptions } from \"./types.js\";\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n *\n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n *\n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n *\n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport declare function syncToArray<const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options?: Partial<SyncOptions>): Reactive<RxValueTypes<T>>;\n//# sourceMappingURL=sync-to-array.d.ts.map","import type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../types.js\";\nimport type { SyncOptions } from \"./types.js\";\nexport declare function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<SyncOptions>): Reactive<RxValueTypeObject<T>>;\n//# sourceMappingURL=sync-to-object.d.ts.map","import type { Processors } from \"@ixfx/process\";\nimport type { ReactiveOrSource, Reactive, ReactiveWritable, ReactiveOp } from \"../types.js\";\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns\n */\nexport declare function tapProcess<In, T2, T3, T4, T5, T6>(input: ReactiveOrSource<In>, ...processors: Processors<In, T2, T3, T4, T5, T6>): Reactive<In>;\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to\n * @returns\n */\nexport declare function tapStream<In>(input: ReactiveOrSource<In>, diverged: ReactiveWritable<In>): Reactive<In>;\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns\n */\nexport declare const tapOps: <TIn, TOut>(input: ReactiveOrSource<TIn>, ...ops: ReactiveOp<TIn, TOut>[]) => Reactive<TOut>;\n//# sourceMappingURL=tap.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { ThrottleOptions } from \"./types.js\";\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n *\n * Throttle will fire on the first value received.\n *\n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n *\n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration,\n * even if the source stops sending.\n * @param options\n * @returns\n */\nexport declare function throttle<V>(throttleSource: ReactiveOrSource<V>, options?: Partial<ThrottleOptions>): Reactive<V>;\n//# sourceMappingURL=throttle.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { TimeoutValueOptions } from \"../from/types.js\";\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n *\n * If `source` emits faster than the `interval`, it won't get triggered.\n *\n * Default for 'timeout': 1000s.\n *\n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n *\n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n *\n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source\n * @param options\n */\nexport declare function timeoutValue<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutValueOptions<TTriggerValue>): Reactive<TSource | TTriggerValue>;\n//# sourceMappingURL=timeout-value.d.ts.map","import type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { TimeoutPingOptions } from \"../from/types.js\";\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n *\n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n *\n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source\n * @param options\n */\nexport declare function timeoutPing<TSource>(source: ReactiveOrSource<TSource>, options: TimeoutPingOptions): Reactive<TSource>;\n//# sourceMappingURL=timeout-ping.d.ts.map","import type { Reactive, ReactiveOrSource } from \"../types.js\";\nimport type { TransformOpts } from \"./types.js\";\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer\n * @returns\n */\nexport declare function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options?: Partial<TransformOpts>): Reactive<Out>;\n//# sourceMappingURL=transform.d.ts.map","import type { ValueToPingOptions } from \"../from/types.js\";\nimport type { Reactive, ReactiveOrSource, ReactivePingable } from \"../types.js\";\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n *\n * Returns a new stream capturing the output of `target`.\n *\n * It `source` or `target` closes, output stream closes too.\n *\n * @returns\n */\nexport declare function valueToPing<TSource, TTarget>(source: ReactiveOrSource<TSource>, target: ReactivePingable<TTarget>, options?: Partial<ValueToPingOptions<TSource>>): Reactive<TTarget>;\n//# sourceMappingURL=value-to-ping.d.ts.map","import type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../types.js\";\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n *\n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input\n * @param options\n * @returns\n */\nexport declare function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In>;\n//# sourceMappingURL=with-value.d.ts.map","import type { Reactive, ReactiveFinite, ReactiveInitial } from \"../types.js\";\nimport type { ArrayOptions } from \"./types.js\";\nexport declare const of: <V>(source: V[] | Iterable<V>, options?: Partial<ArrayOptions>) => (Reactive<V> & ReactiveFinite & {\n    last(): V;\n}) | undefined;\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n *\n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n *\n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n *\n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray\n * @param options\n * @returns\n */\nexport declare const array: <V>(sourceArray: V[], options?: Partial<ArrayOptions>) => Reactive<V> & ReactiveFinite & ReactiveInitial<V>;\n//# sourceMappingURL=array.d.ts.map","import type { ReactiveInitial, ReactiveArray } from \"../types.js\";\nimport type { ArrayObjectOptions } from \"./types.js\";\n/**\n * Wraps an array object.\n *\n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue\n * @param options\n * @returns\n */\nexport declare function arrayObject<V>(initialValue?: readonly V[], options?: Partial<ArrayObjectOptions<V>>): ReactiveArray<V> & ReactiveInitial<readonly V[]>;\n//# sourceMappingURL=array-object.d.ts.map","import type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\nexport declare function boolean(initialValue: boolean): ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport declare function boolean(): ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\n//# sourceMappingURL=boolean.d.ts.map","import type { CountOptions } from \"./types.js\";\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n *\n * ```js\n * const r = Rx.From.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n *\n * The `limit` is exclusive\n * ```js\n * const r = Rx.From.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n *\n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n *\n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.From.count({ start: 10, amount: 2, interval: 500 });\n * ```\n *\n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.From.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options\n */\nexport declare function count(options?: Partial<CountOptions>): import(\"../types.js\").ReactiveStream<number>;\n//# sourceMappingURL=count.d.ts.map","import { type CombineLatestToObject } from \"../ops/combine-latest-to-object.js\";\nimport type { ReactiveNonInitial, ReactiveOrSource, RxValueTypeObject } from \"../types.js\";\nimport type { DerivedOptions } from \"./types.js\";\nexport declare function derived<TResult, const T extends Record<string, ReactiveOrSource<any>>>(fn: (combined: RxValueTypeObject<T>) => TResult | undefined, reactiveSources: T, options?: Partial<DerivedOptions<TResult, CombineLatestToObject<T>>>): ReactiveNonInitial<TResult>;\n//# sourceMappingURL=derived.d.ts.map","import type { Reactive, ReactiveInitial } from \"../types.js\";\nimport type { FieldOptions } from \"../ops/types.js\";\nimport type { EventSourceOptions, EventSourceTriggerOptions } from \"./types.js\";\n/**\n * Fired when `eventName` fires on `target`.\n *\n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n *\n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId')\n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport declare function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options?: Partial<EventSourceOptions & FieldOptions<any, TFieldValue>>): Reactive<TFieldValue>;\n/**\n * Subscribes to an event, emitting data\n *\n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n *\n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n *\n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns\n */\nexport declare function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options?: Partial<EventSourceOptions>): ReactiveInitial<TEventArgs> & Reactive<TEventArgs>;\nexport type TriggerData = {\n    sinceLast: number;\n    total: number;\n};\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of\n * times event has been fired.\n * @param targetOrQuery\n * @param name\n * @param options\n * @returns\n */\nexport declare function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options?: Partial<EventSourceTriggerOptions>): Reactive<TriggerData>;\n//# sourceMappingURL=event.d.ts.map","import type { ReactivePingable } from \"../types.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./types.js\";\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n *\n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n *\n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it.\n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n *\n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n *\n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber\n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback\n * @param options\n * @returns\n */\nexport declare function func<V>(callback: FunctionFunction<V>, options?: Partial<FunctionOptions>): ReactivePingable<V>;\n//# sourceMappingURL=function.d.ts.map","import type { Reactive } from \"../types.js\";\nimport type { GeneratorOptions } from \"./types.js\";\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen\n * @returns\n */\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n *\n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source\n */\nexport declare function iterator<V>(source: IterableIterator<V> | V[] | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options?: Partial<GeneratorOptions>): Reactive<V>;\n//# sourceMappingURL=iterator.d.ts.map","import type { InitLazyStreamOptions, Reactive } from \"../types.js\";\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources\n * @returns\n */\nexport declare function merged<T>(...sources: Reactive<T>[]): Reactive<T>;\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n *\n * @param sources\n * @param options\n * @returns\n */\nexport declare function mergedWithOptions<T>(sources: Reactive<T>[], options?: Partial<InitLazyStreamOptions>): Reactive<T>;\n//# sourceMappingURL=merged.d.ts.map","import type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\nexport declare function number(initialValue: number): ReactiveWritable<number> & ReactiveInitial<number>;\nexport declare function number(): ReactiveWritable<number> & ReactiveNonInitial<number>;\n//# sourceMappingURL=number.d.ts.map","import type { ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\nimport type { ObjectOptions } from \"./types.js\";\nexport declare function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport declare function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n//# sourceMappingURL=object.d.ts.map","import { symbol, type ReactiveArray, type ReactiveDiff, type ReactiveInitial } from \"../types.js\";\nexport type ReactiveProxied<V> = V & {\n    [symbol]: ReactiveDiff<V> & ReactiveInitial<V>;\n};\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n *\n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n *\n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n *\n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n *\n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n *\n * The benefit of `objectProxy` instead of {@link From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n *\n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n *\n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n *\n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target\n * @returns\n */\nexport declare const objectProxy: <V extends object>(target: V) => {\n    proxy: V;\n    rx: ReactiveDiff<V> & ReactiveInitial<V>;\n};\nexport declare const arrayProxy: <V, T extends V[]>(target: T) => {\n    proxy: T;\n    rx: ReactiveArray<V> & ReactiveInitial<readonly V[]>;\n};\n/**\n * Same as {@link objectProxy}, but the return value is the proxied object along with\n * the Reactive wrapped as symbol property.\n *\n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n *\n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two.\n * @param target\n * @returns\n */\nexport declare const objectProxySymbol: <V extends object>(target: V) => ReactiveProxied<V>;\n//# sourceMappingURL=object-proxy.d.ts.map","import type { Reactive, ReactiveWritable } from \"../types.js\";\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n *\n *  // To send a value:\n *  stream.set(someValue);\n *\n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n *\n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n *\n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init\n * @returns\n */\nexport declare function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V>;\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init\n * @returns\n */\nexport declare function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V>;\n//# sourceMappingURL=observable.d.ts.map","import type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\nexport declare function string(initialValue: string): ReactiveWritable<string> & ReactiveInitial<string>;\nexport declare function string(): ReactiveWritable<string> & ReactiveNonInitial<string>;\n//# sourceMappingURL=string.d.ts.map","export * from './array.js';\nexport * from './array-object.js';\nexport * from './boolean.js';\nexport * from './count.js';\nexport * from './derived.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterator.js';\nexport * from './merged.js';\nexport * from './number.js';\nexport * from './object.js';\nexport * from './object-proxy.js';\nexport * from './observable.js';\nexport * from './string.js';\nexport * from './types.js';\n//# sourceMappingURL=index.d.ts.map","import type { IQueueMutableWithEvents } from \"@ixfx/collections/queue\";\n/**\n * Changes to `queue` are output as a responsive stream.\n * The stream emits the full data of the queue (first item being the head of the queue)\n * whenever there is an enqueue, remove or clear operation.\n *\n * ```js\n * const queue = new QueueMutable();\n * const r = asResponsive(queue);\n * r.onValue(v => {\n *  // v is an array of values\n * });\n *\n *\n * Calling `set()` on the stream enqueues data to the wrapped queue.\n * ```js\n * r.set([ `1, `2` ]); // Enqueues 1, 2\n * ```\n * @param queue\n * @returns\n */\nexport declare function asResponsive<T>(queue: IQueueMutableWithEvents<T>): {\n    set: (data: T[]) => void;\n    on(handler: (value: import(\"../types.js\").Passed<readonly T[]>) => void): import(\"../types.js\").Unsubscriber;\n    onValue(handler: (value: readonly T[]) => void): import(\"../types.js\").Unsubscriber;\n    dispose(reason: string): void;\n    isDisposed(): boolean;\n};\n//# sourceMappingURL=responsive-queue.d.ts.map","export * from './responsive-queue.js';\n//# sourceMappingURL=index.d.ts.map","import type { Reactive } from \"./types.js\";\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx\n */\nexport declare function prepare<V extends Record<string, any>>(_rx: V): Reactive<V>;\n//# sourceMappingURL=graph.d.ts.map","import type { ReactiveOrSource, ToArrayOptions } from \"./types.js\";\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n *\n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n *\n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n *\n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport declare function toArray<V>(source: ReactiveOrSource<V>, options?: Partial<ToArrayOptions<V>>): Promise<(V | undefined)[]>;\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n *\n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport declare function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options?: Partial<ToArrayOptions<V>>): Promise<V[]>;\n//# sourceMappingURL=to-array.d.ts.map","import type { ReactiveOrSource } from \"./types.js\";\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n *\n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n *\n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ```\n *\n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n *\n * // Execution continues here immediately\n * ```\n * @param source\n */\nexport declare function toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V>;\n//# sourceMappingURL=to-generator.d.ts.map","import type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactivePingable, ReactiveWritable, Wrapped } from \"./types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./from/types.js\";\nexport declare function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal;\nexport declare function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean;\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v\n * @returns\n */\nexport declare function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V>;\nexport declare const isPingable: <V>(rx: Reactive<V> | ReactiveDiff<V> | object) => rx is ReactivePingable<V>;\nexport declare const hasLast: <V>(rx: Reactive<V> | ReactiveDiff<V> | object) => rx is ReactiveInitial<V>;\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport declare const isReactive: <V>(rx: object) => rx is Reactive<V>;\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx\n * @returns\n */\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx\n * @returns\n */\nexport declare const isWritable: <V>(rx: Reactive<V> | ReactiveWritable<V>) => rx is ReactiveWritable<V>;\nexport declare const isWrapped: <T>(v: any) => v is Wrapped<T>;\nexport declare const opify: <TIn, TRxOut = Reactive<TIn>>(fn: (source: ReactiveOrSource<TIn>, ...args: any[]) => TRxOut, ...args: any[]) => (source: ReactiveOrSource<TIn>) => TRxOut;\nexport declare const isTriggerValue: <V>(t: Trigger<V>) => t is TriggerValue<V>;\nexport declare const isTriggerFunction: <V>(t: Trigger<V>) => t is TriggerFunction<V>;\nexport declare const isTriggerGenerator: <V>(t: Trigger<V>) => t is TriggerGenerator<V>;\nexport declare const isTrigger: <V>(t: any) => t is Trigger<V>;\nexport type ResolveTriggerValue<V> = [value: V, false];\nexport type ResolveTriggerDone = [undefined, true];\n/**\n * Resolves a trigger value.\n *\n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t\n * @returns\n */\nexport declare function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V>;\n//# sourceMappingURL=util.d.ts.map","import type { ReactiveOrSource, Wrapped } from \"./types.js\";\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n *\n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n *\n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source\n * @returns\n */\nexport declare function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn>;\n//# sourceMappingURL=wrap.d.ts.map","import type { GeneratorOptions, FunctionOptions } from \"./from/types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./types.js\";\nexport type ResolveSourceOptions = {\n    /**\n     * Options when creating a reactive from a generator\n     * Default:  `{ lazy: true, interval: 5 }`\n     */\n    generator: GeneratorOptions;\n    /**\n     * Options when creating a reactive from a function.\n     */\n    function: FunctionOptions;\n};\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n *\n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source\n * @returns\n */\nexport declare const resolveSource: <V>(source: ReactiveOrSource<V>, options?: Partial<ResolveSourceOptions>) => Reactive<V>;\n//# sourceMappingURL=resolve-source.d.ts.map","import type { Reactive } from \"./types.js\";\n/**\n * A stream that caches its last value\n */\nexport type CacheStream<T> = {\n    /**\n     * Clears the last cached value\n     * @returns\n     */\n    resetCachedValue: () => void;\n    /**\n     * Gets the cached value, if available\n     * @returns\n     */\n    last: () => T | undefined;\n};\n/**\n * A {@link CacheStream} with an initial value\n */\nexport type CacheStreamInitial<T> = CacheStream<T> & {\n    last: () => T;\n};\n/**\n * Wraps an input stream to cache values, and provide an initial value\n * @param r Input stream\n * @param initialValue Initial value\n */\nexport declare function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue): CacheStreamInitial<TValue> & RT;\n//# sourceMappingURL=cache.d.ts.map","import type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, ReactiveInitialStream, ReactiveOrSource, ReactiveStream, UpstreamOptions } from \"./types.js\";\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n *\n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource\n * @param options\n * @returns\n */\nexport declare function initUpstream<In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out>;\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options\n * @returns\n */\nexport declare function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveInitialStream<V>;\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n *\n * @param options\n * @returns\n */\nexport declare function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V>;\n/**\n * Initialises a new stream.\n *\n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n *\n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options\n * @returns\n */\nexport declare function initStream<V>(options?: Partial<InitStreamOptions>): ReactiveStream<V>;\n//# sourceMappingURL=init-stream.d.ts.map","import type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, ReactivePingable } from \"./types.js\";\nimport type { ChunkOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/types.js\";\nimport type { RankFunction, RankOptions } from \"@ixfx/core\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"./from/types.js\";\nimport { type Interval } from '@ixfx/core';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\nexport * as From from './from/index.js';\nexport * as Collections from './collections/index.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * from './init-stream.js';\nexport declare function run<TIn, TOut>(source: ReactiveOrSource<any>, ...ops: ReactiveOp<any, any>[]): Reactive<any>;\nexport declare function writable<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<any, any>[]): ReactiveWritable<TIn, TOut>;\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns\n */\nexport declare function manual<V>(options?: Partial<InitStreamOptions>): Reactive<V> & ReactiveWritable<V>;\nexport declare const Sinks: {\n    setHtmlText: (options: SinkFns.SetHtmlOptions) => (source: ReactiveOrSource<string>) => void;\n};\nexport declare const Ops: {\n    /**\n   * Annotates values with the result of a function.\n   * The input value needs to be an object.\n   *\n   * For every value `input` emits, run it through `annotator`, which should\n   * return the original value with additional fields.\n   *\n   * Conceptually the same as `transform`, just with typing to enforce result\n   * values are V & TAnnotation\n   * @param annotator\n   * @returns\n   */\n    readonly annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => <In, TAnnotation_1>(source: ReactiveOrSource<In>) => Reactive<{\n        value: In;\n        annotation: TAnnotation_1;\n    }>;\n    /**\n     * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n     * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n     * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n     *\n     * ```js\n     * // Emit values from an array\n     * const r1 = Rx.run(\n     *  Rx.From.array([ 1, 2, 3 ]),\n     *  Rx.Ops.annotateWithOp(\n     *    // Add the 'max' operator to emit the largest-seen value\n     *    Rx.Ops.sum()\n     *  )\n     * );\n     * const data = await Rx.toArray(r1);\n     * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n     * ```\n     * @param annotatorOp\n     * @returns\n     */\n    readonly annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => <In, TAnnotation_1>(source: ReactiveOrSource<In>) => Reactive<{\n        value: In;\n        annotation: TAnnotation_1;\n    }>;\n    /**\n     * Takes a stream of values and chunks them up (by quantity or time elapsed),\n     * emitting them as an array.\n     * @param options\n     * @returns\n     */\n    readonly chunk: <V>(options: Partial<ChunkOptions>) => ReactiveOp<V, V[]>;\n    readonly cloneFromFields: <V>() => ReactiveOp<V, V>;\n    /**\n   * Merges values from several sources into a single source that emits values as an array.\n   * @param options\n   * @returns\n   */\n    readonly combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(options?: Partial<CombineLatestOptions>) => (sources: T) => Reactive<RxValueTypes<T>>;\n    /**\n     * Merges values from several sources into a single source that emits values as an object.\n     * @param options\n     * @returns\n     */\n    readonly combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options?: Partial<CombineLatestOptions>) => (reactiveSources: T) => OpFns.CombineLatestToObject<T>;\n    /**\n   * Debounce values from the stream. It will wait until a certain time\n   * has elapsed before emitting latest value.\n   *\n   * Effect is that no values are emitted if input emits faster than the provided\n   * timeout.\n   *\n   * See also: throttle\n   * @param options\n   * @returns\n   */\n    /**\n     * Drops values from the input stream that match `predicate`\n     * @param predicate If it returns _true_ value is ignored\n     * @returns\n     */\n    readonly drop: <V>(predicate: (value: V) => boolean) => <In>(source: ReactiveOrSource<In>) => Reactive<In>;\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @returns\n     */\n    readonly elapsed: <V>() => ReactiveOp<V, number>;\n    /**\n     * Yields the value of a field from an input stream of values.\n     * Eg if the source reactive emits `{ colour: string, size: number }`,\n     * we might use `field` to pluck out the `colour` field, thus returning\n     * a stream of string values.\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    readonly field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options?: Partial<FieldOptions<TSource, TFieldType>>) => (source: ReactiveOrSource<TSource>) => Reactive<TFieldType>;\n    /**\n     * Filters the input stream, only re-emitting values that pass the predicate\n     * @param predicate If it returns _true_ value is allowed through\n     * @returns\n     */\n    readonly filter: <V>(predicate: (value: V) => boolean) => <In>(source: ReactiveOrSource<In>) => Reactive<In>;\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @param options\n     * @returns\n     */\n    readonly interpolate: <TIn = number>(options?: Partial<OpFns.OpInterpolateOptions>) => (source: ReactiveOrSource<TIn>) => ReactivePingable<number>;\n    /**\n   * Outputs the minimum numerical value of the stream.\n   * A value is only emitted when minimum decreases.\n   * @returns\n   */\n    readonly min: <TIn = number>(options?: OpFns.OpMathOptions) => (source: ReactiveOrSource<TIn>) => Reactive<number>;\n    /**\n     * Outputs the maxium numerical value of the stream.\n     * A value is only emitted when maximum increases.\n     * @returns\n     */\n    readonly max: <TIn = number>(options?: OpFns.OpMathOptions) => (source: ReactiveOrSource<TIn>) => Reactive<number>;\n    readonly sum: <TIn = number>(options?: OpFns.OpMathOptions) => (source: ReactiveOrSource<TIn>) => Reactive<number>;\n    readonly average: <TIn = number>(options?: OpFns.OpMathOptions) => (source: ReactiveOrSource<TIn>) => Reactive<number>;\n    readonly tally: <TIn>(options?: OpFns.TallyOptions) => (source: ReactiveOrSource<TIn>) => Reactive<number>;\n    readonly rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => (source: ReactiveOrSource<TIn>) => Reactive<TIn>;\n    readonly pipe: <TInput, TOutput>(...streams: (Reactive<any> & ReactiveWritable<any>)[]) => (source: ReactiveOrSource<TInput>) => Reactive<unknown>;\n    readonly singleFromArray: <V>(options?: Partial<SingleFromArrayOptions<V>>) => (source: ReactiveOrSource<V[]>) => Reactive<V>;\n    readonly split: <V>(options?: Partial<SplitOptions>) => (source: ReactiveOrSource<V>) => import(\"./types.js\").ReactiveStream<V>[];\n    readonly splitLabelled: <V>(labels: string[]) => (source: ReactiveOrSource<V>) => Record<string, Reactive<V>>;\n    readonly switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options?: Partial<SwitcherOptions>) => (source: ReactiveOrSource<TValue>) => Record<TLabel, Reactive<TValue>>;\n    readonly syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(options?: Partial<SyncOptions>) => (reactiveSources: T) => Reactive<RxValueTypes<T>>;\n    readonly syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options?: Partial<SyncOptions>) => (reactiveSources: T) => Reactive<RxValueTypeObject<T>>;\n    readonly tapProcess: <In>(processor: ((value: In) => any)) => ReactiveOp<In, In>;\n    readonly tapStream: <In>(divergedStream: ReactiveWritable<In>) => ReactiveOp<In, In>;\n    readonly tapOps: <In, Out>(...ops: ReactiveOp<In, Out>[]) => (source: ReactiveOrSource<In>) => Reactive<Out>;\n    /**\n   * Throttle values from the stream.\n   * Only emits a value if some minimum time has elapsed.\n   * @param options\n   * @returns\n   */\n    readonly throttle: <V>(options: Partial<ThrottleOptions>) => (source: ReactiveOrSource<V>) => Reactive<V>;\n    /**\n     * Trigger a value if 'source' does not emit a value within an interval.\n     * Trigger value can be a fixed value, result of function, or step through an iterator.\n     * @param options\n     * @returns\n     */\n    readonly timeoutValue: <V, TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => (source: ReactiveOrSource<V>) => Reactive<V | TTriggerValue>;\n    readonly timeoutPing: <V>(options: TimeoutPingOptions) => (source: ReactiveOrSource<V>) => Reactive<V>;\n    readonly transform: <In, Out>(transformer: ((value: In) => Out), options?: Partial<OpFns.TransformOpts>) => ReactiveOp<In, Out>;\n    /**\n    * Reactive where last (or a given initial) value is available to read\n    * @param opts\n    * @returns\n    */\n    readonly withValue: <V>(opts: Partial<WithValueOptions<V>>) => ReactiveOp<V, V>;\n};\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n *\n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n *\n * Throws an error if the source closes without\n * a value or the timeout is reached.\n *\n * @param source\n * @param maximumWait\n * @returns\n */\nexport declare function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait?: Interval): Promise<V>;\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n *\n * Returns a function to unsubcribe A->B\n * @param a\n * @param b\n * @param transform\n */\nexport declare const to: <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA?: boolean) => import(\"./types.js\").Unsubscriber;\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}