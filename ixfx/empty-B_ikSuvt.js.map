{"version":3,"file":"empty-B_ikSuvt.js","names":["result: ResultError","guard","p: Point","p: number | unknown","p: Point | unknown","d: number","rect: Rect","rect: Rect | RectPositioned","origin?: Point","rect: Point | Rect | RectPositioned","rect: unknown"],"sources":["../../packages/core/src/results.ts","../../packages/geometry/src/point/guard.ts","../../packages/geometry/src/rect/guard.ts","../../packages/geometry/src/rect/empty.ts"],"sourcesContent":["import { getErrorMessage } from \"@ixfx/debug\"\n\nexport type ResultOk<T> = {\n  success: true\n  value: T\n}\n\nexport type ResultError = {\n  success: false\n  error: Error | string\n}\n\nexport type Result<T> = ResultOk<T> | ResultError;\n/**\n * If `result` is an error, throws it, otherwise ignored.\n * @param result \n * @returns \n */\nexport function throwResult<T>(result: Result<T>): result is ResultOk<T> {\n  if (result.success) return true;\n  if (typeof result.error === `string`) throw new Error(result.error);\n  throw result.error;\n}\n\nexport function resultToError(result: ResultError): Error {\n  if (typeof result.error === `string`) return new Error(result.error);\n  else return result.error\n}\n\nexport function resultToValue<T>(result: Result<T>): T {\n  if (result.success) return result.value;\n  else throw resultToError(result);\n}\n\nexport function resultErrorToString(result: ResultError): string {\n  if (typeof result.error === `string`) return result.error;\n  else return getErrorMessage(result.error);\n}","import type { Point, Point3d } from \"./point-type.js\";\nimport { throwNumberTest } from '@ixfx/guards';\n\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport const isNull = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== null) return false;\n  }\n  return p.x === null && p.y === null;\n}\n\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport const isNaN = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) || Number.isNaN(p.y)\n}\n\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p: Point, name = `Point`) {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.x === undefined) {\n    throw new Error(\n      `'${ name }.x' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.y === undefined) {\n    throw new Error(\n      `'${ name }.y' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (typeof p.x !== `number`) {\n\n    throw new TypeError(`'${ name }.x' must be a number. Got ${ typeof p.x }`);\n  }\n  if (typeof p.y !== `number`) {\n\n    throw new TypeError(`'${ name }.y' must be a number. Got ${ typeof p.y }`);\n  }\n  if (p.z !== undefined) {\n    if (typeof p.z !== `number`) throw new TypeError(`${ name }.z must be a number. Got: ${ typeof p.z }`)\n    if (Number.isNaN(p.z)) throw new Error(`'${ name }.z' is NaN. Got: ${ JSON.stringify(p) }`);\n  }\n\n  if (p.x === null) throw new Error(`'${ name }.x' is null`);\n  if (p.y === null) throw new Error(`'${ name }.y' is null`);\n\n  if (Number.isNaN(p.x)) throw new Error(`'${ name }.x' is NaN`);\n  if (Number.isNaN(p.y)) throw new Error(`'${ name }.y' is NaN`);\n}\n\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt: Point | Point3d, name = `pt`) => {\n  guard(pt, name);\n  throwNumberTest(pt.x, `nonZero`, `${ name }.x`);\n  throwNumberTest(pt.y, `nonZero`, `${ name }.y`);\n  if (typeof pt.z !== `undefined`) {\n    throwNumberTest(pt.z, `nonZero`, `${ name }.z`);\n  }\n\n  return true;\n};\n\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p: number | unknown): p is Point {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point).x === undefined) return false;\n  if ((p as Point).y === undefined) return false;\n  return true;\n}\n\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p: Point | unknown): p is Point3d => {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point3d).x === undefined) return false;\n  if ((p as Point3d).y === undefined) return false;\n  if ((p as Point3d).z === undefined) return false;\n  return true;\n};\n\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== 0) return false;\n  }\n  return p.x === 0 && p.y === 0\n\n}\n\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) && Number.isNaN(p.y);\n}\n","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d \n * @param name \n */\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n * \n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *  \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect \n * @param name \n */\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect \n * @returns \n */\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\n\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect \n * @returns \n */\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  rect: Point | Rect | RectPositioned\n): rect is Point =>\n  (rect as Point).x !== undefined && (rect as Point).y !== undefined;\n\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect: unknown): rect is Rect => {\n  if (rect === undefined) return false;\n  if ((rect as Rect).width === undefined) return false;\n  if ((rect as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (\n  rect: any\n): rect is RectPositioned => isRect(rect) && isPositioned(rect);\n","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n});"],"mappings":"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"}