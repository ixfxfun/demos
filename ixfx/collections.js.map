{"version":3,"file":"collections.js","names":["#capacity","#pointer","value: V","value","opts: QueueOpts<any>","message: string","opts: QueueOpts<V>","queue: ReadonlyArray<V>","toAdd: ReadonlyArray<V>","opts: QueueOpts<V>","data: readonly V[]","index: number","result: readonly V[]","attemptedToAdd: readonly V[]","removed: readonly V[]","finalData: readonly V[]","predicate: (item: V) => boolean","mutable","options: QueueOpts<V>","opts: StackOpts","stack: ReadonlyArray<V>","toAdd: ReadonlyArray<V>","peek","isEmpty","isFull","opts: StackOpts","data: ReadonlyArray<V>","fn: (v: V) => void","peek","isEmpty","isFull","mutable","a: TraversableTree<T>","b: TraversableTree<T>","eq: IsEqual<T>","parent?: DiffNode<T>","diff: DiffAnnotation<T>","diffNode: DiffNode<T>","toString","vv: DiffAnnotation<any>","identical: [ a: TraversableTree<T>, b: TraversableTree<T> ][]","removed: TraversableTree<T>[]","n: TraversableTree<T>","n: DiffNode<T>","n: DiffAnnotation<T> | undefined","indent: number","t: string[]","compare","a: TreeNode<T>","b: TreeNode<T>","eq?: IsEqual<T>","treeCompare","asDynamicTraversable","node: TreeNode<T>","n: SimplifiedNode<T>","node: TreeNode<T> | WrappedNode<T>","n: TreeNode<T>","value: T","value","parent: WrappedNode<T> | TreeNode<T>","hasParent","hasAnyParent","child: WrappedNode<T> | TreeNode<T>","hasChild","hasAnyChild","addValue","add","child: TreeNode<T>","depthFirst","entry: TreeNode<T> | undefined","breadthFirst","root: TreeNode<T>","seen: TreeNode<T>[]","root","children","parents","node: TreeNode<any>","parent: TreeNode<T>","findChildByValue","eq: IsEqual<T>","prospectiveChild: TreeNode<T>","findAnyChildByValue","prospectiveParent: TreeNode<T>","value: T | undefined","value?: T","value: Record<string, any>","parent?: TreeNode<any>","seen: any[]","parent?: TreeNode<T>","childrenLength","t: TraversableTree<T>","c: TreeNode<T>","children: TreeNode<T>[]","toStringDeep","followValue","continuePredicate: (nodeValue: T, depth: number) => boolean","entries: readonly Entry[]","node: object","options: Partial<ChildrenOptions>","toStringDeep","node: TreeNode<Entry | EntryStatic>","node: T","v: any","value","depthFirst","ancestors: string[]","name: string","path: string","options: PathOpts","parent?: TraversableTree<EntryStatic>","t: TraversableTree<EntryStatic>","options: Partial<CreateOptions>","create","sourceValue: T","nodeValue: T","create","pathOpts: Partial<PathOpts>","root: TreeNode<LabelledValue<T>> | undefined","add","value: T","path: string","value","root","prettyPrint","remove","childrenLength","getRoot","node?: LabelledNode<T>","labelled: LabelledValue<T>","root: LabelledNode<T>","node: LabelledNode<T>","label: string","node: LabelledNode<T> | undefined","c: LabelledNode<T>","c: LabelledNode<T> | undefined","tree: TraversableTree<T>","child: T","possibleParent: T","eq?: IsEqual<T>","possibleParentValue: TV","eq?: IsEqual<TV>","child: TraversableTree<TValue>","possibleParentValue: TValue","eq?: IsEqual<TValue>","eq: IsEqual<T>","eq: IsEqual<TV>","value","parent: TraversableTree<T>","prospectiveChild: TraversableTree<T>","eq: IsEqual<TraversableTree<T>>","parent: T","possibleChild: T","possibleChildValue: T","possibleValue: T","node: TraversableTree<T>","node: T","possibleValue: TV","root: T","root","entry: T | undefined","root: TraversableTree<T>","predicate: (node: TraversableTree<T>) => boolean","order: `breadth` | `depth`","predicate: (nodeValue: T) => boolean","continuePredicate: (nodeValue: T, depth: number) => boolean","type: string","children","node: TreeNode<T> | TraversableTree<T> | object","TreeNodeToTraversable","ObjectToTraversable","node: any","opts: StackOpts","data: ReadonlyArray<V>","fn: (v: V) => void","isEmpty","isFull","peek","immutable","options: StackOpts","mutable","keyString?: ToString<V>","keyString: ToString<V> | undefined","value","v: V","keyString?: ToString<V>","map?: Map<string, V>","map","v: V","immutable","keyString: ToString<V>","#depth","#maxDepth","set","value: string","value","#getChild","#dumpToArray","r: Array<string>","create: boolean","create","opts: QueueOpts<PriorityItem<V>>","item: V","priority: number","priority","eq?: IsEqual<V>","toDelete: PriorityItem<V> | undefined","item","IterablesLast","IterablesMax","IterablesMin","opts: QueueOpts<V>","data: ReadonlyArray<V>","#data","fn: (v: V) => void","immutable","options: QueueOpts<V>","options: Opts","opts: Opts","#maintain","key: K","value","interval: Interval","property: `get` | `set` | `either`","prune: [ k: K, v: V ][]","value: V","key","existing","map: ReadonlyMap<K, V>","data: ArrayKeys<K, V>","map","data: ObjectKeys<K, V>","key: K","value: V","value","dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>","key: K","value: V","value","data","key: K","value: V","value","#map","type: MultiValue<V, M>","opts: MapMultiOpts<V>","key: string","set","values: V[]","value: V","eq: IsEqual<V>","value","map: M","map","other: IMapOf<V>","options?: MapSetOpts<V>","a: V","b: V","t: MultiValue<V, ReadonlyMap<string, V>>","mapAddValue","mapFindValue","mapFilterValues","mapToArray","value","mapHasAnyValue","options: MapCircularOpts<V>","t: MultiValue<V, ICircularArray<V>>","value","key: K","amount: number","value","options: MapArrayOpts<V>","toStringFunction: IsEqual<V>","a: V","b: V","t: MultiValue<V, readonly V[]>","value","map: IWithEntries<K, Iterable<V>>","predicate: (value: V, key: K) => boolean","map","value","map: IMapOf<V>","largest: readonly [ string, number ]","value: V","isEqual: IsEqual<V>","groupBy: (value: V) => string","valueEq: IsEqual<V>","initial: [ string, readonly V[] ][]","key: string","value: V","value","eq: IsEqual<V>","key: string","values: readonly V[]","value: V","without","value","del","groupBy: (value: V) => string","valueEq: IsEqual<V>","key: string","entries: [ key: string, value: readonly V[] ][]","_key: string","_value: V","value: V","eq?: IsEqual<V>","value","groupBy: ToString<V>","valueEq: IsEqual<V>","label: string","r: (V | undefined)[][]","columnIndex: number","rowIndex: number","value","row: number | string","#getRowRaw","column: number | string","value: V | undefined","#getOrCreateRawRow","#getColumnRaw","index: number | undefined","row: TableRow<V>","length?: number","createVertex","id: string","graph: DirectedGraph","key: string","graph","toAdjacencyMatrix","dumpGraph","graph: DirectedGraph | Iterable<Vertex>","debugGraphToArray","r: string[]","vertices","edge: Edge","g: DirectedGraph","adjacentVertices","context: Vertex | string | undefined","vertex: Vertex","outIdOrVertex: string | Vertex","vertex: string | Vertex","resolveVertex","getOrCreate","updateGraphVertex","from: string | Vertex","to: string | Vertex","connectTo","from: string","to: string","weight?: number","connect","options: ConnectOptions","connectWithEdges","edges: Edge[]","edges","v: Vertex","stringForEdge","a: Vertex","b: Vertex","idOrVertex: string | Vertex","startIdOrVertex: string | Vertex","targetIdOrVertex?: string | Vertex","sourceOrId: Vertex | string","path: Edge[]","immutableMap","topOrder: Vertex[]","vertices: Iterable<Vertex>","scc: Vertex[][]","vertex: TarjanVertex","stronglyConnected: Vertex[]","w: TarjanVertex | undefined","id: string","graph: Graph","vertex: Vertex","graph","idOrVertex: string | Vertex","a: string | Vertex","b: string | Vertex","a: string","b: string","weight?: number","graphChanged: Graph","options: ConnectOptions","edges: Edge[]","edges","g: Graph","immutableMap","r: string[]","edge: Edge","context: Vertex | string | undefined"],"sources":["../packages/collections/src/circular-array.ts","../packages/collections/src/queue/queue-fns.ts","../packages/collections/src/queue/queue-mutable.ts","../packages/collections/src/stack/StackFns.ts","../packages/collections/src/stack/StackMutable.ts","../packages/collections/src/tree/compare.ts","../packages/collections/src/tree/tree-mutable.ts","../packages/collections/src/tree/traverse-object.ts","../packages/collections/src/tree/pathed.ts","../packages/collections/src/tree/traversable-tree.ts","../packages/collections/src/tree/index.ts","../packages/collections/src/stack/StackImmutable.ts","../packages/collections/src/stack/index.ts","../packages/collections/src/set/set-mutable.ts","../packages/collections/src/set/SetImmutable.ts","../packages/collections/src/set/massive-set.ts","../packages/collections/src/set/index.ts","../packages/collections/src/queue/priority-mutable.ts","../packages/collections/src/queue/queue-immutable.ts","../packages/collections/src/queue/index.ts","../packages/collections/src/map/expiring-map.ts","../packages/collections/src/map/map-immutable-fns.ts","../packages/collections/src/map/map.ts","../packages/collections/src/map/map-mutable.ts","../packages/collections/src/map/map-of-multi-impl.ts","../packages/collections/src/map/map-of-set-mutable.ts","../packages/collections/src/map/map-of-circular-mutable.ts","../packages/collections/src/map/number-map.ts","../packages/collections/src/map/map-of-array-mutable.ts","../packages/collections/src/map/map-multi-fns.ts","../packages/collections/src/map/map-of-simple-base.ts","../packages/collections/src/map/map-of-simple-mutable.ts","../packages/collections/src/map/map-of-simple.ts","../packages/collections/src/map/index.ts","../packages/collections/src/table.ts","../packages/collections/src/graph/directed-graph.ts","../packages/collections/src/graph/undirected-graph.ts","../packages/collections/src/graph/index.ts"],"sourcesContent":["import { integerTest, resultThrow } from \"@ixfx/guards\";\n\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface ICircularArray<V> extends Array<V> {\n  /**\n   * Returns true if the array has filled to capacity and is now\n   * recycling array indexes.\n   */\n  get isFull(): boolean;\n\n  /**\n   * Returns a new Circular with item added\n   *\n   * Items are added at `pointer` position, which automatically cycles through available array indexes.\n   *\n   * @param value Thing to add\n   * @returns Circular with item added\n   */\n  add(value: V): ICircularArray<V>;\n\n  get length(): number;\n\n  /**\n   * Returns the current add position of array.\n   */\n  get pointer(): number;\n}\n\n/**\n * A circular array keeps a maximum number of values, overwriting older values as needed. Immutable.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = new CircularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = new CircularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport class CircularArray<V> extends Array {\n  #capacity: number;\n  #pointer: number;\n\n  constructor(capacity = 0) {\n    super();\n    // Allowed to create with capacity zero\n    resultThrow(integerTest(capacity, `positive`, `capacity`));\n\n    // Can't throw because .filter won't use ctor proprly\n    this.#capacity = capacity;\n    this.#pointer = 0;\n  }\n\n  /**\n   * Add to array\n   * @param value Thing to add\n   * @returns \n   */\n  add(value: V): CircularArray<V> {\n    const ca = CircularArray.from(this) as CircularArray<V>;\n    ca[ this.#pointer ] = value;\n    ca.#capacity = this.#capacity;\n    if (this.#capacity > 0) {\n      ca.#pointer =\n        this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n    } else {\n      ca.#pointer = this.#pointer + 1;\n    }\n    return ca;\n  }\n\n  get pointer(): number {\n    return this.#pointer;\n  }\n\n  get isFull(): boolean {\n    if (this.#capacity === 0) return false;\n    return this.length === this.#capacity;\n  }\n}\n","import type { QueueOpts } from './queue-types.js';\n\nexport const debug = (opts: QueueOpts<any>, message: string): void => {\n  opts.debug ? console.log(`queue:${ message }`) : undefined;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`: {\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [ ...queue, ...toAdd.slice(0, toRemove - 1) ];\n      }\n    }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`: {\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return [ ...toAdd.slice(0, capacity - 1), toAdd.at(-1)! ];\n        }\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        //return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [ ...toKeep, ...toAddFinal ];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`: {\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [ ...queue, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown overflow policy ${ policy }`);\n    }\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [ ...queue, ...toAdd ];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${ toReturn.length\n      } capacity: ${ opts.capacity } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${ toReturn.length\n      } expected: ${ potentialLength } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[ 0 ];\n\nexport const isEmpty = <V>(opts: QueueOpts<V>, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import { type IQueueMutable, type IQueueMutableWithEvents, type QueueMutableEvents } from './iqueue-mutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './queue-fns.js';\nimport { type QueueOpts } from './queue-types.js';\nimport { isEqualDefault, type IsEqual } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\n\n/**\n * Mutable queue that fires events when manipulated.\n * \n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n * \n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n * \n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @typeParam V - Data type of items\n */\nexport class QueueMutable<V> extends SimpleEventEmitter<QueueMutableEvents<V>> implements IQueueMutable<V> {\n  readonly options: QueueOpts<V>;\n  data: readonly V[];\n  eq: IsEqual<V>;\n\n  constructor(opts: QueueOpts<V> = {}, data: readonly V[] = []) {\n    super();\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.options = opts;\n    this.data = data;\n    this.eq = opts.eq ?? isEqualDefault;\n  }\n\n  clear() {\n    const copy = [ ...this.data ];\n    this.data = [];\n    this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n    this.onClear();\n  }\n\n  /**\n   * Called when all data is cleared\n   */\n  protected onClear() { /** no-op */\n  }\n\n  at(index: number): V {\n    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);\n    const v = this.data.at(index);\n    if (v === undefined) throw new Error(`Index appears to be outside range of queue`);\n    return v;\n  }\n\n  enqueue(...toAdd: readonly V[]): number {\n    this.data = enqueue(this.options, this.data, ...toAdd);\n    const length = this.data.length;\n    this.onEnqueue(this.data, toAdd);\n    return length;\n  }\n\n  protected onEnqueue(result: readonly V[], attemptedToAdd: readonly V[]) {\n    this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.options, this.data);\n    if (v === undefined) return;\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.options, this.data);\n    this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n    this.onRemoved([ v ], this.data);\n    return v;\n  }\n\n  protected onRemoved(removed: readonly V[], finalData: readonly V[]) {\n    this.fireEvent(`removed`, { removed, finalData });\n  }\n\n  /**\n   * Removes values that match `predicate`.\n   * @param predicate \n   * @returns Returns number of items removed.\n   */\n  removeWhere(predicate: (item: V) => boolean): number {\n    const countPre = this.data.length;\n    const toRemove = this.data.filter(v => predicate(v));\n    if (toRemove.length === 0) return 0;\n    this.data = this.data.filter((element) => !predicate(element));\n    this.onRemoved(toRemove, this.data);\n    return countPre - this.data.length;\n  }\n\n  /**\n * Return a copy of the array\n * @returns \n */\n  toArray(): V[] {\n    return [ ...this.data ];\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.options, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.options, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.options, this.data);\n  }\n}\n\n/**\n * Creates a new QueueMutable\n * @param options \n * @param startingItems \n * @returns \n */\nexport function mutable<V>(\n  options: QueueOpts<V> = {},\n  ...startingItems: readonly V[]\n): IQueueMutableWithEvents<V> {\n  return new QueueMutable({ ...options }, [ ...startingItems ]);\n}\n\n","import type { StackOpts } from './Types.js';\n\nexport const trimStack = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = stack.length + toAdd.length;\n  const policy = opts.discardPolicy ?? `additions`;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  if (opts.debug) {\n    console.log(\n      `Stack.push: stackLen: ${ stack.length } potentialLen: ${ potentialLength } toRemove: ${ toRemove } policy: ${ policy }`\n    );\n  }\n  switch (policy) {\n    case `additions`: {\n      if (opts.debug) {\n        console.log(\n          `Stack.push:DiscardAdditions: stackLen: ${ stack.length } slice: ${ potentialLength - capacity\n          } toAddLen: ${ toAdd.length }`\n        );\n      }\n\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (stack.length === opts.capacity) {\n        return stack; // Completely full\n      } else {\n        // Only add some from the new array\n        return [ ...stack, ...toAdd.slice(0, toAdd.length - toRemove) ];\n      }\n    }\n    case `newer`: {\n      if (toRemove >= stack.length) {\n        // New items will completely flush out old\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n      } else {\n        // Keep some of the old (from 0)\n        //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n        if (opts.debug) {\n          console.log(` from orig: ${ JSON.stringify(stack.slice(0, stack.length - toRemove)) }`);\n        }\n        return [\n          ...stack.slice(0, stack.length - toRemove),\n          ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n        ];\n      }\n    }\n    case `older`: {\n      // Oldest item in stack is position 0\n      return [ ...stack, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown discard policy ${ policy }`);\n    }\n  }\n};\n\n// Add to top (last index)\nexport const push = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\n  //const mutated = [...stack, ...toAdd];\n  const potentialLength = stack.length + toAdd.length;\n\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n  const toReturn = overSize\n    ? trimStack(opts, stack, toAdd)\n    : [ ...stack, ...toAdd ];\n  return toReturn;\n};\n\n// Remove from top (last index)\nexport const pop = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (stack.length === 0) throw new Error(`Stack is empty`);\n  return stack.slice(0, - 1);\n};\n\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): V | undefined => stack.at(-1);\n\nexport const isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean =>\n  stack.length === 0;\n\nexport const isFull = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return stack.length >= opts.capacity;\n  }\n  return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\n\nimport type { IStackMutable } from './IStackMutable.js';\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\nimport type { StackOpts } from './Types.js';\n\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable<V> implements IStackMutable<V> {\n  readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  /**\n   * Push data onto the stack.\n   * If `toAdd` is empty, nothing happens\n   * @param toAdd Data to add\n   * @returns Length of stack\n   */\n  push(...toAdd: ReadonlyArray<V>): number {\n    if (toAdd.length === 0) return this.data.length;\n    this.data = push(this.opts, this.data, ...toAdd);\n    return this.data.length;\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  pop(): V | undefined {\n    const v = peek(this.opts, this.data);\n    this.data = pop(this.opts, this.data);\n    return v;\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = <V>(\n  opts: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackMutable<V> => new StackMutable({ ...opts }, [ ...startingItems ]);\n","import { type IsEqual, isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport * as TreeMutable from './tree-mutable.js';\nimport type { TreeNode, TraversableTree } from './types.js';\n\nexport type DiffAnnotation<T> = {\n  /**\n   * In the case of changes, this is old value\n   */\n  a: TraversableTree<T>\n  /**\n   * In the case of changes, this is the new value\n   */\n  b: TraversableTree<T>\n  /**\n   * If true, this node's value has been modified\n   */\n  valueChanged: boolean\n  /**\n   * If true, one of the child values has changed\n   */\n  childChanged: boolean\n  /**\n   * List of new children\n   */\n  added: TraversableTree<T>[]\n  /**\n   * List of removed children\n   */\n  removed: TraversableTree<T>[]\n}\n\nexport type DiffNode<T> = TreeNode<DiffAnnotation<T>> & {\n  toString: () => string\n};\n\nexport const compare = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder, parent?: DiffNode<T>): DiffNode<T> => {\n  const valueEqual = valueOrIdentityEqual(a, b, eq);\n  // if (!valueEqual) {\n  //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n  // }\n  const childrenCompare = compareChildren(a, b, eq);\n\n  const diff: DiffAnnotation<T> = {\n    valueChanged: !valueEqual, a, b,\n    added: childrenCompare.added,\n    removed: childrenCompare.removed,\n    childChanged: false\n  }\n  const diffNode: DiffNode<T> = {\n    value: diff,\n    childrenStore: [],\n    parent\n  }\n\n  const childrenDiff = childrenCompare.identical.map(c => compare(c[ 0 ], c[ 1 ], eq, diffNode));\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value!));\n  TreeMutable.setChildren(diffNode, childrenDiff);\n  //diffNode.childrenStore = childrenDiff;\n\n  diffNode.toString = () => toString(diffNode, 0);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  diffNode.value!.childChanged = someChildChange;\n  TreeMutable.throwTreeTest(diffNode);\n\n  return diffNode;\n}\n\nconst hasChange = (vv: DiffAnnotation<any>): boolean => {\n  if (vv === undefined) return false;\n  if (vv.valueChanged) return true;\n  if (vv.childChanged) return true;\n  if (vv.added.length > 0) return true;\n  if (vv.removed.length > 0) return true;\n  return false;\n}\n\n\nconst compareChildren = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T> = isEqualValueIgnoreOrder) => {\n  const childrenOfA = [ ...a.children() ];\n  const childrenOfB = [ ...b.children() ];\n\n  const identical: [ a: TraversableTree<T>, b: TraversableTree<T> ][] = []\n  const removed: TraversableTree<T>[] = [];\n  for (const childA of childrenOfA) {\n    let foundIndex = -1;\n    for (const [ index, childOfB ] of childrenOfB.entries()) {\n      const d = valueOrIdentityEqual(childA, childOfB, eq);\n      if (d) {\n        identical.push([ childA, childOfB ]);\n        foundIndex = index;\n        break;\n      }\n    }\n    if (foundIndex === -1) {\n      // A's child not found in B's children\n      removed.push(childA);\n    } else {\n      // Found, remove it from list of B's children\n      childrenOfB.splice(foundIndex, 1);\n    }\n  }\n  const added = [ ...childrenOfB ];\n  return { added, identical, removed }\n}\n\nconst valueOrIdentityEqual = <T>(a: TraversableTree<T>, b: TraversableTree<T>, eq: IsEqual<T>): boolean => {\n  if (a.getIdentity() === b.getIdentity()) return true;\n  if (eq(a.getValue(), b.getValue())) return true;\n  return false;\n}\n\nconst toStringSingle = <T>(n: TraversableTree<T>): string => {\n  return JSON.stringify(n.getValue());\n}\n\nconst toString = <T>(n: DiffNode<T>, indent = 0): string => {\n  if (n === undefined) return `(undefined)`;\n  let t = toStringDiff(n.value, indent);\n  for (const c of n.childrenStore) {\n    t += toString(c, indent + 2);\n  }\n  return t;\n}\n\nconst toStringDiff = <T>(n: DiffAnnotation<T> | undefined, indent: number): string => {\n  const spaces = ` `.repeat(indent);\n  if (n === undefined) return `${ spaces }(undefined)`;\n  const t: string[] = [];\n  t.push(`a: ${ toStringSingle(n.a) } b: ${ toStringSingle(n.b) }`);\n  if (n.valueChanged) t.push(`Value changed. Child changed: ${ n.childChanged }`);\n  else t.push(`Value unchanged. Child changed: ${ n.childChanged }`);\n\n  if (n.added.length > 0) {\n    t.push(`Added:`);\n    for (const c of n.added) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  if (n.removed.length > 0) {\n    t.push(`Removed: ${ n.removed.length }`);\n    for (const c of n.removed) {\n      t.push(` - ` + toStringSingle(c));\n    }\n  }\n  t.push(`----\\n`)\n  return t.map(line => spaces + line).join(`\\n`);\n}","import { isEqualDefault, type IsEqual } from \"@ixfx/core\"\nimport { without } from '@ixfx/arrays';\nimport { containsDuplicateInstances } from \"@ixfx/arrays\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\"\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { compare as treeCompare } from './compare.js';\nimport { toStringAbbreviate } from \"@ixfx/core/text\";\nimport type { LabelledSingleValue, TreeNode, SimplifiedNode, TraversableTree } from \"./types.js\"\n\n/**\n * Compares two nodes.\n * \n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a \n * @param b \n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = <T>(a: TreeNode<T>, b: TreeNode<T>, eq?: IsEqual<T>) => {\n  return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n}\n\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n * \n * Recursive: strips parentage of all children and so on too.\n * @param node \n * @returns \n */\nexport const stripParentage = <T>(node: TreeNode<T>): SimplifiedNode<T> => {\n  const n: SimplifiedNode<T> = {\n    value: node.value,\n    childrenStore: node.childrenStore.map(c => stripParentage(c))\n  }\n  return n;\n}\n/**\n * Wraps a {@link TreeNode} for a more object-oriented means of access.\n */\nexport type WrappedNode<T> = TraversableTree<T> & {\n  /**\n   * Underlying Node\n   */\n  wraps: TreeNode<T>,\n  /**\n   * Gets value, if defined\n   * @returns Value of Node\n   */\n  getValue: () => T | undefined\n  /**\n   * Remove node and its children from tree\n   * @returns \n   */\n  remove: () => void\n  /**\n   * Adds a child node\n   * @param child \n   * @returns \n   */\n  add: (child: WrappedNode<T> | TreeNode<T>) => WrappedNode<T>\n  /**\n   * Adds a new child node, with `value` as its value\n   * @param value \n   * @returns \n   */\n  addValue: (value: T) => WrappedNode<T>\n  /**\n   * Returns _true_ if `child` is an immediate child of this node\n   * @param child \n   * @returns \n   */\n  hasChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  queryValue: (value: T) => IterableIterator<WrappedNode<T>>\n  /**\n   * Returns _true_ if `child` is contained any any descendant\n   * @param child\n   * @returns \n   */\n  hasAnyChild: (child: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate parent for this node\n   * @param parent \n   * @returns \n   */\n  hasParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n  /**\n   * Returns _true_ if `parent` is the immediate or ancestor parent for this node\n   * @param parent \n   * @returns \n   */\n  hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>) => boolean\n}\n\nconst unwrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = <T>(node: TreeNode<T> | WrappedNode<T>) => (`wraps` in node) ? node : wrap(node);\n\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns \n */\nexport const wrap = <T>(n: TreeNode<T>): WrappedNode<T> => {\n  return {\n    *children() {\n      for (const c of n.childrenStore) {\n        yield wrap(c)\n      }\n    },\n    getValue: () => n.value as T,\n    getIdentity: () => n,\n    *queryValue(value: T): IterableIterator<WrappedNode<T>> {\n      for (const v of queryByValue(value, unwrapped(n))) {\n        yield wrap(v);\n      }\n    },\n    getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n    hasParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasParent(n, unwrapped(parent));\n    },\n    hasAnyParent: (parent: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyParent(n, unwrapped(parent));\n    },\n    hasChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasChild(unwrapped(child), n);\n    },\n    hasAnyChild: (child: WrappedNode<T> | TreeNode<T>): boolean => {\n      return hasAnyChild(unwrapped(child), n);\n    },\n    remove: () => {\n      remove(n);\n    },\n    addValue: (value: T): WrappedNode<T> => {\n      const nodeValue = addValue(value, n);\n      return wrap(nodeValue);\n    },\n    add: (child: WrappedNode<T> | TreeNode<T>): WrappedNode<T> => {\n      add(unwrapped(child), n);\n      return wrapped(child);\n    },\n    wraps: n\n  }\n}\n\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child \n * @returns \n */\nexport const remove = <T>(child: TreeNode<T>) => {\n  const p = child.parent;\n  if (p === undefined) return;\n  child.parent = undefined;\n  p.childrenStore = without(p.childrenStore, child);\n};\n\n/**\n * Depth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* depthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!root) return;\n  const stack = new StackMutable<TreeNode<T>>();\n  stack.push(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = stack.pop();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      stack.push(...entry.childrenStore);\n    }\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n  }\n}\n\n/**\n * Breadth-first iteration of the children of `node`\n * @param node \n * @returns \n */\nexport function* breadthFirst<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  if (!node) return;\n  const queue = new QueueMutable<TreeNode<T>>();\n  queue.enqueue(...node.childrenStore);\n  let entry: TreeNode<T> | undefined = queue.dequeue();\n  while (entry) {\n    yield entry;\n    if (entry) {\n      queue.enqueue(...entry.childrenStore);\n    }\n    if (queue.isEmpty) break;\n    entry = queue.dequeue();\n  }\n}\n\n/**\n * Validates the tree from `root` downwards.\n * @param root \n * @param seen \n * @returns \n */\nexport function treeTest<T>(root: TreeNode<T>, seen: TreeNode<T>[] = []): [ ok: boolean, msg: string, node: TreeNode<T> ] {\n  if (root.parent === root) return [ false, `Root has itself as parent`, root ];\n  if (seen.includes(root)) return [ false, `Same node instance is appearing further in tree`, root ];\n  seen.push(root);\n  if (containsDuplicateInstances(root.childrenStore)) return [ false, `Children list contains duplicates`, root ];\n\n  for (const c of root.childrenStore) {\n    if (c.parent !== root) return [ false, `Member of childrenStore does not have .parent set`, c ];\n    if (hasAnyChild(root, c)) return [ false, `Child has parent as its own child`, c ];\n    const v = treeTest(c, seen);\n    if (!v[ 0 ]) return v;\n  }\n  return [ true, ``, root ];\n}\n\n/**\n * Throws an exception if `root` fails tree validation\n * @param root \n * @returns \n */\nexport function throwTreeTest<T>(root: TreeNode<T>) {\n  const v = treeTest(root);\n  if (v[ 0 ]) return;\n  throw new Error(`${ v[ 1 ] } Node: ${ toStringAbbreviate(v[ 2 ].value, 30) }`, { cause: v[ 2 ] })\n}\n/**\n * Iterate over direct children of `root`\n * @param root \n */\nexport function* children<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  for (const c of root.childrenStore) {\n    yield c;\n  }\n}\n\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root \n */\nexport function* parents<T>(root: TreeNode<T>): IterableIterator<TreeNode<T>> {\n  let p = root.parent;\n  while (p) {\n    yield p;\n    p = p.parent;\n  }\n}\n\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node \n * @returns \n */\nexport function nodeDepth(node: TreeNode<any>): number {\n  const p = [ ...parents(node) ];\n  return p.length;\n}\n\nexport const hasChild = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of parent.childrenStore) {\n    if (c === child) return true;\n  }\n  return false;\n}\n\nexport const findChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): TreeNode<T> | undefined => {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) return c;\n  }\n}\n\nexport function* queryByValue<T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault): IterableIterator<TreeNode<T>> {\n  for (const c of parent.childrenStore) {\n    if (eq(value, c.value as T)) yield c;\n  }\n}\n\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n * \n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild \n * @param parent \n * @returns \n */\nexport const hasAnyChild = <T>(prospectiveChild: TreeNode<T>, parent: TreeNode<T>) => {\n  for (const c of breadthFirst(parent)) {\n    if (c === prospectiveChild) return true;\n  }\n  return false;\n}\n\nexport const findAnyChildByValue = <T>(value: T, parent: TreeNode<T>, eq: IsEqual<T> = isEqualDefault) => {\n  for (const c of breadthFirst(parent)) {\n    if (eq(c.value as T, value)) return c;\n  }\n}\n\nexport const getRoot = <T>(node: TreeNode<T>): TreeNode<T> => {\n  if (node.parent) return getRoot(node.parent);\n  return node;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n * \n * Use {@link hasParent} to only check immediate parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasAnyParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  for (const p of parents(child)) {\n    if (p === prospectiveParent) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n * \n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child \n * @param prospectiveParent \n * @returns \n */\nexport const hasParent = <T>(child: TreeNode<T>, prospectiveParent: TreeNode<T>) => {\n  return child.parent === prospectiveParent;\n}\n\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root); \n * ```\n * @param node \n * @returns \n */\nexport const computeMaxDepth = <T>(node: TreeNode<T>) => {\n  return computeMaxDepthImpl(node, 0);\n}\n\nconst computeMaxDepthImpl = <T>(node: TreeNode<T>, startingDepth = 0) => {\n  let depth = startingDepth;\n  for (const c of node.childrenStore) {\n    depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n  }\n  return depth;\n}\n\nexport const add = <T>(child: TreeNode<T>, parent: TreeNode<T>) => {\n  throwAttemptedChild(child, parent);\n  //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n  //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n  const p = child.parent;\n  parent.childrenStore = [ ...parent.childrenStore, child ];\n  child.parent = parent;\n  if (p) {\n    p.childrenStore = without(p.childrenStore, child);\n  }\n}\n\nexport const addValue = <T>(value: T | undefined, parent: TreeNode<T>) => {\n  return createNode(value, parent);\n}\n\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value \n * @returns \n */\nexport const root = <T>(value?: T) => {\n  return createNode(value);\n}\n\nexport const fromPlainObject = (value: Record<string, any>, label = ``, parent?: TreeNode<any>, seen: any[] = []): TreeNode<LabelledSingleValue<any>> => {\n  const entries = Object.entries(value);\n  parent = parent === undefined ? root() : addValue<LabelledSingleValue<any>>({ label, value }, parent);\n  for (const entry of entries) {\n    const value = entry[ 1 ];\n    // Avoid circular references\n    if (seen.includes(value)) continue;\n    seen.push(value);\n\n    if (typeof entry[ 1 ] === `object`) {\n      fromPlainObject(value, entry[ 0 ], parent, seen);\n    } else {\n      addValue<LabelledSingleValue<any>>({ label: entry[ 0 ], value: value }, parent);\n    }\n  }\n  return parent;\n}\n\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link root} alternatively.\n * @param value \n * @returns \n */\nexport const rootWrapped = <T>(value: T | undefined) => {\n  return wrap(createNode(value));\n}\n\nexport const createNode = <T>(value: T | undefined, parent?: TreeNode<T>): TreeNode<T> => {\n  const n: TreeNode<T> = {\n    childrenStore: [],\n    parent: parent,\n    value: value\n  }\n  if (parent !== undefined) {\n    parent.childrenStore = [ ...parent.childrenStore, n ];\n  }\n  return n;\n}\n\nexport const childrenLength = <T>(node: TreeNode<T>): number => {\n  return node.childrenStore.length;\n}\n\nexport const value = <T>(node: TreeNode<T>): T | undefined => {\n  return node.value;\n}\n\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node \n * @returns \n */\nexport const asDynamicTraversable = <T>(node: TreeNode<T>): TraversableTree<T> => {\n  const t: TraversableTree<T> = {\n    *children() {\n      for (const c of node.childrenStore) {\n        yield asDynamicTraversable(c);\n      }\n    },\n    getParent() {\n      if (node.parent === undefined) return;\n      return asDynamicTraversable(node.parent);\n    },\n    getValue(): any {\n      return node.value;\n    },\n    getIdentity() {\n      return node;\n    },\n  }\n  return t;\n}\n\nconst throwAttemptedChild = <T>(c: TreeNode<T>, parent: TreeNode<T>) => {\n  if (parent === c) throw new Error(`Cannot add self as child`);\n  if (c.parent === parent) return; // skip if it's already a child\n  if (hasAnyParent(parent, c)) throw new Error(`Child contains parent (1)`, { cause: c });\n  if (hasAnyParent(c, parent)) throw new Error(`Parent already contains child`, { cause: c });\n  if (hasAnyChild(parent, c)) throw new Error(`Child contains parent (2)`, { cause: c });\n}\n\nexport const setChildren = <T>(parent: TreeNode<T>, children: TreeNode<T>[]) => {\n  // Verify children are legit\n  for (const c of children) {\n    throwAttemptedChild(c, parent);\n  }\n\n  parent.childrenStore = [ ...children ];\n  for (const c of children) {\n    c.parent = parent;\n  }\n}\n\nexport const toStringDeep = <T>(node: TreeNode<T>, indent = 0): string => {\n  const t = `${ `  `.repeat(indent) } + ${ node.value ? JSON.stringify(node.value) : `-` }`;\n  return node.childrenStore.length > 0 ? (\n    t +\n    `\\n` +\n    node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)\n  ) : t;\n}\n\nexport function* followValue<T>(root: TreeNode<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T | undefined> {\n  for (const c of root.childrenStore) {\n    const value = c.value;\n    if (value === undefined) continue;\n    if (continuePredicate(value, depth)) {\n      yield c.value;\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }","import { toStringAbbreviate } from '@ixfx/core/text';\n\nimport { last } from '@ixfx/iterables/sync';\nimport * as TreeArrayBacked from './tree-mutable.js';\nimport { isPrimitive } from '@ixfx/core'; //'../../util/IsPrimitive.js';\nimport type { TraversableTree, TreeNode, SimplifiedNode } from './types.js';\nimport { nullUndefTest, resultThrow } from '@ixfx/guards' //'../../util/GuardEmpty.js';\nexport type Entry = Readonly<{ name: string, sourceValue: any, nodeValue: any }>;\nexport type EntryWithAncestors = Readonly<{ name: string, sourceValue: any, nodeValue: any, ancestors: string[] }>;\n//export type EntryStatic = Readonly<{ name: string, value: any, ancestors?: Array<string> }>\nexport type EntryStatic = Readonly<{ name: string, value: any, ancestors: string[] }>\n\n\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n  /**\n   * Separator for path, eg '.'\n   */\n  readonly separator?: string;\n\n};\n\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link Entry}.\n * @param entries \n * @returns \n */\nexport function prettyPrintEntries(entries: readonly Entry[]) {\n  if (entries.length === 0) return `(empty)`;\n  let t = ``;\n  for (const [ index, entry ] of entries.entries()) {\n    t += `  `.repeat(index);\n    t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n  }\n  return t;\n}\n\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const prettyPrint = (\n  node: object,\n  indent = 0,\n  options: Partial<ChildrenOptions> = {}\n): string => {\n  resultThrow(nullUndefTest(node, `node`));\n  const defaultName = options.name ?? `node`;\n  const entry = getNamedEntry(node, defaultName);\n  const t = `${ `  `.repeat(indent) } + name: ${ entry.name } value: ${ JSON.stringify(entry.nodeValue) }`;\n  const childrenAsArray = [ ...children(node, options) ];\n  return childrenAsArray.length > 0 ? (\n    t +\n    `\\n` +\n    childrenAsArray.map((d) => prettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)\n  ) : t;\n};\n\n/**\n * Returns a debug string representation of the node (recursive)\n * @param node \n * @param indent \n * @returns \n */\nexport const toStringDeep = (node: TreeNode<Entry | EntryStatic>, indent = 0) => {\n  let t = ` `.repeat(indent) + ` ${ node.value?.name }`;\n  if (node.value !== undefined) {\n    if (`sourceValue` in node.value && `nodeValue` in node.value) {\n      let sourceValue = toStringAbbreviate(node.value.sourceValue, 20);\n      const nodeValue = toStringAbbreviate(node.value.nodeValue, 20);\n      sourceValue = sourceValue === nodeValue ? `` : `source: ` + sourceValue;\n      t += ` = ${ nodeValue } ${ sourceValue }`\n    } else if (`value` in node.value && node.value.value !== undefined) t += ` = ${ node.value.value }`;\n\n    if (`ancestors` in node.value) {\n\n      t += ` (ancestors: ${ (node.value.ancestors).join(`, `) })`;\n    }\n  }\n  t += `\\n`\n  for (const c of node.childrenStore) {\n    t += toStringDeep(c, indent + 1);\n  }\n  return t;\n}\n\nexport type ChildrenOptions = Readonly<{\n  /**\n   * If set, only uses leaves or branches. 'none' means there is no filter.\n   */\n  filter: `none` | `leaves` | `branches`\n  /**\n   * Default name to use. This is necessary in some cases, eg a root object.\n   */\n  name: string\n}>;\n\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays. \n * \n * Sub-children are included as an object blob.\n * \n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n * \n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n * \n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children: \n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n * \n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node \n * @param options  \n */\nexport function* children<T extends object>(\n  node: T,\n  options: Partial<ChildrenOptions> = {}\n): IterableIterator<Entry> {\n  resultThrow(nullUndefTest(node, `node`));\n\n  const filter = options.filter ?? `none`;\n\n  const filterByValue = (v: any): [ filter: boolean, isPrimitive: boolean ] => {\n    if (filter === `none`) return [ true, isPrimitive(v) ];\n    else if (filter === `leaves` && isPrimitive(v)) return [ true, true ];\n    else if (filter === `branches` && !isPrimitive(v)) return [ true, false ];\n    return [ false, isPrimitive(v) ];\n  }\n\n  if (Array.isArray(node)) {\n    //if (options.name === undefined) defaultName = `array`;\n    for (const [ index, element ] of node.entries()) {\n      const f = filterByValue(element);\n      if (f[ 0 ]) {\n        yield { name: index.toString(), sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n        //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n      }\n    }\n  } else if (typeof node === `object`) {\n    const entriesIter = (`entries` in node) ? (node as any as Map<any, any>).entries() : Object.entries(node);\n    for (const [ name, value ] of entriesIter) {\n      //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n      const f = filterByValue(value);\n      if (f[ 0 ]) {\n        yield { name: name, sourceValue: value, nodeValue: f[ 1 ] ? value : undefined };\n      }\n    }\n  }\n}\n\nexport function* depthFirst<T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: string[] = []): IterableIterator<EntryWithAncestors> {\n  for (const c of children(node, options)) {\n    //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n    yield { ...c, ancestors: [ ...ancestors ] };\n    yield* depthFirst(c.sourceValue, options, [ ...ancestors, c.name ]);\n  }\n}\n\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName<T extends object>(\n  name: string,\n  node: T\n): Entry | undefined {\n  for (const d of children(node)) {\n    if (d.name === name) return d;\n  }\n}\n\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Entry {\n  //  Unit tested\n  const v = last(traceByPath(path, node, options));\n  if (!v) throw new Error(`Could not trace path: ${ path } `);\n  return v;\n}\n\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n * \n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n * \n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Iterable<EntryWithAncestors> {\n  resultThrow(\n    nullUndefTest(path, `path`),\n    nullUndefTest(node, `node`)\n  );\n\n  const separator = options.separator ?? `.`;\n  // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n  const pathSplit = path.split(separator);\n\n  const ancestors: string[] = [];\n  for (const p of pathSplit) {\n    const entry = childByName(p, node);\n    //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n    // if (allowArrayIndexes) {\n    //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n    //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n    //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n    //   if (arrayIndex >= 0) {\n    //     // Get array by name without the []\n    //     entry = childByName(withoutBrackets, node);\n    //     //onsole.log(`  entry: ${ entry?.name }`);\n    //     if (entry && Array.isArray(entry.sourceValue)) {\n    //       // Result was array as expected\n    //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], nodeValue: entry.sourceValue[ arrayIndex ] };\n    //     }\n    //   }\n    // }\n\n    if (!entry) {\n      yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n      return;\n    }\n    node = entry.sourceValue;\n    yield { ...entry, ancestors: [ ...ancestors ] };\n    ancestors.push(p);\n  }\n}\n\n/**\n * Returns a projection of `node` as a dynamic traversable.\n * This means that the tree structure is dynamically created as last-minute as possible.\n * \n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n * \n * ```js\n * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n * \n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n * \n * Instead .getIdentity() to get a stable identity:\n * ```js\n * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n * @param node Object to read\n * @param options Options when creating traversable\n * @param ancestors Do not use\n * @param parent Do not use\n * @returns \n */\nexport const asDynamicTraversable = <T extends object>(node: T, options: Partial<ChildrenOptions> = {}, ancestors: string[] = [], parent?: TraversableTree<EntryStatic>): TraversableTree<EntryStatic> => {\n  const name = options.name ?? `object`;\n  const t: TraversableTree<EntryStatic> = {\n    *children() {\n      for (const c of children(node, options)) {\n        yield asDynamicTraversable(c.sourceValue, { ...options, name: c.name }, [ ...ancestors, name ], t);\n      }\n    },\n    getParent() {\n      return parent;\n    },\n    getValue() {\n      return { name, value: node, ancestors };\n    },\n    getIdentity() {\n      return node;\n    }\n  }\n  return t;\n}\n\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node \n * @param options \n * @returns \n */\nexport const createWrapped = <T extends object>(node: T, options: Partial<CreateOptions>): TreeArrayBacked.WrappedNode<any> => {\n  return TreeArrayBacked.wrap(create(node, options));\n};\n\nexport type CreateOptions = {\n  name: string\n  /**\n   * If _true_, only leaf nodes have values. This avoids repetition (important\n   * when comparing trees), with semantics being in the tree itself.\n   * \n   * When _false_ (default) values get decomposed down the tree. This\n   * makes it easy to get all the data for a branch of the tree.\n   * \n   * \n   * Eg if storing { person: { address { state: `qld` } } }\n   * When _true_, the tree would be:\n   * ```\n   * person, value: undefined\n   *  + address, value: undefined\n   *    + state, value: 'qld'\n   * ```\n   * But when _false_, the tree would be:\n   * ```\n   * person, value: { address: { state: `qld } }\n   *  + address, value: { state: `qld` }\n   *    + state, value: `qld`\n   * ```\n   */\n  valuesAtLeaves: boolean\n}\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure.\n * The structure is a snapshot of the object. If the object changes afterwards, the tree will\n * remain the same.\n * \n * Alternatively, consider {@link asDynamicTraversable} which reads the object dynamically.\n * @param node \n * @param options \n * @returns \n */\nexport const create = <T extends object>(node: T, options: Partial<CreateOptions> = {}): TreeNode<EntryStatic> => {\n  const valuesAtLeaves = options.valuesAtLeaves ?? false;\n\n  const valueFor = valuesAtLeaves ? (v: any) => { if (isPrimitive(v)) return v; } : (v: any) => v;\n  return createImpl(node, valueFor(node), options, []);\n}\n\nconst createImpl = <T extends object>(sourceValue: T, nodeValue: T, options: Partial<CreateOptions> = {}, ancestors: string[]): TreeNode<EntryStatic> => {\n  const defaultName = options.name ?? `object_ci`;\n  //onsole.log(`createImpl name: ${ defaultName } nodeValue: ${ JSON.stringify(nodeValue) }`);\n  const r = TreeArrayBacked.root<EntryStatic>({ name: defaultName, value: nodeValue, ancestors: [ ...ancestors ] });\n  ancestors = [ ...ancestors, defaultName ];\n  for (const c of children(sourceValue, options)) {\n    const v = options.valuesAtLeaves ? c.nodeValue : c.sourceValue;\n    TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n  }\n  return r;\n}\n\n/**\n * Returns a copy of `node` with its (and all its children's) parent information removed.\n * @param node \n * @param options \n * @returns \n */\nexport const createSimplified = <T extends object>(node: T, options: Partial<CreateOptions> = {}): SimplifiedNode<EntryStatic> => {\n  return TreeArrayBacked.stripParentage(create(node, options));\n}\n\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry<T extends object>(node: T, defaultName = ``): Entry {\n  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node as Entry;\n  if (`name` in node) {\n    return { name: node.name as string, nodeValue: node, sourceValue: node };\n  }\n  return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n\n\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }","import * as TreeArrayBacked from \"./tree-mutable.js\";\nimport type { LabelledValue, LabelledNode, TreeNode } from \"./types.js\";\n/**\n * Options for parsing a path\n */\nexport type PathOpts = Readonly<{\n  /**\n   * Separator for path, eg '.'\n   */\n  separator: string;\n  /**\n   * If two values are stored at same path, what to do? Default: overwrite\n   * * overwrite: last-write wins\n   * * ignore: first-write wins\n   * * allow: allow multiple values\n   */\n  duplicates: `overwrite` | `allow` | `ignore`\n}>;\n\n\n\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n * \n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n * \n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n * \n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n * \n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts \n * @returns \n */\nexport const create = <T>(pathOpts: Partial<PathOpts> = {}) => {\n  let root: TreeNode<LabelledValue<T>> | undefined;\n\n  const add = (value: T, path: string) => {\n    const n = addValueByPath(value, path, root, pathOpts);\n    if (root === undefined) {\n      root = TreeArrayBacked.getRoot(n);\n    }\n  }\n\n  const prettyPrint = () => {\n    if (root === undefined) return `(empty)`;\n    return TreeArrayBacked.toStringDeep(root);\n  }\n\n  const getValue = (path: string): T | undefined => {\n    if (root === undefined) return;\n    return valueByPath(path, root, pathOpts);\n  }\n\n  const remove = (path: string): boolean => {\n    if (root === undefined) return false;\n    return removeByPath(path, root, pathOpts);\n  }\n\n  const hasPath = (path: string): boolean => {\n    if (root === undefined) return false;\n    const c = findChildByPath(path, root, pathOpts);\n    return c !== undefined;\n  }\n\n  const getNode = (path: string): LabelledNode<T> | undefined => {\n    if (root === undefined) return;\n    const c = findChildByPath(path, root, pathOpts);\n    return c;\n  }\n\n  const childrenLength = (path: string): number => {\n    if (root === undefined) return 0;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined) return 0;\n    return c.childrenStore.length;\n  }\n\n  const getValues = (path: string): T[] => {\n    if (root === undefined) return [];\n    return valuesByPath(path, root, pathOpts);\n  }\n\n  const getRoot = () => {\n    return root;\n  }\n  const clearValues = (path: string): boolean => {\n    if (root === undefined) return false;\n    return clearValuesByPath(path, root, pathOpts);\n  }\n  return { getRoot, add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues }\n}\n\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n * \n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = <T>(value: T, path: string, node?: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): LabelledNode<T> => {\n  const separator = pathOpts.separator ?? `.`;\n  const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n  const split = path.split(separator);\n  let count = 0;\n  for (const p of split) {\n    const lastEntry = count === split.length - 1;\n    //onsole.log(`p: ${ p }`);\n    const found = findChildByLabel(p, node);\n    if (found === undefined) {\n      //onsole.log(`  - not found`);\n      const labelled: LabelledValue<T> = {\n        value: (lastEntry ? value : undefined),\n        label: p\n      };\n      node = TreeArrayBacked.createNode(labelled, node);\n    } else {\n      node = found;\n      if (lastEntry) {\n        switch (duplicatePath) {\n          case `ignore`: {\n            break;\n          }\n          case `allow`: {\n            const existing = getValuesFromNode(node);\n            node.value = {\n              values: [ ...existing, value ],\n              label: p\n            }\n            break;\n          }\n          case `overwrite`: {\n            node.value = {\n              value,\n              label: p\n            }\n            break;\n          }\n        }\n      } else {\n        //onsole.log(`  - found!`, found.value);\n        node = found;\n      }\n    }\n    count++;\n  }\n  if (node === undefined) throw new Error(`Could not create tree`);\n  return node;\n}\n\nexport const removeByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  TreeArrayBacked.remove(c);\n  return true;\n}\n\nexport const clearValuesByPath = <T>(path: string, root: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): boolean => {\n  if (root === undefined) return false;\n  const c = findChildByPath(path, root, pathOpts);\n  if (c === undefined) return false;\n  c.value = {\n    label: c.value?.label ?? ``,\n    value: undefined\n  }\n  return true;\n}\nexport const childrenLengthByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): number => {\n  if (node === undefined) return 0;\n  const c = findChildByPath(path, node, pathOpts);\n  if (c === undefined) return 0;\n  return c.childrenStore.length;\n}\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = <T>(label: string, node: LabelledNode<T> | undefined): LabelledNode<T> | undefined => {\n  if (node === undefined) return undefined;\n  if (label === undefined) throw new Error(`Parameter 'label' cannot be undefined`);\n  if (node.value?.label === label) return node;\n  for (const c of node.childrenStore) {\n    if (c.value?.label === label) return c;\n  }\n}\n\nexport const valueByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): T | undefined => {\n  const values = valuesByPath(path, node, pathOpts);\n  if (values.length === 0) return undefined;\n  if (values.length > 1) throw new Error(`Multiple values at path. Use getValues instead`);\n  return values[ 0 ];\n}\n\nconst getValuesFromNode = <T>(c: LabelledNode<T>): T[] => {\n  if (c.value === undefined) return [];\n  if (`values` in c.value) return c.value.values;\n  if (`value` in c.value) {\n    if (c.value.value === undefined) return [];\n    return [ c.value.value ];\n  }\n  return [];\n}\n\nconst findChildByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}) => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      return;\n    }\n  }\n  return c;\n}\n\nexport const valuesByPath = <T>(path: string, node: LabelledNode<T>, pathOpts: Partial<PathOpts> = {}): T[] => {\n  const separator = pathOpts.separator ?? `.`;\n  const split = path.split(separator);\n  let c: LabelledNode<T> | undefined = node;\n  for (const p of split) {\n    //onsole.log(`getValue p: ${ p }`);\n    c = findChildByLabel(p, c);\n    if (c === undefined) {\n      //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n      return [];\n    }\n  }\n  return getValuesFromNode(c);\n}","import { toStringAbbreviate } from \"@ixfx/core/text\";\nimport { isEqualDefault, type IsEqual } from \"@ixfx/core\"; //\"../../util/IsEqual.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { isTraversable } from \"./index.js\";\nimport type { TraversableTree, TreeNode } from \"./types.js\";\n\nexport const childrenLength = <T>(tree: TraversableTree<T>): number => {\n  return [ ...tree.children() ].length;\n}\n\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  child: T,\n  possibleParent: T,\n  eq?: IsEqual<T>\n): boolean => {\n  return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyParentValue = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  child: T,\n  possibleParentValue: TV,\n  eq?: IsEqual<TV>\n): boolean => {\n  return hasParentValue<T, TV>(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const findAnyParentByValue = <TValue>(\n  child: TraversableTree<TValue>,\n  possibleParentValue: TValue,\n  eq?: IsEqual<TValue>\n): TraversableTree<TValue> | undefined => {\n  return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  child: T,\n  possibleParent: T,\n  eq: IsEqual<T> = isEqualDefault<T>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const isChildTrav = isTraversable(child);\n  const isParentTrav = isTraversable(possibleParent);\n  const p = (isChildTrav ? child.getParent() : child.parent) as T;\n  if (typeof p === `undefined`) return false;\n  if (eq(p, possibleParent)) return true;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const pId = isChildTrav ? (p as TraversableTree<TV>).getIdentity() : (p as TreeNode<TV>).value;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const ppId = isParentTrav ? (possibleParent).getIdentity() : (possibleParent as any as TreeNode<TV>).value;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  if (eq(pId, ppId)) return true;\n  //if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n  return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\n\nexport const hasParentValue = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  child: T,\n  possibleParentValue: TV,\n  eq: IsEqual<TV> = isEqualDefault<TV>,\n  maxDepth = 0\n): boolean => {\n  if (maxDepth < 0) return false;\n  const p = `getParent` in child ? child.getParent() : child.parent;\n  if (p === undefined) return false;\n  const value = `getValue` in p ? p.getValue() : p.value;\n  if (eq(value!, possibleParentValue)) return true;\n  return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\nexport const findParentByValue = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  child: T,\n  possibleParentValue: TV,\n  eq: IsEqual<TV> = isEqualDefault<TV>,\n  maxDepth = 0\n): T | undefined => {\n  if (maxDepth < 0) return;\n  const p = (`getParent` in child ? child.getParent() : child.parent) as T | undefined;\n  if (p === undefined) return;\n  const value = `getValue` in p ? p.getValue() : p.value;\n\n  if (eq(value!, possibleParentValue)) return p;\n  return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = <T>(\n  parent: TraversableTree<T>,\n  prospectiveChild: TraversableTree<T>,\n  eq: IsEqual<TraversableTree<T>> = isEqualDefault\n) => {\n\n  if (eq(parent, prospectiveChild)) throw new Error(`Child equals parent`);\n  if (hasAnyChild(parent, prospectiveChild, eq)) {\n    throw new Error(`Circular. Parent already has child`);\n  }\n  if (hasAnyChild(prospectiveChild, parent, eq)) {\n    throw new Error(`Prospective child has parent as child relation`);\n  }\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  parent: T,\n  possibleChild: T,\n  eq: IsEqual<T> = isEqualDefault\n): boolean => {\n  return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\n\nexport const hasAnyChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleChildValue: T,\n  eq: IsEqual<T> = isEqualDefault\n): boolean => {\n  return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = <T extends TraversableTree<TV> | TreeNode<TV>, TV>(\n  parent: T,\n  possibleChild: T,\n  eq: IsEqual<T> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent, possibleChild)) return true;\n  const pId = `getIdentity` in parent ? parent.getIdentity() : parent.value;\n  const pcId = `getIdentity` in possibleChild ? possibleChild.getIdentity() : possibleChild.value;\n  if (eq(pId, pcId)) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    const cId = `getIdentity` in c ? c.getIdentity() : c.value;\n    if (eq(c, possibleChild)) return true;\n    if (eq(cId, pcId)) return true;\n  }\n  return false;\n};\n\nexport const hasChildValue = <T>(\n  parent: TraversableTree<T>,\n  possibleValue: T,\n  eq: IsEqual<T> = isEqualDefault,\n  maxDepth = 0\n): boolean => {\n\n  if (maxDepth < 0) return false;\n  if (eq(parent.getValue(), possibleValue)) return true;\n  for (const c of breadthFirst(parent, maxDepth)) {\n    if (eq(c.getValue(), possibleValue)) return true;\n  }\n  return false;\n};\n\n/**\n * Iterates over siblings of `node`.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* siblings<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>> {\n  const p = node.getParent();\n  if (p === undefined) return;\n  for (const s of p.children()) {\n    if (s === node) continue;\n    yield s;\n  }\n}\n\n// export function parents<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>>;\n// export function parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>>;\n\n/**\n * Iterates over parents of `node`, starting with immediate parent\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns \n */\nexport function* parents<T extends TraversableTree<TV> | TreeNode<TV>, TV>(node: T): IterableIterator<T> {\n  if (isTraversable(node)) {\n    let p = node.getParent();\n    while (p !== undefined) {\n      yield p as T;\n      p = p.getParent();\n    }\n  } else {\n    let p = node.parent;\n    while (p !== undefined) {\n      yield p as T;\n      p = p.parent\n    }\n  }\n}\n\n// export function findAnyChildByValue<TValue>(parent: TraversableTree<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TraversableTree<TValue> | undefined;\n// export function findAnyChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TreeNode<TValue> | undefined;\n\n/**\n * Descends `parent`, breadth-first, looking for a particular value.\n * Returns _undefined_ if not found.\n * @param parent \n * @param possibleValue \n * @param eq \n * @returns \n */\nexport function findAnyChildByValue<T extends TraversableTree<TV> | TreeNode<TV>, TV>(parent: T,\n  possibleValue: TV,\n  eq: IsEqual<TV> = isEqualDefault\n): T | undefined {\n  return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n};\n\n// export function findChildByValue<T extends TraversableTree<TV> | TreeNode<TV>, TV>(parent: T,\n//   possibleValue: TV,\n//   eq?: IsEqual<TV>,\n//   maxDepth?: number\n// ): TraversableTree<TV> | undefined;\n\n// export function findChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>,\n//   maxDepth?: number\n// ): TreeNode<TValue> | undefined;\n\n/**\n * Searches breadth-first for `possibleValue` under and including `parent`.\n * `maxDepth` sets he maximum level to which the tree is searched.\n * @param parent \n * @param possibleValue \n * @param eq \n * @param maxDepth \n * @returns \n */\nexport function findChildByValue<T extends TraversableTree<TV> | TreeNode<TV>, TV>(parent: T,\n  possibleValue: TV,\n  eq: IsEqual<TV> = isEqualDefault,\n  maxDepth = 0\n): T | undefined {\n\n  if (maxDepth < 0) return;\n  const isTraver = isTraversable(parent);\n  if (isTraver) {\n    if (eq(parent.getValue(), possibleValue)) return parent;\n  } else {\n    if (eq(parent.value!, possibleValue)) return parent;\n  }\n\n  for (const d of breadthFirst<T, TV>(parent, maxDepth)) {\n    // This child matches\n    if (isTraver) {\n      if (eq((d as TraversableTree<TV>).getValue(), possibleValue)) return d;\n    } else {\n      if (eq((d as TreeNode<TV>).value!, possibleValue)) return d;\n    }\n  }\n  return;\n};\n\n/**\n * Iterates over children of `root`, depth-first.\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node \n * @returns \n */\nexport function* depthFirst<T extends TraversableTree<TV> | TreeNode<TV>, TV>(root: T): Generator<T> {\n  if (!root) return;\n  const stack = new StackMutable<T>();\n  let entry: T | undefined = root;\n  while (entry) {\n    const entries = isTraversable(entry) ?\n      [ ...entry.children() ] as T[] :\n      [ ...entry.childrenStore ] as T[]\n    stack.push(...entries);\n    if (stack.isEmpty) break;\n    entry = stack.pop();\n    if (entry) yield entry;\n  }\n}\n//export function breadthFirst<T>(root: TraversableTree<T>, depth?: number): IterableIterator<TraversableTree<T>>;\n//export function breadthFirst<T>(root: TreeNode<T>, depth?: number): IterableIterator<TreeNode<T>>;\n\n/**\n * Iterates over the children of `root`, breadth-first\n * \n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @param depth How many levels to traverse \n * @returns \n */\nexport function* breadthFirst<T extends TraversableTree<TV> | TreeNode<TV>, TV>(root: T, depth = Number.MAX_SAFE_INTEGER): IterableIterator<T> {\n  if (!root) return;\n  const isTrav = isTraversable(root);\n  const queue = isTrav ? new QueueMutable<TraversableTree<T>>() : new QueueMutable<TreeNode<T>>();\n\n  let entry: T | undefined = root;\n  while (entry) {\n    if (depth < 0) return;\n    if (entry !== undefined) {\n      const kids = `childrenStore` in entry ? entry.childrenStore : entry.children();\n      for (const c of kids) {\n        yield c as any;\n        queue.enqueue(c as any);\n      }\n    }\n    entry = queue.dequeue() as any as T;\n    depth--;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function find<T>(root: TraversableTree<T>, predicate: (node: TraversableTree<T>) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root)) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n  for (const c of iter(root)) {\n    if (predicate(c)) return c;\n  }\n}\n\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n * \n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root \n * @param predicate \n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns \n */\nexport function findByValue<T>(root: TraversableTree<T>, predicate: (nodeValue: T) => boolean, order: `breadth` | `depth` = `breadth`): TraversableTree<T> | undefined {\n  if (predicate(root.getValue())) return root;\n  const iter = order === `breadth` ? breadthFirst : depthFirst;\n\n  for (const c of iter(root)) {\n    if (predicate(c.getValue())) return c;\n  }\n}\n\n/**\n * Search through children in a path-like manner.\n * \n * It finds the first child of `root` that matches `continuePredicate`. \n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n * \n * If it can't find a child, it stops.\n * \n * This is different to 'find' functions, which exhausively search all possible child nodes, regardless of position in tree.\n * \n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n * \n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root \n * @param continuePredicate \n * @param depth \n */\nexport function* followValue<T>(root: TraversableTree<T>, continuePredicate: (nodeValue: T, depth: number) => boolean, depth = 1): IterableIterator<T> {\n  for (const c of root.children()) {\n    if (continuePredicate(c.getValue(), depth)) {\n      yield c.getValue();\n      yield* followValue(c, continuePredicate, depth + 1);\n    }\n  }\n}\n\nexport function toStringDeep<T>(node: TraversableTree<T>, depth = 0) {\n  if (node === undefined) return `(undefined)`;\n  if (node === null) return `(null)`;\n  const v = node.getValue();\n  let type: string = typeof v;\n  if (Array.isArray(v)) type = `array`;\n  let t = `  `.repeat(depth) + `value: ${ JSON.stringify(v) } (${ type })\\n`;\n  for (const n of node.children()) {\n    t += toStringDeep(n, depth + 1);\n  }\n  return t;\n}\n\nexport function toString(...nodes: TraversableTree<any>[]) {\n  let t = ``;\n  for (const node of nodes) {\n    const v = node.getValue();\n    const vString = toStringAbbreviate(v);\n    const children = [ ...node.children() ];\n    const parent = node.getParent();\n    let type: string = typeof v;\n    if (Array.isArray(v)) type = `array`;\n    t += `value: ${ vString } (${ type }) kids: ${ children.length } parented: ${ parent ? `y` : `n` }\\n`;\n  }\n  return t;\n}","import { asDynamicTraversable as ObjectToTraversable } from './traverse-object.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './tree-mutable.js';\nimport type { TraversableTree, TreeNode } from './types.js';\n\nexport * as Mutable from './tree-mutable.js';\nexport * as Pathed from './pathed.js'\nexport * as FromObject from './traverse-object.js';\nexport * as Traverse from './traversable-tree.js';\nexport * from './compare.js';\nexport type * from './types.js';\n\nexport const toTraversable = <T>(node: TreeNode<T> | TraversableTree<T> | object) => {\n  if (isTraversable(node)) return node;\n  if (isTreeNode(node)) return TreeNodeToTraversable(node);\n  if (typeof node === `object`) return ObjectToTraversable(node);\n  throw new Error(`Parameter 'node' not convertible`);\n}\n\nexport const isTreeNode = (node: any): node is TreeNode<any> => {\n  if (`parent` in node && `childrenStore` in node && `value` in node) {\n    if (Array.isArray(node.childrenStore)) return true;\n  }\n  return false;\n}\n\nexport const isTraversable = (node: any): node is TraversableTree<any> => {\n  return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n}","// -------------------------\n// Immutable\n// -------------------------\nimport type { IStackImmutable } from './IStackImmutable.js';\nimport { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nimport type { StackOpts } from './Types.js';\n\nexport class StackImmutable<V> implements IStackImmutable<V> {\n  private readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  push(...toAdd: ReadonlyArray<V>): StackImmutable<V> {\n    return new StackImmutable<V>(\n      this.opts,\n      push(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  pop(): IStackImmutable<V> {\n    return new StackImmutable<V>(this.opts, pop(this.opts, this.data));\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = <V>(\n  options: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackImmutable<V> => new StackImmutable({ ...options }, [ ...startingItems ]);\n","export type { IStack } from './IStack.js';\nexport type { IStackMutable } from './IStackMutable.js';\nexport type { IStackImmutable } from './IStackImmutable.js';\nexport * from './StackImmutable.js';\nexport * from './StackMutable.js';\nexport type * from './Types.js';\nexport * from './StackFns.js';","//  UNIT TESTED\nimport { defaultKeyer, type ToString } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';//'../../Events.js';\nimport { type ISetMutable } from './ISetMutable.js';\nimport { type ValueSetEventMap } from './Types.js';\n\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = <V>(\n  keyString?: ToString<V>\n): ISetMutable<V> => new SetStringMutable(keyString);\n\n/**\n * Mutable string set\n */\nexport class SetStringMutable<V>\n  extends SimpleEventEmitter<ValueSetEventMap<V>>\n  implements ISetMutable<V> {\n  //  UNIT TESTED\n  /* eslint-disable functional/prefer-readonly-type */\n  store = new Map<string, V>();\n  keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n   */\n  constructor(keyString: ToString<V> | undefined) {\n    super();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  /**\n   * Number of items stored in set\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Adds one or more items to set. `add` event is fired for each item\n   * @param values items to add\n   */\n  add(...values: V[]): boolean {\n    //eslint-disable-next-line functional/no-let\n    let somethingAdded = false;\n    for (const value of values) {\n      const isUpdated = this.has(value);\n      this.store.set(this.keyString(value), value);\n      super.fireEvent(`add`, { value: value, updated: isUpdated });\n      if (!isUpdated) somethingAdded = true;\n    }\n    return somethingAdded;\n  }\n\n  /**\n   * Returns values from set as an iterable\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  values() {\n    return this.store.values();\n  }\n\n  /**\n   * Clear items from set\n   */\n  clear() {\n    this.store.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  /**\n   * Delete value from set.\n   * @param v Value to delete\n  * @returns _True_ if item was found and removed\n   */\n  delete(v: V): boolean {\n    const isDeleted = this.store.delete(this.keyString(v));\n    if (isDeleted) super.fireEvent(`delete`, v);\n    return isDeleted;\n  }\n\n  /**\n   * Returns _true_ if item exists in set\n   * @param v\n   * @returns\n   */\n  has(v: V): boolean {\n    return this.store.has(this.keyString(v));\n  }\n\n  /**\n   * Returns array copy of set\n   * @returns Array copy of set\n   */\n  toArray(): V[] {\n    return [ ...this.store.values() ];\n  }\n}\n","import { defaultKeyer, type ToString, toStringDefault } from '@ixfx/core';\nimport { type ISetImmutable } from './ISetImmutable.js';\n\nexport class SetStringImmutable<V> implements ISetImmutable<V> {\n  private store: Map<string, V>;\n  private keyString;\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(keyString?: ToString<V>, map?: Map<string, V>) {\n    this.store = map ?? new Map<string, V>();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  get size(): number {\n    return this.store.size;\n  }\n\n  add(...values: readonly V[]): ISetImmutable<V> {\n    const s = new Map<string, V>(this.store);\n    for (const v of values) {\n      const key = this.keyString(v);\n      s.set(key, v);\n    }\n    return new SetStringImmutable<V>(this.keyString, s);\n  }\n\n  delete(v: V): ISetImmutable<V> {\n    const s = new Map<string, V>(this.store);\n    const key = this.keyString(v);\n    if (s.delete(key)) return new SetStringImmutable(this.keyString, s);\n    return this;\n  }\n\n  has(v: V): boolean {\n    const key = this.keyString(v);\n    return this.store.has(key);\n  }\n\n  toArray(): V[] {\n    return [ ...this.store.values() ];\n  }\n\n  *values() {\n    yield* this.store.values();\n  }\n}\n\n/**\n * Immutable set that uses a `keyString` function to determine uniqueness\n *\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`.\n * @returns\n */\nexport const immutable = <V>(\n  keyString: ToString<V> = toStringDefault\n): ISetImmutable<V> => new SetStringImmutable(keyString);\n","/**\n * MassiveSet supports semantics similar to Set, but without the\n * limitation on how much data is stored.\n * \n * It only supports strings, and stores data in a hierarchy.\n * \n * ```js\n * const set = new MassiveSet(); // maxDepth=1 default\n * set.add(`test`);\n * set.add(`bloorp`);\n * ```\n * \n * In the above example, it will create a subtree for the first letter\n * of each key, putting the value underneath it. So we'd get a sub\n * MassiveSet for every key starting with 't' and every one starting with 'b'.\n * \n * If `maxDepth` was 2, we'd get the same two top-level nodes, but then\n * another sub-node based on the _second_ character of the value.\n * \n * It's not a very smart data-structure since it does no self-balancing\n * or tuning.\n */\nexport class MassiveSet {\n  #depth\n  #maxDepth;\n  children = new Map<string, MassiveSet>();\n  values: Array<string> = [];\n\n  constructor(maxDepth = 1, depth = 0) {\n    this.#depth = depth;\n    this.#maxDepth = maxDepth;\n  }\n\n  /**\n   * Returns the number of values stored in just this level of the set\n   * @returns \n   */\n  sizeLocal() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the number of branches at this node\n   * Use {@link sizeChildrenDeep} to count all branches recursively\n   * @returns \n   */\n  sizeChildren() {\n    return [ ...this.children.values() ].length;\n  }\n\n  sizeChildrenDeep() {\n    let t = this.sizeChildren();\n    for (const c of this.children.values()) {\n      t += c.sizeChildrenDeep();\n    }\n    return t;\n  }\n\n  /**\n   * Returns the total number of values stored in the set\n   */\n  size() {\n    let x = this.values.length;\n    for (const set of this.children.values()) {\n      x += set.size();\n    }\n    return x;\n  }\n\n  add(value: string) {\n    if (typeof value !== `string`) throw new Error(`Param 'value' must be a string. Got: ${ typeof value }`);\n\n    if (value.length === 0) throw new Error(`Param 'value' is empty`);\n\n    const destination = this.#getChild(value, true);\n    if (destination === this) {\n      if (!this.hasLocal(value)) {\n        this.values.push(value);\n      }\n      return;\n    }\n\n    if (!destination) throw new Error(`Could not create child set for: ${ value }`);\n    destination.add(value);\n  }\n\n  remove(value: string): boolean {\n    if (typeof value !== `string`) throw new Error(`Param 'value' must be a string. Got: ${ typeof value }`);\n    if (value.length === 0) throw new Error(`Param 'value' is empty`);\n\n    const destination = this.#getChild(value, false);\n    if (destination === undefined) return false;\n    if (destination === this) {\n      if (this.hasLocal(value)) {\n        this.values = this.values.filter(v => v !== value);\n        return true;\n      }\n      return false; // Not found\n    }\n    return destination.remove(value);\n  }\n\n  debugDump() {\n    const r = this.#dumpToArray();\n    for (const rr of r) {\n      console.log(rr);\n    }\n  }\n\n  #dumpToArray(depth = 0) {\n    const r: Array<string> = [];\n    r.push(`Depth: ${ this.#depth } Max: ${ this.#maxDepth }`);\n    for (const [ key, value ] of this.children.entries()) {\n      const dumped = value.#dumpToArray(depth + 1);\n      r.push(` key: ${ key }`);\n      for (const d of dumped) {\n        r.push(` `.repeat(depth + 1) + d);\n      }\n    }\n\n    r.push(`Values: (${ this.values.length })`);\n    for (const v of this.values) {\n      r.push(` ${ v }`);\n    }\n    return r.map(line => ` `.repeat(depth) + line);\n  }\n\n  #getChild(value: string, create: boolean) {\n    if (value === undefined) throw new Error(`Param 'value' undefined`);\n    if (this.#depth === this.#maxDepth) return this;\n    if (value.length <= this.#depth) return this;\n    const k = value[ this.#depth ];\n    if (k === undefined) throw new Error(`Logic error. Depth: ${ this.#depth } Len: ${ value.length }`);\n    let child = this.children.get(k);\n    if (child === undefined && create) {\n      child = new MassiveSet(this.#maxDepth, this.#depth + 1);\n      this.children.set(k, child);\n    }\n    return child;\n  }\n\n  /**\n   * Returns _true_ if `value` stored on this node\n   * @param value \n   * @returns \n   */\n  hasLocal(value: string) {\n    for (const v of this.values) {\n      if (v === value) return true;\n    }\n    return false;\n  }\n\n  has(value: string): boolean {\n    if (typeof value !== `string`) return false;\n\n    const destination = this.#getChild(value, false);\n    if (destination === undefined) return false;\n    if (destination === this) return this.hasLocal(value);\n    return destination.has(value);\n  }\n}","\n\nexport * from './set-mutable.js';\nexport * from './SetImmutable.js';\nexport { type ISetMutable } from './ISetMutable.js';\nexport { type ISetImmutable } from './ISetImmutable.js';\nexport * from './massive-set.js';\nexport type * from './Types.js';","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { isEqualDefault, type IsEqual } from \"@ixfx/core\";\nimport { max as IterablesMax, min as IterablesMin, last as IterablesLast } from \"@ixfx/iterables\";\nimport type { IPriorityQueueMutable, PriorityItem } from \"./ipriority-queue-mutable.js\";\nimport { QueueMutable } from \"./queue-mutable.js\";\nimport type { QueueOpts } from \"./queue-types.js\";\n\n/**\n * Simple priority queue implementation.\n * Higher numbers mean higher priority.\n * \n * ```js\n * const pm = new PriorityMutable();\n * \n * // Add items with a priority (higher numeric value = higher value)\n * pm.enqueueWithPriority(`hello`, 4);\n * pm.enqueueWithPriotity(`there`, 1);\n * \n * ```\n */\nexport class PriorityMutable<V> extends QueueMutable<PriorityItem<V>> implements IPriorityQueueMutable<V> {\n  constructor(opts: QueueOpts<PriorityItem<V>> = {}) {\n    if (opts.eq === undefined) {\n      opts = {\n        ...opts,\n        eq: (a, b) => {\n          return isEqualDefault(a.item, b.item);\n        }\n      }\n    }\n    super(opts);\n  }\n\n  /**\n   * Adds an item with a given priority\n   * @param item Item\n   * @param priority Priority (higher numeric value means higher priority)\n   */\n  enqueueWithPriority(item: V, priority: number) {\n    resultThrow(numberTest(priority, `positive`));\n    super.enqueue({ item, priority });\n  }\n\n  changePriority(item: V, priority: number, addIfMissing = false, eq?: IsEqual<V>) {\n    if (item === undefined) throw new Error(`Item cannot be undefined`);\n    let toDelete: PriorityItem<V> | undefined;\n    for (const d of this.data) {\n      if (eq) {\n        if (eq(d.item, item)) {\n          toDelete = d;\n          break;\n        }\n      } else {\n        if (this.eq(d, { item, priority: 0 })) {\n          toDelete = d;\n          break;\n        }\n      }\n    }\n    if (toDelete === undefined && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${ JSON.stringify(item) }`);\n    if (toDelete !== undefined) {\n      this.removeWhere(item => toDelete === item)\n    }\n    this.enqueueWithPriority(item, priority);\n  }\n\n  dequeueMax(): V | undefined {\n    //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n    const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n\n    if (m === undefined) return;\n    this.removeWhere(item => item === m);\n    return m.item;\n  }\n\n  dequeueMin(): V | undefined {\n    const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n    //const m = IterablesLast(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n    if (m === undefined) return;\n    this.removeWhere(item => item.item === m);\n    return m.item;\n  }\n\n  peekMax(): V | undefined {\n    const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n    //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n    if (m === undefined) return;\n    return m.item;\n  }\n\n  peekMin(): V | undefined {\n    //const m = IterablesLast<V>(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n    const m = IterablesLast(IterablesMin(this.data, (a, b) => a.priority >= b.priority));\n    if (m === undefined) return;\n    return m.item;\n  }\n}\n\n/**\n * Creates a {@link PriorityMutable} queue.\n * \n * Options:\n * * eq: Equality function\n * * capacity: limit on number of items\n * * discardPolicy: what to do if capacity is reached\n * @param opts \n * @returns \n */\nexport function priority<V>(\n  opts: QueueOpts<PriorityItem<V>> = {}\n): IPriorityQueueMutable<V> {\n  return new PriorityMutable(opts);\n}","import type { IQueueImmutable } from './iqueue-immutable.js';\nimport { peek, isFull, isEmpty, enqueue, dequeue } from './queue-fns.js';\nimport { type QueueOpts } from './queue-types.js';\n\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable<V> implements IQueueImmutable<V> {\n  readonly opts: QueueOpts<V>;\n  #data: ReadonlyArray<V>;\n\n  /**\n   * Creates an instance of Queue.\n   * @param {QueueOpts} opts Options foor queue\n   * @param {V[]} data Initial data. Index 0 is front of queue\n   */\n  constructor(opts: QueueOpts<V> = {}, data: ReadonlyArray<V> = []) {\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n    this.opts = opts;\n    this.#data = data;\n  }\n\n  forEach(fn: (v: V) => void) {\n    //eslint-disable-next-line functional/no-let\n    for (let index = this.#data.length - 1; index >= 0; index--) {\n      fn(this.#data[ index ]);\n    }\n  }\n\n  forEachFromFront(fn: (v: V) => void) {\n    // From front of queue\n    // eslint-disable-next-line unicorn/no-array-for-each\n    this.#data.forEach(item => { fn(item) }); //(vv) => fn(vv));\n  }\n\n  enqueue(...toAdd: ReadonlyArray<V> | Array<V>): QueueImmutable<V> {\n    return new QueueImmutable<V>(\n      this.opts,\n      enqueue(this.opts, this.#data, ...toAdd)\n    );\n  }\n\n  dequeue(): QueueImmutable<V> {\n    return new QueueImmutable<V>(this.opts, dequeue(this.opts, this.#data));\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.#data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.#data);\n  }\n\n  get length(): number {\n    return this.#data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.#data);\n  }\n\n  toArray() {\n    return [ ...this.#data ];\n  }\n}\n\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * import { Queues } from \"https://unpkg.com/ixfx/dist/collections.js\"\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @typeParam V - Type of values stored\n * @param options\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = <V>(\n  options: QueueOpts<V> = {},\n  ...startingItems: ReadonlyArray<V>\n): IQueueImmutable<V> => {\n  options = { ...options }; // Make a copy of options\n  return new QueueImmutable(options, [ ...startingItems ]); // Make a copy of array so it can't be modified\n};\n","export type * from './ipriority-queue-mutable.js';\nexport type * from './iqueue-immutable.js';\nexport type * from './iqueue-mutable.js';\nexport * from './priority-mutable.js';\nexport { immutable, QueueImmutable } from './queue-immutable.js';\nexport { mutable, QueueMutable } from './queue-mutable.js';\nexport type * from './queue-types.js';\n//export * from './Responsive.js';\nexport * from './queue-fns.js';","import { SimpleEventEmitter } from '@ixfx/events';\nimport { sortByValueProperty } from '@ixfx/core/maps';\nimport { intervalToMs, type Interval } from '@ixfx/core';\nimport { integerTest, resultThrow } from '@ixfx/guards';\n\n/**\n * Expiring map options\n */\nexport type Opts = {\n  /**\n   * Capacity limit\n   */\n  readonly capacity?: number;\n  /**\n   * Policy for evicting items if capacity is reached\n   */\n  readonly evictPolicy?: `none` | `oldestGet` | `oldestSet`;\n  /**\n   * Automatic deletion policy.\n   * none: no automatic deletion (default)\n   * get/set: interval based on last get/set\n   * either: if either interval has elapsed\n   */\n  readonly autoDeletePolicy?: `none` | `get` | `set` | `either`;\n  /**\n   * Automatic deletion interval\n   */\n  readonly autoDeleteElapsedMs?: number;\n};\n\ntype Item<V> = {\n  readonly value: V;\n  readonly lastSet: number;\n  readonly lastGet: number;\n};\n\n/**\n * Event from the ExpiringMap\n */\nexport type ExpiringMapEvent<K, V> = {\n  readonly key: K;\n  readonly value: V;\n};\n\nexport type ExpiringMapEvents<K, V> = {\n  /**\n   * Fires when an item is removed due to eviction\n   * or automatic expiry\n   */\n  readonly expired: ExpiringMapEvent<K, V>;\n  /**\n   * Fires when a item with a new key is added\n   */\n  readonly newKey: ExpiringMapEvent<K, V>;\n\n  /**\n   * Fires when an item is manually removed,\n   * removed due to eviction or automatic expiry\n   */\n  readonly removed: ExpiringMapEvent<K, V>;\n};\n\n/**\n * Create a ExpiringMap instance\n * @param options Options when creating map\n * @returns\n */\nexport const create = <K, V>(options: Opts = {}): ExpiringMap<K, V> =>\n  new ExpiringMap(options);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using {@link touch}.\n *\n *\n * Events:\n * * 'expired': when an item is automatically removed.\n * * 'removed': when an item is manually or automatically removed.\n * * 'newKey': when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example\n * Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example\n * Automatically delete the oldest item if we reach a capacity limit\n * ```js\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n * @typeParam K - Type of keys\n * @typeParam V - Type of values\n */\nexport class ExpiringMap<K, V> extends SimpleEventEmitter<\n  ExpiringMapEvents<K, V>\n> {\n  private capacity: number;\n  private store: Map<K, Item<V>>;\n  //private keyCount: number;\n  private evictPolicy;\n\n  private autoDeleteElapsedMs: number;\n  private autoDeletePolicy;\n  private autoDeleteTimer: ReturnType<typeof setInterval> | undefined;\n  private disposed = false;\n  constructor(opts: Opts = {}) {\n    super();\n    this.capacity = opts.capacity ?? -1;\n\n    resultThrow(integerTest(this.capacity, `nonZero`, `capacity`));\n    this.store = new Map();\n    //this.keyCount = 0;\n\n    if (opts.evictPolicy && this.capacity <= 0) {\n      throw new Error(`evictPolicy is set, but no capacity limit is set`);\n    }\n    this.evictPolicy = opts.evictPolicy ?? `none`;\n    this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n    this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n\n    if (this.autoDeleteElapsedMs > 0) {\n      this.autoDeleteTimer = setInterval(\n        () => { this.#maintain(); },\n        Math.max(1000, this.autoDeleteElapsedMs * 2)\n      );\n    }\n  }\n\n  dispose() {\n    if (this.disposed) return;\n    this.disposed = true;\n    if (this.autoDeleteTimer) {\n      clearInterval(this.autoDeleteTimer)\n      this.autoDeleteTimer = undefined;\n    }\n  }\n  /**\n   * Returns the number of keys being stored.\n   */\n  get keyLength() {\n    return this.store.size;// keyCount;\n  }\n\n  *entries(): IterableIterator<[ k: K, v: V ]> {\n    for (const entry of this.store.entries()) {\n      yield [ entry[ 0 ], entry[ 1 ].value ];\n    }\n  }\n\n  *values(): IterableIterator<V> {\n    for (const v of this.store.values()) {\n      yield v.value;\n    }\n  }\n\n  *keys(): IterableIterator<K> {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was set. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedSet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (typeof v === `undefined`) return;\n    return Date.now() - v.lastSet;\n  }\n\n  /**\n   * Returns the elapsed time since `key`\n   * was accessed. Returns _undefined_ if `key`\n   * does not exist\n   */\n  elapsedGet(key: K): number | undefined {\n    const v = this.store.get(key);\n    if (typeof v === `undefined`) return;\n    return Date.now() - v.lastGet;\n  }\n\n  /**\n   * Returns true if `key` is stored.\n   * Does not affect the key's last access time.\n   * @param key\n   * @returns\n   */\n  has(key: K): boolean {\n    return this.store.has(key);\n  }\n\n  /**\n   * Gets an item from the map by key, returning\n   * undefined if not present\n   * @param key Key\n   * @returns Value, or undefined\n   */\n  get(key: K): V | undefined {\n    const v = this.store.get(key);\n    if (v) {\n      if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) {\n        this.store.set(key, {\n          ...v,\n          lastGet: performance.now(),\n        });\n      }\n      return v.value;\n    }\n  }\n\n  /**\n   * Deletes the value under `key`, if present.\n   *\n   * Returns _true_ if something was removed.\n   * @param key\n   * @returns\n   */\n  delete(key: K): boolean {\n    const value = this.store.get(key);\n    if (!value) return false;\n    const d = this.store.delete(key);\n    //this.keyCount = this.keyCount - 1;\n    this.fireEvent(`removed`, {\n      key,\n      value: value.value,\n    });\n    return d;\n  }\n\n  /**\n   * Clears the contents of the map.\n   * Note: does not fire `removed` event\n   */\n  clear() {\n    this.store.clear();\n  }\n\n  /**\n   * Updates the lastSet/lastGet time for a value\n   * under `k`.\n   *\n   * Returns false if key was not found\n   * @param key\n   * @returns\n   */\n  touch(key: K): boolean {\n    const v = this.store.get(key);\n    if (!v) return false;\n    this.store.set(key, {\n      ...v,\n      lastSet: Date.now(),\n      lastGet: Date.now(),\n    });\n    return true;\n  }\n\n  private findEvicteeKey(): K | undefined {\n    if (this.evictPolicy === `none`) return;\n    let sortBy = ``;\n    if (this.evictPolicy === `oldestGet`) sortBy = `lastGet`;\n    else if (this.evictPolicy === `oldestSet`) sortBy = `lastSet`;\n    else throw new Error(`Unknown eviction policy ${ this.evictPolicy }`);\n    const sorted = sortByValueProperty(this.store, sortBy);\n    return sorted[ 0 ][ 0 ];\n  }\n\n  #maintain() {\n    if (this.autoDeletePolicy === `none`) return;\n    this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n  }\n\n  /**\n   * Deletes all values where elapsed time has past\n   * for get/set or either.\n   * ```js\n   * // Delete all keys (and associated values) not accessed for a minute\n   * em.deleteWithElapsed({mins:1}, `get`);\n   * // Delete things that were set 1s ago\n   * em.deleteWithElapsed(1000, `set`);\n   * ```\n   * \n   * @param interval Interval\n   * @param property Basis for deletion 'get','set' or 'either'\n   * @returns Items removed\n   */\n  deleteWithElapsed(\n    interval: Interval,\n    property: `get` | `set` | `either`\n  ): [ k: K, v: V ][] {\n    const entries = [ ...this.store.entries() ];\n    const prune: [ k: K, v: V ][] = [];\n    const intervalMs = intervalToMs(interval, 1000);\n    const now = performance.now();\n    for (const entry of entries) {\n      const elapsedGet = now - entry[ 1 ].lastGet;\n      const elapsedSet = now - entry[ 1 ].lastSet;\n      const elapsed =\n        property === `get`\n          ? elapsedGet\n          : (property === `set`\n            ? elapsedSet\n            : Math.max(elapsedGet, elapsedSet));\n      if (elapsed >= intervalMs) {\n        prune.push([ entry[ 0 ], entry[ 1 ].value ]);\n      }\n    }\n\n    for (const entry of prune) {\n      this.store.delete(entry[ 0 ]);\n      //this.keyCount = this.keyCount - 1;\n      const eventArguments = {\n        key: entry[ 0 ],\n        value: entry[ 1 ],\n      };\n      this.fireEvent(`expired`, eventArguments);\n      this.fireEvent(`removed`, eventArguments);\n    }\n    return prune;\n  }\n\n  /**\n   * Sets the `key` to be `value`.\n   *\n   * If the key already exists, it is updated.\n   *\n   * If the map is full, according to its capacity,\n   * another value is selected for removal.\n   * @param key\n   * @param value\n   * @returns\n   */\n  set(key: K, value: V) {\n    const existing = this.store.get(key);\n\n    if (existing) {\n      // Update set time\n      this.store.set(key, {\n        ...existing,\n        lastSet: performance.now(),\n      });\n      return;\n    }\n\n    // New key\n    if (this.keyLength === this.capacity && this.capacity > 0) {\n      // Evict first\n      const key = this.findEvicteeKey();\n      if (!key) {\n        throw new Error(`ExpiringMap full (capacity: ${ this.capacity })`);\n      }\n      const existing = this.store.get(key);\n      this.store.delete(key);\n      //this.keyCount = this.keyCount - 1;\n      if (existing) {\n        const eventArguments = { key, value: existing.value };\n        this.fireEvent(`expired`, eventArguments);\n        this.fireEvent(`removed`, eventArguments);\n      }\n    }\n\n    //this.keyCount++;\n    this.store.set(key, {\n      lastGet: 0,\n      lastSet: performance.now(),\n      value: value,\n    });\n\n    this.fireEvent(`newKey`, { key, value });\n  }\n}\n","import type { ArrayKeys, EitherKey, ObjectKeys } from '../types.js';\n\n/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ArrayKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d[ 0 ] === undefined) throw new Error(`key cannot be undefined`);\n    if (d[ 1 ] === undefined) throw new Error(`value cannot be undefined`);\n    x.set(d[ 0 ], d[ 1 ]);\n  }\n  return x;\n};\n\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ObjectKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\n\n    x.set(d.key, d.value);\n  }\n  return x;\n};\n\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = <K, V>(map: ReadonlyMap<K, V>, key: K): boolean =>\n  map.has(key);\n\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = <K, V>(\n  map: ReadonlyMap<K, V>,\n  ...data: EitherKey<K, V>\n): ReadonlyMap<K, V> => {\n  if (map === undefined) throw new Error(`map parameter is undefined`);\n  if (data === undefined) throw new Error(`data parameter i.s undefined`);\n  if (data.length === 0) return map;\n\n  const firstRecord = data[ 0 ];\n  const isObject =\n    typeof (firstRecord as { readonly key: K; readonly value: V }).key !==\n    `undefined` &&\n    typeof (firstRecord as { readonly key: K; readonly value: V }).value !==\n    `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n  return isObject\n    ? addObjects(map, data as ObjectKeys<K, V>)\n    : addArray(map, data as ArrayKeys<K, V>);\n};\n\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key: K, value: V) => {\n  const x = new Map<K, V>(map.entries());\n  x.set(key, value);\n  return x;\n};\n\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  x.delete(key);\n  return x;\n};\n","import { type EitherKey } from '../types.js';\nimport type { IMapBase } from './imap-base.js';\nimport { add, del, set } from './map-immutable-fns.js';\n\n/**\n * An immutable map. Rather than changing the map, functions like `add` and `delete`\n * return a new map reference which must be captured.\n *\n * Immutable data is useful because as it gets passed around your code, it never\n * changes from underneath you. You have what you have.\n *\n * @example\n * ```js\n * let m = map(); // Create\n * let m2 = m.set(`hello`, `samantha`);\n * // m is still empty, only m2 contains a value.\n * ```\n *\n * @typeParam K - Type of map keys. Typically `string`\n * @typeParam V - Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapImmutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items, returning the changed map.\n   *\n   * Can add items in the form of `[key,value]` or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): IMapImmutable<K, V>;\n  /**\n   * Deletes an item by key, returning the changed map\n   * @param key\n   */\n  delete(key: K): IMapImmutable<K, V>;\n  /**\n   * Returns an empty map\n   */\n  clear(): IMapImmutable<K, V>;\n\n\n  /**\n   * Sets `key` to be `value`, overwriting anything existing.\n   * Returns a new map with added key.\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): IMapImmutable<K, V>;\n\n}\n\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = <K, V>(\n  dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>\n): IMapImmutable<K, V> => {\n  if (dataOrMap === undefined) return immutable([]);\n  if (Array.isArray(dataOrMap)) return immutable<K, V>(add(new Map(), ...dataOrMap));\n\n  const data = dataOrMap as ReadonlyMap<K, V>;\n  return {\n    add: (...itemsToAdd: EitherKey<K, V>) => {\n      const s = add(data, ...itemsToAdd);\n      return immutable(s);\n    },\n    set: (key: K, value: V) => {\n      const s = set(data, key, value);\n      return immutable(s);\n    },\n    get: (key: K) => data.get(key),\n    delete: (key: K) => immutable(del(data, key)),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    clear: () => immutable(),\n    has: (key: K) => data.has(key),\n    entries: () => data.entries(),\n    values: () => data.values(),\n    isEmpty: () => data.size === 0,\n  };\n};\n","import { type EitherKey } from '../types.js';\nimport type { IMapBase } from './imap-base.js';\nimport { add, del, set, has } from './map-immutable-fns.js';\n\n/**\n * A mutable map.\n *\n * It is a wrapper around the in-built Map type, but adds roughly the same API as {@link IMapImmutable}.\n *\n * @typeParam K - Type of map keys. Typically `string`\n * @typeParam V - Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapMutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items to map\n   *\n   * Can add items in the form of [key,value] or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): void;\n  /**\n   * Sets a value to a specified key\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): void;\n  /**\n   * Deletes an item by key\n   * @param key\n   */\n  delete(key: K): void;\n  /**\n   * Clears map\n   */\n  clear(): void;\n}\n\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = <K, V>(...data: EitherKey<K, V>): IMapMutable<K, V> => {\n  // eslint-disable-next-line functional/no-let\n  let m = add(new Map<K, V>(), ...data);\n  return {\n    add: (...data: EitherKey<K, V>) => {\n      m = add(m, ...data);\n    },\n    delete: (key: K) => {\n      m = del(m, key);\n    },\n    clear: () => {\n      m = add(new Map<K, V>());\n    },\n    set: (key: K, value: V): void => {\n      m = set(m, key, value);\n    },\n    get: (key: K): V | undefined => m.get(key),\n    entries: () => m.entries(),\n    values: () => m.values(),\n    isEmpty: () => m.size === 0,\n    has: (key: K) => has(m, key),\n  };\n};\n","import {\n  type IsEqual,\n  isEqualDefault\n} from '@ixfx/core';\nimport type {\n  MapArrayEvents,\n  IMapOfMutableExtended,\n} from './imap-of-mutable-extended.js';\nimport type { MapMultiOpts, MultiValue } from './map-multi.js';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport type { IMapOf } from './imap-of.js';\nimport { toStringDefault, type ToString } from '@ixfx/core';\n\n/**\n * @internal\n */\nexport class MapOfMutableImpl<V, M>\n  extends SimpleEventEmitter<MapArrayEvents<V>>\n  implements IMapOfMutableExtended<V, M> {\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #map = new Map<string, M>();\n  readonly groupBy: ToString<V>;\n  readonly type: MultiValue<V, M>;\n\n  constructor(type: MultiValue<V, M>, opts: MapMultiOpts<V> = {}) {\n    super();\n    this.type = type;\n    this.groupBy = opts.groupBy ?? toStringDefault;\n  }\n\n  /**\n   * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n   */\n  get typeName() {\n    return this.type.name;\n  }\n\n  /**\n   * Returns the number of keys\n   */\n  get lengthKeys(): number {\n    return this.#map.size;\n  }\n\n  /**\n   * Returns the length of the longest child list\n   */\n  get lengthMax() {\n    //eslint-disable-next-line functional/no-let\n    let m = 0;\n    for (const v of this.#map.values()) {\n      m = Math.max(m, this.type.count(v));\n    }\n    return m;\n  }\n\n  debugString(): string {\n    const keys = [ ...this.#map.keys() ];\n    // eslint-disable-next-line functional/no-let\n    let r = `Keys: ${ keys.join(`, `) }\\r\\n`;\n    for (const k of keys) {\n      const v = this.#map.get(k);\n      if (v === undefined) {\n        r += ` - ${ k } (undefined)\\r\\n`\n      } else {\n        const asArray = this.type.toArray(v);\n        if (asArray !== undefined) {\n          r += ` - ${ k } (${ this.type.count(v) }) = ${ JSON.stringify(\n            asArray\n          ) }\\r\\n`;\n        }\n      }\n    };\n    return r;\n  }\n\n  get isEmpty(): boolean {\n    return this.#map.size === 0;\n  }\n\n  clear() {\n    this.#map.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  addKeyedValues(key: string, ...values: V[]) {\n    const set = this.#map.get(key);\n    if (set === undefined) {\n      this.#map.set(key, this.type.add(undefined, values));\n      super.fireEvent(`addedKey`, { key: key });\n      super.fireEvent(`addedValues`, { values: values });\n    } else {\n      // eslint-disable-next-line functional/immutable-data\n      this.#map.set(key, this.type.add(set, values));\n      super.fireEvent(`addedValues`, { values: values });\n    }\n  }\n  //eslint-disable-next-line functional/prefer-immutable-types\n  set(key: string, values: V[]) {\n    this.addKeyedValues(key, ...values);\n    return this;\n  }\n\n  addValue(...values: readonly V[]) {\n    for (const v of values) this.addKeyedValues(this.groupBy(v), v);\n  }\n\n  hasKeyValue(key: string, value: V, eq: IsEqual<V>): boolean {\n    const m = this.#map.get(key);\n    if (m === undefined) return false;\n    return this.type.has(m, value, eq);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  has(key: string): boolean {\n    return this.#map.has(key);\n  }\n\n  deleteKeyValue(key: string, value: V): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    return this.deleteKeyValueFromMap(a, key, value);\n  }\n\n  private deleteKeyValueFromMap(map: M, key: string, value: V): boolean {\n    const preCount = this.type.count(map);\n    const filtered = this.type.without(map, value);\n    const postCount = filtered.length;\n    this.#map.set(key, this.type.add(undefined, filtered));\n    return preCount > postCount;\n  }\n\n  deleteByValue(value: V): boolean {\n    //eslint-disable-next-line functional/no-let\n    let something = false;\n    [ ...this.#map.keys() ].filter((key) => {\n      const a = this.#map.get(key);\n      if (!a) throw new Error(`Bug: map could not be accessed`);\n      if (this.deleteKeyValueFromMap(a, key, value)) {\n        something = true; // note that something was deleted\n\n        // If key is empty, delete it\n        if (this.count(key) === 0) this.delete(key);\n      }\n    });\n    return something;\n  }\n\n  delete(key: string): boolean {\n    const a = this.#map.get(key);\n    if (a === undefined) return false;\n    this.#map.delete(key);\n    this.fireEvent(`deleteKey`, { key: key });\n    return true;\n  }\n\n  firstKeyByValue(\n    value: V,\n    eq: IsEqual<V> = isEqualDefault\n  ): string | undefined {\n    const keys = [ ...this.#map.keys() ];\n    const found = keys.find((key) => {\n      const a = this.#map.get(key);\n      if (a === undefined) throw new Error(`Bug: map could not be accessed`);\n      const r = this.type.has(a, value, eq);\n      return r;\n    });\n    return found;\n  }\n\n  count(key: string): number {\n    const entry = this.#map.get(key);\n    if (entry === undefined) return 0;\n    return this.type.count(entry);\n  }\n\n  /**\n   * Iterates over values stored under `key`\n   * An empty array is returned if there are no values\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  /**\n   * Iterate over the values stored under `key`.\n   * If key does not exist, iteration is essentially a no-op\n   * @param key\n   * @returns\n   */\n  *valuesFor(key: string) {\n    const m = this.#map.get(key);\n    if (m === undefined) return;\n    yield* this.type.iterable(m);\n  }\n\n  //eslint-disable-next-line functional/prefer-tacit\n  getSource(key: string): M | undefined {\n    return this.#map.get(key);\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keys(): IterableIterator<string> {\n    yield* this.#map.keys();\n    //return Array.from(this.#map.keys());\n  }\n\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const entry of this.#map.entries()) {\n      for (const v of this.type.iterable(entry[ 1 ])) {\n        yield [ entry[ 0 ], v ];\n      }\n    }\n  }\n\n  *valuesFlat(): IterableIterator<V> {\n    for (const entry of this.#map.entries()) {\n      yield* this.type.iterable(entry[ 1 ]);\n    }\n  }\n\n  *entries(): IterableIterator<[ key: string, value: V[] ]> {\n    for (const [ k, v ] of this.#map.entries()) {\n      const temporary = [ ...this.type.iterable(v) ];\n      yield [ k, temporary ];\n    }\n  }\n\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const key of this.keys()) {\n      yield [ key, this.count(key) ];\n    }\n  }\n\n  merge(other: IMapOf<V>) {\n    for (const key of other.keys()) {\n      const data = other.get(key);\n      this.addKeyedValues(key, ...data);\n    }\n  }\n\n  get size() {\n    return this.#map.size;\n  }\n\n\n  get [ Symbol.toStringTag ]() {\n    return this.#map[ Symbol.toStringTag ];\n  }\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { without } from '@ixfx/arrays';\nimport type { MapSetOpts, MultiValue } from './map-multi.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\nimport {\n  hasAnyValue as mapHasAnyValue,\n  toArray as mapToArray,\n  findValue as mapFindValue,\n  filterValues as mapFilterValues,\n  addValue as mapAddValue\n} from '@ixfx/core/maps';\nimport type { IMapOfMutableExtended } from './imap-of-mutable-extended.js';\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is Util.ToString function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = ofSetMutable();\n * map.addKeyedValues(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = ofSetMutable({hash});\n * map.addValue({age:40, name: `Mary`});\n * map.addValue({age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param options\n * @returns\n */\nexport const ofSetMutable = <V>(\n  options?: MapSetOpts<V>\n): IMapOfMutableExtended<V, ReadonlyMap<string, V>> => {\n  const hash = options?.hash ?? toStringDefault;\n  const comparer = (a: V, b: V) => hash(a) === hash(b);\n\n  const t: MultiValue<V, ReadonlyMap<string, V>> = {\n    get name() {\n      return `set`;\n    },\n    iterable: (source) => source.values(),\n    add: (dest, values) => mapAddValue(dest, hash, `skip`, ...values),\n    count: (source) => source.size,\n    find: (source, predicate) => mapFindValue(source, predicate),\n    filter: (source, predicate) => mapFilterValues(source, predicate),\n    toArray: (source) => mapToArray(source),\n    has: (source, value) => mapHasAnyValue(source, value, comparer),\n    without: (source, value) => without(mapToArray(source), value, comparer),\n  };\n  const m = new MapOfMutableImpl<V, ReadonlyMap<string, V>>(t, options);\n  return m;\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { CircularArray, type ICircularArray } from '../circular-array.js';\nimport type { MapMultiOpts, MultiValue } from './map-multi.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\nimport type { IMapOfMutableExtended } from './imap-of-mutable-extended.js';\n\nexport type MapCircularOpts<V> = MapMultiOpts<V> & {\n  readonly capacity: number;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param options\n * @returns\n */\nexport const ofCircularMutable = <V>(\n  options: MapCircularOpts<V>\n): IMapOfMutableExtended<V, ICircularArray<V>> => {\n  const comparer = isEqualDefault;\n\n  const t: MultiValue<V, ICircularArray<V>> = {\n    get name() {\n      return `circular`;\n    },\n    add: (destination, values) => {\n      destination ??= new CircularArray<V>(options.capacity);\n      for (const v of values) {\n        //values.forEach(v => dest = dest?.add(v));\n        destination = destination.add(v);\n      }\n      return destination;\n    },\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(predicate),\n    filter: (source, predicate) => source.filter(predicate),\n    toArray: (source) => source,\n    iterable: (source) => source.values(),\n    has: (source, value) =>\n      source.find((v) => comparer(v, value)) !== undefined,\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n  };\n  return new MapOfMutableImpl<V, ICircularArray<V>>(t, options);\n};\n","/**\n * Simple map for numbers.\n * \n * Keys not present in map return the `defaultValue` given in the constructor\n * ```js\n * // All keys default to zero.\n * const map = new NumberMap();\n * map.get(`hello`); // 0\n * ```\n * \n * To check if a key is present, use `has`:\n * ```js\n * map.has(`hello`); // false\n * ```\n * \n * Math:\n * ```js\n * // Adds 1 by default to value of `hello`\n * map.add(`hello`);         // 1\n * map.multiply(`hello`, 2); // 2 \n * \n * // Reset key to default value\n * map.reset(`hello`); // 0\n * ```\n * \n * Different default value:\n * ```js\n * const map = new NumberMap(10);\n * map.get(`hello`); // 10\n * ```\n * \n * Regular `set` works as well:\n * ```js\n * map.set(`hello`, 5);\n * map.add(`hello`, 2); // 7\n * ```\n */\nexport class NumberMap<K> extends Map<K, number> {\n  readonly defaultValue: number;\n\n  constructor(defaultValue = 0) {\n    super();\n    this.defaultValue = defaultValue;\n  }\n\n  get(key: K): number {\n    const v = super.get(key);\n    if (v === undefined) return this.defaultValue;\n    return v;\n  }\n\n  reset(key: K): number {\n    super.set(key, this.defaultValue);\n    return this.defaultValue;\n  }\n\n  multiply(key: K, amount: number): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value *= amount;\n    super.set(key, value);\n    return value;\n  }\n\n  add(key: K, amount = 1): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value += amount;\n    super.set(key, value);\n    return value;\n  }\n\n  subtract(key: K, amount = 1): number {\n    const v = super.get(key);\n    let value = v ?? this.defaultValue;\n    value -= amount;\n    super.set(key, value);\n    return value;\n  }\n}","import type { ToString } from '@ixfx/core';\nimport { type IsEqual, isEqualDefault } from '@ixfx/core';\nimport { type IMapOfMutableExtended } from './imap-of-mutable-extended.js';\nimport { type MapMultiOpts, type MultiValue } from './map-multi.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n\n/**\n * Map of array options\n */\nexport type MapArrayOpts<V> = MapMultiOpts<V> & {\n  /**\n   * Comparer to use\n   */\n  readonly comparer?: IsEqual<V>;\n  /**\n   * Key function\n   */\n  readonly convertToString?: ToString<V>;\n};\n\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: Util.ToString\n *\n * A custom Util.ToString function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param options Optiosn for mutable array\n * @typeParam V - Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = <V>(\n  options: MapArrayOpts<V> = {}\n): IMapOfMutableExtended<V, readonly V[]> => {\n  // const toStringFunction = opts.toString === undefined ?  \n  // const comparer =\n  //   opts.comparer === undefined\n  //     ? (opts.toString === undefined\n  //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n  //       : isEqualDefault)\n  //     : opts.comparer;\n  // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n  //   const r = opts.convertToString(a) === opts.convertToString(b)\n  //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n  //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n  //   return r;\n  // };\n\n  const convertToString = options.convertToString;\n  const toStringFunction: IsEqual<V> = typeof convertToString === `undefined` ? isEqualDefault : (a: V, b: V) => convertToString(a) === convertToString(b)\n\n  const comparer = options.comparer ?? toStringFunction;\n\n  const t: MultiValue<V, readonly V[]> = {\n    get name() {\n      return `array`;\n    },\n    add: (destination, values) => {\n      if (destination === undefined) return [ ...values ];\n      return [ ...destination, ...values ];\n    },\n    iterable: (source) => source.values(),\n    count: (source) => source.length,\n    find: (source, predicate) => source.find(f => predicate(f)),\n    filter: (source, predicate) => source.filter(f => predicate(f)),\n    toArray: (source) => source,\n    has: (source, value) => source.some((v) => comparer(v, value)),\n    without: (source, value) => source.filter((v) => !comparer(v, value)),\n    //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n  };\n  const m = new MapOfMutableImpl<V, readonly V[]>(t, options);\n  return m;\n};\n","//  UNIT TESTED\n\nimport { type IsEqual, isEqualDefault } from '@ixfx/core';\nimport type { IMapOf } from './imap-of.js';\nimport type { IWithEntries } from '@ixfx/core';\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const value = e[ 1 ];\n    for (const subValue of value) {\n      if (predicate(subValue, e[ 0 ])) return e;\n    }\n  }\n};\n\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = <V>(map: IMapOf<V>): number => {\n  //eslint-disable-next-line functional/no-let\n  let largest: readonly [ string, number ] = [ '', 0 ];\n  for (const e of map.keysAndCounts()) {\n    if (e[ 1 ] > largest[ 1 ]) {\n      largest = e;\n    }\n  }\n  return largest[ 1 ];\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const value_ = e[ 1 ];\n    for (const subValue of value_) {\n      if (isEqual(subValue, value)) return e;\n    }\n  }\n};\n","import { defaultKeyer, type IsEqual, isEqualDefault } from '@ixfx/core';\nimport { firstEntryByValue } from './map-multi-fns.js';\n\nexport class MapOfSimpleBase<V> {\n  protected map: Map<string, readonly V[]>;\n  protected readonly groupBy;\n  protected valueEq;\n\n  /**\n   * Constructor\n   * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n   * @param valueEq Compare values. By default uses JS logic for equality\n   */\n  constructor(\n    groupBy: (value: V) => string = defaultKeyer,\n    valueEq: IsEqual<V> = isEqualDefault<V>,\n    initial: [ string, readonly V[] ][] = []\n  ) {\n    this.groupBy = groupBy;\n    this.valueEq = valueEq;\n    this.map = new Map(initial);\n  }\n\n  /**\n   * Returns _true_ if `key` exists\n   * @param key\n   * @returns\n   */\n  has(key: string): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Returns _true_ if `value` exists under `key`.\n   * @param key Key\n   * @param value Value to seek under `key`\n   * @returns _True_ if `value` exists under `key`.\n   */\n  hasKeyValue(key: string, value: V): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    for (const v of values) {\n      if (this.valueEq(v, value)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Debug dump of contents\n   * @returns\n   */\n  debugString(): string {\n    let r = ``;\n    const keys = [ ...this.map.keys() ];\n    keys.every((k) => {\n      const v = this.map.get(k);\n      if (v === undefined) return;\n      r += k + ` (${ v.length }) = ${ JSON.stringify(v) }\\r\\n`;\n    });\n    return r;\n  }\n\n  /**\n   * Return number of values stored under `key`.\n   * Returns 0 if `key` is not found.\n   * @param key\n   * @returns\n   */\n  count(key: string): number {\n    const values = this.map.get(key);\n    if (!values) return 0;\n    return values.length;\n  }\n\n\n  /**\n * Returns first key that contains `value`\n * @param value \n * @param eq \n * @returns \n */\n  firstKeyByValue(value: V, eq: IsEqual<V> = isEqualDefault) {\n    const entry = firstEntryByValue(this, value, eq);\n    if (entry) return entry[ 0 ];\n  }\n\n  /**\n   * Iterate over all entries\n   */\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const key of this.map.keys()) {\n      for (const value of this.map.get(key)!) {\n        yield [ key, value ];\n      }\n    }\n  }\n\n  /**\n   * Iterate over keys and array of values for that key\n   */\n  *entries(): IterableIterator<[ key: string, value: V[] ]> {\n    for (const [ k, v ] of this.map.entries()) {\n      yield [ k, [ ...v ] ];\n    }\n  }\n\n\n  /**\n   * Get all values under `key`\n   * @param key\n   * @returns\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.map.get(key);\n    if (!m) return;\n    yield* m.values();\n  }\n\n  /**\n   * Iterate over all keys\n   */\n  *keys(): IterableIterator<string> {\n    yield* this.map.keys();\n  }\n\n  /**\n   * Iterate over all values (regardless of key).\n   * Use {@link values} to iterate over a set of values per key\n   */\n  *valuesFlat(): IterableIterator<V> {\n    for (const entries of this.map) {\n      yield* entries[ 1 ];\n    }\n  }\n\n  /**\n   * Yields the values for each key in sequence, returning an array.\n   * Use {@link valuesFlat} to iterate over all keys regardless of key.\n   */\n  *values(): IterableIterator<readonly V[]> {\n    for (const entries of this.map) {\n      yield entries[ 1 ];\n    }\n  }\n  /**\n   * Iterate over keys and length of values stored under keys\n   */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const entries of this.map) {\n      yield [ entries[ 0 ], entries[ 1 ].length ];\n    }\n  }\n\n  /**\n   * Returns the count of keys.\n   */\n  get lengthKeys() {\n    return this.map.size;\n  }\n\n  /**\n  * _True_ if empty\n  */\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n}\n","import { defaultKeyer, type IsEqual, isEqualDefault } from '@ixfx/core';\nimport type { IMapOfMutable } from './imap-of-mutable.js';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable<V>\n  extends MapOfSimpleBase<V>\n  implements IMapOfMutable<V> {\n\n  addKeyedValues(key: string, ...values: readonly V[]) {\n    const existing = this.map.get(key);\n    if (existing === undefined) {\n      this.map.set(key, values);\n    } else {\n      this.map.set(key, [ ...existing, ...values ]);\n    }\n  }\n\n  /**\n   * Set `values` to `key`.\n   * Previous data stored under `key` is thrown away.\n   * @param key \n   * @param values \n   */\n  setValues(key: string, values: readonly V[]) {\n    this.map.set(key, values);\n  }\n\n  /**\n   * Adds a value, automatically extracting a key via the\n   * `groupBy` function assigned in the constructor options.\n   * @param values Adds several values\n   */\n  addValue(...values: readonly V[]) {\n    for (const v of values) {\n      const key = this.groupBy(v);\n      this.addKeyedValues(key, v);\n    }\n  }\n\n  /**\n   * Delete `value` under a particular `key`\n   * @param key\n   * @param value\n   * @returns _True_ if `value` was found under `key`\n   */\n  deleteKeyValue(key: string, value: V): boolean {\n    const existing = this.map.get(key);\n    if (existing === undefined) return false;\n    const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n    this.map.set(key, without);\n    return without.length < existing.length;\n  }\n\n  /**\n   * Deletes `value` regardless of key.\n   *\n   * Uses the constructor-defined equality function.\n   * @param value Value to delete\n   * @returns\n   */\n  deleteByValue(value: V): boolean {\n    let del = false;\n    const entries = [ ...this.map.entries() ];\n    for (const keyEntries of entries) {\n      for (const values of keyEntries[ 1 ]) {\n        if (this.valueEq(values, value)) {\n          del = true;\n          this.deleteKeyValue(keyEntries[ 0 ], value);\n        }\n      }\n    }\n    return del;\n  }\n\n  /**\n   * Deletes all values under `key`,\n   * @param key\n   * @returns _True_ if `key` was found and values stored\n   */\n  delete(key: string): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    if (values.length === 0) return false;\n    this.map.delete(key);\n    return true;\n  }\n\n  /**\n   * Clear contents\n   */\n  clear() {\n    this.map.clear();\n  }\n}\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = <V>(\n  groupBy: (value: V) => string = defaultKeyer,\n  valueEq: IsEqual<V> = isEqualDefault<V>\n): IMapOfMutable<V> => new MapOfSimpleMutable<V>(groupBy, valueEq);\n","import type { ToString, IsEqual } from '@ixfx/core';\nimport type { IMapOf } from './imap-of.js';\nimport type { IMapOfImmutable } from './imap-of-immutable.js';\nimport { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n\n/**\n * Simple immutable MapOf\n */\nexport class MapOfSimple<V>\n  extends MapOfSimpleBase<V>\n  implements IMapOf<V>, IMapOfImmutable<V> {\n  addKeyedValues(key: string, ...values: readonly V[]): IMapOfImmutable<V> {\n    //const asEntries = values.map(v => [key, v]) as [string, V[]][];\n    //return this.addBatch(asEntries);\n    return this.addBatch([ [ key, values ] ]);\n  }\n\n  addValue(...values: readonly V[]): IMapOfImmutable<V> {\n    const asEntries = values.map((v) => [ this.groupBy(v), v ]) as [\n      string,\n      V[]\n    ][];\n    return this.addBatch(asEntries);\n  }\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  addBatch(entries: [ key: string, value: readonly V[] ][]): IMapOfImmutable<V> {\n    // Deep copy Map\n    const temporary = new Map<string, V[]>(\n      [ ...this.map.entries() ].map((e) => [ e[ 0 ], [ ...e[ 1 ] ] ])\n    );\n\n    for (const [ key, list ] of entries) {\n      // Does key exist already\n      const existingList = temporary.get(key);\n      if (typeof existingList === `undefined`) {\n        // No, use the batch input as the data for this key\n        // @ts-expect-error\n        temporary.set(key, list);\n      } else {\n        // Yes\n        existingList.push(...list);\n      }\n    }\n    return new MapOfSimple<V>(this.groupBy, this.valueEq, [ ...temporary.entries() ]);\n  }\n\n  clear(): IMapOfImmutable<V> {\n    return new MapOfSimple<V>(this.groupBy, this.valueEq);\n  }\n\n  deleteKeyValue(_key: string, _value: V): IMapOfImmutable<V> {\n    throw new Error(`Method not implemented.`);\n  }\n\n  deleteByValue(value: V, eq?: IsEqual<V>): IMapOfImmutable<V> {\n    const entries = [ ...this.map.entries() ];\n    const eqFunction = eq ?? this.valueEq;\n    const x = entries.map((entry) => {\n      const key = entry[ 0 ];\n      const values = entry[ 1 ].filter((vv) => !eqFunction(vv, value)) as readonly V[];\n      return [ key, values ] as [ string, V[] ];\n    });\n    return new MapOfSimple<V>(this.groupBy, this.valueEq, x);\n  }\n\n  delete(key: string): IMapOfImmutable<V> {\n    const entries = [ ...this.map.entries() ].filter((e) => e[ 0 ] !== key);\n    return new MapOfSimple<V>(this.groupBy, this.valueEq, entries);\n  }\n}\n\n/**\n * A simple immutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * let m = mapSimple();\n * m = m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m = m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimple = <V>(\n  groupBy: ToString<V> = defaultKeyer,\n  valueEq: IsEqual<V> = isEqualDefault<V>\n): IMapOfImmutable<V> => new MapOfSimple<V>(groupBy, valueEq);\n","export { create as expiringMap } from './expiring-map.js';\nexport type {\n  ExpiringMapEvent,\n  ExpiringMapEvents,\n  Opts as ExpiringMapOpts,\n} from './expiring-map.js';\n\nexport type { IMapOf } from './imap-of.js';\nexport { immutable, type IMapImmutable } from './map.js';\nexport { mutable, type IMapMutable } from './map-mutable.js';\nexport { ofSetMutable } from './map-of-set-mutable.js';\nexport { ofCircularMutable } from './map-of-circular-mutable.js';\nexport type { MapCircularOpts } from './map-of-circular-mutable.js';\nexport type { IMapOfMutable } from './imap-of-mutable.js';\nexport type { IMapOfImmutable } from './imap-of-immutable.js';\nexport type { MapArrayOpts } from './map-of-array-mutable.js';\nexport { NumberMap } from './number-map.js';\nexport * from './map-multi.js';\n\n//export type { IDictionary as IMappish, IWithEntries } from '../../data/maps/IMappish.js';\n\n","import { resultIsError, type Result } from \"@ixfx/guards\";\nimport type { TableRow, TableValue } from \"./types.js\";\n\n\n/**\n * Stores values in a table of rows (vertical) and columns (horizontal)\n */\nexport class Table<V> {\n  rows: TableRow<V>[] = [];\n  rowLabels: string[] = [];\n  colLabels: string[] = [];\n  /**\n   * Keep track of widest row\n   */\n  columnMaxLength = 0;\n\n  /**\n   * Gets the label for a given column index,\n   * returning _undefined_ if not found.\n   * \n   * Case-sensitive\n   * @param label Label to seek\n   * @returns Index of column, or _undefined_ if not found\n   */\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  /**\n   * Gets the label for a given row index,\n   * returning _undefined_ if not found.\n   * \n   * Case-sensitive\n   * @param label Label to seek\n   * @returns Index of row, or _undefined_ if not found\n   */\n  getRowLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.rowLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n  /**\n   * Dumps the values of the table to the console\n   */\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n\n\n  /**\n   * Return a copy of table as nested array\n   * \n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): (V | undefined)[][] {\n    const r: (V | undefined)[][] = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    return this.columnMaxLength;\n    // const lengths = this.rows.map(row => row.length);\n    // return Math.max(...lengths);\n  }\n\n  /**\n   * Iterates over the table row-wise, in object format.\n   * @see {@link rowsWithLabelsArray} to get rows in array format\n   */\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Iterates over each row, including the labels if available\n   * @see {@link rowsWithLabelObject} to get rows in object format\n   */\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Assign labels to columns\n   * @param labels \n   */\n  labelColumns(...labels: string[]) {\n    this.colLabels = labels;\n  }\n\n  /**\n   * Assign label to a specific column\n   * First column has an index of 0\n   * @param columnIndex \n   * @param label \n   */\n  labelColumn(columnIndex: number, label: string) {\n    this.colLabels[ columnIndex ] = label;\n  }\n\n  /**\n   * Label rows\n   * @param labels Labels \n   */\n  labelRows(...labels: string[]) {\n    this.rowLabels = labels;\n  }\n\n  /**\n   * Assign label to a specific row\n   * First row has an index of 0\n   * @param rowIndex \n   * @param label \n   */\n  labelRow(rowIndex: number, label: string) {\n    this.rowLabels[ rowIndex ] = label;\n  }\n\n  /**\n   * Adds a new row\n   * @param data Columns\n   */\n  appendRow(...data: TableValue<V>[]): TableRow<V> {\n    this.columnMaxLength = Math.max(this.columnMaxLength, data.length);\n    this.rows.push(data);\n    return data;\n  }\n\n  /**\n   * Gets a row along with labels, as an array\n   * @param rowIndex \n   * @returns \n   */\n  getRowWithLabelsArray(rowIndex: number): [ label: string | undefined, value: V | undefined ][] | undefined {\n    const row = this.rows.at(rowIndex);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowIndex \n   * @returns \n   */\n  getRowWithLabelsObject(rowIndex: number): object | undefined {\n    const row = this.rows.at(rowIndex);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at given position\n   * @param row Index or label of row \n   * @returns \n   */\n  #getOrCreateRawRow(row: number | string): Result<\n    TableRow<V>,\n    `row-label-notfound` | `row-index-invalid`> {\n    const index = typeof row === `number` ? row : this.getRowLabelIndex(row);\n    // Couldn't lookup label\n    if (index === undefined) return { success: false, error: `row-label-notfound` };\n\n    // Bad index\n    if (index < 0) return { success: false, error: `row-index-invalid` }\n\n    // Within existing set of rows\n    if (index < this.rows.length) {\n      return { success: true, value: this.rows[ index ] };\n    }\n\n    const newRow = [];\n    this.rows[ index ] = newRow;\n\n    return { success: true, value: newRow };\n  }\n\n  /**\n   * Gets a copy of values at given row, specified by index or label\n   * @param row \n   * @returns Returns row or throws an error if label or index not found \n   */\n  row(row: number | string): readonly (V | undefined)[] | undefined {\n    const r = this.#getRowRaw(row);\n    if (resultIsError(r)) {\n      throw new Error(r.error);\n    }\n    return [ ...r.value ]\n  }\n\n  /**\n   * Set the value of row,columm.\n   * Row is created if it doesn't exist, with the other column values being _undefined_\n   * @param row Index or label \n   * @param columnIndex \n   * @param value \n   */\n  set(row: number | string, column: number | string, value: V | undefined) {\n    const result = this.#getOrCreateRawRow(row);\n    if (resultIsError(result)) throw new Error(result.error);\n\n    // Have an array that corresponds to row\n    const r = result.value;\n    const columnIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (typeof columnIndex === `undefined`) throw new Error(`Column label '${ column }' not found or is invalid`);\n\n    if (columnIndex < 0) throw new Error(`Column index invalid (less than zero)`);\n\n    // Already have needed columns\n    r[ columnIndex ] = value;\n  }\n\n  /**\n   * Gets the value at a specified row and column.\n   * Throws an error if coordinates are out of range or missing.\n   * @param row Row index or label\n   * @param column Column index or label\n   * @returns \n   */\n  get(row: number | string, column: number | string): TableValue<V> {\n    const rowR = this.#getRowRaw(row);\n    if (resultIsError(rowR)) throw new Error(rowR.error);\n\n    const colR = this.#getColumnRaw(rowR.value, column);\n    if (resultIsError(colR)) throw new Error(colR.error);\n\n    return colR.value.value;\n  }\n\n  #getRowRaw(row: number | string): Result<TableRow<V>, `row-label-notfound` | `row-invalid` | `row-index-out-of-range`> {\n    let index: number | undefined = 0;\n    if (typeof row === `number`) {\n      index = row;\n    } else {\n      index = this.getRowLabelIndex(row);\n      if (typeof index !== `number`) return { error: `row-label-notfound`, success: false };\n    }\n    if (typeof index !== `number`) return { error: `row-invalid`, success: false };\n\n    if (index < 0 || index >= this.rows.length) return { error: `row-index-out-of-range`, success: false };\n    return { success: true, value: this.rows[ index ] };\n  }\n\n  #getColumnRaw(row: TableRow<V>, column: number | string): Result<{ index: number, value: V | undefined }, `col-label-notfound` | `col-index-out-of-range`> {\n    const colIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (typeof colIndex !== `number`) return { success: false, error: `col-label-notfound` };\n    if (colIndex < 0 || colIndex >= row.length) return { success: false, error: `col-index-out-of-range` };\n    return {\n      success: true, value: { index: colIndex, value: row[ colIndex ] }\n    };\n  }\n\n  /**\n   * Set all the columns of a row to a specified value.\n   *\n   * By default, sets the number of columns corresponding to\n   * the table's maximum column length. To set an arbitrary\n   * length of the row, use `length`\n   * @param row Index or label of row\n   * @param length How wide the row is. If unset, uses the current maximum width of rows.\n   * @param value Value to set\n   */\n  setRow(row: number | string, value: V | undefined, length?: number): TableRow<V> {\n    // Get or create a row\n    const rowResult = this.#getOrCreateRawRow(row);\n    if (resultIsError(rowResult)) throw new Error(rowResult.error);\n\n    // Set value within row\n    const r = rowResult.value;\n    const width = typeof length === `number` ? length : this.columnMaxLength;\n    for (let columnNumber = 0; columnNumber < width; columnNumber++) {\n      r[ columnNumber ] = value;\n    }\n    return r;\n  }\n}","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { QueueMutable } from \"../queue/queue-mutable.js\"\nimport { PriorityMutable } from \"../queue/priority-mutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../map/map.js\"\nimport { NumberMap } from \"../map/number-map.js\"\nimport * as Sync from \"@ixfx/iterables/sync\"\nimport { Table } from \"../table.js\"\nimport { resultThrow, stringTest, type Result } from \"@ixfx/guards\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: readonly Edge[]\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | string[]\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable.\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n/**\n * Returns _true_ if graph contains `key`.\n * \n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key \n * @returns \n */\nexport function hasKey(graph: DirectedGraph, key: string): boolean {\n  resultThrow(graphTest(graph));\n  return graph.vertices.has(key);\n}\n\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n * \n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph \n * @param key \n * @returns \n */\nexport function get(graph: DirectedGraph, key: string): Vertex | undefined {\n  resultThrow(graphTest(graph));\n\n  resultThrow(stringTest(key, `non-empty`, `key`));\n  return graph.vertices.get(key);\n\n}\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  resultThrow(graphTest(graph));\n\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, false, v.length);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): string[] => {\n\n  const r: string[] = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\n/**\n * Returns the weight of an edge, or 1 if undefined.\n * @param graph\n * @param edge \n * @returns \n */\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  resultThrow(graphTest(graph));\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  resultThrow(graphTest(graph));\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\nfunction graphTest(g: DirectedGraph, parameterName = `graph`): Result<DirectedGraph, string> {\n  if (g === undefined) return { success: false, error: `Param '${ parameterName }' is undefined. Expected Graph` };\n  if (g === null) return { success: false, error: `Param '${ parameterName }' is null. Expected Graph` };\n  if (typeof g === `object`) {\n    if (!(`vertices` in g)) return {\n      success: false, error: `Param '${ parameterName }.vertices' does not exist. Is it a Graph type?`\n    };\n  } else {\n    return { success: false, error: `Param '${ parameterName } is type '${ typeof g }'. Expected an object Graph` };\n  }\n  return { success: true, value: g };\n}\n\n// function throwGraphTest(g: DirectedGraph, parameterName = `graph`) {\n//   const r = testGraph(g, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ] as string)\n// }\n\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  resultThrow(graphTest(graph));\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  resultThrow(graphTest(graph));\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: (string | Vertex)[]): boolean => {\n  resultThrow(graphTest(graph));\n\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  resultThrow(graphTest(graph));\n\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  resultThrow(graphTest(graph));\n\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  resultThrow(graphTest(graph));\n\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  resultThrow(graphTest(graph));\n\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  resultThrow(graphTest(graph));\n\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  resultThrow(graphTest(graph));\n\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  if (typeof graph !== `object`) throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${ typeof graph }`);\n  if (typeof options !== `object`) throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${ typeof options }`);\n\n  const result = connectWithEdges(graph, options);\n  return result.graph;\n}\n\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well. \n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connectWithEdges(graph: DirectedGraph, options: ConnectOptions): { graph: DirectedGraph, edges: Edge[] } {\n  resultThrow(graphTest(graph));\n\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  const edges: Edge[] = []\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n\n  if (!bidi) return { graph, edges };\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n  return { graph, edges };\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): string[] => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  resultThrow(graphTest(graph));\n\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  resultThrow(graphTest(graph));\n\n  if (idOrVertex === undefined) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  resultThrow(graphTest(graph));\n\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  resultThrow(graphTest(graph));\n\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  resultThrow(graphTest(graph));\n\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Edge[] => {\n    const path: Edge[] = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  resultThrow(graphTest(graph));\n\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n * \n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: ConnectOptions[]): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  resultThrow(graphTest(graph));\n\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  resultThrow(graphTest(graph));\n\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Vertex[] = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Vertex[][] {\n  resultThrow(graphTest(graph));\n\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Vertex[][] = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Vertex[] = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  resultThrow(graphTest(graph));\n\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","\nimport { immutable as immutableMap, type IMapImmutable } from \"../map/map.js\"\nimport { Table } from \"../table.js\"\n\nexport type Vertex = Readonly<{\n  id: string\n}>\n\nexport type Edge = Readonly<{\n  a: string,\n  b: string,\n  weight?: number\n}>\n\nexport type Graph = Readonly<{\n  edges: readonly Edge[],\n  vertices: IMapImmutable<string, Vertex>\n}>\n\nexport type ConnectOptions = Readonly<{\n  a: string\n  b: string | string[]\n  weight?: number\n}>\n\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id\n  }\n}\n\nexport const updateGraphVertex = (graph: Graph, vertex: Vertex): Graph => {\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\nexport const getOrCreate = (graph: Graph, id: string): Readonly<{ graph: Graph, vertex: Vertex }> => {\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\nfunction resolveVertex(graph: Graph, idOrVertex: string | Vertex): Vertex {\n  if (idOrVertex === undefined) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n  if (graph === undefined) throw new Error(`Param 'graph' is undefined. Expected Graph`);\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Returns _true/false_ if there is a connection between `a` and `b` in `graph`.\n * Use {@link getConnection} if you want to the edge.\n * @param graph Graph to search \n * @param a\n * @param b\n * @returns _true_ if edge exists \n */\nexport const hasConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): boolean => {\n  const edge = getConnection(graph, a, b);\n  return edge !== undefined;\n}\n\n/**\n * Gets the connection, if it exists between `a` and `b` in `graph`.\n * If it doesn't exist, _undefined_ is returned.\n * Use {@link hasConnection} for a simple true/false if edge exists.\n * @param graph Graph\n * @param a \n * @param b \n * @returns \n */\nexport const getConnection = (graph: Graph, a: string | Vertex, b: string | Vertex): Edge | undefined => {\n  if (a === undefined) throw new Error(`Param 'a' is undefined. Expected string or Vertex`);\n  if (b === undefined) throw new Error(`Param 'b' is undefined. Expected string or Vertex`);\n  if (graph === undefined) throw new Error(`Param 'graph' is undefined. Expected Graph`);\n\n  const aa = resolveVertex(graph, a);\n  const bb = resolveVertex(graph, b);\n  for (const edge of graph.edges) {\n    if (edge.a == aa.id && edge.b === bb.id) return edge;\n    if (edge.a == bb.id && edge.b === aa.id) return edge;\n  }\n  return;\n}\n\n/**\n * Connects A with B, returning the changed graph and created edge.\n * If the connection already exists, the original graph & edge is returned.\n * @param graph \n * @param a \n * @param b \n * @param weight \n * @returns \n */\nexport function connectTo(graph: Graph, a: string, b: string, weight?: number): { graph: Graph, edge: Edge } {\n  const aResult = getOrCreate(graph, a);\n  graph = aResult.graph;\n  const bResult = getOrCreate(graph, b);\n  graph = bResult.graph;\n\n  let edge = getConnection(graph, a, b);\n  if (edge !== undefined) return { graph, edge };\n  edge = {\n    a,\n    b,\n    weight\n  }\n\n  const graphChanged: Graph = {\n    ...graph,\n    edges: [ ...graph.edges, edge ]\n  }\n  return { graph: graphChanged, edge }\n}\n\n\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connectWithEdges} but only the {@link Graph} is returned.\n * \n * ```js\n * let g = graph(); // Create an empty graph\n * // Make a connection between `red` and `orange`\n * g = connect(g, { a: `red`, b: `orange` });\n * \n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * g = connect(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connect(graph: Graph, options: ConnectOptions): Graph {\n  const result = connectWithEdges(graph, options);\n  return result.graph;\n}\n\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connect} but graph and edges are returned.\n * \n * ```js\n * let g = graph(); // Create an empty graph\n * \n * // Make a connection between `red` and `orange`\n * result = connectWithEdges(g, { a: `red`, b: `orange` });\n * \n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * result = connectWithEdges(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connectWithEdges(graph: Graph, options: ConnectOptions): { graph: Graph, edges: Edge[] } {\n  const { a, weight, b } = options;\n  const destinations = Array.isArray(b) ? b : [ b ];\n  const edges: Edge[] = [];\n  for (const destination of destinations) {\n    const result = connectTo(graph, a, destination, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n\n  return { graph, edges };\n}\n\nexport const graph = (...initialConnections: ConnectOptions[]): Graph => {\n  let g: Graph = {\n    vertices: immutableMap(),\n    edges: []\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\nexport function toAdjacencyMatrix(graph: Graph): Table<boolean> {\n  const v = [ ...graph.vertices.values() ];\n\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    table.setRow(i, false, v.length);\n\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      const connected = hasConnection(graph, ii, jj);\n      if (connected) {\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: Graph): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: Graph): string[] => {\n  const r: string[] = [];\n\n  r.push(`Vertices: ${ [ ...graph.vertices.values() ].map(v => v.id).join(`, `) }`);\n\n  r.push(`Edges:`);\n  for (const edge of graph.edges) {\n    r.push(stringForEdge(edge));\n  }\n  return r;\n}\n\nconst stringForEdge = (edge: Edge) => {\n  const weight = edge.weight ? ` (${ edge.weight })` : ``;\n  return `${ edge.a } <-> ${ edge.b }${ weight }`\n}\n\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns \n */\nexport function* adjacentVertices(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield resolveVertex(graph, edge.b);\n    else if (edge.b === context) yield resolveVertex(graph, edge.a);\n  }\n}\n\nexport function* edgesForVertex(graph: Graph, context: Vertex | string | undefined) {\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of graph.edges) {\n    if (edge.a === context) yield edge;\n    else if (edge.b === context) yield edge;\n  }\n}","/**\n * Directed graphs\n * \n * Graph _vertices_ (ie. nodes) connect to each other along _edges_.\n * This is 'directed' in that connections are not necessarily mutual.\n * A can connect to B without B connecting to A.\n * \n * Connections can have an optional weight, defaulting to 1.\n * \n * @example Creating a directed graph A connects to B and C; B connects to C. C has edges.\n * ```js\n * let g = Directed.graph(\n *  { from: `a`, to: [`b`, `c`] },\n *  { from: `b`, to: `c` }\n*  );\n* ```\n* \n* Graphs do not store data directly, only the relation between vertices. Each vertex has an id,\n* so to associate data, use a map along with the graph.\n*\n*/\nexport * as Directed from './directed-graph.js';\n\n/**\n * Undirected graphs\n * \n * Graph _vertices_ (ie. nodes) connect to each other along _edges_.\n * Unlike a directed graph, nodes are always mutually connected.\n * \n * @example Creating an undirected graph where vertex 0 connects to 1, 2 & 3; 2 connects to 1\n * ```js\n * let g = Undirected.graph(\n *    { a: `0`, b: [ `1`, `2`, `3` ] },\n *    { a: `2`, b: `1` }\n *  );\n* ```\n* \n* Graphs do not store data directly, only the relation between vertices. Each vertex has an id,\n* so to associate data, use a map along with the graph.\n*\n*/\nexport * as Undirected from './undirected-graph.js';"],"mappings":"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"}