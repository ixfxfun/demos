{"version":3,"file":"core.js","names":["recordEntriesDepthFirst","mapObjectKeys"],"sources":["../../packages/core/dist/src/records/compare.js","../../packages/core/dist/src/records/clone-from-fields.js","../../packages/core/dist/src/records/map-object.js","../../packages/core/dist/src/records/traverse.js","../../packages/core/dist/src/records/merge.js","../../packages/core/dist/src/records/keys-to-numbers.js","../../packages/core/dist/src/records/pathed.js","../../packages/core/dist/src/records/index.js","../../packages/core/dist/src/maps.js","../../packages/core/dist/src/trackers/tracked-value.js","../../packages/core/dist/src/trackers/tracker-base.js","../../packages/core/dist/src/trackers/object-tracker.js","../../packages/core/dist/src/trackers/primitive-tracker.js","../../packages/core/dist/src/trackers/index.js"],"sourcesContent":["import { mapObjectKeys } from '@ixfx/core/records';\nimport { compareIterableValuesShallow, isEqualDefault } from '@ixfx/core';\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareObjectKeys = (a, b) => {\n    const c = compareIterableValuesShallow(Object.keys(a), Object.keys(b));\n    return c;\n};\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n *\n * ```js\n * const a = { msg: `hi`, v: 10 };\n *\n * changedDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n *\n * Under the hood, we use {@link compareObjectData}(a, b, true). If B has additional or removed fields,\n * this is considered an error.\n *\n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a\n * @param b\n */\nexport const changedObjectDataFields = (a, b) => {\n    const r = compareObjectData(a, b, true);\n    if (Object.entries(r.added).length > 0)\n        throw new Error(`Shape of data has changed`);\n    if (Object.entries(r.removed).length > 0)\n        throw new Error(`Shape of data has changed`);\n    const output = compareResultToObject(r, b);\n    return output;\n};\nconst compareResultToObject = (r, b) => {\n    const output = {};\n    if (r.isArray) {\n        return b;\n    }\n    for (const entry of Object.entries(r.changed)) {\n        output[entry[0]] = entry[1];\n    }\n    for (const entry of Object.entries(r.added)) {\n        output[entry[0]] = entry[1];\n    }\n    for (const childEntry of Object.entries(r.children)) {\n        const childResult = childEntry[1];\n        if (childResult.hasChanged) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            output[childEntry[0]] = compareResultToObject(childResult, b[childEntry[0]]);\n        }\n    }\n    return output;\n};\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n *\n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport const compareArrays = (a, b, eq = (isEqualDefault)) => {\n    if (!Array.isArray(a))\n        throw new Error(`Param 'a' is not an array`);\n    if (!Array.isArray(b))\n        throw new Error(`Param 'b' is not an array`);\n    const c = compareObjectData(a, b, false, eq);\n    if (!c.isArray)\n        throw new Error(`Change set does not have arrays as parameters`);\n    const convert = (key) => {\n        if (key.startsWith(`_`)) {\n            return Number.parseInt(key.slice(1));\n        }\n        else\n            throw new Error(`Unexpected key '${key}'`);\n    };\n    const cc = {\n        ...c,\n        added: mapObjectKeys(c.added, convert),\n        changed: mapObjectKeys(c.changed, convert),\n        removed: c.removed.map(v => convert(v)),\n        summary: c.summary.map(value => {\n            return [value[0], convert(value[1]), value[2]];\n        })\n    };\n    return cc;\n};\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the\n * values are primitive values or other simple objects. It also works with arrays.\n *\n * Uses === equality semantics by default.\n * @param a\n * @param b\n */\nexport const compareObjectData = (a, b, assumeSameShape = false, eq = isEqualDefault) => {\n    a ??= {};\n    b ??= {};\n    const entriesA = Object.entries(a);\n    const entriesB = Object.entries(b);\n    const scannedKeys = new Set();\n    const changed = {};\n    const added = {};\n    const children = {};\n    const removed = [];\n    const isArray = Array.isArray(a);\n    const summary = new Array();\n    let hasChanged = false;\n    // Look for existing entries of A that are modified\n    for (const entry of entriesA) {\n        const outputKey = isArray ? `_${entry[0]}` : entry[0];\n        const aValue = entry[1];\n        const bValue = b[entry[0]];\n        scannedKeys.add(entry[0]);\n        if (bValue === undefined) {\n            // B does not have a key from A\n            hasChanged = true;\n            if (assumeSameShape && !isArray) {\n                // If we're assuming it's the same shape, then _undefined_ is actually the value\n                changed[outputKey] = bValue;\n                summary.push([`mutate`, outputKey, bValue]);\n            }\n            else {\n                // Key removed\n                removed.push(outputKey);\n                summary.push([`del`, outputKey, aValue]);\n            }\n            continue;\n        }\n        if (typeof aValue === `object`) {\n            const r = compareObjectData(aValue, bValue, assumeSameShape, eq);\n            if (r.hasChanged)\n                hasChanged = true;\n            children[outputKey] = r;\n            const childSummary = r.summary.map(sum => { return [sum[0], outputKey + `.` + sum[1], sum[2]]; });\n            summary.push(...childSummary);\n        }\n        else {\n            if (!eq(aValue, bValue)) {\n                changed[outputKey] = bValue;\n                hasChanged = true;\n                summary.push([`mutate`, outputKey, bValue]);\n            }\n        }\n    }\n    // Look for entries in B that weren't in A\n    if (!assumeSameShape || isArray) {\n        for (const entry of entriesB) {\n            const key = isArray ? `_${entry[0]}` : entry[0];\n            if (scannedKeys.has(entry[0]))\n                continue;\n            added[key] = entry[1];\n            hasChanged = true;\n            summary.push([`add`, key, entry[1]]);\n        }\n    }\n    return {\n        changed, added, removed, children, hasChanged, isArray, summary\n    };\n};\n","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\nexport const cloneFromFields = (source) => {\n    const entries = [];\n    for (const field in source) {\n        const value = (source)[field];\n        if (testPlainObjectOrPrimitive(value)) {\n            entries.push([field, value]);\n        }\n    }\n    return Object.fromEntries(entries);\n};\n","/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n *\n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = (object, mapFunction) => {\n    const entries = Object.entries(object);\n    const mapped = entries.map(([sourceField, sourceFieldValue], index) => [\n        sourceField,\n        mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n    ]);\n    return Object.fromEntries(mapped);\n};\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data\n * @param mapper\n * @returns\n */\nexport function mapObjectByObject(data, mapper) {\n    const entries = Object.entries(data);\n    for (const entry of entries) {\n        if (entry[0] in mapper) {\n            const m = mapper[entry[0]];\n            entry[1] = (typeof m === `object`) ?\n                mapObjectByObject(entry[1], m) :\n                m(entry[1], data);\n        }\n    }\n    return Object.fromEntries(entries);\n}\n","import { resultThrow, nullUndefTest } from '@ixfx/guards';\nimport { isPrimitive } from '../is-primitive.js';\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link RecordEntry}.\n * @param entries\n * @returns\n */\nexport function prettyPrintEntries(entries) {\n    if (entries.length === 0)\n        return `(empty)`;\n    let t = ``;\n    for (const [index, entry] of entries.entries()) {\n        t += `  `.repeat(index);\n        t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n    }\n    return t;\n}\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const recordEntryPrettyPrint = (node, indent = 0, options = {}) => {\n    resultThrow(nullUndefTest(node, `node`));\n    const defaultName = options.name ?? `node`;\n    const entry = getNamedRecordEntry(node, defaultName);\n    const t = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.nodeValue)}`;\n    const childrenAsArray = [...recordChildren(node, options)];\n    return childrenAsArray.length > 0 ? (t +\n        `\\n` +\n        childrenAsArray.map((d) => recordEntryPrettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)) : t;\n};\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * Sub-children are included as an object blob.\n *\n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n *\n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport function* recordChildren(node, options = {}) {\n    resultThrow(nullUndefTest(node, `node`));\n    const filter = options.filter ?? `none`;\n    const filterByValue = (v) => {\n        if (filter === `none`)\n            return [true, isPrimitive(v)];\n        else if (filter === `leaves` && isPrimitive(v))\n            return [true, true];\n        else if (filter === `branches` && !isPrimitive(v))\n            return [true, false];\n        return [false, isPrimitive(v)];\n    };\n    if (Array.isArray(node)) {\n        //if (options.name === undefined) defaultName = `array`;\n        for (const [index, element] of node.entries()) {\n            const f = filterByValue(element);\n            if (f[0]) {\n                yield { name: index.toString(), sourceValue: element, nodeValue: f[1] ? element : undefined };\n                //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n            }\n        }\n    }\n    else if (typeof node === `object`) {\n        const entriesIter = (`entries` in node) ? node.entries() : Object.entries(node);\n        for (const [name, value] of entriesIter) {\n            //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n            const f = filterByValue(value);\n            if (f[0]) {\n                yield { name: name, sourceValue: value, nodeValue: f[1] ? value : undefined };\n            }\n        }\n    }\n}\nexport function* recordEntriesDepthFirst(node, options = {}, ancestors = []) {\n    for (const c of recordChildren(node, options)) {\n        //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n        yield { ...c, ancestors: [...ancestors] };\n        yield* recordEntriesDepthFirst(c.sourceValue, options, [...ancestors, c.name]);\n    }\n}\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction recordEntryChildByName(name, node) {\n    for (const d of recordChildren(node)) {\n        if (d.name === name)\n            return d;\n    }\n}\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceRecordEntryByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getRecordEntryByPath(path, node, options = {}) {\n    const paths = [...traceRecordEntryByPath(path, node, options)];\n    if (paths.length === 0)\n        throw new Error(`Could not trace path: ${path} `);\n    return paths.at(-1);\n}\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getRecordEntryByPath} if you don't care about interim steps.\n *\n * ```js\n * const people = {\n *  jane: {\n *   address: {\n *    postcode: 1000,\n *    street: 'West St',\n *    city: 'Blahville'\n *   },\n * colour: 'red'\n *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceRecordEntryByPath(path, node, options = {}) {\n    resultThrow(nullUndefTest(path, `path`), nullUndefTest(node, `node`));\n    const separator = options.separator ?? `.`;\n    const pathSplit = path.split(separator);\n    const ancestors = [];\n    for (const p of pathSplit) {\n        const entry = recordEntryChildByName(p, node);\n        if (!entry) {\n            yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n            return;\n        }\n        node = entry.sourceValue;\n        yield { ...entry, ancestors: [...ancestors] };\n        ancestors.push(p);\n    }\n}\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedRecordEntry(node, defaultName = ``) {\n    if (`name` in node && `nodeValue` in node && `sourceValue` in node)\n        return node;\n    if (`name` in node) {\n        return { name: node.name, nodeValue: node, sourceValue: node };\n    }\n    return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n","// Source: https://stackoverflow.com/questions/49682569/typescript-merge-object-types\n// jcalz 2021-09-09\nexport function mergeObjects(...a) {\n    return Object.assign({}, ...a);\n}\n","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n *\n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n *\n *\n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n *\n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object\n * @param onInvalidKey\n * @returns\n */\nexport const keysToNumbers = (object, onInvalidKey = `throw`) => {\n    const returnObject = {};\n    for (const entry of Object.entries(object)) {\n        const asNumber = Number.parseInt(entry[0]);\n        if (Number.isNaN(asNumber)) {\n            switch (onInvalidKey) {\n                case `throw`: {\n                    throw new TypeError(`Cannot convert key '${entry[0]}' to an integer`);\n                }\n                case `ignore`: {\n                    continue;\n                }\n                case `keep`: {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n                    returnObject[entry[0]] = entry[1];\n                    continue;\n                }\n                default: {\n                    throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n                }\n            }\n        }\n        returnObject[asNumber] = entry[1];\n    }\n    return returnObject;\n};\n","import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport { compareObjectKeys } from './compare.js';\nconst getEntries = (target, deepProbe) => {\n    if (target === undefined)\n        throw new Error(`Param 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Param 'target' is null`);\n    if (typeof target !== `object`)\n        throw new Error(`Param 'target' is not an object (got: ${typeof target})`);\n    if (deepProbe) {\n        const entries = [];\n        for (const field in target) {\n            const value = target[field];\n            if (testPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return entries;\n    }\n    else {\n        return Object.entries(target);\n    }\n};\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n *\n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns\n */\nexport function* compareData(a, b, options = {}) {\n    if (typeof a === `undefined`) {\n        yield {\n            path: options.pathPrefix ?? ``,\n            value: b,\n            state: `added`\n        };\n        return;\n    }\n    if (typeof b === `undefined`) {\n        yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` };\n        return;\n    }\n    const asPartial = options.asPartial ?? false;\n    const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n    const pathPrefix = options.pathPrefix ?? ``;\n    const deepEntries = options.deepEntries ?? false;\n    const eq = options.eq ?? isEqualContextString;\n    const includeMissingFromA = options.includeMissingFromA ?? false;\n    const includeParents = options.includeParents ?? false;\n    //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n    if (isPrimitive(a) && isPrimitive(b)) {\n        if (a !== b)\n            yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    if (isPrimitive(b)) {\n        yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    const entriesA = getEntries(a, deepEntries);\n    const entriesAKeys = new Set();\n    for (const [key, valueA] of entriesA) {\n        entriesAKeys.add(key);\n        const keyOfAInB = key in b;\n        const valueOfKeyInB = b[key];\n        //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n        if (typeof valueA === `object` && valueA !== null) {\n            if (keyOfAInB) {\n                //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n                if (valueOfKeyInB === undefined) {\n                    throw new Error(`Pathed.compareData Value for key ${key} is undefined`);\n                }\n                else {\n                    const sub = [...compareData(valueA, valueOfKeyInB, {\n                            ...options,\n                            pathPrefix: pathPrefix + key + `.`\n                        })];\n                    if (sub.length > 0) {\n                        for (const s of sub)\n                            yield s;\n                        if (includeParents) {\n                            yield { path: pathPrefix + key, value: b[key], previous: valueA, state: `change` };\n                        }\n                    }\n                }\n            }\n            else {\n                if (asPartial)\n                    continue;\n                //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n                yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` };\n            }\n        }\n        else {\n            const subPath = pathPrefix + key;\n            if (keyOfAInB) {\n                // B contains key from A\n                if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n                    //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n                    yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n                }\n                else {\n                    if (!eq(valueA, valueOfKeyInB, subPath)) {\n                        //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n                        yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n                    }\n                }\n            }\n            else {\n                // B does not contain key from A\n                if (asPartial)\n                    continue; // Ignore\n                yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n            }\n        }\n    }\n    if (includeMissingFromA) {\n        const entriesB = getEntries(b, deepEntries);\n        for (const [key, valueB] of entriesB) {\n            if (entriesAKeys.has(key))\n                continue;\n            // Key in B that's not in A\n            //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n            yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n        }\n    }\n}\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source\n * @param changes\n */\nexport const applyChanges = (source, changes) => {\n    for (const change of changes) {\n        source = updateByPath(source, change.path, change.value);\n    }\n    return source;\n};\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n *\n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n *\n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n *\n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n *\n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter\n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n *\n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n *\n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns\n */\nexport const updateByPath = (target, path, value, allowShapeChange = false) => {\n    if (path === undefined)\n        throw new Error(`Parameter 'path' is undefined`);\n    if (typeof path !== `string`)\n        throw new Error(`Parameter 'path' should be a string. Got: ${typeof path}`);\n    if (target === undefined)\n        throw new Error(`Parameter 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Parameter 'target' is null`);\n    const split = path.split(`.`);\n    const r = updateByPathImpl(target, split, value, allowShapeChange);\n    return r;\n};\nconst updateByPathImpl = (o, split, value, allowShapeChange) => {\n    if (split.length === 0) {\n        //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n        if (allowShapeChange)\n            return value; // yolo\n        if (Array.isArray(o) && !Array.isArray(value))\n            throw new Error(`Expected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (!Array.isArray(o) && Array.isArray(value))\n            throw new Error(`Unexpected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (typeof o !== typeof value)\n            throw new Error(`Cannot reassign object type. (${typeof o} -> ${typeof value}). Set allowShapeChange=true to ignore.`);\n        // Make sure new value has the same set of keys\n        if (typeof o === `object` && !Array.isArray(o)) {\n            const c = compareObjectKeys(o, value);\n            if (c.a.length > 0) {\n                throw new Error(`New value is missing key(s): ${c.a.join(`,`)}`);\n            }\n            if (c.b.length > 0) {\n                throw new Error(`New value cannot add new key(s): ${c.b.join(`,`)}`);\n            }\n        }\n        return value;\n    }\n    const start = split.shift();\n    if (!start)\n        return value;\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(o)) {\n        const index = Number.parseInt(start);\n        if (index >= o.length && !allowShapeChange)\n            throw new Error(`Array index ${index.toString()} is outside of the existing length of ${o.length.toString()}. Use allowShapeChange=true to permit this.`);\n        const copy = [...o];\n        copy[index] = updateByPathImpl(copy[index], split, value, allowShapeChange);\n        return copy;\n    }\n    else if (start in o) {\n        const copy = { ...o };\n        copy[start] = updateByPathImpl(copy[start], split, value, allowShapeChange);\n        return copy;\n    }\n    else {\n        throw new Error(`Path ${start} not found in data`);\n    }\n};\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n *\n * Returns _undefined_ if path could not be resolved.\n *\n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object\n * @param path\n * @returns\n */\nexport const getField = (object, path) => {\n    if (typeof path !== `string`)\n        throw new Error(`Param 'path' ought to be a string. Got: '${typeof path}'`);\n    if (path.length === 0)\n        throw new Error(`Param string 'path' is empty`);\n    if (object === undefined)\n        throw new Error(`Param 'object' is undefined`);\n    if (object === null)\n        throw new Error(`Param 'object' is null`);\n    const split = path.split(`.`);\n    const v = getFieldImpl(object, split);\n    return v;\n};\nconst getFieldImpl = (object, split) => {\n    if (object === undefined)\n        throw new Error(`Param 'object' is undefined`);\n    if (split.length === 0)\n        throw new Error(`Path has run out`);\n    const start = split.shift();\n    if (!start)\n        throw new Error(`Unexpected empty split path`);\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n        const index = Number.parseInt(start); //start.slice(1, -1));\n        //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n        if (typeof object[index] === `undefined`) {\n            return { success: false, error: `Index '${index}' does not exist. Length: ${object.length}` };\n        }\n        if (split.length === 0) {\n            return { value: object[index], success: true };\n        }\n        else {\n            return getFieldImpl(object[index], split);\n        }\n    }\n    else if (typeof object === `object` && start in object) {\n        //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n        if (split.length === 0) {\n            return { value: object[start], success: true };\n        }\n        else {\n            return getFieldImpl(object[start], split);\n        }\n    }\n    else {\n        return { success: false, error: `Path '${start}' not found` };\n    }\n};\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n *\n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included.\n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object, onlyLeaves = false) {\n    if (object === undefined || object === null)\n        return;\n    const iter = recordEntriesDepthFirst(object);\n    for (const c of iter) {\n        if (c.nodeValue === undefined && onlyLeaves)\n            continue;\n        let path = c.name;\n        if (c.ancestors.length > 0)\n            path = c.ancestors.join(`.`) + `.` + path;\n        yield path;\n    }\n}\n;\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [\n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns\n */\nexport function* getPathsAndData(o, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``) {\n    if (o === null)\n        return;\n    if (o === undefined)\n        return;\n    yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\nfunction* getPathsAndDataImpl(o, prefix, onlyLeaves = false, maxDepth) {\n    if (maxDepth <= 0)\n        return;\n    if (typeof o !== `object`)\n        return;\n    for (const entries of Object.entries(o)) {\n        const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[0];\n        const value = entries[1];\n        const leaf = (typeof value !== `object`);\n        if (onlyLeaves && leaf || !onlyLeaves) {\n            yield { path: sub, value };\n        }\n        yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n    }\n}\n","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\nexport * from './pathed.js';\n/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n *\n * mapObjectKeys(input, key => key.toUppercase());\n *\n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object\n * @param mapFunction\n * @returns\n */\nexport const mapObjectKeys = (object, mapFunction) => {\n    const destinationObject = {};\n    for (const entries of Object.entries(object)) {\n        const key = mapFunction(entries[0]);\n        destinationObject[key] = entries[1];\n    }\n    return destinationObject;\n};\n","import { defaultComparer } from './comparers.js';\nimport { isEqualDefault } from './is-equal.js';\nimport { toStringDefault, } from './to-string.js';\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (data, target) => {\n    target = Math.round(target);\n    if (data.has(target)) {\n        return target;\n    }\n    else {\n        let offset = 1;\n        while (offset < 1000) {\n            if (data.has(target - offset))\n                return target - offset;\n            else if (data.has(target + offset))\n                return target + offset;\n            offset++;\n        }\n        throw new Error(`Could not find target ${target.toString()}`);\n    }\n};\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = getFromKeys(data, keys);\n * ```\n * @param data\n * @param keys\n * @returns\n */\nexport const getFromKeys = (data, keys) => {\n    for (const key of keys) {\n        if (data.has(key))\n            return data.get(key);\n    }\n};\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = (map, key, value, comparer) => {\n    if (!map.has(key))\n        return false;\n    const values = [...map.values()];\n    return values.some((v) => comparer(v, value));\n};\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer\n */\nexport const deleteByValueMutate = (map, value, comparer = isEqualDefault) => {\n    for (const entry of Object.entries(map)) {\n        if (comparer(entry[1], value)) {\n            map.delete(entry[0]);\n        }\n    }\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByPredicate = (map, predicate) => {\n    for (const entry of map.entries()) {\n        if (predicate(entry[1], entry[0]))\n            return entry;\n    }\n};\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (isEqual(entry[1], value))\n            return entry;\n    }\n};\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n *\n * @example\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\";\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * Maps.addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\nexport const addKeepingExisting = (set, hasher, ...values) => {\n    const s = set === undefined ? new Map() : new Map(set);\n    for (const v of values) {\n        const hashResult = hasher(v);\n        if (s.has(hashResult))\n            continue;\n        s.set(hashResult, v);\n    }\n    return s;\n};\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = (map, comparer) => {\n    const f = comparer ?? defaultComparer;\n    return [...map.entries()].sort((a, b) => f(a[1], b[1]));\n};\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * cosnt m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = Maps.sortByValue(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = (map, property, compareFunction) => {\n    const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n    return [...map.entries()].sort((aE, bE) => {\n        const a = aE[1];\n        const b = bE[1];\n        return cfn(a[property], b[property]);\n    });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = (map, value, comparer) => {\n    const entries = [...map.entries()];\n    return entries.some((kv) => comparer(kv[1], value));\n};\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\nexport function* filter(map, predicate) {\n    for (const v of map.values()) {\n        if (predicate(v))\n            yield v;\n    }\n}\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = (map) => [...map.values()];\n/**\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` }\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = Maps.fromIterable(data, v => v.fruit);\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param allowOverwrites When set to _true_, items with same id will silently overwrite each other, with last write wins. _false_ by default.\n * @returns\n */\nexport const fromIterable = (data, keyFunction = (toStringDefault), allowOverwrites = false) => {\n    const m = new Map();\n    for (const d of data) {\n        const id = keyFunction(d);\n        if (m.has(id) && !allowOverwrites) {\n            throw new Error(`id ${id} is already used and new data will overwrite it. `);\n        }\n        m.set(id, d);\n    }\n    return m;\n};\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = (data) => {\n    const map = new Map();\n    if (Array.isArray(data)) {\n        for (const d of data)\n            addObjectMutate(map, d);\n    }\n    else {\n        addObjectMutate(map, data);\n    }\n    return map;\n};\n/**\n * Adds an object to an existing map, mutating it.\n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObject(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectMutate = (map, data) => {\n    const entries = Object.entries(data);\n    for (const [key, value] of entries) {\n        map.set(key, value);\n    }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const find = (map, predicate) => [...map.values()].find(v => predicate(v));\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link find} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map\n * @param predicate\n * @returns\n */\nexport const some = (map, predicate) => [...map.values()].some(v => predicate(v));\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = (m, valueTransform) => [...m].reduce((object, [key, value]) => {\n    const t = valueTransform(value);\n    object[key] = t;\n    return object;\n}, {});\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = (keys, values) => {\n    if (keys.length !== values.length) {\n        throw new Error(`Keys and values arrays should be same length`);\n    }\n    return Object.fromEntries(keys.map((k, index) => [k, values[index]]));\n};\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = (source, transformer) => new Map(Array.from(source, (v) => [v[0], transformer(v[1], v[0])]));\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = (m) => [...m].reduce((object, [key, value]) => {\n    object[key] = value;\n    return object;\n}, {});\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = (m, transformer) => [...m.entries()].map((x) => transformer(x[0], x[1]));\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Arrays.mergeByKey Arrays.mergeByKey} if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = (reconcile, ...maps) => {\n    const result = new Map();\n    for (const m of maps) {\n        for (const [mk, mv] of m) {\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return result;\n};\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate = (map, fn) => async (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value; //Promise.resolve(value);\n    value = await fn(key, args);\n    if (value === undefined)\n        throw new Error(`fn returned undefined`);\n    map.set(key, value);\n    return value;\n};\n","import { getOrGenerate } from '../maps.js';\nimport { TrackerBase } from './tracker-base.js';\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class PointsTracker extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap {\n    store;\n    gog;\n    constructor(creator) {\n        this.store = new Map();\n        this.gog = getOrGenerate(this.store, creator);\n    }\n    /**\n     * Number of named values being tracked\n     */\n    get size() {\n        return this.store.size;\n    }\n    /**\n     * Returns _true_ if `id` is stored\n     * @param id\n     * @returns\n     */\n    has(id) {\n        return this.store.has(id);\n    }\n    /**\n     * For a given id, note that we have seen one or more values.\n     * @param id Id\n     * @param values Values(s)\n     * @returns Information about start to last value\n     */\n    //eslint-disable-next-line functional/prefer-immutable-types\n    async seen(id, ...values) {\n        const trackedValue = await this.getTrackedValue(id, ...values);\n        // Pass it over to the TrackedValue\n        const result = trackedValue.seen(...values);\n        return result;\n    }\n    /**\n     * Creates or returns a TrackedValue instance for `id`.\n     * @param id\n     * @param values\n     * @returns\n     */\n    //eslint-disable-next-line functional/prefer-immutable-types\n    async getTrackedValue(id, ...values) {\n        if (id === null)\n            throw new Error(`id parameter cannot be null`);\n        if (id === undefined)\n            throw new Error(`id parameter cannot be undefined`);\n        // Create or recall TrackedValue by id\n        const trackedValue = await this.gog(id, values[0]);\n        return trackedValue;\n    }\n    /**\n     * Remove a tracked value by id.\n     * Use {@link reset} to clear them all.\n     * @param id\n     */\n    delete(id) {\n        this.store.delete(id);\n    }\n    /**\n     * Remove all tracked values.\n     * Use {@link delete} to remove a single value by id.\n     */\n    reset() {\n        this.store = new Map();\n    }\n    /**\n     * Enumerate ids\n     */\n    *ids() {\n        yield* this.store.keys();\n    }\n    /**\n     * Enumerate tracked values\n     */\n    *tracked() {\n        yield* this.store.values();\n    }\n    /**\n     * Iterates TrackedValues ordered with oldest first\n     * @returns\n     */\n    *trackedByAge() {\n        const tp = [...this.store.values()];\n        tp.sort((a, b) => {\n            const aa = a.elapsed;\n            const bb = b.elapsed;\n            if (aa === bb)\n                return 0;\n            if (aa > bb)\n                return -1;\n            return 1;\n        });\n        for (const t of tp) {\n            yield t;\n        }\n    }\n    /**\n     * Iterates underlying values, ordered by age (oldest first)\n     * First the named values are sorted by their `elapsed` value, and then\n     * we return the last value for that group.\n     */\n    *valuesByAge() {\n        for (const tb of this.trackedByAge()) {\n            yield tb.last;\n        }\n    }\n    /**\n     * Enumerate last received values\n     *\n     * @example Calculate centroid of latest-received values\n     * ```js\n     * const pointers = pointTracker();\n     * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n     * ```\n     */\n    *last() {\n        for (const p of this.store.values()) {\n            yield p.last;\n        }\n    }\n    /**\n     * Enumerate starting values\n     */\n    *initialValues() {\n        for (const p of this.store.values()) {\n            yield p.initial;\n        }\n    }\n    /**\n     * Returns a tracked value by id, or undefined if not found\n     * @param id\n     * @returns\n     */\n    get(id) {\n        return this.store.get(id);\n    }\n}\n","import {} from './tracked-value.js';\n/**\n * Base tracker class\n */\nexport class TrackerBase {\n    /**\n     * @ignore\n     */\n    seenCount;\n    /**\n     * @ignore\n     */\n    storeIntermediate;\n    /**\n     * @ignore\n     */\n    resetAfterSamples;\n    /**\n     * @ignore\n     */\n    sampleLimit;\n    id;\n    debug;\n    constructor(opts = {}) {\n        this.id = opts.id ?? `tracker`;\n        this.debug = opts.debug ?? false;\n        this.sampleLimit = opts.sampleLimit ?? -1;\n        this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n        this.storeIntermediate =\n            opts.storeIntermediate ??\n                (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n        this.seenCount = 0;\n        if (this.debug) {\n            console.log(`TrackerBase: sampleLimit: ${this.sampleLimit} resetAfter: ${this.resetAfterSamples} store: ${this.storeIntermediate}`);\n        }\n    }\n    /**\n     * Reset tracker\n     */\n    reset() {\n        this.seenCount = 0;\n        this.onReset();\n    }\n    /**\n     * Adds a value, returning computed result.\n     *\n     * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.\n     * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is\n     * called to take it down to sample limit, and `onTrimmed()` is called.\n     * @param p\n     * @returns\n     */\n    seen(...p) {\n        if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n            this.reset();\n        }\n        else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n            this.seenCount = this.trimStore(this.sampleLimit);\n            this.onTrimmed(`resize`);\n        }\n        this.seenCount += p.length;\n        const t = this.filterData(p);\n        return this.computeResults(t);\n    }\n}\n","import { TrackerBase } from './tracker-base.js';\n/**\n * A tracked value of type `V`.\n */\nexport class ObjectTracker extends TrackerBase {\n    values;\n    constructor(opts = {}) {\n        super(opts);\n        this.values = [];\n    }\n    onTrimmed(reason) {\n        // no-op\n    }\n    /**\n     * Reduces size of value store to `limit`.\n     * Returns number of remaining items\n     * @param limit\n     */\n    trimStore(limit) {\n        if (limit >= this.values.length)\n            return this.values.length;\n        // Index 0 will be the oldest\n        this.values = this.values.slice(-limit);\n        return this.values.length;\n    }\n    /**\n     * Allows sub-classes to be notified when a reset happens\n     * @ignore\n     */\n    onReset() {\n        this.values = [];\n    }\n    /**\n     * Tracks a value\n     * @ignore\n     */\n    filterData(p) {\n        // Make sure values have a timestamp\n        const ts = p.map((v) => `at` in v\n            ? v\n            : {\n                ...v,\n                at: Date.now(),\n            });\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const last = ts.at(-1);\n        if (this.storeIntermediate)\n            this.values.push(...ts);\n        else\n            switch (this.values.length) {\n                case 0: {\n                    // Add as initial value\n                    this.values.push(last);\n                    break;\n                }\n                case 1: {\n                    // Add last value\n                    this.values.push(last);\n                    break;\n                }\n                case 2: {\n                    // Replace last value\n                    this.values[1] = last;\n                    break;\n                }\n            }\n        return ts;\n    }\n    /**\n     * Last seen value. If no values have been added, it will return the initial value\n     */\n    get last() {\n        if (this.values.length === 1)\n            return this.values[0];\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.values.at(-1);\n    }\n    /**\n     * Returns the oldest value in the buffer\n     */\n    get initial() {\n        return this.values.at(0);\n    }\n    /**\n     * Returns number of recorded values (includes the initial value in the count)\n     */\n    get size() {\n        return this.values.length;\n    }\n    /**\n     * Returns the elapsed time, in milliseconds since the initial value\n     */\n    get elapsed() {\n        return Date.now() - this.values[0].at;\n    }\n}\n","import { TrackerBase } from \"./tracker-base.js\";\nexport class PrimitiveTracker extends TrackerBase {\n    values;\n    timestamps;\n    constructor(opts) {\n        super(opts);\n        this.values = [];\n        this.timestamps = [];\n    }\n    /**\n     * Reduces size of value store to `limit`. Returns\n     * number of remaining items\n     * @param limit\n     */\n    trimStore(limit) {\n        if (limit >= this.values.length)\n            return this.values.length;\n        this.values = this.values.slice(-limit);\n        this.timestamps = this.timestamps.slice(-limit);\n        return this.values.length;\n    }\n    onTrimmed(reason) {\n        // no-op\n    }\n    get last() {\n        return this.values.at(-1);\n    }\n    get initial() {\n        return this.values.at(0);\n    }\n    /**\n     * Returns number of recorded values (this can include the initial value)\n     */\n    get size() {\n        return this.values.length;\n    }\n    /**\n     * Returns the elapsed time, in milliseconds since the instance was created\n     */\n    get elapsed() {\n        if (this.values.length < 0)\n            throw new Error(`No values seen yet`);\n        return Date.now() - this.timestamps[0];\n    }\n    onReset() {\n        this.values = [];\n        this.timestamps = [];\n    }\n    /**\n     * Tracks a value\n     */\n    filterData(rawValues) {\n        const lastValue = rawValues.at(-1);\n        const last = { value: lastValue, at: performance.now() };\n        const values = rawValues.map(value => ({\n            at: performance.now(),\n            value: value\n        }));\n        //const now = Date.now();\n        if (this.storeIntermediate) {\n            this.values.push(...rawValues);\n            this.timestamps.push(...values.map(v => v.at));\n        }\n        else\n            switch (this.values.length) {\n                case 0: {\n                    // Add as initial value\n                    this.values.push(last.value);\n                    this.timestamps.push(last.at);\n                    break;\n                }\n                case 2: {\n                    // Replace last value\n                    this.values[1] = last.value;\n                    this.timestamps[1] = last.at;\n                    break;\n                }\n                case 1: {\n                    // Add last value\n                    this.values.push(last.value);\n                    this.timestamps.push(last.at);\n                    break;\n                }\n                // No default\n            }\n        return values;\n    }\n}\n","export * from \"./object-tracker.js\";\nexport * from './primitive-tracker.js';\nexport * from \"./tracked-value.js\";\nexport * from './tracker-base.js';\n"],"mappings":"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"}