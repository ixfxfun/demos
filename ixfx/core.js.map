{"version":3,"file":"core.js","names":["object: Record<TKeySource, unknown>","mapFunction: (key: TKeySource) => TKeyDestination","a: object","b: object","r: CompareChangeSet<TKey>","a: TValue[]","b: TValue[]","eq: IsEqual<TValue>","key: string","cc: CompareChangeSet<number>","a: object | null","b: object | null","eq: IsEqual<T>","removed: string[]","source: T","entries: [ key: string, value: any ][]","object: TSource","mapFunction: (args: MapObjectArgs) => TFieldValue","data: object","mapper: Record<string, (value: any, context: any) => any>","isPrimitive","value: any","entries: readonly RecordEntry[]","node: object","options: Partial<RecordChildrenOptions>","node: T","v: any","isPrimitive","recordEntriesDepthFirst","ancestors: string[]","name: string","path: string","options: PathOpts","object: Record<string | number | symbol, T>","onInvalidKey: `throw` | `ignore` | `keep`","returnObject: Record<number, T>","value: object","replaceWith: any","value: unknown","toStringDefault","itemToMakeStringFor: V","value: null | boolean | string | object","a: number","b: number","x: any","y: any","comparer: Comparer<V>","x: V","y: V","itemToMakeStringFor: unknown","key: string","value: unknown","isEqualDefault","a: T","b: T","toStringDefault","a: Record<string, unknown>","b: Record<string, unknown>","fieldComparer?: IsEqual<unknown>","value: object","isEqualContextString: IsEqualContext<unknown>","a: unknown","b: unknown","_path: string","data: ReadonlyMap<number, unknown>","target: number","data: ReadonlyMap<string, T>","keys: Iterable<string>","map: ReadonlyMap<K, V>","key: K","value: V","comparer: IsEqual<V>","isEqualDefault","map: Map<K, V>","map: IWithEntries<K, V>","predicate: (value: V, key: K) => boolean","isEqual: IsEqual<V>","map: Map<string, V> | undefined","hasher: ToString<V>","collisionPolicy: `overwrite` | `skip` | `throw`","map: Map<string, V> | ReadonlyMap<string, V> | undefined","map: Map<string, V>","comparer?: (a: V, b: V) => number","property: string","compareFunction?: (a: Z, b: Z) => number","map: ReadonlyMap<string, V>","predicate: (v: V) => boolean","data: Iterable<V>","toStringDefault","data: object | object[]","data: object","m: ReadonlyMap<string, T>","valueTransform: (value: T) => K","object: object","keys: readonly string[]","values: ArrayLike<V | undefined>","source: ReadonlyMap<K, V>","transformer: (value: V, key: K) => R","m: ReadonlyMap<K, V>","transformer: (key: K, item: V) => R","reconcile: MergeReconcile<V>","map: IDictionary<K, V>","fn: (key: K, args?: Z) => V","args?: Z","fn: (key: K, args?: Z) => Promise<V> | V","target: object","deepProbe: boolean","entries: [ key: string, value: any ][]","a: V","b: Partial<V>","options: Partial<CompareDataOptions<V>>","source: V","changes: PathDataChange<any>[]","target: V","path: string","value: any","o: any","split: string[]","allowShapeChange: boolean","object: Record<string, any>","position: string","object: object | null","o: object","prefix: string","maxDepth: number","callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback","interval?: Interval","options: Partial<ContinuouslyOpts>","runState: HasCompletionRunStates","currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined","scheduledCallback: () => void","interval: Interval","interval","a: Scored","b: Scored","similarityFunction: Similarity<V>","lastData: readonly DataWithId<V>[] | undefined","newData: readonly DataWithId<V>[]","options: AlignOpts","newThings: DataWithId<V>[]","fn: Similarity<V>","lastData: readonly DataWithId<V>[]","newData: DataWithId<V>[]","a: V","v: V","predicate: (v: V) => boolean","skipValue: V | undefined","source: string","source: any","eq: IsEqual<T>","isInteger","value: string | number","compareIterableValuesShallow","a: Iterable<V>","b: Iterable<V>","isEqualDefault","shared:V[]","aUnique:V[]","bUnique:V[]","index: number","values: KeyValue[]","sortStyle: KeyValueSortSyles","a: number","b?: number | boolean","roundUp?: boolean","v: number","intervalToMs","interval: Interval | undefined","defaultNumber?: number","interval: number | Interval | undefined","millisOrFunction: number | (() => number) | Interval","interval: number | undefined","toString: ToString<T>","value: T","target: EventTarget","name: string","resolve","rx: object","resolve","r: ResolveToValue<V>","resolveSync","r: ResolveToValueSync<V>","p: ResolveToValue<T>","fallback: ResolveFallbackOpts<T>","p: ResolveToValueSync<T>","returnValue: any[]","object: T","resolvers: any[]","keys: string[]","entries: [ key: string, value: any ][]","optsOrMillis: SleepOpts<V>","intervalToMs","resolve","predicate: () => boolean","checkInterval: Interval"],"sources":["../packages/core/src/records/map-object-keys.ts","../packages/core/src/records/compare.ts","../packages/core/src/records/clone-from-fields.ts","../packages/core/src/records/map-object.ts","../packages/core/src/is-primitive.ts","../packages/core/src/records/traverse.ts","../packages/core/src/records/merge.ts","../packages/core/src/records/keys-to-numbers.ts","../packages/core/src/records/index.ts","../packages/core/src/records/circular.ts","../packages/core/src/to-string.ts","../packages/core/src/comparers.ts","../packages/core/src/is-equal.ts","../packages/core/src/maps.ts","../packages/core/src/pathed.ts","../packages/core/src/trackers/index.ts","../packages/core/src/continuously.ts","../packages/core/src/correlate.ts","../packages/core/src/default-keyer.ts","../packages/core/src/elapsed.ts","../packages/core/src/filters.ts","../packages/core/src/text.ts","../packages/core/src/is-equal-test.ts","../packages/core/src/is-integer.ts","../packages/core/src/iterable-compare-values-shallow.ts","../packages/core/src/key-value.ts","../packages/core/src/util/round.ts","../packages/core/src/interval-type.ts","../packages/core/src/track-unique.ts","../packages/core/src/platform.ts","../packages/core/src/promise-from-event.ts","../packages/core/src/reactive-core.ts","../packages/core/src/resolve-core.ts","../packages/core/src/util/zip.ts","../packages/core/src/resolve-fields.ts","../packages/core/src/sleep.ts"],"sourcesContent":["/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n * \n * mapObjectKeys(input, key => key.toUppercase());\n * \n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object \n * @param mapFunction \n * @returns \n */\nexport const mapObjectKeys = <TKeySource extends string | number | symbol, TKeyDestination extends string | number | symbol>(object: Record<TKeySource, unknown>, mapFunction: (key: TKeySource) => TKeyDestination) => {\n  const destinationObject = {};\n  for (const entries of Object.entries(object)) {\n    const key = mapFunction(entries[ 0 ] as TKeySource);\n    (destinationObject as Record<TKeyDestination, unknown>)[ key ] = entries[ 1 ];\n  }\n  return destinationObject as Record<TKeyDestination, unknown>;\n}\n","\nimport { compareIterableValuesShallow, isEqualDefault, type IsEqual } from '@ixfx/core';\nimport type { ChangeRecord, CompareChangeSet } from '../types-compare.js';\nimport { mapObjectKeys } from './map-object-keys.js';\n\n\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const compareObjectKeys = (a: object, b: object) => {\n  const c = compareIterableValuesShallow(Object.keys(a), Object.keys(b));\n  return c;\n}\n\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n * \n * ```js\n * const a = { msg: `hi`, v: 10 };\n * \n * changedObjectDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedObjectDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedObjectDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n * \n * If B has additional or removed fields, this is considered an error.\n * \n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a \n * @param b \n */\nexport const changedObjectDataFields = (a: object, b: object) => {\n  const r = compareObjectData(a, b, true);\n  if (Object.entries(r.added).length > 0) throw new Error(`Shape of data has changed`);\n  if (Object.entries(r.removed).length > 0) throw new Error(`Shape of data has changed`);\n\n  const output = compareResultToObject(r, b);\n  return output;\n}\n\nconst compareResultToObject = <TKey extends string | number>(r: CompareChangeSet<TKey>, b: object): Record<string, unknown> | object[] => {\n  const output = {}\n\n  if (r.isArray) {\n    return b as object[];\n  }\n\n  for (const entry of Object.entries(r.changed)) {\n    (output as object)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n  for (const entry of Object.entries(r.added)) {\n    (output as object)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n\n  for (const childEntry of Object.entries(r.children)) {\n    const childResult = childEntry[ 1 ] as CompareChangeSet<TKey>;\n    if (childResult.hasChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      (output as object)[ childEntry[ 0 ] ] = compareResultToObject(childResult, b[ childEntry[ 0 ] ]);\n    }\n  }\n  return output;\n}\n\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n * \n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport const compareArrays = <TValue>(a: TValue[], b: TValue[], eq: IsEqual<TValue> = isEqualDefault<TValue>): CompareChangeSet<number> => {\n  if (!Array.isArray(a)) throw new Error(`Param 'a' is not an array`);\n  if (!Array.isArray(b)) throw new Error(`Param 'b' is not an array`);\n  const c = compareObjectData(a, b, false, eq);\n  if (!c.isArray) throw new Error(`Change set does not have arrays as parameters`);\n\n  const convert = (key: string): number => {\n    if (key.startsWith(`_`)) {\n      return Number.parseInt(key.slice(1));\n    } else throw new Error(`Unexpected key '${ key }'`);\n  }\n  const cc: CompareChangeSet<number> = {\n    ...c,\n    added: mapObjectKeys(c.added, convert),\n    changed: mapObjectKeys(c.changed, convert),\n    removed: c.removed.map(v => convert(v)),\n    summary: c.summary.map(value => {\n      return [ value[ 0 ], convert(value[ 1 ]), value[ 2 ] ];\n    })\n  }\n  return cc;\n}\n\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the \n * values are primitive values or other simple objects. It also works with arrays.\n * \n * Uses === equality semantics by default.\n * @param a \n * @param b \n */\nexport const compareObjectData = <T>(a: object | null, b: object | null, assumeSameShape = false, eq: IsEqual<T> = isEqualDefault): CompareChangeSet<string> => {\n  a ??= {};\n  b ??= {};\n  const entriesA = Object.entries(a);\n  const entriesB = Object.entries(b);\n\n  const scannedKeys = new Set<string>();\n  const changed = {}\n  const added = {}\n  const children = {}\n  const removed: string[] = [];\n  const isArray = Array.isArray(a);\n\n  const summary = new Array<ChangeRecord<string>>();\n  let hasChanged = false;\n\n  // Look for existing entries of A that are modified\n  for (const entry of entriesA) {\n    const outputKey = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n    const aValue = entry[ 1 ] as unknown;\n    const bValue = b[ entry[ 0 ] ] as unknown;\n    scannedKeys.add(entry[ 0 ]);\n\n    if (bValue === undefined) {\n      // B does not have a key from A\n      hasChanged = true;\n      if (assumeSameShape && !isArray) {\n        // If we're assuming it's the same shape, then _undefined_ is actually the value\n        changed[ outputKey ] = bValue;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      } else {\n        // Key removed\n        removed.push(outputKey);\n        summary.push([ `del`, outputKey, aValue ]);\n      }\n      continue;\n    }\n\n    if (typeof aValue === `object`) {\n      const r = compareObjectData(aValue, bValue as object, assumeSameShape, eq);\n      if (r.hasChanged) hasChanged = true;\n      children[ outputKey ] = r;\n      const childSummary = r.summary.map(sum => { return [ sum[ 0 ], outputKey + `.` + sum[ 1 ], sum[ 2 ] ] }) as ChangeRecord<string>[];\n      summary.push(...childSummary);\n    } else {\n      if (!eq(aValue as T, bValue as T)) {\n        changed[ outputKey ] = bValue;\n        hasChanged = true;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      }\n    }\n  }\n\n  // Look for entries in B that weren't in A\n  if (!assumeSameShape || isArray) {\n    for (const entry of entriesB) {\n      const key = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n\n      if (scannedKeys.has(entry[ 0 ])) continue;\n      added[ key ] = entry[ 1 ] as unknown;\n      hasChanged = true;\n      summary.push([ `add`, key, entry[ 1 ] ])\n    }\n  }\n  return {\n    changed, added, removed, children, hasChanged, isArray, summary\n  }\n}","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\n\nexport const cloneFromFields = <T extends object>(source: T) => {\n\n  const entries: [ key: string, value: any ][] = [];\n  for (const field in source) {\n    const value = (source)[ field ];\n    if (testPlainObjectOrPrimitive(value as unknown)) {\n      entries.push([ field, value ]);\n    }\n  }\n  return Object.fromEntries(entries) as T;\n}","import type { RemapObjectPropertyType } from \"../ts-utility.js\";\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  object: TSource,\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n  ]) as MapResult[];\n  return Object.fromEntries(mapped) as RemapObjectPropertyType<TSource, TFieldValue>;\n};\n\nexport type MapObjectArgs = {\n  field: string\n  path: string\n  value: any\n  index: number\n}\n\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data \n * @param mapper \n * @returns \n */\nexport function mapObjectByObject(data: object, mapper: Record<string, (value: any, context: any) => any>) {\n  const entries = Object.entries(data);\n  for (const entry of entries) {\n    if (entry[ 0 ] in mapper) {\n      const m = mapper[ entry[ 0 ] ];\n      entry[ 1 ] = (typeof m === `object`) ?\n        mapObjectByObject(entry[ 1 ] as object, m) :\n        m(entry[ 1 ], data);\n    }\n  }\n  return Object.fromEntries(entries);\n}","import type { Primitive, PrimitiveOrObject } from \"./types.js\";\n\n/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n * \n * Use {@link isPrimitiveOrObject} to also return true if `value` is an object.\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value: any): value is Primitive {\n  if (typeof value === `number`) return true;\n  if (typeof value === `string`) return true;\n  if (typeof value === `bigint`) return true;\n  if (typeof value === `boolean`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `value` is number, string, bigint, boolean or an object\n * \n * Use {@link isPrimitive} to not include objects.\n * @param value\n * @returns \n */\nexport function isPrimitiveOrObject(value: any): value is PrimitiveOrObject {\n  if (isPrimitive(value)) return true;\n  if (typeof value === `object`) return true;\n  return false;\n}","import { resultThrow, nullUndefTest } from '@ixfx/guards';\nimport { isPrimitive } from '../is-primitive.js';\n\nexport type RecordEntry = Readonly<{ name: string, sourceValue: any, nodeValue: any }>;\nexport type RecordEntryWithAncestors = Readonly<{ name: string, sourceValue: any, nodeValue: any, ancestors: string[] }>;\nexport type RecordEntryStatic = Readonly<{ name: string, value: any, ancestors: string[] }>\n\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n  /**\n   * Separator for path, eg '.'\n   */\n  readonly separator?: string;\n};\n\nexport type RecordChildrenOptions = Readonly<{\n  /**\n   * If set, only uses leaves or branches. 'none' means there is no filter.\n   */\n  filter: `none` | `leaves` | `branches`\n  /**\n   * Default name to use. This is necessary in some cases, eg a root object.\n   */\n  name: string\n}>;\n\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link RecordEntry}.\n * @param entries \n * @returns \n */\nexport function prettyPrintEntries(entries: readonly RecordEntry[]) {\n  if (entries.length === 0) return `(empty)`;\n  let t = ``;\n  for (const [ index, entry ] of entries.entries()) {\n    t += `  `.repeat(index);\n    t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n  }\n  return t;\n}\n\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const recordEntryPrettyPrint = (\n  node: object,\n  indent = 0,\n  options: Partial<RecordChildrenOptions> = {}\n): string => {\n  resultThrow(nullUndefTest(node, `node`));\n  const defaultName = options.name ?? `node`;\n  const entry = getNamedRecordEntry(node, defaultName);\n  const t = `${ `  `.repeat(indent) } + name: ${ entry.name } value: ${ JSON.stringify(entry.nodeValue) }`;\n  const childrenAsArray = [ ...recordChildren(node, options) ];\n  return childrenAsArray.length > 0 ? (\n    t +\n    `\\n` +\n    childrenAsArray.map((d) => recordEntryPrettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)\n  ) : t;\n};\n\n\n\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays. \n * \n * Sub-children are included as an object blob.\n * \n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n * \n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n * \n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children: \n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n * \n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node \n * @param options  \n */\nexport function* recordChildren<T extends object>(\n  node: T,\n  options: Partial<RecordChildrenOptions> = {}\n): IterableIterator<RecordEntry> {\n  resultThrow(nullUndefTest(node, `node`));\n\n  const filter = options.filter ?? `none`;\n\n  const filterByValue = (v: any): [ filter: boolean, isPrimitive: boolean ] => {\n    if (filter === `none`) return [ true, isPrimitive(v) ];\n    else if (filter === `leaves` && isPrimitive(v)) return [ true, true ];\n    else if (filter === `branches` && !isPrimitive(v)) return [ true, false ];\n    return [ false, isPrimitive(v) ];\n  }\n\n  if (Array.isArray(node)) {\n    //if (options.name === undefined) defaultName = `array`;\n    for (const [ index, element ] of node.entries()) {\n      const f = filterByValue(element);\n      if (f[ 0 ]) {\n        yield { name: index.toString(), sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n        //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n      }\n    }\n  } else if (typeof node === `object`) {\n    const entriesIter = (`entries` in node) ? (node as any as Map<any, any>).entries() : Object.entries(node);\n    for (const [ name, value ] of entriesIter) {\n      //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n      const f = filterByValue(value);\n      if (f[ 0 ]) {\n        yield { name: name, sourceValue: value, nodeValue: f[ 1 ] ? value : undefined };\n      }\n    }\n  }\n}\n\nexport function* recordEntriesDepthFirst<T extends object>(node: T, options: Partial<RecordChildrenOptions> = {}, ancestors: string[] = []): IterableIterator<RecordEntryWithAncestors> {\n  for (const c of recordChildren(node, options)) {\n    //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n    yield { ...c, ancestors: [ ...ancestors ] };\n    yield* recordEntriesDepthFirst(c.sourceValue, options, [ ...ancestors, c.name ]);\n  }\n}\n\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction recordEntryChildByName<T extends object>(\n  name: string,\n  node: T\n): RecordEntry | undefined {\n  for (const d of recordChildren(node)) {\n    if (d.name === name) return d;\n  }\n}\n\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceRecordEntryByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getRecordEntryByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): RecordEntry {\n  const paths = [ ...traceRecordEntryByPath(path, node, options) ];\n  if (paths.length === 0) throw new Error(`Could not trace path: ${ path } `);\n  return paths.at(-1) as RecordEntry;\n}\n\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n * \n * Use {@link getRecordEntryByPath} if you don't care about interim steps.\n *\n * ```js\n * const people = {\n *  jane: {\n *   address: {\n *    postcode: 1000,\n *    street: 'West St',\n *    city: 'Blahville'\n *   },\n * colour: 'red'\n *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n * \n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceRecordEntryByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Iterable<RecordEntryWithAncestors> {\n  resultThrow(\n    nullUndefTest(path, `path`),\n    nullUndefTest(node, `node`)\n  );\n  const separator = options.separator ?? `.`;\n  const pathSplit = path.split(separator);\n\n  const ancestors: string[] = [];\n  for (const p of pathSplit) {\n    const entry = recordEntryChildByName(p, node);\n    if (!entry) {\n      yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n      return;\n    }\n    node = entry.sourceValue;\n    yield { ...entry, ancestors: [ ...ancestors ] };\n    ancestors.push(p);\n  }\n}\n\n\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedRecordEntry<T extends object>(node: T, defaultName = ``): RecordEntry {\n  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node as RecordEntry;\n  if (`name` in node) {\n    return { name: node.name as string, nodeValue: node, sourceValue: node };\n  }\n  return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n","// Source: https://stackoverflow.com/questions/49682569/typescript-merge-object-types\n// jcalz 2021-09-09\n\ntype OptionalPropertyNames<T> =\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  { [ K in keyof T ]-?: ({} extends Record<K, T[ K ]> ? K : never) }[ keyof T ];\n\ntype SpreadProperties<L, R, K extends keyof L & keyof R> =\n  { [ P in K ]: L[ P ] | Exclude<R[ P ], undefined> };\n\ntype Id<T> = T extends infer U ? { [ K in keyof U ]: U[ K ] } : never\n\ntype SpreadTwo<L, R> = Id<\n  & Pick<L, Exclude<keyof L, keyof R>>\n  & Pick<R, Exclude<keyof R, OptionalPropertyNames<R>>>\n  & Pick<R, Exclude<OptionalPropertyNames<R>, keyof L>>\n  & SpreadProperties<L, R, OptionalPropertyNames<R> & keyof L>\n>;\n\nexport type Spread<A extends readonly [ ...any ]> = A extends [ infer L, ...infer R ] ?\n  SpreadTwo<L, Spread<R>> : unknown\n\nexport function mergeObjects<A extends object[]>(...a: [ ...A ]) {\n  return Object.assign({}, ...a) as Spread<A>;\n}","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n * \n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n * \n * \n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n * \n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object \n * @param onInvalidKey \n * @returns \n */\nexport const keysToNumbers = <T>(object: Record<string | number | symbol, T>, onInvalidKey: `throw` | `ignore` | `keep` = `throw`): Record<number, T> => {\n  const returnObject: Record<number, T> = {};\n  for (const entry of Object.entries(object)) {\n    const asNumber = Number.parseInt(entry[ 0 ]);\n    if (Number.isNaN(asNumber)) {\n      switch (onInvalidKey) {\n        case `throw`: {\n          throw new TypeError(`Cannot convert key '${ entry[ 0 ] }' to an integer`);\n        }\n        case `ignore`: {\n          continue;\n        }\n        case `keep`: {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n          (returnObject as any)[ entry[ 0 ] ] = entry[ 1 ];\n          continue;\n        }\n        default: {\n          throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n        }\n      }\n    }\n    returnObject[ asNumber ] = entry[ 1 ];\n  }\n  return returnObject;\n}\n","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './map-object-keys.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\nexport type * from '../types-compare.js';\n\n","export const removeCircularReferences = (value: object, replaceWith: any = null, seen = new WeakSet(), path = ``) => {\n  if (value === null) return value;\n  if (typeof value !== `object`) throw new TypeError(`Param 'value' must be an object. Got type: ${ typeof value }`);\n\n  seen.add(value);\n  const entries = Object.entries(value);\n  for (const entry of entries) {\n    if (entry[ 1 ] === null) continue;\n    if (typeof entry[ 1 ] !== `object`) continue;\n\n    if (seen.has(entry[ 1 ] as WeakKey)) {\n      //value[ entry[0] ] = replaceWith;\n      entry[ 1 ] = replaceWith;\n      continue;\n    }\n    entry[ 1 ] = removeCircularReferences(entry[ 1 ] as object, replaceWith, seen, `${ entry[ 0 ] }.`);\n  }\n  return Object.fromEntries(entries);\n};","\n// Via Vuejs\n\nimport { removeCircularReferences } from \"./records/circular.js\";\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\n/**\n * Returns _true_ if `value` is a Map type\n * @param value\n * @returns \n */\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\n\n/**\n * Returns _true_ if `value` is a Set type\n * @param value \n * @returns \n */\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n\n/**\n * Converts a value to string form.\n * For simple objects, .toString() is used, other JSON.stringify is used.\n * It is meant for creating debugging output or 'hash' versions of objects, and does\n * not necessarily maintain full fidelity of the input\n * @param value \n * @returns \n */\nexport const defaultToString = (value: null | boolean | string | object): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (value === null) return `null`;\n  if (typeof value === `boolean` || typeof value === `number`) {\n    return value.toString();\n  }\n\n  if (typeof value === `string`) return value;\n  if (typeof value === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  try {\n    const s = JSON.stringify(value);\n    return s;\n  } catch (error) {\n    // Circular maybe\n    if (typeof value === `object`) {\n      return JSON.stringify(removeCircularReferences(value, `(circular)`));\n    } else {\n      throw error;\n    }\n  }\n};","import { defaultToString } from \"./to-string.js\";\n\nexport type CompareResult = number; // 0 | 1 | -1;\nexport type Comparer<V> = (a: V, b: V) => CompareResult;\n\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * \n * Returns:\n * * 0: values are equal\n * * negative: `a` should be before `b`\n * * positive: `a` should come after `b`\n * @param a\n * @param b\n * @returns\n */\nexport const numericComparer = (a: number, b: number): CompareResult => {\n  // ✔️ Unit tested\n  if (a === b) return 0;\n  if (a > b) return 1;\n  return -1;\n};\n\n\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n * \n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\n\nexport const jsComparer = (x: any, y: any): CompareResult => {\n  // ✔️ Unit tested\n\n  // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n  if (x === undefined && y === undefined) return 0;\n  if (x === undefined) return 1;\n  if (y === undefined) return -1;\n\n  const xString = defaultToString(x);\n  const yString = defaultToString(y);\n\n  if (xString < yString) return -1;\n  if (xString > yString) return 1;\n  return 0;\n};\n\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = <V>(comparer: Comparer<V>): Comparer<V> => {\n  return (x: V, y: V) => {\n    const v = comparer(x, y);\n    return v * -1;\n  };\n};\n\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n * \n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x: any, y: any): CompareResult => {\n  if (typeof x === `number` && typeof y === `number`) {\n    return numericComparer(x, y);\n  }\n  return jsComparer(x, y);\n};","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: unknown) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n\n  JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string, unknown>, b: Record<string, unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string, unknown>, valueB as Record<string, unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b` are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","import { defaultComparer } from './comparers.js';\nimport { isEqualDefault, type IsEqual } from './is-equal.js';\nimport {\n  toStringDefault,\n} from './to-string.js';\nimport type { IDictionary, IWithEntries, ToString } from './types.js';\n\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (\n  data: ReadonlyMap<number, unknown>,\n  target: number\n): number => {\n  target = Math.round(target);\n  if (data.has(target)) {\n    return target;\n  } else {\n    let offset = 1;\n    while (offset < 1000) {\n      if (data.has(target - offset)) return target - offset;\n      else if (data.has(target + offset)) return target + offset;\n      offset++;\n    }\n    throw new Error(`Could not find target ${ target.toString() }`);\n  }\n};\n\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = findBySomeKey(data, keys);\n * ```\n * @param data \n * @param keys \n * @returns \n */\nexport const findBySomeKey = <T>(data: ReadonlyMap<string, T>, keys: Iterable<string>): T | undefined => {\n  for (const key of keys) {\n    if (data.has(key)) return data.get(key);\n  }\n}\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match. By default uses === comparison.\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n): boolean => {\n  if (!map.has(key)) return false;\n  const values = [ ...map.values() ];\n  return values.some((v) => comparer(v, value));\n};\n\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueCompareMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer Uses === equality by default. Use isEqualValueDefault to compare by value\n */\nexport const deleteByValueCompareMutate = <K, V>(\n  map: Map<K, V>,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n) => {\n  for (const entry of map.entries()) {\n    if (comparer(entry[ 1 ], value)) {\n      map.delete(entry[ 0 ]);\n    }\n  }\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link findEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const findEntryByPredicate = <K, V>(\n  map: IWithEntries<K, V>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (predicate(entry[ 1 ], entry[ 0 ])) return entry;\n  }\n};\n\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * Uses JS's === comparison by default. Consider using `isEqualValueDefault` to match by value.\n * An alternative is {@link findEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const findEntryByValue = <K, V>(\n  map: IWithEntries<K, V>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (isEqual(entry[ 1 ], value)) return entry;\n  }\n};\n\n\n\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n * Returns a copy of the input map.\n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\n// export const addKeepingExisting = <V>(\n//   set: ReadonlyMap<string, V> | undefined,\n//   hasher: ToString<V>,\n//   ...values: readonly V[]\n// ) => {\n//   const s = set === undefined ? new Map() : new Map(set);\n//   for (const v of values) {\n//     const hashResult = hasher(v);\n//     if (s.has(hashResult)) continue;\n//     s.set(hashResult, v);\n//   }\n//   return s;\n// };\n\n/**\n * Mutates `map`, adding each value to it using a\n * function to produce a key. Use {@link addValue} for an immutable version.\n * ```\n * const map = new Map();\n * addValueMutate(map, v=>v.name, { name:`Jane`, size:10 }, { name:`Bob`, size: 9 });\n * // Map consists of entries:\n * // [ `Jane`, { name:`Jane`, size:10 } ],\n * // [ `Bob` { name:`Bob`, size: 9 } ]\n * ```\n * \n * Uses {@link addValueMutator} under the hood.\n * @param map Map to modify. If _undefined_, a new map is created\n * @param hasher Function to generate a string key for a given object value\n * @param values Values to add\n * @param collisionPolicy What to do if the key already exists\n * @returns Map instance\n */\nexport const addValueMutate = <V>(\n  map: Map<string, V> | undefined,\n  hasher: ToString<V>,\n  collisionPolicy: `overwrite` | `skip` | `throw`,\n  ...values: readonly V[]\n) => {\n  const m = map ?? new Map<string, V>();\n  const f = addValueMutator(m, hasher, collisionPolicy);\n  f(...values);\n  return m;\n};\n\n/**\n * Adds values to a map, returning a new, modified copy and leaving the original\n * intact.\n * \n * Use {@link addValueMutate} for a mutable \n * @param map Map to start with, or _undefined_ to automatically create a map \n * @param hasher Function to create keys for values\n * @param collisionPolicy What to do if a key already exists\n * @param values Values to add\n * @returns A new map containing values\n */\nexport const addValue = <V>(\n  map: Map<string, V> | ReadonlyMap<string, V> | undefined,\n  hasher: ToString<V>,\n  collisionPolicy: `overwrite` | `skip` | `throw`,\n  ...values: readonly V[]\n) => {\n  const m = map === undefined ? new Map<string, V>() : new Map<string, V>(map);\n  for (const v of values) {\n    const hashResult = hasher(v);\n    if (collisionPolicy !== `overwrite`) {\n      if (m.has(hashResult)) {\n        if (collisionPolicy === `throw`) throw new Error(`Key '${ hashResult }' already in map`);\n        if (collisionPolicy === `skip`) continue;\n      }\n    }\n    m.set(hashResult, v);\n  }\n  return m;\n};\n\n/**\n * Returns a function that adds values to a map, using a hashing function to produce a key.\n * Use {@link addValueMutate} if you don't need a reusable function.\n * \n * ```js\n * const map = new Map(); // Create map\n * const mutate = addValueMutator(map, v=>v.name); // Create a mutator using default 'overwrite' policy\n * mutate( { name:`Bob`, size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( {name: `Bob`, size: 11 }); // Change the value stored under key `Bob`.\n * map.get(`Bob`); // { name: `Bob`, size: 11 }\n * ```\n * \n * The 'collision policy' determines what to do if the key already exists. The default behaviour\n * is to overwrite the key, just as Map.set would.\n * ```js\n * const map = new Map();\n * const mutate = addValueMutator(map, v=>v.name, `skip`);\n * mutate( { name:`Bob`,size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( { name:`Bob`, size: 20 }); // This value would be skipped because map already contains 'Bob'\n * map.get(`Bob`); // { name: `Bob`, size: 10 }\n * ``` \n *\n * @param map Map to modify\n * @param hasher Hashing function to make a key for a value\n * @param collisionPolicy What to do if a value is already stored under a key\n * @returns Function\n */\nexport const addValueMutator = <V>(\n  map: Map<string, V>,\n  hasher: ToString<V>,\n  collisionPolicy: `overwrite` | `skip` | `throw` = `overwrite`\n) => {\n  return (...values: readonly V[]) => {\n    for (const v of values) {\n      const hashResult = hasher(v);\n      if (collisionPolicy !== `overwrite`) {\n        if (map.has(hashResult)) {\n          if (collisionPolicy === `throw`) throw new Error(`Key '${ hashResult }' already in map`);\n          if (collisionPolicy === `skip`) continue;\n        }\n      }\n      map.set(hashResult, v);\n    }\n    return map;\n  }\n};\n\n\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  comparer?: (a: V, b: V) => number\n) => {\n  const f = comparer ?? defaultComparer;\n  return [ ...map.entries() ].sort((a, b) => f(a[ 1 ], b[ 1 ]));\n};\n\n\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = sortByValueProperty(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = <K, V, Z>(\n  map: ReadonlyMap<K, V>,\n  property: string,\n  compareFunction?: (a: Z, b: Z) => number\n) => {\n  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n  return [ ...map.entries() ].sort((aE, bE) => {\n    const a = aE[ 1 ];\n    const b = bE[ 1 ];\n    return cfn(a[ property ] as Z, b[ property ] as Z);\n  });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  const entries = [ ...map.entries() ];\n  return entries.some((kv) => comparer(kv[ 1 ], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filterValues(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filterValues(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\n\nexport function* filterValues<V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = <V>(map: ReadonlyMap<string, V>): readonly V[] =>\n  [ ...map.values() ];\n\n\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` },\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = fromIterable(data, v => v.fruit);\n * map.get(`granny-smith`); // { fruit: `granny-smith`, family: `apple`, colour: `green` }\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param collisionPolicy By default, values with same key overwrite previous (`overwrite`)\n * @returns\n */\nexport const fromIterable = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>,\n  collisionPolicy: `overwrite` | `skip` | `throw` = `overwrite`\n): ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const key = keyFunction(d);\n    if (m.has(key)) {\n      if (collisionPolicy === `throw`) throw new Error(\n        `Key '${ key }' is already used and new data will overwrite it. `\n      );\n      if (collisionPolicy === `skip`) continue;\n    }\n    m.set(key, d);\n  }\n  return m;\n};\n\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectEntriesMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = <V>(data: object | object[]): ReadonlyMap<string, V> => {\n  const map = new Map<string, V>();\n  if (Array.isArray(data)) {\n    for (const d of data) addObjectEntriesMutate<V>(map, d as object);\n  } else {\n    addObjectEntriesMutate<V>(map, data);\n  }\n  return map;\n};\n\n/**\n * Adds an object to an existing map, mutating it. \n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObjectEntriesMutate(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectEntriesMutate = <V>(map: Map<string, V>, data: object) => {\n  const entries = Object.entries(data);\n  for (const [ key, value ] of entries) {\n    map.set(key, value as V);\n  }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n * To get an entry see {@link findEntryByPredicate}\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = findValue(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const findValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  predicate: (v: V) => boolean\n): V | undefined => [ ...map.values() ].find(v => predicate(v));\n\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link findValue} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map \n * @param predicate \n * @returns \n */\nexport const some = <V>(map: ReadonlyMap<string, V>, predicate: (v: V) => boolean): boolean => [ ...map.values() ].some(v => predicate(v));\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = <T, K>(\n  m: ReadonlyMap<string, T>,\n  valueTransform: (value: T) => K\n): Readonly<Record<string, K>> =>\n  [ ...m ].reduce((object: object, [ key, value ]) => {\n    const t = valueTransform(value);\n    object[ key ] = t;\n    return object;\n  }, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = <V>(\n  keys: readonly string[],\n  values: ArrayLike<V | undefined>\n) => {\n  if (keys.length !== values.length) {\n    throw new Error(`Keys and values arrays should be same length`);\n  }\n  return Object.fromEntries(keys.map((k, index) => [ k, values[ index ] ]));\n};\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = <K, V, R>(\n  source: ReadonlyMap<K, V>,\n  transformer: (value: V, key: K) => R\n) => new Map(Array.from(source, (v) => [ v[ 0 ], transformer(v[ 1 ], v[ 0 ]) ]));\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = <T>(\n  m: ReadonlyMap<string, T>\n): Readonly<Record<string, T>> =>\n  [ ...m ].reduce((object: object, [ key, value ]) => {\n    object[ key ] = value;\n    return object;\n  }, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * const person = { age: 29, name: `John`};\n * map.set(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = <K, V, R>(\n  m: ReadonlyMap<K, V>,\n  transformer: (key: K, item: V) => R\n): readonly R[] => [ ...m.entries() ].map((x) => transformer(x[ 0 ], x[ 1 ]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of `a` merged into `b`.\n * `b` is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also @ixfx/arrays/mergeByKey if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 1 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = <K, V>(\n  reconcile: MergeReconcile<V>,\n  ...maps: readonly ReadonlyMap<K, V>[]\n): ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [ mk, mv ] of m) {\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return result;\n};\n\n\nexport type GetOrGenerate<K, V, Z> = (key: K, args?: Z) => Promise<V>;\n\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync =\n  <K, V, Z>(map: IDictionary<K, V>, fn: (key: K, args?: Z) => V) =>\n    (key: K, args?: Z): V => {\n      let value = map.get(key);\n      if (value !== undefined) return value;\n      value = fn(key, args);\n      map.set(key, value);\n      return value;\n    };\n\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate =\n  <K, V, Z>(\n    map: IDictionary<K, V>,\n    fn: (key: K, args?: Z) => Promise<V> | V\n  ): GetOrGenerate<K, V, Z> =>\n    async (key: K, args?: Z): Promise<V> => {\n      let value = map.get(key);\n      if (value !== undefined) return value; //Promise.resolve(value);\n      value = await fn(key, args);\n      if (value === undefined) throw new Error(`fn returned undefined`);\n      map.set(key, value);\n      return value;\n    };\n\n","import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString, defaultToString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport type { IsEqualContext } from '@ixfx/core';\nimport { compareObjectKeys } from './records/compare.js';\nimport type { Result } from '@ixfx/guards';\n\n/**\n * Data at a particular path\n */\nexport type PathData<V> = {\n  /**\n   * Path\n   */\n  path: string\n  /**\n   * Value\n   */\n  value: V\n}\n/**\n * A change to a value\n */\nexport type PathDataChange<V> = PathData<V> & {\n  /**\n   * Previous value, if any\n   */\n  previous?: V\n  /**\n   * Nature of the change\n   */\n  state: `change` | `added` | `removed`\n}\n\n/**\n * Compare data\n */\nexport type CompareDataOptions<V> = {\n  /**\n   * If _true_, it treats the B value as a partial\n   * version of B. Only the things present in B are compared.\n   * Omissions from B are not treated as removed keys.\n   */\n  asPartial: boolean\n  /**\n   * If _true_ (default), if a value is undefined,\n   * it signals that the key itself is removed.\n   */\n  undefinedValueMeansRemoved: boolean\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n\n  skipInstances: WeakSet<any>\n}\n\n/**\n * Get the entries for `target`.\n * \n * 'deep probe' uses alternative means to get entries of object, since `Object.entries`\n * can fail for some objects.\n * @param target Object to get entries from\n * @param deepProbe If true\n * @returns \n */\nconst getEntries = (target: object, deepProbe: boolean) => {\n  if (target === undefined) throw new Error(`Param 'target' is undefined`);\n  if (target === null) throw new Error(`Param 'target' is null`);\n  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${ typeof target })`);\n  if (deepProbe) {\n    const entries: [ key: string, value: any ][] = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (testPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  //console.log(`compareData a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } opts: ${ options }`)\n  if (typeof a === `undefined`) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (typeof b === `undefined`) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const asPartial = options.asPartial ?? false;\n  const skipInstances = options.skipInstances ?? new WeakSet();\n  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n\n  //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  if (isPrimitive(b)) {\n    yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n\n    const keyOfAInB = key in b;\n    const valueOfKeyInB = b[ key ];\n    //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ defaultToString(valueA) }  valueAType: ${ typeof valueA } entriesCount: ${ entriesA.length }`);\n\n    if (typeof valueA === `object` && valueA !== null) {\n      if (skipInstances.has(valueA as object)) continue; // Already seen\n      skipInstances.add(valueA as object);\n      if (keyOfAInB) {\n        //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueOfKeyInB);\n        if (valueOfKeyInB === undefined) {\n          throw new Error(`Pathed.compareData Value for key ${ key } is undefined`);\n        } else {\n          const sub = [ ...compareData(valueA as V, valueOfKeyInB, {\n            ...options,\n            skipInstances,\n            pathPrefix: pathPrefix + key + `.`\n          }) ];\n          if (sub.length > 0) {\n            for (const s of sub) yield s;\n            if (includeParents) {\n              yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n            }\n          }\n        }\n      } else {\n        if (asPartial) continue;\n        //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n        yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (keyOfAInB) {\n        // B contains key from A\n        if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n          //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ defaultToString(b) } A: ${ defaultToString(a) }`);\n          yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n        } else {\n          if (!eq(valueA, valueOfKeyInB, subPath)) {\n            //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueOfKeyInB } subPath: ${ subPath }`)\n            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n          }\n        }\n      } else {\n        // B does not contain key from A\n        if (asPartial) continue; // Ignore\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: PathDataChange<any>[]): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: string[], value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareObjectKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * \n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // { value: `Thom`  success: true }\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`);      // { value: `green` success: true }\n * ```\n * \n * Returns an error result with more details, eg `{ success: false, error: 'Path could not be found' }`\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object Object to query\n * @param path Path\n * @param separator Separator of chunks of path. Defaults to '.'\n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string, separator = `.`): Result<V, any> => {\n  if (typeof path !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Param string 'path' is empty`);\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (object === null) throw new Error(`Param 'object' is null`);\n\n  const split = path.split(separator);\n  const v = getFieldImpl<V>(object, split, path);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: string[], position: string): Result<V, any> => {\n  if (object === undefined) return { success: false, error: `Param 'object' is undefined. Position: ${ position }` };\n  if (split.length === 0) return { success: false, error: `Path has been exhausted. position: ${ position }` };\n  const start = split.shift();\n  if (!start) return { success: false, error: `Unexpected empty split path. Position: ${ position }` };\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n    if (typeof object[ index ] === `undefined`) {\n      return { success: false, error: `Index '${ index }' does not exist. Length: ${ object.length }. Position: ${ position }` };\n    }\n\n    if (split.length === 0) {\n      return { value: object[ index ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ index ], split, split.join(`.`));\n    }\n  } else if (typeof object === `object` && start in object) {\n    //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n\n    if (split.length === 0) {\n      return { value: object[ start ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ start ], split, split.join(`.`));\n    }\n  } else {\n    return { success: false, error: `Path '${ start }' not found. Position: ${ position }` };\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = recordEntriesDepthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, onlyLeaves = false, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    const value = entries[ 1 ];\n    const leaf = (typeof value !== `object`);\n\n    if (onlyLeaves && leaf || !onlyLeaves) {\n      yield { path: sub, value };\n    }\n    yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n  }\n}","","import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs, type Interval } from '@ixfx/core';\n\nexport type HasCompletionRunStates = `idle` | `scheduled` | `running`;\nexport type HasCompletion = {\n  /**\n   * Gets the current run state\n   * idle: not yet started or completed with no future run scheduled\n   * scheduled: waiting to run\n   * running: currently executing its callback\n   */\n  get runState(): HasCompletionRunStates\n  /**\n   * Returns the number of times the scheduled function\n   * has been executed.\n   * \n   * This number will be reset in some conditions.\n   * For example `continuously` resets it when the loop stops.\n   * \n   * Use {@link startCountTotal} to track total number.\n   */\n  get startCount(): number\n\n  /**\n   * Total number of times scheduled function has been\n   * executed.\n   */\n  get startCountTotal(): number\n};\n\n/**\n * Runs a function continuously, returned by {@link continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, does nothing\n   */\n  start(): void;\n\n  /**\n   * (Re-)starts the loop. If an existing iteration has been\n   * scheduled, this is cancelled and started again.\n   *\n   * This can be useful when adjusting the interval\n   */\n  reset(): void;\n  /**\n   * How many milliseconds since loop was started after being stopped.\n   */\n  get elapsedMs(): number;\n  /**\n   * If disposed, the continuously instance won't be re-startable\n   */\n  get isDisposed(): boolean;\n  /**\n   * Stops loop. It can be restarted using .start()\n   */\n  cancel(): void;\n  /**\n   * Sets the interval speed of loop. Change will take effect on next loop. For it to kick\n   * in earlier, call .reset() after changing the value.\n   */\n  set interval(interval: Interval);\n  /**\n   * Gets the current interval, ie. speed of loop.\n   */\n  get interval(): Interval;\n};\n\nexport type ContinuouslySyncCallback = (\n  /**\n   * Number of times loop\n   * Ticks is reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => boolean | void;\n\nexport type ContinuouslyAsyncCallback = (\n  /**\n   * Number of times loop has run\n   * Reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits.\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => Promise<boolean | void>;\n\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n\n/**\n * Options for {@link continuously}\n */\nexport type ContinuouslyOpts = Readonly<{\n  /**\n   * Abort signal to exit loop\n   */\n  signal: AbortSignal;\n  /**\n   * If _true_, callback runs before waiting period.\n   * @defaultValue false\n   */\n  fireBeforeWait: boolean;\n  /**\n   * Called whenever .start() is invoked.\n   * If this function returns:\n   *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n   *  - `cancel`: loop stops, but can be re-started if .start() is called again\n   *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n   *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n   *\n   */\n  onStartCalled: (\n    /**\n     * Number of times loop has run\n     * Reset when loop is exits.\n     */\n    ticks?: number,\n    /**\n     * Elapsed milliseconds.\n     * Reset when loop is exits.\n     */\n    elapsedMs?: number\n  ) => OnStartCalled;\n}>;\n\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n * \n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n * \n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n * \n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n * \n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport const continuously = (\n  callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback,\n  interval?: Interval,\n  options: Partial<ContinuouslyOpts> = {}\n): Continuously => {\n  let intervalMs = intervalToMs(interval, 0);\n  resultThrow(integerTest(intervalMs, `positive`, `interval`));\n  const fireBeforeWait = options.fireBeforeWait ?? false;\n  const onStartCalled = options.onStartCalled;\n  const signal = options.signal;\n\n  let disposed = false;\n  let runState: HasCompletionRunStates = `idle`;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let startedAt = performance.now();\n  let intervalUsed = interval ?? 0;\n  let cancelled = false;\n  let currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const deschedule = () => {\n    if (currentTimer === undefined) return;\n    globalThis.clearTimeout(currentTimer);\n    currentTimer = undefined;\n    startCount = 0;\n    startedAt = Number.NaN;\n  }\n\n  const schedule = (scheduledCallback: () => void) => {\n    if (intervalMs === 0) {\n      if (typeof requestAnimationFrame === `undefined`) {\n        currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n      } else {\n        currentTimer = undefined;\n        requestAnimationFrame(scheduledCallback);\n      }\n    } else {\n      currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n    }\n  }\n\n  const cancel = () => {\n    if (cancelled) return;\n    cancelled = true;\n\n    if (runState === `idle`) return; // No need to cancel\n    runState = `idle`;\n    deschedule();\n  };\n\n  const loop = async () => {\n    if (signal?.aborted) {\n      runState = `idle`;\n    }\n    if (runState === `idle`) return;\n\n    runState = `running`\n    startCount++;\n    startCountTotal++;\n    const valueOrPromise = callback(startCount, performance.now() - startedAt);\n    const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n    if (cancelled) {\n      return;\n    }\n    runState = `scheduled`;\n\n    // Didn't get a value, exit out\n    if (value !== undefined && !value) {\n      cancel();\n      return;\n    }\n\n    if (cancelled) return; // has been cancelled\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    schedule(loop);\n  };\n\n  const start = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n\n    if (onStartCalled !== undefined) {\n      // A function governs whether to allow .start() to go ahead\n      const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n      switch (doWhat) {\n        case `cancel`: {\n          cancel();\n          return;\n        }\n        case `reset`: {\n          reset();\n          return;\n        }\n        case `dispose`: {\n          disposed = true;\n          cancel();\n          return;\n        }\n        // No default\n      }\n    }\n\n    if (runState === `idle`) {\n      // Start running\n      startCount = 0;\n      startedAt = performance.now();\n      runState = `scheduled`;\n      if (fireBeforeWait) {\n        void loop(); // Exec first, then wait\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop); // Wait first, then exec\n      }\n    } // else: already running, ignore\n  };\n\n  const reset = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n    startCount = 0;\n    startedAt = Number.NaN;\n\n    // Cancel scheduled iteration\n    if (runState !== `idle`) {\n      cancel();\n    }\n    start();\n  };\n\n  return {\n    start,\n    reset,\n    cancel,\n    get interval() {\n      return intervalUsed;\n    },\n    get runState() {\n      return runState;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    },\n    get startCount() {\n      return startCount;\n    },\n    set interval(interval: Interval) {\n      const ms = intervalToMs(interval, 0);\n      resultThrow(integerTest(ms, `positive`, `interval`));\n      intervalMs = ms;\n      intervalUsed = interval;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n  };\n};\n","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFunction Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\nexport const align = <V>(\n  similarityFunction: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  options: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = options.matchThreshold ?? 0;\n  const debug = options.debug ?? false;\n  const results = new Map<string, DataWithId<V>>();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map<string, DataWithId<V>>();\n  lastData?.forEach((d, index) => {\n    if (typeof d === `undefined`) {\n      throw new Error(`'lastData' contains undefined (index: ${ index.toString() })`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  for (const newD of newData) { //let index = 0; index < newData.length; index++) {\n    //const newD = newData[ index ];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${ newD.id }`);\n\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: (last).id,\n      score: (last as unknown) === null ? -1 : similarityFunction(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${ newD.id }`);\n      }\n      newThings.push(newD);\n      continue;\n    }\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[ 0 ];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${ top.score.toString() } id: ${ newD.id }`\n        );\n      }\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${ newD.id } -> ${ top.id } (score: ${ top.score.toString() })`\n      );\n    }\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    lastMap.delete(top.id);\n  }\n\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, options: AlignOpts = {}) => {\n  let lastData: readonly DataWithId<V>[] = [];\n\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, options);\n    return [ ...lastData ];\n  };\n  return compute;\n};\n","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since the initial call.\n * \n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns the interval between the start and each subsequent call.\n * \n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n * \n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns \n */\nexport const elapsedInterval = (): Since => {\n  let start = performance.now();\n  return (): number => {\n    const now = performance.now();\n    const x = now - start;\n    start = now;\n    return x;\n  }\n}\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n * \n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = (): Since => {\n  const start = Date.now();\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n","\n/**\n * Returns `v` if `predicate` returns _true_,\n * alternatively returning `skipValue`.\n * \n * ```js\n * // Return true if value is less than 10\n * const p = v => v < 10;\n * \n * filterValue(5, p, 0);   // 5\n * filterValue(20, p, 0);  // 0\n * ```\n * @param v Value to test\n * @param predicate Predicate\n * @param skipValue Value to return if predicate returns false\n * @returns Input value if predicate is _true_, or `skipValue` if not.\n */\nexport const filterValue = <V>(v: V, predicate: (v: V) => boolean, skipValue: V | undefined): V | undefined => {\n  if (predicate(v)) return v;\n  return skipValue;\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n\n\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n * \n * If `source` is under `maxLength` the original is returned.\n * @param source \n * @param maxLength Maximum length. Defaults to 20\n * @returns \n */\nexport const abbreviate = (source: string, maxLength = 15) => {\n  resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n\n  if (source.length > maxLength && source.length > 3) {\n    if (maxLength > 15) {\n      const chunk = Math.round((maxLength - 2) / 2);\n      return source.slice(0, chunk) + `...` + source.slice(-chunk);\n    }\n    return source.slice(0, maxLength) + `...`;\n  }\n  return source;\n}\n\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns \n */\nexport const toStringAbbreviate = (source: any, maxLength = 20) => {\n  if (source === undefined) return `(undefined)`;\n  if (source === null) return `(null)`;\n  return abbreviate(JSON.stringify(source), maxLength);\n}\n\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): string | undefined => {\n  // ✔ Unit tested\n\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (typeof end === `undefined`) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return;\n\n  return source.slice(startPos + 1, endPos);\n};\n\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): [ source: string, between: string | undefined ] => {\n  // ✔ Unit tested\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);\n  if (end !== undefined && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return [ source, undefined ];\n\n  if (typeof end === `undefined`) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return [ source, undefined ];\n\n  const between = source.slice(startPos + 1, endPos);\n  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n  return [ sourceResult, between ];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (\n  source: string,\n  code: number,\n  start = 0,\n  end = source.length - 1\n): number => {\n  for (let index = start; index <= end; index++) {\n    if (source.codePointAt(index) === code) return index;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (\n  source: string,\n  removeStart: number,\n  removeLength: number\n) =>\n  source.slice(0, removeStart) +\n  source.slice(removeStart + removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (\n  source: string | null,\n  length: number\n): readonly string[] => {\n  resultThrow(integerTest(length, `aboveZero`, `length`));\n  if (source === null) throw new Error(`source parameter null`);\n  if (typeof source !== `string`) {\n    throw new TypeError(`source parameter not a string`);\n  }\n\n  // ✔ Unit tested\n  const chunks = Math.ceil(source.length / length);\n  const returnValue: string[] = [];\n  let start = 0;\n\n  for (let c = 0; c < chunks; c++) {\n    returnValue.push(source.slice(start, start + length));\n    start += length;\n  }\n  return returnValue;\n};\n\n\n\n/**\n * Returns the `source` string up until (and excluding) `match`. \n * \n * By default, if match is not found, all of `source` is returned.\n *\n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * \n * If match is not found, fallback can be returned instead:\n * ```js\n * // Yields 'lemon'\n * untilMatch(`apple orange mellon`, `kiwi`, { fallback: `lemon` });\n * ```\n * \n * Or an exception thrown\n * ```js\n * // Throws\n * untilMatch(`apple orange mellon`, `kiwi`, { ifNoMatch: `throw` });\n * ```\n * @param source\n * @param match\n * @param startPos If provided, gives the starting offset. Default 0\n */\n// export const untilMatch = (\n//   source: string,\n//   match: string,\n//   options: Partial<UntilMatchOptions> = {}\n// ): string => {\n//   //  ✔️ Unit tested\n//   let fallback = options.fallback;\n//   const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n//   if (ifNoMatch === `original`) fallback = source;\n//   if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) {\n//     if (ifNoMatch === `throw`) throw new Error(`Match string not found in source`);\n//     // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n//     return fallback!;\n//   }\n//   return source.slice(startPos ?? 0, m);\n// };\n\n\n// export type UntilMatchOptions = MatchOptions & {\n//   ifNoMatch: `throw` | `original` | `fallback`,\n//   fallback?: string\n// }\n\nexport type MatchOptions = {\n  startPos: number;\n  fromEnd: boolean;\n  ifNoMatch: `throw` | `original` | `fallback`,\n  fallback: string\n}\n\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 0 ];\n}\n\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 1 ];\n}\n\n/**\n * Returns the text that is before and after `match`.\n * \n * See also: {@link beforeMatch}, {@link afterMatch}.\n * \n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source \n * @param match \n * @param options \n * @returns \n */\nexport const beforeAfterMatch = (source: string, match: string, options: Partial<MatchOptions> = {}): [ before: string, after: string ] => {\n  if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n  let fallback = options.fallback;\n  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n  if (ifNoMatch === `original`) fallback = source;\n  if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0 && ifNoMatch === `throw`) throw new Error(`Match '${ match }' not found in source.`);\n  if (m < 0 && ifNoMatch === `original`) return [ source, source ];\n  if (m < 0 && ifNoMatch === `fallback`) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [ fallback!, fallback! ];\n  }\n  return [\n    source.slice(0, m),\n    source.slice(Math.max(0, m + match.length))\n  ]\n}\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (\n  source: string,\n  ...wrappers: readonly string[]\n): string => {\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.slice(w.length, source.length - w.length * 2 + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string;\n  /**\n   * Start position, with respect to source text\n   */\n  readonly start: number;\n  /**\n   * End position, with respect to source text\n   */\n  readonly end: number;\n  /**\n   * Index of range. First range is 0\n   */\n  readonly index: number;\n}\n\nexport type LineSpan = {\n  readonly start: number;\n  readonly end: number;\n  readonly length: number;\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (\n  ranges: readonly Range[],\n  start: number,\n  end: number\n): LineSpan => {\n  let s = -1;\n  let endPos = -1;\n  for (const [ index, r ] of ranges.entries()) {\n    s = index;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  for (let index = s; index < ranges.length; index++) {\n    const r = ranges[ index ];\n    endPos = index;\n    if (end === r.end) {\n      endPos = index + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return { length: endPos - s, start: s, end: endPos };\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (\n  source: string,\n  split: string\n): readonly Range[] => {\n  let start = 0;\n  let text = ``;\n  const ranges: Range[] = [];\n  let index = 0;\n  for (let index_ = 0; index_ < source.length; index_++) {\n    if (source.indexOf(split, index_) === index_) {\n      const end = index_;\n      ranges.push({\n        text,\n        start,\n        end,\n        index,\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(index_);\n    }\n  }\n  if (start < source.length) {\n    ranges.push({ text, start, index, end: source.length });\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (\n  source: string,\n  ...chars: readonly string[]\n): number => {\n  let counted = 0;\n  for (let index = 0; index < source.length; index++) {\n    if (chars.includes(source.charAt(index))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (\n  source: string,\n  start: string,\n  end: string = start\n): boolean => source.startsWith(start) && source.endsWith(end);\n\n\nexport const htmlEntities = (source: string): string =>\n  source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${ index.codePointAt(0) };`);\n\n\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern \n * @returns \n */\nexport const wildcard = (pattern: string) => {\n  // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n  // for this solution to work on any string, no matter what characters it has\n  const escapeRegex = (value: string) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n\n  // \".\"  => Find a single character, except newline or line terminator\n  // \".*\" => Matches any string that contains zero or more characters\n  pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n\n  // \"^\"  => Matches any string with the following at the beginning of it\n  // \"$\"  => Matches any string with that in front at the end of it\n  pattern = `^` + pattern + `$`\n\n  // Create a regular expression object for matching string\n  const regex = new RegExp(pattern);\n\n  return (value: string) => {\n    // Returns true if it finds a match, otherwse it returns false\n    return regex.test(value);\n  }\n}","import { toStringAbbreviate } from \"./text.js\";\nimport type { IsEqual } from \"./is-equal.js\";\n\n\n/**\n * Wraps the `eq` function, tracing the input data result\n * ```js\n * // Init trace\n * const traceEq = isEqualTrace(isEqualValueDefault); \n * // Use it in some function that takes IsEqual<T>\n * compare(a, b, eq);\n * ```\n * @param eq \n * @returns \n */\nexport const isEqualTrace = <T>(eq: IsEqual<T>): IsEqual<T> => {\n  return (a, b) => {\n    const result = eq(a, b);\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    console.log(`isEqualTrace eq: ${ result } a: ${ toStringAbbreviate(a) } b: ${ toStringAbbreviate(b) }`);\n    return result;\n  }\n}","/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n * \n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n * \n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value \n * @returns \n */\nexport const isInteger = (value: string | number) => {\n  if (value === undefined) return false;\n  if (typeof value === `string`) {\n    const v = Number.parseInt(value);\n    if (Number.isNaN(v)) return false;\n    if (v.toString() === value.toString()) return true;\n    return false;\n  }\n  if (typeof value === `number`) {\n    if (Number.isNaN(value)) return false;\n    if (!Number.isFinite(value)) return false;\n    if (Math.round(value) === value) return true;\n    return false;\n  }\n  return false;\n}","import { isEqualDefault } from \"./is-equal.js\";\n\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common and those unique in `a` or `b`.\n * Ignores ordering of values, and is NOT recursive.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValuesShallow(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n * \n * By default uses === semantics for comparison.\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareIterableValuesShallow = <V>(\n  a: Iterable<V>,\n  b: Iterable<V>,\n  eq = isEqualDefault<V>\n) => {\n  const shared:V[] = [];\n  const aUnique:V[] = [];\n  const bUnique:V[] = [];\n\n  for (const elementOfA of a) {\n    let seenInB = false;\n    // Does B contain this thing from A?\n    for (const elementOfB of b) {\n      if (eq(elementOfA, elementOfB)) {\n        seenInB = true;\n        break;\n      }\n    }\n\n    if (seenInB) {\n      // Common in A & B\n      shared.push(elementOfA);\n    } else {\n      // No, it's only found in A\n      aUnique.push(elementOfA);\n    }\n  }\n\n  for (const elementOfB of b) {\n    let seenInA = false;\n    // Does A contain this thing from B?\n    for (const elementOfA of a) {\n      if (eq(elementOfB, elementOfA)) {\n        seenInA = true;\n      }\n    }\n    if (!seenInA) {\n      // No, something unique to B\n      bUnique.push(elementOfB);\n    }\n  }\n\n  // Are the two iterables the same?\n  const isSame = aUnique.length === 0 && bUnique.length === 0;\n\n  return {\n    shared,\n    isSame,\n    a: aUnique,\n    b: bUnique\n  };\n};\n","\nimport type { KeyValue } from './types.js'\n//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\n\nimport { defaultComparer } from './comparers.js';\n\n// const byKey = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 0 ])\n// );\n\n// export const byValueString = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as string)\n// );\n\n// const byValueNumber = (reverse = false) => pipe(\n//   reverse ? reverseOrd(N.Ord) : N.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as number)\n// );\n\n// export const sortByKey = (reverse = false) => sort<KeyValue>(byKey(reverse));\n// export const sortByValueString = (reverse = false) => sort<KeyValue>(byValueString(reverse));\n// export const sortByValueNumber = (reverse = false) => sort<KeyValue>(byValueNumber(reverse));\n\nexport type KeyValueSorter = (data: KeyValue[]) => KeyValue[];\n\nconst sorterByValueIndex = (index: number, reverse = false) => {\n  return (values: KeyValue[]) => {\n    const s = values.toSorted((a, b) => {\n      return defaultComparer(a[ index ], b[ index ]);\n    });\n    if (reverse) return s.reverse();\n    return s;\n  }\n}\n\nexport type KeyValueSortSyles = `value` | `value-reverse` | `key` | `key-reverse`;\nexport const keyValueSorter = (sortStyle: KeyValueSortSyles): KeyValueSorter => {\n  switch (sortStyle) {\n    case `value`: {\n      return sorterByValueIndex(1, false);\n    }\n    case `value-reverse`: {\n      return sorterByValueIndex(1, true);\n    }\n    case `key`: {\n      return sorterByValueIndex(0, false);\n    }\n    case `key-reverse`: {\n      return sorterByValueIndex(0, true);\n    }\n    default: {\n      throw new Error(`Unknown sorting value '${ (sortStyle as string) }'. Expecting: value, value-reverse, key or key-reverse`);\n    }\n  }\n};\n\n\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };","import { integerTest, resultThrow } from \"@ixfx/guards\";\n\nexport function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number | boolean, roundUp?: boolean) {\n  resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n\n  const up = (typeof b === `boolean`) ? b : (roundUp ?? false)\n  let rounder;\n  if (a === 0) {\n    rounder = Math.round;\n  } else {\n    const p = Math.pow(10, a);\n    if (up) {\n      rounder = (v: number) => Math.ceil(v * p) / p;\n    } else {\n      rounder = (v: number) => Math.floor(v * p) / p;\n    }\n  }\n  if (typeof b === `number`) return rounder(b);\n  return rounder;\n}\n\n","import { numberTest } from '@ixfx/guards';\nimport { round } from './util/round.js';\nimport type { Interval } from './types.js';\n\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n\n\n/**\n * Return the millisecond value of an Interval.\n * \n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber?: number\n): number {\n  if (isInterval(interval)) {\n    // Number given, must be millis?\n    if (typeof interval === `number`) return interval;\n\n    let ms = interval.millis ?? 0;\n    ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n    ms += (interval.mins ?? 0) * 60 * 1000;\n    ms += (interval.secs ?? 0) * 1000;\n    return ms;\n  } else {\n    if (typeof defaultNumber !== `undefined`) return defaultNumber;\n    throw new Error(`Not a valid interval: ${ JSON.stringify(interval) }`);\n  }\n}\n\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval \n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval: number | Interval | undefined): interval is Interval {\n  if (typeof interval === `undefined`) return false;\n  if (interval === null) return false;\n  if (typeof interval === `number`) {\n    if (Number.isNaN(interval)) return false;\n    if (!Number.isFinite(interval)) return false;\n    return true;\n  }\n  if (typeof interval !== `object`) return false;\n  const hasMillis = `millis` in interval;\n  const hasSecs = `secs` in interval;\n  const hasMins = `mins` in interval;\n  const hasHours = `hours` in interval;\n  if (hasMillis && !numberTest(interval.millis).success) return false;\n  if (hasSecs && !numberTest(interval.secs).success) return false;\n  if (hasMins && !numberTest(interval.mins).success) return false;\n  if (hasHours && !numberTest(interval.hours).success) return false;\n  if (hasMillis || hasSecs || hasHours || hasMins) return true;\n  return false;\n}\n\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n * \n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns \n */\nexport const elapsedToHumanString = (millisOrFunction: number | (() => number) | Interval, rounding = 2): string => {\n  let interval: number | undefined = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return elapsedToHumanString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};","import { toStringDefault, type ToString } from \"@ixfx/core\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link uniqueInstances}\n * \n * ```js\n * const t = unique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = unique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * \n * Return function throws an error if `value` is null or undefined.\n * @returns \n */\nexport const unique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}\n\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link unique} to track by value.\n */\nexport const uniqueInstances = <T>(): TrackUnique<T> => {\n\n  const set = new Set<T>();\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    if (set.has(value)) return false;\n    set.add(value);\n    return true;\n  }\n}","/**\n * Returns _true_ if it seems like the code is running on iOS (iPad/iPhone)\n * @returns \n */\nexport const runningiOS = () =>\n  [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n  ].includes(navigator.platform) ||\n  // iPad on iOS 13 detection\n  (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);","export const promiseFromEvent = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      if (Array.isArray(args) && args.length === 1) resolve(args[ 0 ]);\n      else resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};","import type { Reactive, ReactiveInitial } from \"./types-reactive.js\";\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns _true_ if `rx` has a last value\n * \n * Judged seeing if `.last()` exists on `rx`.\n * @param rx Reactive\n * @returns \n */\nexport const hasLast = <V>(rx: object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}","//import { hasLast, isReactive } from \"@ixfx/rx\";\n//import type { ReactiveNonInitial } from \"@ixfx/rx\";\nimport type { BasicType } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport type { ReactiveNonInitial } from \"./types-reactive.js\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n\n\n/**\n * Something that can resolve to a value\n */\nexport type ResolveToValueSync<V> = BasicType | ReactiveNonInitial<V> | Generator<V> | IterableIterator<V> | ((args: any) => V)\nexport type ResolveToValueAsync<V> = AsyncGenerator<V> | AsyncIterableIterator<V> | Promise<V> | ((args: any) => Promise<V>);\nexport type ResolveToValue<V> = ResolveToValueAsync<V> | ResolveToValueSync<V>;\n\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n * \n * To resolve an object's properties, use {@link resolveFields}.\n * \n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r \n * @param args \n * @returns \n */\nexport async function resolve<V extends BasicType>(r: ResolveToValue<V>, ...args: any): Promise<V> {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        const v = await r.next();\n        //console.log(`  hasDone: ${ `done` in v } value:`, v);\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last()!;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    const v = await r(args) as V;\n    return v;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * For a given input `r`, attempts to 'resolve' it. See {@link resolve} for details.\n * @param r \n * @param args \n * @returns \n */\nexport function resolveSync<V extends BasicType>(r: ResolveToValueSync<V>, ...args: any): V {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        throw new Error(`resolveSync cannot work with an async generator`);\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last()!;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    return r(args);\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_ \n * or NaN, `fallbackValue` is returned instead.\n * \n * `null` is an allowed return value.\n * \n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args \n * @returns \n */\nexport async function resolveWithFallback<T extends BasicType>(p: ResolveToValue<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = await resolve(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport function resolveWithFallbackSync<T extends BasicType>(p: ResolveToValueSync<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = resolveSync(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport type ResolveFallbackOpts<T> = { value: T, overrideWithLast?: boolean }","export const zip = (\n  ...arrays: any[][] | readonly any[][] | readonly (readonly any[])[]\n): any[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => (a as any[]).length);\n\n  const returnValue: any[] = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","import { resolve, resolveSync, type ReactiveNonInitial, type ResolveToValue } from \"@ixfx/core\";\nimport { zip } from \"./util/zip.js\";\n// import { zip } from \"./arrays/Zip.js\";\n\n/**\n * An object that can be 'resolved'.\n * @see {@link resolveFields}\n */\nexport type ResolvedObject<T extends Record<string, ResolveToValue<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number :\n    T[ K ] extends string ? string :\n    T[ K ] extends boolean ? boolean :\n    T[ K ] extends bigint ? bigint :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends ReactiveNonInitial<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends (infer V)[] ? V : // array needed?\n    T[ K ] extends object ? T[ K ] : never\n  };\n\n\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n * \n * Use {@link resolveFieldsSync} for a synchronous version.\n * \n * Not recursive.\n * \n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n * \n * It also works with generators. Probably best with those that are infinite.\n * \n * ```js\n * import { count } from './numbers.js';\n * \n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object \n * @returns \n */\nexport async function resolveFields<T extends Record<string, ResolveToValue<any>>>(object: T): Promise<ResolvedObject<T>> {\n  const resolvers: any[] = [];\n  const keys: string[] = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    resolvers.push(resolve(resolvable));\n    keys.push(entry[ 0 ]);\n  }\n  const results = await Promise.all(resolvers);\n  const entries = zip(keys, results);\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\n/**\n * 'Resolves' all the fields of `object` in a synchronous manner.\n * Uses {@link resolveSync} under-the-hood\n * @param object \n * @returns \n */\nexport function resolveFieldsSync<T extends Record<string, ResolveToValue<any>>>(object: T): ResolvedObject<T> {\n  const entries: [ key: string, value: any ][] = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    const value = resolveSync(resolvable);\n    entries.push([ entry[ 0 ], value ]);\n  }\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\n\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nimport type { Interval } from './types.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n\n  if (typeof window === `undefined`) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * `Flow.delay()` and {@link sleep} are similar. `Flow.delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  resultThrow(numberTest(timeoutMs, `positive`, `timeoutMs`));\n\n\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        clearTimeout(t);\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      const t = setTimeout(() => {\n        signal?.removeEventListener(`abort`, onAbortSignal);\n        if (signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate \n * @param checkInterval \n */\nexport const sleepWhile = async (predicate: () => boolean, checkInterval: Interval = 100) => {\n  while (predicate()) {\n    await sleep(checkInterval);\n  }\n}"],"mappings":"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"}