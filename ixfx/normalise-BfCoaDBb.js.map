{"version":3,"file":"normalise-BfCoaDBb.js","names":["rect: RectPositioned | Rect","origin?: Point","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a: Point | Point3d","xOrB?: Point | Point3d | number","y?: number","z?: number","a: Point","b: Point","lines:Line[]","a: Point","b?: Point","c?: Point","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","pt: Point","length","ptOrX: Point | number","y?: number"],"sources":["../../packages/geometry/src/rect/corners.ts","../../packages/geometry/src/point/sum.ts","../../packages/geometry/src/point/distance.ts","../../packages/geometry/src/line/from-points.ts","../../packages/geometry/src/line/join-points-to-lines.ts","../../packages/geometry/src/point/angle.ts","../../packages/geometry/src/point/divider.ts","../../packages/geometry/src/point/magnitude.ts","../../packages/geometry/src/point/normalise.ts"],"sourcesContent":["import { type Point } from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from './point-type.js';\nimport { getPointParameter } from \"./get-point-parameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines:Line[] = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","\nimport { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  const pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | number[], b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | number[],\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};"],"mappings":"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"}