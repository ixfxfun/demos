import{n as e}from"./chunk-CVLEGGlw.js";import{Ct as t,I as n}from"./src-DdJCbM4z.js";import{r}from"./equality-Cw3R326F.js";import{a as i,c as a,i as o,n as s,o as c,r as l,s as u,t as d}from"./StackMutable-CC_MLivw.js";var f=class e{opts;data;constructor(e={},t=[]){this.opts=e,this.data=t}push(...t){return new e(this.opts,u(this.opts,this.data,...t))}pop(){return new e(this.opts,c(this.opts,this.data))}forEach(e){this.data.forEach(e)}forEachFromTop(e){[...this.data].reverse().forEach(e)}get isEmpty(){return l(this.opts,this.data)}get isFull(){return o(this.opts,this.data)}get peek(){return i(this.opts,this.data)}get length(){return this.data.length}};const p=(e={},...t)=>new f({...e},[...t]);var m=e({StackImmutable:()=>f,StackMutable:()=>d,immutable:()=>p,isEmpty:()=>l,isFull:()=>o,mutable:()=>s,peek:()=>i,pop:()=>c,push:()=>u,trimStack:()=>a});const h=(e,t)=>{for(let n of e.entries()){let e=n[1];for(let r of e)if(t(r,n[0]))return n}},g=e=>{if(typeof e!=`object`)throw TypeError(`Param 'map' is not an object. Got: ${typeof e}`);if(!(`entries`in e))throw TypeError(`Param 'map' does not have 'entries' function`);let t,n=-(2**53-1);for(let r of e.entries()){let e=r[1];if(typeof e!=`object`)throw TypeError(`All items in map are expected to be an object type. Got: ${typeof e}`);if(!(`length`in e))throw TypeError(`All items in map must have a 'length' field`);e.length>n&&(t=r)}return t},_=(e,n,r=t)=>{if(typeof e!=`object`)throw TypeError(`Param 'map' is expected to be an object. Got: ${typeof e}`);if(!(`entries`in e))throw TypeError(`Param 'map' is expected to have 'entries()'`);for(let t of e.entries()){let e=t[1];for(let i of e)if(r(i,n))return t}},v=e=>{let t=[...e.entries()].map(e=>[e[0],[...e[1]]]);return new Map(t)},y=(e,n,i=t)=>{let a=[...e.entries()],o=[...n.entries()];if(a.length!==o.length)return!1;for(let e of a){let t=o.find(t=>t[0]===e[0]);if(!t||!r(Array.from(e[1]),Array.from(t[1]),i))return!1}return!0};var b=class{map;groupBy;valueEq;constructor(e=n,r=t,i=[]){this.groupBy=e,this.valueEq=r,Array.isArray(i)?this.map=new Map(i):this.map=new Map(i.entries())}get getRawMapUnsafe(){return this.map}has(e){return this.map.has(e)}hasKeyValue(e,t){let n=this.map.get(e);if(!n)return!1;for(let e of n)if(this.valueEq(e,t))return!0;return!1}debugString(){let e=``;return[...this.map.keys()].every(t=>{let n=this.map.get(t);n!==void 0&&(e+=t+` (${n.length}) = ${JSON.stringify(n)}\r\n`)}),e}count(e){let t=this.map.get(e);return t?t.length:0}firstKeyByValue(e,n=t){let r=_(this,e,n);if(r)return r[0]}*entriesFlat(){for(let e of this.map.entries())for(let t of e[1])yield[e[0],t]}*entries(){for(let[e,t]of this.map.entries())yield[e,[...t]]}*valuesFor(e){let t=this.map.get(e);t&&(yield*t.values())}*keys(){yield*this.map.keys()}*valuesFlat(){for(let e of this.map)yield*e[1]}getRawArray(e){let t=this.map.get(e);if(t)return t}*values(){for(let e of this.map)yield e[1]}*keysAndCounts(){for(let e of this.map)yield[e[0],e[1].length]}get lengthKeys(){return this.map.size}get isEmpty(){return this.map.size===0}},x=class extends b{addKeyedValues(e,...t){let n=this.map.get(e);n===void 0?this.map.set(e,t):this.map.set(e,[...n,...t])}setValues(e,t){this.map.set(e,t)}addValue(...e){for(let t of e){let e=this.groupBy(t);this.addKeyedValues(e,t)}}deleteKeyValue(e,t){let n=this.map.get(e);if(n===void 0)return!1;let r=n.filter(e=>!this.valueEq(e,t));return this.map.set(e,r),r.length<n.length}deleteByValue(e){let t=!1,n=[...this.map.entries()];for(let r of n)for(let n of r[1])this.valueEq(n,e)&&(t=!0,this.deleteKeyValue(r[0],e));return t}delete(e){let t=this.map.get(e);return!t||t.length===0?!1:(this.map.delete(e),!0)}clear(){this.map.clear()}};const S=(e=n,r=t)=>new x(e,r);export{y as a,g as c,v as i,m as l,S as n,h as o,b as r,_ as s,x as t,f as u};