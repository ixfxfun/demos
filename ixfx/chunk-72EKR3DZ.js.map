{"version":3,"sources":["../src/Events.ts","../src/DefaultKeyer.ts","../src/collections/map/MapMultiFns.ts","../src/collections/map/MapOfSimpleBase.ts","../src/collections/map/MapOfSimpleMutable.ts","../src/flow/IntervalType.ts"],"sourcesContent":["\nimport type { ISimpleEventEmitter, Listener } from './ISimpleEventEmitter.js';\nimport { ofSimpleMutable } from './collections/map/MapOfSimpleMutable.js';\nimport { intervalToMs, type Interval } from './flow/IntervalType.js';\n\n/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n * \n * By default waits a maximum of 1 minute.\n * \n * Automatically unsubscribes on success or failure (ie. timeout)\n * \n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns \n */\nexport const eventRace = (target: EventTarget, eventNames: Array<string>, options: Partial<{ timeout: Interval, signal: AbortSignal }> = {}) => {\n  const intervalMs = intervalToMs(options.timeout, 60 * 1000);\n  const signal = options.signal;\n  let triggered = false;\n  let disposed = false;\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n\n  const promise = new Promise<Event>((resolve, reject) => {\n    const onEvent = (event: Event) => {\n      if (`type` in event) {\n        if (eventNames.includes(event.type)) {\n          triggered = true;\n          resolve(event);\n          dispose();\n        } else {\n          console.warn(`eventRace: Got event '${ event.type }' that is not in race list`);\n        }\n      } else {\n        console.warn(`eventRace: Event data does not have expected 'type' field`);\n        console.log(event);\n      }\n    }\n\n    for (const name of eventNames) {\n      target.addEventListener(name, onEvent);\n    }\n\n    const dispose = () => {\n      if (disposed) return;\n      if (timeout !== undefined) clearTimeout(timeout);\n      timeout = undefined;\n      disposed = true;\n      for (const name of eventNames) {\n        target.removeEventListener(name, onEvent);\n      }\n    }\n\n    timeout = setTimeout(() => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`eventRace: Events not fired within interval. Events: ${ JSON.stringify(eventNames) } Interval: ${ intervalMs }`));\n    }, intervalMs);\n\n\n    signal?.addEventListener(`abort`, () => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`Abort signal received ${ signal.reason }`));\n    });\n  });\n  return promise;\n}\n\n\nexport class SimpleEventEmitter<Events> implements ISimpleEventEmitter<Events> {\n  readonly #listeners = ofSimpleMutable<Listener<Events>>();\n  #disposed = false;\n\n  dispose() {\n    if (this.#disposed) return;\n    this.clearEventListeners();\n  }\n\n  get isDisposed() {\n    return this.#disposed;\n  }\n\n  /**\n   * Fire event\n   * @param type Type of event\n   * @param args Arguments for event\n   * @returns\n   */\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[ K ]) {\n    if (this.#disposed) throw new Error(`Disposed`);\n    const listeners = this.#listeners.get(type as string);\n    //console.log(`Firing ${type as string}`);\n    for (const l of listeners) {\n      l(args, this);\n    }\n  }\n\n  /**\n   * Adds event listener.\n   * \n   * @throws Error if emitter is disposed\n   * @typeParam K - Events\n   * @param name Event name\n   * @param listener Event handler\n   */\n  addEventListener<K extends keyof Events>(\n    name: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ): void {\n    if (this.#disposed) throw new Error(`Disposed`);\n    this.#listeners.addKeyedValues(\n      name as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Remove event listener\n   *\n   * @param listener\n   */\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ) {\n    if (this.#disposed) return;\n\n    // listener: Listener<Events>): void {\n    this.#listeners.deleteKeyValue(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Clear all event listeners\n   * @private\n   */\n  clearEventListeners() {\n    if (this.#disposed) return;\n    this.#listeners.clear();\n  }\n}\n\n// type TestEventMap = {\n//   readonly change: TestEvent\n//   readonly other: TestEvent2;\n// }\n\n// interface TestEvent2 {\n//   readonly something: string;\n// }\n// interface TestEvent {\n//   readonly blah: boolean;\n// }\n\n// class TestEmitter extends SimpleEventEmitter<TestEventMap> {\n//   constructor() {\n//     super();\n//     this.addEventListener(`change`, (e) => {\n//       e.blah;\n//     });\n//   }\n// }\n\n/*\nexport class Event {\n  public target: any;\n  public type: string;\n  constructor(type: string, target: any) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\nexport class ErrorEvent extends Event {\n  public message: string;\n  public error: Error;\n  constructor(error: Error, target: any) {\n    super('error', target);\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\nexport class CloseEvent extends Event {\n  public code: number;\n  public reason: string;\n  public wasClean = true;\n  constructor(code = 1000, reason = '', target: any) {\n    super('close', target);\n    this.code = code;\n    this.reason = reason;\n  }\n}\nexport interface WebSocketEventMap {\n  close: CloseEvent;\n  error: ErrorEvent;\n  message: MessageEvent;\n  open: Event;\n}\n\nexport interface WebSocketEventListenerMap {\n  close: (event: CloseEvent) => void | {handleEvent: (event: CloseEvent) => void};\n  error: (event: ErrorEvent) => void | {handleEvent: (event: ErrorEvent) => void};\n  message: (event: MessageEvent) => void | {handleEvent: (event: MessageEvent) => void};\n  open: (event: Event) => void | {handleEvent: (event: Event) => void};\n}\n*/\n\nexport { type ISimpleEventEmitter, type Listener } from './ISimpleEventEmitter.js';","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};","// âœ” UNIT TESTED\n\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport type { IMapOf } from './IMapOf.js';\nimport type { IWithEntries } from '../../data/maps/IMappish.js';\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (predicate(subValue, e[ 0 ])) return e;\n    }\n  }\n};\n\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = <V>(map: IMapOf<V>): number => {\n  //eslint-disable-next-line functional/no-let\n  let largest: readonly [ string, number ] = [ '', 0 ];\n  for (const e of map.keysAndCounts()) {\n    if (e[ 1 ] > largest[ 1 ]) {\n      largest = e;\n    }\n  }\n  return largest[ 1 ];\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = <K, V>(\n  map: IWithEntries<K, Iterable<V>>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: Iterable<V> ] | undefined => {\n  for (const e of map.entries()) {\n    const val = e[ 1 ];\n    for (const subValue of val) {\n      if (isEqual(subValue, value)) return e;\n    }\n  }\n};\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport { firstEntryByValue } from './MapMultiFns.js';\n\nexport class MapOfSimpleBase<V> {\n  protected map: Map<string, ReadonlyArray<V>>;\n  protected readonly groupBy;\n  protected valueEq;\n\n  /**\n   * Constructor\n   * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n   * @param valueEq Compare values. By default uses JS logic for equality\n   */\n  constructor(\n    groupBy: (value: V) => string = defaultKeyer,\n    valueEq: IsEqual<V> = isEqualDefault<V>,\n    initial: Array<[ string, ReadonlyArray<V> ]> = []\n  ) {\n    this.groupBy = groupBy;\n    this.valueEq = valueEq;\n    this.map = new Map(initial);\n  }\n\n  /**\n   * Returns _true_ if `key` exists\n   * @param key\n   * @returns\n   */\n  has(key: string): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Returns _true_ if `value` exists under `key`.\n   * @param key Key\n   * @param value Value to seek under `key`\n   * @returns _True_ if `value` exists under `key`.\n   */\n  hasKeyValue(key: string, value: V): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    for (const v of values) {\n      if (this.valueEq(v, value)) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Debug dump of contents\n   * @returns\n   */\n  debugString(): string {\n    let r = ``;\n    const keys = [ ...this.map.keys() ];\n    keys.every((k) => {\n      const v = this.map.get(k);\n      if (v === undefined) return;\n      r += k + ` (${ v.length }) = ${ JSON.stringify(v) }\\r\\n`;\n    });\n    return r;\n  }\n\n  /**\n   * Return number of values stored under `key`.\n   * Returns 0 if `key` is not found.\n   * @param key\n   * @returns\n   */\n  count(key: string): number {\n    const values = this.map.get(key);\n    if (!values) return 0;\n    return values.length;\n  }\n\n\n  /**\n * Returns first key that contains `value`\n * @param value \n * @param eq \n * @returns \n */\n  firstKeyByValue(value: V, eq: IsEqual<V> = isEqualDefault) {\n    const entry = firstEntryByValue(this, value, eq);\n    if (entry) return entry[ 0 ];\n  }\n\n  /**\n   * Iterate over all entries\n   */\n  *entriesFlat(): IterableIterator<[ key: string, value: V ]> {\n    for (const key of this.map.keys()) {\n      for (const value of this.map.get(key)!) {\n        yield [ key, value ];\n      }\n    }\n  }\n\n  /**\n   * Iterate over keys and array of values for that key\n   */\n  *entries(): IterableIterator<[ key: string, value: Array<V> ]> {\n    for (const [ k, v ] of this.map.entries()) {\n      yield [ k, [ ...v ] ];\n    }\n  }\n\n\n  /**\n   * Get all values under `key`\n   * @param key\n   * @returns\n   */\n  *get(key: string): IterableIterator<V> {\n    const m = this.map.get(key);\n    if (!m) return;\n    yield* m.values();\n  }\n\n  /**\n   * Iterate over all keys\n   */\n  *keys(): IterableIterator<string> {\n    yield* this.map.keys();\n  }\n\n  /**\n   * Iterate over all values (regardless of key).\n   * Use {@link values} to iterate over a set of values per key\n   */\n  *valuesFlat(): IterableIterator<V> {\n    for (const entries of this.map) {\n      yield* entries[ 1 ];\n    }\n  }\n\n  /**\n   * Yields the values for each key in sequence, returning an array.\n   * Use {@link valuesFlat} to iterate over all keys regardless of key.\n   */\n  *values(): IterableIterator<ReadonlyArray<V>> {\n    for (const entries of this.map) {\n      yield entries[ 1 ];\n    }\n  }\n  /**\n   * Iterate over keys and length of values stored under keys\n   */\n  *keysAndCounts(): IterableIterator<[ string, number ]> {\n    for (const entries of this.map) {\n      yield [ entries[ 0 ], entries[ 1 ].length ];\n    }\n  }\n\n  /**\n   * Returns the count of keys.\n   */\n  get lengthKeys() {\n    return this.map.size;\n  }\n\n  /**\n  * _True_ if empty\n  */\n  get isEmpty(): boolean {\n    return this.map.size === 0;\n  }\n\n}\n","import { defaultKeyer } from '../../DefaultKeyer.js';\nimport { type IsEqual, isEqualDefault } from '../../util/IsEqual.js';\nimport type { IMapOfMutable } from './IMapOfMutable.js';\nimport { MapOfSimpleBase } from './MapOfSimpleBase.js';\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable<V>\n  extends MapOfSimpleBase<V>\n  implements IMapOfMutable<V> {\n\n  addKeyedValues(key: string, ...values: ReadonlyArray<V>) {\n    const existing = this.map.get(key);\n    if (existing === undefined) {\n      this.map.set(key, values);\n    } else {\n      this.map.set(key, [ ...existing, ...values ]);\n    }\n  }\n\n  /**\n   * Set `values` to `key`.\n   * Previous data stored under `key` is thrown away.\n   * @param key \n   * @param values \n   */\n  setValues(key: string, values: ReadonlyArray<V>) {\n    this.map.set(key, values);\n  }\n\n  /**\n   * Adds a value, automatically extracting a key via the\n   * `groupBy` function assigned in the constructor options.\n   * @param values Adds several values\n   */\n  addValue(...values: ReadonlyArray<V>) {\n    for (const v of values) {\n      const key = this.groupBy(v);\n      this.addKeyedValues(key, v);\n    }\n  }\n\n  /**\n   * Delete `value` under a particular `key`\n   * @param key\n   * @param value\n   * @returns _True_ if `value` was found under `key`\n   */\n  deleteKeyValue(key: string, value: V): boolean {\n    const existing = this.map.get(key);\n    if (existing === undefined) return false;\n    const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n    this.map.set(key, without);\n    return without.length < existing.length;\n  }\n\n  /**\n   * Deletes `value` regardless of key.\n   *\n   * Uses the constructor-defined equality function.\n   * @param value Value to delete\n   * @returns\n   */\n  deleteByValue(value: V): boolean {\n    let del = false;\n    const entries = [ ...this.map.entries() ];\n    for (const keyEntries of entries) {\n      for (const values of keyEntries[ 1 ]) {\n        if (this.valueEq(values, value)) {\n          del = true;\n          this.deleteKeyValue(keyEntries[ 0 ], value);\n        }\n      }\n    }\n    return del;\n  }\n\n  /**\n   * Deletes all values under `key`,\n   * @param key\n   * @returns _True_ if `key` was found and values stored\n   */\n  delete(key: string): boolean {\n    const values = this.map.get(key);\n    if (!values) return false;\n    if (values.length === 0) return false;\n    this.map.delete(key);\n    return true;\n  }\n\n  /**\n   * Clear contents\n   */\n  clear() {\n    this.map.clear();\n  }\n}\n\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = <V>(\n  groupBy: (value: V) => string = defaultKeyer,\n  valueEq: IsEqual<V> = isEqualDefault<V>\n): IMapOfMutable<V> => new MapOfSimpleMutable<V>(groupBy, valueEq);\n","import { numberTest } from '../util/GuardNumbers.js';\nimport { round } from '../numbers/Round.js';\n\n/**\n * Interval types allows for more expressive coding, rather than embedding millisecond values.\n * \n * That is, we can use `{ mins: 5 }` to mean 5 minutes rather than `5*60*1000` \n * or worse, 300000, for the same value.\n *\n * @example\n * ```js\n * { hours: 1 };  // 1 hour\n * { mins: 5 };   // 5 mins\n * { secs: 5 };   // 5 secs\n * { millis: 5 }; // 5 milliseconds\n * ```\n * \n * If several fields are used, this sums their value\n * ```js\n * { secs: 2, millis: 1 }; // equal 2001 milliseconds.\n * ```\n * \n * Wherever ixfx takes an `Interval`, you can also just provide a number instead.\n * This will be taken as a millisecond value.\n * \n * @see {@link intervalToMs} to convert to milliseconds.\n * @see {@link isInterval} check whether input is an Interval type\n * @see {@link elapsedToHumanString} render interval in human-friendly form\n */\nexport type Interval =\n  | number\n  | {\n    readonly millis?: number;\n    readonly secs?: number;\n    readonly hours?: number;\n    readonly mins?: number;\n  };\n\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n\n\n/**\n * Return the millisecond value of an Interval.\n * \n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber?: number\n): number {\n  if (isInterval(interval)) {\n    // Number given, must be millis?\n    if (typeof interval === `number`) return interval;\n\n    let ms = interval.millis ?? 0;\n    ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n    ms += (interval.mins ?? 0) * 60 * 1000;\n    ms += (interval.secs ?? 0) * 1000;\n    return ms;\n  } else {\n    if (typeof defaultNumber !== `undefined`) return defaultNumber;\n    throw new Error(`Not a valid interval: ${ interval }`);\n  }\n}\n\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval \n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval: number | Interval | undefined): interval is Interval {\n  if (interval === undefined) return false;\n  if (interval === null) return false;\n  if (typeof interval === `number`) {\n    if (Number.isNaN(interval)) return false;\n    if (!Number.isFinite(interval)) return false;\n    return true;\n  } else if (typeof interval !== `object`) return false;\n\n  const hasMillis = `millis` in interval;\n  const hasSecs = `secs` in interval;\n  const hasMins = `mins` in interval;\n  const hasHours = `hours` in interval;\n  if (hasMillis && !numberTest(interval.millis)[ 0 ]) return false;\n  if (hasSecs && !numberTest(interval.secs)[ 0 ]) return false;\n  if (hasMins && !numberTest(interval.mins)[ 0 ]) return false;\n  if (hasHours && !numberTest(interval.hours)[ 0 ]) return false;\n  if (hasMillis || hasSecs || hasHours || hasMins) return true;\n  return false;\n}\n\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n * \n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns \n */\nexport const elapsedToHumanString = (millisOrFunction: number | (() => number) | Interval, rounding = 2): string => {\n  let interval: number | undefined = {} = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return elapsedToHumanString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};"],"mappings":";;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACMO,IAAM,eAAe,CAAI,MAAS;AACvC,SAAO,OAAO,MAAM,WAAW,IAAI,KAAK,UAAU,CAAC;AACrD;;;ACiBO,IAAM,aAAa,CACxB,KACA,cACwD;AACxD,aAAW,KAAK,IAAI,QAAQ,GAAG;AAC7B,UAAM,MAAM,EAAG,CAAE;AACjB,eAAW,YAAY,KAAK;AAC1B,UAAI,UAAU,UAAU,EAAG,CAAE,CAAC,EAAG,QAAO;AAAA,IAC1C;AAAA,EACF;AACF;AAKO,IAAM,YAAY,CAAI,QAA2B;AAEtD,MAAI,UAAuC,CAAE,IAAI,CAAE;AACnD,aAAW,KAAK,IAAI,cAAc,GAAG;AACnC,QAAI,EAAG,CAAE,IAAI,QAAS,CAAE,GAAG;AACzB,gBAAU;AAAA,IACZ;AAAA,EACF;AACA,SAAO,QAAS,CAAE;AACpB;AAoBO,IAAM,oBAAoB,CAC/B,KACA,OACA,UAAsB,mBACkC;AACxD,aAAW,KAAK,IAAI,QAAQ,GAAG;AAC7B,UAAM,MAAM,EAAG,CAAE;AACjB,eAAW,YAAY,KAAK;AAC1B,UAAI,QAAQ,UAAU,KAAK,EAAG,QAAO;AAAA,IACvC;AAAA,EACF;AACF;;;AC5EO,IAAM,kBAAN,MAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAU9B,YACE,UAAgC,cAChC,UAAsB,gBACtB,UAA+C,CAAC,GAChD;AACA,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,MAAM,IAAI,IAAI,OAAO;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,KAAsB;AACxB,WAAO,KAAK,IAAI,IAAI,GAAG;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,KAAa,OAAmB;AAC1C,UAAM,SAAS,KAAK,IAAI,IAAI,GAAG;AAC/B,QAAI,CAAC,OAAQ,QAAO;AACpB,eAAW,KAAK,QAAQ;AACtB,UAAI,KAAK,QAAQ,GAAG,KAAK,EAAG,QAAO;AAAA,IACrC;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,cAAsB;AACpB,QAAI,IAAI;AACR,UAAM,OAAO,CAAE,GAAG,KAAK,IAAI,KAAK,CAAE;AAClC,SAAK,MAAM,CAAC,MAAM;AAChB,YAAM,IAAI,KAAK,IAAI,IAAI,CAAC;AACxB,UAAI,MAAM,OAAW;AACrB,WAAK,IAAI,KAAM,EAAE,MAAO,OAAQ,KAAK,UAAU,CAAC,CAAE;AAAA;AAAA,IACpD,CAAC;AACD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,KAAqB;AACzB,UAAM,SAAS,KAAK,IAAI,IAAI,GAAG;AAC/B,QAAI,CAAC,OAAQ,QAAO;AACpB,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,gBAAgB,OAAU,KAAiB,gBAAgB;AACzD,UAAM,QAAQ,kBAAkB,MAAM,OAAO,EAAE;AAC/C,QAAI,MAAO,QAAO,MAAO,CAAE;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,CAAC,cAA2D;AAC1D,eAAW,OAAO,KAAK,IAAI,KAAK,GAAG;AACjC,iBAAW,SAAS,KAAK,IAAI,IAAI,GAAG,GAAI;AACtC,cAAM,CAAE,KAAK,KAAM;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,CAAC,UAA8D;AAC7D,eAAW,CAAE,GAAG,CAAE,KAAK,KAAK,IAAI,QAAQ,GAAG;AACzC,YAAM,CAAE,GAAG,CAAE,GAAG,CAAE,CAAE;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,CAAC,IAAI,KAAkC;AACrC,UAAM,IAAI,KAAK,IAAI,IAAI,GAAG;AAC1B,QAAI,CAAC,EAAG;AACR,WAAO,EAAE,OAAO;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,CAAC,OAAiC;AAChC,WAAO,KAAK,IAAI,KAAK;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,aAAkC;AACjC,eAAW,WAAW,KAAK,KAAK;AAC9B,aAAO,QAAS,CAAE;AAAA,IACpB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,CAAC,SAA6C;AAC5C,eAAW,WAAW,KAAK,KAAK;AAC9B,YAAM,QAAS,CAAE;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAIA,CAAC,gBAAsD;AACrD,eAAW,WAAW,KAAK,KAAK;AAC9B,YAAM,CAAE,QAAS,CAAE,GAAG,QAAS,CAAE,EAAE,MAAO;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,aAAa;AACf,WAAO,KAAK,IAAI;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,UAAmB;AACrB,WAAO,KAAK,IAAI,SAAS;AAAA,EAC3B;AAEF;;;AC7IO,IAAM,qBAAN,cACG,gBACoB;AAAA,EAE5B,eAAe,QAAgB,QAA0B;AACvD,UAAM,WAAW,KAAK,IAAI,IAAI,GAAG;AACjC,QAAI,aAAa,QAAW;AAC1B,WAAK,IAAI,IAAI,KAAK,MAAM;AAAA,IAC1B,OAAO;AACL,WAAK,IAAI,IAAI,KAAK,CAAE,GAAG,UAAU,GAAG,MAAO,CAAC;AAAA,IAC9C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,KAAa,QAA0B;AAC/C,SAAK,IAAI,IAAI,KAAK,MAAM;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,QAA0B;AACpC,eAAW,KAAK,QAAQ;AACtB,YAAM,MAAM,KAAK,QAAQ,CAAC;AAC1B,WAAK,eAAe,KAAK,CAAC;AAAA,IAC5B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAe,KAAa,OAAmB;AAC7C,UAAM,WAAW,KAAK,IAAI,IAAI,GAAG;AACjC,QAAI,aAAa,OAAW,QAAO;AACnC,UAAM,UAAU,SAAS,OAAO,CAAC,kBAAkB,CAAC,KAAK,QAAQ,eAAe,KAAK,CAAC;AACtF,SAAK,IAAI,IAAI,KAAK,OAAO;AACzB,WAAO,QAAQ,SAAS,SAAS;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,cAAc,OAAmB;AAC/B,QAAI,MAAM;AACV,UAAM,UAAU,CAAE,GAAG,KAAK,IAAI,QAAQ,CAAE;AACxC,eAAW,cAAc,SAAS;AAChC,iBAAW,UAAU,WAAY,CAAE,GAAG;AACpC,YAAI,KAAK,QAAQ,QAAQ,KAAK,GAAG;AAC/B,gBAAM;AACN,eAAK,eAAe,WAAY,CAAE,GAAG,KAAK;AAAA,QAC5C;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,KAAsB;AAC3B,UAAM,SAAS,KAAK,IAAI,IAAI,GAAG;AAC/B,QAAI,CAAC,OAAQ,QAAO;AACpB,QAAI,OAAO,WAAW,EAAG,QAAO;AAChC,SAAK,IAAI,OAAO,GAAG;AACnB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,IAAI,MAAM;AAAA,EACjB;AACF;AAoBO,IAAM,kBAAkB,CAC7B,UAAgC,cAChC,UAAsB,mBACD,IAAI,mBAAsB,SAAS,OAAO;;;ACzE1D,SAAS,aACd,UACA,eACQ;AACR,MAAI,WAAW,QAAQ,GAAG;AAExB,QAAI,OAAO,aAAa,SAAU,QAAO;AAEzC,QAAI,KAAK,SAAS,UAAU;AAC5B,WAAO,SAAS,SAAS,KAAK,KAAK,KAAK;AACxC,WAAO,SAAS,QAAQ,KAAK,KAAK;AAClC,WAAO,SAAS,QAAQ,KAAK;AAC7B,WAAO;AAAA,EACT,OAAO;AACL,QAAI,OAAO,kBAAkB,YAAa,QAAO;AACjD,UAAM,IAAI,MAAM,yBAA0B,QAAS,EAAE;AAAA,EACvD;AACF;AAOO,SAAS,WAAW,UAA+D;AACxF,MAAI,aAAa,OAAW,QAAO;AACnC,MAAI,aAAa,KAAM,QAAO;AAC9B,MAAI,OAAO,aAAa,UAAU;AAChC,QAAI,OAAO,MAAM,QAAQ,EAAG,QAAO;AACnC,QAAI,CAAC,OAAO,SAAS,QAAQ,EAAG,QAAO;AACvC,WAAO;AAAA,EACT,WAAW,OAAO,aAAa,SAAU,QAAO;AAEhD,QAAM,YAAY,YAAY;AAC9B,QAAM,UAAU,UAAU;AAC1B,QAAM,UAAU,UAAU;AAC1B,QAAM,WAAW,WAAW;AAC5B,MAAI,aAAa,CAAC,WAAW,SAAS,MAAM,EAAG,CAAE,EAAG,QAAO;AAC3D,MAAI,WAAW,CAAC,WAAW,SAAS,IAAI,EAAG,CAAE,EAAG,QAAO;AACvD,MAAI,WAAW,CAAC,WAAW,SAAS,IAAI,EAAG,CAAE,EAAG,QAAO;AACvD,MAAI,YAAY,CAAC,WAAW,SAAS,KAAK,EAAG,CAAE,EAAG,QAAO;AACzD,MAAI,aAAa,WAAW,YAAY,QAAS,QAAO;AACxD,SAAO;AACT;AAgBO,IAAM,uBAAuB,CAAC,kBAAsD,WAAW,MAAc;AAClH,MAAI,WAA+B,CAAC,IAAI;AACxC,MAAI,OAAO,qBAAqB,YAAY;AAC1C,UAAM,iBAAiB,iBAAiB;AACxC,WAAO,qBAAqB,cAAc;AAAA,EAC5C,WAAW,OAAO,qBAAqB,UAAU;AAC/C,eAAW;AAAA,EACb,WAAW,OAAO,qBAAqB,UAAU;AAC/C,eAAW,aAAa,QAAQ;AAAA,EAClC;AAEA,MAAI,KAAK,aAAa,QAAQ;AAC9B,MAAI,OAAO,OAAO,YAAa,QAAO;AACtC,MAAI,KAAK,IAAM,QAAO,GAAI,MAAM,UAAU,EAAE,CAAE;AAC9C,QAAM;AACN,MAAI,KAAK,IAAK,QAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AACvC,QAAM;AACN,MAAI,KAAK,GAAI,QAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AACtC,QAAM;AACN,SAAO,GAAI,GAAG,QAAQ,CAAC,CAAE;AAC3B;;;AL1HO,IAAM,YAAY,CAAC,QAAqB,YAA2B,UAA+D,CAAC,MAAM;AAC9I,QAAM,aAAa,aAAa,QAAQ,SAAS,KAAK,GAAI;AAC1D,QAAM,SAAS,QAAQ;AACvB,MAAI,YAAY;AAChB,MAAI,WAAW;AACf,MAAI;AAEJ,QAAM,UAAU,IAAI,QAAe,CAAC,SAAS,WAAW;AACtD,UAAM,UAAU,CAAC,UAAiB;AAChC,UAAI,UAAU,OAAO;AACnB,YAAI,WAAW,SAAS,MAAM,IAAI,GAAG;AACnC,sBAAY;AACZ,kBAAQ,KAAK;AACb,kBAAQ;AAAA,QACV,OAAO;AACL,kBAAQ,KAAK,yBAA0B,MAAM,IAAK,4BAA4B;AAAA,QAChF;AAAA,MACF,OAAO;AACL,gBAAQ,KAAK,2DAA2D;AACxE,gBAAQ,IAAI,KAAK;AAAA,MACnB;AAAA,IACF;AAEA,eAAW,QAAQ,YAAY;AAC7B,aAAO,iBAAiB,MAAM,OAAO;AAAA,IACvC;AAEA,UAAM,UAAU,MAAM;AACpB,UAAI,SAAU;AACd,UAAI,YAAY,OAAW,cAAa,OAAO;AAC/C,gBAAU;AACV,iBAAW;AACX,iBAAW,QAAQ,YAAY;AAC7B,eAAO,oBAAoB,MAAM,OAAO;AAAA,MAC1C;AAAA,IACF;AAEA,cAAU,WAAW,MAAM;AACzB,UAAI,aAAa,SAAU;AAC3B,cAAQ;AACR,aAAO,IAAI,MAAM,wDAAyD,KAAK,UAAU,UAAU,CAAE,cAAe,UAAW,EAAE,CAAC;AAAA,IACpI,GAAG,UAAU;AAGb,YAAQ,iBAAiB,SAAS,MAAM;AACtC,UAAI,aAAa,SAAU;AAC3B,cAAQ;AACR,aAAO,IAAI,MAAM,yBAA0B,OAAO,MAAO,EAAE,CAAC;AAAA,IAC9D,CAAC;AAAA,EACH,CAAC;AACD,SAAO;AACT;AAGO,IAAM,qBAAN,MAAwE;AAAA,EACpE,aAAa,gBAAkC;AAAA,EACxD,YAAY;AAAA,EAEZ,UAAU;AACR,QAAI,KAAK,UAAW;AACpB,SAAK,oBAAoB;AAAA,EAC3B;AAAA,EAEA,IAAI,aAAa;AACf,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQU,UAAkC,MAAS,MAAmB;AACtE,QAAI,KAAK,UAAW,OAAM,IAAI,MAAM,UAAU;AAC9C,UAAM,YAAY,KAAK,WAAW,IAAI,IAAc;AAEpD,eAAW,KAAK,WAAW;AACzB,QAAE,MAAM,IAAI;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,iBACE,MACA,UACM;AACN,QAAI,KAAK,UAAW,OAAM,IAAI,MAAM,UAAU;AAC9C,SAAK,WAAW;AAAA,MACd;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,oBACE,MACA,UACA;AACA,QAAI,KAAK,UAAW;AAGpB,SAAK,WAAW;AAAA,MACd;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,sBAAsB;AACpB,QAAI,KAAK,UAAW;AACpB,SAAK,WAAW,MAAM;AAAA,EACxB;AACF;","names":[]}