{"version":3,"file":"modulation.js","names":["ticks","totalTicks: number","options: Partial<TicksModSettableOptions>","feedback?: Partial<ModuleSettableFeedback>","interval: Interval","options: Partial<ModuleSettableOptions>","feedback?: Partial<ModuleSettableFeedback>","bpm: number","bpm","hz: number","amount: number","options: Partial<{ clamp: boolean, max: number, min: number }>","clamp","elapsed","piPi","timerOrFreq: Flow.Timer | number","pow","t: number","x: number","value: number","fn: ModFunction","duration: Interval","relative: undefined | (() => number)","relative","totalTicks: number","durationTicks: number","options: EasingOptions","time","ticks","nameOrFunction: EasingName | ((v: number) => number)","duration: Interval","totalTicks: number","durationTicks: number","easingsMap: Map<string, ((v: number) => number)> | undefined","easingName: EasingName","Named","#sm","#timeSource","opts: AdsrTimingOpts","#holdingInitial","#timer","#holding","#disposed","allowLooping: boolean","elapsed","relative","#triggered","adsr: Adsr","opts: EnvelopeOpts","opts: EnvelopeOpts","opts: AdsrIterableOpts","t: ForceAffected","bounds?: Rects.Rect","attractors: readonly ForceAffected[]","gravity: number","distanceRange: { readonly min?: number; readonly max?: number }","attractee: ForceAffected","attractor: ForceAffected","targetPos: Points.Point","opts: TargetOpts","ff: ForceAffected","vector: Points.Point","mass: MassApplication","thing: ForceAffected","mass: number","mass","_mass: number","force: number","pipeline","v: Points.Point","pinnedAt: Points.Point","pinnedAt?: Points.Point","opts: PendulumOpts","acceleration: Points.Point","velocity: Points.Point","velocityMax?: number","currentPos: Points.Point","position: Points.Point","distance: number","angleRadians: number","origin: Points.Point","distance","b: number","d: number","t: number","driftAmtPerMs: number","v: number","elapsed","interpolate","pos1: number","pos2?: number | Partial<InterpolateOptions>","pos3?: number | Partial<InterpolateOptions>","pos4?: Partial<InterpolateOptions>","amountProcess: undefined | ((v: number) => number)","limits: InterpolateOptions[ 'limits' ]","amount: number","_amt: number","_a: number","_b: number","o: Partial<InterpolateOptions>","getEasing","a: number","b: number","aValue: number","bValue: number","incrementAmount: number","options?: Partial<InterpolateOptions>","retargetB?: number","retargetA?: number","interpolateAngle","aRadians: number","bRadians: number","duration: Interval","options: JitterOpts","value: number","abs","relative","_: number","randomFloatFunction","v: number","randomFloat","amount: number","original: number","modulation: number","balance: number","a: ModFunction","b: ModFunction","amt: number","noop: ModFunction","v: number","lower?: number","upper?: number","start?: number","rounding?: number","interval: number","lower: number","upper: number","distance","opts: SpringOptions","timerOrFreq?: Flow.Timer | number","t: number","source: TimingSources","duration: number","options: Partial<ModSettableOptions>","t: number","options: Partial<WaveOptions>","invert","sourceFunction: ModSettable","shaperFunction: ModFunction | undefined","v: number","shaperFunction: ModFunction","feedback?: Partial<WaveShaperFeedback>","currentValue: number","targetValue: number","slowDownFactor: number","easingNameOrOptions: EasingName | WeightedOptions"],"sources":["../packages/modulation/src/source/ticks.ts","../packages/modulation/src/source/time.ts","../packages/modulation/src/source/per-second.ts","../packages/modulation/src/source/index.ts","../packages/modulation/src/oscillator.ts","../packages/modulation/src/gaussian.ts","../packages/modulation/src/easing/easings-named.ts","../packages/modulation/src/easing/line.ts","../packages/modulation/src/modulator-timed.ts","../packages/modulation/src/easing/index.ts","../packages/modulation/src/envelope/Types.ts","../packages/modulation/src/envelope/AdsrBase.ts","../packages/modulation/src/envelope/Adsr.ts","../packages/modulation/src/envelope/index.ts","../packages/modulation/src/forces.ts","../packages/modulation/src/cubic-bezier.ts","../packages/modulation/src/drift.ts","../packages/modulation/src/util/pi-pi.ts","../packages/modulation/src/interpolate.ts","../packages/modulation/src/jitter.ts","../packages/modulation/src/mix.ts","../packages/modulation/src/no-op.ts","../packages/modulation/src/ping-pong.ts","../packages/modulation/src/spring.ts","../packages/modulation/src/timing-source-factory.ts","../packages/modulation/src/waveforms.ts","../packages/modulation/src/weighted-average.ts","../packages/modulation/src/weighted-random.ts"],"sourcesContent":["import { resultThrow, integerTest } from \"@ixfx/guards\";\nimport type { ModSettable as ModuleSettable, ModSettableFeedback as ModuleSettableFeedback, ModSettableOptions as ModuleSettableOptions } from \"../types.js\";\n\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport type TicksModSettableOptions = ModuleSettableOptions & {\n  exclusiveStart: boolean\n  exclusiveEnd: boolean\n}\n/**\n * Returns a function which cycles between 0..1 (inclusive of 0 and 1).\n * `totalTicks` is how many ticks it takes to get to 1. Since we want an inclusive 0 & 1,\n * the total ticks is actually +1.\n *\n * Ie. if totalTicks = 10, we get: 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\n * \n * Use 'exclusiveStart' and 'exclusiveEnd' flags to shift range. Eg, with `totalTicks` of 10: \n * * 'exclusiveStart:true': first value is 0.1, last value is 1.0 (10 values total)\n * * 'exclusiveEnd:true': first value is 0, last value is 0.9 (10 values total)\n * * If both are true, first value is 0.1, last value is 0.9 (9 values total)\n * * If both are false (or not set), we get the case described earlier, first value is 0, last value is 1 (11 values total)\n * \n * Other examples:\n * * totalTicks: 20, value goes up by 0.05\n * * totalTicks: 1, value goes up by 1\n * @param totalTicks Positive, integer value. How many ticks to complete a cycle\n * @param options\n * @returns \n */\nexport function ticks(totalTicks: number, options: Partial<TicksModSettableOptions> = {}): ModuleSettable {\n  resultThrow(integerTest(totalTicks, `aboveZero`, `totalTicks`));\n  const exclusiveStart = options.exclusiveStart ?? false;\n  const exclusiveEnd = options.exclusiveEnd ?? false;\n  const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n\n  const startPoint = exclusiveStart ? 1 : 0;\n  const endPoint = exclusiveEnd ? totalTicks - 1 : totalTicks;\n\n  let cycleCount = 0;\n  let v = options.startAt ?? startPoint;\n  if (options.startAtRelative) {\n    let totalTicksForReal = totalTicks;\n    if (exclusiveStart) totalTicksForReal--;\n    if (exclusiveEnd) totalTicksForReal--;\n    v = Math.round(options.startAtRelative * totalTicksForReal);\n  }\n\n  return (feedback?: Partial<ModuleSettableFeedback>) => {\n    if (feedback) {\n      if (feedback.resetAt !== undefined) {\n        v = feedback.resetAt;\n      }\n      if (feedback.resetAtRelative !== undefined) {\n        v = Math.floor(feedback.resetAtRelative * totalTicks);\n      }\n    }\n    if (cycleCount >= cycleLimit) return 1;\n\n    const current = v / totalTicks;\n    v++;\n    if (v > endPoint) {\n      cycleCount++;\n      v = startPoint;\n    }\n    return current;\n  }\n}\n","import { type Interval, intervalToMs } from \"@ixfx/core\";\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { ModSettableOptions as ModuleSettableOptions, ModSettable as ModuleSettable, ModSettableFeedback as ModuleSettableFeedback } from \"../types.js\";\n\n/**\n * Returns the percentage of time toward `interval`. See also: {@link bpm}, {@link hertz} which are the same but\n * using different units for time.\n * \n * By default, it continues forever, cycling from 0..1 repeatedly for each interval. Use\n * `cycleLimit` to restrict this. A value of 1 means it won't loop. \n * \n * The starting 'position' is `performance.now()`. If `startAt` option is provided, this will be used instead.\n * It probably should be an offset of `performance.now()`, eg: `{ startAt: performance.now() - 500 }` to shift\n * the cycle by 500ms.\n * \n * When using `startAtRelative`, the starting position will be set backward by the relative amount. A value\n * of 0.5, for example, will set the timer back 50% of the interval, meaning the cycle will start half way through.\n * \n * @param interval \n * @param options \n * @returns\n */\nexport function elapsed(interval: Interval, options: Partial<ModuleSettableOptions> = {}): ModuleSettable {\n  const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = 1;\n  let start = options.startAt ?? performance.now();\n  let cycleCount = 0;\n  const intervalMs = intervalToMs(interval, 1000);\n  if (options.startAtRelative) {\n    resultThrow(numberTest(options.startAtRelative, `percentage`, `startAtRelative`));\n    start = performance.now() - (intervalMs * options.startAtRelative);\n  }\n  //let stopAt = cycleLimit > 0 ? (intervalMs + start) : Number.MAX_SAFE_INTEGER;\n  return (feedback?: Partial<ModuleSettableFeedback>) => {\n    if (feedback) {\n      if (feedback.resetAt !== undefined) {\n        start = feedback.resetAt;\n        if (start === 0) start = performance.now();\n      }\n      if (feedback.resetAtRelative !== undefined) {\n        resultThrow(numberTest(feedback.resetAtRelative, `percentage`, `resetAtRelative`));\n        start = performance.now() - (intervalMs * feedback.resetAtRelative);\n      }\n    }\n    if (cycleCount >= cycleLimit) return limitValue;\n    const now = performance.now();\n    const elapsedCycle = now - start;\n    if (elapsedCycle >= intervalMs) {\n      cycleCount += Math.floor(elapsedCycle / intervalMs);\n      start = now;\n      if (cycleCount >= cycleLimit) return limitValue;\n    }\n    return (elapsedCycle % intervalMs) / intervalMs;\n  }\n\n  // } else {\n  //   return () => ((performance.now() - start) % intervalMs) / intervalMs;\n  // }\n}\n\n/**\n * Counts beats based on a BPM.\n * Uses {@link elapsed} internally.\n * @param bpm \n * @param options \n * @returns \n */\nexport function bpm(bpm: number, options: Partial<ModuleSettableOptions> = {}): ModuleSettable {\n  const interval = (60 * 1000) / bpm; // milliseconds between beats.\n  return elapsed(interval, options);\n}\n\n/**\n * Counts based on hertz (oscillations per second).\n * Uses {@link elapsed} internally.\n * @param hz \n * @param options \n * @returns \n */\nexport function hertz(hz: number, options: Partial<ModuleSettableOptions> = {}): ModuleSettable {\n  const interval = 1000 / hz;\n  return elapsed(interval, options);\n}\n\n","import type { ModSource } from \"../types.js\";\n\n/**\n * Returns a proportion of `amount` depending on elapsed time.\n * Cumulatively, `amount` is yielded every second.\n * \n * ```js\n * // Calculate a proportion of 0.1 every second\n * const x = perSecond(0.1);\n * x();\n * ```\n * \n * The faster `x()` is called, the smaller the chunks of `amount` are returned.\n * Values accumulate. For example, `x()` isn't called for two seconds, 2*amount is returned.\n * \n * @example Usage\n * ```js\n * const settings = {\n *  ageMod: perSecond(0.1);\n * };\n * \n * let state = {\n *  age: 1\n * };\n * \n * // Update\n * setInterval(() => {\n *  let { age } = state;\n *  // Add 0.1 per second, regardless of \n *  // loop speed\n *  age += settings.ageMod(); \n *  state = {\n *    ...state,\n *    age: clamp(age)\n *  }\n * });\n * ```\n * \n * Use the `clamp` option so the returned value never exceeds `amount`.\n * Alternatively, `min`/`max` options allow you to set arbitrary limits.\n * @param amount\n * @returns \n */\nexport const perSecond = (amount: number, options: Partial<{ clamp: boolean, max: number, min: number }> = {}): ModSource => {\n  const perMilli = amount / 1000;\n  let min = options.min ?? Number.MIN_SAFE_INTEGER;\n  let max = options.max ?? Number.MAX_SAFE_INTEGER;\n  const clamp = options.clamp ?? false;\n  if (clamp && options.max) throw new Error(`Use either 'max' or 'clamp', not both.`);\n  if (clamp) max = amount;\n  let called = performance.now();\n\n  return () => {\n    const now = performance.now();\n    const elapsed = now - called;\n    called = now;\n    const x = perMilli * elapsed;\n    if (x > max) return max;\n    if (x < min) return min;\n    return x;\n  }\n}\n\n/**\n * As {@link perSecond}, but per minute.\n * @param amount \n * @param options \n * @returns \n */\nexport const perMinute = (amount: number, options: Partial<{ clamp: boolean, max: number, min: number }> = {}): ModSource => {\n  return perSecond(amount / 60, options);\n}","export * from './ticks.js'\nexport * from './time.js';\nexport * from './per-second.js';","import * as Flow from '@ixfx/flow';\nconst piPi = Math.PI * 2;\n\n/**\n * Sine oscillator.\n *\n * ```js\n * import { Oscillators } from \"@ixfx/modulation.js\"\n * import { frequencyTimer } from \"@ixfx/flow.js\";\n * // Setup\n * const osc = Oscillators.sine(frequencyTimer(10));\n * const osc = Oscillators.sine(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n *\n * @example Saw/tri pinch\n * ```js\n * const v = Math.pow(osc.value, 2);\n * ```\n *\n * @example Saw/tri bulge\n * ```js\n * const v = Math.pow(osc.value, 0.5);\n * ```\n *\n */\n\nexport function* sine(timerOrFreq: Flow.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n  }\n\n  while (true) {\n    // Rather than -1 to 1, we want 0 to 1\n    yield (Math.sin(timerOrFreq.elapsed * piPi) + 1) / 2;\n  }\n}\n\n/**\n * Bipolar sine (-1 to 1)\n * @param timerOrFreq\n */\n\nexport function* sineBipolar(timerOrFreq: Flow.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield Math.sin(timerOrFreq.elapsed * piPi);\n  }\n}\n\n/**\n * Triangle oscillator\n *\n * ```js\n * // Setup\n * const osc = triangle(Timers.frequencyTimer(0.1));\n * const osc = triangle(0.1);\n *\n * // Call whenver a value is needed\n * const v = osc.next().value;\n * ```\n */\n\nexport function* triangle(timerOrFreq: Flow.Timer | number) {\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    // elapsed is repeatedly 0->1\n    let v = timerOrFreq.elapsed;\n    // /2 = 0->0.5\n    if (v < 0.5) {\n      // Upward\n      v *= 2;\n    } else {\n      // Downward\n      v = 2 - v * 2;\n    }\n    yield v;\n  }\n}\n\n/**\n * Saw oscillator\n *\n * ```js\n * import { Oscillators } from \"@ixfx/modulation.js\"\n * import { frequencyTimer } from \"@ixfx/flow.js\";\n * // Setup\n * const osc = Oscillators.saw(Timers.frequencyTimer(0.1));\n *\n * // Or\n * const osc = Oscillators.saw(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n */\n\nexport function* saw(timerOrFreq: Flow.Timer | number) {\n  if (timerOrFreq === undefined) throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield timerOrFreq.elapsed;\n  }\n}\n\n/**\n * Square oscillator\n *\n * ```js\n * import { Oscillators } from \"@ixfx/modulation.js\"\n *\n * // Setup\n * const osc = Oscillators.square(Timers.frequencyTimer(0.1));\n * const osc = Oscillators.square(0.1);\n *\n * // Call whenever a value is needed\n * osc.next().value;\n * ```\n */\n\nexport function* square(timerOrFreq: Flow.Timer | number) {\n  if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n  }\n  while (true) {\n    yield timerOrFreq.elapsed < 0.5 ? 0 : 1;\n  }\n}\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n  //const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = gaussianA / standardDeviation;\n    // p:-8 pinched\n    let p = -2.5; // -1/1.25;\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n    return v;\n  };\n};","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\nexport const bounceOut = (x: number) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nexport const quintIn = (x: number) => x * x * x * x * x;\nexport const quintOut = (x: number) => 1 - pow(1 - x, 5);\nexport const arch = (x: number) => x * (1 - x) * 4;\n\nexport const smoothstep = (x: number) => x * x * (3 - 2 * x);\nexport const smootherstep = (x: number) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x: number) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x: number) => sin((x * pi) / 2);\nexport const quadIn = (x: number) => x * x;\nexport const quadOut = (x: number) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x: number) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x: number) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x: number) => x * x * x;\nexport const cubicOut = (x: number) => 1 - pow(1 - x, 3);\nexport const quartIn = (x: number) => x * x * x * x;\nexport const quartOut = (x: number) => 1 - pow(1 - x, 4);\nexport const expoIn = (x: number) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x: number) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x: number) =>\n  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x: number) =>\n  x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? pow(2, 20 * x - 10) / 2\n        : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x: number) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x: number) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x: number) =>\n  x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n\nexport const backInOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c2 = c1 * 1.525;\n\n  return x < 0.5\n    ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n    : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\n\nexport const bounceIn = (x: number) => 1 - bounceOut(1 - x);\n\nexport const bell = gaussian();\n\nexport const elasticInOut = (x: number) => {\n  const c5 = (2 * pi) / 4.5;\n\n  return x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x: number) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import { Points, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\n\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns \n */\nexport const line = (bend = 0, warp = 0) => {\n  const max = 1;\n  const cubicB = {\n    x: scale(bend, -1, 1, 0, max),\n    y: scale(bend, -1, 1, max, 0),\n  }\n\n  // Add in bend as 'drive'\n  let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n\n  // Warp\n  if (bend !== 0 && warp > 0) {\n    if (bend > 0) {\n      cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n    } else {\n      cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n    }\n  }\n\n  const bzr = Beziers.cubic(Points.Empty, Points.Unit,\n    cubicA, cubicB\n  );\n\n  const inter = Beziers.interpolator(bzr);\n  return (value: number) => inter(value);\n}","import { intervalToMs, type Interval } from \"@ixfx/core\";\nimport type { ModFunction, ModulatorTimed } from \"./types.js\";\nimport * as Flow from '@ixfx/flow';\nimport { functionTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  fn: ModFunction,\n  duration: Interval\n): () => number => {\n  resultThrow(functionTest(fn, `fn`));\n  let relative: undefined | (() => number);\n  return () => {\n    if (typeof relative === `undefined`) relative = Flow.ofTotal(duration, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n * \n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"@ixfx/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (\n  fn: ModFunction,\n  duration: Interval\n): ModulatorTimed => {\n  resultThrow(functionTest(fn, `fn`));\n\n  const timer = Flow.elapsedMillisecondsAbsolute();\n  const durationMs = intervalToMs(duration);\n  if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  const relativeTimer = Flow.relative(\n    durationMs,\n    {\n      timer,\n      clampValue: true\n    });\n  return Flow.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n * \n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  fn: ModFunction,\n  totalTicks: number\n): () => number => {\n  resultThrow(functionTest(fn, `fn`));\n\n  let relative: undefined | (() => number);\n  return () => {\n    if (typeof relative === `undefined`) relative = Flow.ofTotalTicks(totalTicks, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n/**\n * Creates an modulator based on ticks. \n * \n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"@ixfx/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (\n  fn: ModFunction,\n  durationTicks: number\n): ModulatorTimed => {\n  resultThrow(functionTest(fn, `fn`));\n  const timer = Flow.elapsedTicksAbsolute();\n  const relativeTimer = Flow.relative(\n    durationTicks,\n    {\n      timer,\n      clampValue: true\n    });\n  return Flow.timerWithFunction(fn, relativeTimer);\n};","import * as Named from './easings-named.js';\nimport { stringTest, resultThrow } from '@ixfx/guards';\nimport { type Interval } from '@ixfx/core';\nimport type { ModFunction, ModulatorTimed } from '../types.js';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nexport type * from './types.js';\nimport * as ModuleTimed from '../modulator-timed.js';\nimport type { EasingName, EasingOptions } from './types.js';\n\n\n/**\n * Creates an easing function\n * ```js\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({ \n *  duration: 1000, \n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options \n * @returns \n */\nexport const create = (options: EasingOptions): () => number => {\n  const name = resolveEasingName(options.name ?? `quintIn`);\n  const fn = name ?? options.fn;\n  if (typeof fn === `undefined`) throw new Error(`Either 'name' or 'fn' must be set`);\n\n  if (`duration` in options) {\n    return time(fn, options.duration);\n  } else if (`ticks` in options) {\n    return ticks(fn, options.ticks);\n  } else {\n    throw new Error(`Expected 'duration' or 'ticks' in options`);\n  }\n}\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * \n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * \n * @example Time based easing\n * ```\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * \n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.timeModulator(fn, duration);\n  // const timer = Timer.elapsedMillisecondsAbsolute();\n  // const durationMs = intervalToMs(duration);\n  // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  // const relativeTimer = Timer.relative(\n  //   durationMs,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n * \n * ```js\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.time(fn, duration);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n\n\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n * \n * ```js\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  totalTicks: number\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.ticks(fn, totalTicks);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n/**\n * Creates an easing based on ticks. \n * \n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  durationTicks: number\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.tickModulator(fn, durationTicks);\n  // const timer = Timer.elapsedTicksAbsolute();\n  // const relativeTimer = Timer.relative(\n  //   durationTicks,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\nconst resolveEasingName = (nameOrFunction: EasingName | ((v: number) => number)): ModFunction => {\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (typeof fn === `undefined`) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n    throw error;\n  }\n  return fn;\n}\n\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\n\n\nlet easingsMap: Map<string, ((v: number) => number)> | undefined;\n\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): ModFunction {\n  resultThrow(stringTest(easingName, `non-empty`, `easingName`));\n\n  const found = cacheEasings().get(easingName.toLowerCase());\n  if (found === undefined) throw new Error(`Easing not found: '${ easingName }'`);\n  return found;\n};\n\n// Cache named easings\nfunction cacheEasings() {\n  if (easingsMap === undefined) {\n    easingsMap = new Map();\n    for (const [ k, v ] of Object.entries(Named)) {\n      easingsMap.set(k.toLowerCase(), v);\n    }\n    return easingsMap\n  } else return easingsMap;\n}\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames(): Iterable<string> {\n  const map = cacheEasings();\n  yield* map.keys();\n};\n\n","export type EnvelopeOpts = AdsrOpts & AdsrTimingOpts;\n/**\n * Options for the ADSR envelope.\n */\nexport type AdsrOpts = Partial<{\n  /**\n   * Attack bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly attackBend: number;\n  /**\n   * Decay bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly decayBend: number;\n  /**\n   * Release bezier 'bend'. Bend from -1 to 1. 0 for a straight line\n   */\n  readonly releaseBend: number;\n\n  /**\n   * Peak level (maximum of attack stage)\n   */\n  readonly peakLevel: number;\n\n  /**\n   * Starting level (usually 0)\n   */\n  readonly initialLevel: number;\n  /**\n   * Sustain level. Only valid if trigger and hold happens\n   */\n  readonly sustainLevel: number;\n  /**\n   * Release level, when envelope is done (usually 0)\n   */\n  readonly releaseLevel: number;\n\n  /**\n   * When _false_, envelope starts from it's current level when being triggered.\n   * _True_ by default.\n   */\n  readonly retrigger: boolean;\n}>;\n\nexport type AdsrTimingOpts = Partial<{\n  /**\n   * If true, envelope indefinately returns to attack stage after release\n   *\n   * @type {boolean}\n   */\n  readonly shouldLoop: boolean;\n\n  /**\n   * Duration for attack stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly attackDuration: number;\n  /**\n   * Duration for decay stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly decayDuration: number;\n  /**\n   * Duration for release stage\n   * Unit depends on timer source\n   * @type {number}\n   */\n  readonly releaseDuration: number;\n}>;\n\nexport type AdsrIterableOpts = {\n  readonly signal?: AbortSignal;\n  readonly sampleRateMs?: number;\n  readonly env: EnvelopeOpts;\n};\n\n/**\n * State change event\n */\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface StateChangeEvent {\n  readonly newState: string;\n  readonly priorState: string;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface CompleteEvent {\n  /* no-op */\n}\n\nexport type AdsrEvents = {\n  readonly change: StateChangeEvent;\n  readonly complete: CompleteEvent;\n};\n\nexport const adsrStateTransitions = Object.freeze({\n  attack: [ `decay`, `release` ],\n  decay: [ `sustain`, `release` ],\n  sustain: [ `release` ],\n  release: [ `complete` ],\n  complete: null,\n});\nexport type AdsrStateTransitions = Readonly<typeof adsrStateTransitions>;\n\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { elapsedMillisecondsAbsolute, type Timer, type TimerSource } from '@ixfx/flow';\nimport { adsrStateTransitions, type AdsrEvents, type AdsrStateTransitions, type AdsrTimingOpts } from './Types.js';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\n\nexport const defaultAdsrTimingOpts = Object.freeze({\n  attackDuration: 600,\n  decayDuration: 200,\n  releaseDuration: 800,\n  shouldLoop: false\n})\n/**\n * Base class for an ADSR envelope.\n * \n * It outputs values on a scale of 0..1 corresponding to each phase.\n */\nexport class AdsrBase extends SimpleEventEmitter<AdsrEvents> {\n  readonly #sm: StateMachineWithEvents<AdsrStateTransitions>;\n  readonly #timeSource: TimerSource;\n\n  #timer: Timer | undefined;\n  #holding: boolean;\n  #holdingInitial: boolean;\n  #disposed = false;\n  #triggered = false;\n  protected attackDuration: number;\n  protected decayDuration: number;\n  protected releaseDuration: number;\n  protected decayDurationTotal: number;\n\n  /**\n   * If _true_ envelope will loop\n   */\n  shouldLoop: boolean;\n\n  constructor(opts: AdsrTimingOpts = {}) {\n    super();\n\n    this.attackDuration = opts.attackDuration ?? defaultAdsrTimingOpts.attackDuration;\n    this.decayDuration = opts.decayDuration ?? defaultAdsrTimingOpts.decayDuration;\n    this.releaseDuration = opts.releaseDuration ?? defaultAdsrTimingOpts.releaseDuration;\n    this.shouldLoop = opts.shouldLoop ?? defaultAdsrTimingOpts.shouldLoop;\n\n    this.#sm = new StateMachineWithEvents<AdsrStateTransitions>(\n      adsrStateTransitions,\n      { initial: `attack` }\n    );\n\n    this.#sm.addEventListener(`change`, (event) => {\n      // Reset timer on release\n      if (event.newState === `release` && this.#holdingInitial) {\n        this.#timer?.reset();\n      }\n      super.fireEvent(`change`, event);\n    });\n    this.#sm.addEventListener(`stop`, (event) => {\n      super.fireEvent(`complete`, event);\n    });\n\n    this.#timeSource = () => elapsedMillisecondsAbsolute();\n    this.#holding = this.#holdingInitial = false;\n    this.decayDurationTotal = this.attackDuration + this.decayDuration;\n  }\n\n  dispose() {\n    if (this.#disposed) return;\n    this.#sm.dispose();\n  }\n\n  get isDisposed() {\n    return this.#disposed;\n  }\n\n  /**\n   * Changes state based on timer status\n   * @returns _True_ if state was changed\n   */\n  protected switchStateIfNeeded(allowLooping: boolean): boolean {\n    if (this.#timer === undefined) return false;\n    let elapsed = this.#timer.elapsed;\n    const wasHeld = this.#holdingInitial && !this.#holding;\n\n    // Change through states for as long as needed\n    let hasChanged = false;\n    //console.log(`AdsrBase.switchStateIfNeeded elapsed: ${ elapsed } wasHeld: ${ wasHeld }`);\n    let state = this.#sm.state;\n    do {\n      hasChanged = false;\n      state = this.#sm.state;\n      //console.log(`  AdsrBase.switchStateIfNeeded: ${ state }`);\n      switch (state) {\n        case `attack`: {\n          if (elapsed > this.attackDuration || wasHeld) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `decay`: {\n          if (elapsed > this.decayDurationTotal || wasHeld) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `sustain`: {\n          if (!this.#holding || wasHeld) {\n            elapsed = 0;\n            this.#sm.next();\n            this.#timer.reset();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `release`: {\n          if (elapsed > this.releaseDuration) {\n            this.#sm.next();\n            hasChanged = true;\n          }\n          break;\n        }\n        case `complete`: {\n          if (this.shouldLoop && allowLooping) {\n            this.trigger(this.#holdingInitial);\n          }\n        }\n      }\n    } while (hasChanged && state !== `complete`);\n    return hasChanged;\n  }\n\n  /**\n   * Computes a stage's progress from 0-1\n   * @param allowStateChange\n   * @returns\n   */\n  protected computeRaw(\n    allowStateChange = true,\n    allowLooping = true\n  ): [ stage: string | undefined, amount: number, prevStage: string ] {\n    if (this.#timer === undefined) {\n      return [ undefined, 0, this.#sm.state ];\n    }\n    // Change state if necessary based on elapsed time\n    if (allowStateChange) this.switchStateIfNeeded(allowLooping);\n\n    const previousStage = this.#sm.state;\n    const elapsed = this.#timer.elapsed;\n\n    let relative = 0;\n    const state = this.#sm.state;\n    switch (state) {\n      case `attack`: {\n        relative = elapsed / this.attackDuration;\n        break;\n      }\n      case `decay`: {\n        relative = (elapsed - this.attackDuration) / this.decayDuration;\n        break;\n      }\n      case `sustain`: {\n        relative = 1;\n        break;\n      }\n      case `release`: {\n        relative = Math.min(elapsed / this.releaseDuration, 1);\n        break;\n      }\n      case `complete`: {\n        return [ `complete`, 1, previousStage ];\n      }\n      default: {\n        throw new Error(`State machine in unknown state: ${ state }`);\n      }\n    }\n    return [ state, relative, previousStage ];\n  }\n\n  /**\n   * Returns _true_ if envelope has finished\n   */\n  get isDone(): boolean {\n    return this.#sm.isDone;\n  }\n\n  protected onTrigger(): void {\n    /* no op */\n  }\n\n  /**\n   * Triggers envelope, optionally _holding_ it.\n   * \n   * If `hold` is _false_ (default), envelope will run through all stages,\n   * but sustain stage won't have an affect.\n   * \n   * If `hold` is _true_, it will run to, and stay at the sustain stage. \n   * Use {@link release} to later release the envelope.\n   *\n   * If event is already trigged it will be _retriggered_. \n   * Initial value depends on `opts.retrigger`\n   * * _false_ (default): envelope continues at current value.\n   * * _true_: envelope value resets to `opts.initialValue`.\n   *\n   * @param hold If _true_ envelope will hold at sustain stage\n   */\n  trigger(hold = false) {\n    this.onTrigger();\n    this.#triggered = true;\n    this.#sm.reset();\n    this.#timer = this.#timeSource();\n    this.#holding = hold;\n    this.#holdingInitial = hold;\n  }\n\n  get hasTriggered() {\n    return this.#triggered;\n  }\n\n  compute(): void {\n    /* no-op */\n  }\n\n  /**\n   * Release if 'trigger(true)' was previouslly called.\n   * Has no effect if not triggered or held.\n   * @returns \n   */\n  release() {\n    if (this.isDone || !this.#holdingInitial) return; // Was never holding or done\n\n    // Setting holding flag to false, computeRaw will change state\n    this.#holding = false;\n    this.compute();\n  }\n}","import { Paths, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\nimport { AdsrBase } from './AdsrBase.js';\nimport type { EnvelopeOpts } from './Types.js';\n\nexport const defaultAdsrOpts = Object.freeze({\n  attackBend: -1,\n  decayBend: -0.3,\n  releaseBend: -0.3,\n  peakLevel: 1,\n  initialLevel: 0,\n  sustainLevel: 0.6,\n  releaseLevel: 0,\n  retrigger: false\n})\n\nexport class AdsrIterator implements Iterator<number> {\n\n  constructor(private adsr: Adsr) {\n\n  }\n\n  next(...args: [] | [ undefined ]): IteratorResult<number> {\n    if (!this.adsr.hasTriggered) {\n      this.adsr.trigger();\n    }\n\n    const c = this.adsr.compute();\n    return {\n      value: c[ 1 ],\n      done: c[ 0 ] === `complete`\n    }\n  }\n\n  get [ Symbol.toStringTag ]() {\n    return `Generator`;\n  }\n}\n/**\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\n * usually in response to an intial trigger.\n *\n * [See the ixfx Guide on Envelopes](https://ixfx.fun/modulation/envelopes/introduction/).\n *\n * @example Setup\n * ```js\n * const env = new Envelopes.Adsr({\n *  attackDuration: 1000,\n *  decayDuration: 200,\n *  sustainDuration: 100\n * });\n * ```\n *\n * Options for envelope are as follows:\n *\n * ```js\n * initialLevel?: number\n * attackBend: number\n * attackDuration: number\n * decayBend: number\n * decayDuration:number\n * sustainLevel: number\n * releaseBend: number\n * releaseDuration: number\n * releaseLevel?: number\n * peakLevel: number\n * retrigger?: boolean\n * shouldLoop: boolean\n * ```\n *\n * If `retrigger` is _false_ (default), a re-triggered envelope continues at current value\n * rather than resetting to `initialLevel`.\n *\n * If `shouldLoop` is true, envelope loops until `release()` is called.\n *\n * @example Using\n * ```js\n * env.trigger(); // Start envelope\n * ...\n * // Get current value of envelope\n * const [state, scaled, raw] = env.compute();\n * ```\n *\n * * `state` is a string, one of the following: 'attack', 'decay', 'sustain', 'release', 'complete'\n * * `scaled` is a value scaled according to the stage's _levels_\n * * `raw` is the progress from 0 to 1 within a stage. ie. 0.5 means we're halfway through a stage.\n *\n * Instead of `compute()`, most usage of the envelope is just fetching the `value` property, which returns the same scaled value of `compute()`:\n *\n * ```js\n * const value = env.value; // Get scaled number\n * ```\n *\n * @example Hold & release\n * ```js\n * env.trigger(true);   // Pass in true to hold\n * ...envelope will stop at sustain stage...\n * env.release();      // Release into decay\n * ```\n *\n * Check if it's done:\n *\n * ```js\n * env.isDone; // True if envelope is completed\n * ```\n *\n * Envelope has events to track activity: 'change' and 'complete':\n *\n * ```\n * env.addEventListener(`change`, ev => {\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\n * })\n * ```\n * \n * It's also possible to iterate over the values of the envelope:\n * ```js\n * const env = new Envelopes.Adsr();\n * for await (const v of env) {\n *  // v is the numeric value\n *  await Flow.sleep(100); // Want to pause a little to give envelope time to run\n * }\n * // Envelope has finished\n * ```\n */\nexport class Adsr extends AdsrBase implements Iterable<number> {\n  readonly attackPath: Paths.Path;\n  readonly decayPath: Paths.Path;\n  readonly releasePath: Paths.Path;\n\n  readonly initialLevel;\n  readonly peakLevel;\n  readonly releaseLevel;\n  readonly sustainLevel;\n\n  readonly attackBend;\n  readonly decayBend;\n  readonly releaseBend;\n\n  protected initialLevelOverride: number | undefined;\n  readonly retrigger: boolean;\n  private releasedAt: number | undefined;\n\n  constructor(opts: EnvelopeOpts = {}) {\n    super(opts);\n\n    this.retrigger = opts.retrigger ?? defaultAdsrOpts.retrigger;\n\n    this.initialLevel = opts.initialLevel ?? defaultAdsrOpts.initialLevel;\n    this.peakLevel = opts.peakLevel ?? defaultAdsrOpts.peakLevel;\n    this.releaseLevel = opts.releaseLevel ?? defaultAdsrOpts.releaseLevel;\n    this.sustainLevel = opts.sustainLevel ?? defaultAdsrOpts.sustainLevel;\n\n    this.attackBend = opts.attackBend ?? defaultAdsrOpts.attackBend;\n    this.releaseBend = opts.releaseBend ?? defaultAdsrOpts.releaseBend;\n    this.decayBend = opts.decayBend ?? defaultAdsrOpts.decayBend;\n\n    const max = 1;\n    this.attackPath = Beziers.toPath(\n      Beziers.quadraticSimple(\n        { x: 0, y: this.initialLevel },\n        { x: max, y: this.peakLevel },\n        -this.attackBend\n      )\n    );\n    this.decayPath = Beziers.toPath(\n      Beziers.quadraticSimple(\n        { x: 0, y: this.peakLevel },\n        { x: max, y: this.sustainLevel },\n        -this.decayBend\n      )\n    );\n    this.releasePath = Beziers.toPath(\n      Beziers.quadraticSimple(\n        { x: 0, y: this.sustainLevel },\n        { x: max, y: this.releaseLevel },\n        -this.releaseBend\n      )\n    );\n  }\n\n  protected onTrigger() {\n    this.initialLevelOverride = undefined;\n    if (!this.retrigger) {\n      const [ _stage, scaled, _raw ] = this.compute(true, false);\n      //console.log(`Adsr stage: ${ _stage } scaled: ${ scaled } raw: ${ _raw }`);\n\n      if (!Number.isNaN(scaled) && scaled > 0) {\n        this.initialLevelOverride = scaled;\n      }\n    }\n  }\n\n  [ Symbol.iterator ](): Iterator<number> {\n    return new AdsrIterator(this);\n  }\n\n  /**\n   * Returns the scaled value\n   * Same as .compute()[1]\n   */\n  get value(): number {\n    return this.compute(true)[ 1 ];\n  }\n\n  /**\n   * Compute value of envelope at this point in time.\n   *\n   * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\n   * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\n   */\n  compute(\n    allowStateChange = true,\n    allowLooping = true\n  ): [ stage: string | undefined, scaled: number, raw: number ] {\n    const [ stage, amt ] = super.computeRaw(allowStateChange, allowLooping);\n    //console.log(`Adsr.compute: stage: ${ stage } amt: ${ amt }!`);\n    // Stage is undefined when envelope is complete or underlying timer is undefined\n    if (stage === undefined) return [ undefined, Number.NaN, Number.NaN ];\n    let v;\n    switch (stage) {\n      case `attack`: {\n        v = this.attackPath.interpolate(amt).y;\n        if (this.initialLevelOverride !== undefined) {\n          v = scale(v, 0, 1, this.initialLevelOverride, 1);\n        }\n        this.releasedAt = v;\n        break;\n      }\n      case `decay`: {\n        v = this.decayPath.interpolate(amt).y;\n        this.releasedAt = v;\n        break;\n      }\n      case `sustain`: {\n        v = this.sustainLevel;\n        this.releasedAt = v;\n        break;\n      }\n      case `release`: {\n        v = this.releasePath.interpolate(amt).y;\n        // Bound release level to the amp level that we released at.\n        // ie. when release happens before a stage completes\n        if (this.releasedAt !== undefined) {\n          v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\n        }\n        break;\n      }\n      case `complete`: {\n        v = this.releaseLevel;\n        this.releasedAt = undefined;\n        break;\n      }\n      default: {\n        throw new Error(`Unknown state: ${ stage }`);\n      }\n    }\n    return [ stage, v, amt ];\n  }\n}","import { Adsr } from './Adsr.js';\nimport type { AdsrIterableOpts, EnvelopeOpts } from './Types.js';\nimport { resolveWithFallbackSync } from '@ixfx/core';\nimport { repeat } from '@ixfx/flow';\n\nexport * from './Types.js';\nexport * from './Adsr.js';\nexport * from './AdsrBase.js';\n\n/**\n * Returns a function that iterates over an envelope\n * ```js\n * const e = Envelopes.adsr();\n * \n * e(); // Yields current value\n * ```\n * \n * Starts the envelope the first time the return function is called.\n * When the envelope finishes, it continues to return the `releaseLevel` of the envelope.\n * \n * Options can be provided to set the shape of the envelope as usual, eg:\n * ```js\n * const e = Envelopes.adsr({\n *  attackDuration: 1000,\n *  releaseDuration: 500\n * });\n * ```\n * @param opts \n * @returns \n */\nexport const adsr = (opts: EnvelopeOpts = {}) => {\n  const envelope = new Adsr(opts);\n  const finalValue = envelope.releaseLevel;\n  const iterator = envelope[ Symbol.iterator ]();\n  return () => resolveWithFallbackSync(iterator, { overrideWithLast: true, value: finalValue });\n}\n\n/**\n * Creates and runs an envelope, sampling its values at `sampleRateMs`.\n * Note that if the envelope loops, iterator never returns.\n *\n * @example Init\n * ```js\n * import { Envelopes } from '@ixfx/modulation.js';\n * import { IterableAsync } from  '@ixfx/iterable.js';\n *\n * const opts = {\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * ```\n *\n * ```js\n * //  Add data to array\n * // Sample an envelope every 20ms into an array\n * const data = await IterableAsync.toArray(Envelopes.adsrIterable(opts, 20));\n * ```\n *\n * ```js\n * // Iterate with `for await`\n * // Work with values as sampled\n * for await (const v of Envelopes.adsrIterable(opts, 5)) {\n *  // Work with envelope value `v`...\n * }\n * ```\n * @param opts Envelope options\n * @returns\n */\nexport async function* adsrIterable(\n  opts: AdsrIterableOpts\n): AsyncGenerator<number> {\n  const envelope = new Adsr(opts.env);\n  const sampleRateMs = opts.sampleRateMs ?? 100;\n  envelope.trigger();\n\n  const r = repeat<number>(() => envelope.value, {\n    while: () => !envelope.isDone,\n    delay: sampleRateMs,\n    signal: opts.signal,\n  })\n  for await (const v of r) {\n    yield v;\n  }\n}\n","/**\n * Acknowledgements: much of the work here is an adapation from Daniel Shiffman's excellent _The Nature of Code_ website.\n */\nimport { Points, Polar, Rects } from '@ixfx/geometry';\nimport { clamp } from '@ixfx/numbers';\nimport { interpolateAngle } from '@ixfx/numbers';\n\n/**\n * Logic for applying mass\n */\nexport type MassApplication = `dampen` | `multiply` | `ignored`;\n\n/**\n * Basic properties of a thing that can be\n * affected by forces\n */\nexport type ForceAffected = {\n  /**\n   * Position. Probably best to use relative coordinates\n   */\n  readonly position?: Points.Point;\n  /**\n   * Velocity vector.\n   * Probably don't want to assign this yourself, but rather have it computed based on acceleration and applied forces\n   */\n  readonly velocity?: Points.Point;\n  /**\n   * Acceleration vector. Most applied forces will alter the acceleration, culminating in a new velocity being set and the\n   * acceleraton value zeroed\n   */\n  readonly acceleration?: Points.Point;\n  /**\n   * Mass. The unit is undefined, again best to think of this being on a 0..1 scale. Mass is particularly important\n   * for the attraction/repulsion force, but other forces can incorporate mass too.\n   */\n  readonly mass?: number;\n\n  readonly angularAcceleration?: number;\n\n  readonly angularVelocity?: number;\n\n  readonly angle?: number;\n};\n\n/**\n * A function that updates values of a thing.\n *\n * These can be created using the xxxForce functions, eg {@link attractionForce}, {@link accelerationForce}, {@link magnitudeForce}, {@link velocityForce}\n */\nexport type ForceFn = (t: ForceAffected) => ForceAffected;\n\n/**\n * A vector to apply to acceleration or a force function\n */\nexport type ForceKind = Points.Point | ForceFn | null;\n\n/**\n * Throws an error if `t` is not of the `ForceAffected` shape.\n * @param t\n * @param name\n */\nexport const guard = (t: ForceAffected, name = `t`) => {\n  if (t === undefined) {\n    throw new Error(`Parameter ${ name } is undefined. Expected ForceAffected`);\n  }\n  if (t === null) {\n    throw new Error(`Parameter ${ name } is null. Expected ForceAffected`);\n  }\n  if (typeof t !== `object`) {\n    throw new TypeError(\n      `Parameter ${ name } is type ${ typeof t }. Expected object of shape ForceAffected`\n    );\n  }\n};\n\n/**\n * `constrainBounce` yields a function that affects `t`'s position and velocity such that it\n * bounces within bounds.\n *\n * ```js\n * // Setup bounce with area constraints\n * // Reduce velocity by 10% with each impact\n * const b = constrainBounce({ width:200, height:500 }, 0.9);\n *\n * // Thing\n * const t = {\n *  position: { x: 50,  y: 50 },\n *  velocity: { x: 0.3, y: 0.01 }\n * };\n *\n * // `b` returns an altereted version of `t`, with the\n * // bounce logic applied.\n * const bounced = b(t);\n * ```\n *\n * `dampen` parameter allows velocity to be dampened with each bounce. A value\n * of 0.9 for example reduces velocity by 10%. A value of 1.1 will increase velocity by\n * 10% with each bounce.\n * @param bounds Constraints of area\n * @param dampen How much to dampen velocity by. Defaults to 1 meaning there is no damping.\n * @returns A function that can perform bounce logic\n */\nexport const constrainBounce = (\n  bounds?: Rects.Rect,\n  dampen = 1\n) => {\n  if (!bounds) bounds = { width: 1, height: 1 }\n  const minX = Rects.getEdgeX(bounds, `left`);\n  const maxX = Rects.getEdgeX(bounds, `right`);\n  const minY = Rects.getEdgeY(bounds, `top`);\n  const maxY = Rects.getEdgeY(bounds, `bottom`);\n\n  return (t: ForceAffected): ForceAffected => {\n    const position = computePositionFromVelocity(\n      t.position ?? Points.Empty,\n      t.velocity ?? Points.Empty\n    );\n\n    let velocity = t.velocity ?? Points.Empty;\n    let { x, y } = position;\n\n    if (x > maxX) {\n      x = maxX;\n      velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n    } else if (x < minX) {\n      x = minX;\n      velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n    }\n\n    if (y > maxY) {\n      y = maxY;\n      velocity = Points.multiplyScalar(Points.invert(velocity, `y`), dampen);\n    } else if (position.y < minY) {\n      y = minY;\n      velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `y`);\n    }\n\n    return Object.freeze({\n      ...t,\n      position: { x, y },\n      velocity,\n    });\n  };\n};\n\n/**\n * For a given set of attractors, returns a function that a sets acceleration of attractee.\n * Keep note though that this bakes-in the values of the attractor, it won't reflect changes to their state. For dynamic\n * attractors, it might be easier to use `computeAttractionForce`.\n *\n * @example Force\n * ```js\n * const f = Forces.attractionForce(sun, gravity);\n * earth = Forces.apply(earth, f);\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n * @param attractors\n * @param gravity\n * @param distanceRange\n * @returns\n */\nexport const attractionForce =\n  (\n    attractors: readonly ForceAffected[],\n    gravity: number,\n    distanceRange: { readonly min?: number; readonly max?: number } = {}\n  ) =>\n    (attractee: ForceAffected): ForceAffected => {\n      let accel = attractee.acceleration ?? Points.Empty;\n      for (const a of attractors) {\n        if (a === attractee) continue;\n\n        const f = computeAttractionForce(a, attractee, gravity, distanceRange);\n        accel = Points.sum(accel, f);\n      }\n      return {\n        ...attractee,\n        acceleration: accel,\n      };\n    };\n\n/**\n * Computes the attraction force between two things.\n * Value for `gravity` will depend on what range is used for `mass`. It's probably a good idea\n * to keep mass to mean something relative - ie 1 is 'full' mass, and adjust the `gravity`\n * value until it behaves as you like. Keeping mass in 0..1 range makes it easier to apply to\n * visual properties later.\n *\n * @example Attractee and attractor, gravity 0.005\n * ```js\n * const attractor = { position: { x:0.5, y:0.5 }, mass: 1 };\n * const attractee = { position: Points.random(), mass: 0.01 };\n * attractee = Forces.apply(attractee, Forces.computeAttractionForce(attractor, attractee, 0.005));\n * ```\n *\n * @example Many attractees for one attractor, gravity 0.005\n * ```js\n * attractor =  { position: { x:0.5, y:0.5 }, mass: 1 };\n * attractees = attractees.map(a => Forces.apply(a, Forces.computeAttractionForce(attractor, a, 0.005)));\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n *\n * `attractor` thing attracting (eg, earth)\n * `attractee` thing being attracted (eg. satellite)\n *\n *\n * `gravity` will have to be tweaked to taste.\n * `distanceRange` clamps the computed distance. This affects how tightly the particles will orbit and can also determine speed. By default it is 0.001-0.7\n * @param attractor Attractor (eg earth)\n * @param attractee Attractee (eg satellite)\n * @param gravity Gravity constant\n * @param distanceRange Min/max that distance is clamped to.\n * @returns\n */\nexport const computeAttractionForce = (\n  attractor: ForceAffected,\n  attractee: ForceAffected,\n  gravity: number,\n  distanceRange: { readonly min?: number; readonly max?: number } = {}\n): Points.Point => {\n  if (attractor.position === undefined) {\n    throw new Error(`attractor.position not set`);\n  }\n  if (attractee.position === undefined) {\n    throw new Error(`attractee.position not set`);\n  }\n\n  const distributionRangeMin = distanceRange.min ?? 0.01;\n  const distributionRangeMax = distanceRange.max ?? 0.7;\n\n  // Vector between objects\n  const f = Points.normalise(\n    Points.subtract(attractor.position, attractee.position)\n  );\n\n  // Distance\n  const d = clamp(Points.distance(f), distributionRangeMin, distributionRangeMax);\n\n  // Multiply vector by gravity, scaled by mass of things and distance\n  return Points.multiplyScalar(\n    f,\n    (gravity * (attractor.mass ?? 1) * (attractee.mass ?? 1)) / (d * d)\n  );\n};\n\nexport type TargetOpts = {\n  /**\n   * Acceleration scaling. Defaults to 0.001\n   */\n  readonly diminishBy?: number;\n  /**\n   * If distance is less than this range, don't move.\n   * If undefined (default), will try to get an exact position\n   */\n  readonly range?: Points.Point;\n};\n/**\n * A force that moves a thing toward `targetPos`.\n *\n * ```js\n * const t = Forces.apply(t, Forces.targetForce(targetPos));\n * ```\n * @param targetPos\n * @param opts\n * @returns\n */\nexport const targetForce = (targetPos: Points.Point, opts: TargetOpts = {}) => {\n  const fn = (t: ForceAffected): ForceAffected => {\n    const accel = computeAccelerationToTarget(\n      targetPos,\n      t.position ?? { x: 0.5, y: 0.5 },\n      opts\n    );\n    return {\n      ...t,\n      acceleration: Points.sum(t.acceleration ?? Points.Empty, accel),\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns `pt` with x and y set to `setpoint` if either's absolute value is below `v`\n * @param pt\n * @param v\n * @returns\n */\n// const roundTo = (pt: Point, v: number, setpoint: number): Point => {\n//   const x = Math.abs(pt.x);\n//   const y = Math.abs(pt.y);\n\n//   if (x < v && y < v) return { x: setpoint, y: setpoint };\n//   if (x < v) return { x: setpoint, y: pt.y };\n//   if (y < v) return { x: pt.x, y: setpoint };\n//   return pt;\n// };\n\n/**\n * Apply a series of force functions or forces to `t`. Null/undefined entries are skipped silently.\n * It also updates the velocity and position of the returned version of `t`.\n *\n * ```js\n * // Wind adds acceleration. Force is dampened by mass\n * const wind = Forces.accelerationForce({ x: 0.00001, y: 0 }, `dampen`);\n *\n * // Gravity adds acceleration. Force is magnified by mass\n * const gravity = Forces.accelerationForce({ x: 0, y: 0.0001 }, `multiply`);\n *\n * // Friction is calculated based on velocity. Force is magnified by mass\n * const friction = Forces.velocityForce(0.00001, `multiply`);\n *\n *  // Flip movement velocity if we hit a wall. And dampen it by 10%\n * const bouncer = Forces.constrainBounce({ width: 1, height: 1 }, 0.9);\n *\n * let t = {\n *  position: Points.random(),\n *  mass: 0.1\n * };\n *\n * // Apply list of forces, returning a new version of the thing\n * t = Forces.apply(t,\n *   gravity,\n *   wind,\n *   friction,\n *   bouncer\n * );\n * ```\n */\nexport const apply = (\n  t: ForceAffected,\n  ...accelForces: readonly ForceKind[]\n): ForceAffected => {\n  if (t === undefined) throw new Error(`t parameter is undefined`);\n\n  for (const f of accelForces) {\n    if (f === null || f === undefined) continue;\n    t = typeof f === `function` ? f(t) : {\n      ...t,\n      acceleration: Points.sum(t.acceleration ?? Points.Empty, f),\n    };\n  }\n\n  // Integate velocity from acceleration\n  const velo = computeVelocity(\n    t.acceleration ?? Points.Empty,\n    t.velocity ?? Points.Empty\n  );\n\n  // Compute position\n  const pos = computePositionFromVelocity(t.position ?? Points.Empty, velo);\n\n  const ff: ForceAffected = {\n    ...t,\n    position: pos,\n    velocity: velo,\n    // Clear accel, because it has been integrated into velocity\n    acceleration: Points.Empty,\n  };\n  return ff;\n};\n\n/**\n * Apples `vector` to acceleration, scaling according to mass, based on the `mass` option.\n * It returns a function which can later be applied to a thing.\n *\n * ```js\n * // Acceleration vector of (0.1, 0), ie moving straight on horizontal axis\n * const f = Forces.accelerationForce({ x:0.1, y:0 }, `dampen`);\n *\n * // Thing to move\n * let t = { position: ..., acceleration: ... }\n *\n * // Apply force\n * t = f(t);\n * ```\n * @param vector\n * @returns Force function\n */\nexport const accelerationForce =\n  (vector: Points.Point, mass: MassApplication = `ignored`): ForceFn =>\n    (t: ForceAffected) =>\n      Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vector, t, mass), //Points.sum(t.acceleration ?? Points.Empty, op(t.mass ?? 1))\n      });\n\n/**\n * Returns an acceleration vector with mass either dampening or multiplying it.\n * The passed-in `thing` is not modified.\n *\n * ```js\n * // Initial acceleration vector\n * const accel = { x: 0.1, y: 0};\n *\n * // Thing being moved\n * const thing = { mass: 0.5, position: ..., acceleration: ... }\n *\n * // New acceleration vector, affected by mass of `thing`\n * const accelWithMass = massApplyAccel(accel, thing, `dampen`);\n * ```\n * Mass of thing can be factored in, according to `mass` setting. Use `dampen`\n * to reduce acceleration with greater mass of thing. Use `multiply` to increase\n * the effect of acceleration with a greater mass of thing. `ignored` means\n * mass is not taken into account.\n *\n * If `t` has no mass, the `mass` setting is ignored.\n *\n * This function is used internally by the predefined forces.\n *\n * @param vector Vector force\n * @param thing Thing being affected\n * @param mass How to factor in mass of thing (default ignored)\n * @returns Acceleration vector\n */\nconst massApplyAccel = (\n  vector: Points.Point,\n  thing: ForceAffected,\n  mass: MassApplication = `ignored`\n) => {\n\n  let op;\n  switch (mass) {\n    case `dampen`: {\n      op = (mass: number) => Points.divide(vector, mass, mass);\n\n      break;\n    }\n    case `multiply`: {\n      op = (mass: number) => Points.multiply(vector, mass, mass);\n\n      break;\n    }\n    case `ignored`: {\n      op = (_mass: number) => vector;\n\n      break;\n    }\n    default: {\n      throw new Error(\n\n        `Unknown 'mass' parameter '${ mass }. Expected 'dampen', 'multiply' or 'ignored'`\n      );\n    }\n  }\n  return Points.sum(thing.acceleration ?? Points.Empty, op(thing.mass ?? 1));\n  // if (t.mass) {\n  //   if (dampen) return Points.sum(t.acceleration ?? Points.Empty, Points.divide(v, t.mass ?? 1));\n  //   else return Points.sum(t.acceleration ?? Points.Empty, Points.multiply(v, t.mass ?? 1));\n  // }\n  // return v;\n};\n\n/**\n * A force based on the square of the thing's velocity.\n * It's like {@link velocityForce}, but here the velocity has a bigger impact.\n *\n * ```js\n * const thing = {\n *  position: { x: 0.5, y:0.5 },\n *  velocity: { x: 0.001, y:0 }\n * };\n * const drag = magnitudeForce(0.1);\n *\n * // Apply drag force to thing, returning result\n * const t = Forces.apply(thing, drag);\n * ```\n * @param force Force value\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const magnitudeForce =\n  (force: number, mass: MassApplication = `ignored`): ForceFn =>\n    (t: ForceAffected): ForceAffected => {\n      if (t.velocity === undefined) return t;\n\n      const mag = Points.distance(Points.normalise(t.velocity));\n      const magSq = force * mag * mag;\n      const vv = Points.multiplyScalar(Points.invert(t.velocity), magSq);\n      return Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vv, t, mass),\n      });\n    };\n\n/**\n * Null force does nothing\n * @returns A force that does nothing\n */\nexport const nullForce = (t: ForceAffected): ForceAffected => t;\n\n/**\n * Force calculated from velocity of object. Reads velocity and influences acceleration.\n *\n * ```js\n * let t = { position: Points.random(), mass: 0.1 };\n * const friction = velocityForce(0.1, `dampen`);\n *\n * // Apply force, updating position and velocity\n * t = Forces.apply(t, friction);\n * ```\n * @param force Force\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const velocityForce = (\n  force: number,\n  mass: MassApplication\n): ForceFn => {\n  // Invert velocity and then multiply by force\n  const pipeline = Points.pipeline(\n    // Points.normalise,\n    Points.invert,\n    (v: Points.Point) => Points.multiplyScalar(v, force)\n  );\n\n  return (t: ForceAffected): ForceAffected => {\n    if (t.velocity === undefined) return t;\n\n    // Apply pipeline\n    const v = pipeline(t.velocity);\n    return Object.freeze({\n      ...t,\n      acceleration: massApplyAccel(v, t, mass),\n    });\n  };\n};\n\n/**\n * Sets angle, angularVelocity and angularAcceleration based on\n *  angularAcceleration, angularVelocity, angle\n * @returns\n */\nexport const angularForce = () => (t: ForceAffected) => {\n  const accumulator = t.angularAcceleration ?? 0;\n  const vel = t.angularVelocity ?? 0;\n  const angle = t.angle ?? 0;\n\n  const v = vel + accumulator;\n  const a = angle + v;\n\n  return Object.freeze({\n    ...t,\n    angle: a,\n    angularVelocity: v,\n    angularAcceleration: 0,\n  });\n};\n\n// export const positionFromAngleForce = () => (t:ForceAffected) => {\n//   return Object.freeze({\n//     ...t,\n//     position: computePositionFromAngle()\n//   });\n// };\n\n/**\n * Yields a force function that applies the thing's acceleration.x to its angular acceleration.\n * @param scaling Use this to scale the accel.x value. Defaults to 20 (ie accel.x*20). Adjust if rotation is too much or too little\n * @returns\n */\nexport const angleFromAccelerationForce =\n  (scaling = 20) =>\n    (t: ForceAffected) => {\n      const accel = t.acceleration ?? Points.Empty;\n      return Object.freeze({\n        ...t,\n        angularAcceleration: accel.x * scaling,\n      });\n    };\n\n/**\n * Yields a force function that applies the thing's velocity to its angle.\n * This will mean it points in the direction of travel.\n * @param interpolateAmt If provided, the angle will be interpolated toward by this amount. Defaults to 1, no interpolation\n * @returns\n */\nexport const angleFromVelocityForce =\n  (interpolateAmt = 1) =>\n    (t: ForceAffected) => {\n      const a = Points.angleRadian(t.velocity ?? Points.Empty);\n      return Object.freeze({\n        ...t,\n        angle:\n          interpolateAmt < 1\n            ? interpolateAngle(interpolateAmt, t.angle ?? 0, a)\n            : a,\n      });\n    };\n\n/**\n * Spring force\n *\n *  * ```js\n * // End of spring that moves\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Anchored other end of spring\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const springForce = Forces.springForce(pinnedAt, 0.4);\n *\n * continuously(() => {\n *  // Apply force\n *  thing = Forces.apply(thing, springForce);\n * }).start();\n * ```\n * [Read more](https://www.joshwcomeau.com/animation/a-friendly-introduction-to-spring-physics/)\n *\n * @param pinnedAt Anchored end of the spring\n * @param restingLength Length of spring-at-rest (default: 0.5)\n * @param k Spring stiffness (default: 0.0002)\n * @param damping Damping factor to apply, so spring slows over time. (default: 0.995)\n * @returns\n */\nexport const springForce =\n  (\n    pinnedAt: Points.Point,\n    restingLength = 0.5,\n    k = 0.0002,\n    damping = 0.999\n  ) =>\n    (t: ForceAffected): ForceAffected => {\n      const direction = Points.subtract(t.position ?? Points.Empty, pinnedAt);\n      const mag = Points.distance(direction);\n      const stretch = Math.abs(restingLength - mag);\n\n      const f = Points.pipelineApply(direction, Points.normalise, (p) =>\n        Points.multiplyScalar(p, -k * stretch)\n      );\n\n      const accel = massApplyAccel(f, t, `dampen`);\n      const velo = computeVelocity(\n        accel ?? Points.Empty,\n        t.velocity ?? Points.Empty\n      );\n      const veloDamped = Points.multiply(velo, damping, damping);\n      return {\n        ...t,\n        velocity: veloDamped,\n        acceleration: Points.Empty,\n      };\n    };\n\n/**\n * Pendulum force options\n */\nexport type PendulumOpts = {\n  /**\n   * Length of 'string' thing is hanging from. If\n   * undefined, the current length between thing and\n   * pinnedAt is used.\n   */\n  readonly length?: number;\n  /**\n   * Max speed of swing. Slower speed can reach equilibrium faster, since it\n   * might not swing past resting point.\n   * Default 0.001.\n   */\n  readonly speed?: number;\n  /**\n   * Damping, how much to reduce velocity. Default 0.995 (ie 0.5% loss)\n   */\n  readonly damping?: number;\n};\n/**\n * The pendulum force swings something back and forth.\n *\n * ```js\n * // Swinger\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Position thing swings from (middle of screen)\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const pendulumForce = Forces.pendulumForce(pinnedAt, { length: 0.4 });\n *\n * continuously(() => {\n *  // Apply force\n *  // Returns a new thing with recalculated angularVelocity, angle and position.\n *  thing = Forces.apply(thing, pendulumForce);\n * }).start();\n * ```\n *\n * [Read more](https://natureofcode.com/book/chapter-3-oscillation/)\n *\n * @param pinnedAt Location to swing from (x:0.5, y:0.5 default)\n * @param opts Options\n * @returns\n */\nexport const pendulumForce =\n  (pinnedAt?: Points.Point, opts: PendulumOpts = {}) =>\n    (t: ForceAffected): ForceAffected => {\n      if (!pinnedAt) pinnedAt = { x: 0, y: 0 };\n      const length =\n        opts.length ?? Points.distance(pinnedAt, t.position ?? Points.Empty);\n      const speed = opts.speed ?? 0.001;\n      const damping = opts.damping ?? 0.995;\n\n      let angle = t.angle;\n      if (angle === undefined) {\n\n        if (t.position) {\n          angle = Points.angleRadian(pinnedAt, t.position) - Math.PI / 2;\n        } else {\n          angle = 0; // Position wherever\n        }\n      }\n      const accel = ((-1 * speed) / length) * Math.sin(angle);\n      const v = (t.angularVelocity ?? 0) + accel;\n      angle += v;\n\n      return Object.freeze({\n        angularVelocity: v * damping,\n        angle,\n        position: computePositionFromAngle(length, angle + Math.PI / 2, pinnedAt),\n      });\n    };\n\n/**\n * Compute velocity based on acceleration and current velocity\n * @param acceleration Acceleration\n * @param velocity Velocity\n * @param velocityMax If specified, velocity will be capped at this value\n * @returns\n */\nexport const computeVelocity = (\n  acceleration: Points.Point,\n  velocity: Points.Point,\n  velocityMax?: number\n): Points.Point => {\n  const p = Points.sum(velocity, acceleration);\n  return velocityMax === undefined ? p : Points.clampMagnitude(p, velocityMax);\n};\n\n/**\n * Returns the acceleration to get from `currentPos` to `targetPos`.\n *\n * @example Barebones usage:\n * ```js\n * const accel = Forces.computeAccelerationToTarget(targetPos, currentPos);\n * const vel = Forces.computeVelocity(accel, currentVelocity);\n *\n * // New position:\n * const pos = Points.sum(currentPos, vel);\n * ```\n *\n * @example Implementation:\n * ```js\n * const direction = Points.subtract(targetPos, currentPos);\n * const accel = Points.multiply(direction, diminishBy);\n * ```\n * @param currentPos Current position\n * @param targetPos Target position\n * @param opts Options\n * @returns\n */\nexport const computeAccelerationToTarget = (\n  targetPos: Points.Point,\n  currentPos: Points.Point,\n  opts: TargetOpts = {}\n) => {\n  const diminishBy = opts.diminishBy ?? 0.001;\n\n  // Compare to current position of thing to get vector direction\n  const direction = Points.subtract(targetPos, currentPos);\n\n  if (opts.range && // If direction is less than range, return { x: 0, y: 0}\n    Points.compare(Points.abs(direction), opts.range) === -2) {\n    return Points.Empty;\n  }\n\n  // Diminish vector to make a meaningful acceleration\n  return Points.multiplyScalar(direction, diminishBy);\n};\n\n/**\n * Compute a new position based on existing position and velocity vector\n * @param position Position Current position\n * @param velocity Velocity vector\n * @returns Point\n */\nexport const computePositionFromVelocity = (\n  position: Points.Point,\n  velocity: Points.Point\n): Points.Point => Points.sum(position, velocity);\n\n/**\n * Compute a position based on distance and angle from origin\n * @param distance Distance from origin\n * @param angleRadians Angle, in radians from origin\n * @param origin Origin point\n * @returns Point\n */\nexport const computePositionFromAngle = (\n  distance: number,\n  angleRadians: number,\n  origin: Points.Point\n) => Polar.toCartesian(distance, angleRadians, origin);\n\nconst _angularForce = angularForce();\nconst _angleFromAccelerationForce = angleFromAccelerationForce();\n\n/**\n * A force that orients things according to direction of travel.\n *\n * Under the hood, it applies:\n * * angularForce,\n * * angleFromAccelerationForce, and\n * * angleFromVelocityForce\n * @param interpolationAmt\n * @returns\n */\nexport const orientationForce = (interpolationAmt = 0.5): ForceFn => {\n  const angleFromVel = angleFromVelocityForce(interpolationAmt);\n\n  return (t: ForceAffected) => {\n    t = _angularForce(t);\n    t = _angleFromAccelerationForce(t);\n    t = angleFromVel(t);\n    return t;\n  };\n};\n","import type { ModFunction } from \"./types.js\";\n\n/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"@ixfx/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @returns Value\n */\nexport const cubicBezierShape =\n  (b: number, d: number): ModFunction =>\n    (t: number) => {\n      const s = 1 - t;\n      const s2 = s * s;\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n    };\n","export type Drifter = {\n  update(v: number): number;\n  reset(): void;\n};\n\n/**\n * WIP\n * Returns a {@link Drifter} that moves a value over time.\n *\n * It keeps track of how much time has elapsed, accumulating `driftAmtPerMs`.\n * The accumulated drift is wrapped on a 0..1 scale.\n * ```js\n * // Set up the drifer\n * const d = drif(0.001);\n *\n * d.update(1.0);\n * // Returns 1.0 + accumulated drift\n * ```\n * @param driftAmtPerMs\n * @returns\n */\nexport const drift = (driftAmtPerMs: number): Drifter => {\n  //eslint-disable-next-line functional/no-let\n  let lastChange = performance.now();\n\n  const update = (v: number = 1) => {\n    const elapsed = performance.now() - lastChange;\n\n    const amt = (driftAmtPerMs * elapsed) % 1;\n    lastChange = performance.now();\n    const calc = (v + amt) % 1;\n    return calc;\n  };\n\n  const reset = () => {\n    lastChange = performance.now();\n  };\n  return { update, reset };\n};\n","export const piPi = Math.PI * 2;","import { clamp, wrap, type BasicInterpolateOptions } from \"@ixfx/numbers\";\nimport { ofTotal } from \"@ixfx/flow\";\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { get as getEasing, type EasingName } from './easing/index.js';\nimport type { Interval } from \"@ixfx/core\";\nimport { piPi } from \"./util/pi-pi.js\";\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type InterpolateOptions = BasicInterpolateOptions & {\n  easing: EasingName,\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from '@ixfx/numbers.js';\n * \n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from '@ixfx/numbers.js';\n * \n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from '@ixfx/numbers.js';\n * \n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from '@ixfx/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    resultThrow(\n      numberTest(_a, ``, `a`),\n      numberTest(_b, ``, `b`),\n      numberTest(_amt, ``, `amount`)\n    );\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easer = getEasing(o.easing);\n      if (!easer) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easer;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    resultThrow(numberTest(amount, ``, `amount`));\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * \n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from '@ixfx/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}","import { resultThrow, numberTest } from '@ixfx/guards';\nimport { clamp } from '@ixfx/numbers';\nimport { floatSource as randomFloatFunction, float as randomFloat } from '@ixfx/random';\nimport type { RandomSource } from '@ixfx/random';\n\nexport type JitterOpts = {\n  readonly relative?: number;\n  readonly absolute?: number;\n  readonly clamped?: boolean;\n  readonly source?: RandomSource;\n};\n\nexport type Jitterer = (value: number) => number;\n\n/**\n * Returns a {@link Jitterer} that works with absolute values,\n * ie. values outside of 0..1 range.\n * \n * Jitter amount is _absolute_, meaning a fixed value regardless of input value,\n * or _relative_, meaning it is scaled according to input value.\n * \n * ```js\n * // Jitter by -10 to +10 (absolute value: 10)\n * const j1 = jitterAbsolute({ absolute: 10 });\n * j1(100); // Produces range of 90...110\n * \n * // Jitter by -20 to +20 (relative value 20%)\n * const j2 = jitterAbsolute({ relative: 0.20 });\n * j2(100); // Produces a range of -80...120\n * ```\n * \n * The expected used case is calling `jitterAbsolute` to set up a jitterer\n * and then reusing it with different input values, as above with the `j1` and `j2`.\n * \n * However to use it 'one-off', just call the returned function immediately:\n * ```js\n * const v = jitterAbsolute({ absolute: 10 })(100); // v is in range of 90-110\n * ```\n * \n * When `clamped` is true, return value is clamped to 0...value.\n * That is, rather than the usual bipolar jittering, the jittering only goes below.\n * ```js\n * const j = jitterAbsolute({ absolute: 10, clamped: true })\n * j(100); // Produces range of 90-100\n * ```\n * @param options\n * @returns \n */\nexport const jitterAbsolute = (options: JitterOpts): Jitterer => {\n  const { relative, absolute } = options;\n  const clamped = options.clamped ?? false;\n  const source = options.source ?? Math.random;\n  if (absolute !== undefined) {\n    return (value: number) => {\n      const abs = (source() * absolute * 2) - absolute;\n      const valueNew = value + abs;\n      if (clamped) return clamp(valueNew, 0, value);\n      return valueNew;\n    }\n  }\n  if (relative !== undefined) {\n    return (value: number) => {\n      const rel = value * relative;\n      const abs = (source() * rel * 2) - rel;\n      const valueNew = value + abs;\n      if (clamped) return clamp(valueNew, 0, value);\n      return valueNew;\n    }\n  }\n  throw new Error(`Either absolute or relative fields expected`);\n}\n\n/**\n * Jitters `value` by the absolute `jitter` amount. Returns a function.\n *\n * All values should be on a 0..1 scale, and the return value is by default clamped to 0..1.\n * Pass `clamped:false` as an option to allow for arbitary ranges.\n *\n * `jitter` returns a function that calculates jitter. If you only need a one-off\n * jitter, you can immediately execute the returned function:\n * ```js\n * // Compute 10% jitter of input 0.5\n * const value = jitter({ relative: 0.1 })(0.5);\n * ```\n *\n * However, if the returned jitter function is to be used again,\n * assign it to a variable:\n * ```js\n * const myJitter = jitter({ absolute: 0.5 });\n *\n * // Jitter an input value 1.0\n * const value = myJitter(1);\n * ```\n *\n * A custom source for random numbers can be provided. Eg, use a weighted\n * random number generator:\n *\n * ```js\n * import { weighted } from '@ixfx/random.js';\n * jitter({ relative: 0.1, source: weighted });\n * ```\n *\n * Options\n * * clamped: If false, `value`s out of percentage range can be used and return value may be beyond percentage range. True by default\n * * random: Random source (default is Math.random)\n * @param options Options\n * @returns Function that performs jitter\n */\nexport const jitter = (options: JitterOpts = {}): Jitterer => {\n  const clamped = options.clamped ?? true;\n  let r = (_: number) => 0;\n  if (options.absolute !== undefined) {\n    resultThrow(numberTest(\n      options.absolute,\n      clamped ? `percentage` : `bipolar`,\n      `opts.absolute`\n    ));\n    const absRand = randomFloatFunction({\n      min: -options.absolute,\n      max: options.absolute,\n      source: options.source,\n    });\n    r = (v: number) => v + absRand();\n  } else if (options.relative === undefined) {\n    throw new TypeError(`Either absolute or relative jitter amount is required.`);\n  } else {\n    const rel = options.relative ?? 0.1;\n    resultThrow(numberTest(\n      rel,\n      clamped ? `percentage` : `bipolar`,\n      `opts.relative`\n    ));\n    r = (v: number) =>\n      v +\n      randomFloat({\n        min: -Math.abs(rel * v),\n        max: Math.abs(rel * v),\n        source: options.source,\n      });\n  }\n\n  const compute = (value: number) => {\n    resultThrow(numberTest(value, clamped ? `percentage` : `bipolar`, `value`));\n    let v = r(value);\n    if (clamped) v = clamp(v);\n    return v;\n  };\n  return compute;\n};\n","import { interpolate } from \"@ixfx/numbers\";\nimport type { ModFunction } from \"./types.js\";\n\n/**\n * Mixes in modulation. This is used when you want to\n * fold in a controllable amount of modulation.\n * \n * For example, we have a base value of 0.5 (50%) that we want to modulate\n * by 0.9 (90%). That is, reduce its value by 10%. `mix` allows us\n * to slowly ramp up to the fully modulated value.\n * \n * ```js\n * // When 'amt' is 0, modulation doesn't affect value at all,\n * // original is returned\n * mix(0, 0.5, 0.9); // 0.5\n * // Mixing in 50% of modulation\n * mix(0.5, 0.5, 0.9); // 0.475\n * // All modulation applied, so now we get 90% of 0.5\n * mix(1, 0.5, 0.9); // 0.45 (ie. 90% of 0.5)\n * ```\n * @param amount Amount of modulation (0..1). 0 means modulation value has no effect\n * @param original Original value to modulate\n * @param modulation Modulation amount (0..1)\n * @returns \n */\nexport const mix = (amount: number, original: number, modulation: number) => {\n  const m = modulation * amount;\n  const base = (1 - amount) * original;\n  return base + (original * m);\n};\n\n\n/**\n * Returns a modulator that mixes between two modulation functions.\n * Both modulators are given the same input value.\n *\n * ```js\n * import { Easings } from \"@ixfx/modulation.js\";\n * // Get a 50/50 mix of two easing functions\n * const mix = Easings.mix(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param balance Mix between a and b\n * @param a\n * @param b\n * @returns Numeric value\n */\nexport const mixModulators = (\n  balance: number,\n  a: ModFunction,\n  b: ModFunction\n): ModFunction => (amt: number) => interpolate(balance, a(amt), b(amt));\n\n/**\n * Returns a 'crossfader` function of two easing functions, synchronised with the progress through the easing.\n * \n * Example `amt` values:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of easingA, 20% of easingB, both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of easingA, 80% of easingB, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower values.\n *\n * ```js\n * import { Easings } from \"@ixfx/modulation.js\";\n * Easings.crossFade(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param a Easing A\n * @param b Easing B\n * @returns Numeric value\n */\nexport const crossfade = (a: ModFunction, b: ModFunction): ModFunction => {\n  return (amt: number) => {\n    const mixer = mixModulators(amt, a, b);\n    return mixer(amt);\n  }\n}","import type { ModFunction } from \"./types.js\";\n\n/**\n * A 'no-op' function. Returns the input value without modification.\n * Useful for when some default is needed\n * @param v \n * @returns \n */\nexport const noop: ModFunction = (v: number) => v;\n","import { resultThrow, numberTest } from '@ixfx/guards';\n\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (\n  interval = 0.1,\n  lower?: number,\n  upper?: number,\n  start?: number,\n  rounding?: number\n) {\n  if (typeof lower === `undefined`) lower = 0;\n  if (typeof upper === `undefined`) upper = 1;\n  if (typeof start === `undefined`) start = lower;\n\n  resultThrow(\n    numberTest(interval, `bipolar`, `interval`),\n    numberTest(upper, `bipolar`, `end`),\n    numberTest(start, `bipolar`, `offset`),\n    numberTest(lower, `bipolar`, `start`)\n  );\n  return pingPong(interval, lower, upper, start, rounding);\n};\n\n/**\n * Ping-pongs continually back and forth a `lower` and `upper` value (both inclusive) by a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (\n  interval: number,\n  lower: number,\n  upper: number,\n  start?: number,\n  rounding?: number\n) {\n  if (lower === undefined) throw new Error(`Parameter 'lower' is undefined`);\n  if (interval === undefined) {\n    throw new Error(`Parameter 'interval' is undefined`);\n  }\n  if (upper === undefined) throw new Error(`Parameter 'upper' is undefined`);\n\n  if (rounding === undefined && interval <= 1 && interval >= 0) {\n    rounding = 10 / interval;\n  } else if (typeof rounding === `undefined`) rounding = 1234;\n\n  if (Number.isNaN(interval)) throw new Error(`interval parameter is NaN`);\n  if (Number.isNaN(lower)) throw new Error(`lower parameter is NaN`);\n  if (Number.isNaN(upper)) throw new Error(`upper parameter is NaN`);\n  if (Number.isNaN(start)) throw new Error(`upper parameter is NaN`);\n\n  if (lower >= upper) throw new Error(`lower must be less than upper`);\n  if (interval === 0) throw new Error(`Interval cannot be zero`);\n  const distance = upper - lower;\n  if (Math.abs(interval) >= distance) {\n    throw new Error(`Interval should be between -${ distance } and ${ distance }`);\n  }\n\n  let incrementing = interval > 0;\n\n  // Scale up values by rounding factor\n  upper = Math.floor(upper * rounding);\n  lower = Math.floor(lower * rounding);\n  interval = Math.floor(Math.abs(interval * rounding));\n\n  if (interval === 0) {\n    throw new Error(`Interval is zero (rounding: ${ rounding })`);\n  }\n  start = start === undefined ? lower : Math.floor(start * rounding);\n  if (start > upper || start < lower) {\n    throw new Error(\n      `Start (${ start / rounding }) must be within lower (${ lower / rounding\n      }) and upper (${ upper / rounding })`\n    );\n  }\n\n  let v = start;\n  yield v / rounding;\n  let firstLoop = true;\n  while (true) {\n    v = v + (incrementing ? interval : -interval);\n    if (incrementing && v >= upper) {\n      incrementing = false;\n      v = upper;\n      if (v === upper && firstLoop) {\n        // Edge case where we start at upper bound and increment\n        v = lower;\n        incrementing = true;\n      }\n    } else if (!incrementing && v <= lower) {\n      incrementing = true;\n      v = lower;\n      if (v === lower && firstLoop) {\n        // Edge case where we start at lower bound and decrement\n        v = upper;\n        incrementing = false;\n      }\n    }\n    yield v / rounding;\n    firstLoop = false;\n  }\n};\n","import * as Flow from '@ixfx/flow';\nimport type { ModFunction, SpringOptions } from './types.js';\n\n/**\n * Produces values according to rough spring physics.\n * \n * ```js\n * import { continuously } from \"@ixfx/flow.js\"\n * import { spring } from \"@ixfx/modulation.js\"\n * \n * const s = spring();\n *\n * continuously(() => {\n *  const result = s.next();\n *  if (result.done) return false; // Exit loop\n *  const value = result.value;\n *  // Value is mostly within 0..1 range but will exceed these limits\n * }, 10).start();\n * ```\n *\n * Parameters to the spring can be provided.\n * ```js\n * import { spring } from \"@ixfx/modulation.js\"\n * const s = spring({\n *  mass: 5,\n *  damping: 10\n *  stiffness: 100\n * });\n * ```\n * \n * If you don't want to use a generator: {@link springValue}.\n * \n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n * \n * @param opts Options for spring\n * @param timerOrFreq Timer to use, or frequency\n */\nexport function* spring(\n  opts: SpringOptions = {},\n  timerOrFreq?: Flow.Timer | number\n) {\n  if (timerOrFreq === undefined) timerOrFreq = Flow.elapsedMillisecondsAbsolute();\n  else if (typeof timerOrFreq === `number`) {\n    timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n  }\n\n  const fn = springShape(opts);\n\n  // Give it some iterations to settle\n  let doneCountdown = opts.countdown ?? 10;\n\n  while (doneCountdown > 0) {\n    const s = fn(timerOrFreq.elapsed / 1000);\n    yield s;\n    if (s === 1) {\n      doneCountdown--;\n    } else {\n      doneCountdown = 100;\n    }\n  }\n}\n\n/**\n * The same as {@link spring} but instead of a generator we get\n * a value. When the spring is done, 1 is returned instead of undefined.\n * \n * ```js\n * import { springValue } from \"@ixfx/modulation.js\"\n * const s = springValue();\n * s(); // 0..1 (roughly - exceeding 1 is possible)\n * ```\n * \n * Options can be provided:\n * ```js\n * import { spring } from \"@ixfx/modulation.js\"\n * const s = springValue({\n *  stiffness: 100,\n *  damping: 10\n * })\n * ```\n * @example Applied\n * ```js\n * import { Modulation, Data } from  \"@ixfx/bundle.js\"\n * let state = {\n *  spring: Modulation.springValue()\n * }\n * \n * function loop() {\n *  const d = Data.resolveFields(state);\n * \n *  // Apply calculated spring value to compute x value\n *  const x = window.innerWidth * d.spring;\n * \n *  \n *  window.requestAnimationFrame(loop);\n * }\n * loop();\n * ```\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n * \n * @param opts \n * @param timerOrFreq \n * @returns \n */\nexport function springValue(opts: SpringOptions = {},\n  timerOrFreq?: Flow.Timer | number) {\n  const s = spring(opts, timerOrFreq);\n  return () => {\n    const v = s.next();\n    if (v.done) return 1;\n    return v.value;\n  }\n}\n\n/**\n * Spring-dynamics modulator.\n * To have spring driven by time or ticks, use {@link spring} or {@link springValue}.\n * This is a lower-level function.\n * @param opts \n * @returns \n */\nexport const springShape = (opts: SpringOptions = {}): ModFunction => {\n  /** MIT License github.com/pushkine/ */\n  const from = 0;\n  const to = 1;\n  const mass = opts.mass ?? 1;\n  const stiffness = opts.stiffness ?? 100;\n  const soft = opts.soft ?? false;\n  const damping = opts.damping ?? 10;\n  const velocity = opts.velocity ?? 0.1;\n  const delta = to - from;\n  if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n    const angularFrequency = -Math.sqrt(stiffness / mass);\n    const leftover = -angularFrequency * delta - velocity;\n    return (t: number) =>\n      to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n  } else {\n    const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n    const leftover =\n      (damping * delta - 2 * mass * velocity) / dampingFrequency;\n    const dfm = (0.5 * dampingFrequency) / mass;\n    const dm = -(0.5 * damping) / mass;\n    return (t: number) =>\n      to -\n      (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n      Math.E ** (t * dm);\n  }\n};","import * as TimeSources from './source/time.js';\nimport type { ModSettable, ModSettableOptions } from './types.js';\n\nexport type TimingSources = `elapsed` | `hertz` | `bpm`\n\n/**\n * A factory function for creating a timing source. It returns\n * a function which creates a designated timer.\n * \n * This is useful in times where you need to recreate timers, eg for reset\n * type of behaviours because the options for the timer to be\n * consolidated in one place.\n * \n * ```js\n * // Get a factory for an elapsed timer\n * const factory = sources(`elapsed`, 1000);\n * \n * // Create the timer\n * let t = factory();\n * \n * // Get a value from the timer\n * const value = t();\n * \n * // Recreate the timer, note we don't need any options\n * t = factory();\n * ```\n * \n * @param source Kind of timer to make\n * @param duration Duration depends on the timer used. Will be milliseconds, hertz or bpm.\n * @param options Options to pass to timer.\n * @returns \n */\nexport const timingSourceFactory = (source: TimingSources, duration: number, options: Partial<ModSettableOptions> = {}): TimingSourceFactory => {\n  switch (source) {\n    case `elapsed`:\n      return () => TimeSources.elapsed(duration, options)\n    case `bpm`:\n      return () => TimeSources.bpm(duration, options);\n    case `hertz`:\n      return () => TimeSources.hertz(duration, options);\n    default:\n      throw new Error(`Unknown source '${ source }'. Expected: 'elapsed', 'hertz' or 'bpm'`);\n  }\n}\n\nexport type TimingSourceFactory = () => ModSettable","import { resultThrow, integerTest } from \"@ixfx/guards\";\nimport type { ModSettable, ModSettableFeedback, ModSettableOptions, ModFunction } from \"./types.js\";\nimport * as Sources from './source/index.js';\n\n/**\n * Function that modulates a wave\n */\nexport type WaveModulator = (feedback?: Partial<WaveShaperFeedback>) => number;\n\nexport type Waveforms = `sine` | `sine-bipolar` | `saw` | `triangle` | `square` | `arc`;\n/**\n * Options for the wave function. Defaults to a sine wave of one cycle per-second.\n */\nexport type WaveOptions = ModSettableOptions & {\n  period: number\n  /**\n   * Clock source. Set this or ticks, hertz, secs or millis\n   * @returns \n   */\n  source: () => number,\n  /**\n   * Waveshape. Default 'sine'\n   */\n  shape: Waveforms\n  /**\n   * Number of ticks per cycle\n   * (Set either ticks, hertz, secs or millis)\n   */\n  ticks: number\n  /**\n   * Number of cycles per second\n   * (Set either ticks, hertz, secs or millis)\n   */\n  hertz: number\n  /**\n   * Number of seconds per cycle. Defaults to one second.\n   * (Set either ticks, hertz, secs or millis)\n   */\n  secs: number\n  /**\n   * Number of milliseconds per cycle\n   * (Set either ticks, hertz, secs or millis)\n   */\n  millis: number\n  /**\n   * If _true_, shape is inverted\n   */\n  invert: boolean\n}\n/**\n * Returns a function that shapes a 0..1 value as a \n * triangle waveform.\n * \n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function triangleShape(period = 1): ModFunction {\n  period = 1 / period;\n  const halfPeriod = period / 2;\n  return (t: number) => {\n    const v = Math.abs((t % period) - halfPeriod);\n    //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n    return v;\n  }\n}\n\n/**\n * Returns a function that shapes a 0..1 value as a square waveform.\n * \n * `period` sets the number of cycles in the 0..1 range.\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function squareShape(period = 1): ModFunction {\n  period = 1 / period;\n  const halfPeriod = period / 2;\n  return (t: number) => {\n    return (t % period) < halfPeriod ? 1 : 0;\n    //console.log(`square: ${ t } v: ${ v }`);\n    //return v;\n  }\n}\n\n/**\n * Returns a function that shapes a 0..1 value as a sine waveform.\n * An input value of 0 will be the very beginning of the wave cycle, input of 1 will be the end,\n * 0.5 will be them middle and so on.\n * ```js\n * const s = sineShape();\n * // Calculate value of sine wave at 50%\n * // By default there is one oscillation, thus\n * // it will be the middle of the cycle.\n * s(0.5); \n * ```\n * \n * The `period` determines number of cycles for\n * an input value of 1.\n * ```js\n * // Oscillate twice in 0..1 range\n * const s = sineShape(2);\n * ```\n * \n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period \n * @returns \n */\nexport function sineShape(period = 1): ModFunction {\n  period = period * (Math.PI * 2);\n  return (t: number) => {\n    const v = (Math.sin(t * period) + 1) / 2;\n    //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n    return v;\n  }\n}\n\n/**\n * A series of arcs, sort of like a bouncing ball.\n * @param period \n * @returns \n */\nexport function arcShape(period = 1): ModFunction {\n  period = period * (Math.PI * 2);\n  return (t: number) => Math.abs(Math.sin(t * period));\n}\n\nexport function sineBipolarShape(period = 1): ModFunction {\n  period = period * (Math.PI * 2);\n  return (t: number) => Math.sin(t * period);\n}\n\n/**\n * Creates a wave modulator by name.\n * \n * Defaults to 5-second sine wave. \n * ```js\n * import { wave } from '@ixfx/modulation.js';\n * // Triangle wave that has a single cycle over two seconds\n * const m = wave({ secs: 2, shape: `triangle`});\n * \n * // Call m() to get current value of wave, eg in\n * // an animation loop\n * const v = m();\n * ```\n * \n * @example\n * ```js\n * import { wave } from '@ixfx/modulation.js';\n * import { resolveFields } from '@ixfx/data.js';\n * \n * const state = {\n *  intensity: wave({secs: 2, shape: `sine` }),\n *  someOtherState: 10\n * }\n * \n * const use = async () {\n *  const { intensity } = await resolveFields(state);\n *  // Do something with intensity value...\n * }\n * ```\n * @param options \n * @returns \n */\nexport function wave(options: Partial<WaveOptions>) {\n  const shape = options.shape ?? `sine`;\n  const invert = options.invert ?? false;\n  const period = options.period ?? 1;\n  let sourceFunction: ModSettable;\n\n  resultThrow(integerTest(period, `aboveZero`, `period`));\n\n  const sourceOptions = {\n    ...options\n  }\n  if (options.ticks) {\n    sourceFunction = Sources.ticks(options.ticks, sourceOptions);\n  } else if (options.hertz) {\n    sourceFunction = Sources.hertz(options.hertz, sourceOptions);\n  } else if (options.millis) {\n    sourceFunction = Sources.elapsed(options.millis, sourceOptions);\n  } else if (options.source) {\n    sourceFunction = options.source;\n  } else {\n    const secs = options.secs ?? 5;\n    sourceFunction = Sources.elapsed(secs * 1000, sourceOptions);\n  }\n\n  let shaperFunction: ModFunction | undefined;\n  switch (shape) {\n    case `saw`:\n      shaperFunction = (v: number) => v;\n      break;\n    case `sine`:\n      shaperFunction = sineShape(period);\n      break;\n    case `sine-bipolar`:\n      shaperFunction = sineBipolarShape(period);\n      break;\n    case `square`:\n      shaperFunction = squareShape(period);\n      break;\n    case `triangle`:\n      shaperFunction = triangleShape(period);\n      break;\n    case `arc`:\n      shaperFunction = arcShape(period);\n      break;\n    default:\n      throw new Error(`Unknown wave shape '${ shape }'. Expected: sine, sine-bipolar, saw, triangle, arc or square`);\n  }\n  return waveFromSource(sourceFunction, shaperFunction, invert);\n}\n\n/**\n * Wave shaper feedback.\n * Feedback allows you to dynamically control tempo for advanced uses.\n */\nexport type WaveShaperFeedback = {\n  /**\n   * Data to feedback to clock source\n   */\n  clock: ModSettableFeedback\n  /**\n   * If set, source function is ignored and this value (0..1) is used instead\n   */\n  override: number\n}\n/**\n * Returns a wave-shaping modulator with a source and shaper as input.\n * ```js\n * // 1Hz sine wave source, \n * const wm = waveFromSource(Sources.hertz(1), sineShape(period));\n * ```\n * @param sourceFunction Signal source \n * @param shaperFunction Modulator\n * @returns \n */\nexport function waveFromSource(sourceFunction: ModSettable, shaperFunction: ModFunction, invert = false): WaveModulator {\n  return (feedback?: Partial<WaveShaperFeedback>) => {\n    let v = sourceFunction(feedback?.clock);\n    if (feedback?.override) v = feedback.override;\n    v = shaperFunction(v);\n    if (invert) v = 1 - v;\n    return v;\n  }\n}\n\n","/**\n * Weighted average\n * \n * @param currentValue \n * @param targetValue \n * @param slowDownFactor \n * @returns \n */\nexport const weightedAverage = (currentValue: number, targetValue: number, slowDownFactor: number) => {\n  return ((currentValue * (slowDownFactor - 1)) + targetValue) / slowDownFactor\n}","import type { RandomSource } from \"@ixfx/random\";\nimport { get, type EasingName } from \"./easing/index.js\";\n\n/**\n * Options for producing weighted distribution\n */\nexport type WeightedOptions = Readonly<{\n  /**\n   * Easing function to use (optional)\n   */\n  easing?: EasingName;\n  /**\n   * Random source (optional)\n   */\n  source?: RandomSource;\n}>\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n *\n * Use {@link weightedSource} to return a function instead.\n *\n * ```js\n * Random.weighted();          // quadIn easing by default, which skews toward low values\n * Random.weighted(`quadOut`); // quadOut favours high values\n * ```\n * @param easingNameOrOptions Options. Uses 'quadIn' by default.\n * @see {@link weightedSource} Returns a function rather than value\n * @returns Random number (0-1)\n */\nexport const weighted = (\n  easingNameOrOptions: EasingName | WeightedOptions = `quadIn`\n): number => weightedSource(easingNameOrOptions)();\n\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n * Use {@link weighted} to get a value directly.\n *\n * ```js\n * const r1 = Random.weightedSource();          // quadIn easing by default, which skews toward low values\n * r1(); // Produce a value\n *\n * const r2 = Random.weightedSource(`quadOut`); // quadOut favours high values\n * r2(); // Produce a value\n * ```\n * @param easingNameOrOptions Easing name or options `quadIn` by default.\n * @see {@link weighted} Returns value instead of function\n * @returns Function which returns a weighted random value\n */\nexport const weightedSource = (\n  easingNameOrOptions: EasingName | WeightedOptions = `quadIn`\n): RandomSource => {\n  const options =\n    typeof easingNameOrOptions === `string`\n      ? { easing: easingNameOrOptions }\n      : easingNameOrOptions;\n  const source = options.source ?? Math.random;\n  const easingName = options.easing ?? `quadIn`;\n  const easingFunction = get(easingName);\n  if (typeof easingFunction === `undefined`) {\n    throw new Error(`Easing function '${ easingName }' not found.`);\n  }\n\n  const compute = (): number => {\n    const r = source();\n    return easingFunction(r);\n  };\n  return compute;\n};"],"mappings":"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"}