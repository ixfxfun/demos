{"version":3,"sources":["../src/geometry/index.ts","../src/geometry/Waypoint.ts","../src/geometry/line/JoinPointsToLines.ts","../src/geometry/line/Angles.ts","../src/geometry/line/Midpoint.ts","../src/geometry/line/index.ts","../src/geometry/line/Nearest.ts","../src/geometry/line/DistanceSingleLine.ts","../src/geometry/line/Bbox.ts","../src/geometry/line/Divide.ts","../src/geometry/line/FromFlatArray.ts","../src/geometry/line/FromPivot.ts","../src/geometry/line/FromPointsToPath.ts","../src/geometry/line/IsEqual.ts","../src/geometry/line/Multiply.ts","../src/geometry/line/RelativePosition.ts","../src/geometry/line/Rotate.ts","../src/geometry/line/Subtract.ts","../src/geometry/line/Sum.ts","../src/geometry/line/ToString.ts","../src/geometry/line/ToPath.ts","../src/geometry/Layout.ts","../src/geometry/CirclePacking.ts","../src/geometry/shape/index.ts","../src/geometry/rect/Corners.ts","../src/geometry/circle/IsContainedBy.ts","../src/geometry/circle/Intersecting.ts","../src/geometry/circle/Random.ts","../src/geometry/circle/Center.ts","../src/geometry/rect/Random.ts","../src/geometry/circle/index.ts","../src/geometry/circle/Area.ts","../src/geometry/rect/FromCenter.ts","../src/geometry/circle/Bbox.ts","../src/geometry/circle/ExteriorPoints.ts","../src/geometry/circle/InteriorPoints.ts","../src/geometry/circle/Perimeter.ts","../src/geometry/circle/Interpolate.ts","../src/geometry/circle/Multiply.ts","../src/geometry/circle/Svg.ts","../src/geometry/circle/ToPath.ts","../src/geometry/circle/ToPositioned.ts","../src/geometry/rect/index.ts","../src/geometry/rect/Area.ts","../src/geometry/rect/Apply.ts","../src/geometry/rect/Cardinal.ts","../src/geometry/rect/Divide.ts","../src/geometry/rect/Edges.ts","../src/geometry/rect/Empty.ts","../src/geometry/rect/Encompass.ts","../src/geometry/rect/FromElement.ts","../src/geometry/rect/FromNumbers.ts","../src/geometry/rect/GetRectPositionedParameter.ts","../src/geometry/rect/IsEqual.ts","../src/geometry/rect/Lengths.ts","../src/geometry/rect/Multiply.ts","../src/geometry/rect/Nearest.ts","../src/geometry/rect/Placeholder.ts","../src/geometry/rect/NormaliseByRect.ts","../src/geometry/rect/Subtract.ts","../src/geometry/rect/Sum.ts","../src/geometry/rect/ToArray.ts","../src/geometry/path/index.ts","../src/geometry/grid/index.ts","../src/geometry/grid/Inside.ts","../src/geometry/grid/Guards.ts","../src/geometry/grid/ApplyBounds.ts","../src/geometry/grid/Array1d.ts","../src/geometry/grid/Array2d.ts","../src/geometry/grid/As.ts","../src/geometry/grid/Values.ts","../src/geometry/grid/enumerators/Cells.ts","../src/geometry/grid/Offset.ts","../src/geometry/grid/Directions.ts","../src/geometry/grid/enumerators/index.ts","../src/geometry/grid/Geometry.ts","../src/geometry/grid/Indexing.ts","../src/geometry/grid/IsEqual.ts","../src/geometry/grid/Neighbour.ts","../src/geometry/grid/ToArray.ts","../src/geometry/grid/ToString.ts","../src/geometry/grid/Visual.ts","../src/geometry/grid/visitors/index.ts","../src/geometry/grid/visitors/Breadth.ts","../src/geometry/grid/visitors/CellNeighbours.ts","../src/geometry/grid/visitors/Columns.ts","../src/geometry/grid/visitors/Depth.ts","../src/geometry/grid/visitors/Random.ts","../src/geometry/grid/visitors/RandomContiguous.ts","../src/geometry/grid/visitors/Rows.ts","../src/geometry/grid/visitors/Visitor.ts","../src/geometry/grid/visitors/Step.ts","../src/geometry/path/CompoundPath.ts","../src/geometry/Ellipse.ts","../src/geometry/CurveSimplification.ts","../src/geometry/QuadTree.ts","../src/geometry/Scaler.ts","../src/geometry/Convolve2d.ts","../src/visual/ImageDataGrid.ts","../src/geometry/arc/index.ts","../src/geometry/Vector.ts","../src/geometry/SurfacePoints.ts","../src/geometry/triangle/index.ts","../src/geometry/triangle/Guard.ts","../src/geometry/triangle/Edges.ts","../src/geometry/triangle/Area.ts","../src/geometry/triangle/Centroid.ts","../src/geometry/triangle/Perimeter.ts","../src/geometry/triangle/InnerCircle.ts","../src/geometry/triangle/OuterCircle.ts","../src/geometry/triangle/Rotate.ts","../src/geometry/triangle/Equilateral.ts","../src/geometry/triangle/Right.ts","../src/geometry/triangle/Isosceles.ts"],"sourcesContent":["export * as Waypoints from './Waypoint.js';\nexport * as Layouts from './Layout.js';\n\nexport * as Circles from './circle/index.js';\nexport * as Lines from './line/index.js';\nexport * as Rects from './rect/index.js';\nexport * as Points from './point/index.js';\nexport * as Paths from './path/index.js';\nexport * as Grids from './grid/index.js';\nexport * as Beziers from './bezier/index.js';\nexport * as Compound from './path/CompoundPath.js';\nexport * as Ellipses from './Ellipse.js';\nexport type * from './Types.js';\n\nexport * from './Angles.js';\nexport * as CurveSimplification from './CurveSimplification.js';\n\n/**\n * Quad tree is a datastructure for efficiently determining whether\n * a point/shape is at a location\n * - {@link quadTree}: Create a quad tree\n */\nexport * as QuadTree from './QuadTree.js';\n\nexport * as Scaler from './Scaler.js';\nexport * as Convolve2d from './Convolve2d.js';\n\n/**\n * Work with arcs. Arcs are a angle-limited circle, describing a wedge.\n * \n * {@link ArcPositioned} has a origin x,y.\n * \n * Conversions:\n * - {@link fromDegrees}\n * - {@link toLine}: A line from start/end position of arc\n * - {@link toSvg}: Returns an SVG representation of arc\n * \n * Calculations:\n * - {@link bbox}: Bounding box\n * - {@link interpolate}: Interplate two arcs\n * - {@link point}: Find a point on the arc, given an angle\n * - {@link length}: Circumference of arc\n * \n * Comparisons:\n * - {@link isArc}: Returns true if object is Arc-ish\n * - {@link isEqual}: Returns true if two objects have identical arc properties\n */\nexport * as Arcs from './arc/index.js';\n\n/**\n * Generate a few basic geometric shapes\n * Overview:\n * * {@link arrow}\n * * {@link starburst}\n */\nexport * as Shapes from './shape/index.js';\n\n/**\n * Helper functions for working with vectors, which can either be a {@link Point} or Polar {@link Polar.Coord}.\n * While most of the functionality is provided in either of those modules, the Vector module lets you cleanly\n * interoperate between these two coordinates.\n */\nexport * as Vectors from './Vector.js';\n\n\n/**\n * Work with Polar coordinates.\n * A {@link Polar.Coord} is just `{ angleRadians:number, distance: number }`.\n * \n * Conversion: {@link toCartesian}, {@link fromCartesian}, {@link toString}\n * \n * Math: {@link divide}, {@link invert}, {@link multiply}, {@link dotProduct}\n * \n * Geometric manipulations: {@link rotate}, {@link rotateDegrees}\n * \n * Cleaning: {@link clampMagnitude}, {@link normalise}\n * \n * Debugging: {@link toString}\n * \n * Comparisons: {@link isAntiParallel}, {@link isOpposite}, {@link isParallel}, {@link isPolarCoord}\n */\nexport * as Polar from './Polar.js';\n\n/**\n * Functions for producing points within a shape.\n * Useful for creating patterns.\n * \n * Overview:\n * * {@link sphereFibonacci}: Generate points on a sphere\n * * {@link circleVogelSpiral}: Generate a sunflower-esque pattern of points in a circle \n */\nexport * as SurfacePoints from './SurfacePoints.js';\n\n/**\n * Triangle processing.\n * \n * Helpers for creating:\n * - {@link Triangles.fromFlatArray}: Create from `[ aX, aY, bX, bY, cX, cY ]`\n * - {@link Triangles.fromPoints}: Create from an array of three Points.\n * - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n * \n * There are sub-modules for dealing with particular triangles:\n * - {@link Triangles.Equilateral}: Equilateral triangls\n * - {@link Triangles.Right}: Right-angled triangles\n * - {@link Triangles.Isosceles}: Iscosceles triangles\n * \n * Calculations\n * - {@link angles}: Internal angles in radians. {@link anglesDegrees} for degrees. \n * - {@link area}: Area of triangle\n * - {@link bbox}: Bounding box\n * - {@link centroid}: Centroid of triangle\n * - {@link perimeter}: Calculate perimeter\n * - {@link lengths}: Return array lengths of triangle's edges\n * - {@link rotate}, {@link rotateByVertex}\n * \n * Conversions\n * - {@link edges}: Edges of triangle as {@link Line}\n * - {@link corners}: Corner positions\n * - {@link innerCircle}: Largest circle to fit within triangle\n * - {@link outerCircle}: Largest circle to enclose triangle\n * - {@link toFlatArray}: Returns an array of coordinates: `[aX, aY, bX, bY, cX, cY]`\n * \n * Comparisons\n * - {@link intersectsPoint}: Whether a point intersects triangle\n * - {@link isEqual}: Check whether two triangles have equal values\n * - {@link isAcute}, {@link isEquilateral}, {@link isIsosceles}, {@link isRightAngle}\n * - {@link isTriangle}: Returns true if object has expected properties of a triangle\n */\nexport * as Triangles from './triangle/index.js';\n\n// try {\n//   if (typeof window !== `undefined`) {\n//     //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-explicit-any\n//     (window as any).ixfx = { ...(window as any).ixfx, Geometry: { Circles, Arcs, Lines, Rects, Points, Paths, Grids, Beziers, Compound, Ellipses, Polar, Shapes, radiansFromAxisX, radianToDegree, degreeToRadian } };\n//   }\n// } catch { /* no-op */ }\n","import type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { Path } from \"./path/PathType.js\";\nimport type { Point } from \"./point/PointType.js\";\nimport { joinPointsToLines } from './line/JoinPointsToLines.js';\nimport { toPath } from './line/ToPath.js';\nimport { distance as PointsDistance } from \"./point/Distance.js\";\nimport { sortByNumericProperty } from \"../data/arrays/Sort.js\";\n\nexport type Waypoint = CirclePositioned;\n\nexport type WaypointOpts = {\n  readonly maxDistanceFromLine: number;\n  readonly enforceOrder: boolean;\n};\n\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints \n * @param opts \n * @returns \n */\nexport const fromPoints = (\n  waypoints: ReadonlyArray<Point>,\n  opts: Partial<WaypointOpts> = {}\n) => {\n  const lines = joinPointsToLines(...waypoints);\n  return init(\n    lines.map((l) => toPath(l)),\n    opts\n  );\n};\n\n/**\n * Result \n */\nexport type WaypointResult = {\n  /**\n   * Path being compared against\n   */\n  path: Path\n  /**\n   * Index of this path in original `paths` array\n   */\n  index: number\n  /**\n   * Nearest point on path. See also {@link distance}\n   */\n  nearest: Point\n  /**\n   * Closest distance to path. See also {@link nearest}\n   */\n  distance: number\n  /**\n   * Rank of this result, 0 being highest.\n   */\n  rank: number\n  /**\n   * Relative position on this path segment\n   * 0 being start, 0.5 middle and so on.\n   */\n  positionRelative: number\n}\n\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => Array<WaypointResult>\n\n/**\n * Initialise\n * \n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths \n * @param opts \n * @returns \n */\nexport const init = (paths: ReadonlyArray<Path>, opts: Partial<WaypointOpts> = {}): Waypoints => {\n  //const enforceOrder = opts.enforceOrder ?? true;\n  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n\n  const checkUnordered = (pt: Point): Array<WaypointResult> => {\n    const results = paths.map((p, index) => {\n      const nearest = p.nearest(pt);\n      const distance = PointsDistance(pt, nearest);\n\n      // Relative position of nearest point on this path segment\n      const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);;\n      return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n    });\n\n    const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n    const sorted = sortByNumericProperty(filtered, `distance`);\n\n    // Assign ranks\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let rank = 0; rank < sorted.length; rank++) {\n      sorted[ rank ].rank = rank;\n    }\n    return sorted;\n  };\n\n  // const checkUnordered = (p:Point) => {\n  //   // Calculate progress of pointer between all the waypoint lines\n  //   const progresses = lines.map((line, index) => (\n  //     {\n  //       index,\n  //       score: Points.progressBetween(p, line.a, line.b)\n  //     }));\n  //   // Sort by closest\n  //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n  // };\n  return checkUnordered;\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { fromPoints } from \"./FromPoints.js\";\nimport type { PolyLine } from \"./LineType.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { interpolate } from \"./Interpolate.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport type { Point } from \"../point/PointType.js\";\n\nconst directionVector = (line: Line): Point => ({\n  x: line.b.x - line.a.x,\n  y: line.b.y - line.a.y\n});\n\n\n\nconst directionVectorNormalised = (line: Line): Point => {\n  const l = length(line);\n  const v = directionVector(line);\n  return {\n    x: v.x / l,\n    y: v.y / l\n  };\n};\n\n/**\n * Returns a parallel line to `line` at `distance`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance \n */\nexport const parallel = (line: Line, distance: number): Line => {\n  const dv = directionVector(line);\n  const dvn = directionVectorNormalised(line);\n  const a = {\n    x: line.a.x - dvn.y * distance,\n    y: line.a.y + dvn.x * distance\n  };\n  return {\n    a,\n    b: {\n      x: a.x + dv.x,\n      y: a.y + dv.y\n    }\n  };\n};\n\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line: Line, distance: number, amount = 0) => {\n  const origin = interpolate(amount, line);\n  const dvn = directionVectorNormalised(line);\n  return {\n    x: origin.x - dvn.y * distance,\n    y: origin.y + dvn.x * distance\n  };\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\n\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine \n * @param pointB \n * @returns \n */\nexport const midpoint = (aOrLine: Point | Line, pointB?: Point): Point => {\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  return interpolate(0.5, a, b);\n};","import type { Point } from '../point/PointType.js';\nimport type { Line } from './LineType.js';\n//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/NormaliseByRect.js';\nimport { minFast } from '../../numbers/NumericArrays.js';\nimport { distanceSingleLine } from './DistanceSingleLine.js';\nimport { isLine } from './Guard.js';\nimport { length } from './Length.js';\nimport { interpolate } from './Interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/Guard.js';\nexport * from './Angles.js';\nexport * from './Bbox.js';\nexport * from './DistanceSingleLine.js';\nexport * from './Divide.js';\nexport * from './FromFlatArray.js';\nexport * from './FromNumbers.js';\nexport * from './FromPoints.js';\nexport * from './FromPivot.js';\nexport * from './FromPointsToPath.js';\nexport * from './GetPointsParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './IsEqual.js';\nexport * from './JoinPointsToLines.js';\nexport * from './Length.js';\nexport type * from './LinePathType.js';\nexport type * from './LineType.js';\nexport * from './Midpoint.js';\nexport * from './Multiply.js';\nexport * from './Nearest.js';\nexport * from './RelativePosition.js';\nexport * from './Rotate.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './ToPath.js';\nexport * from './ToString.js';\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Empty = Object.freeze({\n  a: Object.freeze({ x: 0, y: 0 }),\n  b: Object.freeze({ x: 0, y: 0 })\n});\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({\n  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n  b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l \n * @returns \n */\nexport const isEmpty = (l: Line): boolean => PointIsEmpty(l.a) && PointIsEmpty(l.b);\n\nexport const isPlaceholder = (l: Line): boolean => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n\n\n\n\n/**\n * Applies `fn` to both start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n * \n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n * \n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns \n */\nexport const apply = (line: Line, fn: (p: Point) => Point) => Object.freeze<Line>(\n  {\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n  }\n);\n\n\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint \n * @param b \n * @returns \n */\nexport const angleRadian = (lineOrPoint: Line | Point, b?: Point): number => {\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b point must be provided`);\n  }\n  return Math.atan2(b.y - a.y, b.x - a.x);\n};\n\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line \n * @param width\n * @param height \n * @returns \n */\nexport const normaliseByRect = (line: Line, width: number, height: number): Line => Object.freeze({\n  ...line,\n  a: PointsNormaliseByRect(line.a, width, height),\n  b: PointsNormaliseByRect(line.b, width, height)\n});\n\n\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange \n * @returns True if point is within range\n */\nexport const withinRange = (line: Line, point: Point, maxRange: number): boolean => {\n  const calculatedDistance = distance(line, point);\n  return calculatedDistance <= maxRange;\n};\n\n\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n * \n * @example\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns \n */\nexport const slope = (lineOrPoint: Line | Point, b?: Point): number => {\n\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b parameter required`);\n  }\n  if (b === undefined) {\n    throw new TypeError(`Second point missing`)\n  } else {\n    return (b.y - a.y) / (b.x - a.x);\n  }\n};\n\n\n/**\n * Scales a line from its midpoint\n * \n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor \n */\nexport const scaleFromMidpoint = (line: Line, factor: number): Line => {\n  const a = interpolate(factor / 2, line);\n  const b = interpolate(0.5 + factor / 2, line);\n  return { a, b };\n};\n\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line: Line, x: number): Point => {\n  const y = line.a.y + (x - line.a.x) * slope(line);\n  return Object.freeze({ x: x, y });\n};\n\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line: Line, distance: number): Line => {\n  const calculatedLength = length(line);\n  return Object.freeze({\n    ...line,\n    a: line.a,\n    b: Object.freeze({\n      x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n      y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n    })\n  });\n};\n\n/**\n * Yields every integer point along `line`. \n * \n * @example Basic usage\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n * \n * Some precision is lost as start and end\n * point is also returned as an integer.\n * \n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\n//eslint-disable-next-line func-style\nexport function* pointsOf(line: Line): Generator<Point> {\n  // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n  const { a, b } = line;\n  let x0 = Math.floor(a.x);\n  let y0 = Math.floor(a.y);\n  const x1 = Math.floor(b.x);\n  const y1 = Math.floor(b.y);\n  const dx = Math.abs(x1 - x0);\n  const dy = -Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1;\n  const sy = y0 < y1 ? 1 : -1;\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  let err = dx + dy;\n\n  while (true) {\n    yield { x: x0, y: y0 };\n    if (x0 === x1 && y0 === y1) break;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const e2 = 2 * err;\n    if (e2 >= dy) {\n      err += dy;\n      x0 += sx;\n    }\n    if (e2 <= dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n}\n\n/**\n * Returns the distance of `point` to the \n * nearest point on `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line: Line | ReadonlyArray<Line>, point: Point): number => {\n  if (Array.isArray(line)) {\n    const distances = line.map(l => distanceSingleLine(l, point));\n    return minFast(distances);\n  } else {\n    return distanceSingleLine(line as Line, point);\n  }\n};\n\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n * \n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a: Point | Line, b: Point): ReadonlyArray<number> => {\n  if (isLine(a)) {\n    return [ a.a.x, a.a.y, a.b.x, a.b.y ];\n  } else if (isPoint(a) && isPoint(b)) {\n    return [ a.x, a.y, b.x, b.y ];\n  } else {\n    throw new Error(`Expected single line parameter, or a and b points`);\n  }\n};\n\n/**\n * Yields all the points of all the lines.\n * \n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines \n */\n//eslint-disable-next-line func-style\nexport function* asPoints(lines: Iterable<Line>) {\n  for (const l of lines) {\n    yield l.a;\n    yield l.b;\n  }\n}\n\n/**\n * Returns an SVG description of line\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const toSvgString = (a: Point, b: Point): ReadonlyArray<string> => [ `M${ a.x } ${ a.y } L ${ b.x } ${ b.y }` ];\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { minIndex } from \"../../numbers/NumericArrays.js\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line: Line | ReadonlyArray<Line>, point: Point): Point => {\n\n  const n = (line: Line): Point => {\n    const { a, b } = line;\n    const atob = { x: b.x - a.x, y: b.y - a.y };\n    const atop = { x: point.x - a.x, y: point.y - a.y };\n    const length = atob.x * atob.x + atob.y * atob.y;\n\n\n    let dot = atop.x * atob.x + atop.y * atob.y;\n    const t = Math.min(1, Math.max(0, dot / length));\n    dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n    return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n  };\n\n  if (Array.isArray(line)) {\n    const pts = line.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(line as Line));\n  }\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard } from './Guard.js';\nimport { guard as guardPoint } from '../point/Guard.js';\nimport { length } from \"./Length.js\";\nimport { nearest } from \"./Nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns \n */\nexport const distanceSingleLine = (line: Line, point: Point): number => {\n  guard(line, `line`);\n  guardPoint(point, `point`);\n\n  if (length(line) === 0) {\n    // Line is really a point\n    return length(line.a, point);\n  }\n\n  const near = nearest(line, point);\n  return length(near, point);\n};","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport type { Line } from \"./LineType.js\";\nimport { bbox as PointsBbox } from \"../point/Bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line: Line): RectPositioned => PointsBbox(line.a, line.b);\n","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { divide as PointDivide } from '../point/Divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param line \n * @param point \n * @returns \n */\nexport const divide = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointDivide(line.a, point),\n  b: PointDivide(line.b, point)\n});\n\n","import { fromNumbers } from \"./FromNumbers.js\";\nimport type { Line } from \"./LineType.js\";\n\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n * \n * See {@link toFlatArray} to create an array from a line.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array: ReadonlyArray<number>): Line => {\n  if (!Array.isArray(array)) throw new Error(`arr parameter is not an array`);\n  if (array.length !== 4) throw new Error(`array is expected to have length four`);\n  return fromNumbers(array[ 0 ], array[ 1 ], array[ 2 ], array[ 3 ]);\n};","import type { Point } from \"../point/PointType.js\"\nimport * as Polar from \"../Polar.js\";\nimport { radianInvert } from \"../Angles.js\";\n\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n * \n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n * \n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line. \n * * Angle of 45deg will be angled downwards.\n * \n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin: Point = { x: 0.5, y: 0.5 }, length: number = 1, angleRadian: number = 0, balance: number = 0.5) => {\n  const left = length * balance;\n  const right = length * (1 - balance);\n  const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n  const b = Polar.toCartesian(right, angleRadian, origin);\n  return Object.freeze({\n    a, b\n  });\n}","import type { Point } from \"../point/PointType.js\";\nimport { fromPoints } from \"./FromPoints.js\";\nimport type { LinePath } from \"./LinePathType.js\";\nimport { toPath } from \"./ToPath.js\";\n\n/**\n * Returns a {@link LinePath} from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const fromPointsToPath = (a: Point, b: Point): LinePath => toPath(fromPoints(a, b));\n","import type { Line } from \"./LineType.js\";\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a: Line, b: Line): boolean => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);","import type { Point } from \"../Types.js\";\nimport type { Line } from \"./LineType.js\";\nimport { multiply as PointsMultiply } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const multiply = (line: Line, point: Point): Line => (Object.freeze({\n  ...line,\n  a: PointsMultiply(line.a, point),\n  b: PointsMultiply(line.b, point)\n}));","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line \n * @param pt \n */\nexport const relativePosition = (line: Line, pt: Point): number => {\n  const fromStart = PointsDistance(line.a, pt);\n  const total = length(line);\n  return fromStart / total;\n}","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./Interpolate.js\";\n\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n * \n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n * \n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n * \n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns \n */\nexport const rotate = (line: Line, amountRadian?: number, origin?: Point | number): Line => {\n  if (amountRadian === undefined || amountRadian === 0) return line;\n  if (origin === undefined) origin = 0.5;\n  if (typeof origin === `number`) {\n    origin = interpolate(origin, line.a, line.b);\n  }\n  return Object.freeze({\n    ...line,\n    a: PointRotate(line.a, amountRadian, origin),\n    b: PointRotate(line.b, amountRadian, origin)\n  });\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\n\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const subtract = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSubtract(line.a, point),\n  b: PointsSubtract(line.b, point)\n});","import type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { sum as PointsSum } from '../point/Sum.js';\n\n/**\n * Adds both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const sum = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSum(line.a, point),\n  b: PointsSum(line.b, point)\n});","import type { Point } from \"../point/PointType.js\";\nimport { guard, isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport function toString(a: Point, b: Point): string;\n\n/**\n * Returns a string representation of a line \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toString(line);\n * ```\n * @param line \n */\nexport function toString(line: Line): string;\n\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b \n * @returns \n */\n//eslint-disable-next-line func-style\nexport function toString(a: Point | Line, b?: Point): string {\n  if (isLine(a)) {\n    guard(a, `a`);\n    b = a.b;\n    a = a.a;\n  } else if (b === undefined) throw new Error(`Expect second point if first is a point`);\n  return PointsToString(a) + `-` + PointsToString(b);\n}\n\n","import type { LinePath } from \"./LinePathType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { length } from \"./Length.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { parallel, perpendicularPoint } from \"./Angles.js\";\nimport { midpoint } from \"./Midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./Bbox.js\";\nimport { relativePosition } from \"./RelativePosition.js\";\nimport { sum } from \"./Sum.js\";\nimport { divide } from \"./Divide.js\";\nimport { rotate } from \"./Rotate.js\";\nimport { nearest } from \"./Nearest.js\";\nimport { distanceSingleLine } from './DistanceSingleLine.js';\nimport { isEqual } from \"./IsEqual.js\";\nimport { multiply } from \"./Multiply.js\";\nimport { subtract } from \"./Subtract.js\";\nimport { toString } from \"./ToString.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n * \n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n * \n * // Now we can use it...\n * l.length();\n * \n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line \n * @returns \n */\nexport const toPath = (line: Line): LinePath => {\n  const { a, b } = line;\n  return Object.freeze({\n    ...line,\n    length: () => length(a, b),\n    interpolate: (amount: number) => interpolate(amount, a, b),\n    relativePosition: (point: Point) => relativePosition(line, point),\n    bbox: () => bbox(line),\n    toString: () => toString(a, b),\n    toFlatArray: () => toFlatArray(a, b),\n    toSvgString: () => toSvgString(a, b),\n    toPoints: () => [ a, b ],\n    rotate: (amountRadian: number, origin: Point) => toPath(rotate(line, amountRadian, origin)),\n    nearest: (point: Point) => nearest(line, point),\n    sum: (point: Point) => toPath(sum(line, point)),\n    divide: (point: Point) => toPath(divide(line, point)),\n    multiply: (point: Point) => toPath(multiply(line, point)),\n    subtract: (point: Point) => toPath(subtract(line, point)),\n    midpoint: () => midpoint(a, b),\n    distanceToPoint: (point: Point) => distanceSingleLine(line, point),\n    parallel: (distance: number) => parallel(line, distance),\n    perpendicularPoint: (distance: number, amount?: number) => perpendicularPoint(line, distance, amount),\n    slope: () => slope(line),\n    withinRange: (point: Point, maxRange: number) => withinRange(line, point, maxRange),\n    isEqual: (otherLine: Line) => isEqual(line, otherLine),\n    apply: (fn: (point: Point) => Point) => toPath(apply(line, fn)),\n    kind: `line`\n  });\n};","export * as CirclePacking from './CirclePacking.js';","import { sortByNumericProperty } from \"../data/arrays/Sort.js\";\nimport type { RandomSource } from \"../random/Types.js\";\nimport { randomPoint as ShapesRandomPoint, type ShapePositioned } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/Intersecting.js\";\nimport type { Circle, CirclePositioned } from \"./circle/CircleType.js\";\nimport type { Point } from \"./point/PointType.js\";\n\nexport type RandomOpts = {\n  readonly attempts?: number\n  readonly randomSource?: RandomSource\n}\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles: ReadonlyArray<Circle>, container: ShapePositioned, opts: RandomOpts = {}) => {\n  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);\n  const attempts = opts.attempts ?? 2000;\n\n  const sorted = sortByNumericProperty(circles, `radius`);\n  const positionedCircles: Array<CirclePositioned> = [];\n\n  const willHit = (b: Point, radius: number) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n\n  while (sorted.length > 0) {\n    //eslint-disable-next-line functional/immutable-data\n    const circle = sorted.pop();\n    if (!circle) break;\n\n    const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < attempts; index++) {\n      const position = ShapesRandomPoint(container, randomPointOpts);\n      if (!willHit(position, circle.radius)) {\n        //eslint-disable-next-line functional/immutable-data\n        positionedCircles.push(Object.freeze({ ...circle, ...position }));\n        break;\n      }\n    }\n  }\n\n  return positionedCircles;\n};","import { toCartesian } from '../Polar.js';\nimport { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { Triangles, Points } from '../index.js';\nimport type { Triangle } from '../triangle/TriangleType.js';\nimport { isCirclePositioned, isCircle } from '../circle/Guard.js';\nimport type { RandomSource } from '../../random/Types.js';\nimport { corners as RectsCorners } from '../rect/Corners.js';\nimport { center as RectsCenter } from '../rect/Center.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/Intersecting.js';\nimport { randomPoint as circleRandomPoint } from '../circle/Random.js';\nimport { center as circleCenter } from '../circle/Center.js';\nimport { randomPoint as rectRandomPoint } from '../rect/Random.js';\nimport { isRect, isRectPositioned } from '../rect/Guard.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\nimport type { Rect, RectPositioned, } from '../rect/RectTypes.js';\nimport type { CirclePositioned, Circle } from '../circle/CircleType.js';\nimport type { Line, PolyLine } from '../line/LineType.js';\nimport type { Point, Point3d } from './../point/PointType.js';\n\nexport type ShapePositioned = CirclePositioned | RectPositioned;\nexport type ContainsResult = `none` | `contained`;\n\nexport type Sphere = Point3d & {\n  readonly radius: number;\n};\n\nexport type PointCalculableShape =\n  | PolyLine\n  | Line\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  | RectPositioned\n  | Point\n  | CirclePositioned\n  ;\n\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link CirclePositioned} or {@link RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (\n  a: ShapePositioned,\n  b: ShapePositioned | Point\n): boolean => {\n  if (isCirclePositioned(a)) {\n    return CirclesIsIntersecting(a, b);\n  } else if (isRectPositioned(a)) {\n    return RectsIsIntersecting(a, b);\n  }\n  throw new Error(\n    `a or b are unknown shapes. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`\n  );\n};\n\n// export enum Quadrant {\n//   Nw, Ne, Sw, Se\n// }\n\nexport type ShapeRandomPointOpts = {\n  readonly randomSource: RandomSource;\n};\n\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link CirclePositioned} or {@link RectPositioned}\n * @param shape \n * @param opts \n * @returns \n */\nexport const randomPoint = (\n  shape: ShapePositioned,\n  opts: Partial<ShapeRandomPointOpts> = {}\n): Point => {\n  if (isCirclePositioned(shape)) {\n    return circleRandomPoint(shape, opts);\n  } else if (isRectPositioned(shape)) {\n    return rectRandomPoint(shape, opts);\n  }\n  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n\n// }\n\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (\n  shape?: Rect | Triangle | Circle\n): Point => {\n  if (shape === undefined) {\n    return Object.freeze({ x: 0.5, y: 0.5 });\n  } else if (isRect(shape)) {\n    return RectsCenter(shape);\n  } else if (Triangles.isTriangle(shape)) {\n    return Triangles.centroid(shape);\n  } else if (isCircle(shape)) {\n    return circleCenter(shape);\n  } else {\n    throw new Error(`Unknown shape: ${ JSON.stringify(shape) }`);\n  }\n};\n\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (\n  outerRadius: number,\n  points = 5,\n  innerRadius?: number,\n  origin: Point = Points.Empty,\n  opts?: { readonly initialAngleRadian?: number }\n): ReadonlyArray<Point> => {\n  throwIntegerTest(points, `positive`, `points`);\n  const angle = (Math.PI * 2) / points;\n  const angleHalf = angle / 2;\n\n  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n  if (innerRadius === undefined) innerRadius = outerRadius / 2;\n\n  //eslint-disable-next-line functional/no-let\n  let a = initialAngle;\n  const pts = [];\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < points; index++) {\n    const peak = toCartesian(outerRadius, a, origin);\n    const left = toCartesian(innerRadius, a - angleHalf, origin);\n    const right = toCartesian(innerRadius, a + angleHalf, origin);\n\n    //eslint-disable-next-line functional/immutable-data\n    pts.push(left, peak);\n    //eslint-disable-next-line functional/immutable-data\n    if (index + 1 < points) pts.push(right);\n    a += angle;\n  }\n  return pts;\n};\n\nexport type ArrowOpts = {\n  readonly arrowSize?: number;\n  readonly tailLength?: number;\n  readonly tailThickness?: number;\n  readonly angleRadian?: number;\n};\n\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (\n  origin: Point,\n  from: `tip` | `tail` | `middle`,\n  opts: ArrowOpts = {}\n): ReadonlyArray<Point> => {\n  const tailLength = opts.tailLength ?? 10;\n  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n  const angleRadian = opts.angleRadian ?? 0;\n  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n\n  const triAngle = Math.PI / 2;\n\n  let tri: Triangle;\n  let tailPoints: ReadonlyArray<Point>;\n\n  if (from === `tip`) {\n    tri = Triangles.equilateralFromVertex(origin, arrowSize, triAngle);\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n  } else if (from === `middle`) {\n    const midX = tailLength + arrowSize / 2;\n    const midY = tailThickness / 2;\n    tri = Triangles.equilateralFromVertex(\n      {\n        x: origin.x + arrowSize * 1.2,\n        y: origin.y,\n      },\n      arrowSize,\n      triAngle\n    );\n\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x - midX, y: origin.y - midY },\n        tailLength + arrowSize,\n        tailThickness\n      )\n    );\n  } else {\n    //const midY = origin.y - tailThickness/2;\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n    tri = Triangles.equilateralFromVertex(\n      { x: origin.x + tailLength + arrowSize * 0.7, y: origin.y },\n      arrowSize,\n      triAngle\n    );\n  }\n\n  const arrow = Points.rotate(\n    [\n      tailPoints[ 0 ],\n      tailPoints[ 1 ],\n      tri.a,\n      tri.b,\n      tri.c,\n      tailPoints[ 2 ],\n      tailPoints[ 3 ],\n    ],\n    angleRadian,\n    origin\n  );\n\n  return arrow;\n};\n","import { type Point } from \"../point/PointType.js\";\nimport { getRectPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import { isPoint } from \"../point/Guard.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isCircle } from \"./Guard.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n * \n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n * \n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a: CirclePositioned, b: CirclePositioned | Point, c?: number): boolean => {\n  const d = distanceCenter(a, b);\n  if (isCircle(b)) {\n    return (d < Math.abs(a.radius - b.radius));\n  } else if (isPoint(b)) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (c === undefined) {\n      return d <= a.radius;\n    } else {\n      // Defining a circle\n      return (d < Math.abs(a.radius - c));\n    }\n  } else throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport * as Intersects from '../Intersects.js';\nimport { isContainedBy } from \"./IsContainedBy.js\";\nimport { isCircle } from \"./Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/IsEqual.js\";\nimport type { Point } from '../point/PointType.js';\nimport { isPoint } from '../point/Guard.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n * \n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number): boolean => {\n  if (PointsIsEqual(a, b)) return true;\n  if (isContainedBy(a, b, c)) return true;\n  if (isCircle(b)) {\n    return Intersects.circleCircle(a, b);\n  } else if (isRectPositioned(b)) {\n    return Intersects.circleRect(a, b);\n  } else if (isPoint(b) && c !== undefined) {\n    return Intersects.circleCircle(a, { ...b, radius: c });\n  }\n  return false;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../Polar.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n * \n * By default creates a uniform distribution.\n * \n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n * \n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns \n */\nexport const randomPoint = (within: Circle | CirclePositioned, opts: Partial<CircleRandomPointOpts> = {}): Point => {\n  const offset: Point = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n  const strategy = opts.strategy ?? `uniform`;\n  const margin = opts.margin ?? 0;\n  const radius = within.radius - margin;\n  const rand = opts.randomSource ?? Math.random;\n  switch (strategy) {\n    case `naive`: {\n      return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n    }\n    case `uniform`: {\n      return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown strategy '${ strategy }'. Expects 'uniform' or 'naive'`);\n    }\n  }\n};","import type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns the center of a circle\n * \n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 10, y: 10};\n * \n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n * \n * It's a trivial function, but can make for more understandable code\n * @param circle \n * @returns Center of circle\n */\nexport const center = (circle: CirclePositioned | Circle) => {\n  return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport { sum as PointsSum } from '../point/Sum.js';\nimport type { Point } from '../point/PointType.js';\nimport { isPositioned } from './Guard.js';\nimport type { Rect, RectPositioned } from './RectTypes.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): RectPositioned => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    width: rando(),\n    height: rando(),\n  });\n};\n\nexport type RectRandomPointOpts = {\n  readonly strategy?: `naive`;\n  readonly randomSource?: RandomSource;\n  readonly margin?: { readonly x: number; readonly y: number };\n};\n\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (\n  within: Rect | RectPositioned,\n  options: RectRandomPointOpts = {}\n): Point => {\n  // TODO: Does not implement uniform distribution\n  // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n  const rand = options.randomSource ?? defaultRandom;\n  const margin = options.margin ?? { x: 0, y: 0 };\n\n  const x = rand() * (within.width - margin.x - margin.x);\n  const y = rand() * (within.height - margin.y - margin.y);\n\n  const pos = { x: x + margin.x, y: y + margin.y };\n  return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};","export * from './Area.js';\nexport * from './Bbox.js';\nexport * from './Center.js';\nexport type * from './CircleType.js';\nexport * from './CircularPath.js';\nexport * from './DistanceCenter.js';\nexport * from './DistanceFromExterior.js';\nexport * from './ExteriorPoints.js';\nexport * from './Guard.js';\nexport * from './InteriorPoints.js';\nexport * from './Interpolate.js';\nexport * from './Intersecting.js';\nexport * from './Intersections.js';\nexport * from './IsContainedBy.js';\nexport * from './IsEqual.js';\nexport * from './Multiply.js';\nexport * from './Perimeter.js';\nexport * from './Random.js';\nexport * from './Svg.js';\nexport * from './ToPath.js';\nexport * from './ToPositioned.js';\n\n","import type { Circle } from \"./CircleType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns the area of `circle`.\n * @param circle \n * @returns \n */\nexport const area = (circle: Circle) => {\n  guard(circle);\n  return Math.PI * circle.radius * circle.radius;\n};","import { type RectPositioned } from \"./RectTypes.js\";\n\nimport type { Point } from \"../point/PointType.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { guardDim } from \"./Guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  PointsGuard(origin, `origin`);\n\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n\n  const halfW = width / 2;\n  const halfH = height / 2;\n  return {\n    x: origin.x - halfW,\n    y: origin.y - halfH,\n    width: width,\n    height: height,\n  };\n};","import type { RectPositioned } from \"../Types.js\";\nimport type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/FromCenter.js';\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns \n */\nexport const bbox = (circle: CirclePositioned | Circle): RectPositioned => {\n  return isCirclePositioned(circle) ?\n    RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n    { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","import type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\n\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n * \n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const { x, y, radius } = circle;\n\n  let xx = radius;\n  let yy = 0;\n  let radiusError = 1 - x;\n  while (xx >= yy) {\n    yield { x: xx + x, y: yy + y };\n    yield { x: yy + x, y: xx + y };\n    yield { x: -xx + x, y: yy + y };\n    yield { x: -yy + x, y: xx + y };\n    yield { x: -xx + x, y: -yy + y };\n    yield { x: -yy + x, y: -xx + y };\n    yield { x: xx + x, y: -yy + y };\n    yield { x: yy + x, y: -xx + y }\n    yy++;\n    if (radiusError < 0) {\n      radiusError += 2 * yy + 1;\n    } else {\n      xx--;\n      radiusError += 2 * (yy - xx + 1);\n    }\n  }\n}\n\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance } from \"../point/Distance.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns all integer points contained within `circle`.\n * \n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const xMin = circle.x - circle.radius;\n  const xMax = circle.x + circle.radius;\n  const yMin = circle.y - circle.radius;\n  const yMax = circle.y + circle.radius;\n  for (let x = xMin; x < xMax; x++) {\n    for (let y = yMin; y < yMax; y++) {\n      const r = Math.abs(distance(circle, x, y));\n      if (r <= circle.radius) yield { x, y };\n    }\n  }\n}","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { guard, isCirclePositioned } from \"./Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { minIndex } from \"../../numbers/NumericArrays.js\";\nconst piPi = Math.PI * 2;\n\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n * \n * ```js\n * import { Circles } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n * \n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle: CirclePositioned | ReadonlyArray<CirclePositioned>, point: Point): Point => {\n  const n = (a: CirclePositioned): Point => {\n    const l = Math.sqrt(Math.pow(point.x - a.x, 2) + Math.pow(point.y - a.y, 2));\n    const x = a.x + (a.radius * ((point.x - a.x) / l));\n    const y = a.y + (a.radius * ((point.y - a.y) / l));\n    return { x, y };\n  };\n\n  if (Array.isArray(circle)) {\n    const pts = circle.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(circle as CirclePositioned));\n  }\n};\n\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * // Circle without position\n * const circleA = { radius: 5 };\n * \n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n * \n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point): Point => {\n  if (origin === undefined) {\n    origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n    y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n  };\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle \n * @returns \n */\nexport const circumference = (circle: Circle): number => {\n  guard(circle);\n  return piPi * circle.radius;\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle \n * @returns \n */\nexport const length = (circle: Circle): number => circumference(circle);\n","import type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport { pointOnPerimeter } from \"./Perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 100, x: 100, y: 100 };\n * \n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle \n * @param t Position, 0-1\n * @returns \n */\nexport const interpolate = (circle: CirclePositioned, t: number): Point => pointOnPerimeter(circle, t * piPi);\n","import type { CirclePositioned, Circle } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/Multiply.js';\n\nexport function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport function multiplyScalar(a: Circle, value: number): Circle;\n\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n * \n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n * \n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a: Circle | CirclePositioned, value: number): Circle | CirclePositioned {\n  if (isCirclePositioned(a)) {\n    const pt = PointsMultiplyScalar(a, value);\n    return Object.freeze({\n      ...a,\n      ...pt,\n      radius: a.radius * value\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      radius: a.radius * value\n    });\n  }\n}\n\n","import type { Point } from \"../point/PointType.js\";\nimport type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCircle, isCirclePositioned } from \"./Guard.js\";\n\ntype ToSvg = {\n  (circleOrRadius: Circle | number, sweep: boolean, origin: Point): ReadonlyArray<string>;\n  (circle: CirclePositioned, sweep: boolean): ReadonlyArray<string>;\n};\n\n\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns \n */\nexport const toSvg: ToSvg = (a: CirclePositioned | number | Circle, sweep: boolean, origin?: Point): ReadonlyArray<string> => {\n  if (isCircle(a)) {\n    if (origin !== undefined) {\n      return toSvgFull(a.radius, origin, sweep);\n    }\n    if (isCirclePositioned(a)) {\n      return toSvgFull(a.radius, a, sweep);\n    } else throw new Error(`origin parameter needed for non-positioned circle`);\n  } else {\n    if (origin === undefined) { throw new Error(`origin parameter needed`); } else {\n      return toSvgFull(a, origin, sweep);\n    }\n  }\n};\n\nconst toSvgFull = (radius: number, origin: Point, sweep: boolean): ReadonlyArray<string> => {\n  // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n  const { x, y } = origin;\n  const s = sweep ? `1` : `0`;\n  return `\n    M ${ x }, ${ y }\n    m -${ radius }, 0\n    a ${ radius },${ radius } 0 1,${ s } ${ radius * 2 },0\n    a ${ radius },${ radius } 0 1,${ s } -${ radius * 2 },0\n  `.split(`\\n`);\n};\n","import type { Point } from \"../point/PointType.js\";\nimport { bbox } from \"./Bbox.js\";\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { CircularPath } from \"./CircularPath.js\";\nimport { guard } from \"./Guard.js\";\nimport { interpolate } from \"./Interpolate.js\";\nimport { nearest } from \"./Perimeter.js\";\nimport { toSvg } from \"./Svg.js\";\nimport { circumference } from \"./Perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle: CirclePositioned): CircularPath => {\n  guard(circle);\n\n  return {\n    ...circle,\n    nearest: (point: Point) => nearest(circle, point),\n    /**\n     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n     * @param {t} Relative (0.0-1.0) point\n     * @returns {Point} X,y\n     */\n    interpolate: (t: number) => interpolate(circle, t),\n    bbox: () => bbox(circle),\n    length: () => circumference(circle),\n    toSvgString: (sweep = true) => toSvg(circle, sweep),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `circular`\n  };\n};","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\nimport { getPointParameter } from \"../point/GetPointParameter.js\";\n\n\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle \n * @param defaultPositionOrX \n * @param y \n * @returns \n */\nexport const toPositioned = (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number): CirclePositioned => {\n  if (isCirclePositioned(circle)) return circle;\n\n  // Returns 0,0 if params are undefined\n  const pt = getPointParameter(defaultPositionOrX, y);\n  return Object.freeze({\n    ...circle,\n    ...pt\n  });\n};","export * from './Area.js';\nexport * from './Apply.js';\nexport * from './Cardinal.js';\nexport * from './Center.js';\nexport * from './Corners.js';\nexport * from './Distance.js';\nexport * from './Divide.js';\nexport * from './Edges.js';\nexport * from './Empty.js';\nexport * from './Encompass.js';\nexport * from './FromCenter.js';\nexport * from './FromElement.js';\nexport * from './FromNumbers.js';\nexport * from './FromTopLeft.js';\nexport * from './GetRectPositionedParameter.js';\nexport * from './Guard.js';\nexport * from './Intersects.js';\nexport * from './IsEqual.js';\nexport * from './Lengths.js';\nexport * from './Max.js';\nexport * from './Multiply.js';\nexport * from './Nearest.js';\nexport * from './Placeholder.js';\nexport * from './NormaliseByRect.js';\nexport * from './Random.js';\nexport type * from './RectTypes.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './ToArray.js';","import { guard } from \"./Guard.js\";\nimport type { Rect } from \"./RectTypes.js\";\n\n/**\n * Returns the area of `rect`\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect: Rect): number => {\n  guard(rect);\n  return rect.height * rect.width;\n};","import { guard } from \"./Guard.js\";\nimport type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./Guard.js\";\n\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number\n\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number\n\nexport function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\n\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth \n * @param heightValue \n * @returns \n */\nexport function applyFields(op: ApplyFieldOp, rectOrWidth: RectPositioned | Rect | number, heightValue?: number): RectPositioned | Rect {\n  let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n  let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n  if (width === undefined) throw new Error(`Param 'width' undefined`);\n  if (height === undefined) throw new Error(`Param 'height' undefined`);\n\n  width = op(width, `width`);\n  height = op(height, `height`);\n\n  if (typeof rectOrWidth === `object`) {\n    if (isPositioned(rectOrWidth)) {\n      const x = op(rectOrWidth.x, `x`);\n      const y = op(rectOrWidth.y, `y`);\n      return { ...rectOrWidth, width, height, x, y };\n    } else {\n      return {\n        ...rectOrWidth, width, height\n      }\n    }\n  }\n  return { width, height };\n}\n\nexport function applyMerge(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op \n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function applyMerge(\n  op: ApplyMergeOp,\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  guard(a, `a`);\n\n  if (isRect(b)) {\n    // Math op by another rectangle\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b.width),\n      y: op(a.y, b.height),\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    });\n  } else {\n    // Math op with a series of values\n    if (typeof b !== `number`) {\n      throw new TypeError(\n        `Expected second parameter of type Rect or number. Got ${ JSON.stringify(\n          b\n        ) }`\n      );\n    }\n    if (typeof c !== `number`) throw new Error(`Expected third param as height. Got ${ JSON.stringify(c) }`);\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b),\n      y: op(a.y, c),\n      width: op(a.width, b),\n      height: op(a.height, c),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b),\n      height: op(a.height, c),\n    });\n  }\n}\n\n/**\n * Uses `op` with `param` to width and height.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  parameter: number\n): RectPositioned;\n\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return isPositioned(rect) ? Object.freeze({\n    ...rect,\n    x: op(rect.x, parameter),\n    y: op(rect.y, parameter),\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  }) : Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}\n\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op \n * @param rect \n * @param parameter \n * @returns \n */\nexport function applyDim(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}","import type { RectPositioned } from \"./RectTypes.js\";\nimport type { GridCardinalDirection } from '../grid/index.js';\nimport type { Point } from \"../point/PointType.js\";\n\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (\n  rect: RectPositioned,\n  card: GridCardinalDirection | `center`\n): Point => {\n  const { x, y, width, height } = rect;\n  switch (card) {\n    case `nw`: {\n      return Object.freeze({ x, y });\n    }\n    case `n`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y,\n      });\n    }\n    case `ne`: {\n      return Object.freeze({\n        x: x + width,\n        y,\n      });\n    }\n    case `sw`: {\n      return Object.freeze({ x, y: y + height });\n    }\n    case `s`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height,\n      });\n    }\n    case `se`: {\n      return Object.freeze({\n        x: x + width,\n        y: y + height,\n      });\n    }\n    case `w`: {\n      return Object.freeze({ x, y: y + height / 2 });\n    }\n    case `e`: {\n      return Object.freeze({ x: x + width, y: y + height / 2 });\n    }\n    case `center`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height / 2,\n      });\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown direction: ${ card }`);\n    }\n  }\n};","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./Apply.js\";\n\nconst divideOp = (a: number, b: number) => a / b;\n\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport function divide(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport function divide(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Divides rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function divide(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(divideOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(divideOp, rect, amount);\n}\n\nexport function divideDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(divideOp, rect, amount);\n}\n","import { isPoint } from \"../point/Guard.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/JoinPointsToLines.js';\n\nimport type { Point } from '../point/PointType.js';\nimport { corners } from \"./Corners.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Line> => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n});","import type { Point } from \"../point/PointType.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect \n * @param points \n * @returns \n */\nexport const encompass = (rect: RectPositioned, ...points: Point[]): RectPositioned => {\n  const x = points.map(p => p.x);\n  const y = points.map(p => p.y);\n\n  let minX = Math.min(...x, rect.x);\n  let minY = Math.min(...y, rect.y);\n  let maxX = Math.max(...x, rect.x + rect.width);\n  let maxY = Math.max(...y, rect.y + rect.height);\n\n  let rectW = Math.max(rect.width, maxX - minX);\n  let rectH = Math.max(rect.height, maxY - minY);\n\n  return Object.freeze({\n    ...rect,\n    x: minX,\n    y: minY,\n    width: rectW,\n    height: rectH\n  })\n} ","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el: HTMLElement): Rect => ({\n  width: el.clientWidth,\n  height: el.clientHeight,\n});","import type { RectPositioned, Rect } from \"./RectTypes.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport function fromNumbers(width: number, height: number): Rect;\n\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function fromNumbers(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): RectPositioned;\n\n/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function fromNumbers(\n  xOrWidth: number,\n  yOrHeight: number,\n  width?: number,\n  height?: number\n): Rect | RectPositioned {\n  if (width === undefined || height === undefined) {\n    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);\n    if (typeof yOrHeight !== `number`) {\n      throw new TypeError(`height is not an number`);\n    }\n    return Object.freeze({ width: xOrWidth, height: yOrHeight });\n  }\n  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);\n  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);\n  if (typeof width !== `number`) throw new Error(`width is not an number`);\n  if (typeof height !== `number`) throw new Error(`height is not an number`);\n\n  return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { isRect, isRectPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a \n * @param b \n * @param c \n * @param d \n * @returns \n */\nexport function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned {\n  if (typeof a === `number`) {\n    if (typeof b === `number`) {\n      if (typeof c === `number` && typeof d === `number`) {\n        return { x: a, y: b, width: c, height: d }\n      } else if (isRect(c)) {\n        return { x: a, y: b, width: c.width, height: c.height }\n      } else {\n        throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n      }\n    } else {\n      throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n    }\n  } else if (isRectPositioned(a)) {\n    return a;\n  } else if (isRect(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { width: a.width, height: a.height, x: b, y: c };\n    } else if (isPoint(b)) {\n      return { width: a.width, height: a.height, x: b.x, y: b.y };\n    } else {\n      throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n    }\n  } else if (isPoint(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { x: a.x, y: a.y, width: b, height: c };\n    } else if (isRect(b)) {\n      return { x: a.x, y: a.y, width: b.width, height: b.height };\n    } else {\n      throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n    }\n  }\n  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n\n","import { isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a: Rect, b: Rect): boolean => {\n  if (a === undefined) throw new Error(`a undefined`);\n  if (b === undefined) throw new Error(`b undefined`);\n  return a.width === b.width && a.height === b.height;\n};\n\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (\n  a: Rect | RectPositioned,\n  b: Rect | RectPositioned\n): boolean => {\n  if (isPositioned(a) && isPositioned(b)) {\n    if (!PointsIsEqual(a, b)) return false;\n    return a.width === b.width && a.height === b.height;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    return a.width === b.width && a.height === b.height;\n  } else {\n    // One param is positioned, the other is not\n    return false;\n  }\n};","import { length as LinesLength } from '../line/Length.js';\n\nimport { edges } from './Edges.js';\nimport { guardPositioned } from './Guard.js';\nimport type { RectPositioned } from './RectTypes.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect: RectPositioned): ReadonlyArray<number> => {\n  guardPositioned(rect, `rect`);\n  return edges(rect).map((l) => LinesLength(l));\n};\n","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./Apply.js\";\n\nconst multiplyOp = (a: number, b: number) => a * b;\n\n\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport function multiply(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function multiply(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(multiplyOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * \n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n\n\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n * \n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns \n */\nexport function multiplyDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n","import type { Point } from \"../point/PointType.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\n\n/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect \n * @param p \n * @returns \n */\nexport const nearestInternal = (rect: RectPositioned, p: Point): Point => {\n  let { x, y } = p;\n  if (x < rect.x) x = rect.x;\n  else if (x > rect.x + rect.width) x = rect.x + rect.width;\n  if (y < rect.y) y = rect.y;\n  else if (y > rect.y + rect.height) y = rect.y + rect.height;\n  return Object.freeze({ ...p, x, y });\n}","export const Placeholder = Object.freeze({\n  width: Number.NaN,\n  height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n  x: Number.NaN,\n  y: Number.NaN,\n  width: Number.NaN,\n  height: Number.NaN,\n});\n","import { isPoint, isPoint3d } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\"\nimport type { Rect } from \"./RectTypes.js\"\n\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect \n * @returns \n */\nexport const dividerByLargestDimension = (rect: Rect) => {\n  const largest = Math.max(rect.width, rect.height);\n  return (value: number | Point) => {\n    if (typeof value === `number`) {\n      return value / largest;\n    } else if (isPoint3d(value)) {\n      return Object.freeze({\n        ...value,\n        x: value.x / largest,\n        y: value.y / largest,\n        z: value.x / largest\n      });\n    } else if (isPoint(value)) {\n      return Object.freeze({\n        ...value,\n        x: value.x / largest,\n        y: value.y / largest\n      });\n    } else throw new Error(`Param 'value' is neither number nor Point`);\n  }\n}","import { applyMerge } from \"./Apply.js\";\nimport { isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\nconst subtractOp = (a: number, b: number) => a - b;\n\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function subtract(a: Rect, b: Rect): Rect;\nexport function subtract(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const rect = { width: 100, height: 100 };\n * Rects.subtract(rect, 200, 200);\n * // Yields: { width: -100, height: -100 }\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport function subtract(a: Rect, width: number, height: number): Rect;\n\nexport function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a: Rect | undefined, b: Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return applyMerge(subtractOp, a, b, c);\n}\n\n/**\n * Subtracts a width & height from `a`. Leaves x & y as-is.\n * ```js\n * const rect = { x: 10, y: 20, width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { x:10, y: 20, width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport function subtractSize(a:RectPositioned, b:Rect|number, c?:number):RectPositioned;\n\n\n/**\n * Subtracts a width & height from `a`.\n * ```js\n * const rect = { width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport function subtractSize(a:Rect, b:Rect|number, c?:number):Rect;\n\n\n\nexport function subtractSize(a:Rect|RectPositioned, b:Rect|number, c?:number):Rect|RectPositioned {\n  const w = typeof b === `number` ? b : b.width;\n  const h = typeof b === `number`? c : b.height;\n  if (h === undefined) throw new Error(`Expected height as third parameter`);\n  const r = {\n      ...a,\n      width: a.width-w,\n      height: a.height-h\n    };\n  return r;\n}\n\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 }, \n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a \n * @param b \n * @returns \n */\nexport function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x - xB,\n    y: y - yB,\n    width: a.width - b.width,\n    height: a.height - b.height\n  })\n}","import { applyMerge } from \"./Apply.js\";\nimport { getRectPositioned, isPositioned } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\nconst sumOp = (a: number, b: number) => a + b;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function sum(a: Rect, b: Rect): Rect;\n\n/**\n * Sums width/height of `b` with `a`, returning result.\n * \n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n * \n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a \n * @param b \n */\nexport function sum(a: RectPositioned, b: Rect): RectPositioned;\n\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Sums width/height of `rect` with `width` and `height`\n * \n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function sum(a: Rect, b: Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return applyMerge(sumOp, a, b, c);\n}\n\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a \n * @param b \n * @returns \n */\nexport function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x + xB,\n    y: y + yB,\n    width: a.width + b.width,\n    height: a.height + b.height\n  })\n}","import { isPositioned, isRect } from \"./Guard.js\";\nimport type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./RectTypes.js\";\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: Rect): RectArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: RectPositioned): RectPositionedArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n// eslint-disable-next-line func-style\nexport function toArray(\n  rect: Rect | RectPositioned\n): RectArray | RectPositionedArray {\n  if (isPositioned(rect)) {\n    return [ rect.x, rect.y, rect.width, rect.height ];\n  } else if (isRect(rect)) {\n    return [ rect.width, rect.height ];\n  } else {\n    throw new Error(\n      `Param 'rect' is not a rectangle. Got: ${ JSON.stringify(rect) }`\n    );\n  }\n}\n","import type { Point } from '../point/PointType.js';\nimport { isLine } from '../line/Guard.js';\nimport type { Path } from './PathType.js';\nimport { isQuadraticBezier } from '../bezier/Guard.js';\nexport * from './PathType.js';\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.a;\n  else if (isLine(path)) return path.a;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.b;\n  else if (isLine(path)) return path.b;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n","export * from './ApplyBounds.js';\nexport * as Array1d from './Array1d.js';\nexport * as Array2d from './Array2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './As.js';\nexport * from './Directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './Geometry.js';\nexport * from './Guards.js';\nexport * from './Indexing.js';\nexport * from './Inside.js';\nexport * from './IsEqual.js';\nexport * from './Neighbour.js';\nexport * from './Offset.js';\nexport * from './ToArray.js';\nexport * from './ToString.js';\nexport type * from './Types.js';\nexport * from './Visual.js';\nexport * from './Values.js';\nexport * as Visit from './visitors/index.js';\n\n\n\n\n\n","import type { Grid, GridCell } from \"./Types.js\";\n\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid: Grid, cell: GridCell): boolean => {\n  if (cell.x < 0 || cell.y < 0) return false;\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\n  return true;\n};\n\n\n","import { inside } from \"./Inside.js\";\nimport type { GridCell, Grid } from \"./Types.js\";\n\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell: GridCell | undefined): cell is GridCell => {\n  if (cell === undefined) return false;\n  return `x` in cell && `y` in cell;\n};\n\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (\n  cell: GridCell,\n  parameterName = `Param`,\n  grid?: Grid\n) => {\n  if (cell === undefined) {\n    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n  }\n  if (cell.x === undefined) throw new Error(parameterName + `.x is undefined`);\n  if (cell.y === undefined) throw new Error(parameterName + `.y is undefined`);\n  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);\n  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);\n  if (!Number.isInteger(cell.x)) {\n    throw new TypeError(parameterName + `.x is non-integer`);\n  }\n  if (!Number.isInteger(cell.y)) {\n    throw new TypeError(parameterName + `.y is non-integer`);\n  }\n  if (grid !== undefined && !inside(grid, cell)) {\n    throw new Error(\n      `${ parameterName } is outside of grid. Cell: ${ cell.x },${ cell.y } Grid: ${ grid.cols }, ${ grid.rows }`\n    );\n  }\n};\n\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid: Grid, parameterName = `Param`) => {\n  if (grid === undefined) {\n    throw new Error(`${ parameterName } is undefined. Expecting grid.`);\n  }\n  if (!(`rows` in grid)) throw new Error(`${ parameterName }.rows is undefined`);\n  if (!(`cols` in grid)) throw new Error(`${ parameterName }.cols is undefined`);\n\n  if (!Number.isInteger(grid.rows)) {\n    throw new TypeError(`${ parameterName }.rows is not an integer`);\n  }\n  if (!Number.isInteger(grid.cols)) {\n    throw new TypeError(`${ parameterName }.cols is not an integer`);\n  }\n};","import { clampIndex } from \"../../numbers/Clamp.js\";\nimport { guardCell, guardGrid } from \"./Guards.js\";\nimport type { GridBoundsLogic, GridCell, Grid } from \"./Types.js\";\n\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid \n * @param cell \n * @param wrap \n * @returns \n */\nexport const applyBounds = function (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  guardGrid(grid, `grid`);\n  guardCell(cell, `cell`);\n\n  let x = cell.x;\n  let y = cell.y;\n  switch (wrap) {\n    case `wrap`: {\n      x = x % grid.cols;\n      y = y % grid.rows;\n      if (x < 0) x = grid.cols + x;\n      else if (x >= grid.cols) {\n        x -= grid.cols;\n      }\n      if (y < 0) y = grid.rows + y;\n      else if (y >= grid.rows) {\n        y -= grid.rows;\n      }\n      x = Math.abs(x);\n      y = Math.abs(y);\n      break;\n    }\n    case `stop`: {\n      x = clampIndex(x, grid.cols);\n      y = clampIndex(y, grid.rows);\n      break;\n    }\n    case `undefined`: {\n      if (x < 0 || y < 0) return;\n      if (x >= grid.cols || y >= grid.rows) return;\n      break;\n    }\n    case `unbounded`: {\n      break;\n    }\n    default: {\n      throw new Error(`Unknown BoundsLogic '${ wrap }'. Expected: wrap, stop, undefined or unbounded`);\n    }\n  }\n  return Object.freeze({ x, y });\n};","import { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { indexFromCell } from \"./index.js\";\nimport type { GridCellAccessor, GridCell, GridBoundsLogic, Grid, GridCellSetter, GridReadable, GridWritable, GridArray1d } from \"./Types.js\";\n\n\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n * \n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array \n * @param cols \n * @returns \n */\nexport const access = <V>(\n  array: ReadonlyArray<V>,\n  cols: number\n): GridCellAccessor<V> => {\n  const grid = gridFromArrayDimensions(array, cols);\n\n  const fn: GridCellAccessor<V> = (\n    cell: GridCell,\n    wrap: GridBoundsLogic = `undefined`\n  ): V | undefined => accessWithGrid(grid, array, cell, wrap);\n  return fn;\n};\n\nconst accessWithGrid = <T>(grid: Grid, array: ReadonlyArray<T> | Array<T>, cell: GridCell, wrap: GridBoundsLogic) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) return undefined;\n  return array[ index ];\n}\n\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n * \n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array \n * @param cols \n * @returns \n */\nexport const setMutate = <V>(\n  array: V[],\n  cols: number\n): GridCellSetter<V> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setMutateWithGrid = <V>(\n  grid: Grid,\n  array: V[],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  array[ index ] = value;\n  return array;\n}\n\nexport const set = <V>(\n  array: readonly V[],\n  cols: number\n) => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic) => setWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setWithGrid = <V>(\n  grid: Grid,\n  array: readonly V[],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  let copy = [ ...array ];\n  copy[ index ] = value;\n  array = copy;\n  return copy;\n}\n\n/**\n * Creates a {@link Grid} from the basis of an array and a given number of columns\n * @param array \n * @param cols \n * @returns \n */\nconst gridFromArrayDimensions = <T>(array: ReadonlyArray<T> | Array<T>, cols: number): Grid => {\n  const grid = { cols, rows: Math.ceil(array.length / cols) };\n  return grid;\n}\n\n\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *  \n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n * \n * Use {@link wrap} for an immutable version.\n * \n * @param array Array to wrap\n * @param cols Width of grid\n * @returns \n */\nexport const wrapMutable = <T>(array: T[], cols: number): GridArray1d<T> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return {\n    ...grid,\n    get: access(array, cols),\n    set: setMutate(array, cols),\n    get array() {\n      return array;\n    }\n  }\n}\n\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n * \n * ```js\n * const myArray = [\n *    `a`, `b`, `c`, \n *    `d`, `e`, `f` \n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n * \n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n * \n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns \n */\nexport const wrap = <T>(array: T[], cols: number): GridArray1d<T> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return {\n    ...grid,\n    get: (cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n    set: (value: T, cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => {\n      array = setWithGrid(grid, array, value, cell, boundsLogic);\n      return wrap(array, cols);\n    },\n    get array() {\n      return array;\n    }\n  }\n}\n\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n * \n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n * \n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport const createArray = <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number): T[] => {\n  const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n  if (!cols) throw new Error(`Parameter 'columns' missing`);\n  throwIntegerTest(rows, `aboveZero`, `rows`);\n  throwIntegerTest(cols, `aboveZero`, `cols`);\n\n  let t: T[] = [];\n  let total = rows * cols;\n  for (let i = 0; i < total; i++) {\n    t[ i ] = initialValue;\n  }\n  return t;\n}\n\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n * \n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue \n * @param rowsOrGrid \n * @param columns \n * @returns \n */\nexport const createMutable = <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number): GridArray1d<T> => {\n  const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n  if (!cols) throw new Error(`Parameter 'columns' missing`);\n  const arr = createArray(initialValue, rows, cols);\n  return wrapMutable(arr, cols);\n}\n","import { applyBounds } from \"./ApplyBounds.js\";\nimport type { GridBoundsLogic, GridCell, GridCellAccessor, GridCellSetter, Grid, GridReadable, GridWritable } from \"./Types.js\";\n\nexport type ArrayGrid<T> = GridReadable<T> & GridWritable<T> & {\n  array: T[][]\n}\n\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array \n * @returns \n */\nexport const create = <T>(array: ReadonlyArray<T[]> | Array<T[]>): Grid => {\n  let colLen = NaN;\n  for (const row of array) {\n    if (Number.isNaN(colLen)) {\n      colLen = row.length;\n    } else {\n      if (colLen !== row.length) throw new Error(`Array does not have uniform column length`);\n    }\n  }\n\n  return { rows: array.length, cols: colLen };\n}\n\nexport const setMutate = <V>(\n  array: V[][]\n): GridCellSetter<V> => {\n  const grid = create(array);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n}\n\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.Array2d.setMutateWithGrid(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\nconst setMutateWithGrid = <V>(\n  grid: Grid,\n  array: V[][],\n  value: V, cell: GridCell, bounds: GridBoundsLogic\n) => {\n  let boundCell = applyBounds(grid, cell, bounds);\n  if (boundCell === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  array[ boundCell.y ][ boundCell.x ] = value;\n  return array;\n}\n// export const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n//   const fn = (v: V, position: Cell) => {\n//     const pos = cellAtPoint(grid, position);\n//     if (pos === undefined) {\n//       throw new Error(\n//         `Position does not exist. Pos: ${ JSON.stringify(\n//           position\n//         ) } Grid: ${ JSON.stringify(grid) }`\n//       );\n//     }\n//     array[ pos.y ][ pos.x ] = v;\n//   };\n//   return fn;\n// };\n\nexport const access = <T>(\n  array: ReadonlyArray<T[]>\n): GridCellAccessor<T> => {\n  const grid = create(array);\n\n  const fn: GridCellAccessor<T> = (\n    cell: GridCell,\n    wrap: GridBoundsLogic = `undefined`\n  ): T | undefined => accessWithGrid(grid, array, cell, wrap);\n  return fn;\n};\n\nconst accessWithGrid = <T>(grid: Grid, array: ReadonlyArray<T[]> | Array<T[]>, cell: GridCell, wrap: GridBoundsLogic) => {\n  let boundCell = applyBounds(grid, cell, wrap);\n  if (boundCell === undefined) return undefined;\n  return array[ boundCell.y ][ boundCell.x ];\n}\n\nexport const wrapMutable = <T>(array: T[][]): ArrayGrid<T> => {\n  const grid = create(array);\n  return {\n    ...grid,\n    get: access(array),\n    set: setMutate(array),\n    get array() {\n      return array;\n    }\n  }\n}\n\nexport const set = <V>(\n  array: readonly V[][]\n) => {\n  const grid = create(array);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic) => setWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setWithGrid = <V>(\n  grid: Grid,\n  array: readonly V[][],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  let boundCell = applyBounds(grid, cell, wrap);\n  if (boundCell === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  let copyWhole = [ ...array ];\n  let copyRow = [ ...copyWhole[ boundCell.y ] ];\n  copyRow[ boundCell.x ] = value;\n  copyWhole[ boundCell.y ] = copyRow;\n  array = copyWhole;\n  return copyWhole;\n}\n\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n * \n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n * \n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns \n */\nexport const wrap = <T>(array: T[][]): ArrayGrid<T> => {\n  const grid = create(array);\n  return {\n    ...grid,\n    get: (cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n    set: (value: T, cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => {\n      array = setWithGrid(grid, array, value, cell, boundsLogic);\n      return wrap(array);\n    },\n    get array() {\n      return array;\n    }\n  }\n}","import type { GridCell, Grid, GridReadable } from \"./Types.js\";\nimport { cells } from \"./enumerators/Cells.js\";\n\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n * \n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 }\n  let row = start.y;\n  let rowCells: Array<GridCell> = [];\n\n  for (const c of cells(grid, start)) {\n    if (c.y === row) {\n      rowCells.push(c);\n    } else {\n      yield rowCells;\n      rowCells = [ c ];\n      row = c.y;\n    }\n  }\n  if (rowCells.length > 0) yield rowCells;\n};\n\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n * \n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n * \n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid \n * @param start \n */\nexport function* columns(grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 };\n  for (let x = start.x; x < grid.cols; x++) {\n    let colCells: Array<GridCell> = [];\n    for (let y = start.y; y < grid.rows; y++) {\n      colCells.push({ x, y });\n    }\n    yield colCells;\n  }\n}","import type { GridReadable, GridCell, GridBoundsLogic } from \"./Types.js\";\n\n\nexport function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell>): Generator<T>\nexport function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell[]>): Generator<T[]>\n\n/**\n * Converts an 1D or 2D array of cell coordinates into values\n * \n * ```js\n * // 1D (ie an array of coordinates)\n * const cells = Grid.As.cells(grid);\n * for (const v of Grid.values(grid, cells)) {\n * \n * }\n * ```\n * ```js\n * // 2D (ie an array of rows)\n * const rows = Grid.As.rows(grid);\n * for (const v of Grid.values(grid, rows)) {\n * }\n * ```\n * @param grid \n * @param iter \n */\nexport function* values<T>(grid: GridReadable<T>, iter: Iterable<GridCell> | Iterable<GridCell[]>) {\n  for (const d of iter) {\n    if (Array.isArray(d)) {\n      yield d.map(v => grid.get(v, `undefined`));\n    } else {\n      yield grid.get(d, `undefined`);\n    }\n  }\n}\n\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell[]>, wrap?: BoundsLogic): Generator<T[]>\n\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell>, wrap?: BoundsLogic): Generator<T>\n\n// /**\n//  * Visits the values of a readable grid\n//  * @param readable Readable grid\n//  * @param visitor Visitor\n//  * @param wrap Wrapping logic, defaultign to 'undefined'\n//  */\n// export function* visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell | Cell[]>, wrap: BoundsLogic = `undefined`) {\n//   for (const cellOrCells of visitor) {\n//     if (Array.isArray(cellOrCells)) {\n//       yield cellOrCells.map(cell => readable.accessor(cell, wrap));\n//     } else {\n//       yield readable.accessor(cellOrCells, wrap);\n//     }\n//   }\n// }","import { guardGrid, guardCell } from \"../Guards.js\";\nimport type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../Types.js\";\nimport { values } from \"../Values.js\";\n\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n * \n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n * \n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n * \n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n * \n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid: Grid, start?: GridCell, wrap = true) {\n  if (!start) start = { x: 0, y: 0 }\n\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  let { x, y } = start;\n  let canMove = true;\n  do {\n    yield { x, y };\n    x++;\n    if (x === grid.cols) {\n      y++;\n      x = 0;\n    }\n    if (y === grid.rows) {\n      if (wrap) {\n        y = 0;\n        x = 0;\n      } else {\n        canMove = false;\n      }\n    }\n    if (x === start.x && y === start.y) canMove = false; // Complete\n  } while (canMove);\n};\n\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n * \n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true) {\n  yield* values(grid, cells(grid, start, wrap));\n}\n\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true): Generator<GridCellAndValue<T>> {\n  for (const cell of cells(grid, start, wrap)) {\n    yield { cell, value: grid.get(cell) }\n  }\n}","import { clampIndex } from '../../numbers/Clamp.js';\nimport { applyBounds } from './ApplyBounds.js';\nimport { guardCell, guardGrid } from './Guards.js';\nimport type { Grid, GridCell, GridBoundsLogic } from './Types.js';\n\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n * \n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (\n  grid: Grid,\n  start: GridCell,\n  vector: GridCell,\n  bounds: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  return applyBounds(grid, {\n    x: start.x + vector.x,\n    y: start.y + vector.y\n  }, bounds)\n  // guardCell(start, `start`, grid);\n  // guardCell(vector);\n  // guardGrid(grid, `grid`);\n\n  // // eslint-disable-next-line functional/no-let\n  // let x = start.x;\n  // // eslint-disable-next-line functional/no-let\n  // let y = start.y;\n  // switch (bounds) {\n  //   case `wrap`: {\n  //     x += vector.x % grid.cols;\n  //     y += vector.y % grid.rows;\n  //     if (x < 0) x = grid.cols + x;\n  //     else if (x >= grid.cols) {\n  //       x -= grid.cols;\n  //     }\n  //     if (y < 0) y = grid.rows + y;\n  //     else if (y >= grid.rows) {\n  //       y -= grid.rows;\n  //     }\n  //     break;\n  //   }\n  //   case `stop`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     x = clampIndex(x, grid.cols);\n  //     y = clampIndex(y, grid.rows);\n  //     break;\n  //   }\n  //   case `undefined`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     if (x < 0 || y < 0) return;\n  //     if (x >= grid.cols || y >= grid.rows) return;\n  //     break;\n  //   }\n  //   case `unbounded`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     break;\n  //   }\n  //   default: {\n  //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n  //   }\n  // }\n  // return Object.freeze({ x, y });\n};\n\n","import { zipKeyValue } from \"../../data/maps/MapFns.js\";\nimport { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { guardCell, guardGrid } from \"./Guards.js\";\nimport type { GridBoundsLogic, GridCardinalDirection, GridCardinalDirectionOptional, GridCell, Grid, GridNeighbours } from \"./Types.js\";\nimport { offset } from \"./Offset.js\";\n\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n  `n`,\n  `ne`,\n  `nw`,\n  `e`,\n  `s`,\n  `se`,\n  `sw`,\n  `w`,\n]) as ReadonlyArray<GridCardinalDirection>;\n\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n  `n`,\n  `e`,\n  `s`,\n  `w`,\n]) as ReadonlyArray<GridCardinalDirection>;\n\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (\n  grid: Grid,\n  start: GridCell,\n  steps: number,\n  bounds: GridBoundsLogic = `stop`\n): GridNeighbours => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  throwIntegerTest(steps, `aboveZero`, `steps`);\n\n  const directions = allDirections;\n  const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n  const cells = directions.map((d, index) =>\n    offset(grid, start, vectors[ index ], bounds)\n  );\n\n  return zipKeyValue(directions, cells) as GridNeighbours;\n};\n\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (\n  cardinal: GridCardinalDirectionOptional,\n  multiplier = 1\n): GridCell => {\n  // eslint-disable-next-line functional/no-let\n  let v;\n  switch (cardinal) {\n    case `n`: {\n      v = { x: 0, y: -1 * multiplier };\n      break;\n    }\n    case `ne`: {\n      v = { x: 1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    case `e`: {\n      v = { x: 1 * multiplier, y: 0 };\n      break;\n    }\n    case `se`: {\n      v = { x: 1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `s`: {\n      v = { x: 0, y: 1 * multiplier };\n      break;\n    }\n    case `sw`: {\n      v = { x: -1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `w`: {\n      v = { x: -1 * multiplier, y: 0 };\n      break;\n    }\n    case `nw`: {\n      v = { x: -1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    default: {\n      v = { x: 0, y: 0 };\n    }\n  }\n  return Object.freeze(v);\n};","//import type { Cell, GridReadable } from '../Types.js';\n\nexport * from './Cells.js';\n\n// export function* withValues<T>(grid: GridReadable<T>, iter: IterableIterator<Cell>) {\n//   for (const cell of iter) {\n//     yield { cell, value: grid.get(cell, `undefined`) };\n//   }\n// }","import { guardCell } from \"./Guards.js\";\nimport type { GridCell } from \"./Types.js\";\n\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start: GridCell, end: GridCell): ReadonlyArray<GridCell> => {\n  // https://stackoverflow.com/a/4672319\n  guardCell(start);\n  guardCell(end);\n\n  // eslint-disable-next-line functional/no-let\n  let startX = start.x;\n  // eslint-disable-next-line functional/no-let\n  let startY = start.y;\n  const dx = Math.abs(end.x - startX);\n  const dy = Math.abs(end.y - startY);\n  const sx = startX < end.x ? 1 : -1;\n  const sy = startY < end.y ? 1 : -1;\n  // eslint-disable-next-line functional/no-let\n  let error = dx - dy;\n\n  const cells = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // eslint-disable-next-line functional/immutable-data\n    cells.push(Object.freeze({ x: startX, y: startY }));\n    if (startX === end.x && startY === end.y) break;\n    const error2 = 2 * error;\n    if (error2 > -dy) {\n      error -= dy;\n      startX += sx;\n    }\n    if (error2 < dx) {\n      error += dx;\n      startY += sy;\n    }\n  }\n  return cells;\n};\n\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (\n  start: GridCell,\n  end: GridCell,\n  endInclusive = false\n): ReadonlyArray<GridCell> {\n  const cells: Array<GridCell> = [];\n  if (start.x === end.x) {\n    // Vertical\n    const lastY = endInclusive ? end.y + 1 : end.y;\n    for (let y = start.y; y < lastY; y++) {\n      cells.push({ x: start.x, y: y });\n    }\n  } else if (start.y === end.y) {\n    // Horizontal\n    const lastX = endInclusive ? end.x + 1 : end.x;\n    for (let x = start.x; x < lastX; x++) {\n      cells.push({ x: x, y: start.y });\n    }\n  } else {\n    throw new Error(\n      `Only does vertical and horizontal: ${ start.x },${ start.y } - ${ end.x },${ end.y }`\n    );\n  }\n  return cells;\n};","import { throwIntegerTest } from \"../../util/GuardNumbers.js\";\nimport { guardGrid } from \"./Guards.js\";\nimport { offset } from \"./Offset.js\";\nimport type { Grid, GridCell, GridBoundsLogic } from \"./Types.js\";\n\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic\n): number | undefined => {\n  guardGrid(grid, `grid`);\n\n  if (cell.x < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        //cell = { ...cell, x: grid.cols + cell.x };\n        cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`)!;\n        break;\n      }\n    }\n  }\n  if (cell.y < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: grid.rows + cell.y };\n        break;\n      }\n    }\n  }\n  if (cell.x >= grid.cols) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: grid.cols - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, x: cell.x % grid.cols };\n        break;\n      }\n    }\n  }\n  if (cell.y >= grid.rows) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: grid.rows - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: cell.y % grid.rows };\n        break;\n      }\n    }\n  }\n\n  const index = cell.y * grid.cols + cell.x;\n\n  return index;\n};\n\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (\n  colsOrGrid: number | Grid,\n  index: number\n): GridCell => {\n  let cols = 0;\n  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n  throwIntegerTest(cols, `aboveZero`, `colsOrGrid`);\n\n  return {\n    x: index % cols,\n    y: Math.floor(index / cols),\n  };\n};","import type { GridCell, Grid, GridVisual } from \"./Types.js\";\n\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (\n  a: Grid | GridVisual,\n  b: Grid | GridVisual\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  if (`rows` in a && `cols` in a) {\n    if (`rows` in b && `cols` in b) {\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\n    } else return false;\n  }\n  if (`size` in a) {\n    if (`size` in b) {\n      if (a.size !== b.size) return false;\n    } else return false;\n  }\n  return true;\n};\n\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (\n  a: GridCell | undefined,\n  b: GridCell | undefined\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  return a.x === b.x && a.y === b.y;\n};","import { zipKeyValue } from \"../../data/maps/MapFns.js\";\nimport { allDirections, getVectorFromCardinal } from \"./Directions.js\";\nimport type { GridBoundsLogic, GridCardinalDirection, GridCell, Grid, GridNeighbour, GridNeighbourMaybe, GridNeighbours } from \"./Types.js\";\nimport { randomElement } from '../../data/arrays/Random.js';\nimport { offset } from \"./Offset.js\";\n\nexport const randomNeighbour = (nbos: ReadonlyArray<GridNeighbour>) => randomElement(nbos); // .filter(isNeighbour));\n\n/**\n * Returns _true_ if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (\n  n: GridNeighbour | GridNeighbourMaybe | undefined\n): n is GridNeighbour => {\n  if (n === undefined) return false;\n  if (n[ 1 ] === undefined) return false;\n  return true;\n};\n\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n * \n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n * \n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions \n * @param bounds Bounds\n * @returns \n */\nexport const neighbourList = (\n  grid: Grid,\n  cell: GridCell,\n  directions: ReadonlyArray<GridCardinalDirection>,\n  bounds: GridBoundsLogic\n): ReadonlyArray<GridNeighbour> => {\n  // Get neighbours for cell\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\n\n  // Filter out undefined cells\n  const entries = Object.entries(cellNeighbours);\n  return (entries as Array<GridNeighbourMaybe>).filter(n => isNeighbour(n));\n};\n\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (\n  grid: Grid,\n  cell: GridCell,\n  bounds: GridBoundsLogic = `undefined`,\n  directions?: ReadonlyArray<GridCardinalDirection>\n): GridNeighbours => {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  return zipKeyValue<GridCell>(directories, points) as GridNeighbours;\n};","\n/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\n\nimport type { Grid } from \"./Types.js\";\n\nexport const toArray2d = <V>(grid: Grid, initialValue?: V): Array<Array<V>> => {\n  const returnValue = [];\n  for (let row = 0; row < grid.rows; row++) {\n    returnValue[ row ] = Array.from<V>({ length: grid.cols });\n    if (initialValue) {\n      for (let col = 0; col < grid.cols; col++) {\n        returnValue[ row ][ col ] = initialValue;\n      }\n    }\n  }\n  return returnValue;\n};","import type { GridCell } from \"./Types.js\";\n\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v: GridCell): string => `Cell{${ v.x },${ v.y }}`;\n","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport { guardCell } from \"./Guards.js\";\nimport type { GridCell, GridVisual } from \"./Types.js\";\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport type { Point } from \"../point/PointType.js\";\nimport { throwIntegerTest, throwNumberTest } from '../../util/GuardNumbers.js';\nimport { cells } from \"./enumerators/Cells.js\";\n\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(\n  grid: GridVisual\n): IterableIterator<RectPositioned> {\n  for (const c of cells(grid)) {\n    yield rectangleForCell(grid, c);\n  }\n}\n\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (\n  grid: GridVisual,\n  position: Point\n): GridCell | undefined => {\n  const size = grid.size;\n  throwNumberTest(size, `positive`, `grid.size`);\n  if (position.x < 0 || position.y < 0) return;\n  const x = Math.floor(position.x / size);\n  const y = Math.floor(position.y / size);\n  if (x >= grid.cols) return;\n  if (y >= grid.rows) return;\n  return { x, y };\n};\n\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (\n  grid: GridVisual,\n  cell: GridCell\n): RectPositioned => {\n  guardCell(cell);\n  const size = grid.size;\n  const x = cell.x * size;\n  const y = cell.y * size;\n  const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n  return r;\n};\n\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid: GridVisual, cell: GridCell): Point => {\n  guardCell(cell);\n\n  const size = grid.size;\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n  return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};","import type { GridCell, GridCreateVisitor, Grid, GridReadable, GridNeighbourSelectionLogic, GridVisitorOpts } from '../Types.js';\nimport { breadthLogic } from './Breadth.js';\nimport { neighboursLogic } from './CellNeighbours.js';\nimport { columnLogic } from './Columns.js';\nimport { depthLogic } from './Depth.js';\nimport { randomLogic } from './Random.js';\nimport { randomContiguousLogic } from './RandomContiguous.js';\nimport { rowLogic } from './Rows.js';\nimport { visitByNeighbours } from './Visitor.js';\n\nexport * from './Breadth.js';\nexport * from './CellNeighbours.js';\nexport * from './Columns.js';\nexport * from './Depth.js';\nexport * from './Step.js';\nexport * from './Random.js';\nexport * from './RandomContiguous.js';\nexport * from './Rows.js';\nexport * from './Visitor.js';\n\nexport type VisitorTypes = `row` | `column` | `neighbours` | `breadth` | `depth` | `random` | `random-contiguous`\n\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type \n * @param opts \n * @returns \n */\nexport const create = (type: VisitorTypes, opts: Partial<GridVisitorOpts> = {}) => {\n  switch (type) {\n    case `random-contiguous`:\n      return withLogic(randomContiguousLogic(), opts);\n    case `random`:\n      return withLogic(randomLogic(), opts);\n    case `depth`:\n      return withLogic(depthLogic(), opts);\n    case `breadth`:\n      return withLogic(breadthLogic(), opts);\n    case `neighbours`:\n      return withLogic(neighboursLogic(), opts);\n    case `row`:\n      return withLogic(rowLogic(opts), opts);\n    case `column`:\n      return withLogic(columnLogic(opts), opts);\n    default:\n      throw new TypeError(`Param 'type' unknown. Value: ${ type }`);\n  }\n}\n\nexport const withLogic = (logic: GridNeighbourSelectionLogic, options: Partial<GridVisitorOpts> = {}) => {\n  return (grid: Grid, optionsOverride: Partial<GridVisitorOpts> = {}) => {\n    return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n  }\n}\n\nfunction isIterator<T>(v: any): v is Generator<T> {\n  if (typeof v !== `object`) return false;\n  if (!(`next` in v)) return false;\n  if (!(`throw` in v)) return false;\n  if (!(`return` in v)) return false;\n  return true;\n\n}\n\n\n// export function* withValues<T>(createOrIter: CreateVisitor | Generator<Cell>, grid: GridReadable<T>, opts: Partial<VisitorOpts>) {\n//   const iter = isIterator(createOrIter) ? createOrIter : createOrIter(grid, opts)();\n//   for (const cell of iter) {\n//     yield { cell, value: grid.accessor(cell, `undefined`) }\n//   }\n// }\n\n// export const byCells = (grid: Grid, options: Partial<VisitorOpts> = {}) => {\n//   return (logic: NeighbourSelectionLogic, optionsOverride: Partial<VisitorOpts> = {}) => {\n//     return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n//   }\n// }\n\n// export const byCellsLeftToRightTopToBottom = ():CreateVisitor => {\n//   return (grid) => {\n//     return cells(grid)\n//   }\n// }","import type { Grid, GridCell, GridVisitorOpts, GridNeighbourSelectionLogic } from \"../Types.js\";\n//import { visitor } from \"./Visitor.js\";\n\n// export const visitorBreadth = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos[ 0 ],\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const breadthLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (nbos) => nbos[ 0 ],\n  }\n}","import { allDirections } from \"../Directions.js\";\nimport { neighbourList } from \"../Neighbour.js\";\nimport type { GridNeighbour, GridNeighbourSelectionLogic } from \"../Types.js\";\n\n// export function* cellNeigbours(\n//   grid: Grid,\n//   cell: Cell,\n//   bounds: BoundsLogic = `undefined`,\n//   directions?: ReadonlyArray<CardinalDirection>\n// ) {\n//   const dirs = directions ?? allDirections;\n//   const points = dirs.map((c) =>\n//     offset(grid, cell, getVectorFromCardinal(c), bounds)\n//   );\n//   for (const pt of points) {\n//     if (pt !== undefined) yield pt;\n//   }\n// }\n\nexport const neighboursLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (neighbours: readonly GridNeighbour[]) => {\n      return neighbours.at(0);\n    },\n    getNeighbours: (grid, cell) => {\n      return neighbourList(grid, cell, allDirections, `undefined`)\n    }\n  }\n}\n","import type { GridNeighbour, GridNeighbourSelectionLogic, GridVisitorOpts } from \"../Types.js\";\n\n/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport const columnLogic = (opts: Partial<GridVisitorOpts> = {}): GridNeighbourSelectionLogic => {\n  const reversed = opts.reversed ?? false;\n  return {\n    select: (nbos) => nbos.find((n) => n[ 0 ] === (reversed ? `n` : `s`)),\n    getNeighbours: (grid, cell): ReadonlyArray<GridNeighbour> => {\n      if (reversed) {\n        // WALK UP COLUMN, RIGHT-TO-LEFT\n        if (cell.y > 0) {\n          // Easy case\n          cell = { x: cell.x, y: cell.y - 1 };\n        } else {\n          // Top of column\n          if (cell.x === 0) {\n            // Top-left corner, need to wrap\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          } else {\n            cell = { x: cell.x - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n        if (cell.y < grid.rows - 1) {\n          // Easy case, move down by one\n          cell = { x: cell.x, y: cell.y + 1 };\n        } else {\n          // End of column\n          if (cell.x < grid.cols - 1) {\n            // Move to next column and start at top\n            cell = { x: cell.x + 1, y: 0 };\n          } else {\n            // Move to start of grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `n` : `s`, cell ] ];\n    }\n  }\n}","import type { GridNeighbourSelectionLogic } from \"../Types.js\";\n\n// export const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos.at(-1),\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const depthLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (nbos) => nbos.at(-1)\n  }\n}","import { randomNeighbour } from \"../Neighbour.js\";\nimport type { GridNeighbour, GridNeighbourSelectionLogic } from \"../Types.js\";\nimport { cells } from \"../enumerators/Cells.js\";\n\n// export const visitorRandom = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const randomLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    getNeighbours: (grid, cell) => {\n      const t: Array<GridNeighbour> = [];\n      for (const c of cells(grid, cell)) {\n        t.push([ `n`, c ]);\n      }\n      return t;\n    },\n    select: randomNeighbour,\n  }\n}","import { randomNeighbour } from \"../Neighbour.js\";\nimport type { GridNeighbourSelectionLogic } from \"../Types.js\";\n\n// export const visitorRandomContiguous = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomContiguousLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: randomNeighbour,\n  }\n}","import type { GridCell, Grid, GridNeighbour, GridNeighbourSelectionLogic, GridVisitorOpts } from \"../Types.js\";\n\n/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport const rowLogic = (opts: Partial<GridVisitorOpts> = {}): GridNeighbourSelectionLogic => {\n  const reversed = opts.reversed ?? false;\n  return {\n    select: (nbos: ReadonlyArray<GridNeighbour>) =>\n      nbos.find((n) => n[ 0 ] === (reversed ? `w` : `e`)),\n    getNeighbours: (\n      grid: Grid,\n      cell: GridCell\n    ): ReadonlyArray<GridNeighbour> => {\n      if (reversed) {\n        // WALKING BACKWARD ALONG ROW\n        if (cell.x > 0) {\n          // All fine, step to the left\n          cell = { x: cell.x - 1, y: cell.y };\n        } else {\n          // At the beginning of a row\n          if (cell.y > 0) {\n            // Wrap to next row up\n            cell = { x: grid.cols - 1, y: cell.y - 1 };\n          } else {\n            // Wrap to end of grid\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        /*\n         * WALKING FORWARD ALONG ROWS\n         */\n        if (cell.x < grid.rows - 1) {\n          // All fine, step to the right\n          cell = { x: cell.x + 1, y: cell.y };\n        } else {\n          // At the end of a row\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.y < grid.rows - 1) {\n            // More rows available, wrap to next row down\n            cell = { x: 0, y: cell.y + 1 };\n          } else {\n            // No more rows available, wrap to start of the grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `w` : `e`, cell ] ];\n    }\n  }\n}","import { mutable } from '../../../collections/set/index.js';\nimport { crossDirections } from \"../Directions.js\";\nimport { guardGrid, guardCell, isCell } from \"../Guards.js\";\nimport { cellEquals } from \"../IsEqual.js\";\nimport { neighbourList } from '../Neighbour.js';\nimport { cellKeyString } from \"../ToString.js\";\nimport type { GridNeighbourSelectionLogic, Grid, GridCell, GridVisitorOpts, GridNeighbour } from \"../Types.js\";\n\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a {@link Collections.Sets.ISetMutable} instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport function* visitByNeighbours(\n  logic: GridNeighbourSelectionLogic,\n  grid: Grid,\n  opts: Partial<GridVisitorOpts> = {}\n): Generator<GridCell> {\n  guardGrid(grid, `grid`);\n  const start = opts.start ?? { x: 0, y: 0 };\n\n  guardCell(start, `opts.start`, grid);\n\n  const v = opts.visited ?? mutable<GridCell>(cellKeyString);\n  const possibleNeighbours = logic.getNeighbours ?? ((g: Grid, c: GridCell) => neighbourList(g, c, crossDirections, `undefined`));\n\n  let cellQueue: Array<GridCell> = [ start ];\n  let moveQueue: Array<GridNeighbour> = [];\n  let current: GridCell | undefined = undefined;\n\n  while (cellQueue.length > 0) {\n    if (current === undefined) {\n      const nv = cellQueue.pop();\n      if (nv === undefined) {\n        break;\n      }\n      current = nv;\n    }\n\n    if (!v.has(current)) {\n      v.add(current);\n      yield current;\n\n      const nextSteps = possibleNeighbours(grid, current).filter(\n        (step) => {\n          if (step[ 1 ] === undefined) return false;\n          return !v.has(step[ 1 ])\n        }\n      );\n\n      if (nextSteps.length === 0) {\n        // No more moves for this cell\n        if (current !== undefined) {\n          cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n        }\n      } else {\n        for (const n of nextSteps) {\n          if (n === undefined) continue;\n          if (n[ 1 ] === undefined) continue;\n          moveQueue.push(n);\n        }\n      }\n    }\n\n    // Remove steps already made\n    moveQueue = moveQueue.filter((step) => !v.has(step[ 1 ]));\n\n    if (moveQueue.length === 0) {\n      current = undefined;\n    } else {\n      // Pick move\n      const potential = logic.select(moveQueue);\n      if (potential !== undefined) {\n        cellQueue.push(potential[ 1 ]);\n        current = potential[ 1 ];\n      }\n    }\n  }\n};\n","import { throwIntegerTest } from \"../../../util/GuardNumbers.js\";\nimport { guardCell, guardGrid } from \"../Guards.js\";\nimport type { Grid, GridCell, GridVisitorOpts, GridCreateVisitor } from \"../Types.js\";\n\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n * \n * // Step by 10\n * stepper(10); // GridCell {x,y}\n * \n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport const stepper = (\n  grid: Grid,\n  createVisitor: GridCreateVisitor,\n  start: GridCell = { x: 0, y: 0 },\n  resolution = 1\n) => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  throwIntegerTest(resolution, ``, `resolution`)\n\n  // Create a list of steps\n  const steps: GridCell[] = [];\n  let count = 0;\n  let position = 0;\n  for (const c of createVisitor(grid, { start, boundsWrap: `undefined` })) {\n    count++;\n    if ((count % resolution) !== 0) continue;\n    steps.push(c);\n  }\n\n  return (step: number, fromStart = false) => {\n    throwIntegerTest(step, ``, `step`)\n    if (fromStart) position = step;\n    else position += step;\n    //position = position % steps.length;\n    return steps.at(position % steps.length);\n\n  }\n}\n\n// export const step = (\n//   grid: Grid,\n//   start: Cell,\n//   steps: number,\n//   createVisitor: CreateVisitor\n// ): Cell => {\n//   throwIntegerTest(steps, ``, `steps`);\n\n//   const opts: Partial<VisitorOpts> = {\n//     reversed: steps < 0,\n//     start\n//   };\n//   steps = Math.abs(steps);\n\n//   let c = start;\n//   let v = createVisitor(grid, opts);\n//   v.next(); // Burn up starting cell\n\n//   let stepsMade = 0;\n\n//   while (stepsMade < steps) {\n//     stepsMade++;\n//     const { value } = v.next();\n//     if (value) {\n//       c = value;\n//       if (opts.debug) {\n//         console.log(\n//           `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n//         );\n//       }\n//     } else {\n//       if (steps >= grid.cols * grid.rows) {\n//         steps -= grid.cols * grid.rows;\n//         stepsMade = 0;\n//         v = createVisitor(grid, opts);\n//         v.next();\n//         c = start;\n//         if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n//       } else throw new Error(`Value not received by visitor`);\n//     }\n//   }\n//   return c;\n// };\n","\n//import { Points, Paths } from '../index.js';\nimport * as Paths from '../path/index.js';\nimport { bbox as PointsBbox } from '../point/Bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/IsEqual.js';\nimport type { CompoundPath, Dimensions, Path, RectPositioned } from '../Types.js';\nimport type { Point } from '../point/PointType.js';\nimport { corners as RectsCorners } from '../rect/Corners.js';\nimport { sortByNumericProperty } from '../../data/arrays/Sort.js';\n\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Path): CompoundPath => {\n  const existing = [ ...compoundPath.segments ];\n  //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n  existing[ index ] = path;\n  return fromPaths(...existing);\n};\n\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths: ReadonlyArray<Path>, t: number, useWidth?: boolean, dimensions?: Dimensions) => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n\n  // Expected value to land on\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n  let soFar = 0;\n\n  // Use widths or lengths?\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\n  for (const [ index, element ] of l.entries()) {\n    if (soFar + element >= expected) {\n      const relative = expected - soFar;\n      let amt = relative / element;\n      if (amt > 1) amt = 1;\n      return paths[ index ].interpolate(amt);\n    } else soFar += element;\n  }\n  return { x: 0, y: 0 };\n};\n\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths \n * @param point \n * @returns \n */\nexport const distanceToPoint = (paths: ReadonlyArray<Path>, point: Point): number => {\n  if (paths.length === 0) return 0;\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length === 0) throw new Error(`Could not look up distances`);\n  return distances[ 0 ].distance;\n}\n\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold \n * @param dimensions Pre-computed dimensions\n * @returns \n */\nexport const relativePosition = (paths: ReadonlyArray<Path>, point: Point, intersectionThreshold: number, dimensions?: Dimensions): number => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length < 0) throw new Error(`Point does not intersect with path`);\n  const d = distances[ 0 ];\n  if (d.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${ d.distance }, threshold: ${ intersectionThreshold }`);\n\n  const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n\n  // Add up distances\n  let accumulated = 0;\n  for (let index = 0; index < d.index; index++) {\n    // Add up length of paths before closest path segment\n    accumulated += dimensions.lengths[ index ];\n  }\n\n  // Add up partial amount of closest path\n  accumulated += dimensions.lengths[ d.index ] * relativePositionOnPath;\n  const accumulatedRel = accumulated / dimensions.totalLength;\n  console.log(`acc: ${ accumulated } rel: ${ accumulatedRel } on path: ${ relativePositionOnPath } path: ${ d.index }`);\n  return accumulatedRel;\n}\n\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths: ReadonlyArray<Path>): Dimensions => {\n  const widths = paths.map(l => l.bbox().width);\n  const lengths = paths.map(l => l.length());\n  let totalLength = 0;\n  let totalWidth = 0;\n  for (const length of lengths) {\n    totalLength += length;\n  }\n  for (const width of widths) {\n    totalWidth += width;\n  }\n\n  return { totalLength, totalWidth, widths, lengths };\n};\n\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths: ReadonlyArray<Path>): RectPositioned => {\n  const boxes = paths.map(p => p.bbox());\n  const corners = boxes.flatMap(b => RectsCorners(b));\n\n  return PointsBbox(...corners);\n};\n\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths: ReadonlyArray<Path>): string => paths.map(p => p.toString()).join(`, `);\n\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths: ReadonlyArray<Path>) => {\n  let lastPos = Paths.getEnd(paths[ 0 ]);\n  for (let index = 1; index < paths.length; index++) {\n    const start = Paths.getStart(paths[ index ]);\n    if (!PointsIsEqual(start, lastPos)) throw new Error(`Path index ${ index } does not start at prior path end. Start: ${ start.x },${ start.y } expected: ${ lastPos.x },${ lastPos.y }`);\n    lastPos = Paths.getEnd(paths[ index ]);\n  }\n};\n\nexport const toSvgString = (paths: ReadonlyArray<Path>): ReadonlyArray<string> => paths.flatMap(p => p.toSvgString());\n\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths: ReadonlyArray<Path>): CompoundPath => {\n  guardContinuous(paths); // Throws an error if paths are not connected\n  const dims = computeDimensions(paths);\n\n  return Object.freeze({\n    segments: paths,\n    length: () => dims.totalLength,\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    interpolate: (t: number, useWidth = false) => interpolate(paths, t, useWidth, dims),\n    relativePosition: (point: Point, intersectionThreshold: number) => relativePosition(paths, point, intersectionThreshold, dims),\n    distanceToPoint: (point: Point) => distanceToPoint(paths, point),\n    bbox: () => bbox(paths),\n    toString: () => toString(paths),\n    toSvgString: () => toSvgString(paths),\n    kind: `compound`\n  });\n};\n","\nimport type { Point } from './point/PointType.js';\nimport { degreeToRadian } from './Angles.js';\nimport type { Path } from './path/index.js';\n\n/**\n * An ellipse\n */\nexport type Ellipse = {\n  readonly radiusX: number\n  readonly radiusY: number\n  /**\n   * Rotation, in radians\n   */\n  readonly rotation?: number\n  readonly startAngle?: number\n  readonly endAngle?: number\n}\n\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse\n\n\nexport const fromDegrees = (radiusX: number, radiusY: number, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360): Ellipse => ({\n  radiusX, radiusY,\n  rotation: degreeToRadian(rotationDeg),\n  startAngle: degreeToRadian(startAngleDeg),\n  endAngle: degreeToRadian(endAngleDeg)\n});\n\nexport type EllipticalPath = Ellipse & Path & {\n  readonly kind: `elliptical`\n};","import type { Point } from \"./point/PointType.js\";\nimport { distance } from \"./point/Distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpShortestDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = distanceFromPointToLine(points[ index_ ], firstPoint, lastPoint);\n\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpShortestDistance(l1, epsilon);\n    const r2 = rdpShortestDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];//concat(r2);\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpPerpendicularDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = findPerpendicularDistance(points[ index_ ], firstPoint, lastPoint);\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpPerpendicularDistance(l1, epsilon);\n    const r2 = rdpPerpendicularDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n\nfunction findPerpendicularDistance(p: Point, p1: Point, p2: Point) {\n  // if start and end point are on the same x the distance is the difference in X.\n  let result;\n  let slope;\n  let intercept;\n  if (p1.x == p2.x) {\n    result = Math.abs(p.x - p1.x);\n  } else {\n    slope = (p2.y - p1.y) / (p2.x - p1.x);\n    intercept = p1.y - (slope * p1.x);\n    result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n  }\n\n  return result;\n}\n\n\nconst distanceFromPointToLine = (p: Point, index: Point, index_: Point) => {\n  const lineLength = distance(index, index_);//First, we need the length of the line segment.\n  if (lineLength == 0) {\t//if it's 0, the line is actually just a point.\n    return distance(p, index);\n  }\n  const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n\n  //t is very important. t is a number that essentially compares the individual coordinates\n  //distances between the point and each point on the line.\n\n  if (t < 0) {\t//if t is less than 0, the point is behind i, and closest to i.\n    return distance(p, index);\n  }\t//if greater than 1, it's closest to j.\n  if (t > 1) {\n    return distance(p, index_);\n  }\n  return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n}\n\n\n","import { type TraversableTree } from '../collections/tree/Types.js';\nimport * as Shapes from './shape/index.js';\nimport type { Point } from './point/PointType.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/FromTopLeft.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/From.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/RectTypes.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n  /**\n   * Maximum items per node\n   */\n  readonly maxItems: number;\n  /**\n   * Maximum level of sub-division\n   */\n  readonly maxLevels: number;\n};\n\n/**\n * Direction\n */\nexport enum Direction {\n  Nw,\n  Ne,\n  Sw,\n  Se,\n}\n\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds: RectPositioned, initialData: ReadonlyArray<QuadTreeItem> = [], opts: Partial<QuadTreeOpts> = {}): QuadTreeNode => {\n  const o: QuadTreeOpts = {\n    maxItems: opts.maxItems ?? 4,\n    maxLevels: opts.maxLevels ?? 4\n  };\n\n  const n = new QuadTreeNode(undefined, bounds, 0, o);\n  for (const d of initialData) {\n    n.add(d);\n  }\n  return n;\n};\n\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n * \n */\nexport class QuadTreeNode implements TraversableTree<Array<QuadTreeItem>> {\n  #items: Array<QuadTreeItem> = [];\n  #children: Array<QuadTreeNode> = [];\n  #parent: QuadTreeNode | undefined;\n  /**\n   * Constructor\n   * @param boundary\n   * @param level\n   * @param opts\n   */\n  constructor(\n    parent: QuadTreeNode | undefined,\n    readonly boundary: RectPositioned,\n    readonly level: number,\n    readonly opts: QuadTreeOpts\n  ) {\n    this.#parent = parent;\n  }\n\n  getLengthChildren(): number {\n    return this.#children.length;\n  }\n\n  *parents(): IterableIterator<QuadTreeNode> {\n    //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n    let n: QuadTreeNode | undefined = this;\n    while (n.#parent !== undefined) {\n      yield n.#parent;\n      n = n.#parent;\n    }\n  }\n\n  getParent() {\n    return this.#parent;\n  }\n\n  /**\n   * Iterates over immediate children\n   */\n  *children(): IterableIterator<QuadTreeNode> {\n    for (const c of this.#children) {\n      yield c;\n    }\n  }\n\n  /**\n   * Array of QuadTreeItem\n   * @returns\n   */\n  getValue() {\n    return this.#items;\n  }\n\n  getIdentity() {\n    return this;\n  }\n  /**\n   * Get a descendant node in a given direction\n   * @param d\n   * @returns\n   */\n  direction(d: Direction): QuadTreeNode | undefined {\n    return this.#children[ d ] as QuadTreeNode | undefined;\n  }\n\n  /**\n   * Add an item to the quadtree\n   * @param p\n   * @returns False if item is outside of boundary, True if item was added\n   */\n  add(p: QuadTreeItem): boolean {\n    if (!Shapes.isIntersecting(this.boundary, p)) return false;\n\n    if (this.#children.length > 0) {\n      for (const d of this.#children) (d).add(p);\n      return true;\n    }\n\n    this.#items.push(p);\n\n    if (\n      this.#items.length > this.opts.maxItems &&\n      this.level < this.opts.maxLevels\n    ) {\n      if (this.#children.length === 0) {\n        this.#subdivide();\n      }\n\n      // Add to child\n      for (const item of this.#items) {\n        for (const d of this.#children) (d).add(item);\n      }\n      //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n      this.#items = [];\n    }\n    return true;\n  }\n\n  /**\n   * Returns true if point is inside node's boundary\n   * @param p\n   * @returns\n   */\n  couldHold(p: Point) {\n    return RectsIntersectsPoint(this.boundary, p);\n  }\n\n  #subdivide() {\n    const w = this.boundary.width / 2;\n    const h = this.boundary.height / 2;\n    const x = this.boundary.x;\n    const y = this.boundary.y;\n\n    // top-left corners of each of the four new sections\n    const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n    const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n    // rects.forEach((r, index) => {\n    //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n    // });\n    this.#children = rects.map(\n      (r) => new QuadTreeNode(this, r, this.level + 1, this.opts)\n    );\n  }\n}\n","\nimport type { Point } from './point/PointType.js';\nimport type { Rect } from './rect/index.js';\nimport { isPoint } from './point/index.js';\nimport { isRect } from './rect/Guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/Placeholder.js';\n\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (\n  a: number | Point,\n  b?: number | Rect,\n  c?: number | Rect,\n  d?: number\n) => Point;\n\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n  /**\n   * Relative to absolute coordinates\n   */\n  readonly abs: Scaler;\n  /**\n   * Absolute to relative coordintes\n   */\n  readonly rel: Scaler;\n\n  readonly width: number;\n\n  readonly height: number;\n\n  computeScale(): Point\n};\n\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (\n  scaleBy: ScaleBy = `both`,\n  defaultRect?: Rect\n): ScalerCombined => {\n  const defaultBounds = defaultRect ?? PlaceholderRect;\n\n  let sw = 1;\n  let sh = 1;\n  let s = { x: 1, y: 1 };\n\n  const computeScale = () => {\n    switch (scaleBy) {\n      case `height`: {\n        return { x: sh, y: sh };\n      }\n      case `width`: {\n        return { x: sw, y: sw };\n      }\n      case `min`: {\n        return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n      }\n      case `max`: {\n        return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n      }\n      default: {\n        return { x: sw, y: sh };\n      }\n    }\n  };\n\n  const normalise = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): [ x: number, y: number, w: number, h: number ] => {\n    let inX = Number.NaN;\n    let inY = Number.NaN;\n    let outW = defaultBounds.width;\n    let outH = defaultBounds.height;\n\n    if (typeof a === `number`) {\n      inX = a;\n      if (typeof b === `number`) {\n        inY = b;\n        if (c === undefined) return [ inX, inY, outW, outH ];\n        if (isRect(c)) {\n          outW = c.width;\n          outH = c.height;\n        } else if (typeof c === `number`) {\n          outW = c;\n          if (typeof d === `number`) {\n            outH = d;\n          } else {\n            throw new TypeError(`Missing final height value`);\n          }\n        } else throw new Error(`Missing valid output range`);\n      } else if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else {\n        throw new Error(\n          `Expected input y or output Rect to follow first number parameter`\n        );\n      }\n    } else if (isPoint(a)) {\n      inX = a.x;\n      inY = a.y;\n      if (b === undefined) return [ inX, inY, outW, outH ];\n      if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else if (typeof b === `number`) {\n        outW = b;\n        if (typeof c === `number`) {\n          outH = c;\n        } else {\n          throw new TypeError(\n            `Expected height as third parameter after Point and output width`\n          );\n        }\n      } else {\n        throw new TypeError(\n          `Expected Rect or width as second parameter when first parameter is a Point`\n        );\n      }\n    } else {\n      throw new Error(`Expected input Point or x value as first parameter`);\n    }\n    return [ inX, inY, outW, outH ];\n  };\n\n  const scaleAbs = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(true, ...n);\n  };\n\n  const scaleRel = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(false, ...n);\n  };\n\n  const scaleNormalised = (\n    abs: boolean,\n    x: number,\n    y: number,\n    w: number,\n    h: number\n  ): Point => {\n    if (Number.isNaN(w)) throw new Error(`Output width range missing`);\n    if (Number.isNaN(h)) throw new Error(`Output height range missing`);\n\n    // If output dimensions has changed since last, create a new scale\n    if (w !== sw || h !== sh) {\n      sw = w;\n      sh = h;\n      s = computeScale();\n    }\n\n    return abs ? {\n      x: x * s.x,\n      y: y * s.y,\n    } : {\n      x: x / s.x,\n      y: y / s.y,\n    };\n  };\n\n  return {\n    computeScale,\n    rel: scaleRel,\n    abs: scaleAbs,\n    width: defaultBounds.width,\n    height: defaultBounds.height\n  };\n};\n\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }","import type { Rgb, Rgb8Bit } from '../visual/Colour.js';\nimport * as ImageDataGrid from '../visual/ImageDataGrid.js';\nimport * as Grids from './grid/index.js';\n\nexport type Kernel<T> = ReadonlyArray<ReadonlyArray<T>>;\n//export type CellWithValue<V> = readonly [ cell: Grids.Cell, value: V | undefined ];\nexport type CellValueScalar<TCell, TKernel> = Grids.GridCellAndValue<TCell> & { kernel: TKernel };\n\nexport type KernelCompute = <V>(offset: Grids.GridCell, value: V) => V;\nexport type KernelReduce<TCell, TKernel> = (values: CellValueScalar<TCell, TKernel>[]) => TCell | undefined;\n\n/**\n * Multiply every element of kernel by the same `scalar` value.\n * Returns new result, input is unmodified\n * @param kernel \n * @param scalar \n * @returns \n */\nexport const multiply = (kernel: Kernel<number>, scalar: number): Kernel<number> => {\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  const copy: Array<Array<number>> = [];\n  for (let row = 0; row < rows; row++) {\n    copy[ row ] = [];\n    for (let col = 0; col < cols; col++) {\n      copy[ row ][ col ] = kernel[ row ][ col ] * scalar;\n    }\n  }\n  return copy;\n};\n\n\nexport function convolveCell<TCell, TKernel>(cell: Grids.GridCell, kernel: Kernel2dArray<TKernel>, source: Grids.GridReadable<TCell>, reduce: KernelReduce<TCell, TKernel>): TCell | undefined {\n  const valuesAtKernelPos: CellValueScalar<TCell, TKernel>[] = kernel.map(o => {\n    // For a kernel cell vector, get the position in the source grid\n    const pos = Grids.offset(source, cell, o.cell, `stop`); // `stop` avoids fringing at extents of image\n\n    // If there's no cell, return undefined\n    let kernelValue: TKernel | undefined;\n    let sourceValue: TCell | undefined;\n\n    if (pos) {\n      sourceValue = source.get(pos, `undefined`);\n      kernelValue = o.value;\n    }\n    //if (!pos) return { cell: o.cell, value: undefined, scalar: NaN } as CellValueScalar<T>;\n    return { cell: o.cell, value: sourceValue, kernel: o.value } as CellValueScalar<TCell, TKernel>;\n  });\n  return reduce(valuesAtKernelPos);\n}\n\n/**\n * Performs kernel-based convolution over `image`.\n * @param kernel \n * @param image \n */\nexport function* convolveImage(kernel: Kernel<number>, image: ImageData) {\n  //const grid = { rows: image.width, cols: image.height };\n  const imageDataAsGrid = ImageDataGrid.wrap(image);\n  yield* convolve(kernel, imageDataAsGrid, Grids.By.cells(imageDataAsGrid), rgbReducer);\n}\n\nexport function* convolve<TCell, TKernel>(kernel: Kernel<TKernel>, source: Grids.GridReadable<TCell>, visitor: Iterable<Grids.GridCell>, reduce: KernelReduce<TCell, TKernel>, origin?: Grids.GridCell): IterableIterator<Grids.GridCellAndValue<TCell>> {\n  if (!origin) {\n    const kernelRows = kernel.length;\n    const kernelCols = kernel[ 0 ].length;\n    origin = { x: Math.floor(kernelRows / 2), y: Math.floor(kernelCols / 2) };\n  }\n\n  const asArray = kernel2dToArray(kernel, origin);\n  // for (const c of visitor) {\n  //   const v = convolveCell<V>(c, asArray, source, access, reduce);\n  //   yield [ c, v ];\n  // }\n  for (const cell of visitor) {\n    const value = convolveCell<TCell, TKernel>(cell, asArray, source, reduce);\n    yield { cell, value };\n  }\n}\n\nexport type Kernel2dArray<T> = Array<Grids.GridCellAndValue<T>>;\n\n/**\n * For a given kernel, returns an array of offsets. These\n * consist of a cell offset (eg `{x:-1,y:-1}`) and the value at that kernel position.\n * @param kernel \n * @param origin \n * @returns \n */\nexport const kernel2dToArray = <T>(kernel: Kernel<T>, origin?: Grids.GridCell): Kernel2dArray<T> => {\n  const offsets: Kernel2dArray<T> = [];\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  if (!origin) {\n    origin = {\n      x: Math.floor(rows / 2),\n      y: Math.floor(cols / 2)\n    };\n  }\n\n  for (let xx = 0; xx < rows; xx++) {\n    for (let yy = 0; yy < cols; yy++) {\n      const v: Grids.GridCellAndValue<T> = {\n        cell: { x: xx - origin.x, y: yy - origin.y },\n        value: kernel[ xx ][ yy ]\n      }\n      offsets.push(v);\n      //offsets.push([ { x: xx - origin.x, y: yy - origin.y }, kernel[ xx ][ yy ] ]);\n    }\n  }\n  return offsets;\n};\n\nexport const rgbReducer: KernelReduce<Rgb8Bit, number> = (values: CellValueScalar<Rgb8Bit, number>[]) => {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let opacity = 0;\n  for (const value of values) {\n    const rgb = value.value;\n    const kernelValue = value.kernel;\n    if (!rgb) continue;\n    if (rgb.opacity === 0) continue;\n    if (kernelValue === 0) continue;\n    r += (rgb.r * kernelValue);\n    g += (rgb.g * kernelValue);\n    b += (rgb.b * kernelValue);\n    opacity += ((rgb.opacity ?? 1) * kernelValue);\n  }\n\n  const result: Rgb8Bit = {\n    r, g, b,\n    unit: `8bit`,\n    space: `srgb`,\n    opacity\n  };\n  return result;\n};\nexport const identityKernel = [\n  [ 0, 0, 0 ],\n  [ 0, 1, 0 ],\n  [ 0, 0, 0 ]\n];\n\nexport const edgeDetectionKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 4, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const sharpenKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 5, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const boxBlurKernel = multiply([\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ]\n], 1 / 9);\n\nexport const gaussianBlur3Kernel = multiply([\n  [ 1, 2, 1 ],\n  [ 2, 4, 2 ],\n  [ 1, 2, 1 ]\n], 1 / 16);\n\nexport const gaussianBlur5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, 36, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], 1 / 256);\n\nexport const unsharpMasking5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, -476, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], -1 / 256);","import * as Grids from '../geometry/grid/index.js';\nimport type { Rgb, Rgb8Bit } from './Colour.js';\nimport { toRgb8bit } from './Colour.js';\n\n/**\n * Returns a {@link Grids.Grid} based on the provided `image`\n * @param image ImageData\n * @returns Grid\n */\nexport const grid = (image: ImageData): Grids.Grid => {\n  const g = { rows: image.width, cols: image.height };\n  return g;\n}\n\n/**\n * Returns an object that allows get/set grid semantics on the underlying `image` data.\n * Uses 8-bit sRGB values, meaning 0..255 range for red, green, blue & opacity.\n * \n * ```js\n * // Get CANVAS element, drawing context and then image data\n * const canvasEl = document.querySelector(`#my-canvas`);\n * const ctx = canvasEl.getContext(`2d`);\n * const imageData = ctx.getImageData();\n * \n * // Now that we have image data, we can wrap it:\n * const asGrid = ImageDataGrid.wrap(imageData);\n * asGrid.get({ x:10, y: 20 }); // Get pixel at 10,20\n * asGrid.set(colour, { x:10, y: 20 }); // Set pixel value\n * \n * // Display changes back on the canvas\n * ctx.putImageData(imageData, 0, 0)\n * ```\n * @param image \n * @returns \n */\nexport const wrap = (image: ImageData): Grids.GridWritable<Rgb8Bit> & Grids.GridReadable<Rgb8Bit> => {\n  return {\n    ...grid(image),\n    get: accessor(image),\n    set: setter(image)\n  }\n}\n\n/**\n * Returns a function to access pixel values by x,y\n * @param image \n * @returns \n */\nexport const accessor = (image: ImageData): Grids.GridCellAccessor<Rgb8Bit> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellAccessor<Rgb8Bit> = (cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) return;\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      unit: `8bit`,\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns a function that sets pixel values\n * @param image \n * @returns \n */\nexport const setter = (image: ImageData): Grids.GridCellSetter<Rgb> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellSetter<Rgb> = (value: Rgb, cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) throw new Error(`Cell out of range. ${ cell.x },${ cell.y }`);\n    const pixel = toRgb8bit(value);\n    const pxIndex = index * 4;\n    data[ pxIndex ] = pixel.r;\n    data[ pxIndex + 1 ] = pixel.g;\n    data[ pxIndex + 2 ] = pixel.b;\n    data[ pxIndex + 3 ] = pixel.opacity ?? 255;\n  };\n  return fn;\n}\n\n// export function* visit(image: ImageData, visitor: Grids.VisitGenerator) {\n//   const a = accessor(image);\n\n//   for (const cell of visitor) {\n//     yield a(cell, `undefined`);\n//   }\n// }\n\n/**\n * Yields pixels of an image row by row\n * @param image \n */\nexport function* byRow(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  const v = Grids.As.rows(g, { x: 0, y: 0 });\n  for (const row of v) {\n    const pixels = row.map(p => a(p, `undefined`));\n    yield pixels\n  }\n}\n\n/**\n * Yields pixels of an image column by column\n * @param image \n */\nexport function* byColumn(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  //Grids.visitorRow\n  for (let x = 0; x < g.cols; x++) {\n    const col: Array<Rgb8Bit> = [];\n    for (let y = 0; y < g.rows; y++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) col.push(p);\n    }\n    yield col;\n  }\n}","import { degreeToRadian, radianArc, radiansSum } from '../Angles.js';\nimport { guard as guardPoint, isPoint } from '../point/Guard.js';\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { bbox as pointsBbox } from '../point/Bbox.js';\nimport { toCartesian } from '../Polar.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Line } from '../line/LineType.js';\nimport type { Path } from '../path/index.js';\nimport type { Rect, RectPositioned } from '../rect/index.js';\nimport { fromPoints as LinesFromPoints } from '../line/FromPoints.js';\nimport type { Arc, ArcPositioned } from './ArcType.js';\nimport type { CirclePositioned } from '../Types.js';\n\nexport type * from './ArcType.js';\n\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns \n */\nexport const isArc = (p: unknown): p is Arc => (p as Arc).startRadian !== undefined && (p as Arc).endRadian !== undefined && (p as Arc).clockwise !== undefined;\n\n/**\n * Returns true if parameter has a positioned (x,y) \n * @param p Point, Arc or ArcPositiond\n * @returns \n */\nexport const isPositioned = (p: Point | Arc | ArcPositioned): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n\nconst piPi = Math.PI * 2;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean): Arc;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */export function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin: Point): ArcPositioned\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin?: Point): Arc | ArcPositioned {\n  const a: Arc = {\n    radius,\n    startRadian: degreeToRadian(startDegrees),\n    endRadian: degreeToRadian(endDegrees),\n    clockwise\n  };\n  if (isPoint(origin)) {\n    guardPoint(origin);\n    const ap: ArcPositioned = {\n      ...a,\n      x: origin.x,\n      y: origin.y\n    };\n    return Object.freeze(ap);\n  } else {\n    return Object.freeze(a);\n  }\n}\n\n/**\n * Returns a {@link Geometry.Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc: ArcPositioned): Line => LinesFromPoints(\n  point(arc, arc.startRadian),\n  point(arc, arc.endRadian)\n);\n\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n * \n * See also: \n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc \n * @param origin \n * @returns \n */\nexport const getStartEnd = (arc: ArcPositioned | Arc, origin?: Point): [ start: Point, end: Point ] => {\n  guard(arc);\n  const start = point(arc, arc.startRadian, origin);\n  const end = point(arc, arc.endRadian, origin);\n  return [ start, end ];\n}\n\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n * \n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate \n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point): Point => {\n\n  if (origin === undefined) {\n    origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n    y: (Math.sin(angleRadian) * arc.radius) + origin.y\n  };\n};\n\n/**\n * Throws an error if arc instance is invalid\n * @param arc \n */\nexport const guard = (arc: Arc | ArcPositioned) => {\n  if (arc === undefined) throw new TypeError(`Arc is undefined`);\n  if (isPositioned(arc)) {\n    guardPoint(arc, `arc`);\n  }\n  if (arc.radius === undefined) throw new TypeError(`Arc radius is undefined (${ JSON.stringify(arc) })`);\n  if (typeof arc.radius !== `number`) throw new TypeError(`Radius must be a number`);\n  if (Number.isNaN(arc.radius)) throw new TypeError(`Radius is NaN`);\n  if (arc.radius <= 0) throw new TypeError(`Radius must be greater than zero`);\n\n  if (arc.startRadian === undefined) throw new TypeError(`Arc is missing 'startRadian' field`);\n  if (arc.endRadian === undefined) throw new TypeError(`Arc is missing 'startRadian' field`);\n  if (Number.isNaN(arc.endRadian)) throw new TypeError(`Arc endRadian is NaN`);\n  if (Number.isNaN(arc.startRadian)) throw new TypeError(`Arc endRadian is NaN`);\n\n  if (arc.clockwise === undefined) throw new TypeError(`Arc is missing 'clockwise field`);\n  if (arc.startRadian >= arc.endRadian) throw new TypeError(`startRadian is expected to be les than endRadian`);\n};\n\n\ntype Interpolate = {\n  (amount: number, arc: Arc, allowOverflow: boolean, origin: Point): Point;\n  (amount: number, arc: ArcPositioned, allowOverflow?: boolean): Point;\n};\n\n/**\n * Compute relative position on arc.\n * \n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns \n */\nexport const interpolate: Interpolate = (amount: number, arc: ArcPositioned | Arc, allowOverflow?: boolean, origin?: Point): Point => {\n  guard(arc);\n  const overflowOk = allowOverflow ?? false;\n  if (!overflowOk) {\n    if (amount < 0) throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);\n    if (amount > 1) throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);\n  }\n  const span = angularSize(arc); // angular size\n  const rel = span * amount;\n  const angle = radiansSum(arc.startRadian, rel, arc.clockwise);\n  //console.log(`interpolate span: ${ span.toFixed(2) } rel: ${ rel.toFixed(2) } angle: ${ angle.toFixed(2) } amt: ${ amount.toFixed(2) } cw: ${ arc.clockwise } start: ${ arc.startRadian }`);\n  return point(arc, angle, origin);\n  //return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc \n */\nexport const angularSize = (arc: Arc) => radianArc(arc.startRadian, arc.endRadian, arc.clockwise)\n\n/**\n * Creates a {@link Geometry.Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc \n * @returns Path\n */\nexport const toPath = (arc: ArcPositioned): Path => {\n  guard(arc);\n\n  return Object.freeze({\n    ...arc,\n    nearest: (point: Point) => { throw new Error(`not implemented`); },\n    interpolate: (amount: number) => interpolate(amount, arc),\n    bbox: () => bbox(arc) as RectPositioned,\n    length: () => length(arc),\n    toSvgString: () => toSvg(arc),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `arc`\n  });\n};\n\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns \n */\nexport const fromCircle = (circle: CirclePositioned, startRadian: number, endRadian: number, clockwise = true): ArcPositioned => {\n  const a: ArcPositioned = Object.freeze({\n    ...circle,\n    endRadian,\n    startRadian,\n    clockwise\n  });\n  return a;\n}\n\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns \n */\nexport const fromCircleAmount = (circle: CirclePositioned, startRadian: number, sizeRadian: number, clockwise = true): ArcPositioned => {\n  const endRadian = radiansSum(startRadian, sizeRadian, clockwise);\n  return fromCircle(circle, startRadian, endRadian)\n}\n\n\n/**\n * Calculates the length of the arc\n * @param arc \n * @returns Length\n */\nexport const length = (arc: Arc): number => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n\n/**\n * Calculates a {@link Geometry.Rect | Rect} bounding box for arc.\n * @param arc \n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc: ArcPositioned | Arc): RectPositioned | Rect => {\n  if (isPositioned(arc)) {\n    const middle = interpolate(0.5, arc);\n    const asLine = toLine(arc);\n    return pointsBbox(middle, asLine.a, asLine.b);\n  } else {\n    return {\n      width: arc.radius * 2,\n      height: arc.radius * 2\n    };\n  }\n};\n\n\ntype ToSvg = {\n  /**\n   * SVG path for arc description\n   * @param origin Origin of arc\n   * @param radius Radius\n   * @param startRadian Start\n   * @param endRadian End\n   */\n  (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: SvgOpts): ReadonlyArray<string>;\n  /**\n   * SVG path for non-positioned arc.\n   * If `arc` does have a position, `origin` will override it.\n   */\n  (arc: Arc, origin: Point, opts?: SvgOpts): ReadonlyArray<string>;\n  /**\n   * SVG path for positioned arc\n   */\n  (arc: ArcPositioned, opts?: SvgOpts): ReadonlyArray<string>;\n};\n\n\n/**\n * Creates an SV path snippet for arc\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg: ToSvg = (a: Point | Arc | ArcPositioned, b?: number | Point | SvgOpts, c?: number | SvgOpts, d?: number, e?: SvgOpts) => {\n  if (isArc(a)) {\n    if (isPositioned(a)) {\n      if (isPoint(b)) {\n        // Passing in a origin override\n        return toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as SvgOpts)\n      } else {\n        // Using origin in arc\n        return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b as SvgOpts);\n      }\n    } else {\n      return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as SvgOpts) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n    }\n  } else {\n    if (c === undefined) throw new Error(`startAngle undefined`);\n    if (d === undefined) throw new Error(`endAngle undefined`);\n\n    if (isPoint(a)) {\n      if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n        return toSvgFull(a, b, c, d, e);\n      } else {\n        throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n      }\n    } else {\n      throw new Error(`Expected (point, number, number, number). Missing first point.`);\n    }\n  }\n};\n\nexport type SvgOpts = {\n\n  /**\n   * \"If the arc should be greater or less than 180 degrees\"\n   * ie. tries to maximise arc length\n   */\n  readonly largeArc?: boolean\n\n  /**\n   * \"If the arc should begin moving at positive angles\"\n   * ie. the kind of bend it makes to reach end point\n   */\n  readonly sweep?: boolean\n}\n\nconst toSvgFull = (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: SvgOpts): ReadonlyArray<string> => {\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n  // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n  // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n\n  if (opts === undefined || typeof opts !== `object`) opts = {};\n\n  const isFullCircle = endRadian - startRadian === 360;\n  const start = toCartesian(radius, endRadian - 0.01, origin);\n  const end = toCartesian(radius, startRadian, origin);\n\n  const { largeArc = false, sweep = false } = opts;\n\n  const d = [ `\n    M ${ start.x } ${ start.y }\n    A ${ radius } ${ radius } 0 ${ largeArc ? `1` : `0` } ${ sweep ? `1` : `0` } ${ end.x } ${ end.y },\n  `];\n\n  //eslint-disable-next-line functional/immutable-data\n  if (isFullCircle) d.push(`z`);\n\n  return d;\n};\n\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b \n * @returns Distance \n */\nexport const distanceCenter = (a: ArcPositioned, b: ArcPositioned): number => pointsDistance(a, b);\n\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a: Arc | ArcPositioned, b: Arc | ArcPositioned): boolean => {\n  if (a.radius !== b.radius) return false;\n  if (a.endRadian !== b.endRadian) return false;\n  if (a.startRadian !== b.startRadian) return false;\n  if (a.clockwise !== b.clockwise) return false;\n\n  if (isPositioned(a) && isPositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return true;\n};","import type { Line } from './line/LineType.js';\nimport type { Point } from './point/PointType.js';\nimport { normalise as PointsNormalise } from './point/Normalise.js';\nimport { isPoint } from './point/Guard.js';\n//import * as Points from './point/index.js'\nimport * as Polar from './Polar.js';\nimport type { Vector } from './Types.js';\nimport { divide as PointDivide } from './point/Divider.js';\nimport { guard as LinesGuard } from './line/Guard.js';\nimport { sum as PointsSum } from './point/Sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/Multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/DotProduct.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/Magnitude.js';\nimport { distance as PointsDistance } from './point/Distance.js';\nimport { Empty as PointEmpty } from './point/Empty.js';\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\n\nexport const fromRadians = (radians: number) => {\n  return Object.freeze({\n    x: Math.cos(radians),\n    y: Math.sin(radians)\n  });\n}\n\nexport const toRadians = (point: Point) => {\n  return Math.atan2(point.y, point.x);\n}\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2\n * if `bipolar` normalisation is used, direction will be fixed to -...\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (\n  pt: Point,\n  angleNormalisation: `` | `unipolar` | `bipolar` = ``,\n  origin: Point = EmptyCartesian\n): Polar.Coord => {\n  pt = PointsSubtract(pt, origin);\n\n  //eslint-disable-next-line functional/no-let\n  let direction = Math.atan2(pt.y, pt.x);\n  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi;\n  else if (angleNormalisation === `bipolar`) {\n    if (direction > pi) direction -= piPi;\n    else if (direction <= -pi) direction += piPi;\n  }\n\n  return Object.freeze({\n    distance: PointsDistance(pt),\n    angleRadian: direction,\n  });\n};\n\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line: Line): Point =>\n  PointsSubtract(line.b, line.a);\n\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line: Line): Polar.Coord => {\n  LinesGuard(line, `line`);\n  const pt = PointsSubtract(line.b, line.a);\n  return fromPointPolar(pt);\n};\n\nconst isPolar = (v: Vector): v is Polar.Coord => {\n  if (Polar.isPolarCoord(v)) return true;\n  return false;\n};\n\nconst isCartesian = (v: Vector): v is Point => {\n  if (isPoint(v)) return true;\n  return false;\n};\n\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v: Vector): Vector => {\n  if (isPolar(v)) {\n    return Polar.normalise(v);\n  } else if (isCartesian(v)) {\n    return PointsNormalise(v);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\nexport const quadrantOffsetAngle = (p: Point): number => {\n  if (p.x >= 0 && p.y >= 0) return 0; // Q1\n  if (p.x < 0 && p.y >= 0) return pi; // Q2\n  if (p.x < 0 && p.y < 0) return pi; // Q3\n  return piPi; // Q4\n};\n\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v: Vector, origin = PointEmpty): Polar.Coord => {\n  if (isPolar(v)) {\n    return v;\n  } else if (isCartesian(v)) {\n    return Polar.fromCartesian(v, origin);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v: Vector): Point => {\n  if (isPolar(v)) {\n    return Polar.toPoint(v);\n  } else if (isCartesian(v)) {\n    return v;\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v: Vector, digits?: number) => {\n  if (isPolar(v)) {\n    return Polar.toString(v, digits);\n  } else if (isCartesian(v)) {\n    return PointsToString(v, digits);\n  }\n  // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Vector, b: Vector) => {\n  if (isPolar(a) && isPolar(b)) {\n    return Polar.dotProduct(a, b);\n  } else if (isCartesian(a) && isCartesian(b)) {\n    return PointsDotProduct(a, b);\n  }\n  throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v: Vector, max = 1, min = 0) => {\n  if (isPolar(v)) {\n    return Polar.clampMagnitude(v, max, min);\n  } else if (isCartesian(v)) {\n    return PointsClampMagnitude(v, max, min);\n  }\n  throw new Error(`Expected either polar or Cartesian vector`);\n};\n\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSum(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSubtract(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsMultiply(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointDivide(a, b);\n  return polar ? toPolar(c) : c;\n};\n","import type { Point, Point3d } from './point/PointType.js';\nimport type { Circle, CirclePositioned } from './circle/CircleType.js';\nimport type { Sphere } from './shape/index.js';\n\nimport { toPositioned as circleToPositioned } from './circle/ToPositioned.js';\nimport { scale } from '../numbers/Scale.js';\nimport { linearSpace } from '../numbers/LinearSpace.js';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n  /**\n   * Upper limit of points to produce.\n   * By default, 5000.\n   */\n  readonly maxPoints?: number;\n  /**\n   * Density value (0..1) which determines spacing of points.\n   * This is useful because it scales with whatever circle radius is given\n   * Use this parameter OR the `spacing` parameter.\n   */\n  readonly density?: number;\n  /**\n   * Spacing between points.\n   * Use this option OR the density value.\n   */\n  readonly spacing?: number;\n  /**\n   * Rotation offset to apply, in radians. 0 by default\n   */\n  readonly rotation?: number;\n};\n\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(\n  circle?: Circle,\n  opts: VogelSpiralOpts = {}\n): IterableIterator<Point> {\n  const maxPoints = opts.maxPoints ?? 5000;\n  const density = opts.density ?? 0.95;\n  const rotationOffset = opts.rotation ?? 0;\n\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const max = c.radius;\n  //eslint-disable-next-line functional/no-let\n  let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n  if (opts.spacing) spacing = opts.spacing;\n\n  //eslint-disable-next-line functional/no-let\n  let radius = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n  //eslint-disable-next-line functional/no-let\n  let angle = 0;\n  while (count < maxPoints && radius < max) {\n    radius = spacing * count ** 0.5;\n    angle = rotationOffset + (count * 2 * pi) / goldenSection;\n    yield Object.freeze({\n      x: c.x + radius * cos(angle),\n      y: c.y + radius * sin(angle),\n    });\n    count++;\n  }\n}\n\nexport type CircleRingsOpts = {\n  readonly rings?: number;\n  /**\n   * Rotation offset, in radians\n   */\n  readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(\n  circle?: Circle | CirclePositioned,\n  opts: CircleRingsOpts = {}\n): IterableIterator<Point> {\n  const rings = opts.rings ?? 5;\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const ringR = 1 / rings;\n  const rotationOffset = opts.rotation ?? 0;\n\n  //eslint-disable-next-line functional/no-let\n  let ringCount = 1;\n\n  // Origin\n  yield Object.freeze({ x: c.x, y: c.y });\n\n  //eslint-disable-next-line functional/no-let\n  for (let r = ringR; r <= 1; r += ringR) {\n    const n = Math.round(pi / asin(1 / (2 * ringCount)));\n    for (const theta of linearSpace(0, piPi, n + 1)) {\n      yield Object.freeze({\n        x: c.x + r * cos(theta + rotationOffset) * c.radius,\n        y: c.y + r * sin(theta + rotationOffset) * c.radius,\n      });\n    }\n    ringCount++;\n  }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(\n  samples = 100,\n  rotationRadians = 0,\n  sphere?: Sphere\n): IterableIterator<Point3d> {\n  const offset = 2 / samples;\n  const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n\n  for (let index = 0; index < samples; index++) {\n    const y = index * offset - 1 + offset / 2;\n    const r = sqrt(1 - pow(y, 2));\n    const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n    const x = cos(a) * r;\n    const z = sin(a) * r;\n    //eslint-disable-next-line functional/immutable-data\n    yield Object.freeze({\n      x: s.x + x * s.radius,\n      y: s.y + y * s.radius,\n      z: s.z + z * s.radius,\n    });\n  }\n}\n","import * as Polar from '../Polar.js';\nimport * as Points from '../point/index.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { radianToDegree } from '../Angles.js';\nimport { guard } from './Guard.js';\nimport { intersectsPoint as RectsIntersectsPoint } from '../rect/Intersects.js';\nimport type { RectPositioned } from '../Types.js';\nimport type { Point } from '../point/PointType.js';\nimport { getPointParameter } from '../point/GetPointParameter.js';\nimport type { Triangle } from './TriangleType.js';\n\nexport * from './Area.js';\nexport * from './Centroid.js';\nexport * from './Edges.js';\nexport * from './InnerCircle.js';\nexport * from './Guard.js';\nexport * from './OuterCircle.js';\nexport * from './Perimeter.js';\nexport * from './Rotate.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './Equilateral.js';\n\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './Right.js';\n\nexport * as Isosceles from './Isosceles.js';\n\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n\n\nconst piPi = Math.PI * 2;\n\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\n \nexport const Empty = Object.freeze({\n  a: { x: 0, y: 0 },\n  b: { x: 0, y: 0 },\n  c: { x: 0, y: 0 },\n});\n\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\n \nexport const Placeholder = Object.freeze({\n  a: { x: Number.NaN, y: Number.NaN },\n  b: { x: Number.NaN, y: Number.NaN },\n  c: { x: Number.NaN, y: Number.NaN },\n});\n\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t: Triangle): boolean =>\n  Points.isEmpty(t.a) && Points.isEmpty(t.b) && Points.isEmpty(t.c);\n\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t: Triangle): boolean =>\n  Points.isPlaceholder(t.a) &&\n  Points.isPlaceholder(t.b) &&\n  Points.isPlaceholder(t.c);\n\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport const apply = (\n  t: Triangle,\n  fn: (p: Point, label?: string) => Point\n) =>\n  Object.freeze<Triangle>({\n    ...t,\n    a: fn(t.a, `a`),\n    b: fn(t.b, `b`),\n    c: fn(t.c, `c`),\n  });\n\n\n\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p: unknown): p is Triangle => {\n  if (p === undefined) return false;\n  const tri = p as Triangle;\n  if (!Points.isPoint(tri.a)) return false;\n  if (!Points.isPoint(tri.b)) return false;\n  if (!Points.isPoint(tri.c)) return false;\n  return true;\n};\n\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: Triangle, b: Triangle): boolean =>\n  Points.isEqual(a.a, b.a) &&\n  Points.isEqual(a.b, b.b) &&\n  Points.isEqual(a.c, b.c);\n\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t: Triangle): ReadonlyArray<Point> => {\n  guard(t);\n  return [ t.a, t.b, t.c ];\n};\n\n\n\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    Points.distance(t.a, t.b),\n    Points.distance(t.b, t.c),\n    Points.distance(t.c, t.a),\n  ];\n};\n\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    Points.angleRadian(t.a, t.b),\n    Points.angleRadian(t.b, t.c),\n    Points.angleRadian(t.c, t.a),\n  ];\n};\n\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return radianToDegree(angles(t));\n};\n\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t: Triangle): boolean => {\n  guard(t);\n  const [ a, b, c ] = lengths(t);\n  return a === b && b === c;\n};\n\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t: Triangle): boolean => {\n  const [ a, b, c ] = lengths(t);\n  if (a === b) return true;\n  if (b === c) return true;\n  if (c === a) return true;\n  return false;\n};\n\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t: Triangle): boolean =>\n  angles(t).includes(Math.PI / 2);\n\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t: Triangle): boolean => !isRightAngle(t);\n\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t: Triangle): boolean =>\n  !angles(t).some((v) => v >= Math.PI / 2);\n\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t: Triangle): boolean =>\n  angles(t).some((v) => v > Math.PI / 2);\n\n\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (\n  origin: Point,\n  radius: number,\n  opts: { readonly initialAngleRadian?: number } = {}\n): Triangle => {\n  throwNumberTest(radius, `positive`, `radius`);\n  Points.guard(origin, `origin`);\n\n  const initialAngleRadian = opts.initialAngleRadian ?? 0;\n\n  const angles = [\n    initialAngleRadian,\n    initialAngleRadian + (piPi * 1) / 3,\n    initialAngleRadian + (piPi * 2) / 3,\n  ];\n  const points = angles.map((a) => Polar.toCartesian(radius, a, origin));\n  return fromPoints(points);\n};\n\n\n\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (\n  origin?: Point,\n  length = 10,\n  angleRadian: number = Math.PI / 2\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const a = Points.project(origin, length, Math.PI - -angleRadian / 2);\n  const c = Points.project(origin, length, Math.PI - angleRadian / 2);\n  return { a, b: origin, c };\n};\n\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport const toFlatArray = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [ t.a.x, t.a.y, t.b.x, t.b.y, t.c.x, t.c.y ];\n};\n\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords: ReadonlyArray<number>): Triangle => {\n  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);\n  if (coords.length !== 6) {\n    throw new Error(\n      `coords array expected with 6 elements. Got ${ coords.length }`\n    );\n  }\n  return fromPoints(Points.fromNumbers(...coords));\n};\n\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points: ReadonlyArray<Point>): Triangle => {\n  if (!Array.isArray(points)) throw new Error(`points expected as array`);\n  if (points.length !== 3) {\n    throw new Error(\n      `points array expected with 3 elements. Got ${ points.length }`\n    );\n  }\n  const t: Triangle = {\n    a: points[ 0 ],\n    b: points[ 1 ],\n    c: points[ 2 ],\n  };\n  return t;\n};\n\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t: Triangle, inflation = 0): RectPositioned => {\n  const { a, b, c } = t;\n  const xMin = Math.min(a.x, b.x, c.x) - inflation;\n  const xMax = Math.max(a.x, b.x, c.x) + inflation;\n  const yMin = Math.min(a.y, b.y, c.y) - inflation;\n  const yMax = Math.max(a.y, b.y, c.y) + inflation;\n\n  const r: RectPositioned = {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin,\n  };\n  return r;\n};\n\nexport type BarycentricCoord = {\n  readonly a: number;\n  readonly b: number;\n  readonly c: number;\n};\n\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): BarycentricCoord => {\n  const pt = getPointParameter(a, b);\n\n  const ab = (x: number, y: number, pa: Point, pb: Point) =>\n    (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n\n  const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n  const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n  const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n\n  return {\n    a: alpha,\n    b: theta,\n    c: gamma,\n  };\n};\n\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (\n  t: Triangle,\n  bc: BarycentricCoord\n): Point => {\n  guard(t);\n  const { a, b, c } = t;\n\n  const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n  const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n\n  if (a.z && b.z && c.z) {\n    const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n    return Object.freeze({ x, y, z });\n  } else {\n    return Object.freeze({ x, y });\n  }\n};\n\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport const intersectsPoint = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): boolean => {\n  const box = bbox(t);\n\n  const pt = getPointParameter(a, b);\n\n  // If it's not in the bounding box, can return false straight away\n  if (!RectsIntersectsPoint(box, pt)) return false;\n\n  const bc = barycentricCoord(t, pt);\n\n  return (\n    0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1\n  );\n};\n","import type { Triangle } from \"./TriangleType.js\";\nimport { guard as PointsGuard } from '../point/Guard.js'\n\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t: Triangle, name = `t`) => {\n  if (t === undefined) throw new Error(`{$name} undefined`);\n  PointsGuard(t.a, name + `.a`);\n  PointsGuard(t.b, name + `.b`);\n  PointsGuard(t.c, name + `.c`);\n};","\nimport type { Triangle } from \"../Types.js\";\nimport type { PolyLine } from \"../line/LineType.js\";\nimport { joinPointsToLines } from \"../line/JoinPointsToLines.js\";\nimport { guard } from \"./Guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t: Triangle): PolyLine => {\n  guard(t);\n  return joinPointsToLines(t.a, t.b, t.c, t.a);\n};","import { guard } from \"./Guard.js\";\nimport { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t: Triangle): number => {\n  guard(t, `t`);\n\n  // Get length of edges\n  const lengths = edges(t).map((l) => LinesLength(l));\n\n  // Add up length of edges, halve\n  const p = (lengths[ 0 ] + lengths[ 1 ] + lengths[ 2 ]) / 2;\n  return Math.sqrt(p * (p - lengths[ 0 ]) * (p - lengths[ 1 ]) * (p - lengths[ 2 ]));\n};","import type { Point } from \"../point/PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t: Triangle): Point => {\n  guard(t);\n  const total = PointsReduce(\n    [ t.a, t.b, t.c ],\n    (p: Point, accumulator: Point) => ({\n      x: p.x + accumulator.x,\n      y: p.y + accumulator.y,\n    })\n  );\n  const div = {\n    x: total.x / 3,\n    y: total.y / 3,\n  };\n  return div;\n};","import { guard } from \"./Guard.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\n\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t: Triangle): number => {\n  guard(t);\n  return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};","import type { CirclePositioned } from \"../circle/CircleType.js\";\nimport { area } from \"./Area.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { perimeter } from \"./Perimeter.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t: Triangle): CirclePositioned => {\n  const c = centroid(t);\n  const p = perimeter(t) / 2;\n  const a = area(t);\n  const radius = a / p;\n  return { radius, ...c };\n};","import { length as LinesLength } from '../line/Length.js';\nimport { edges } from \"./Edges.js\";\nimport { centroid } from './Centroid.js';\nimport type { Triangle } from \"./TriangleType.js\";\nimport type { CirclePositioned } from '../circle/CircleType.js';\n\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t: Triangle): CirclePositioned => {\n  const [ a, b, c ] = edges(t).map((l) => LinesLength(l));\n  const cent = centroid(t);\n  const radius =\n    (a * b * c) /\n    Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n  return {\n    radius,\n    ...cent,\n  };\n};","import type { Point } from \"../point/PointType.js\";\nimport { centroid } from \"./Centroid.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * \n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport const rotate = (\n  triangle: Triangle,\n  amountRadian?: number,\n  origin?: Point\n): Triangle => {\n  if (amountRadian === undefined || amountRadian === 0) return triangle;\n  if (origin === undefined) origin = centroid(triangle);\n  return Object.freeze({\n    ...triangle,\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};\n\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n * \n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport const rotateByVertex = (\n  triangle: Triangle,\n  amountRadian: number,\n  vertex: `a` | `b` | `c` = `b`\n): Triangle => {\n  const origin =\n    vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n  return Object.freeze({\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};","import type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\n\nconst pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\n\nexport type TriangleEquilateral =\n  | {\n    readonly length: number;\n  }\n  | number;\n\nconst resolveLength = (t: TriangleEquilateral): number => {\n  if (typeof t === `number`) return t;\n  return t.length;\n};\n\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * *  0: a and c on vertical, b at the tip\n * *  Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * *  Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * *  Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (\n  t: TriangleEquilateral,\n  origin?: Point,\n  rotationRad?: number\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t) / Math.sqrt(3);\n  const rot = rotationRad ?? Math.PI * 1.5;\n  const b = {\n    x: r * Math.cos(rot) + origin.x,\n    y: r * Math.sin(rot) + origin.y,\n  };\n  const a = {\n    x: r * Math.cos(rot + pi4over3) + origin.x,\n    y: r * Math.sin(rot + pi4over3) + origin.y,\n  };\n  const c = {\n    x: r * Math.cos(rot + pi2over3) + origin.x,\n    y: r * Math.sin(rot + pi2over3) + origin.y,\n  };\n\n  return Object.freeze({ a, b, c });\n};\n\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (\n  t: TriangleEquilateral,\n  ptA?: Point\n): Point => {\n  if (!ptA) ptA = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n  return {\n    x: ptA.x + r / 2,\n    y: ptA.y - radius,\n  };\n};\n\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (\n  t: TriangleEquilateral,\n  ptB?: Point\n): Point => {\n  if (!ptB) ptB = Object.freeze({ x: 0, y: 0 })\n\n  const { radius } = incircle(t);\n  return {\n    x: ptB.x,\n    y: ptB.y + radius * 2,\n  };\n};\n\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (\n  t: TriangleEquilateral,\n  ptC?: Point\n): Point => {\n  if (!ptC) ptC = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n\n  return {\n    x: ptC.x - r / 2,\n    y: ptC.y - radius,\n  };\n};\n\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t: TriangleEquilateral): number =>\n  (Math.sqrt(3) / 2) * resolveLength(t);\n\nexport const perimeter = (t: TriangleEquilateral): number =>\n  resolveLength(t) * 3;\n\nexport const area = (t: TriangleEquilateral): number =>\n  (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","import type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nexport type Right = {\n  readonly adjacent?: number;\n  readonly hypotenuse?: number;\n  readonly opposite?: number;\n};\n\nexport type DefinedRight = {\n  readonly adjacent: number;\n  readonly hypotenuse: number;\n  readonly opposite: number;\n};\n\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x + seg[ 1 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x - seg[ 0 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - seg[ 1 ], y: origin.y + h };\n  const b = { x: origin.x + seg[ 0 ], y: origin.y + h };\n  return { a, b, c };\n};\n\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t: Right): DefinedRight => {\n  const a = t.adjacent;\n  const o = t.opposite;\n  const h = t.hypotenuse;\n\n  if (a !== undefined && o !== undefined) {\n    return {\n      ...t,\n      adjacent: a,\n      opposite: o,\n      hypotenuse: Math.hypot(a, o),\n    };\n  } else if (a && h) {\n    return {\n      ...t,\n      adjacent: a,\n      hypotenuse: h,\n      opposite: h * h - a * a,\n    };\n  } else if (o && h) {\n    return {\n      ...t,\n      hypotenuse: h,\n      opposite: o,\n      adjacent: h * h - o * o,\n    };\n  } else if (t.opposite && t.hypotenuse && t.adjacent) {\n    return t as DefinedRight;\n  }\n  throw new Error(`Missing at least two edges`);\n};\n\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t: Right): number => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return Math.sqrt(p * q);\n};\n\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (\n  t: Right\n): readonly [ p: number, q: number ] => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return [ p, q ];\n};\n\nexport const perimeter = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\n\nexport const area = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return (tt.opposite * tt.adjacent) / 2;\n};\n\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.adjacent * tt.adjacent +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.opposite * tt.opposite) /\n    (2 * tt.adjacent * tt.hypotenuse)\n  );\n};\n\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.opposite * tt.opposite +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.adjacent * tt.adjacent) /\n    (2 * tt.opposite * tt.hypotenuse)\n  );\n};\n\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (\n  t: Right\n): readonly [ a: number, b: number, c: number ] => {\n  const tt = resolveLengths(t);\n  const b = tt.adjacent * tt.adjacent;\n  const c = tt.hypotenuse * tt.hypotenuse;\n  const a = tt.opposite * tt.opposite;\n\n  return [\n    Math.sqrt(2 * (b + c) - a) / 2,\n    Math.sqrt(2 * (c + a) - b) / 2,\n    Math.sqrt(2 * (a + b) - c) / 2,\n  ];\n};\n\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return { radius: tt.hypotenuse / 2 };\n};\n\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return {\n    radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n  };\n};\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (\n  angleRad: number,\n  adjacent: number\n): number => Math.tan(angleRad) * adjacent;\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (\n  angleRad: number,\n  hypotenuse: number\n): number => Math.sin(angleRad) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport const adjacentFromHypotenuse = (\n  angleRadian: number,\n  hypotenuse: number\n): number => Math.cos(angleRadian) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.tan(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const hypotenuseFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.sin(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (\n  angleRadian: number,\n  adjacent: number\n): number => adjacent / Math.cos(angleRadian);\n","\nimport type { Circle } from \"../circle/CircleType.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Triangle } from \"./TriangleType.js\";\nexport type Isosceles = {\n  readonly legs: number;\n  readonly base: number;\n};\n\nexport const baseAngle = (t: Isosceles): number =>\n  Math.acos(t.base / (2 * t.legs));\n\nexport const apexAngle = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.acos((2 * aa - cc) / (2 * aa));\n};\n\nexport const height = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.sqrt((4 * aa - cc) / 4);\n};\n\nexport const legHeights = (t: Isosceles): number => {\n  const b = baseAngle(t);\n  return t.base * Math.sin(b);\n};\n\nexport const perimeter = (t: Isosceles): number => 2 * t.legs + t.base;\n\nexport const area = (t: Isosceles): number => {\n  const h = height(t);\n  return (h * t.base) / 2;\n};\n\nexport const circumcircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  const hh = h * h;\n  const cc = t.base * t.base;\n  return { radius: (4 * hh + cc) / (8 * h) };\n};\n\nexport const incircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\n\nexport const medians = (\n  t: Isosceles\n): readonly [ a: number, b: number, c: number ] => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n  const medianC = Math.sqrt(4 * aa - cc) / 2;\n  return [ medianAB, medianAB, medianC ];\n};\n\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const incircleR = incircle(t).radius;\n  const verticalToApex = h - incircleR;\n\n  const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n  const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n  const c = { x: origin.x, y: origin.y - verticalToApex };\n  return { a, b, c };\n};\n\nexport const fromA = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + t.base, y: origin.y };\n  const c = { x: origin.x + t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromB = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base, y: origin.y };\n  const c = { x: origin.x - t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromC = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base / 2, y: origin.y + h };\n  const b = { x: origin.x + t.base / 2, y: origin.y + h };\n  return { a, b, c };\n};\n"],"mappings":"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","names":["fromPoints","distance","getPointParameter","Empty","angleRadian","bbox","distance","divide","fromNumbers","getPointParameter","guard","isEmpty","isEqual","isPlaceholder","multiply","normaliseByRect","rotate","subtract","sum","toString","point","line","length","point","guard","bbox","divide","point","fromNumbers","length","angleRadian","isEqual","multiply","point","rotate","subtract","point","sum","point","toString","guard","Empty","isEmpty","isPlaceholder","angleRadian","normaliseByRect","height","point","distance","point","bbox","toString","rotate","sum","divide","multiply","subtract","distance","isEqual","fromPoints","nearest","distance","random","center","isIntersecting","randomPoint","isIntersecting","offset","center","randomPoint","isPositioned","isIntersecting","randomPoint","center","angleRadian","arrow","random","isIntersecting","randomPoint","bbox","center","guard","interpolate","isEqual","isIntersecting","length","multiplyScalar","nearest","toPath","guard","height","bbox","piPi","nearest","point","angleRadian","guard","length","piPi","interpolate","multiplyScalar","toPath","guard","point","nearest","interpolate","bbox","Empty","Placeholder","area","distanceFromExterior","divide","fromNumbers","guard","guardPositioned","isEmpty","isEqual","isPlaceholder","isPositioned","multiply","multiplyScalar","randomPoint","subtract","sum","area","guard","height","isPositioned","guard","height","divide","guard","Empty","fromNumbers","height","isEqual","isPositioned","guardPositioned","multiply","multiplyScalar","Placeholder","subtract","isPositioned","sum","isPositioned","isPositioned","isEqual","grid","grid","grid","wrap","grid","wrap","columns","rows","access","set","setMutate","wrap","wrapMutable","setMutate","grid","wrap","setMutateWithGrid","access","accessWithGrid","wrapMutable","set","setWithGrid","grid","grid","wrap","grid","wrap","grid","grid","grid","cells","cardinal","cells","grid","wrap","isEqual","grid","grid","grid","create","neighbours","grid","grid","grid","grid","grid","grid","create","grid","bbox","interpolate","relativePosition","toString","toSvgString","interpolate","point","relativePosition","lengths","length","bbox","corners","toString","toSvgString","slope","Direction","isIntersecting","Placeholder","normalise","multiply","wrap","wrap","multiply","rows","reduce","wrap","values","bbox","distanceCenter","fromDegrees","guard","interpolate","isEqual","isPositioned","length","toPath","toSvg","isPositioned","piPi","fromDegrees","guard","angleRadian","interpolate","toPath","point","bbox","length","toSvg","toSvgFull","distanceCenter","isEqual","clampMagnitude","divide","dotProduct","multiply","normalise","subtract","sum","toCartesian","toString","piPi","point","guard","normalise","toCartesian","toString","dotProduct","clampMagnitude","sum","subtract","multiply","divide","pi","piPi","offset","Empty","Placeholder","apply","area","bbox","corners","edges","fromFlatArray","fromPoints","guard","intersectsPoint","isEmpty","isEqual","isPlaceholder","lengths","rotate","toFlatArray","guard","edges","guard","area","guard","lengths","edges","guard","guard","edges","area","edges","rotate","area","fromCenter","perimeter","area","circumcircle","height","incircle","perimeter","angleRadian","area","circumcircle","fromA","fromB","fromC","fromCenter","height","incircle","medians","perimeter","piPi","Empty","Placeholder","isEmpty","isPlaceholder","apply","isEqual","corners","guard","lengths","angles","fromPoints","length","angleRadian","toFlatArray","fromFlatArray","bbox","intersectsPoint"]}