import{n as e}from"./chunk-CVLEGGlw.js";import{$ as t,Ct as n,Ft as r,I as i,J as a,Lt as o,Q as s,Tt as ee,X as c,Y as te,Z as ne,_t as l,at as re,bt as ie,ct as ae,dt as oe,et as se,gt as ce,h as le,ht as ue,it as de,k as u,lt as fe,mt as pe,nt as me,ot as he,pt as ge,q as _e,rt as ve,st as ye,tt as be,ut as xe,vt as Se,yt as Ce}from"./src-DdJCbM4z.js";import{a as we,y as d}from"./numbers-BlBexQl9.js";import{i as f}from"./object-C3MekYVU.js";import{i as Te,t as p}from"./without-BZTwhsyg.js";import{B as Ee}from"./src-kD5hEVnd.js";import{t as m}from"./queue-mutable-DkFlFSVY.js";import{t as h}from"./simple-event-emitter-DdjYDCSw.js";import{t as g}from"./StackMutable-CC_MLivw.js";import{a as De,c as Oe,i as ke,l as Ae,n as je,o as Me,r as Ne,s as Pe,t as _,u as Fe}from"./map-of-simple-mutable-DrS2vpyB.js";import{n as Ie,r as Le,t as Re}from"./set-BX5QennO.js";import{n as ze,t as Be}from"./queue-WkPm9kWw.js";import{a as Ve,c as He,i as Ue,l as We,o as Ge,s as v,t as Ke,u as qe}from"./graph-CVtu0waB.js";var Je=class e extends Array{#e;#t;constructor(e=0){super(),d(we(e,`positive`,`capacity`)),this.#e=e,this.#t=0}add(t){let n=e.from(this);return n[this.#t]=t,n.#e=this.#e,this.#e>0?n.#t=this.#t+1===this.#e?0:this.#t+1:n.#t=this.#t+1,n}get pointer(){return this.#t}get isFull(){return this.#e===0?!1:this.length===this.#e}};const y=(e,t,n=ee,r)=>{let i=Ze(e,t,n),a=Xe(e,t,n),o={valueChanged:!i,a:e,b:t,added:a.added,removed:a.removed,childChanged:!1},s={value:o,childrenStore:[],parent:r},c=a.identical.map(e=>y(e[0],e[1],n,s)),te=Ye(o)||c.some(e=>Ye(e.value));return St(s,c),s.toString=()=>Qe(s,0),s.value.childChanged=te,it(s),s},Ye=e=>e===void 0?!1:!!(e.valueChanged||e.childChanged||e.added.length>0||e.removed.length>0),Xe=(e,t,n=ee)=>{let r=[...e.children()],i=[...t.children()],a=[],o=[];for(let e of r){let t=-1;for(let[r,o]of i.entries())if(Ze(e,o,n)){a.push([e,o]),t=r;break}t===-1?o.push(e):i.splice(t,1)}return{added:[...i],identical:a,removed:o}},Ze=(e,t,n)=>!!(e.getIdentity()===t.getIdentity()||n(e.getValue(),t.getValue())),b=e=>JSON.stringify(e.getValue()),Qe=(e,t=0)=>{if(e===void 0)return`(undefined)`;let n=$e(e.value,t);for(let r of e.childrenStore)n+=Qe(r,t+2);return n},$e=(e,t)=>{let n=` `.repeat(t);if(e===void 0)return`${n}(undefined)`;let r=[];if(r.push(`a: ${b(e.a)} b: ${b(e.b)}`),e.valueChanged?r.push(`Value changed. Child changed: ${e.childChanged}`):r.push(`Value unchanged. Child changed: ${e.childChanged}`),e.added.length>0){r.push(`Added:`);for(let t of e.added)r.push(` - `+b(t))}if(e.removed.length>0){r.push(`Removed: ${e.removed.length}`);for(let t of e.removed)r.push(` - `+b(t))}return r.push(`----
`),r.map(e=>n+e).join(`
`)};var et=e({add:()=>M,addValue:()=>N,asDynamicTraversable:()=>I,breadthFirst:()=>T,children:()=>at,childrenLength:()=>yt,childrenValues:()=>ot,compare:()=>tt,computeMaxDepth:()=>ht,createNode:()=>F,depthFirst:()=>rt,findAnyChildByValue:()=>dt,findChildByValue:()=>lt,findParentsValue:()=>pt,followValue:()=>Ct,fromPlainObject:()=>_t,getRoot:()=>k,hasAnyChild:()=>O,hasAnyParent:()=>A,hasChild:()=>ct,hasParent:()=>mt,nodeDepth:()=>st,parents:()=>D,parentsValues:()=>ft,queryByValue:()=>ut,queryParentsValue:()=>j,remove:()=>w,root:()=>P,rootWrapped:()=>vt,setChildren:()=>St,stripParentage:()=>x,throwTreeTest:()=>it,toStringDeep:()=>L,treeTest:()=>E,value:()=>bt,wrap:()=>C});const tt=(e,t,n)=>y(I(e),I(t),n),x=e=>({value:e.value,childrenStore:e.childrenStore.map(e=>x(e))}),S=e=>`wraps`in e?e.wraps:e,nt=e=>`wraps`in e?e:C(e),C=e=>({*children(){for(let t of e.childrenStore)yield C(t)},getValue:()=>e.value,getIdentity:()=>e,*queryValue(t){for(let n of ut(t,S(e)))yield C(n)},*queryParentsValue(e,t,n){for(let r of j(S(e),t,n))yield C(r)},*parentsValues(e){yield*ft(S(e))},findParentsValue(e,t,n){let r=pt(e,t,n);if(r!==void 0)return C(r)},getParent:()=>e.parent===void 0?void 0:C(e.parent),hasParent:t=>mt(e,S(t)),hasAnyParent:t=>A(e,S(t)),hasChild:t=>ct(S(t),e),hasAnyChild:t=>O(S(t),e),remove:()=>{w(e)},addValue:t=>C(N(t,e)),add:t=>(M(S(t),e),nt(t)),wraps:e}),w=e=>{let t=e.parent;t!==void 0&&(e.parent=void 0,t.childrenStore=p(t.childrenStore,e))};function*rt(e){if(!P)return;let t=new g;t.push(...e.childrenStore);let n=t.pop();for(;n&&(yield n,n&&t.push(...n.childrenStore),!t.isEmpty);)n=t.pop()}function*T(e){if(!e)return;let t=new m;t.enqueue(...e.childrenStore);let n=t.dequeue();for(;n&&(yield n,n&&t.enqueue(...n.childrenStore),!t.isEmpty);)n=t.dequeue()}function E(e,t=[]){if(e.parent===e)return[!1,`Root has itself as parent`,e];if(t.includes(e))return[!1,`Same node instance is appearing further in tree`,e];if(t.push(e),Te(e.childrenStore))return[!1,`Children list contains duplicates`,e];for(let n of e.childrenStore){if(n.parent!==e)return[!1,`Member of childrenStore does not have .parent set`,n];if(O(e,n))return[!1,`Child has parent as its own child`,n];let r=E(n,t);if(!r[0])return r}return[!0,``,e]}function it(e){let t=E(e);if(!t[0])throw Error(`${t[1]} Node: ${u(t[2].value,30)}`,{cause:t[2]})}function*at(e){for(let t of e.childrenStore)yield t}function*ot(e){for(let t of e.childrenStore)t.value!==void 0&&(yield t.value)}function*D(e){let t=e.parent;for(;t;)yield t,t=t.parent}function st(e){return[...D(e)].length}const ct=(e,t)=>{for(let n of t.childrenStore)if(n===e)return!0;return!1},lt=(e,t,r=n)=>{for(let n of t.childrenStore)if(r(e,n.value))return n};function*ut(e,t,r=n){for(let n of t.childrenStore)r(e,n.value)&&(yield n)}const O=(e,t)=>{for(let n of T(t))if(n===e)return!0;return!1},dt=(e,t,r=n)=>{for(let n of T(t))if(r(n.value,e))return n},k=e=>e.parent?k(e.parent):e,A=(e,t)=>{for(let n of D(e))if(n===t)return!0;return!1};function*ft(e){for(let t of D(e))t.value!==void 0&&(yield t.value);return!1}function*j(e,t,r=n){for(let n of D(e))n.value!==void 0&&r(n.value,t)&&(yield n);return!1}function pt(e,t,r=n){for(let n of j(e,t,r))return n}const mt=(e,t)=>e.parent===t,ht=e=>gt(e,0),gt=(e,t=0)=>{let n=t;for(let r of e.childrenStore)n=Math.max(n,gt(r,t+1));return n},M=(e,t)=>{xt(e,t);let n=e.parent;t.childrenStore=[...t.childrenStore,e],e.parent=t,n&&(n.childrenStore=p(n.childrenStore,e))},N=(e,t)=>F(e,t),P=e=>F(e),_t=(e,t=``,n,r=[])=>{let i=Object.entries(e);n=n===void 0?P():N({label:t,value:e},n);for(let e of i){let t=e[1];r.includes(t)||(r.push(t),typeof e[1]==`object`?_t(t,e[0],n,r):N({label:e[0],value:t},n))}return n},vt=e=>C(F(e)),F=(e,t)=>{let n={childrenStore:[],parent:t,value:e};return t!==void 0&&(t.childrenStore=[...t.childrenStore,n]),n},yt=e=>e.childrenStore.length,bt=e=>e.value,I=e=>({*children(){for(let t of e.childrenStore)yield I(t)},getParent(){if(e.parent!==void 0)return I(e.parent)},getValue(){return e.value},getIdentity(){return e}}),xt=(e,t)=>{if(t===e)throw Error(`Cannot add self as child`);if(e.parent!==t){if(A(t,e))throw Error(`Child contains parent (1)`,{cause:e});if(A(e,t))throw Error(`Parent already contains child`,{cause:e});if(O(t,e))throw Error(`Child contains parent (2)`,{cause:e})}},St=(e,t)=>{for(let n of t)xt(n,e);e.childrenStore=[...t];for(let n of t)n.parent=e},L=(e,t=0)=>{let n=`${`  `.repeat(t)} + ${e.value?JSON.stringify(e.value):`-`}`;return e.childrenStore.length>0?n+`
`+e.childrenStore.map(e=>L(e,t+1)).join(`
`):n};function*Ct(e,t,n=1){for(let r of e.childrenStore){let e=r.value;e!==void 0&&t(e,n)&&(yield r.value,yield*Ct(r,t,n+1))}}var wt=e({asDynamicTraversable:()=>z,children:()=>R,create:()=>B,createSimplified:()=>Pt,createWrapped:()=>Mt,depthFirst:()=>Ot,getByPath:()=>At,prettyPrint:()=>Et,prettyPrintEntries:()=>Tt,toStringDeep:()=>Dt,traceByPath:()=>jt});function Tt(e){if(e.length===0)return`(empty)`;let t=``;for(let[n,r]of e.entries())t+=`  `.repeat(n),t+=r.name+` = `+JSON.stringify(r.leafValue)+`
`;return t}const Et=(e,t=0,n={})=>{d(f(e,`node`));let r=Ft(e,n.name??`node`),i=`${`  `.repeat(t)} + name: ${r.name} value: ${JSON.stringify(r.leafValue)}`,a=[...R(e,n)];return a.length>0?i+`
`+a.map(e=>Et(e.leafValue,t+1,{...n,name:e.name})).join(`
`):i},Dt=(e,t=0)=>{let n=` `.repeat(t)+` ${e.value?.name}`;if(e.value!==void 0){if(`sourceValue`in e.value&&`leafValue`in e.value){let t=u(e.value.sourceValue,20),r=u(e.value.leafValue,20);t=t===r?``:`source: `+t,n+=` = ${r} ${t}`}else `sourceValue`in e.value&&e.value.sourceValue!==void 0&&(n+=` = ${e.value.sourceValue}`);`ancestors`in e.value&&(n+=` (ancestors: ${e.value.ancestors.join(`, `)})`)}n+=`
`;for(let r of e.childrenStore)n+=Dt(r,t+1);return n};function*R(e,t={}){d(f(e,`node`));let n=t.filter??`none`,r=e=>n===`none`?[!0,o(e)]:n===`leaves`&&o(e)?[!0,!0]:n===`branches`&&!o(e)?[!0,!1]:[!1,o(e)];if(Array.isArray(e))for(let[t,n]of e.entries()){let e=r(n);e[0]&&(yield{name:t.toString(),_kind:`entry`,sourceValue:n,leafValue:e[1]?n:void 0})}else if(typeof e==`object`){let t=`entries`in e?e.entries():Object.entries(e);for(let[e,n]of t){let[t,i]=r(n);t&&(yield{name:e,_kind:`entry`,sourceValue:n,leafValue:i?n:void 0})}}}function*Ot(e,t={},n=[]){for(let r of R(e,t))yield{...r,ancestors:[...n],_kind:`entry-ancestors`},yield*Ot(r.sourceValue,t,[...n,r.name])}function kt(e,t){for(let n of R(t))if(n.name===e)return n}function At(e,t,n={}){let r=Ee(jt(e,t,n));if(!r)throw Error(`Could not trace path: ${e} `);return r}function*jt(e,t,n={}){d(f(e,`path`),f(t,`node`));let r=n.separator??`.`,i=e.split(r),a=[];for(let e of i){let n=kt(e,t);if(!n){yield{name:e,sourceValue:void 0,leafValue:void 0,ancestors:a,_kind:`entry-ancestors`};return}t=n.sourceValue,yield{...n,ancestors:[...a],_kind:`entry-ancestors`},a.push(e)}}const z=(e,t={},n=[],r)=>{let i=t.name??`object`,a={*children(){for(let{name:r,sourceValue:o,leafValue:s}of R(e,t))yield z(o,{...t,name:r},[...n,i],a)},getParent(){return r},getValue(){return{name:i,sourceValue:e,ancestors:n,_kind:`entry-static`}},getIdentity(){return e}};return a},Mt=(e,t)=>C(B(e,t)),B=(e,t={})=>Nt(e,(t.valuesAtLeaves??!1?e=>{if(o(e))return e}:e=>e)(e),t,[]),Nt=(e,t,n={},r)=>{let i=n.name??`object_ci`,a=P({name:i,sourceValue:t,ancestors:[...r],_kind:`entry-static`});r=[...r,i];for(let t of R(e,n)){let e=n.valuesAtLeaves?t.leafValue:t.sourceValue;M(Nt(t.sourceValue,e,{...n,name:t.name},r),a)}return a},Pt=(e,t={})=>x(B(e,t));function Ft(e,t=``){return`name`in e&&`leafValue`in e&&`sourceValue`in e?{name:e.name,_kind:`entry`,leafValue:e.leafValue,sourceValue:e.sourceValue}:`name`in e?{name:e.name,leafValue:e,sourceValue:e,_kind:`entry`}:{name:t,leafValue:e,sourceValue:e,_kind:`entry`}}var It=e({addValueByPath:()=>Rt,childrenLengthByPath:()=>Vt,clearValuesByPath:()=>Bt,create:()=>Lt,removeByPath:()=>zt,valueByPath:()=>Ht,valuesByPath:()=>U});const Lt=(e={})=>{let t;return{getRoot:()=>t,add:(n,r)=>{let i=Rt(n,r,t,e);t===void 0&&(t=k(i))},prettyPrint:()=>t===void 0?`(empty)`:L(t),remove:n=>t===void 0?!1:zt(n,t,e),getValue:n=>{if(t!==void 0)return Ht(n,t,e)},getValues:n=>t===void 0?[]:U(n,t,e),hasPath:n=>t===void 0?!1:H(n,t,e)!==void 0,childrenLength:n=>{if(t===void 0)return 0;let r=H(n,t,e);return r===void 0?0:r.childrenStore.length},getNode:n=>{if(t!==void 0)return H(n,t,e)},clearValues:n=>t===void 0?!1:Bt(n,t,e)}},Rt=(e,t,n,r={})=>{let i=r.separator??`.`,a=r.duplicates??`overwrite`,o=t.split(i),s=0;for(let t of o){let r=s===o.length-1,i=V(t,n);if(i===void 0)n=F({value:r?e:void 0,label:t},n);else if(n=i,r)switch(a){case`ignore`:break;case`allow`:{let r=Ut(n);n.value={values:[...r,e],label:t};break}case`overwrite`:n.value={value:e,label:t};break}else n=i;s++}if(n===void 0)throw Error(`Could not create tree`);return n},zt=(e,t,n={})=>{if(t===void 0)return!1;let r=H(e,t,n);return r===void 0?!1:(w(r),!0)},Bt=(e,t,n={})=>{if(t===void 0)return!1;let r=H(e,t,n);return r===void 0?!1:(r.value={label:r.value?.label??``,value:void 0},!0)},Vt=(e,t,n={})=>{if(t===void 0)return 0;let r=H(e,t,n);return r===void 0?0:r.childrenStore.length},V=(e,t)=>{if(t!==void 0){if(e===void 0)throw Error(`Parameter 'label' cannot be undefined`);if(t.value?.label===e)return t;for(let n of t.childrenStore)if(n.value?.label===e)return n}},Ht=(e,t,n={})=>{let r=U(e,t,n);if(r.length!==0){if(r.length>1)throw Error(`Multiple values at path. Use getValues instead`);return r[0]}},Ut=e=>e.value===void 0?[]:`values`in e.value?e.value.values:`value`in e.value?e.value.value===void 0?[]:[e.value.value]:[],H=(e,t,n={})=>{let r=n.separator??`.`,i=e.split(r),a=t;for(let e of i)if(a=V(e,a),a===void 0)return;return a},U=(e,t,n={})=>{let r=n.separator??`.`,i=e.split(r),a=t;for(let e of i)if(a=V(e,a),a===void 0)return[];return Ut(a)};var Wt=e({breadthFirst:()=>X,childrenLength:()=>Gt,couldAddChild:()=>Yt,depthFirst:()=>Y,find:()=>nn,findAnyChildByValue:()=>en,findAnyParentByValue:()=>Jt,findByValue:()=>rn,findChildByValue:()=>tn,findParentByValue:()=>K,followValue:()=>an,hasAnyChild:()=>q,hasAnyChildValue:()=>Xt,hasAnyParent:()=>Kt,hasAnyParentValue:()=>qt,hasChild:()=>Zt,hasChildValue:()=>J,hasParent:()=>W,hasParentValue:()=>G,parents:()=>$t,siblings:()=>Qt,toString:()=>sn,toStringDeep:()=>on});const Gt=e=>[...e.children()].length,Kt=(e,t,n)=>W(e,t,n,2**53-1),qt=(e,t,n)=>{if(e===void 0)throw TypeError(`Param 'child' is undefined`);return G(e,t,n,2**53-1)},Jt=(e,t,n)=>K(e,t,n,2**53-1),W=(e,t,r=n,i=0)=>{if(i<0)return!1;let a=Z(e),o=Z(t),s=a?e.getParent():e.parent;return s===void 0?!1:r(s,t)||r(a?s.getIdentity():s.value,o?t.getIdentity():t.value)?!0:W(s,t,r,i-1)},G=(e,t,r=n,i=0)=>{if(e===void 0)throw Error(`Param 'child' is undefined`);if(i<0)return!1;let a=`getParent`in e?e.getParent():e.parent;return a===void 0?!1:r(`getValue`in a?a.getValue():a.value,t)?!0:G(a,t,r,i-1)},K=(e,t,r=n,i=0)=>{if(i<0)return;let a=`getParent`in e?e.getParent():e.parent;if(a!==void 0)return r(`getValue`in a?a.getValue():a.value,t)?a:K(a,t,r,i-1)},Yt=(e,t,r=n)=>{if(r(e,t))throw Error(`Child equals parent`);if(q(e,t,r))throw Error(`Circular. Parent already has child`);if(q(t,e,r))throw Error(`Prospective child has parent as child relation`)},q=(e,t,r=n)=>Zt(e,t,r,2**53-1),Xt=(e,t,r=n)=>J(e,t,r,2**53-1),Zt=(e,t,r=n,i=0)=>{if(i<0)return!1;if(r(e,t))return!0;let a=`getIdentity`in e?e.getIdentity():e.value,o=`getIdentity`in t?t.getIdentity():t.value;if(r(a,o))return!0;for(let n of X(e,i)){let e=`getIdentity`in n?n.getIdentity():n.value;if(r(n,t)||r(e,o))return!0}return!1},J=(e,t,r=n,i=0)=>{if(i<0)return!1;if(r(e.getValue(),t))return!0;for(let n of X(e,i))if(r(n.getValue(),t))return!0;return!1};function*Qt(e){let t=e.getParent();if(t!==void 0)for(let n of t.children())n!==e&&(yield n)}function*$t(e){if(Z(e)){let t=e.getParent();for(;t!==void 0;)yield t,t=t.getParent()}else{let t=e.parent;for(;t!==void 0;)yield t,t=t.parent}}function en(e,t,r=n){return tn(e,t,r,2**53-1)}function tn(e,t,r=n,i=0){if(i<0)return;let a=Z(e);if(a){if(r(e.getValue(),t))return e}else if(r(e.value,t))return e;for(let n of X(e,i))if(a){if(r(n.getValue(),t))return n}else if(r(n.value,t))return n}function*Y(e){if(!e)return;let t=new g,n=e;for(;n;){let e=Z(n)?[...n.children()]:[...n.childrenStore];if(t.push(...e),t.isEmpty)break;n=t.pop(),n&&(yield n)}}function*X(e,t=2**53-1){if(!e)return;let n=(Z(e),new m),r=e;for(;r;){if(t<0)return;if(r!==void 0){let e=`childrenStore`in r?r.childrenStore:r.children();for(let t of e)yield t,n.enqueue(t)}r=n.dequeue(),t--}}function nn(e,t,n=`breadth`){if(t(e))return e;let r=n===`breadth`?X:Y;for(let n of r(e))if(t(n))return n}function rn(e,t,n=`breadth`){if(t(e.getValue()))return e;let r=n===`breadth`?X:Y;for(let n of r(e))if(t(n.getValue()))return n}function*an(e,t,n=1){for(let r of e.children())t(r.getValue(),n)&&(yield r.getValue(),yield*an(r,t,n+1))}function on(e,t=0){if(e===void 0)return`(undefined)`;if(e===null)return`(null)`;let n=e.getValue(),r=typeof n;Array.isArray(n)&&(r=`array`);let i=`  `.repeat(t)+`value: ${JSON.stringify(n)} (${r})\n`;for(let n of e.children())i+=on(n,t+1);return i}function sn(...e){let t=``;for(let n of e){let e=n.getValue(),r=u(e),i=[...n.children()],a=n.getParent(),o=typeof e;Array.isArray(e)&&(o=`array`),t+=`value: ${r} (${o}) kids: ${i.length} parented: ${a?`y`:`n`}\n`}return t}var cn=e({FromObject:()=>wt,Mutable:()=>et,Pathed:()=>It,Traverse:()=>Wt,compare:()=>y,isTraversable:()=>Z,isTreeNode:()=>un,toTraversable:()=>ln});const ln=e=>{if(Z(e))return e;if(un(e))return I(e);if(typeof e==`object`)return z(e);throw Error(`Parameter 'node' not convertible`)},un=e=>!!(`parent`in e&&`childrenStore`in e&&`value`in e&&Array.isArray(e.childrenStore)),Z=e=>`children`in e&&`getParent`in e&&`getValue`in e&&`getIdentity`in e,dn=(e={})=>new Q(e);var Q=class extends h{capacity;store;evictPolicy;autoDeleteElapsedMs;autoDeletePolicy;autoDeleteTimer;disposed=!1;constructor(e={}){if(super(),this.capacity=e.capacity??-1,d(we(this.capacity,`nonZero`,`capacity`)),this.store=new Map,e.evictPolicy&&this.capacity<=0)throw Error(`evictPolicy is set, but no capacity limit is set`);this.evictPolicy=e.evictPolicy??`none`,this.autoDeleteElapsedMs=e.autoDeleteElapsedMs??-1,this.autoDeletePolicy=e.autoDeletePolicy??`none`,this.autoDeleteElapsedMs>0&&(this.autoDeleteTimer=setInterval(()=>{this.#e()},Math.max(1e3,this.autoDeleteElapsedMs*2)))}dispose(){this.disposed||(this.disposed=!0,this.autoDeleteTimer&&=(clearInterval(this.autoDeleteTimer),void 0))}get keyLength(){return this.store.size}*entries(){for(let e of this.store.entries())yield[e[0],e[1].value]}*values(){for(let e of this.store.values())yield e.value}*keys(){yield*this.store.keys()}elapsedSet(e){let t=this.store.get(e);if(t!==void 0)return Date.now()-t.lastSet}elapsedGet(e){let t=this.store.get(e);if(t!==void 0)return Date.now()-t.lastGet}has(e){return this.store.has(e)}get(e){let t=this.store.get(e);if(t)return(this.autoDeletePolicy===`either`||this.autoDeletePolicy===`get`)&&this.store.set(e,{...t,lastGet:performance.now()}),t.value}delete(e){let t=this.store.get(e);if(!t)return!1;let n=this.store.delete(e);return this.fireEvent(`removed`,{key:e,value:t.value}),n}clear(){this.store.clear()}touch(e){let t=this.store.get(e);return t?(this.store.set(e,{...t,lastSet:Date.now(),lastGet:Date.now()}),!0):!1}findEvicteeKey(){if(this.evictPolicy===`none`)return;let e=``;if(this.evictPolicy===`oldestGet`)e=`lastGet`;else if(this.evictPolicy===`oldestSet`)e=`lastSet`;else throw Error(`Unknown eviction policy ${this.evictPolicy}`);return ce(this.store,e)[0][0]}#e(){this.autoDeletePolicy!==`none`&&this.deleteWithElapsed(this.autoDeleteElapsedMs,this.autoDeletePolicy)}deleteWithElapsed(e,t){let n=[...this.store.entries()],r=[],i=le(e,1e3),a=performance.now();for(let e of n){let n=a-e[1].lastGet,o=a-e[1].lastSet;(t===`get`?n:t===`set`?o:Math.max(n,o))>=i&&r.push([e[0],e[1].value])}for(let e of r){this.store.delete(e[0]);let t={key:e[0],value:e[1]};this.fireEvent(`expired`,t),this.fireEvent(`removed`,t)}return r}set(e,t){let n=this.store.get(e);if(n){this.store.set(e,{...n,lastSet:performance.now()});return}if(this.keyLength===this.capacity&&this.capacity>0){let e=this.findEvicteeKey();if(!e)throw Error(`ExpiringMap full (capacity: ${this.capacity})`);let t=this.store.get(e);if(this.store.delete(e),t){let n={key:e,value:t.value};this.fireEvent(`expired`,n),this.fireEvent(`removed`,n)}}this.store.set(e,{lastGet:0,lastSet:performance.now(),value:t}),this.fireEvent(`newKey`,{key:e,value:t})}};const fn=(...e)=>{let t=v(new Map,...e);return{add:(...e)=>{t=v(t,...e)},delete:e=>{t=He(t,e)},clear:()=>{t=v(new Map)},set:(e,n)=>{t=qe(t,e,n)},get:e=>t.get(e),entries:()=>t.entries(),values:()=>t.values(),isEmpty:()=>t.size===0,has:e=>We(t,e)}};var $=class extends h{#e=new Map;groupBy;type;constructor(e,t={}){super(),this.type=e,this.groupBy=t.groupBy??r}get typeName(){return this.type.name}get lengthKeys(){return this.#e.size}get lengthMax(){let e=0;for(let t of this.#e.values())e=Math.max(e,this.type.count(t));return e}debugString(){let e=[...this.#e.keys()],t=`Keys: ${e.join(`, `)}\r\n`;for(let n of e){let e=this.#e.get(n);if(e===void 0)t+=` - ${n} (undefined)\r\n`;else{let r=this.type.toArrayCopy(e);r!==void 0&&(t+=` - ${n} (${this.type.count(e)}) = ${JSON.stringify(r)}\r\n`)}}return t}get isEmpty(){return this.#e.size===0}clear(){this.#e.clear(),super.fireEvent(`clear`,!0)}addKeyedValues(e,...t){let n=this.#e.get(e);n===void 0?(this.#e.set(e,this.type.addKeyedValues(void 0,t)),super.fireEvent(`addedKey`,{key:e}),super.fireEvent(`addedValues`,{values:t})):(this.#e.set(e,this.type.addKeyedValues(n,t)),super.fireEvent(`addedValues`,{values:t}))}set(e,t){return this.addKeyedValues(e,...t),this}addValue(...e){for(let t of e)this.addKeyedValues(this.groupBy(t),t)}hasKeyValue(e,t,n){let r=this.#e.get(e);return r===void 0?!1:this.type.has(r,t,n)}has(e){return this.#e.has(e)}deleteKeyValue(e,t){let n=this.#e.get(e);return n===void 0?!1:this.deleteKeyValueFromMap(n,e,t)}deleteKeyValueFromMap(e,t,n){let r=this.type.count(e),i=this.type.without(e,n),a=i.length;return this.#e.set(t,this.type.addKeyedValues(void 0,i)),r>a}deleteByValue(e){let t=!1;return[...this.#e.keys()].filter(n=>{let r=this.#e.get(n);if(!r)throw Error(`Bug: map could not be accessed`);this.deleteKeyValueFromMap(r,n,e)&&(t=!0,this.count(n)===0&&this.delete(n))}),t}delete(e){return this.#e.get(e)===void 0?!1:(this.#e.delete(e),this.fireEvent(`deleteKey`,{key:e}),!0)}firstKeyByValue(e,t=n){return[...this.#e.keys()].find(n=>{let r=this.#e.get(n);if(r===void 0)throw Error(`Bug: map could not be accessed`);return this.type.has(r,e,t)})}count(e){let t=this.#e.get(e);return t===void 0?0:this.type.count(t)}*valuesFor(e){let t=this.#e.get(e);t!==void 0&&(yield*this.type.iterable(t))}getSource(e){return this.#e.get(e)}*keys(){yield*this.#e.keys()}*entriesFlat(){for(let e of this.#e.entries())for(let t of this.type.iterable(e[1]))yield[e[0],t]}*valuesFlat(){for(let e of this.#e.entries())yield*this.type.iterable(e[1])}*entries(){for(let[e,t]of this.#e.entries())yield[e,[...this.type.iterable(t)]]}*keysAndCounts(){for(let e of this.keys())yield[e,this.count(e)]}merge(e){for(let t of e.keys())this.addKeyedValues(t,...e.valuesFor(t))}get size(){return this.#e.size}get[Symbol.toStringTag](){return this.#e[Symbol.toStringTag]}};const pn=e=>{let t=e?.hash??r,n=(e,n)=>t(e)===t(n);return new $({get name(){return`set`},iterable:e=>e.values(),addKeyedValues:(e,n)=>a(e,t,`skip`,...n),count:e=>e.size,find:(e,t)=>me(e,t),filter:(e,t)=>s(e,t),toArrayCopy:e=>l(e),has:(e,t)=>ae(e,t,n),without:(e,t)=>p(l(e),t,n)},e)},mn=e=>{let t=n;return new $({get name(){return`circular`},addKeyedValues:(t,n)=>{let r=t??new Je(e.capacity);for(let e of n)r=r.add(e);return r},count:e=>e.length,find:(e,t)=>e.find(t),filter:(e,t)=>e.filter(t),toArrayCopy:e=>[...e],iterable:e=>e.values(),has:(e,n)=>e.find(e=>t(e,n))!==void 0,without:(e,n)=>e.filter(e=>!t(e,n))},e)},hn=(e={})=>{let t=e.convertToString,r=t===void 0?n:(e,n)=>t(e)===t(n),i=e.comparer??r;return new $({get name(){return`array`},addKeyedValues:(e,t)=>e===void 0?[...t]:[...e,...t],iterable:e=>e.values(),count:e=>e.length,find:(e,t)=>e.find(e=>t(e)),filter:(e,t)=>e.filter(e=>t(e)),toArrayCopy:e=>[...e],has:(e,t)=>e.some(e=>i(e,t)),without:(e,t)=>e.filter(e=>!i(e,t))},e)};var gn=class e extends Ne{addKeyedValues(e,...t){return this.addBatch([[e,t]])}addValue(...t){let n=new _(this.groupBy,this.valueEq,this.getRawMapUnsafe);return n.addValue(...t),new e(this.groupBy,this.valueEq,[...n.entries()])}addBatch(t){let n=new _(this.groupBy,this.valueEq,this.getRawMapUnsafe);for(let e of t)n.addKeyedValues(e[0],...e[1]);return new e(this.groupBy,this.valueEq,[...n.entries()])}clear(){return new e(this.groupBy,this.valueEq)}deleteKeyValue(t,n,r){let i=r??this.valueEq,a=[...this.map.entries()].map(e=>{let r=e[0];return r===t?[r,e[1].filter(e=>!i(e,n))]:e}).filter(e=>e[1].length>0);return new e(this.groupBy,this.valueEq,a)}deleteByValue(t,n){let r=[...this.map.entries()],i=n??this.valueEq,a=r.map(e=>[e[0],e[1].filter(e=>!i(e,t))]).filter(e=>e[1].length>0);return new e(this.groupBy,this.valueEq,a)}delete(t){let n=[...this.map.entries()].filter(e=>e[0]!==t);return new e(this.groupBy,this.valueEq,n)}};const _n=(e=i,t=n)=>new gn(e,t);var vn=class extends h{#e=new Map;add(...e){for(let t of e)`key`in t&&`value`in t?this.set(t.key,t.value):this.set(t[0],t[1])}set(e,t){let n=this.#e.has(e);this.#e.set(e,t);let r={key:e,value:t};n?this.fireEvent(`key-added`,r):this.fireEvent(`key-updated`,r),this.fireEvent(`added`,r)}delete(e){let t=this.#e.get(e);t!==void 0&&(this.#e.delete(e),this.fireEvent(`removed`,{key:e,value:t}))}clear(){this.#e.clear(),this.fireEvent(`cleared`,void 0)}get(e){return this.#e.get(e)}has(e){return this.#e.has(e)}isEmpty(){return this.#e.size===0}entries(){return this.#e.entries()}values(){return this.#e.values()}},yn=e({ExpiringMap:()=>Q,MapOfMutableImpl:()=>$,MapOfSimple:()=>gn,MapOfSimpleMutable:()=>_,MapWithEvents:()=>vn,NumberMap:()=>Ve,addObjectEntriesMutate:()=>_e,addValue:()=>a,addValueMutate:()=>te,addValueMutator:()=>c,cloneShallow:()=>ke,deleteByValueCompareMutate:()=>ne,equals:()=>De,expiringMap:()=>dn,filterValues:()=>s,findBySomeKey:()=>t,findEntryByPredicate:()=>se,findEntryByValue:()=>be,findValue:()=>me,firstEntry:()=>Me,firstEntryByValue:()=>Pe,fromIterable:()=>ve,fromObject:()=>de,getClosestIntegerKey:()=>re,getOrGenerate:()=>he,getOrGenerateSync:()=>ye,hasAnyValue:()=>ae,hasKeyValue:()=>fe,immutable:()=>Ge,longestEntry:()=>Oe,mapOfSimpleMutable:()=>je,mapToArray:()=>xe,mapToObjectTransform:()=>oe,mergeByKey:()=>ge,mutable:()=>fn,ofArrayMutable:()=>hn,ofCircularMutable:()=>mn,ofSetMutable:()=>pn,ofSimple:()=>_n,ofSimpleMutable:()=>je,some:()=>pe,sortByValue:()=>ue,sortByValueProperty:()=>ce,toArray:()=>l,toObject:()=>Se,transformMap:()=>Ce,zipKeyValue:()=>ie});export{Je as CircularArray,Q as ExpiringMap,Ke as Graphs,_ as MapOfSimpleMutable,yn as Maps,ze as QueueImmutable,m as QueueMutable,Be as Queues,Ie as SetStringImmutable,Le as SetStringMutable,Re as Sets,Fe as StackImmutable,g as StackMutable,Ae as Stacks,Ue as Table,cn as Trees};