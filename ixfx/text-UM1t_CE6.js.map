{"version":3,"file":"text-UM1t_CE6.js","names":[],"sources":["../../core/dist/src/text.js"],"sourcesContent":["import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Whittles down from whole string to last token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToEnd(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const trimmed = afterMatch(source, delimiter);\n        if (trimmed === source) {\n            // Delimiter not found\n            break;\n        }\n        source = trimmed;\n    }\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Starts with last token, builds to whole.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsLastToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n        if (ba[0] === ba[1] && ba[1] === source) {\n            // Delimiter not found\n            break;\n        }\n        const v = ba[1] + accumulator;\n        yield v;\n        accumulator = delimiter + v;\n        source = ba[0];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with the first token and build up until end.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsFirstToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n        if (ba[0] === source && ba[1] === source)\n            break;\n        accumulator += ba[0];\n        yield accumulator;\n        accumulator += delimiter;\n        source = ba[1];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with whole string and whittle down to starting token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToFirst(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n        if (b === source)\n            break;\n        source = b;\n    }\n}\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n *\n * If `source` is under `maxLength` the original is returned.\n * @param source\n * @param maxLength Maximum length. Defaults to 20\n * @returns\n */\nexport const abbreviate = (source, maxLength = 15) => {\n    resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (source.length > maxLength && source.length > 3) {\n        if (maxLength > 15) {\n            const chunk = Math.round((maxLength - 2) / 2);\n            return source.slice(0, chunk) + `...` + source.slice(-chunk);\n        }\n        return source.slice(0, maxLength) + `...`;\n    }\n    return source;\n};\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns\n */\nexport const toStringAbbreviate = (source, maxLength = 20) => {\n    if (source === undefined)\n        return `(undefined)`;\n    if (source === null)\n        return `(null)`;\n    return abbreviate(JSON.stringify(source), maxLength);\n};\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return;\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return;\n    return source.slice(startPos + 1, endPos);\n};\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (typeof start !== `string`)\n        throw new Error(`Parameter 'start' is not a string`);\n    if (end !== undefined && typeof end !== `string`)\n        throw new Error(`Parameter 'end' is not a string`);\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return [source, undefined];\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return [source, undefined];\n    const between = source.slice(startPos + 1, endPos);\n    const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n    return [sourceResult, between];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {\n    for (let index = start; index <= end; index++) {\n        if (source.codePointAt(index) === code)\n            return index;\n    }\n    return -1;\n};\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) +\n    source.slice(removeStart + removeLength);\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (source, length) => {\n    resultThrow(integerTest(length, `aboveZero`, `length`));\n    if (source === null)\n        throw new Error(`source parameter null`);\n    if (typeof source !== `string`) {\n        throw new TypeError(`source parameter not a string`);\n    }\n    // ✔ Unit tested\n    const chunks = Math.ceil(source.length / length);\n    const returnValue = [];\n    let start = 0;\n    for (let c = 0; c < chunks; c++) {\n        returnValue.push(source.slice(start, start + length));\n        start += length;\n    }\n    return returnValue;\n};\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[0];\n};\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[1];\n};\n/**\n * Returns the text that is before and after `match`.\n *\n * See also: {@link beforeMatch}, {@link afterMatch}.\n *\n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeAfterMatch = (source, match, options = {}) => {\n    if (source === undefined)\n        throw new Error(`Param 'source' is undefined`);\n    let fallback = options.fallback;\n    const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n    if (ifNoMatch === `original`)\n        fallback = source;\n    if (ifNoMatch === `fallback` && fallback === undefined)\n        throw new Error(`Fallback must be provided`);\n    const startPos = options.startPos ?? undefined;\n    const fromEnd = options.fromEnd ?? false;\n    const m = fromEnd\n        ? source.lastIndexOf(match, startPos)\n        : source.indexOf(match, startPos);\n    if (m < 0 && ifNoMatch === `throw`)\n        throw new Error(`Match '${match}' not found in source.`);\n    if (m < 0 && ifNoMatch === `original`)\n        return [source, source];\n    if (m < 0 && ifNoMatch === `fallback`) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return [fallback, fallback];\n    }\n    return [\n        source.slice(0, m),\n        source.slice(Math.max(0, m + match.length))\n    ];\n};\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (source, ...wrappers) => {\n    let matched = false;\n    do {\n        matched = false;\n        for (const w of wrappers) {\n            if (source.startsWith(w) && source.endsWith(w)) {\n                source = source.slice(w.length, source.length - w.length * 2 + 1);\n                matched = true;\n            }\n        }\n    } while (matched);\n    return source;\n};\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges, start, end) => {\n    let s = -1;\n    let endPos = -1;\n    for (const [index, r] of ranges.entries()) {\n        s = index;\n        if (r.text.length === 0)\n            continue;\n        if (start < r.end) {\n            break;\n        }\n    }\n    for (let index = s; index < ranges.length; index++) {\n        const r = ranges[index];\n        endPos = index;\n        if (end === r.end) {\n            endPos = index + 1;\n            break;\n        }\n        if (end < r.end) {\n            break;\n        }\n    }\n    return { length: endPos - s, start: s, end: endPos };\n};\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (source, split) => {\n    let start = 0;\n    let text = ``;\n    const ranges = [];\n    let index = 0;\n    for (let index_ = 0; index_ < source.length; index_++) {\n        if (source.indexOf(split, index_) === index_) {\n            const end = index_;\n            ranges.push({\n                text,\n                start,\n                end,\n                index,\n            });\n            start = end + 1;\n            text = ``;\n            index++;\n        }\n        else {\n            text += source.charAt(index_);\n        }\n    }\n    if (start < source.length) {\n        ranges.push({ text, start, index, end: source.length });\n    }\n    return ranges;\n};\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (source, ...chars) => {\n    let counted = 0;\n    for (let index = 0; index < source.length; index++) {\n        if (chars.includes(source.charAt(index))) {\n            counted++;\n        }\n        else {\n            break;\n        }\n    }\n    return counted;\n};\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);\nexport const htmlEntities = (source) => source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${index.codePointAt(0)};`);\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern\n * @returns\n */\nexport const wildcard = (pattern) => {\n    // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n    // for this solution to work on any string, no matter what characters it has\n    const escapeRegex = (value) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n    // \".\"  => Find a single character, except newline or line terminator\n    // \".*\" => Matches any string that contains zero or more characters\n    pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n    // \"^\"  => Matches any string with the following at the beginning of it\n    // \"$\"  => Matches any string with that in front at the end of it\n    pattern = `^` + pattern + `$`;\n    // Create a regular expression object for matching string\n    const regex = new RegExp(pattern);\n    return (value) => {\n        // Returns true if it finds a match, otherwse it returns false\n        return regex.test(value);\n    };\n};\n"],"mappings":"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"}