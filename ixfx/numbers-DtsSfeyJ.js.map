{"version":3,"file":"numbers-DtsSfeyJ.js","names":["value?: unknown","range: NumberGuardRange","value: number","value: number | undefined","min: number","max: number"],"sources":["../../packages/guards/src/result.js","../../packages/guards/src/numbers.ts"],"sourcesContent":["export const getErrorMessage = (ex) => {\n    if (typeof ex === `string`)\n        return ex;\n    if (ex instanceof Error) {\n        return ex.message;\n    }\n    return ex;\n};\n/**\n * If `result` is an error, throws it, otherwise ignored.\n * @param result\n * @returns\n */\nexport function resultThrow(result) {\n    // if (result.success) return true;\n    // if (typeof result.error === `string`) throw new Error(result.error);\n    // throw result.error;\n    if (resultIsError(result)) {\n        // if (typeof result.error === `string`) throw new Error(result.error);\n        // if (result.error instanceof Error) throw result.error;\n        // throw new Error(JSON.stringify(result.error));\n        throw resultToError(result);\n    }\n    return true;\n}\n/**\n * Returns _true_ if `result` is an error\n * @param result\n * @returns\n */\nexport function resultIsError(result) {\n    if (typeof result !== `object`)\n        return false;\n    return !result.success;\n}\n/**\n * Returns _true_ if `result` is OK and has a value\n * @param result\n * @returns\n */\nexport function resultIsOk(result) {\n    if (typeof result !== `object`)\n        return false;\n    return result.success;\n}\n/**\n * Gets the result as an Error\n * @param result\n * @returns\n */\nfunction resultToError(result) {\n    if (typeof result.error === `string`)\n        throw new Error(result.error);\n    if (result.error instanceof Error)\n        throw result.error;\n    return new Error(JSON.stringify(result.error));\n}\n/**\n * Unwraps the result, returning its value if OK.\n * If not, an exception is thrown.\n * @param result\n * @returns\n */\nexport function resultToValue(result) {\n    if (resultIsOk(result)) {\n        return result.value;\n    }\n    throw resultToError(result);\n}\n/**\n * Returns the error as a string.\n * @param result\n * @returns\n */\nexport function resultErrorToString(result) {\n    if (result.error instanceof Error)\n        return getErrorMessage(result.error);\n    if (typeof result.error === `string`)\n        return result.error;\n    return JSON.stringify(result.error);\n}\n/**\n * Throws an error if any result is a failure.\n * Error message will be the combined from all errors.\n * @param results\n * @returns\n */\nexport const throwIfFailed = (...results) => {\n    const failed = results.filter(r => resultIsError(r)); // as ResultError<any>[];\n    if (failed.length === 0)\n        return;\n    const messages = failed.map(f => resultErrorToString(f));\n    throw new Error(messages.join(`, `));\n};\n/**\n * Returns the first failed result, or _undefined_ if there are no fails\n * @param results\n * @returns\n */\nexport const resultFirstFail = (...results) => {\n    for (const r of results) {\n        const rr = typeof r === `object` ? r : r();\n        if (rr === undefined)\n            continue;\n        if (!rr.success)\n            return rr;\n    }\n};\n/**\n * Returns first failed result or final value.\n * @param results\n * @returns\n */\nexport const resultsCollate = (...results) => {\n    let rr;\n    for (const r of results) {\n        rr = typeof r === `object` ? r : r();\n        if (rr === undefined)\n            continue;\n        if (!rr.success)\n            return rr;\n    }\n    if (!rr)\n        throw new Error(`No results`);\n    return rr;\n};\n/**\n * If `result` is an error, calls `callback`, passing the error.\n * Otherwise does nothing\n * @param result\n * @param callback\n */\nexport const resultWithFail = (result, callback) => {\n    if (resultIsError(result)) {\n        callback(result);\n    }\n};\n","import { resultsCollate } from \"./result.js\";\nimport type { NumberGuardRange, Result } from \"./types.js\";\n\n/**\n * Returns true if `x` is a power of two\n * @param x\n * @returns True if `x` is a power of two\n */\nexport const isPowerOfTwo = (x: number) => Math.log2(x) % 1 === 0;\n\n\n/**\n * Returns `fallback` if `v` is NaN, otherwise returns `v`.\n *\n * Throws if `v` is not a number type.\n * @param v\n * @param fallback\n * @returns\n */\nexport const ifNaN = (v: number, fallback: number): number => {\n  // ✔️ Unit tested\n\n  if (Number.isNaN(v)) return fallback;\n  if (typeof v !== `number`) {\n    throw new TypeError(`v is not a number. Got: ${ typeof v }`);\n  }\n  return v;\n};\n\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n *\n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n *\n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n *\n * @param value\n * @param range\n * @param defaultValue\n * @returns\n */\nexport const integerParse = (\n  value: string | number | null,\n  range: NumberGuardRange = ``,\n  defaultValue: number = Number.NaN\n): number => {\n  if (typeof value === `undefined`) return defaultValue;\n  if (value === null) return defaultValue;\n  try {\n    const parsed = Number.parseInt(typeof value === `number` ? value.toString() : value);\n    const r = integerTest(parsed, range, `parsed`);\n    return r[ 0 ] ? parsed : defaultValue;\n  } catch {\n    return defaultValue;\n  }\n};\n\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Returns `[false, reason:string]` if invalid or `[true]` if valid.\n * Use {@link throwNumberTest} to throw an error rather than return result.\n * \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n *\n * * (empty, default): must be a number type and not NaN.\n * * finite: must be a number, not NaN and not infinite\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param parameterName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns\n */\nexport const numberTest = (\n  value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`,\n): Result<number, string> => {\n  if (value === null) return { success: false, error: `Parameter '${ parameterName }' is null` };\n  if (typeof value === `undefined`) {\n    return { success: false, error: `Parameter '${ parameterName }' is undefined` };\n  }\n  if (Number.isNaN(value)) {\n    return { success: false, error: `Parameter '${ parameterName }' is NaN` };\n  }\n  if (typeof value !== `number`) {\n    return { success: false, error: `Parameter '${ parameterName }' is not a number (${ JSON.stringify(value) })` };\n  }\n  switch (range) {\n    case `finite`: {\n      if (!Number.isFinite(value)) {\n        return { success: false, error: `Parameter '${ parameterName } must be finite (Got: ${ value })` };\n      }\n      break;\n    }\n    case `positive`: {\n      if (value < 0) {\n        return { success: false, error: `Parameter '${ parameterName }' must be at least zero (${ value })` };\n      }\n      break;\n    } case `negative`: {\n      if (value > 0) {\n        return { success: false, error: `Parameter '${ parameterName }' must be zero or lower (${ value })` };\n      }\n      break;\n    }\n    case `aboveZero`: {\n      if (value <= 0) {\n        return {\n          success: false, error: `Parameter '${ parameterName }' must be above zero (${ value })`\n        };\n\n      }\n      break;\n    }\n    case `belowZero`: {\n      if (value >= 0) {\n        return { success: false, error: `Parameter '${ parameterName }' must be below zero (${ value })` };\n      }\n      break;\n    }\n    case `percentage`: {\n      if (value > 1 || value < 0) {\n        return {\n          success: false, error: `Parameter '${ parameterName }' must be in percentage range (0 to 1). (${ value })`\n        };\n      }\n      break;\n    }\n    case `nonZero`: {\n      if (value === 0) {\n        return { success: false, error: `Parameter '${ parameterName }' must non-zero. (${ value })` };\n      }\n      break;\n    }\n    case `bipolar`: {\n      if (value > 1 || value < -1) {\n        return { success: false, error: `Parameter '${ parameterName }' must be in bipolar percentage range (-1 to 1). (${ value })` };\n      }\n      break;\n    }\n  }\n  return { success: true, value };\n};\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Throws if invalid. Use {@link numberTest} to test without throwing.\n *\n* * (empty, default): must be a number type and not NaN.\n* * positive: must be at least zero\n* * negative: must be zero or lower\n* * aboveZero: must be above zero\n* * belowZero: must be below zero\n* * percentage: must be within 0-1, inclusive\n* * nonZero: can be anything except zero\n* * bipolar: can be -1 to 1, inclusive\n* \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n * @param value Value to test\n * @param range Range\n * @param parameterName Name of parameter \n */\n// export const throwNumberTest = (value?: unknown,\n//   range: NumberGuardRange = ``,\n//   parameterName = `?`) => {\n//   throwFromResult(numberTest(value, range, parameterName));\n// }\n\n/**\n * Returns test of `value` being in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n *\n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @returns\n */\nexport const percentTest = (value: number, parameterName = `?`): Result<number, string> =>\n  numberTest(value, `percentage`, parameterName);\n\n// export const throwPercentTest = (value: number, parameterName = `?`) => {\n//   throwFromResult(percentTest(value, parameterName));\n//}\n/**\n * Checks if `value` an integer and meets additional criteria.\n * See {@link numberTest} for guard details, or use that if integer checking is not required.\n *\n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integerTest = (\n  value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`\n): Result<number, string> => {\n  return resultsCollate(\n    numberTest(value, range, parameterName),\n    () => {\n      if (!Number.isInteger(value)) {\n        return { success: false, error: `Param '${ parameterName }' is not an integer` };\n      }\n      return { success: true, value: value }\n    }\n  )\n};\n\nexport const integerArrayTest = (numbers: Iterable<number>): Result<Iterable<number>, string> => {\n  for (const v of numbers) {\n    if (Math.abs(v) % 1 !== 0) return { success: false, error: `Value is not an integer: ${ v }` };\n  }\n  return { success: true, value: numbers };\n};\n\n/**\n * Returns _true_ if `value` is an integer in number or string form\n * @param value \n * @returns \n */\nexport const isInteger = (value: number | string): boolean => {\n  if (typeof value === `string`) value = Number.parseFloat(value);\n  const r = integerTest(value);\n  return r.success;\n}\n\n// export const throwIntegerTest = (value: number | undefined,\n//   range: NumberGuardRange = ``,\n//   parameterName = `?`) => {\n//   throwFromResult(integerTest(value, range, parameterName));\n// }\n\nexport const numberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`): Result<number, string> => {\n  if (typeof value !== `number`) {\n    return { success: false, error: `Param '${ parameterName }' is not a number type. Got type: '${ typeof value }' value: '${ JSON.stringify(value) }'` };\n  }\n  if (Number.isNaN(value)) {\n    return { success: false, error: `Param '${ parameterName }' is not within range ${ min }-${ max }. Got: NaN` };\n  }\n  if (Number.isFinite(value)) {\n    if (value < min) {\n      return { success: false, error: `Param '${ parameterName }' is below range ${ min }-${ max }. Got: ${ value }` };\n    } else if (value > max) {\n      return { success: false, error: `Param '${ parameterName }' is above range ${ min }-${ max }. Got: ${ value }` };\n    }\n    return { success: true, value };\n  } else {\n    return { success: false, error: `Param '${ parameterName }' is not within range ${ min }-${ max }. Got: infinite` };\n  }\n}\n\n// export const throwNumberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`) => {\n//   const r = numberInclusiveRangeTest(value, min, max, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ]);\n// }"],"mappings":"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"}