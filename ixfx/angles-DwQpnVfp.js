import{p as e,u as t,y as n}from"./numbers-BlBexQl9.js";import{n as r}from"./moving-average-CQgRiq9V.js";const i=e=>u(e)&&e.z!==null?!1:e.x===null&&e.y===null,a=e=>u(e)&&!Number.isNaN(e.z)?!1:Number.isNaN(e.x)||Number.isNaN(e.y);function o(t,n=`Point`,r=``){if(t===void 0)return e(`'${n}' is undefined. Expected {x,y} got ${JSON.stringify(t)}`,r);if(t===null)return e(`'${n}' is null. Expected {x,y} got ${JSON.stringify(t)}`,r);if(typeof t!=`object`)return e(`'${n}' is type '${typeof t}'. Expected object.`,r);if(t.x===void 0)return e(`'${n}.x' is undefined. Expected {x,y} got ${JSON.stringify(t)}`,r);if(t.y===void 0)return e(`'${n}.y' is undefined. Expected {x,y} got ${JSON.stringify(t)}`,r);if(typeof t.x!=`number`)return e(`'${n}.x' must be a number. Got ${typeof t.x}`,r);if(typeof t.y!=`number`)return e(`'${n}.y' must be a number. Got ${typeof t.y}`,r);if(t.z!==void 0){if(typeof t.z!=`number`)return e(`${n}.z must be a number. Got: ${typeof t.z}`,r);if(Number.isNaN(t.z))return e(`'${n}.z' is NaN. Got: ${JSON.stringify(t)}`,r)}return t.x===null?e(`'${n}.x' is null`,r):t.y===null?e(`'${n}.y' is null`,r):Number.isNaN(t.x)?e(`'${n}.x' is NaN`,r):Number.isNaN(t.y)?e(`'${n}.y' is NaN`,r):{success:!0,value:t}}function s(e,t=`Point`,r){n(o(e,t,r))}const c=(e,r=`pt`)=>(s(e,r),n(t(e.x,`nonZero`,`${r}.x`),t(e.y,`nonZero`,`${r}.y`),()=>{if(e.z!==void 0)return t(e.z,`nonZero`,`${r}.z`)}),!0);function l(e){return!(e==null||e.x===void 0||e.y===void 0)}const u=e=>!(e==null||e.x===void 0||e.y===void 0||e.z===void 0),d=e=>u(e)&&e.z!==0?!1:e.x===0&&e.y===0,f=e=>u(e)&&!Number.isNaN(e.z)?!1:Number.isNaN(e.x)&&Number.isNaN(e.y),p=Math.PI*2,m=(e,t=`mean`)=>{let n=0,r=0,i=NaN,a=0;if(t!==`mean`)throw Error(`Unknown averaging kind: '${t}' expected: 'mean'`);for(let t of e){if(n+=t.x,r+=t.y,`z`in t&&t.z!==void 0)i+=t.z;else if(Number.isNaN(i))throw Error(`List of points should all have Z property, or none`);a++}return n/=a,r/=a,Number.isNaN(i)?{x:n,y:r}:{x:n,y:r,z:i/a}};function h(e,t={}){let n,i,a;switch(e){case`moving-average-light`:{let e=t.scaling??3;n=r(e),i=r(e),a=r(e);break}default:throw Error(`Unknown averaging kind '${e}'. Expected: 'moving-average-light'`)}return e=>{let t=n(e.x),r=i(e.y);if(u(e)){let n=a(e.z);return Object.freeze({x:t,y:r,z:n})}else return Object.freeze({x:t,y:r})}}function g(e){return Array.isArray(e)?e.map(e=>e*(Math.PI/180)):e*(Math.PI/180)}function _(e){return(e+Math.PI)%(2*Math.PI)}function v(e){return e*1.111111}function y(e,t=!0){return t?e*.9%360:e*.9}function b(e){return e*63.6619772368}function x(e){return e*.0157079633}function S(e){return Array.isArray(e)?e.map(e=>e*180/Math.PI):e*180/Math.PI}const C=e=>Math.atan2(e.x,e.y),w=(e,t,n=!0)=>{if(n){let n=e+t;return n>=p&&(n%=p),n}else{let n=e-t;return n<0?p+n:n}},T=(e,t,n=!0)=>S(w(g(e),g(t),n)),E=(e,t,n=!0)=>{let r=e;t<r&&(r=0,t=p-e+t);let i=t-r;return n&&(i=p-i),i>=p?i%p:i},D=(e,t,n=!0)=>S(E(g(e),g(t),n)),O=e=>{if(k(e))return e;if(typeof e==`number`)return{value:e,unit:`deg`};e=e.toLowerCase();let t=`deg`,n=NaN;if(e.endsWith(`grad`)?(n=Number.parseFloat(e.substring(0,e.length-4)),t=`grad`):e.endsWith(`rad`)?(n=Number.parseFloat(e.substring(0,e.length-3)),t=`rad`):e.endsWith(`turn`)?(n=Number.parseFloat(e.substring(0,e.length-4)),t=`turn`):e.endsWith(`deg`)?(n=Number.parseFloat(e.substring(0,e.length-3)),t=`deg`):n=Number.parseFloat(e),Number.isNaN(n))throw Error(`Invalid angle (bad value?)`);if(t.length===0)throw Error(`Invalid angle (no unit)`);return{value:n,unit:t}},k=e=>typeof e==`object`&&`unit`in e&&`value`in e?!(typeof e.unit!=`string`||typeof e.value!=`number`):!1,A=e=>typeof e==`number`?e:j(e,`rad`).value,j=(e,t)=>{let n=typeof e==`object`?e:O(e);switch(t){case`deg`:if(n.unit===`deg`)return n;if(n.unit===`rad`)return{value:S(n.value),unit:`deg`};if(n.unit===`grad`)return{value:y(n.value),unit:`deg`};if(n.unit===`turn`)return{value:P(n.value),unit:`deg`};throw Error(`Unknown unit: ${n.unit}`);case`grad`:if(n.unit===`deg`)return{value:v(n.value),unit:`grad`};if(n.unit===`rad`)return{value:b(n.value),unit:`grad`};if(n.unit===`grad`)return n;if(n.unit===`turn`)return{value:b(I(n.value)),unit:`grad`};throw Error(`Unknown unit: ${n.unit}`);case`rad`:if(n.unit===`deg`)return{value:g(n.value),unit:`rad`};if(n.unit===`rad`)return n;if(n.unit===`grad`)return{value:x(n.value),unit:`rad`};if(n.unit===`turn`)return{value:b(I(n.value)),unit:`grad`};throw Error(`Unknown unit: ${n.unit}`);case`turn`:if(n.unit===`deg`)return{value:L(n.value),unit:`turn`};if(n.unit===`rad`)return{value:R(n.value),unit:`turn`};if(n.unit===`grad`)return{value:R(x(n.value)),unit:`turn`};if(n.unit===`turn`)return n;throw Error(`Unknown unit: ${n.unit}`);default:throw Error(`Destination unit unknown ('${t}). Expects: deg, grad, rad or turn`)}},M=e=>{let t=A(e);return{x:Math.cos(t),y:Math.sin(t)}},N=(e,t=`rad`)=>{let n=Math.atan2(e.x,e.y);return t===`rad`?{unit:`rad`,value:n}:j(n,t)},P=(e,t=!0)=>t?e*360%360:e*360,F=(e,t=`mean`)=>{let n=e.map(e=>O(e));return N(m(n.map(e=>M(e))),n[0].unit)},I=e=>e*p,L=e=>e/360,R=e=>e/p,z=e=>(e%=p,e<0?e+p:e),B=(e,t,n)=>{if(t<0||t>p)throw TypeError(`Param 'start' out of range. Expecting 0..2PI. Got: ${t}`);if(n<0||n>p)throw TypeError(`Param 'end' out of range. Expecting 0..2PI. Got: ${n}`);return t>Math.PI&&n<=Math.PI?e>Math.PI?e>=t:e<=n:e>=t&&e<=n},V=(e,t)=>{if(e<0||e>p)throw TypeError(`Param 'a' out of range. Expecting 0..2PI. Got: ${e}`);if(t<0||t>p)throw TypeError(`Param 'b' out of range. Expecting 0..2PI. Got: ${t}`);let n=Math.min(e,t),r=Math.max(e,t);if(n<Math.PI&&r>Math.PI){let e=p-r+n,t=r-n;if(e<t)return{min:{start:r,end:n,sweep:e},max:{start:n,end:r,sweep:t}}}return{min:{start:n,end:r,sweep:r-n},max:{start:r,end:n,sweep:p-(r-n)}}};export{s as A,A as C,m as D,I as E,f as F,l as I,u as L,d as M,a as N,h as O,i as P,o as R,w as S,P as T,b as _,v as a,C as b,T as c,x as d,k as f,S as g,V as h,D as i,c as j,p as k,N as l,_ as m,O as n,g as o,E as p,F as r,L as s,j as t,y as u,R as v,M as w,z as x,B as y};