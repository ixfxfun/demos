{"version":3,"file":"sleep-DlSTbGqd.js","names":["toStringDefault","interval","intervalToMs","resolve","resolveSync","resolve"],"sources":["../../packages/core/dist/src/to-string.js","../../packages/core/dist/src/comparers.js","../../packages/core/dist/src/count.js","../../packages/core/dist/src/continuously.js","../../packages/core/dist/src/correlate.js","../../packages/core/dist/src/default-keyer.js","../../packages/core/dist/src/elapsed.js","../../packages/core/dist/src/filters.js","../../packages/core/dist/src/text.js","../../packages/core/dist/src/is-equal-test.js","../../packages/core/dist/src/is-equal.js","../../packages/core/dist/src/is-integer.js","../../packages/core/dist/src/is-primitive.js","../../packages/core/dist/src/iterable-compare-values-shallow.js","../../packages/core/dist/src/key-value.js","../../packages/core/dist/src/util/round.js","../../packages/core/dist/src/interval-type.js","../../packages/core/dist/src/track-unique.js","../../packages/core/dist/src/platform.js","../../packages/core/dist/src/promise-from-event.js","../../packages/core/dist/src/reactive-core.js","../../packages/core/dist/src/resolve-core.js","../../packages/core/dist/src/util/zip.js","../../packages/core/dist/src/resolve-fields.js","../../packages/core/dist/src/results.js","../../packages/core/dist/src/sleep.js"],"sourcesContent":["// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nexport const isMap = (value) => toTypeString(value) === `[object Map]`;\nexport const isSet = (value) => toTypeString(value) === `[object Set]`;\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultToString = (object) => {\n    //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n    if (object === null)\n        return `null`;\n    if (typeof object === `boolean` || typeof object === `number`) {\n        return object.toString();\n    }\n    if (typeof object === `string`)\n        return object;\n    if (typeof object === `symbol`)\n        throw new TypeError(`Symbol cannot be converted to string`);\n    return JSON.stringify(object);\n};\n","import { defaultToString } from \"./to-string.js\";\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * @param x\n * @param y\n * @returns\n */\nexport const numericComparer = (x, y) => {\n    // ✔️ Unit tested\n    if (x === y)\n        return 0;\n    if (x > y)\n        return 1;\n    return -1;\n};\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\nexport const jsComparer = (x, y) => {\n    // ✔️ Unit tested\n    // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n    if (x === undefined && y === undefined)\n        return 0;\n    if (x === undefined)\n        return 1;\n    if (y === undefined)\n        return -1;\n    const xString = defaultToString(x);\n    const yString = defaultToString(y);\n    if (xString < yString)\n        return -1;\n    if (xString > yString)\n        return 1;\n    return 0;\n};\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = (comparer) => {\n    return (x, y) => {\n        const v = comparer(x, y);\n        return v * -1;\n    };\n};\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x, y) => {\n    if (typeof x === `number` && typeof y === `number`) {\n        return numericComparer(x, y);\n    }\n    return jsComparer(x, y);\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount, offset = 0) {\n    resultThrow(integerTest(amount, ``, `amount`), integerTest(offset, ``, `offset`));\n    if (amount === 0)\n        return;\n    let index = 0;\n    do {\n        yield (amount < 0 ? -index + offset : index + offset);\n    } while (index++ < Math.abs(amount) - 1);\n}\n;\n","import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see {@link Timeout} if you want to trigger something once.\n */\nexport const continuously = (callback, interval, options = {}) => {\n    let intervalMs = intervalToMs(interval, 0);\n    resultThrow(integerTest(intervalMs, `positive`, `interval`));\n    const fireBeforeWait = options.fireBeforeWait ?? false;\n    const onStartCalled = options.onStartCalled;\n    const signal = options.signal;\n    let disposed = false;\n    let runState = `idle`;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let startedAt = performance.now();\n    let intervalUsed = interval ?? 0;\n    let cancelled = false;\n    let currentTimer;\n    const deschedule = () => {\n        if (currentTimer === undefined)\n            return;\n        globalThis.clearTimeout(currentTimer);\n        currentTimer = undefined;\n        startCount = 0;\n        startedAt = Number.NaN;\n    };\n    const schedule = (scheduledCallback) => {\n        if (intervalMs === 0) {\n            if (typeof requestAnimationFrame === `undefined`) {\n                currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n            }\n            else {\n                currentTimer = undefined;\n                requestAnimationFrame(scheduledCallback);\n            }\n        }\n        else {\n            currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n        }\n    };\n    const cancel = () => {\n        if (cancelled)\n            return;\n        cancelled = true;\n        if (runState === `idle`)\n            return; // No need to cancel\n        runState = `idle`;\n        deschedule();\n    };\n    const loop = async () => {\n        if (signal?.aborted) {\n            runState = `idle`;\n        }\n        if (runState === `idle`)\n            return;\n        runState = `running`;\n        startCount++;\n        startCountTotal++;\n        const valueOrPromise = callback(startCount, performance.now() - startedAt);\n        const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n        if (cancelled) {\n            return;\n        }\n        runState = `scheduled`;\n        // Didn't get a value, exit out\n        if (value !== undefined && !value) {\n            cancel();\n            return;\n        }\n        if (cancelled)\n            return; // has been cancelled\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop);\n    };\n    const start = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        if (onStartCalled !== undefined) {\n            // A function governs whether to allow .start() to go ahead\n            const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n            switch (doWhat) {\n                case `cancel`: {\n                    cancel();\n                    return;\n                }\n                case `reset`: {\n                    reset();\n                    return;\n                }\n                case `dispose`: {\n                    disposed = true;\n                    cancel();\n                    return;\n                }\n                // No default\n            }\n        }\n        if (runState === `idle`) {\n            // Start running\n            startCount = 0;\n            startedAt = performance.now();\n            runState = `scheduled`;\n            if (fireBeforeWait) {\n                void loop(); // Exec first, then wait\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                schedule(loop); // Wait first, then exec\n            }\n        } // else: already running, ignore\n    };\n    const reset = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        startCount = 0;\n        startedAt = Number.NaN;\n        // Cancel scheduled iteration\n        if (runState !== `idle`) {\n            cancel();\n        }\n        start();\n    };\n    return {\n        start,\n        reset,\n        cancel,\n        get interval() {\n            return intervalUsed;\n        },\n        get runState() {\n            return runState;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        },\n        get startCount() {\n            return startCount;\n        },\n        set interval(interval) {\n            const ms = intervalToMs(interval, 0);\n            resultThrow(integerTest(ms, `positive`, `interval`));\n            intervalMs = ms;\n            intervalUsed = interval;\n        },\n        get isDisposed() {\n            return disposed;\n        },\n        get elapsedMs() {\n            return performance.now() - startedAt;\n        },\n    };\n};\n","const orderScore = (a, b) => {\n    if (a.score > b.score)\n        return -1;\n    else if (a.score < b.score)\n        return 1;\n    return 0;\n};\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\nexport const align = (similarityFunction, lastData, newData, options = {}) => {\n    const matchThreshold = options.matchThreshold ?? 0;\n    const debug = options.debug ?? false;\n    const results = new Map();\n    const newThings = [];\n    const lastMap = new Map();\n    lastData?.forEach((d, index) => {\n        if (typeof d === `undefined`) {\n            throw new Error(`'lastData' contains undefined (index: ${index.toString()})`);\n        }\n        lastMap.set(d.id, d);\n    });\n    for (const newD of newData) { //let index = 0; index < newData.length; index++) {\n        //const newD = newData[ index ];\n        if (!lastData || lastData.length === 0) {\n            // No last data to compare to\n            if (debug)\n                console.debug(`Correlate.align() new id: ${newD.id}`);\n            newThings.push(newD);\n            continue;\n        }\n        // Which of the old data does the new data match up to best?\n        const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n            id: (last).id,\n            score: last === null ? -1 : similarityFunction(last, newD),\n            last,\n        }));\n        if (scoredLastValues.length === 0) {\n            if (debug) {\n                console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n            }\n            newThings.push(newD);\n            continue;\n        }\n        scoredLastValues.sort(orderScore);\n        // Top-ranked match is pretty low, must be something new\n        const top = scoredLastValues[0];\n        if (top.score < matchThreshold) {\n            if (debug) {\n                console.debug(`Correlate.align() new item does not reach threshold. Top score: ${top.score.toString()} id: ${newD.id}`);\n            }\n            newThings.push(newD);\n            continue;\n        }\n        // TODO: If there are close options to pick, need a pluggable\n        // function to determine which is the winner.\n        //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n        // The new item is considered the same as top ranked\n        if (debug && top.id !== newD.id) {\n            console.log(`Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score.toString()})`);\n        }\n        results.set(top.id, { ...newD, id: top.id });\n        // Remove that old one from the list\n        lastMap.delete(top.id);\n    }\n    newThings.forEach((t) => results.set(t.id, t));\n    return Array.from(results.values());\n};\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = (fn, options = {}) => {\n    let lastData = [];\n    const compute = (newData) => {\n        lastData = align(fn, lastData, newData, options);\n        return [...lastData];\n    };\n    return compute;\n};\n","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = (a) => {\n    return typeof a === `string` ? a : JSON.stringify(a);\n};\n","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n/**\n * Returns elapsed time since the initial call.\n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = () => {\n    const start = performance.now();\n    return () => {\n        return performance.now() - start;\n    };\n};\n/**\n * Returns the interval between the start and each subsequent call.\n *\n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n *\n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns\n */\nexport const elapsedInterval = () => {\n    let start = performance.now();\n    return () => {\n        const now = performance.now();\n        const x = now - start;\n        start = now;\n        return x;\n    };\n};\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n *\n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = () => {\n    const start = Date.now();\n    let stoppedAt = 0;\n    return () => {\n        if (stoppedAt === 0) {\n            stoppedAt = Date.now() - start;\n        }\n        return stoppedAt;\n    };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = () => {\n    return () => {\n        return Number.POSITIVE_INFINITY;\n    };\n};\n","/**\n * Returns `v` if `predicate` returns _true_,\n * alternatively returning `skipValue`.\n *\n * ```js\n * // Return true if value is less than 10\n * const p = v => v < 10;\n *\n * filterValue(5, p, 0);   // 5\n * filterValue(20, p, 0);  // 0\n * ```\n * @param v Value to test\n * @param predicate Predicate\n * @param skipValue Value to return if predicate returns false\n * @returns Input value if predicate is _true_, or `skipValue` if not.\n */\nexport const filterValue = (v, predicate, skipValue) => {\n    if (predicate(v))\n        return v;\n    return skipValue;\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Whittles down from whole string to last token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToEnd(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const trimmed = afterMatch(source, delimiter);\n        if (trimmed === source) {\n            // Delimiter not found\n            break;\n        }\n        source = trimmed;\n    }\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Starts with last token, builds to whole.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsLastToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n        if (ba[0] === ba[1] && ba[1] === source) {\n            // Delimiter not found\n            break;\n        }\n        const v = ba[1] + accumulator;\n        yield v;\n        accumulator = delimiter + v;\n        source = ba[0];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with the first token and build up until end.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsFirstToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n        if (ba[0] === source && ba[1] === source)\n            break;\n        accumulator += ba[0];\n        yield accumulator;\n        accumulator += delimiter;\n        source = ba[1];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with whole string and whittle down to starting token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToFirst(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n        if (b === source)\n            break;\n        source = b;\n    }\n}\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n *\n * If `source` is under `maxLength` the original is returned.\n * @param source\n * @param maxLength Maximum length. Defaults to 20\n * @returns\n */\nexport const abbreviate = (source, maxLength = 15) => {\n    resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (source.length > maxLength && source.length > 3) {\n        if (maxLength > 15) {\n            const chunk = Math.round((maxLength - 2) / 2);\n            return source.slice(0, chunk) + `...` + source.slice(-chunk);\n        }\n        return source.slice(0, maxLength) + `...`;\n    }\n    return source;\n};\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns\n */\nexport const toStringAbbreviate = (source, maxLength = 20) => {\n    if (source === undefined)\n        return `(undefined)`;\n    if (source === null)\n        return `(null)`;\n    return abbreviate(JSON.stringify(source), maxLength);\n};\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return;\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return;\n    return source.slice(startPos + 1, endPos);\n};\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (typeof start !== `string`)\n        throw new Error(`Parameter 'start' is not a string`);\n    if (end !== undefined && typeof end !== `string`)\n        throw new Error(`Parameter 'end' is not a string`);\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return [source, undefined];\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return [source, undefined];\n    const between = source.slice(startPos + 1, endPos);\n    const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n    return [sourceResult, between];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {\n    for (let index = start; index <= end; index++) {\n        if (source.codePointAt(index) === code)\n            return index;\n    }\n    return -1;\n};\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) +\n    source.slice(removeStart + removeLength);\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (source, length) => {\n    resultThrow(integerTest(length, `aboveZero`, `length`));\n    if (source === null)\n        throw new Error(`source parameter null`);\n    if (typeof source !== `string`) {\n        throw new TypeError(`source parameter not a string`);\n    }\n    // ✔ Unit tested\n    const chunks = Math.ceil(source.length / length);\n    const returnValue = [];\n    let start = 0;\n    for (let c = 0; c < chunks; c++) {\n        returnValue.push(source.slice(start, start + length));\n        start += length;\n    }\n    return returnValue;\n};\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[0];\n};\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[1];\n};\n/**\n * Returns the text that is before and after `match`.\n *\n * See also: {@link beforeMatch}, {@link afterMatch}.\n *\n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeAfterMatch = (source, match, options = {}) => {\n    if (source === undefined)\n        throw new Error(`Param 'source' is undefined`);\n    let fallback = options.fallback;\n    const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n    if (ifNoMatch === `original`)\n        fallback = source;\n    if (ifNoMatch === `fallback` && fallback === undefined)\n        throw new Error(`Fallback must be provided`);\n    const startPos = options.startPos ?? undefined;\n    const fromEnd = options.fromEnd ?? false;\n    const m = fromEnd\n        ? source.lastIndexOf(match, startPos)\n        : source.indexOf(match, startPos);\n    if (m < 0 && ifNoMatch === `throw`)\n        throw new Error(`Match '${match}' not found in source.`);\n    if (m < 0 && ifNoMatch === `original`)\n        return [source, source];\n    if (m < 0 && ifNoMatch === `fallback`) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return [fallback, fallback];\n    }\n    return [\n        source.slice(0, m),\n        source.slice(Math.max(0, m + match.length))\n    ];\n};\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (source, ...wrappers) => {\n    let matched = false;\n    do {\n        matched = false;\n        for (const w of wrappers) {\n            if (source.startsWith(w) && source.endsWith(w)) {\n                source = source.slice(w.length, source.length - w.length * 2 + 1);\n                matched = true;\n            }\n        }\n    } while (matched);\n    return source;\n};\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges, start, end) => {\n    let s = -1;\n    let endPos = -1;\n    for (const [index, r] of ranges.entries()) {\n        s = index;\n        if (r.text.length === 0)\n            continue;\n        if (start < r.end) {\n            break;\n        }\n    }\n    for (let index = s; index < ranges.length; index++) {\n        const r = ranges[index];\n        endPos = index;\n        if (end === r.end) {\n            endPos = index + 1;\n            break;\n        }\n        if (end < r.end) {\n            break;\n        }\n    }\n    return { length: endPos - s, start: s, end: endPos };\n};\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (source, split) => {\n    let start = 0;\n    let text = ``;\n    const ranges = [];\n    let index = 0;\n    for (let index_ = 0; index_ < source.length; index_++) {\n        if (source.indexOf(split, index_) === index_) {\n            const end = index_;\n            ranges.push({\n                text,\n                start,\n                end,\n                index,\n            });\n            start = end + 1;\n            text = ``;\n            index++;\n        }\n        else {\n            text += source.charAt(index_);\n        }\n    }\n    if (start < source.length) {\n        ranges.push({ text, start, index, end: source.length });\n    }\n    return ranges;\n};\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (source, ...chars) => {\n    let counted = 0;\n    for (let index = 0; index < source.length; index++) {\n        if (chars.includes(source.charAt(index))) {\n            counted++;\n        }\n        else {\n            break;\n        }\n    }\n    return counted;\n};\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);\nexport const htmlEntities = (source) => source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${index.codePointAt(0)};`);\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern\n * @returns\n */\nexport const wildcard = (pattern) => {\n    // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n    // for this solution to work on any string, no matter what characters it has\n    const escapeRegex = (value) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n    // \".\"  => Find a single character, except newline or line terminator\n    // \".*\" => Matches any string that contains zero or more characters\n    pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n    // \"^\"  => Matches any string with the following at the beginning of it\n    // \"$\"  => Matches any string with that in front at the end of it\n    pattern = `^` + pattern + `$`;\n    // Create a regular expression object for matching string\n    const regex = new RegExp(pattern);\n    return (value) => {\n        // Returns true if it finds a match, otherwse it returns false\n        return regex.test(value);\n    };\n};\n","import { toStringAbbreviate } from \"./text.js\";\n/**\n * Wraps the `eq` function, tracing the input data result\n * ```js\n * // Init trace\n * const traceEq = isEqualTrace(isEqualValueDefault);\n * // Use it in some function that takes IsEqual<T>\n * compare(a, b, eq);\n * ```\n * @param eq\n * @returns\n */\nexport const isEqualTrace = (eq) => {\n    return (a, b) => {\n        const result = eq(a, b);\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        console.log(`isEqualTrace eq: ${result} a: ${toStringAbbreviate(a)} b: ${toStringAbbreviate(b)}`);\n        return result;\n    };\n};\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\nexport const toStringOrdered = (itemToMakeStringFor) => {\n    if (typeof itemToMakeStringFor === `string`)\n        return itemToMakeStringFor;\n    const allKeys = new Set();\n    JSON.stringify(itemToMakeStringFor, (key, value) => (allKeys.add(key), value));\n    return JSON.stringify(itemToMakeStringFor, [...allKeys].sort());\n};\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n *\n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n *\n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value\n * @returns\n */\nexport const isInteger = (value) => {\n    if (value === undefined)\n        return false;\n    if (typeof value === `string`) {\n        const v = Number.parseInt(value);\n        if (Number.isNaN(v))\n            return false;\n        if (v.toString() === value.toString())\n            return true;\n        return false;\n    }\n    if (typeof value === `number`) {\n        if (Number.isNaN(value))\n            return false;\n        if (!Number.isFinite(value))\n            return false;\n        if (Math.round(value) === value)\n            return true;\n        return false;\n    }\n    return false;\n};\n","/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n *\n * Use {@link isPrimitiveOrObject} to also return true if `value` is an object.\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value) {\n    if (typeof value === `number`)\n        return true;\n    if (typeof value === `string`)\n        return true;\n    if (typeof value === `bigint`)\n        return true;\n    if (typeof value === `boolean`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `value` is number, string, bigint, boolean or an object\n *\n * Use {@link isPrimitive} to not include objects.\n * @param value\n * @returns\n */\nexport function isPrimitiveOrObject(value) {\n    if (isPrimitive(value))\n        return true;\n    if (typeof value === `object`)\n        return true;\n    return false;\n}\n","import { isEqualDefault } from \"./is-equal.js\";\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common and those unique in `a` or `b`.\n * Ignores ordering of values, and is NOT recursive.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValuesShallow(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n *\n * By default uses === semantics for comparison.\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareIterableValuesShallow = (a, b, eq = (isEqualDefault)) => {\n    const shared = [];\n    const aUnique = [];\n    const bUnique = [];\n    for (const elementOfA of a) {\n        let seenInB = false;\n        // Does B contain this thing from A?\n        for (const elementOfB of b) {\n            if (eq(elementOfA, elementOfB)) {\n                seenInB = true;\n                break;\n            }\n        }\n        if (seenInB) {\n            // Common in A & B\n            shared.push(elementOfA);\n        }\n        else {\n            // No, it's only found in A\n            aUnique.push(elementOfA);\n        }\n    }\n    for (const elementOfB of b) {\n        let seenInA = false;\n        // Does A contain this thing from B?\n        for (const elementOfA of a) {\n            if (eq(elementOfB, elementOfA)) {\n                seenInA = true;\n            }\n        }\n        if (!seenInA) {\n            // No, something unique to B\n            bUnique.push(elementOfB);\n        }\n    }\n    // Are the two iterables the same?\n    const isSame = aUnique.length === 0 && bUnique.length === 0;\n    return {\n        shared,\n        isSame,\n        a: aUnique,\n        b: bUnique\n    };\n};\n","//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\nimport { defaultComparer } from './comparers.js';\nconst sorterByValueIndex = (index, reverse = false) => {\n    return (values) => {\n        const s = values.toSorted((a, b) => {\n            return defaultComparer(a[index], b[index]);\n        });\n        if (reverse)\n            return s.reverse();\n        return s;\n    };\n};\nexport const keyValueSorter = (sortStyle) => {\n    switch (sortStyle) {\n        case `value`: {\n            return sorterByValueIndex(1, false);\n        }\n        case `value-reverse`: {\n            return sorterByValueIndex(1, true);\n        }\n        case `key`: {\n            return sorterByValueIndex(0, false);\n        }\n        case `key-reverse`: {\n            return sorterByValueIndex(0, true);\n        }\n        default: {\n            throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, value-reverse, key or key-reverse`);\n        }\n    }\n};\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest } from '@ixfx/guards';\nimport { round } from './util/round.js';\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n/**\n * Return the millisecond value of an Interval.\n *\n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(interval, defaultNumber) {\n    if (isInterval(interval)) {\n        // Number given, must be millis?\n        if (typeof interval === `number`)\n            return interval;\n        let ms = interval.millis ?? 0;\n        ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n        ms += (interval.mins ?? 0) * 60 * 1000;\n        ms += (interval.secs ?? 0) * 1000;\n        return ms;\n    }\n    else {\n        if (typeof defaultNumber !== `undefined`)\n            return defaultNumber;\n        throw new Error(`Not a valid interval: ${interval}`);\n    }\n}\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval\n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval) {\n    if (interval === undefined)\n        return false;\n    if (interval === null)\n        return false;\n    if (typeof interval === `number`) {\n        if (Number.isNaN(interval))\n            return false;\n        if (!Number.isFinite(interval))\n            return false;\n        return true;\n    }\n    else if (typeof interval !== `object`)\n        return false;\n    const hasMillis = `millis` in interval;\n    const hasSecs = `secs` in interval;\n    const hasMins = `mins` in interval;\n    const hasHours = `hours` in interval;\n    if (hasMillis && !numberTest(interval.millis)[0])\n        return false;\n    if (hasSecs && !numberTest(interval.secs)[0])\n        return false;\n    if (hasMins && !numberTest(interval.mins)[0])\n        return false;\n    if (hasHours && !numberTest(interval.hours)[0])\n        return false;\n    if (hasMillis || hasSecs || hasHours || hasMins)\n        return true;\n    return false;\n}\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n *\n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns\n */\nexport const elapsedToHumanString = (millisOrFunction, rounding = 2) => {\n    let interval = {} = 0;\n    if (typeof millisOrFunction === `function`) {\n        const intervalResult = millisOrFunction();\n        return elapsedToHumanString(intervalResult);\n    }\n    else if (typeof millisOrFunction === `number`) {\n        interval = millisOrFunction;\n    }\n    else if (typeof millisOrFunction === `object`) {\n        interval = intervalToMs(interval);\n    }\n    let ms = intervalToMs(interval);\n    if (typeof ms === `undefined`)\n        return `(undefined)`;\n    if (ms < 1000)\n        return `${round(rounding, ms)}ms`;\n    ms /= 1000;\n    if (ms < 120)\n        return `${ms.toFixed(1)}secs`;\n    ms /= 60;\n    if (ms < 60)\n        return `${ms.toFixed(2)}mins`;\n    ms /= 60;\n    return `${ms.toFixed(2)}hrs`;\n};\n","import { toStringDefault } from \"@ixfx/core\";\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link uniqueInstances}\n *\n * ```js\n * const t = unique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n *\n * Uses JSON.stringify to compare anything which is not a string.\n *\n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n *\n * ```js\n * const t = unique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n *\n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n *\n * Return function throws an error if `value` is null or undefined.\n * @returns\n */\nexport const unique = (toString = toStringDefault) => {\n    const set = new Set();\n    return (value) => {\n        if (value === null)\n            throw new TypeError(`Param 'value' cannot be null`);\n        if (value === undefined)\n            throw new TypeError(`Param 'value' cannot be undefined`);\n        const asString = (typeof value === `string`) ? value : toString(value);\n        if (set.has(asString))\n            return false;\n        set.add(asString);\n        return true;\n    };\n};\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link unique} to track by value.\n */\nexport const uniqueInstances = () => {\n    const set = new Set();\n    return (value) => {\n        if (value === null)\n            throw new TypeError(`Param 'value' cannot be null`);\n        if (value === undefined)\n            throw new TypeError(`Param 'value' cannot be undefined`);\n        if (set.has(value))\n            return false;\n        set.add(value);\n        return true;\n    };\n};\n","//eslint-disable-next-line functional/functional-parameters\nexport const runningiOS = () => [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);\n","export const promiseFromEvent = (target, name) => {\n    return new Promise(resolve => {\n        const handler = (...args) => {\n            target.removeEventListener(name, handler);\n            if (Array.isArray(args) && args.length === 1)\n                resolve(args[0]);\n            else\n                resolve(args);\n        };\n        target.addEventListener(name, handler);\n    });\n};\n","/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n","import { getErrorMessage } from \"@ixfx/debug\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n *\n * To resolve an object's properties, use {@link resolveFields}.\n *\n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r\n * @param args\n * @returns\n */\nexport async function resolve(r, ...args) {\n    if (typeof r === `object`) {\n        if (`next` in r) {\n            const tag = r[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = r.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                const v = await r.next();\n                //console.log(`  hasDone: ${ `done` in v } value:`, v);\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(r)) {\n            if (hasLast(r))\n                return r.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return r;\n        }\n    }\n    else if (typeof r === `function`) {\n        const v = await r(args);\n        return v;\n    }\n    else {\n        // Primitive value?\n        return r;\n    }\n}\nexport function resolveSync(r, ...args) {\n    if (typeof r === `object`) {\n        if (`next` in r) {\n            const tag = r[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = r.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                throw new Error(`resolveSync cannot work with an async generator`);\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(r)) {\n            if (hasLast(r))\n                return r.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return r;\n        }\n    }\n    else if (typeof r === `function`) {\n        return r(args);\n    }\n    else {\n        // Primitive value?\n        return r;\n    }\n}\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_\n * or NaN, `fallbackValue` is returned instead.\n *\n * `null` is an allowed return value.\n *\n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args\n * @returns\n */\nexport async function resolveWithFallback(p, fallback, ...args) {\n    let errored = false;\n    let fallbackValue = fallback.value;\n    const overrideWithLast = fallback.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Needs a fallback value`);\n    try {\n        const r = await resolve(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\nexport function resolveWithFallbackSync(p, fallback, ...args) {\n    let errored = false;\n    let fallbackValue = fallback.value;\n    const overrideWithLast = fallback.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Needs a fallback value`);\n    try {\n        const r = resolveSync(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\n","export const zip = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map((a) => a.length);\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        returnValue.push(arrays.map((a) => a[index]));\n    }\n    return returnValue;\n};\n","import { resolve, resolveSync } from \"@ixfx/core\";\nimport { zip } from \"./util/zip.js\";\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n *\n * Use {@link resolveFieldsSync} for a synchronous version.\n *\n * Not recursive.\n *\n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n *\n * It also works with generators\n * ```js\n * import { count } from './numbers.js';\n *\n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object\n * @returns\n */\nexport async function resolveFields(object) {\n    const resolvers = [];\n    const keys = [];\n    for (const entry of Object.entries(object)) {\n        const resolvable = entry[1];\n        resolvers.push(resolve(resolvable));\n        keys.push(entry[0]);\n    }\n    const results = await Promise.all(resolvers);\n    const entries = zip(keys, results);\n    return Object.fromEntries(entries);\n}\nexport function resolveFieldsSync(object) {\n    const entries = [];\n    for (const entry of Object.entries(object)) {\n        const resolvable = entry[1];\n        const value = resolveSync(resolvable);\n        entries.push([entry[0], value]);\n    }\n    return Object.fromEntries(entries);\n}\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n","import { getErrorMessage } from \"@ixfx/debug\";\n/**\n * If `result` is an error, throws it, otherwise ignored.\n * @param result\n * @returns\n */\nexport function throwResult(result) {\n    if (result.success)\n        return true;\n    if (typeof result.error === `string`)\n        throw new Error(result.error);\n    throw result.error;\n}\nexport function resultToError(result) {\n    if (typeof result.error === `string`)\n        return new Error(result.error);\n    else\n        return result.error;\n}\nexport function resultToValue(result) {\n    if (result.success)\n        return result.value;\n    else\n        throw resultToError(result);\n}\nexport function resultErrorToString(result) {\n    if (typeof result.error === `string`)\n        return result.error;\n    else\n        return getErrorMessage(result.error);\n}\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n    if (typeof window === `undefined`) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        globalThis.requestAnimationFrame = (callback) => {\n            setTimeout(callback, 1);\n        };\n    }\n}\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = (optsOrMillis) => {\n    const timeoutMs = intervalToMs(optsOrMillis, 1);\n    const signal = optsOrMillis.signal;\n    const value = optsOrMillis.value;\n    resultThrow(numberTest(timeoutMs, `positive`, `timeoutMs`));\n    if (timeoutMs === 0) {\n        return new Promise((resolve) => requestAnimationFrame((_) => {\n            resolve(value);\n        }));\n    }\n    else {\n        return new Promise((resolve, reject) => {\n            const onAbortSignal = () => {\n                clearTimeout(t);\n                if (signal) {\n                    signal.removeEventListener(`abort`, onAbortSignal);\n                    reject(new Error(signal.reason));\n                }\n                else {\n                    reject(new Error(`Cancelled`));\n                }\n            };\n            if (signal) {\n                signal.addEventListener(`abort`, onAbortSignal);\n            }\n            const t = setTimeout(() => {\n                signal?.removeEventListener(`abort`, onAbortSignal);\n                if (signal?.aborted) {\n                    reject(new Error(signal.reason));\n                    return;\n                }\n                resolve(value);\n            }, timeoutMs);\n        });\n    }\n};\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate\n * @param checkInterval\n */\nexport const sleepWhile = async (predicate, checkInterval = 100) => {\n    while (predicate()) {\n        await sleep(checkInterval);\n    }\n};\n"],"mappings":"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"}