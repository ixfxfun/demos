{"version":3,"sources":["../src/rx/Util.ts","../src/flow/Sleep.ts","../src/data/Resolve.ts","../src/flow/Repeat.ts"],"sourcesContent":["import { isIterable } from \"../iterables/Iterable.js\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactivePingable, ReactiveWritable, Wrapped } from \"./Types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./sources/Types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport const isPingable = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactivePingable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`ping` in rx) {\n    return true;\n  }\n  return false;\n}\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx \n * @returns \n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx \n * @returns \n */\nexport const isWritable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveWritable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`set` in rx) return true;\n  return false;\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotateElapsed` in v)) return false;\n  return true;\n}\n\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\n\nexport const opify = <TIn, TRxOut = Reactive<TIn>>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => TRxOut, ...args: Array<any>) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    return fn(source, ...args);\n  }\n}\n\n\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { throwNumberTest } from '../util/GuardNumbers.js';\nimport { type Interval, intervalToMs } from './IntervalType.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n  // eslint-disable-next-line unicorn/no-lonely-if\n  if (typeof window === `undefined`) {\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  throwNumberTest(timeoutMs, `positive`, `timeoutMs`);\n\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        clearTimeout(t);\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      const t = setTimeout(() => {\n        signal?.removeEventListener(`abort`, onAbortSignal);\n        if (signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate \n * @param checkInterval \n */\nexport const sleepWhile = async (predicate: () => boolean, checkInterval: Interval = 100) => {\n  while (predicate()) {\n    await sleep(checkInterval);\n  }\n}","import { hasLast, isReactive } from \"../rx/Util.js\";\nimport type { ReactiveNonInitial } from \"../rx/Types.js\";\nimport type { ValueType } from \"./Types.js\";\nimport { getErrorMessage } from \"../debug/GetErrorMessage.js\";\n\n/**\n * Something that can resolve to a value\n */\nexport type ResolveToValueSync<V> = ValueType | ReactiveNonInitial<V> | Generator<V> | IterableIterator<V> | ((args: any) => V)\nexport type ResolveToValueAsync<V> = AsyncGenerator<V> | AsyncIterableIterator<V> | Promise<V> | ((args: any) => Promise<V>);\nexport type ResolveToValue<V> = ResolveToValueAsync<V> | ResolveToValueSync<V>;\n\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n * \n * To resolve an object's properties, use {@link resolveFields}.\n * \n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r \n * @param args \n * @returns \n */\nexport async function resolve<V extends ValueType>(r: ResolveToValue<V>, ...args: any): Promise<V> {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      //console.log(tag);\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        const v = await r.next() as IteratorResult<V>;\n        //console.log(`  hasDone: ${ `done` in v } value:`, v);\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last();\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    const v = await r(args) as V;\n    return v;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\nexport function resolveSync<V extends ValueType>(r: ResolveToValueSync<V>, ...args: any): V {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        throw new Error(`resolveSync cannot work with an async generator`);\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last();\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    return r(args) as V;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_ \n * or NaN, `fallbackValue` is returned instead.\n * \n * `null` is an allowed return value.\n * \n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args \n * @returns \n */\nexport async function resolveWithFallback<T extends ValueType>(p: ResolveToValue<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = await resolve(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport function resolveWithFallbackSync<T extends ValueType>(p: ResolveToValueSync<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = resolveSync(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport type ResolveFallbackOpts<T> = { value: T, overrideWithLast?: boolean }","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport type { ValueType } from '../data/Types.js';\nimport { resolve, resolveSync, type ResolveToValue, type ResolveToValueSync } from '../data/Resolve.js';\nimport { intervalToMs, type Interval } from './IntervalType.js';\nimport { sleep } from './Sleep.js';\nimport type { RequireOnlyOne } from \"src/TsUtil.js\";\n\nexport type RepeatDelayOpts = RepeatOpts & Readonly<Partial<{\n  /**\n * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n */\n  delay: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  delayMinimum: Interval;\n\n  /**\n * When to perform delay. Default is before 'produce' is invoked.\n * Default: 'before'\n */\n  delayWhen: `before` | `after` | `both`;\n}>>\n\n\n/**\n * Options for repeat\n */\nexport type RepeatOpts = Partial<Readonly<{\n  /**\n   * If specified, repeating stops if this function returns false\n   * @param count\n   * @returns \n   */\n  while: (count: number) => boolean\n  /**\n   * By default, if the callback returns\n   * _undefined_ the repeating exits. Set this to _true_ to\n   * ignore undefined values\n   * @default false\n   */\n  allowUndefined: boolean\n  /**\n   * Optional signal to abort\n   */\n  signal: AbortSignal;\n\n  /**\n   * Maximum times to repeat (default: no limit)\n   */\n  count: number\n  /**\n   * Function to call when initialising\n   * @returns \n   */\n  onStart: () => void\n\n  /**\n   * Function to call when done (or an error occurs)\n   * @returns \n   */\n  onComplete: (withError: boolean) => void\n}>>;\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat<T extends ValueType>(\n  produce: ResolveToValue<T> | ArrayLike<T>,\n  opts: RepeatDelayOpts\n): AsyncGenerator<T> {\n  const signal = opts.signal ?? undefined;\n  const delayWhen = opts.delayWhen ?? `before`;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n  const whileFunc = opts.while;\n\n  let cancelled = false;\n  let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n  let started = performance.now();\n\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      if (delayWhen === `before` || delayWhen === `both`) await doDelay();\n      const result = await resolve<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (delayWhen === `after` || delayWhen === `both`) await doDelay();\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n      }\n      if (whileFunc) {\n        if (!whileFunc(loopedTimes)) {\n          cancelled = true;\n        }\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks. \n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync<T extends ValueType>(\n  produce: ResolveToValueSync<T> | ArrayLike<T>,\n  opts: RepeatOpts\n) {\n  const signal = opts.signal ?? undefined;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  let cancelled = false;\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      const result = resolveSync<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n        if (signal?.aborted) cancelled = true;\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n\n\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n\n\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };"],"mappings":"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","names":["resolve"]}