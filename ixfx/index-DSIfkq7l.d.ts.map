{"version":3,"file":"index-DSIfkq7l.d.ts","names":["TaskState","Task","Traversal","BtNode","BtNodeBase","SeqNode","ReadonlyArray","SelNode","iterateBreadth","Generator","iterateDepth","Interval","DelayOpts","AbortSignal","delay","V","Promise","delayLoop","AsyncGenerator","HasCompletion","Interval","TimeoutSyncCallback","TimeoutAsyncCallback","Promise","Timeout","timeout","Interval","TimeoutSyncCallback","TimeoutAsyncCallback","debounce","DebouncedFunction","Dispatch","V","DispatchList","everyNth","T","Comparer","ExpressionOrResult","ResultType","ArgsType","Promise","RunOpts","RunSingleOpts","V","run","runSingle","eventRace","EventTarget","AbortSignal","Partial","Event","Promise","Interval","MovingAverageTimedOptions","AbortSignal","Readonly","movingAverageTimed","SimpleEventEmitter","Debug","FullPolicy","PoolOptions","V","PoolState","PoolUserEventMap","PoolUser","Resource","Pool","LogSet","Generator","create","promiseWithResolvers","T","Promise","Interval","RateMinimumOptions","TInput","AbortSignal","Readonly","rateMinimum","BasicType","ResolveToValue","ResolveToValueSync","Interval","RepeatDelayOpts","RepeatOpts","Partial","Readonly","AbortSignal","repeat","T","ArrayLike","AsyncGenerator","repeatSync","Generator","SimpleEventEmitter","RequestResponseOptions","TRequest","TResp","RequestResponseMatchEvents","RequestResponseMatch","Partial","Promise","Result","RetryResult","V","BackoffOptions","backoffGenerator","Partial","Generator","RetryOpts","AbortSignal","T","RetryTask","Promise","retryFunction","retryTask","runOnce","SyncWait","Promise","SimpleEventEmitter","AsyncTask","Promise","TaskQueueEvents","TaskQueueMutable","throttle","Promise","HasCompletion","Interval","TimerSource","Timer","CompletionTimer","ModulationTimer","TimerOpts","RelativeTimerOpts","hasElapsed","ofTotal","ofTotalTicks","timerAlwaysDone","timerNeverDone","relative","Partial","frequencyTimer","elapsedMillisecondsAbsolute","elapsedTicksAbsolute","timerWithFunction","AsyncPromiseOrGenerator","V","Promise","Generator","IterableIterator","AsyncIterableIterator","AsyncGenerator","AsyncIterable","Iterable","Interval","UpdateFailPolicy","updateOutdated","V","Promise","WaitForValue","T","Promise","singleItem","waitFor","sleep","StateMachine"],"sources":["../../flow/dist/src/behaviour-tree.d.ts","../../flow/dist/src/delay.d.ts","../../flow/dist/src/timeout.d.ts","../../flow/dist/src/debounce.d.ts","../../flow/dist/src/dispatch-list.d.ts","../../flow/dist/src/every.d.ts","../../flow/dist/src/execute.d.ts","../../flow/dist/src/event-race.d.ts","../../flow/dist/src/moving-average.d.ts","../../flow/dist/src/pool.d.ts","../../flow/dist/src/promise-with-resolvers.d.ts","../../flow/dist/src/rate-minimum.d.ts","../../flow/dist/src/repeat.d.ts","../../flow/dist/src/req-resp-match.d.ts","../../flow/dist/src/retry.d.ts","../../flow/dist/src/run-once.d.ts","../../flow/dist/src/sync-wait.d.ts","../../flow/dist/src/task-queue-mutable.d.ts","../../flow/dist/src/throttle.d.ts","../../flow/dist/src/timer.d.ts","../../flow/dist/src/types.d.ts","../../flow/dist/src/update-outdated.d.ts","../../flow/dist/src/wait-for-value.d.ts","../../flow/dist/src/wait-for.d.ts","../../flow/dist/src/index.d.ts"],"sourcesContent":["export type TaskState = `Failed` | `Running` | `Success`;\nexport type Task = {\n    readonly state: TaskState;\n};\nexport type Traversal = readonly [\n    node: BtNode,\n    path: string\n];\n/**\n * Node can have conditions as to whether they should even be considered\n * Conditions can have dependencies on values, ideally this is responsive\n * Conditions might abort sibling nodes, as in example: https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreesOverview/\n */\nexport type BtNodeBase = {\n    readonly name?: string;\n};\nexport type SeqNode = BtNodeBase & {\n    readonly seq: ReadonlyArray<BtNode>;\n};\nexport type SelNode = BtNodeBase & {\n    readonly sel: ReadonlyArray<BtNode>;\n};\nexport type BtNode = SeqNode | SelNode | string;\nexport declare function iterateBreadth(t: BtNode, pathPrefix?: string): Generator<Traversal>;\nexport declare function iterateDepth(t: BtNode, pathPrefix?: string): Generator<Traversal>;\n//# sourceMappingURL=behaviour-tree.d.ts.map","import { type Interval } from '@ixfx/core';\n/**\n * Delay options\n */\nexport type DelayOpts = Interval & {\n    /**\n     * Signal for cancelling delay\n     */\n    readonly signal?: AbortSignal;\n    /**\n     * When delay is applied. \"before\" is default.\n     */\n    readonly delay?: `before` | `after` | `both`;\n};\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport declare const delay: <V>(callback: () => Promise<V>, optsOrMillis: DelayOpts | number) => Promise<V>;\n/**\n * Async generator that loops at a given interval.\n *\n * @example\n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n *\n * @example\n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport declare function delayLoop(timeout: Interval): AsyncGenerator<undefined, void, unknown>;\n//# sourceMappingURL=delay.d.ts.map","import { type HasCompletion } from '@ixfx/core';\nimport { type Interval } from '@ixfx/core';\nexport type TimeoutSyncCallback = (elapsedMs?: number, ...args: readonly unknown[]) => void;\nexport type TimeoutAsyncCallback = (elapsedMs?: number, ...args: readonly unknown[]) => Promise<void>;\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n    /**\n     * Starts the timer.\n     * If the timer has already been started and has a scheduled execution, this is cancelled\n     * and re-scheduled.\n     * @param altTimeoutMs Optional override for the interval. Use _undefined_ to use the original interval\n     * @param args\n     */\n    start(altTimeoutMs?: number, args?: readonly unknown[]): void;\n    /**\n     * Cancels the timer, aborting any scheduled execution.\n     */\n    cancel(): void;\n};\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n *\n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport declare const timeout: (callback: TimeoutSyncCallback | TimeoutAsyncCallback, interval: Interval) => Timeout;\n//# sourceMappingURL=timeout.d.ts.map","import type { Interval } from '@ixfx/core';\nimport { type TimeoutSyncCallback, type TimeoutAsyncCallback } from './timeout.js';\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param interval Minimum time between invocations\n * @returns Debounce function\n */\nexport declare const debounce: (callback: TimeoutSyncCallback | TimeoutAsyncCallback, interval: Interval) => DebouncedFunction;\n/**\n * Debounced function\n */\nexport type DebouncedFunction = (...args: readonly unknown[]) => void;\n//# sourceMappingURL=debounce.d.ts.map","export type Dispatch<V> = (value: V) => void;\n/**\n * Maintains a list of listeners to receive data\n *\n * ```js\n * const d = new DispatchList();\n *\n * // Eg: add a listener\n * d.add(v => {\n *  // Handle a value\n * });\n *\n * // Eg. send a value to all listeners\n * d.notify(`some value`);\n * ```\n */\nexport declare class DispatchList<V> {\n    #private;\n    constructor();\n    /**\n     * Returns _true_ if list is empty\n     * @returns\n     */\n    isEmpty(): boolean;\n    /**\n     * Adds a handler. You get back an id which can be used\n     * to remove the handler later.\n     *\n     * Handlers can be added with 'once' flag set to _true_. This will\n     * automatically remove them after the first value is sent to them.\n     * @param handler\n     * @param options\n     * @returns\n     */\n    add(handler: Dispatch<V>, options?: {\n        once?: boolean;\n    }): string;\n    /**\n     * Remove a handler by its id.\n     * @param id\n     * @returns _True_ if handler was removed, _false_ if not found.\n     */\n    remove(id: string): boolean;\n    /**\n     * Emit a value to all handlers\n     * @param value\n     */\n    notify(value: V): void;\n    /**\n     * Remove all handlers\n     */\n    clear(): void;\n}\n//# sourceMappingURL=dispatch-list.d.ts.map","/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport declare const everyNth: <T>(nth: number, callback?: (data: T) => void) => (data: T) => boolean;\n//# sourceMappingURL=every.d.ts.map","import { type Comparer } from '@ixfx/core';\nexport type ExpressionOrResult<ArgsType, ResultType> = ResultType | ((args: ArgsType | undefined) => Promise<ResultType | undefined> | ResultType | undefined | void);\nexport type RunOpts<ResultType> = {\n    /**\n     * If provided, filters the set of results prior to returning.\n     * @param result\n     * @returns\n     */\n    readonly filter?: (result: ResultType) => boolean;\n    /**\n     * If true, execution order is shuffled each time\n     */\n    readonly shuffle?: boolean;\n    /**\n     * Function to rank results. By default uses {@link defaultComparer} which orders\n     * by numeric value or alphabetical.\n     */\n    readonly rank?: Comparer<ResultType>;\n    /**\n     * If provided, stops execution if _true_ is returned.\n     * Result(s) include most recent execution.\n     * @param latest Latest result\n     * @param sorted Sorted list of current results, not including latest\n     * @returns\n     */\n    readonly stop?: (latest: ResultType | undefined, sorted: readonly ResultType[]) => boolean;\n};\nexport type RunSingleOpts<V> = RunOpts<V> & {\n    readonly at?: number;\n};\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = runSingle([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport declare const run: <ArgsType, ResultType>(expressions: ExpressionOrResult<ArgsType, ResultType>[] | ExpressionOrResult<ArgsType, ResultType> | readonly ExpressionOrResult<ArgsType, ResultType>[], opts?: RunOpts<ResultType>, args?: ArgsType) => Promise<ResultType[]>;\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport declare const runSingle: <ArgsType, ResultType>(expressions: readonly ExpressionOrResult<ArgsType, ResultType>[], opts?: RunSingleOpts<ResultType>, args?: ArgsType) => Promise<ResultType | undefined>;\n//# sourceMappingURL=execute.d.ts.map","/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n *\n * By default waits a maximum of 1 minute.\n *\n * Automatically unsubscribes on success or failure (ie. timeout)\n *\n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns\n */\nexport declare const eventRace: (target: EventTarget, eventNames: string[], options?: Partial<{\n    timeoutMs: number;\n    signal: AbortSignal;\n}>) => Promise<Event>;\n//# sourceMappingURL=event-race.d.ts.map","import type { Interval } from \"@ixfx/core\";\nexport type MovingAverageTimedOptions = Readonly<{\n    interval: Interval;\n    default?: number;\n    abort?: AbortSignal;\n}>;\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n *\n * mat(); // Get current average\n * ```\n *\n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n *\n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport declare const movingAverageTimed: (options: MovingAverageTimedOptions) => (v: number) => number;\n//# sourceMappingURL=moving-average.d.ts.map","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as Debug from '@ixfx/debug';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n/**\n * Pool options\n */\nexport type PoolOptions<V> = {\n    /**\n     * Maximum number of resources for this pool\n     */\n    readonly capacity?: number;\n    /**\n     * If above 0, users will be removed if there is no activity after this interval.\n     * Activity is marked whenever `use` us called with that user key.\n     * Default: disabled\n     */\n    readonly userExpireAfterMs?: number;\n    /**\n     * If above 0, resources with no users will be automatically removed after this interval.\n     * Default: disabled\n     */\n    readonly resourcesWithoutUserExpireAfterMs?: number;\n    /**\n     * Maximum number of users per resource. Defaults to 1\n     */\n    readonly capacityPerResource?: number;\n    /**\n     * What to do if pool is full and a new resource allocation is requested.\n     * Default is `error`, throwing an error when pool is full.\n     */\n    readonly fullPolicy?: FullPolicy;\n    /**\n     * If true, additional logging will trace activity of pool.\n     * Default: false\n     */\n    readonly debug?: boolean;\n    /**\n     * If specified, this function will generate new resources as needed.\n     */\n    readonly generate?: () => V;\n    /**\n     * If specified, this function will be called when a resource is disposed\n     */\n    readonly free?: (v: V) => void;\n};\n/**\n * Function that initialises a pool item\n */\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\nexport type PoolUserEventMap<V> = {\n    readonly disposed: {\n        readonly data: V;\n        readonly reason: string;\n    };\n    readonly released: {\n        readonly data: V;\n        readonly reason: string;\n    };\n};\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport declare class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n    readonly key: string;\n    readonly resource: Resource<V>;\n    private _lastUpdate;\n    private _pool;\n    private _state;\n    private _userExpireAfterMs;\n    /**\n     * Constructor\n     * @param key User key\n     * @param resource Resource being used\n     */\n    constructor(key: string, resource: Resource<V>);\n    /**\n     * Returns a human readable debug string\n     * @returns\n     */\n    toString(): string;\n    /**\n     * Resets countdown for instance expiry.\n     * Throws an error if instance is disposed.\n     */\n    keepAlive(): void;\n    /**\n     * @internal\n     * @param reason\n     * @returns\n     */\n    _dispose(reason: string, data: V): void;\n    /**\n     * Release this instance\n     * @param reason\n     */\n    release(reason: string): void;\n    get data(): V;\n    /**\n     * Returns true if this instance has expired.\n     * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n     */\n    get isExpired(): boolean;\n    /**\n     * Returns elapsed time since last 'update'\n     */\n    get elapsed(): number;\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed(): boolean;\n    /**\n     * Returns true if instance is neither disposed nor expired\n     */\n    get isValid(): boolean;\n}\n/**\n * A resource allocated in the Pool\n */\nexport declare class Resource<V> {\n    #private;\n    readonly pool: Pool<V>;\n    /**\n     * Constructor.\n     * @param pool Pool\n     * @param data Data\n     */\n    constructor(pool: Pool<V>, data: V);\n    /**\n     * Gets data associated with resource.\n     * Throws an error if disposed\n     */\n    get data(): V;\n    /**\n     * Changes the data associated with this resource.\n     * Throws an error if disposed or `data` is undefined.\n     * @param data\n     */\n    updateData(data: V): void;\n    /**\n     * Returns a human-readable debug string for resource\n     * @returns\n     */\n    toString(): string;\n    /**\n     * Assigns a user to this resource.\n     * @internal\n     * @param user\n     */\n    _assign(user: PoolUser<V>): void;\n    /**\n     * Releases a user from this resource\n     * @internal\n     * @param user\n     */\n    _release(user: PoolUser<V>): void;\n    /**\n     * Returns true if resource can have additional users allocated\n     */\n    get hasUserCapacity(): boolean;\n    /**\n     * Returns number of uses of the resource\n     */\n    get usersCount(): number;\n    /**\n     * Returns true if automatic expiry is enabled, and that interval\n     * has elapsed since the users list has changed for this resource\n     */\n    get isExpiredFromUsers(): boolean;\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed(): boolean;\n    /**\n     * Disposes the resource.\n     * If it is already disposed, it does nothing.\n     * @param reason\n     * @returns\n     */\n    dispose(reason: string): void;\n}\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'.\n * All resources in the Pool are meant to be the same kind of object.\n *\n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n *\n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n *\n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport declare class Pool<V> {\n    #private;\n    private _resources;\n    private _users;\n    readonly capacity: number;\n    readonly userExpireAfterMs: number;\n    readonly resourcesWithoutUserExpireAfterMs: number;\n    readonly capacityPerResource: number;\n    readonly fullPolicy: FullPolicy;\n    private generateResource?;\n    readonly freeResource?: (v: V) => void;\n    readonly log: Debug.LogSet;\n    /**\n     * Constructor.\n     *\n     * By default, no capacity limit, one user per resource\n     * @param options Pool options\n     */\n    constructor(options?: PoolOptions<V>);\n    /**\n     * Returns a debug string of Pool state\n     * @returns\n     */\n    dumpToString(): string;\n    /**\n     * Sorts users by longest elapsed time since update\n     * @returns\n     */\n    getUsersByLongestElapsed(): PoolUser<V>[];\n    /**\n     * Returns resources sorted with least used first\n     * @returns\n     */\n    getResourcesSortedByUse(): Resource<V>[];\n    /**\n     * Adds a shared resource to the pool\n     * @throws Error if the capacity limit is reached or resource is null\n     * @param resource\n     * @returns\n     */\n    addResource(resource: V): Resource<V>;\n    /**\n     * Performs maintenance, removing disposed/expired resources & users.\n     * This is called automatically when using a resource.\n     */\n    maintain(): void;\n    /**\n     * Iterate over resources in the pool.\n     * To iterate over the data associated with each resource, use\n     * `values`.\n     */\n    resources(): Generator<Resource<V>, void, unknown>;\n    /**\n     * Iterate over resource values in the pool.\n     * to iterate over the resources, use `resources`.\n     *\n     * Note that values may be returned even though there is no\n     * active user.\n     */\n    values(): Generator<V, void, unknown>;\n    /**\n     * Unassociate a key with a pool item\n     * @param userKey\n     */\n    release(userKey: string, reason?: string): void;\n    /**\n     * @internal\n     * @param user\n     */\n    _release(user: PoolUser<V>): void;\n    /**\n     * @internal\n     * @param resource\n     * @param _\n     */\n    _releaseResource(resource: Resource<V>, _: string): void;\n    /**\n     * Returns true if `v` has an associted resource in the pool\n     * @param resource\n     * @returns\n     */\n    hasResource(resource: V): boolean;\n    /**\n     * Returns true if a given `userKey` is in use.\n     * @param userKey\n     * @returns\n     */\n    hasUser(userKey: string): boolean;\n    /**\n     * @internal\n     * @param key\n     * @param resource\n     * @returns\n     */\n    private _assign;\n    /**\n     * Return the number of users\n     */\n    get usersLength(): number;\n    /**\n     * 'Uses' a resource, returning the value\n     * @param userKey\n     * @returns\n     */\n    useValue(userKey: string): V;\n    /**\n     * Gets a pool item based on a 'user' key.\n     *\n     * The same key should return the same pool item,\n     * for as long as it still exists.\n     *\n     * If a 'user' already has a resource, it will 'keep alive' their use.\n     * If a 'user' does not already have resource\n     *  - if there is capacity, a resource is allocated to user\n     *  - if pool is full\n     *    - fullPolicy = 'error': an error is thrown\n     *    - fullPolicy = 'evictOldestUser': evicts an older user\n     *    - Throw error\n     * @param userKey\n     * @throws Error If all resources are used and fullPolicy = 'error'\n     * @returns\n     */\n    use(userKey: string): PoolUser<V>;\n}\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport declare const create: <V>(options?: PoolOptions<V>) => Pool<V>;\n//# sourceMappingURL=pool.d.ts.map","/**\n * Creates a new Promise, returning the promise\n * along with its resolve and reject functions.\n *\n * ```js\n * const { promise, resolve, reject } = promiseWithResolvers();\n *\n * setTimeout(() => {\n *  resolve();\n * }, 1000);\n *\n * await promise;\n * ```\n *\n * Promise would be passed somewhere that expects a promise,\n * and you're free to call `resolve` or `reject` when needed.\n * @returns\n */\nexport declare function promiseWithResolvers<T>(): {\n    promise: Promise<T>;\n    resolve: (value: T) => void;\n    reject: (reason: any) => void;\n};\n//# sourceMappingURL=promise-with-resolvers.d.ts.map","import type { Interval } from \"@ixfx/core\";\nexport type RateMinimumOptions<TInput> = Readonly<{\n    whatToCall: (args: TInput) => void;\n    fallback: () => TInput;\n    interval: Interval;\n    abort?: AbortSignal;\n}>;\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n *\n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n *\n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n *\n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ```\n *\n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n *\n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n *\n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n *\n * @param options\n * @returns\n */\nexport declare const rateMinimum: <TInput>(options: RateMinimumOptions<TInput>) => (args: TInput) => void;\n//# sourceMappingURL=rate-minimum.d.ts.map","import type { BasicType } from '@ixfx/core';\nimport { type ResolveToValue, type ResolveToValueSync } from '@ixfx/core';\nimport { type Interval } from '@ixfx/core';\nexport type RepeatDelayOpts = RepeatOpts & Readonly<Partial<{\n    /**\n   * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n   */\n    delay: Interval;\n    /**\n     * Minimum interval. That is, only sleep if there is time left over after 'produce'\n     * is invoked.\n     */\n    delayMinimum: Interval;\n    /**\n   * When to perform delay. Default is before 'produce' is invoked.\n   * Default: 'before'\n   */\n    delayWhen: `before` | `after` | `both`;\n}>>;\n/**\n * Options for repeat\n */\nexport type RepeatOpts = Partial<Readonly<{\n    /**\n     * If specified, repeating stops if this function returns false\n     * @param count\n     * @returns\n     */\n    while: (count: number) => boolean;\n    /**\n     * By default, if the callback returns\n     * _undefined_ the repeating exits. Set this to _true_ to\n     * ignore undefined values\n     * @default false\n     */\n    allowUndefined: boolean;\n    /**\n     * Optional signal to abort\n     */\n    signal: AbortSignal;\n    /**\n     * Maximum times to repeat (default: no limit)\n     */\n    count: number;\n    /**\n     * Function to call when initialising\n     * @returns\n     */\n    onStart: () => void;\n    /**\n     * Function to call when done (or an error occurs)\n     * @returns\n     */\n    onComplete: (withError: boolean) => void;\n}>>;\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport declare function repeat<T extends BasicType>(produce: ResolveToValue<T> | ArrayLike<T>, opts: RepeatDelayOpts): AsyncGenerator<T>;\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport declare function repeatSync<T extends BasicType>(produce: ResolveToValueSync<T> | ArrayLike<T>, opts: RepeatOpts): Generator<T, void, unknown>;\n/**\n * Logic for continuing repeats\n */\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n//# sourceMappingURL=repeat.d.ts.map","import { SimpleEventEmitter } from \"@ixfx/events\";\nexport type RequestResponseOptions<TRequest, TResp> = {\n    timeoutMs: number;\n    key: (requestOrResp: TRequest | TResp) => string;\n    keyRequest: (request: TRequest) => string;\n    keyResponse: (resp: TResp) => string;\n    whenUnmatchedResponse: `ignore` | `throw`;\n};\nexport type RequestResponseMatchEvents<TRequest, TResp> = {\n    match: {\n        request: TRequest;\n        response: TResp;\n    };\n    completed: {\n        request: TRequest;\n        response: TResp | string;\n        success: boolean;\n    };\n};\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n *\n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n *\n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n *\n *\n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id;\n *  }\n * });\n * ```\n *\n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id;\n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n *\n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport declare class RequestResponseMatch<TRequest, TResp> extends SimpleEventEmitter<RequestResponseMatchEvents<TRequest, TResp>> {\n    #private;\n    timeoutMs: any;\n    whenUnmatchedResponse: any;\n    keyRequest: any;\n    keyResponse: any;\n    constructor(options?: Partial<RequestResponseOptions<TRequest, TResp>>);\n    debugDump(): void;\n    /**\n     * Make a request and get the outcome via a Promise\n     * @param request\n     */\n    request(request: TRequest): Promise<TResp>;\n    /**\n     * Makes a request with a callback for the outcome\n     * @param request\n     * @param callback\n     */\n    request(request: TRequest, callback: (error: boolean, response: TResp | string) => void): void;\n    /**\n     * Make a request and don't wait for the outcome.\n     * @param request\n     */\n    requestAndForget(request: TRequest): void;\n    /**\n     * Response has been received\n     * @param response Response\n     * @returns _True_ if response matched a request\n     */\n    response(response: TResp, keepAlive: boolean): boolean;\n}\n//# sourceMappingURL=req-resp-match.d.ts.map","import type { Result } from '@ixfx/guards';\n/**\n * Result of backoff\n */\nexport type RetryResult<V> = {\n    /**\n     * Message describing outcome.\n     *\n     * If retry was aborted, message will be abort reason.\n     */\n    readonly message?: string;\n    /**\n     * True if callback function was invoked once where it returned _true_\n     */\n    readonly success: boolean;\n    /**\n     * Number of times callback was attempted\n     */\n    readonly attempts: number;\n    /**\n     * Total elapsed time since beginning of call to `retry`\n     */\n    readonly elapsed: number;\n    /**\n     * Value returned by succeeding function,\n     * or _undefined_ if it failed\n     */\n    readonly value: V | undefined;\n};\nexport type BackoffOptions = {\n    /**\n     * Initial value.\n     * Default: 1\n     */\n    startAt: number;\n    /**\n     * Maximum times to run.\n     * Default: continues forever\n     */\n    limitAttempts: number;\n    /**\n     * Stop retrying if this maximum is reached\n     * Default: no limit\n     */\n    limitValue: number;\n    /**\n     * Math power.\n     * Default: 1.1\n     */\n    power: number;\n};\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n *\n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n *\n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n *\n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n *\n * @param options\n * @returns\n */\nexport declare function backoffGenerator(options?: Partial<BackoffOptions>): Generator<number, void, unknown>;\n/**\n * Backoff options\n */\nexport type RetryOpts<T> = BackoffOptions & {\n    /**\n     * Initial waiting period before first attempt (optional)\n     */\n    readonly predelayMs: number;\n    /**\n     * Optional abort signal\n     */\n    readonly abort: AbortSignal;\n    /**\n     * Log: _true_ monitors the task execution by logging to console\n     */\n    readonly log: boolean;\n    /***\n     * Default task value to return if it fails\n     */\n    readonly taskValueFallback: T;\n};\nexport type RetryTask<T> = {\n    /**\n     * If `probe` returns {success:true} task is considered\n     * complete and retrying stops\n     * @returns\n     */\n    probe: (attempts: number) => Promise<Result<T, any>>;\n};\n/**\n * Keeps calling `callback` until it returns something other than _undefined_.\n * There is an exponentially-increasing delay between each retry attempt.\n *\n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport declare const retryFunction: <T>(callback: () => Promise<T | undefined>, options?: Partial<RetryOpts<T>>) => Promise<RetryResult<T>>;\n/**\n * Keeps trying to run `task`.\n *\n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *\n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n *\n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task\n * @param opts\n * @returns\n */\nexport declare const retryTask: <V>(task: RetryTask<V>, opts?: Partial<RetryOpts<V>>) => Promise<RetryResult<V>>;\n//# sourceMappingURL=retry.d.ts.map","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport declare const runOnce: (onRun: () => boolean) => (() => boolean);\n//# sourceMappingURL=run-once.d.ts.map","/**\n * Simple synchronisation. Supports only a single signal/waiter.\n * Expects one or more calls to .signal() for .forSignal() to resolve\n *\n * ```js\n * const sw = new SyncWait();\n * obj.addEventListener(`click`, () => {\n *  sw.signal();\n * });\n *\n * // Wait until click event\n * await sw.forSignal();\n * ```\n *\n * `forSignal` can also take a maximum time to wait. If the\n * time elapses, an exception is thrown.\n *\n * {@link didSignal} returns _true_/_false_ if signal happened rather\n * than throwing an exception.\n *\n */\nexport declare class SyncWait {\n    #private;\n    signal(): void;\n    /**\n     * Throw away any previous signalled state.\n     * This will cause any currently waiters to throw\n     */\n    flush(): void;\n    /**\n     * Call with `await` to wait until .signal() happens.\n     * If a wait period is specified, an exception is thrown if signal does not happen within this time.\n     * @param maximumWaitMs\n     */\n    forSignal(maximumWaitMs?: number): Promise<void>;\n    /**\n     * An alternative to {@link forSignal}, returning _true_\n     * if signalled, or _false_ if wait period was exceeded\n     *\n     * ```js\n     * const s = await sw.didSignal(5000);\n     * ```\n     * @param maximumWaitMs\n     * @returns\n     */\n    didSignal(maximumWaitMs: number): Promise<boolean>;\n}\n//# sourceMappingURL=sync-wait.d.ts.map","import { SimpleEventEmitter } from '@ixfx/events';\nexport type AsyncTask = () => Promise<void>;\nexport type TaskQueueEvents = {\n    /**\n     * Task queue has emptied.\n     * @returns\n     */\n    empty: any;\n    /**\n     * Task queue was empty and now processing\n     * @returns\n     */\n    started: any;\n};\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n *\n * The TaskQueueMutable is shared across your code,\n * so you don't create it directly. Rather, use:\n *\n * ```js\n * const queue = TaskQueueMutable.shared;\n * ```\n *\n * @example Usage\n * ```js\n * const queue = TaskQueueMutable.shared;\n * q.enqueue(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n *\n * You can listen to events from the TaskQueue:\n * ```js\n * TaskQueueMutable.shared.addEventListener(`started`, () => {\n *  // Queue was empty, now started processing\n * });\n *\n * TaskQueueMutable.shared.addEventListener(`empty`, () => {\n *  // Queue has finished processing all items\n * });\n * ```\n */\nexport declare class TaskQueueMutable extends SimpleEventEmitter<TaskQueueEvents> {\n    static readonly shared: TaskQueueMutable;\n    private _loop;\n    private _queue;\n    private constructor();\n    /**\n     * Adds a task. This triggers processing loop if not already started.\n     *\n     * ```js\n     * queue.add(async () => {\n     *  await sleep(1000);\n     * });\n     * ```\n     * @param task Task to run\n     */\n    enqueue(task: () => Promise<void>): any;\n    dequeue(): any;\n    private processQueue;\n    /**\n     * Clears all tasks, and stops any scheduled processing.\n     * Currently running tasks will continue.\n     * @returns\n     */\n    clear(): void;\n    /**\n    * Returns true if queue is empty\n    */\n    get isEmpty(): any;\n    /**\n     * Number of items in queue\n     */\n    get length(): any;\n}\n//# sourceMappingURL=task-queue-mutable.d.ts.map","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport declare const throttle: (callback: (elapsedMs: number, ...args: readonly unknown[]) => void | Promise<unknown>, intervalMinMs: number) => (...args: unknown[]) => Promise<void>;\n//# sourceMappingURL=throttle.d.ts.map","import { type HasCompletion, type Interval } from '@ixfx/core';\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n *\n * Implementations: {@link elapsedMillisecondsAbsolute}, {@link elapsedTicksAbsolute}, {@link frequencyTimer}\n */\nexport type Timer = {\n    reset(): void;\n    get elapsed(): number;\n};\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relative}\n */\nexport type CompletionTimer = Timer & {\n    /**\n     * Returns _true_ if this timer has completed.\n     */\n    get isDone(): boolean;\n};\nexport type ModulationTimer = CompletionTimer & {\n    mod(amt: number): void;\n};\nexport type TimerOpts = {\n    /**\n     * Timer to use. By default {@link elapsedMillisecondsAbsolute}.\n     */\n    readonly timer: Timer;\n};\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n    /**\n     * If true, returned value will be clamped to 0..1. False by default\n     */\n    readonly clampValue: boolean;\n    readonly wrapValue: boolean;\n};\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n *\n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n *\n * @param elapsed\n * @returns\n */\nexport declare function hasElapsed(elapsed: Interval): () => boolean;\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * const timer = Flow.ofTotal(1000);\n *\n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n *\n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport declare function ofTotal(duration: Interval, opts?: {\n    readonly clampValue?: boolean;\n    readonly wrapValue?: boolean;\n}): () => number;\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport declare function ofTotalTicks(totalTicks: number, opts?: {\n    readonly clampValue?: boolean;\n    readonly wrapValue?: boolean;\n}): () => number;\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns\n */\nexport declare const timerAlwaysDone: () => ModulationTimer;\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns\n */\nexport declare const timerNeverDone: () => ModulationTimer;\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n *\n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n *\n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n *\n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport declare const relative: (total: number, options?: Partial<RelativeTimerOpts>) => ModulationTimer;\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport declare const frequencyTimer: (frequency: number, options?: Partial<TimerOpts>) => ModulationTimer;\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport declare const elapsedMillisecondsAbsolute: () => Timer;\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n *\n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport declare const elapsedTicksAbsolute: () => Timer & {\n    peek: number;\n};\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n *\n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n *\n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n *\n * @param fn\n * @param timer\n * @returns\n */\nexport declare const timerWithFunction: (fn: ((v: number) => number), timer: CompletionTimer) => HasCompletion & CompletionTimer & {\n    compute: () => number;\n};\n//# sourceMappingURL=timer.d.ts.map","export type AsyncPromiseOrGenerator<V> = (() => Promise<V> | Promise<undefined>) | (() => V | undefined) | Generator<V> | IterableIterator<V> | AsyncIterableIterator<V> | AsyncGenerator<V> | AsyncIterable<V> | Iterable<V>;\n//# sourceMappingURL=types.d.ts.map","import { type Interval } from \"@ixfx/core\";\nexport type UpdateFailPolicy = `fast` | `slow` | `backoff`;\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `interval` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. Its minimum value will be `interval`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `interval` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param interval Maximum age of cached result\n * @param updateFail `slow` by default\n * @typeParam V - Return type of `fn`\n * @returns Value\n */\nexport declare const updateOutdated: <V>(fn: (elapsedMs?: number) => Promise<V>, interval: Interval, updateFail?: UpdateFailPolicy) => (() => Promise<V>);\n//# sourceMappingURL=update-outdated.d.ts.map","/**\n * Queue of a single item, only once, allows for simple synchronisation.\n *\n * It has a 'first write wins' behaviour\n *\n * ```js\n * const q = new WaitForValue(); // or singleItem();\n *\n * // In some part of the code add a value\n * const value = q.add(`some-val`);\n *\n * // Somewhere else, wait for value\n * await q.get(value);\n * ```\n *\n * It is not possible to `add` a second item (an exception will throw), however\n * it is possible to call `get` as many times as you need.\n *\n * The `.isUsed` property allows you to to check if a value\n * has been already added to the queue.\n *\n * Based on: https://2ality.com/2024/05/proposal-promise-with-resolvers.html\n */\nexport declare class WaitForValue<T> {\n    #private;\n    constructor();\n    /**\n     * Gets the promise\n     * ```js\n     * const wv = new WaitForValue();\n     *\n     * await wv.get();\n     * ```\n     * @returns\n     */\n    get(): Promise<T>;\n    /**\n     * Adds a value, triggering promise resolution.\n     *\n     * Throws an exception if queue has already been used. Use {@link isUsed} to check.\n     * @param value\n     */\n    add(value: T): void;\n    /**\n     * Returns _true_ if a value has been added\n     * and therefore no more values can be written\n     */\n    get isUsed(): boolean;\n}\n/**\n * {@inheritDoc WaitForValue}\n */\nexport declare const singleItem: <T>() => WaitForValue<T>;\n//# sourceMappingURL=wait-for-value.d.ts.map","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n *\n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n *\n * ```js\n * waitFor(1000,\n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n *\n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n *\n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n *\n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport declare const waitFor: (timeoutMs: number, onAborted: (reason: string) => void, onComplete?: (success: boolean) => void) => (error?: string) => void;\n//# sourceMappingURL=wait-for.d.ts.map","export * from '@ixfx/core/continuously';\nexport * from './behaviour-tree.js';\nexport * from './delay.js';\nexport * from './debounce.js';\nexport * from './dispatch-list.js';\nexport * from './every.js';\nexport * from './execute.js';\nexport * from './event-race.js';\nexport * from './moving-average.js';\nexport * from './pool.js';\nexport * from './promise-with-resolvers.js';\nexport * from './rate-minimum.js';\nexport * from './repeat.js';\nexport * from './req-resp-match.js';\nexport * from './retry.js';\nexport * from './run-once.js';\nexport * from './sync-wait.js';\nexport * from './task-queue-mutable.js';\nexport * from './throttle.js';\nexport * from './timeout.js';\nexport * from './timer.js';\nexport * from './types.js';\nexport * from './update-outdated.js';\nexport * from './wait-for-value.js';\nexport * from './wait-for.js';\nexport { sleep } from '@ixfx/core';\n/**\n * Functions for creating and driving a state machine\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n */\nexport * as StateMachine from './state-machine/index.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}