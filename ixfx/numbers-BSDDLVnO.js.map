{"version":3,"file":"numbers-BSDDLVnO.js","names":["test: GuardResultFail | GuardResultOk","value?: unknown","range: NumberGuardRange","value: number","value: number | undefined","min: number","max: number"],"sources":["../../packages/guards/src/throw-from-result.ts","../../packages/guards/src/numbers.ts"],"sourcesContent":["import type { GuardResultFail, GuardResultOk } from \"./types.js\";\n\nexport const throwFromResult = (test: GuardResultFail | GuardResultOk) => {\n  if (test[ 0 ]) return false;\n  else throw new Error(test[ 1 ]);\n}","import { throwFromResult } from \"./throw-from-result.js\";\nimport type { GuardResult, NumberGuardRange } from \"./types.js\";\n\n/**\n * Returns true if `x` is a power of two\n * @param x\n * @returns True if `x` is a power of two\n */\nexport const isPowerOfTwo = (x: number) => Math.log2(x) % 1 === 0;\n\n\n/**\n * Returns `fallback` if `v` is NaN, otherwise returns `v`.\n *\n * Throws if `v` is not a number type.\n * @param v\n * @param fallback\n * @returns\n */\nexport const ifNaN = (v: number, fallback: number): number => {\n  // ✔️ Unit tested\n\n  if (Number.isNaN(v)) return fallback;\n  if (typeof v !== `number`) {\n    throw new TypeError(`v is not a number. Got: ${ typeof v }`);\n  }\n  return v;\n};\n\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n *\n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n *\n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n *\n * @param value\n * @param range\n * @param defaultValue\n * @returns\n */\nexport const integerParse = (\n  value: string | number | null,\n  range: NumberGuardRange = ``,\n  defaultValue: number = Number.NaN\n): number => {\n  if (typeof value === `undefined`) return defaultValue;\n  if (value === null) return defaultValue;\n  try {\n    const parsed = Number.parseInt(typeof value === `number` ? value.toString() : value);\n    const r = integerTest(parsed, range, `parsed`);\n    return r[ 0 ] ? parsed : defaultValue;\n  } catch {\n    return defaultValue;\n  }\n};\n\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Returns `[false, reason:string]` if invalid or `[true]` if valid.\n * Use {@link throwNumberTest} to throw an error rather than return result.\n * \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n *\n * * (empty, default): must be a number type and not NaN.\n * * finite: must be a number, not NaN and not infinite\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param parameterName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns\n */\nexport const numberTest = (\n  value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`,\n): GuardResult => {\n  if (value === null) return [ false, `Parameter '${ parameterName }' is null` ];\n  if (typeof value === `undefined`) {\n    return [ false, `Parameter '${ parameterName }' is undefined` ];\n  }\n  if (Number.isNaN(value)) {\n    return [ false, `Parameter '${ parameterName }' is NaN` ];\n  }\n  if (typeof value !== `number`) {\n    return [ false, `Parameter '${ parameterName }' is not a number (${ JSON.stringify(value) })` ];\n  }\n  switch (range) {\n    case `finite`: {\n      if (!Number.isFinite(value)) {\n        return [ false, `Parameter '${ parameterName } must be finite (Got: ${ value })` ];\n      }\n      break;\n    }\n    case `positive`: {\n      if (value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be at least zero (${ value })` ];\n      }\n      break;\n    } case `negative`: {\n      if (value > 0) {\n        return [ false, `Parameter '${ parameterName }' must be zero or lower (${ value })` ];\n      }\n      break;\n    }\n    case `aboveZero`: {\n      if (value <= 0) {\n        return [ false, `Parameter '${ parameterName }' must be above zero (${ value })` ]\n\n      }\n      break;\n    }\n    case `belowZero`: {\n      if (value >= 0) {\n        return [ false, `Parameter '${ parameterName }' must be below zero (${ value })` ];\n      }\n      break;\n    }\n    case `percentage`: {\n      if (value > 1 || value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be in percentage range (0 to 1). (${ value })` ]\n      }\n      break;\n    }\n    case `nonZero`: {\n      if (value === 0) {\n        return [ false, `Parameter '${ parameterName }' must non-zero. (${ value })` ];\n      }\n      break;\n    }\n    case `bipolar`: {\n      if (value > 1 || value < -1) {\n        return [ false, `Parameter '${ parameterName }' must be in bipolar percentage range (-1 to 1). (${ value })` ];\n      }\n      break;\n    }\n  }\n  return [ true ];\n};\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Throws if invalid. Use {@link numberTest} to test without throwing.\n *\n* * (empty, default): must be a number type and not NaN.\n* * positive: must be at least zero\n* * negative: must be zero or lower\n* * aboveZero: must be above zero\n* * belowZero: must be below zero\n* * percentage: must be within 0-1, inclusive\n* * nonZero: can be anything except zero\n* * bipolar: can be -1 to 1, inclusive\n* \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n * @param value Value to test\n * @param range Range\n * @param parameterName Name of parameter \n */\nexport const throwNumberTest = (value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(numberTest(value, range, parameterName));\n}\n\n/**\n * Returns test of `value` being in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n *\n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @returns\n */\nexport const percentTest = (value: number, parameterName = `?`): GuardResult =>\n  numberTest(value, `percentage`, parameterName);\n\nexport const throwPercentTest = (value: number, parameterName = `?`) => {\n  throwFromResult(percentTest(value, parameterName));\n}\n/**\n * Checks if `value` an integer and meets additional criteria.\n * See {@link numberTest} for guard details, or use that if integer checking is not required.\n *\n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integerTest = (\n  value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`\n): GuardResult => {\n  // ✔️ Unit tested\n  const r = numberTest(value, range, parameterName);\n  if (!r[ 0 ]) return r;\n  if (!Number.isInteger(value)) {\n    return [ false, `Param '${ parameterName }' is not an integer` ];\n  }\n  return [ true ];\n};\n\nexport const integerArrayTest = (numbers: Iterable<number>): GuardResult => {\n  for (const v of numbers) {\n    if (Math.abs(v) % 1 !== 0) return [ false, `Value is not an integer: ${ v }` ];\n  }\n  return [ true ];\n};\n\n/**\n * Returns _true_ if `value` is an integer in number or string form\n * @param value \n * @returns \n */\nexport const isInteger = (value: number | string): boolean => {\n  if (typeof value === `string`) value = Number.parseFloat(value);\n  const r = integerTest(value);\n  return r[ 0 ];\n}\n\nexport const throwIntegerTest = (value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(integerTest(value, range, parameterName));\n}\n\nexport const numberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`): GuardResult => {\n  if (typeof value !== `number`) {\n    return [ false, `Param '${ parameterName }' is not a number type. Got type: '${ typeof value }' value: '${ JSON.stringify(value) }'` ];\n  }\n  if (Number.isNaN(value)) {\n    return [ false, `Param '${ parameterName }' is not within range ${ min }-${ max }. Got: NaN` ];\n  }\n  if (Number.isFinite(value)) {\n    if (value < min) {\n      return [ false, `Param '${ parameterName }' is below range ${ min }-${ max }. Got: ${ value }` ];\n    } else if (value > max) {\n      return [ false, `Param '${ parameterName }' is above range ${ min }-${ max }. Got: ${ value }` ];\n    }\n    return [ true ];\n  } else {\n    return [ false, `Param '${ parameterName }' is not within range ${ min }-${ max }. Got: infinite` ];\n  }\n}\n\nexport const throwNumberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`) => {\n  const r = numberInclusiveRangeTest(value, min, max, parameterName);\n  if (r[ 0 ]) return;\n  throw new Error(r[ 1 ]);\n}"],"mappings":"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"}