{"version":3,"file":"simple-event-emitter-DFseJGjf.js","names":["test: GuardResultFail | GuardResultOk","value?: unknown","range: NumberGuardRange","value: number","value: number | undefined","min: number","max: number","value: unknown","array: ArrayLike<V>","index: number","itemToMakeStringFor: V","a: T","b: T","isEqualContextString: IsEqualContext<unknown>","a: unknown","b: unknown","_path: string","value: number","v: number","arrayOrLength: number | readonly any[]","map: ReadonlyMap<string, V>","predicate: (v: V) => boolean","keys: readonly string[]","values: ArrayLike<V | undefined>","map: IDictionary<K, V>","fn: (key: K, args?: Z) => Promise<V> | V","key: K","args?: Z","creator: (key: string, start: V | undefined) => T","id: string","opts: TrackedValueOpts","opts: TrackedValueOpts","reason: TrimReason","limit: number","p: Array<V> | Array<TimestampedObject<V>>","key: string","#store","value: T","#listeners","#disposed","type: K","args: Events[ K ]","name: K","listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void"],"sources":["../../packages/guards/src/throw-from-result.ts","../../packages/guards/src/numbers.ts","../../packages/guards/src/arrays.ts","../../packages/core/src/to-string.ts","../../packages/core/src/is-equal.ts","../../packages/numbers/src/clamp.ts","../../packages/core/src/maps.ts","../../packages/core/src/trackers/tracked-value.ts","../../packages/core/src/trackers/tracker-base.ts","../../packages/core/src/trackers/object-tracker.ts","../../packages/events/src/map-of.ts","../../packages/events/src/simple-event-emitter.ts"],"sourcesContent":["import type { GuardResultFail, GuardResultOk } from \"./types.js\";\n\nexport const throwFromResult = (test: GuardResultFail | GuardResultOk) => {\n  if (test[ 0 ]) return false;\n  else throw new Error(test[ 1 ]);\n}","import { throwFromResult } from \"./throw-from-result.js\";\nimport type { GuardResult, NumberGuardRange } from \"./types.js\";\n\n/**\n * Returns true if `x` is a power of two\n * @param x\n * @returns True if `x` is a power of two\n */\nexport const isPowerOfTwo = (x: number) => Math.log2(x) % 1 === 0;\n\n\n/**\n * Returns `fallback` if `v` is NaN, otherwise returns `v`.\n *\n * Throws if `v` is not a number type.\n * @param v\n * @param fallback\n * @returns\n */\nexport const ifNaN = (v: number, fallback: number): number => {\n  // ✔️ Unit tested\n\n  if (Number.isNaN(v)) return fallback;\n  if (typeof v !== `number`) {\n    throw new TypeError(`v is not a number. Got: ${ typeof v }`);\n  }\n  return v;\n};\n\n/**\n * Parses `value` as an integer, returning it if it meets the `range` criteria.\n * If not, `defaultValue` is returned.\n *\n * ```js\n * const i = integerParse('10', 'positive');    // 10\n * const i = integerParse('10.5', 'positive');  // 10\n * const i = integerParse('0', 'nonZero', 100); // 100\n * ```\n *\n * NaN is returned if criteria does not match and no default is given\n * ```js\n * const i = integerParse('10', 'negative');    // NaN\n * ```\n *\n * @param value\n * @param range\n * @param defaultValue\n * @returns\n */\nexport const integerParse = (\n  value: string | number | null,\n  range: NumberGuardRange = ``,\n  defaultValue: number = Number.NaN\n): number => {\n  if (typeof value === `undefined`) return defaultValue;\n  if (value === null) return defaultValue;\n  try {\n    const parsed = Number.parseInt(typeof value === `number` ? value.toString() : value);\n    const r = integerTest(parsed, range, `parsed`);\n    return r[ 0 ] ? parsed : defaultValue;\n  } catch {\n    return defaultValue;\n  }\n};\n\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Returns `[false, reason:string]` if invalid or `[true]` if valid.\n * Use {@link throwNumberTest} to throw an error rather than return result.\n * \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n *\n * * (empty, default): must be a number type and not NaN.\n * * finite: must be a number, not NaN and not infinite\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * * bipolar: can be -1 to 1, inclusive\n * @param value Value to check\n * @param parameterName Name of parameter (for more helpful exception messages)\n * @param range Range to enforce\n * @returns\n */\nexport const numberTest = (\n  value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`,\n): GuardResult => {\n  if (value === null) return [ false, `Parameter '${ parameterName }' is null` ];\n  if (typeof value === `undefined`) {\n    return [ false, `Parameter '${ parameterName }' is undefined` ];\n  }\n  if (Number.isNaN(value)) {\n    return [ false, `Parameter '${ parameterName }' is NaN` ];\n  }\n  if (typeof value !== `number`) {\n    return [ false, `Parameter '${ parameterName }' is not a number (${ JSON.stringify(value) })` ];\n  }\n  switch (range) {\n    case `finite`: {\n      if (!Number.isFinite(value)) {\n        return [ false, `Parameter '${ parameterName } must be finite (Got: ${ value })` ];\n      }\n      break;\n    }\n    case `positive`: {\n      if (value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be at least zero (${ value })` ];\n      }\n      break;\n    } case `negative`: {\n      if (value > 0) {\n        return [ false, `Parameter '${ parameterName }' must be zero or lower (${ value })` ];\n      }\n      break;\n    }\n    case `aboveZero`: {\n      if (value <= 0) {\n        return [ false, `Parameter '${ parameterName }' must be above zero (${ value })` ]\n\n      }\n      break;\n    }\n    case `belowZero`: {\n      if (value >= 0) {\n        return [ false, `Parameter '${ parameterName }' must be below zero (${ value })` ];\n      }\n      break;\n    }\n    case `percentage`: {\n      if (value > 1 || value < 0) {\n        return [ false, `Parameter '${ parameterName }' must be in percentage range (0 to 1). (${ value })` ]\n      }\n      break;\n    }\n    case `nonZero`: {\n      if (value === 0) {\n        return [ false, `Parameter '${ parameterName }' must non-zero. (${ value })` ];\n      }\n      break;\n    }\n    case `bipolar`: {\n      if (value > 1 || value < -1) {\n        return [ false, `Parameter '${ parameterName }' must be in bipolar percentage range (-1 to 1). (${ value })` ];\n      }\n      break;\n    }\n  }\n  return [ true ];\n};\n\n/**\n * Checks if `t` is not a number or within specified range.\n * Throws if invalid. Use {@link numberTest} to test without throwing.\n *\n* * (empty, default): must be a number type and not NaN.\n* * positive: must be at least zero\n* * negative: must be zero or lower\n* * aboveZero: must be above zero\n* * belowZero: must be below zero\n* * percentage: must be within 0-1, inclusive\n* * nonZero: can be anything except zero\n* * bipolar: can be -1 to 1, inclusive\n* \n * Alternatives: {@link integerTest} for additional integer check, {@link percentTest} for percentage-range.\n * @param value Value to test\n * @param range Range\n * @param parameterName Name of parameter \n */\nexport const throwNumberTest = (value?: unknown,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(numberTest(value, range, parameterName));\n}\n\n/**\n * Returns test of `value` being in the range of 0-1.\n * Equiv to `number(value, `percentage`);`\n *\n * This is the same as calling ```number(t, `percentage`)```\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @returns\n */\nexport const percentTest = (value: number, parameterName = `?`): GuardResult =>\n  numberTest(value, `percentage`, parameterName);\n\nexport const throwPercentTest = (value: number, parameterName = `?`) => {\n  throwFromResult(percentTest(value, parameterName));\n}\n/**\n * Checks if `value` an integer and meets additional criteria.\n * See {@link numberTest} for guard details, or use that if integer checking is not required.\n *\n * Note:\n * * `bipolar` will mean -1, 0 or 1.\n * * positive: must be at least zero\n * * negative: must be zero or lower\n * * aboveZero: must be above zero\n * * belowZero: must be below zero\n * * percentage: must be within 0-1, inclusive\n * * nonZero: can be anything except zero\n * @param value Value to check\n * @param parameterName Param name for customising exception message\n * @param range Guard specifier.\n */\nexport const integerTest = (\n  value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`\n): GuardResult => {\n  // ✔️ Unit tested\n  const r = numberTest(value, range, parameterName);\n  if (!r[ 0 ]) return r;\n  if (!Number.isInteger(value)) {\n    return [ false, `Param '${ parameterName }' is not an integer` ];\n  }\n  return [ true ];\n};\n\nexport const integerArrayTest = (numbers: Iterable<number>): GuardResult => {\n  for (const v of numbers) {\n    if (Math.abs(v) % 1 !== 0) return [ false, `Value is not an integer: ${ v }` ];\n  }\n  return [ true ];\n};\n\n/**\n * Returns _true_ if `value` is an integer in number or string form\n * @param value \n * @returns \n */\nexport const isInteger = (value: number | string): boolean => {\n  if (typeof value === `string`) value = Number.parseFloat(value);\n  const r = integerTest(value);\n  return r[ 0 ];\n}\n\nexport const throwIntegerTest = (value: number | undefined,\n  range: NumberGuardRange = ``,\n  parameterName = `?`) => {\n  throwFromResult(integerTest(value, range, parameterName));\n}\n\nexport const numberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`): GuardResult => {\n  if (typeof value !== `number`) {\n    return [ false, `Param '${ parameterName }' is not a number type. Got type: '${ typeof value }' value: '${ JSON.stringify(value) }'` ];\n  }\n  if (Number.isNaN(value)) {\n    return [ false, `Param '${ parameterName }' is not within range ${ min }-${ max }. Got: NaN` ];\n  }\n  if (Number.isFinite(value)) {\n    if (value < min) {\n      return [ false, `Param '${ parameterName }' is below range ${ min }-${ max }. Got: ${ value }` ];\n    } else if (value > max) {\n      return [ false, `Param '${ parameterName }' is above range ${ min }-${ max }. Got: ${ value }` ];\n    }\n    return [ true ];\n  } else {\n    return [ false, `Param '${ parameterName }' is not within range ${ min }-${ max }. Got: infinite` ];\n  }\n}\n\nexport const throwNumberInclusiveRangeTest = (value: number | undefined, min: number, max: number, parameterName = `?`) => {\n  const r = numberInclusiveRangeTest(value, min, max, parameterName);\n  if (r[ 0 ]) return;\n  throw new Error(r[ 1 ]);\n}","import type { GuardResult } from \"./types.js\";\nimport { throwFromResult } from \"./throw-from-result.js\";\nimport { throwIntegerTest } from \"./numbers.js\";\n\n/**\n * Throws an error if parameter is not an array\n * @param value\n * @param parameterName\n */\nexport const arrayTest = (value: unknown, parameterName = `?`): GuardResult => {\n  if (!Array.isArray(value)) {\n    return [ false, `Parameter '${ parameterName }' is expected to be an array'` ];\n  }\n  return [ true ];\n};\n\nexport const throwArrayTest = (value: unknown, parameterName = `?`) => {\n  throwFromResult(arrayTest(value, parameterName));\n}\n\n/**\n * Returns true if parameter is an array of strings\n * @param value\n * @returns\n */\nexport const isStringArray = (value: unknown): boolean => {\n  if (!Array.isArray(value)) return false;\n  return !value.some((v) => typeof v !== `string`);\n};\n\n/**\n * Throws an error if `array` parameter is not a valid array\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n * Arrays.guardArray(someVariable);\n * ```\n * @private\n * @param array\n * @param name\n */\nexport const guardArray = <V>(array: ArrayLike<V>, name = `?`) => {\n  if (array === undefined) {\n    throw new TypeError(`Param '${ name }' is undefined. Expected array.`);\n  }\n  if (array === null) {\n    throw new TypeError(`Param '${ name }' is null. Expected array.`);\n  }\n  if (!Array.isArray(array)) {\n    throw new TypeError(`Param '${ name }' not an array as expected`);\n  }\n};\n\n/**\n * Throws if `index` is an invalid array index for `array`, and if\n * `array` itself is not a valid array.\n * @param array\n * @param index\n */\nexport const guardIndex = <V>(\n  array: ArrayLike<V>,\n  index: number,\n  name = `index`\n) => {\n  guardArray(array);\n  throwIntegerTest(index, `positive`, name);\n  if (index > array.length - 1) {\n    throw new Error(\n      `'${ name }' ${ index } beyond array max of ${ array.length - 1 }`\n    );\n  }\n};","\n// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultToString = (object: any): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (object === null) return `null`;\n  if (typeof object === `boolean` || typeof object === `number`) {\n    return object.toString();\n  }\n\n  if (typeof object === `string`) return object;\n  if (typeof object === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  return JSON.stringify(object);\n};","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: unknown) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n   \n  JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string,unknown>, b: Record<string,unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string,unknown>, valueB as Record<string,unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value: number, min = 0, max = 1) => {\n  // ✔ UNIT TESTED\n  if (Number.isNaN(value)) throw new Error(`Param 'value' is NaN`);\n  if (Number.isNaN(min)) throw new Error(`Param 'min' is NaN`);\n  if (Number.isNaN(max)) throw new Error(`Param 'max' is NaN`);\n\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n};\n\n/**\n * Returns a function that clamps values.\n * \n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport const clamper = (min = 0, max = 1) => {\n  if (Number.isNaN(min)) throw new Error(`Param 'min' is NaN`);\n  if (Number.isNaN(max)) throw new Error(`Param 'max' is NaN`);\n  return (v: number) => {\n    if (v > max) return max;\n    if (v < min) return min;\n    return v;\n  }\n}\n\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport const clampIndex = (\n  v: number,\n  arrayOrLength: number | readonly any[]\n): number => {\n  // ✔ UNIT TESTED\n  if (!Number.isInteger(v)) {\n    throw new TypeError(`v parameter must be an integer (${ v })`);\n  }\n  const length = Array.isArray(arrayOrLength)\n    ? arrayOrLength.length\n    : (arrayOrLength as number);\n\n  if (!Number.isInteger(length)) {\n    throw new TypeError(\n      `length parameter must be an integer (${ length }, ${ typeof length })`\n    );\n  }\n  v = Math.round(v);\n  if (v < 0) return 0;\n  if (v >= length) return length - 1;\n  return v;\n};\n","import { defaultComparer } from './comparers.js';\nimport { isEqualDefault, type IsEqual } from './is-equal.js';\nimport {\n  toStringDefault,\n} from './to-string.js';\nimport type { IDictionary,  IWithEntries, ToString } from './types.js';\n\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (\n  data: ReadonlyMap<number, unknown>,\n  target: number\n): number => {\n  target = Math.round(target);\n  if (data.has(target)) {\n    return target;\n  } else {\n    let offset = 1;\n    while (offset < 1000) {\n      if (data.has(target - offset)) return target - offset;\n      else if (data.has(target + offset)) return target + offset;\n      offset++;\n    }\n    throw new Error(`Could not find target ${ target.toString() }`);\n  }\n};\n\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = getFromKeys(data, keys);\n * ```\n * @param data \n * @param keys \n * @returns \n */\nexport const getFromKeys = <T>(data: ReadonlyMap<string, T>, keys: Iterable<string>): T | undefined => {\n  for (const key of keys) {\n    if (data.has(key)) return data.get(key);\n  }\n}\n\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match\n * @returns True if key is found\n */\nexport const hasKeyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  if (!map.has(key)) return false;\n  const values = [ ...map.values() ];\n  return values.some((v) => comparer(v, value));\n};\n\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer\n */\nexport const deleteByValueMutate = <K, V>(\n  map: Map<K, V>,\n  value: V,\n  comparer: IsEqual<V> = isEqualDefault\n) => {\n  for (const entry of Object.entries(map)) {\n    if (comparer(entry[ 1 ] as V, value)) {\n      map.delete(entry[ 0 ] as K);\n    }\n  }\n};\n\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntryByPredicate = <K, V>(\n  map: IWithEntries<K, V>,\n  predicate: (value: V, key: K) => boolean\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (predicate(entry[ 1 ], entry[ 0 ])) return entry;\n  }\n};\n\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = firstEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = <K, V>(\n  map: IWithEntries<K, V>,\n  value: V,\n  isEqual: IsEqual<V> = isEqualDefault\n): readonly [ key: K, value: V ] | undefined => {\n  for (const entry of map.entries()) {\n    if (isEqual(entry[ 1 ], value)) return entry;\n  }\n};\n\n\n\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n *\n * @example\n * ```js\n * import { Maps } from \"https://unpkg.com/ixfx/dist/collections.js\";\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * Maps.addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\nexport const addKeepingExisting = <V>(\n  set: ReadonlyMap<string, V> | undefined,\n  hasher: ToString<V>,\n  ...values: readonly V[]\n) => {\n  const s = set === undefined ? new Map() : new Map(set);\n  for (const v of values) {\n    const hashResult = hasher(v);\n    if (s.has(hashResult)) continue;\n    s.set(hashResult, v);\n  }\n  return s;\n};\n\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  comparer?: (a: V, b: V) => number\n) => {\n  const f = comparer ?? defaultComparer;\n  return [ ...map.entries() ].sort((a, b) => f(a[ 1 ], b[ 1 ]));\n};\n\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * cosnt m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = Maps.sortByValue(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = <K, V, Z>(\n  map: ReadonlyMap<K, V>,\n  property: string,\n  compareFunction?: (a: Z, b: Z) => number\n) => {\n  const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n  return [ ...map.entries() ].sort((aE, bE) => {\n    const a = aE[ 1 ];\n    const b = bE[ 1 ];\n    return cfn(a[ property ] as Z, b[ property ] as Z);\n  });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = <K, V>(\n  map: ReadonlyMap<K, V>,\n  value: V,\n  comparer: IsEqual<V>\n): boolean => {\n  const entries = [ ...map.entries() ];\n  return entries.some((kv) => comparer(kv[ 1 ], value));\n};\n\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filter(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filter(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\n \nexport function* filter<V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n) {\n  for (const v of map.values()) {\n    if (predicate(v)) yield v;\n  }\n}\n\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = <V>(map: ReadonlyMap<string, V>): readonly V[] =>\n  [ ...map.values() ];\n\n\n/**\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` }\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = Maps.fromIterable(data, v => v.fruit);\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param allowOverwrites When set to _true_, items with same id will silently overwrite each other, with last write wins. _false_ by default.\n * @returns\n */\nexport const fromIterable = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>,\n  allowOverwrites = false\n): ReadonlyMap<string, V> => {\n  const m = new Map<string, V>();\n  for (const d of data) {\n    const id = keyFunction(d);\n    if (m.has(id) && !allowOverwrites) {\n      throw new Error(\n        `id ${ id } is already used and new data will overwrite it. `\n      );\n    }\n    m.set(id, d);\n  }\n  return m;\n};\n\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = <V>(data: object|object[]): ReadonlyMap<string, V> => {\n  const map = new Map<string, V>();\n  if (Array.isArray(data)) {\n    for (const d of data) addObjectMutate<V>(map, d as object);\n  } else {\n    addObjectMutate<V>(map, data);\n  }\n  return map;\n};\n\n/**\n * Adds an object to an existing map, mutating it. \n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObject(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectMutate = <V>(map: Map<string, V>, data: object) => {\n  const entries = Object.entries(data);\n  for (const [ key, value ] of entries) {\n    map.set(key, value as V);\n  }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = find(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const find = <V>(\n  map: ReadonlyMap<string, V>,\n  predicate: (v: V) => boolean\n): V | undefined => [ ...map.values() ].find(v => predicate(v));\n\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link find} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map \n * @param predicate \n * @returns \n */\nexport const some = <V>(map: ReadonlyMap<string, V>, predicate: (v: V) => boolean): boolean => [ ...map.values() ].some(v => predicate(v));\n\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = <T, K>(\n  m: ReadonlyMap<string, T>,\n  valueTransform: (value: T) => K\n): Readonly<Record<string, K>> =>\n  [ ...m ].reduce((object: object, [ key, value ]) => {\n    const t = valueTransform(value);\n    object[ key ] = t;\n    return object;\n  }, {});\n\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = <V>(\n  keys: readonly string[],\n  values: ArrayLike<V | undefined>\n) => {\n  if (keys.length !== values.length) {\n    throw new Error(`Keys and values arrays should be same length`);\n  }\n  return Object.fromEntries(keys.map((k, index) => [ k, values[ index ] ]));\n};\n\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = <K, V, R>(\n  source: ReadonlyMap<K, V>,\n  transformer: (value: V, key: K) => R\n) => new Map(Array.from(source, (v) => [ v[ 0 ], transformer(v[ 1 ], v[ 0 ]) ]));\n\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = <T>(\n  m: ReadonlyMap<string, T>\n): Readonly<Record<string, T>> =>\n  [ ...m ].reduce((object: object, [ key, value ]) => {\n    object[ key ] = value;\n    return object;\n  }, {});\n\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * let person = { age: 29, name: `John`};\n * map.add(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = <K, V, R>(\n  m: ReadonlyMap<K, V>,\n  transformer: (key: K, item: V) => R\n): readonly R[] => [ ...m.entries() ].map((x) => transformer(x[ 0 ], x[ 1 ]));\n// End Functions by Kees C. Bakker\n//#endregion\n\n/**\n * Returns a result of a merged into b.\n * B is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Arrays.mergeByKey Arrays.mergeByKey} if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 2 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = <K, V>(\n  reconcile: MergeReconcile<V>,\n  ...maps: readonly ReadonlyMap<K, V>[]\n): ReadonlyMap<K, V> => {\n  const result = new Map<K, V>();\n  for (const m of maps) {\n    for (const [ mk, mv ] of m) {\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return result;\n};\n\n\nexport type GetOrGenerate<K, V, Z> = (key: K, args?: Z) => Promise<V>;\n\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync =\n  <K, V, Z>(map: IDictionary<K, V>, fn: (key: K, args?: Z) => V) =>\n    (key: K, args?: Z): V => {\n      let value = map.get(key);\n      if (value !== undefined) return value;\n      value = fn(key, args);\n      map.set(key, value);\n      return value;\n    };\n\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate =\n  <K, V, Z>(\n    map: IDictionary<K, V>,\n    fn: (key: K, args?: Z) => Promise<V> | V\n  ): GetOrGenerate<K, V, Z> =>\n    async (key: K, args?: Z): Promise<V> => {\n      let value = map.get(key);\n      if (value !== undefined) return value; //Promise.resolve(value);\n      value = await fn(key, args);\n      if (value === undefined) throw new Error(`fn returned undefined`);\n      map.set(key, value);\n      return value;\n    };\n\n","import { type GetOrGenerate, getOrGenerate } from '../maps.js';\nimport { TrackerBase } from './tracker-base.js';\n\nexport type Timestamped = {\n  readonly at: number\n}\nexport type TimestampedObject<V> = V & Timestamped;\n\n/**\n * Options\n */\nexport type TrackedValueOpts = {\n  readonly id?: string;\n\n  /**\n   * If true, intermediate points are stored. False by default\n   */\n  readonly storeIntermediate?: boolean;\n  /**\n   * If above zero, tracker will reset after this many samples\n   */\n  readonly resetAfterSamples?: number;\n\n  /**\n   * If above zero, there will be a limit to intermediate values kept.\n   *\n   * When the seen values is twice `sampleLimit`, the stored values will be trimmed down\n   * to `sampleLimit`. We only do this when the values are double the size so that\n   * the collections do not need to be trimmed repeatedly whilst we are at the limit.\n   *\n   * Automatically implies storeIntermediate\n   */\n  readonly sampleLimit?: number;\n\n  /**\n   * If _true_, prints debug info\n   */\n  readonly debug?: boolean\n};\n\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class TrackedPointMap extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap<V, T extends TrackerBase<V, TResult>, TResult> {\n  store: Map<string, T>;\n  gog: GetOrGenerate<string, T, V>;\n\n  constructor(creator: (key: string, start: V | undefined) => T) {\n    this.store = new Map();\n    this.gog = getOrGenerate<string, T, V>(this.store, creator);\n  }\n\n  /**\n   * Number of named values being tracked\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Returns _true_ if `id` is stored\n   * @param id\n   * @returns\n   */\n  has(id: string) {\n    return this.store.has(id);\n  }\n\n  /**\n   * For a given id, note that we have seen one or more values.\n   * @param id Id\n   * @param values Values(s)\n   * @returns Information about start to last value\n   */\n  //eslint-disable-next-line @typescript-eslint/no-explicit-any\n  //eslint-disable-next-line functional/prefer-immutable-types\n  public async seen(id: string, ...values: Array<V>): Promise<TResult> {\n    const trackedValue = await this.getTrackedValue(id, ...values);\n\n    // Pass it over to the TrackedValue\n    const result = trackedValue.seen(...values);\n\n    return result;\n  }\n\n  /**\n   * Creates or returns a TrackedValue instance for `id`.\n   * @param id\n   * @param values\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  protected async getTrackedValue(id: string, ...values: Array<V>) {\n    if (id === null) throw new Error(`id parameter cannot be null`);\n    if (id === undefined) throw new Error(`id parameter cannot be undefined`);\n\n    // Create or recall TrackedValue by id\n    const trackedValue = await this.gog(id, values[ 0 ]);\n    return trackedValue;\n  }\n\n  /**\n   * Remove a tracked value by id.\n   * Use {@link reset} to clear them all.\n   * @param id\n   */\n  delete(id: string) {\n    this.store.delete(id);\n  }\n\n  /**\n   * Remove all tracked values.\n   * Use {@link delete} to remove a single value by id.\n   */\n  reset() {\n    this.store = new Map();\n  }\n\n  /**\n   * Enumerate ids\n   */\n  *ids() {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Enumerate tracked values\n   */\n  *tracked() {\n    yield* this.store.values();\n  }\n\n  /**\n   * Iterates TrackedValues ordered with oldest first\n   * @returns\n   */\n  *trackedByAge() {\n    const tp = [ ...this.store.values() ];\n    tp.sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa > bb) return -1;\n      return 1;\n    });\n\n    for (const t of tp) {\n      yield t;\n    }\n  }\n\n  /**\n   * Iterates underlying values, ordered by age (oldest first)\n   * First the named values are sorted by their `elapsed` value, and then\n   * we return the last value for that group.\n   */\n  *valuesByAge() {\n    for (const tb of this.trackedByAge()) {\n      yield tb.last;\n    }\n  }\n\n  /**\n   * Enumerate last received values\n   *\n   * @example Calculate centroid of latest-received values\n   * ```js\n   * const pointers = pointTracker();\n   * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n   * ```\n   */\n  *last() {\n    for (const p of this.store.values()) {\n      yield p.last;\n    }\n  }\n\n  /**\n   * Enumerate starting values\n   */\n  *initialValues() {\n    for (const p of this.store.values()) {\n      yield p.initial;\n    }\n  }\n\n  /**\n   * Returns a tracked value by id, or undefined if not found\n   * @param id\n   * @returns\n   */\n  get(id: string): TrackerBase<V, TResult> | undefined {\n    return this.store.get(id);\n  }\n}\n","import { type Timestamped, type TrackedValueOpts } from './tracked-value.js';\n\n/**\n * Base tracker class\n */\nexport abstract class TrackerBase<V, SeenResultType> {\n  /**\n   * @ignore\n   */\n  seenCount: number;\n\n  /**\n   * @ignore\n   */\n  protected storeIntermediate: boolean;\n\n  /**\n   * @ignore\n   */\n  protected resetAfterSamples: number;\n\n  /**\n   * @ignore\n   */\n  protected sampleLimit: number;\n\n  public readonly id: string;\n\n  protected debug: boolean;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    this.id = opts.id ?? `tracker`;\n    this.debug = opts.debug ?? false;\n    this.sampleLimit = opts.sampleLimit ?? -1;\n    this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n\n    this.storeIntermediate =\n      opts.storeIntermediate ??\n      (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n    this.seenCount = 0;\n\n    if (this.debug) {\n      console.log(`TrackerBase: sampleLimit: ${ this.sampleLimit } resetAfter: ${ this.resetAfterSamples } store: ${ this.storeIntermediate }`);\n    }\n  }\n\n  /**\n   * Reset tracker\n   */\n  reset() {\n    this.seenCount = 0;\n    this.onReset();\n  }\n\n  /**\n   * Adds a value, returning computed result.\n   *  \n   * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.\n   * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is\n   * called to take it down to sample limit, and `onTrimmed()` is called.\n   * @param p \n   * @returns \n   */\n  seen(...p: Array<V>): SeenResultType {\n    if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n      this.reset();\n    } else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n      this.seenCount = this.trimStore(this.sampleLimit);\n      this.onTrimmed(`resize`);\n    }\n\n    this.seenCount += p.length;\n    const t = this.filterData(p);\n    return this.computeResults(t);\n  }\n\n  /**\n   * @ignore\n   * @param p\n   */\n  abstract filterData(p: Array<V>): Array<Timestamped>;\n\n  abstract get last(): V | undefined;\n\n  /**\n   * Returns the initial value, or undefined\n   */\n  abstract get initial(): V | undefined;\n\n  /**\n   * Returns the elapsed milliseconds since the initial value\n   */\n  abstract get elapsed(): number;\n\n  /**\n   * @ignore\n   */\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  abstract computeResults(_p: Array<Timestamped>): SeenResultType;\n\n  /**\n   * @ignore\n   */\n  abstract onReset(): void;\n\n\n  /**\n   * Notification that buffer has been trimmed\n   */\n  abstract onTrimmed(reason: TrimReason): void;\n  abstract trimStore(limit: number): number;\n}\n\nexport type TrimReason = `reset` | `resize`\n","import type { TimestampedObject, TrackedValueOpts } from './tracked-value.js';\nimport { TrackerBase, type TrimReason } from './tracker-base.js';\n\n/**\n * A tracked value of type `V`.\n */\nexport abstract class ObjectTracker<V extends object, SeenResultType> extends TrackerBase<V, SeenResultType> {\n  values: Array<TimestampedObject<V>>;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    super(opts);\n    this.values = [];\n  }\n\n  onTrimmed(reason: TrimReason) {\n    // no-op\n  }\n\n  /**\n   * Reduces size of value store to `limit`. \n   * Returns number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    // Index 0 will be the oldest\n    this.values = this.values.slice(-limit);\n    return this.values.length;\n  }\n\n  /**\n   * Allows sub-classes to be notified when a reset happens\n   * @ignore\n   */\n  onReset() {\n    this.values = [];\n  }\n\n  /**\n   * Tracks a value\n   * @ignore\n   */\n  filterData(p: Array<V> | Array<TimestampedObject<V>>): Array<TimestampedObject<V>> {\n    // Make sure values have a timestamp\n    const ts = p.map((v) =>\n      `at` in v\n        ? v\n        : {\n          ...v,\n          at: Date.now(),\n        }\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const last = ts.at(-1)!;\n\n    if (this.storeIntermediate) this.values.push(...ts);\n    else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last);\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last;\n        break;\n      }\n    }\n    return ts;\n  }\n\n  /**\n   * Last seen value. If no values have been added, it will return the initial value\n   */\n  get last() {\n    if (this.values.length === 1) return this.values[ 0 ];\n    //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.values.at(-1)!;\n  }\n\n  /**\n   * Returns the oldest value in the buffer\n   */\n  get initial() {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (includes the initial value in the count)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the initial value\n   */\n  get elapsed(): number {\n    return Date.now() - this.values[ 0 ].at;\n  }\n\n}\n","export class MapOfSimple<T> {\n  #store = new Map<string, T[]>();\n\n  /**\n   * Gets a copy of the underlying array storing values at `key`, or an empty array if\n   * key does not exist\n   * @param key \n   * @returns \n   */\n  get(key: string) {\n    const arr = this.#store.get(key);\n    if (!arr) return [];\n    return [ ...arr ];\n  }\n\n  /**\n   * Returns the number of values stored under `key`\n   * @param key \n   * @returns \n   */\n  size(key: string) {\n    const arr = this.#store.get(key);\n    if (!arr) return 0;\n    return arr.length;\n  }\n\n  /**\n   * Iterate over all values contained under `key`\n   * @param key \n   * @returns \n   */\n  *iterateKey(key: string): Generator<T> {\n    const arr = this.#store.get(key);\n    if (!arr) return;\n    yield* arr.values();\n  }\n\n  /**\n   * Iterate all values, regardless of key\n   */\n  *iterateValues(): Generator<T> {\n    for (const key of this.#store.keys()) {\n      yield* this.iterateKey(key);\n    }\n  }\n\n  /**\n   * Iterate all keys\n   */\n  *iterateKeys(): Generator<string> {\n    yield* this.#store.keys();\n  }\n\n  addKeyedValues(key: string, ...values: T[]) {\n    let arr = this.#store.get(key);\n    if (!arr) {\n      arr = [];\n      this.#store.set(key, arr);\n    }\n    arr.push(...values);\n  }\n\n  deleteKeyValue(key: string, value: T) {\n    const arr = this.#store.get(key);\n    if (!arr) return false;\n    const arrCopy = arr.filter(v => v !== value);\n    if (arrCopy.length === arr.length) return false;\n    this.#store.set(key, arrCopy);\n    return true;\n  }\n\n  clear() {\n    this.#store.clear();\n  }\n}","import { MapOfSimple } from \"./map-of.js\";\nimport type { ISimpleEventEmitter, Listener } from \"./types.js\";\n\nexport class SimpleEventEmitter<Events> implements ISimpleEventEmitter<Events> {\n  readonly #listeners = new MapOfSimple<Listener<Events>>();\n  #disposed = false;\n\n  dispose() {\n    if (this.#disposed) return;\n    this.clearEventListeners();\n  }\n\n  get isDisposed() {\n    return this.#disposed;\n  }\n\n  /**\n   * Fire event\n   * @param type Type of event\n   * @param args Arguments for event\n   * @returns\n   */\n  protected fireEvent<K extends keyof Events>(type: K, args: Events[ K ]) {\n    if (this.#disposed) throw new Error(`Disposed`);\n    //console.log(`Firing ${ type as string }. Listeners: ${ this.#listeners.size(type as string) }`);\n    for (const l of this.#listeners.iterateKey(type as string)) {\n      l(args, this);\n    }\n  }\n\n  /**\n   * Adds event listener.\n   * \n   * @throws Error if emitter is disposed\n   * @typeParam K - Events\n   * @param name Event name\n   * @param listener Event handler\n   */\n  addEventListener<K extends keyof Events>(\n    name: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ): void {\n    if (this.#disposed) throw new Error(`Disposed`);\n    this.#listeners.addKeyedValues(\n      name as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Remove event listener\n   *\n   * @param listener\n   */\n  removeEventListener<K extends keyof Events>(\n    type: K,\n    listener: (event: Events[ K ], sender: SimpleEventEmitter<Events>) => void\n  ) {\n    if (this.#disposed) return;\n\n    // listener: Listener<Events>): void {\n    this.#listeners.deleteKeyValue(\n      type as string,\n      listener as Listener<Events>\n    );\n  }\n\n  /**\n   * Clear all event listeners\n   * @private\n   */\n  clearEventListeners() {\n    if (this.#disposed) return;\n    this.#listeners.clear();\n  }\n}"],"mappings":"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"}