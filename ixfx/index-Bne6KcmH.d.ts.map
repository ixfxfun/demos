{"version":3,"file":"index-Bne6KcmH.d.ts","names":["Interval","HasCompletionRunStates","HasCompletion","Continuously","ContinuouslySyncCallback","ContinuouslyAsyncCallback","Promise","OnStartCalled","ContinuouslyOpts","AbortSignal","Readonly","continuously","Partial","LogSet","MessageLogger","LogMessage","LogKind","MessageLogger","logger","logSet","LogOption","resolveLogOption","logColours","fpsCounter","getErrorMessage"],"sources":["../../core/dist/src/continuously.d.ts","../../debug/dist/src/types.d.ts","../../debug/dist/src/logger.d.ts","../../debug/dist/src/fps-counter.d.ts","../../debug/dist/src/error-message.d.ts","../../debug/dist/src/index.d.ts"],"sourcesContent":["import { type Interval } from '@ixfx/core';\nexport type HasCompletionRunStates = `idle` | `scheduled` | `running`;\nexport type HasCompletion = {\n    /**\n     * Gets the current run state\n     * idle: not yet started or completed with no future run scheduled\n     * scheduled: waiting to run\n     * running: currently executing its callback\n     */\n    get runState(): HasCompletionRunStates;\n    /**\n     * Returns the number of times the scheduled function\n     * has been executed.\n     *\n     * This number will be reset in some conditions.\n     * For example `continuously` resets it when the loop stops.\n     *\n     * Use {@link startCountTotal} to track total number.\n     */\n    get startCount(): number;\n    /**\n     * Total number of times scheduled function has been\n     * executed.\n     */\n    get startCountTotal(): number;\n};\n/**\n * Runs a function continuously, returned by {@link continuously}\n */\nexport type Continuously = HasCompletion & {\n    /**\n     * Starts loop. If already running, does nothing\n     */\n    start(): void;\n    /**\n     * (Re-)starts the loop. If an existing iteration has been\n     * scheduled, this is cancelled and started again.\n     *\n     * This can be useful when adjusting the interval\n     */\n    reset(): void;\n    /**\n     * How many milliseconds since loop was started after being stopped.\n     */\n    get elapsedMs(): number;\n    /**\n     * If disposed, the continuously instance won't be re-startable\n     */\n    get isDisposed(): boolean;\n    /**\n     * Stops loop. It can be restarted using .start()\n     */\n    cancel(): void;\n    /**\n     * Sets the interval speed of loop. Change will take effect on next loop. For it to kick\n     * in earlier, call .reset() after changing the value.\n     */\n    set interval(interval: Interval);\n    /**\n     * Gets the current interval, ie. speed of loop.\n     */\n    get interval(): Interval;\n};\nexport type ContinuouslySyncCallback = (\n/**\n * Number of times loop\n * Ticks is reset when loop exits.\n */\nticks?: number, \n/**\n * Elapsed milliseconds.\n * Reset when loop exits\n */\nelapsedMs?: number) => boolean | void;\nexport type ContinuouslyAsyncCallback = (\n/**\n * Number of times loop has run\n * Reset when loop exits.\n */\nticks?: number, \n/**\n * Elapsed milliseconds.\n * Reset when loop exits.\n */\nelapsedMs?: number) => Promise<boolean | void>;\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n/**\n * Options for {@link continuously}\n */\nexport type ContinuouslyOpts = Readonly<{\n    /**\n     * Abort signal to exit loop\n     */\n    signal: AbortSignal;\n    /**\n     * If _true_, callback runs before waiting period.\n     * @defaultValue false\n     */\n    fireBeforeWait: boolean;\n    /**\n     * Called whenever .start() is invoked.\n     * If this function returns:\n     *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n     *  - `cancel`: loop stops, but can be re-started if .start() is called again\n     *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n     *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n     *\n     */\n    onStartCalled: (\n    /**\n     * Number of times loop has run\n     * Reset when loop is exits.\n     */\n    ticks?: number, \n    /**\n     * Elapsed milliseconds.\n     * Reset when loop is exits.\n     */\n    elapsedMs?: number) => OnStartCalled;\n}>;\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport declare const continuously: (callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback, interval?: Interval, options?: Partial<ContinuouslyOpts>) => Continuously;\n//# sourceMappingURL=continuously.d.ts.map","export type LogSet = {\n    readonly log: MessageLogger;\n    readonly warn: MessageLogger;\n    readonly error: MessageLogger;\n};\nexport type MessageLogger = (message: LogMessage | string) => void;\nexport type LogKind = `info` | `debug` | `error` | `warn`;\nexport type LogMessage = {\n    readonly kind?: LogKind;\n    readonly msg: any;\n    readonly category?: string;\n};\n//# sourceMappingURL=types.d.ts.map","import type { MessageLogger } from \"./types.js\";\n/**\n * Returns a console logging function which prefixes messages. This is\n * useful for tracing messages from different components. Each prefix\n * is assigned a colour, further helping to distinguish messages.\n *\n * Use {@link logSet} to get a bundled set.\n *\n * ```\n * // Initialise once\n * const log = logger(`a`);\n * const error = logger(`a`, `error`);\n * const warn = logger(`a`, `warn);\n *\n * // And then use\n * log(`Hello`);    // console.log(`a Hello`);\n * error(`Uh-oh`);  // console.error(`a Uh-oh`);\n * warn(`Eek!`);    // console.warn(`a Eeek!`);\n * ```\n *\n * Provide the `colourKey` parameter to make log messages\n * be coloured the same, even though the prefix is different.\n * ```js\n * // Both loggers will use the same colour because they\n * // share the colour key `system`\n * const log = logger(`a`,`log`,`system`);\n * const log2 = logger(`b`, `log`, `system`);\n * ```\n * @param prefix\n * @param kind\n * @param colourKey Optional key to colour log lines by instead of prefix\n * @returns\n */\nexport declare const logger: (prefix: string, kind?: `log` | `warn` | `error`, colourKey?: string) => MessageLogger;\n/**\n* Returns a bundled collection of {@link logger}s\n*\n* ```js\n* const con = logSet(`a`);\n* con.log(`Hello`);  // console.log(`a Hello`);\n* con.warn(`Uh-oh`); // console.warn(`a Uh-oh`);\n* con.error(`Eek!`); // console.error(`a Eek!`);\n* ```\n*\n* By default each prefix is assigned a colour. To use\n* another logic, provide the `colourKey` parameter.\n*\n* ```js\n* // Both set of loggers will use same colour\n* const con = logSet(`a`, true, `system`);\n* const con2 = logSet(`b`, true, `system`);\n* ```\n* @param prefix Prefix for log messages\n* @param verbose True by default. If false, log() messages are a no-op\n* @param colourKey If specified, log messages will be coloured by this key instead of prefix (default)\n* @returns\n*/\nexport declare const logSet: (prefix: string, verbose?: boolean, colourKey?: string) => {\n    log: MessageLogger;\n    warn: MessageLogger;\n    error: MessageLogger;\n};\n/**\n * Either a flag for default console logging, or a simple log function\n */\nexport type LogOption = boolean | MessageLogger;\n/**\n * Resolve a LogOption to a function\n * @param l\n * @returns\n */\nexport declare const resolveLogOption: (l?: LogOption, defaults?: {\n    readonly category?: string;\n    readonly kind?: string;\n}) => MessageLogger;\nexport declare const logColours: (key: string, args?: unknown) => string;\n//# sourceMappingURL=logger.d.ts.map","/**\n * Calculates frames per second.\n *\n * Returns a function which needs to be called at the end of each frame.\n *\n * ```js\n * const fps = fpsCounter();\n *\n * function loop() {\n *  fps(); // Calculate fps\n *  window.requestAnimationFrame(loop);\n * }\n *\n * loop();\n * ```\n * @param autoDisplay If true (default), prints out the FPS to the console\n * @param computeAfterFrames Calculates after this many frames. Higher numbers smoothes the value somewhat\n * @returns\n */\nexport declare const fpsCounter: (autoDisplay?: boolean, computeAfterFrames?: number) => () => number;\n//# sourceMappingURL=fps-counter.d.ts.map","/**\n * Returns a string representation of an error\n * @param ex\n * @returns\n */\nexport declare const getErrorMessage: (ex: unknown) => string;\n//# sourceMappingURL=error-message.d.ts.map","export * from './types.js';\nexport * from './logger.js';\nexport * from './fps-counter.js';\nexport * from './error-message.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":";;;KACYC,sBAAAA;KACAC,aAAAA;;AADZ;AACA;AA2BA;;;EAAwC,IA4BbF,QAAAA,EAAAA,EAhDPC,sBAgDOD;EAAQ;AAIP;AAE5B;AAWA;AAWA;AAIA;;;;EA6BwC,IA7BTU,UAAAA,EAAAA,EAAAA,MAAAA;EAAQ;AAmHvC;;;EAAuE,IAAGN,eAAAA,EAAAA,EAAAA,MAAAA;CAAwB;;;;AAA2E,KA/KjKD,YAAAA,GAAeD,aA+KkJ,GAAA;;;;EC5MjKW,KAAAA,EAAAA,EAAM,IAAA;EAAA;;;;AAGe;AAEjC;EACYG,KAAAA,EAAAA,EAAAA,IAAO;EACPD;;;;EC0BSG;AAwBrB;;EAIC,IAHQD,UAAAA,EAAAA,EAAAA,OAAAA;EAAa;;AAEE;EAKZG,MAAAA,EAAAA,EAAAA,IAAS;EAMAC;;;;EAGF,IAAA,QAAA,CAAA,QAAA,EFjBQrB,QEiBR;EACEsB;;;kBFdDtB;AG1CpB,CAAA;KH4CYI,wBAAAA;;;AI1DZ;;;;;;;;KJqEYC,yBAAAA;;;;;;;;;;uBAUWC;KACXC,aAAAA;;;;KAIAC,gBAAAA,GAAmBE;;;;UAInBD;;;;;;;;;;;;;;;;;;;;;;;;;yBAyBeF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAsFNI,yBAAyBN,4BAA4BD,qCAAqCJ,oBAAoBY,QAAQJ,sBAAsBL;;;;KC5MrJU,MAAAA;gBACMI;iBACCA;kBACCA;ADFpB,CAAA;AACYf,KCGAe,aAAAA,GDHa,CAAA,OAOLhB,ECJkBc,UDIlBd,GAAAA,MAAsB,EAAA,GAAA,IAAA;AAoB9BE,KCvBAa,OAAAA,GDuBY,MAAA,GAAA,OAAA,GAAA,OAAA,GAAA,MAAA;AAAA,KCtBZD,UAAAA,GDsBY;EAAA,SAAGb,IAAAA,CAAAA,ECrBPc,ODqBOd;EAAa,SA4BbF,GAAAA,EAAAA,GAAAA;EAAQ,SAIfA,QAAAA,CAAAA,EAAAA,MAAAA;AAAQ,CAAA;AAE5B;;;;;;;AA9DA;AACA;AA2BA;;;;;AAgC4B;AAE5B;AAWA;AAWA;AAIA;;;;;AAAuC;AAmHvC;;;;;;;;AAA6K;;;;AC5MjKa,cCiCSK,MDjCH,EAAA,CAAA,MAAA,EAAA,MAAA,EAAA,IAAA,CAAA,EAAA,KAAA,GAAA,MAAA,GAAA,OAAA,EAAA,SAAA,CAAA,EAAA,MAAA,EAAA,GCiCoFD,aDjCpF;;;;;AAGe;AAEjC;AACA;AACA;;;;AC0BA;AAwBA;;;;;AAGwB;AAKxB;AAMA;;;;AAGmB,cAjBEE,MAiBF,EAAA,CAAA,MAAA,EAAA,MAAA,EAAA,OAAA,CAAA,EAAA,OAAA,EAAA,SAAA,CAAA,EAAA,MAAA,EAAA,GAAA;EACEG,GAAAA,EAjBZL,aAiB+D;QAhB9DA;SACCA;;ACzCX;;;KD8CYG,SAAAA,aAAsBH;AE5DlC;;;;;cFkEqBI,uBAAuBD;;;MAGtCH;cACeK;;;;;;;;AF1ErB;AACA;AA2BA;;;;;AAgC4B;AAE5B;AAWA;AAWA;AAIA;;;;AAA+BZ,cGtEVa,UHsEUb,EAAAA,CAAAA,WAAAA,CAAAA,EAAAA,OAAAA,EAAAA,kBAAAA,CAAAA,EAAAA,MAAAA,EAAAA,GAAAA,GAAAA,GAAAA,MAAAA;AAAQ;;;;;;;AAxFvC;AACYR,cIGSsB,eJIDvB,EAAAA,CAAAA,EAAAA,EAAAA,OAAAA,EAAAA,GAAsB,MAAA;AAoB1C;AAAA"}