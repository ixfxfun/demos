{"version":3,"file":"process.js","names":["max","value: number | number[]","min","tally","countArrayItems: boolean","r: RankFunction<In>","options: Partial<RankOptions>","best: In | undefined","value: In","message: any","value: T1","fn: (value: Exclude<TIn, undefined>) => TOut","value: TIn","value: TIn | undefined","fn: () => TOut","a: T","b: T","itemToMakeStringFor: V","eq?: (a: TIn, b: TIn) => boolean","lastValue: TIn | undefined","value: TIn","seen: TIn[]","toString?: (value: TIn) => string"],"sources":["../../process/src/basic.ts","../../process/src/cancel-error.ts","../../process/src/flow.ts","../../process/src/if-undefined.ts","../../process/src/util.ts","../../process/src/seen.ts"],"sourcesContent":["import type { Process, RankFunction, RankOptions } from \"./types.js\";\nexport type { Process } from \"./types.js\";\n/**\n * Outputs the current largest-seen value\n * @returns \n */\nexport const max = (): Process<number | number[], number> => {\n  let max = Number.MIN_SAFE_INTEGER;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      max = Math.max(subValue, max);\n    }\n    return max;\n  }\n  return compute;\n}\n\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = (): Process<number | number[], number> => {\n  let min = Number.MAX_SAFE_INTEGER;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      min = Math.min(subValue, min);\n    }\n    return min;\n  }\n  return compute;\n}\n\n/**\n * Returns a sum of values\n * @returns \n */\nexport const sum = (): Process<number | number[], number> => {\n  let t = 0;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      t += subValue;\n    }\n    return t;\n  }\n  return compute;\n}\n\n/**\n * Returns the current average of input values\n * @returns \n */\nexport const average = (): Process<number | number[], number> => {\n  let total = 0;\n  let tally = 0;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      tally++;\n      total += subValue;\n    }\n    return total / tally;\n  }\n  return compute;\n}\n\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems \n * @returns \n */\nexport const tally = (countArrayItems: boolean): Process<any, number> => {\n  let t = 0;\n  const compute = (value: number | number[]) => {\n    if (countArrayItems) {\n      if (Array.isArray(value)) t += value.length;\n      else t++;\n    } else {\n      t++;\n    }\n    return t;\n  }\n  return compute;\n}\n\n\n\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r \n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}) {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  let best: In | undefined;\n  return (value: In) => {\n    if (includeType && typeof value !== includeType) return;\n    if (best === undefined) {\n      best = value;\n      return best;\n    } else {\n      const result = r(value, best);\n      //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n      if (result == `a`) {\n        // New value is the current best\n        best = value;\n        return best;\n      } else if (result === `eq` && emitEqualRanked) {\n        // New value is same rank as previous, but we have flag on\n        return best;\n      } else if (emitRepeatHighest) {\n        // Emit current highest due to flag\n        return best;\n      }\n    }\n  }\n}\n\n\n","export class CancelError extends Error {\n  constructor(message: any) {\n    super(message);\n    this.name = `CancelError`;\n  }\n}","import { CancelError } from \"./cancel-error.js\";\nimport type { Process, Processors } from \"./types.js\";\nexport function flow<T1, T2>(...processors: [ Process<T1, T2> ]): (value: T1) => T2;\nexport function flow<T1, T2, T3>(...processors: [ Process<T1, T2>, Process<T2, T3> ]): (value: T1) => T3;\nexport function flow<T1, T2, T3, T4>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4> ]): (value: T1) => T4;\nexport function flow<T1, T2, T3, T4, T5>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5> ]): (value: T1) => T5;\nexport function flow<T1, T2, T3, T4, T5, T6>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5>, Process<T5, T6> ]): (value: T1) => T6;\n\n/**\n * Creates a flow of data processors (up to 5 are supported).\n * The flow is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = flow(\n *  (value:string) => value.toUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A') // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param processors \n * @returns \n */\nexport function flow<T1, T2, T3, T4, T5, T6>(...processors: Processors<T1, T2, T3, T4, T5, T6>): (value: T1) => T2 | T3 | T4 | T5 | T6 {\n  return (value: T1) => {\n    let v = value;\n    for (const p of processors) {\n      try {\n        // @ts-expect-error\n        v = p(v) as T1;\n      } catch (err) {\n        if (err instanceof CancelError) {\n          break;\n        } else {\n          throw err;\n        }\n      }\n    }\n    return v as T2 | T3 | T4 | T5 | T6;\n  }\n}\n","import { CancelError } from \"./cancel-error.js\";\n\n\n/**\n * Calls a function if the input value is not undefined.\n * Return value from function is passed to next function in flow.\n * \n * ```js\n * const flow = Process.flow(\n *  Process.max(),\n *  Process.seenLastToUndefined(),\n *  Process.ifNotUndefined(v => {\n *    console.log(`v:`, v);\n *  })\n * );\n * flow(100); // Prints 'v:100'\n * flow(90);  // Nothing happens max value has not changed\n * flow(110); // Prints 'v:110'\n * ```\n * @param fn \n * @returns \n */\nexport function ifNotUndefined<TIn, TOut>(fn: (value: Exclude<TIn, undefined>) => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return value;\n    const v = fn(value as Exclude<TIn, undefined>);\n    return v;\n  }\n}\n\n\n\n/**\n * Cancels the remaining flow operations if _undefined_ is an input.\n * See also {@link ifUndefined} or {@link ifNotUndefined}.\n * \n * ```js\n * const c3 = Process.flow(\n *  Basic.max(),\n *  Process.seenLastToUndefined(),\n *  Process.cancelIfUndefined(),\n *  (v => {\n *   console.log(v);\n *  })\n * );\n * c3(100); // Prints '100'\n * c3(90);  // Doesn't print anything since max does not change\n * c3(110); // Prints '110'\n * ```\n * @returns \n */\nexport function cancelIfUndefined<TIn>() {\n  return (value: TIn | undefined) => {\n    if (value === undefined) throw new CancelError(`cancel`);\n    return value as TIn;\n  }\n}\n/**\n * Returns the output of `fn` if the input value is _undefined_.\n * See also: {@link ifNotUndefined} and {@link cancelIfUndefined}.\n * @param fn \n * @returns \n */\nexport function ifUndefined<TIn, TOut>(fn: () => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return fn();\n    else return value;\n  }\n}","/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);","import type { Process } from \"./types.js\";\nimport { isEqualDefault, toStringDefault } from \"./util.js\";\n\n/**\n * If a value is same as the previous value, _undefined_ is emitted instead.\n * \n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenLastToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  if (typeof eq === `undefined`) eq = isEqualDefault;\n  let lastValue: TIn | undefined;\n  return (value: TIn) => {\n    if (value !== lastValue) {\n      lastValue = value;\n      return value;\n    }\n    return undefined;\n  }\n}\n\n/**\n * If a value is same as any previously-seen value, _undefined_ is emitted instead.\n * \n * It stores all previous values and compares against them for each new value. \n * This would likely be not very efficient compared to {@link seenToUndefinedByKey} which uses a one-time computed\n * key and efficient storage of only the keys (using a Set).\n *  \n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  const seen: TIn[] = [];\n  if (typeof eq === `undefined`) eq = isEqualDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    for (const s of seen) {\n      if (eq(s, value)) return;\n    }\n    seen.push(value);\n    return value;\n  }\n}\n\n/**\n * If a value is the same as any previously-seen value, _undefined_ is emitted instead.\n * \n * This version uses a function to create a string key of the object, by default JSON.stringify.\n * Thus we don't need to store all previously seen objects, just their keys.\n * \n * Alternatively, if a key function doesn't make sense for the value, use\n * {@link seenToUndefined}, which stores the values (less efficient).\n * \n * @param toString \n * @returns \n */\nexport function seenToUndefinedByKey<TIn>(toString?: (value: TIn) => string): Process<TIn, TIn | undefined> {\n  const seen = new Set<string>();\n  if (typeof toString === `undefined`) toString = toStringDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    const key = toString(value);\n    if (seen.has(key)) return;\n    seen.add(key);\n    return value;\n  }\n}"],"mappings":"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"}