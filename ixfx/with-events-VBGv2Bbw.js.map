{"version":3,"file":"with-events-VBGv2Bbw.js","names":["#debug","#sm","#smInitial","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt"],"sources":["../packages/flow/dist/src/state-machine/state-machine.js","../packages/flow/dist/src/state-machine/with-events.js"],"sourcesContent":["import { unique } from '@ixfx/arrays';\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = (toClone) => {\n    return Object.freeze({\n        value: toClone.value,\n        visited: [...toClone.visited],\n        machine: toClone.machine,\n    });\n};\n/**\n * Initialises a state machine\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * StateMachineLight.isDdone(sm); // false\n * StateMachineLight.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = (stateMachine, initialState) => {\n    const [machine, machineValidationError] = validateMachine(stateMachine);\n    if (!machine)\n        throw new Error(machineValidationError);\n    const state = \n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState) ?? Object.keys(machine.states)[0];\n    if (typeof machine.states[state] === `undefined`) {\n        throw new TypeError(`Initial state ('${state}') not found`);\n    }\n    // Normalise states\n    const transitions = validateAndNormaliseTransitions(machine.states);\n    if (transitions === undefined) {\n        throw new Error(`Could not normalise transitions`);\n    }\n    return Object.freeze({\n        value: state,\n        visited: [],\n        machine: Object.freeze(Object.fromEntries(transitions)),\n    });\n};\nexport const reset = (sm) => {\n    return init(sm.machine);\n};\nexport const validateMachine = (smOrTransitions) => {\n    if (typeof smOrTransitions === `undefined`) {\n        return [undefined, `Parameter undefined`];\n    }\n    if (smOrTransitions === null) {\n        return [undefined, `Parameter null`];\n    }\n    if (`states` in smOrTransitions) {\n        // Assume Machine type\n        return [smOrTransitions, ``];\n    }\n    if (typeof smOrTransitions === `object`) {\n        return [\n            {\n                states: smOrTransitions,\n            },\n            ``,\n        ];\n    }\n    return [\n        undefined,\n        `Unexpected type: ${typeof smOrTransitions}. Expected object`,\n    ];\n};\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = (sm) => {\n    return possible(sm).length === 0;\n};\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = (sm) => {\n    // Validate current state\n    validateMachineState(sm);\n    // get list of possible targets\n    const fromS = sm.machine[sm.value];\n    if (fromS.length === 1 && fromS[0].state === null)\n        return [];\n    return fromS;\n};\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = (sm) => {\n    const targets = possibleTargets(sm);\n    return targets.map((v) => v.state);\n};\nexport const normaliseTargets = (targets) => {\n    const normaliseSingleTarget = (target) => {\n        // Terminal target\n        if (target === null)\n            return { state: null };\n        // String is the target state\n        if (typeof target === `string`) {\n            return {\n                state: target,\n            };\n        }\n        else if (typeof target === `object` && `state` in target) {\n            const targetState = target.state;\n            if (typeof targetState !== `string`) {\n                throw new TypeError(`Target 'state' field is not a string. Got: ${typeof targetState}`);\n            }\n            if (`preconditions` in target) {\n                return {\n                    state: targetState,\n                    preconditions: target.preconditions,\n                };\n            }\n            return { state: targetState };\n        }\n        else {\n            throw new Error(`Unexpected type: ${typeof target}. Expected string or object with 'state' field.`);\n        }\n    };\n    // Array of targets (either strings or objects)\n    if (Array.isArray(targets)) {\n        let containsNull = false;\n        const mapResults = targets.map((t) => {\n            const r = normaliseSingleTarget(t);\n            if (!r)\n                throw new Error(`Invalid target`);\n            containsNull = containsNull || r.state === null;\n            return r;\n        });\n        if (containsNull && mapResults.length > 1) {\n            throw new Error(`Cannot have null as an possible state`);\n        }\n        return mapResults;\n    }\n    else {\n        const target = normaliseSingleTarget(targets);\n        if (!target)\n            return;\n        return [target];\n    }\n};\nconst validateAndNormaliseTransitions = (d) => {\n    const returnMap = new Map();\n    // 1. Index top-level states\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        if (typeof topLevelState === `undefined`) {\n            throw new TypeError(`Top-level undefined state`);\n        }\n        if (typeof topLevelTargets === `undefined`) {\n            throw new TypeError(`Undefined target state for ${topLevelState}`);\n        }\n        if (returnMap.has(topLevelState)) {\n            throw new Error(`State defined twice: ${topLevelState}`);\n        }\n        if (topLevelState.includes(` `)) {\n            throw new Error(`State names cannot contain spaces`);\n        }\n        returnMap.set(topLevelState, []);\n    }\n    // 2. Normalise target\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        const targets = normaliseTargets(topLevelTargets);\n        if (targets === undefined)\n            throw new Error(`Could not normalise target`);\n        if (targets !== null) {\n            // Check that they all exist as top-level states\n            const seenStates = new Set();\n            for (const target of targets) {\n                if (seenStates.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' already exists for '${topLevelState}'`);\n                }\n                seenStates.add(target.state);\n                if (target.state === null)\n                    continue;\n                if (!returnMap.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' is not defined as a top-level state. Defined under: '${topLevelState}'`);\n                }\n            }\n            returnMap.set(topLevelState, targets);\n        }\n    }\n    return returnMap;\n};\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = (state) => {\n    if (typeof state === `undefined`) {\n        throw new TypeError(`Param 'state' is undefined`);\n    }\n    if (typeof state.value !== `string`) {\n        throw new TypeError(`Existing state is not a string`);\n    }\n};\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = (sm, toState) => {\n    validateMachineState(sm); // throws if not OK\n    validateTransition(sm, toState); // throws if not OK\n    return Object.freeze({\n        value: toState,\n        machine: sm.machine,\n        visited: unique([sm.visited, [sm.value]]),\n    });\n};\nexport const next = (sm) => {\n    //validateMachineState(sm);\n    const first = possibleTargets(sm).at(0);\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (!first || first.state === null) {\n        throw new Error(`Not possible to move to a next state from '${sm.value}`);\n    }\n    return to(sm, first.state);\n};\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = (sm, toState) => {\n    try {\n        validateTransition(sm, toState);\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nexport const validateTransition = (sm, toState) => {\n    if (toState === null)\n        throw new Error(`Cannot transition to null state`);\n    if (typeof toState === `undefined`) {\n        throw new Error(`Cannot transition to undefined state`);\n    }\n    if (typeof toState !== `string`) {\n        throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof toState}`);\n    }\n    //const toS = sm.machine[toState];\n    //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n    const p = possible(sm);\n    if (p.length === 0)\n        throw new Error(`Machine is in terminal state`);\n    if (!p.includes(toState)) {\n        throw new Error(`Target state '${toState}' not available at current state '${sm.value}'. Possible states: ${p.join(`, `)}`);\n    }\n};\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n *\n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length <= 2)\n        throw new Error(`Expects at least two states`);\n    for (let index = 0; index < states.length; index++) {\n        const s = states[index];\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = (index === states.length - 1) ? null : states[index + 1];\n    }\n    return t;\n};\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n *\n * See also {@link fromList}.\n *\n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length < 2)\n        throw new Error(`Expects at least two states`);\n    for (const [index, s] of states.entries()) {\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = [];\n    }\n    for (let index = 0; index < states.length; index++) {\n        const v = t[states[index]];\n        if (index === states.length - 1) {\n            if (states.length > 1) {\n                v.push(states[index - 1]);\n            }\n            else {\n                t[states[index]] = null;\n            }\n        }\n        else {\n            v.push(states[index + 1]);\n            if (index > 0)\n                v.push(states[index - 1]);\n        }\n    }\n    return t;\n};\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n/**\n * A state machine that fires events when state changes.\n *\n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents extends SimpleEventEmitter {\n    #sm;\n    #smInitial;\n    #debug;\n    #isDoneNeedsFiring = false;\n    #isDone = false;\n    #changedAt = elapsedInfinity();\n    /**\n     * Create a state machine with initial state, description and options\n     * @param m Machine description\n     * @param opts Options for machine (defaults to `{debug:false}`)\n     */\n    constructor(m, opts = {}) {\n        super();\n        this.#debug = opts.debug ?? false;\n        this.#sm = StateMachine.init(m, opts.initial);\n        this.#smInitial = StateMachine.cloneState(this.#sm);\n    }\n    #setIsDone(v) {\n        if (this.#isDone === v)\n            return;\n        this.#isDone = v;\n        if (v) {\n            this.#isDoneNeedsFiring = true;\n            setTimeout(() => {\n                if (!this.#isDoneNeedsFiring)\n                    return;\n                this.#isDoneNeedsFiring = false;\n                //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n                this.fireEvent(`stop`, { state: this.#sm.value });\n            }, 2);\n        }\n        else {\n            this.#isDoneNeedsFiring = false;\n        }\n    }\n    /**\n     * Return a list of possible states from current state.\n     *\n     * If list is empty, no states are possible. Otherwise lists\n     * possible states, including 'null' for terminal\n     */\n    get statesPossible() {\n        return StateMachine.possible(this.#sm);\n    }\n    /**\n     * Return a list of all defined states\n     */\n    get statesDefined() {\n        return Object.keys(this.#sm.machine);\n    }\n    /**\n     * Moves to the next state if possible. If multiple states are possible, it will use the first.\n     * If machine is finalised, no error is thrown and null is returned.\n     *\n     * @returns {(string|null)} Returns new state, or null if machine is finalised\n     */\n    next() {\n        const p = StateMachine.possible(this.#sm);\n        if (p.length === 0)\n            return null;\n        this.state = p[0];\n        return p[0];\n    }\n    /**\n     * Returns _true_ if state machine is in its final state\n     *\n     * @returns\n     */\n    get isDone() {\n        return StateMachine.isDone(this.#sm);\n    }\n    /**\n     * Resets machine to initial state\n     */\n    reset() {\n        this.#setIsDone(false);\n        this.#sm = StateMachine.cloneState(this.#smInitial);\n        this.#changedAt = elapsedSince();\n    }\n    /**\n     * Throws if it's not valid to transition to `newState`\n     * @param newState\n     * @returns\n     */\n    validateTransition(newState) {\n        StateMachine.validateTransition(this.#sm, newState);\n    }\n    /**\n     * Returns _true_ if `newState` is valid transition from current state.\n     * Use {@link validateTransition} if you want an explanation for the _false_ results.\n     * @param newState\n     * @returns\n     */\n    isValid(newState) {\n        return StateMachine.isValidTransition(this.#sm, newState);\n    }\n    /**\n     * Gets or sets state. Throws an error if an invalid transition is attempted.\n     * Use `isValid()` to check validity without changing.\n     *\n     * If `newState` is the same as current state, the request is ignored silently.\n     */\n    set state(newState) {\n        const priorState = this.#sm.value;\n        if (newState === this.#sm.value)\n            return;\n        // Try to change state\n        this.#sm = StateMachine.to(this.#sm, newState);\n        if (this.#debug) {\n            console.log(`StateMachine: ${priorState} -> ${newState}`);\n        }\n        this.#changedAt = elapsedSince();\n        setTimeout(() => {\n            this.fireEvent(`change`, { newState: newState, priorState: priorState });\n        }, 1);\n        if (StateMachine.isDone(this.#sm))\n            this.#setIsDone(true);\n    }\n    get state() {\n        return this.#sm.value;\n    }\n    /**\n     * Returns timestamp when state was last changed.\n     * See also `elapsed`\n     */\n    get changedAt() {\n        return this.#changedAt();\n    }\n    /**\n     * Returns milliseconds elapsed since last state change.\n     * See also `changedAt`\n     */\n    get elapsed() {\n        return this.#changedAt();\n    }\n}\n"],"mappings":"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"}