{"version":3,"file":"numeric-arrays-DwffyOZ3.js","names":[],"sources":["../../numbers/dist/src/numeric-arrays.js"],"sourcesContent":["/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (data, fn) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof data}`);\n    const weightingFunction = fn ?? ((x) => x);\n    return data.map((value, index) => {\n        if (typeof value !== `number`)\n            throw new TypeError(`Param 'data' contains non-number at index: '${index}'. Type: '${typeof value}' value: '${value}'`);\n        const relativePos = index / (data.length - 1);\n        const weightForPosition = weightingFunction(relativePos);\n        if (typeof weightForPosition !== `number`)\n            throw new TypeError(`Weighting function returned type '${typeof weightForPosition}' rather than number for input: '${relativePos}'`);\n        const finalResult = value * weightForPosition;\n        //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n        return finalResult;\n    });\n};\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data) => data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (values) => {\n    let r = 0;\n    const length = values[0].length;\n    for (let index = 0; index < length; index++) {\n        let t = 0;\n        for (const [p, value] of values.entries()) {\n            if (p === 0)\n                t = value[index];\n            else {\n                t *= value[index];\n            }\n        }\n        r += t;\n    }\n    return r;\n};\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link numberArrayCompute} if you want min, max and total as well.\n *\n * @example\n * ```js\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data) => {\n    // âœ” UNIT TESTED\n    if (data === undefined)\n        throw new Error(`data parameter is undefined`);\n    const valid = validNumbers(data);\n    const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n    return total / valid.length;\n};\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data) => Math.min(...validNumbers(data));\n/**\n * Returns the index of the largest value.\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data) => data.reduce((bestIndex, value, index, array) => value > array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data) => data.reduce((bestIndex, value, index, array) => value < array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data) => Math.max(...validNumbers(data));\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data) => data.reduce((previous, current) => {\n    if (typeof current !== `number`)\n        return previous;\n    if (Number.isNaN(current))\n        return previous;\n    if (!Number.isFinite(current))\n        return previous;\n    return previous + current;\n}, 0);\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.max(m, datum);\n    }\n    return m;\n};\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data) => {\n    let m = 0;\n    for (const datum of data) {\n        m += datum;\n    }\n    return m;\n};\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.min(m, datum);\n    }\n    return m;\n};\n"],"mappings":";;;;;;;AAkDA,MAAa,eAAe,CAAC,SAAS,KAAK,OAAO,CAAC,MAAM,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,MAAM,EAAE,CAAC;;;;;;AAMnG,MAAa,aAAa,CAAC,WAAW;CAClC,IAAI,IAAI;CACR,MAAM,SAAS,OAAO,GAAG;AACzB,MAAK,IAAI,QAAQ,GAAG,QAAQ,QAAQ,SAAS;EACzC,IAAI,IAAI;AACR,OAAK,MAAM,CAAC,GAAG,MAAM,IAAI,OAAO,SAAS,CACrC,KAAI,MAAM,GACN,IAAI,MAAM;OAEV,KAAK,MAAM;EAGnB,KAAK;CACR;AACD,QAAO;AACV;;;;;;;;;;;AA4DD,MAAa,WAAW,CAAC,GAAG,SAAS,KAAK,OAAO,CAAC,WAAW,OAAO,OAAO,UAAU,QAAQ,MAAM,aAAa,QAAQ,WAAW,EAAE;;;;;;;;;;;AAWrI,MAAa,MAAM,CAAC,SAAS,KAAK,IAAI,GAAG,aAAa,KAAK,CAAC;;;;;;;;;;;;AA+B5D,MAAa,UAAU,CAAC,SAAS;CAC7B,IAAI,IAAI,OAAO;AACf,MAAK,MAAM,SAAS,MAChB,IAAI,KAAK,IAAI,GAAG,MAAM;AAE1B,QAAO;AACV;;;;;;;;;;;;AAYD,MAAa,YAAY,CAAC,SAAS;CAC/B,IAAI,IAAI;AACR,MAAK,MAAM,SAAS,MAChB,KAAK;AAET,QAAO;AACV;;;;;;;;;;;;AAYD,MAAa,UAAU,CAAC,SAAS;CAC7B,IAAI,IAAI,OAAO;AACf,MAAK,MAAM,SAAS,MAChB,IAAI,KAAK,IAAI,GAAG,MAAM;AAE1B,QAAO;AACV"}