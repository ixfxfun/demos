{"version":3,"file":"ui.js","names":["manual","iterator","value","debounce","debounceReactive","init","elem: Readonly<Element>","interval?: Interval","elapsed?: Interval","opts: MutationObserverInit","initialValue?: HslScalar","v: HslScalar","hsl: HslScalar","targetOrQuery: HTMLInputElement | string","options: Partial<DomNumberInputValueOptions>","value: number","options: Partial<DomValueOptions>","target: HTMLInputElement | null","value: string | null | undefined","value: string","v: any","formElOrQuery: HTMLFormElement | string","options: Partial<DomFormOptions<T>>","entries: [ string, unknown ][]","name: string","value: any","value: T","query: string","elements","source: Rx.Reactive<TSource>","elOrQuery: string | HTMLElement | null","bindOpts: Partial<DomBindSourceValue<TSource, string>>","elOrQuery: string | HTMLInputElement | null","bindOpts: DomBindSourceValue<TSource, string>","b: DomBindValueTarget[]","bind","bind: DomBindValueTarget","element: HTMLElement","value: any","v: any","_: any","_element: HTMLElement","bind: DomBindSourceValue<TSource, TDestination>","value: TSource","binds: DomBindResolvedSource<TSource, TDestination>[]","removeElements: boolean","source: Rx.Reactive<V>","elOrQuery: string | HTMLElement","updater: (v: V, el: HTMLElement) => void","value: V","removeElement: boolean","source: Rx.ReactiveDiff<V>","updater: (diffs: Pathed.PathDataChange<any>[], el: HTMLElement) => void","opts: Partial<BindUpdateOpts<V>>","value: Pathed.PathDataChange<any>[]","init","source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>)","options: Partial<ElementsOptions>","path: string","mapFindBySomeKey","el: HTMLElement","changes: (Pathed.PathDataChange<any> | Pathed.PathData<any>)[]","changes","args: Event | undefined"],"sources":["../../rx/dist/src/from/function.js","../../rx/dist/src/from/iterator.js","../../rx/dist/src/util.js","../../rx/dist/src/resolve-source.js","../../rx/dist/src/init-stream.js","../../rx/dist/src/from/object.js","../../rx/dist/src/to-readable.js","../../rx/dist/src/from/event.js","../../rx/dist/src/ops/transform.js","../../rx/dist/src/reactives/debounce.js","../../rx/dist/src/ops/debounce.js","../../rx/dist/src/index.js","../../rx/dist/src/from/observable.js","../../ui/src/rx/browser-resize.ts","../../ui/src/rx/browser-theme-change.ts","../../ui/src/rx/colour.ts","../../ui/src/rx/dom-source.ts","../../ui/src/rx/dom.ts","../../ui/src/rx/index.ts"],"sourcesContent":["import { continuously, intervalToMs } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport { sleep } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n *\n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n *\n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it.\n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n *\n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n *\n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber\n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback\n * @param options\n * @returns\n */\nexport function func(callback, options = {}) {\n    const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n    const closeOnError = options.closeOnError ?? true;\n    const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n    let manual = options.manual ?? false;\n    // If niether interval or manual is set, assume manual\n    if (options.interval === undefined && options.manual === undefined)\n        manual = true;\n    if (manual && options.interval)\n        throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n    const predelay = intervalToMs(options.predelay, 0);\n    const lazy = options.lazy ?? `very`;\n    const signal = options.signal;\n    const internalAbort = new AbortController();\n    const internalAbortCallback = (reason) => { internalAbort.abort(reason); };\n    let sentResults = 0;\n    let enabled = false;\n    const done = (reason) => {\n        events.dispose(reason);\n        enabled = false;\n        if (run)\n            run.cancel();\n    };\n    const ping = async () => {\n        if (!enabled)\n            return false;\n        if (predelay)\n            await sleep(predelay);\n        if (sentResults >= maximumRepeats) {\n            done(`Maximum repeats reached ${maximumRepeats.toString()}`);\n            return false;\n        }\n        //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n        try {\n            if (signal?.aborted) {\n                done(`Signal (${signal.aborted})`);\n                return false;\n            }\n            const value = await callback(internalAbortCallback);\n            sentResults++;\n            events.set(value);\n            return true;\n        }\n        catch (error) {\n            if (closeOnError) {\n                done(`Function error: ${getErrorMessage(error)}`);\n                return false;\n            }\n            else {\n                events.signal(`warn`, getErrorMessage(error));\n                return true;\n            }\n        }\n    };\n    const run = manual ? undefined : continuously(async () => {\n        const pingResult = await ping();\n        if (!pingResult)\n            return false;\n        // if (!loop) {\n        //   done(`fromFunction done`);\n        //   return false; // Stop loop\n        // }\n        if (internalAbort.signal.aborted) {\n            done(`callback function aborted (${internalAbort.signal.reason})`);\n            return false;\n        }\n    }, intervalMs);\n    const events = initLazyStream({\n        lazy,\n        onStart() {\n            enabled = true;\n            if (run)\n                run.start();\n        },\n        onStop() {\n            enabled = false;\n            if (run)\n                run.cancel();\n        },\n    });\n    if (lazy === `never` && run)\n        run.start();\n    return { ...events, ping };\n}\n","import { nextWithTimeout } from \"@ixfx/iterables/async\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { isAsyncIterable } from \"@ixfx/iterables\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen\n * @returns\n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n *\n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source\n */\nexport function iterator(source, options = {}) {\n    const lazy = options.lazy ?? `very`;\n    const log = options.traceLifecycle ? (message) => { console.log(`Rx.From.iterator ${message}`); } : (_) => { };\n    const readIntervalMs = intervalToMs(options.readInterval, 5);\n    const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n    const whenStopped = options.whenStopped ?? `continue`;\n    let iterator;\n    //let reading = false;\n    let ourAc;\n    let sm = StateMachine.init({\n        idle: [`wait_for_next`],\n        wait_for_next: [`processing_result`, `stopping`, `disposed`],\n        processing_result: [`queued`, `disposed`, `stopping`],\n        queued: [`wait_for_next`, `disposed`, `stopping`],\n        stopping: `idle`,\n        disposed: null\n    }, `idle`);\n    const onExternalSignal = () => {\n        log(`onExternalSignal`);\n        ourAc?.abort(options.signal?.reason);\n    };\n    if (options.signal) {\n        options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n    }\n    ;\n    const read = async () => {\n        log(`read. State: ${sm.value}`);\n        ourAc = new AbortController();\n        try {\n            sm = StateMachine.to(sm, `wait_for_next`);\n            const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n            sm = StateMachine.to(sm, `processing_result`);\n            ourAc.abort(`nextWithTimeout completed`);\n            if (v.done) {\n                log(`read v.done true`);\n                events.dispose(`Generator complete`);\n                //reading = false;\n                sm = StateMachine.to(sm, `disposed`);\n            }\n            //if (!reading) return;\n            if (sm.value === `stopping`) {\n                log(`read. sm.value = stopping`);\n                sm = StateMachine.to(sm, `idle`);\n                return;\n            }\n            if (sm.value === `disposed`) {\n                log(`read. sm.value = disposed`);\n                return;\n            }\n            events.set(v.value);\n        }\n        catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            events.dispose(`Generator error: ${error.toString()}`);\n            return;\n        }\n        //if (events.isDisposed()) return;\n        //if (!reading) return;\n        if (sm.value === `processing_result`) {\n            sm = StateMachine.to(sm, `queued`);\n            log(`scheduling read. State: ${sm.value}`);\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            setTimeout(read, readIntervalMs);\n        }\n        else {\n            sm = StateMachine.to(sm, `idle`);\n        }\n    };\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            log(`onStart state: ${sm.value} whenStopped: ${whenStopped}`);\n            if (sm.value !== `idle`)\n                return;\n            if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n            //reading = true;\n            void read();\n        },\n        onStop() {\n            log(`onStop state: ${sm.value} whenStopped: ${whenStopped}`);\n            //reading = false;\n            sm = StateMachine.to(sm, `stopping`);\n            if (whenStopped === `reset`) {\n                log(`onStop reiniting iterator`);\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n        },\n        onDispose(reason) {\n            log(`onDispose (${reason})`);\n            ourAc?.abort(`Rx.From.iterator disposed (${reason})`);\n            if (options.signal)\n                options.signal.removeEventListener(`abort`, onExternalSignal);\n        },\n    });\n    // const readingStart = () => {\n    // }\n    //if (!lazy) readingStart();\n    // return {\n    //   on: events.on,\n    //   value: events.value,\n    //   dispose: events.dispose,\n    //   isDisposed: events.isDisposed\n    // }\n    return events;\n}\n","import { isIterable } from \"@ixfx/iterables\";\nexport function messageIsSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal !== undefined)\n        return true;\n    return false;\n}\nexport function messageIsDoneSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal === `done`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v\n * @returns\n */\nexport function messageHasValue(v) {\n    if (v.value !== undefined)\n        return true;\n    return false;\n}\nexport const isPingable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`ping` in rx) {\n        return true;\n    }\n    return false;\n};\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx\n * @returns\n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx\n * @returns\n */\nexport const isWritable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`set` in rx)\n        return true;\n    return false;\n};\nexport const isWrapped = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (!(`source` in v))\n        return false;\n    if (!(`annotate` in v))\n        return false;\n    return true;\n};\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\nexport const opify = (fn, ...args) => {\n    return (source) => {\n        return fn(source, ...args);\n    };\n};\nexport const isTriggerValue = (t) => (`value` in t);\nexport const isTriggerFunction = (t) => (`fn` in t);\nexport const isTriggerGenerator = (t) => isIterable(t);\nexport const isTrigger = (t) => {\n    if (typeof t !== `object`)\n        return false;\n    if (isTriggerValue(t))\n        return true;\n    if (isTriggerFunction(t))\n        return true;\n    if (isTriggerGenerator(t))\n        return true;\n    return false;\n};\n/**\n * Resolves a trigger value.\n *\n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t\n * @returns\n */\nexport function resolveTriggerValue(t) {\n    if (isTriggerValue(t))\n        return [t.value, false];\n    if (isTriggerFunction(t)) {\n        const v = t.fn();\n        if (v === undefined)\n            return [undefined, true];\n        return [v, false];\n    }\n    if (isTriggerGenerator(t)) {\n        const v = t.gen.next();\n        if (v.done)\n            return [undefined, true];\n        return [v.value, false];\n    }\n    throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}\n","import { isAsyncIterable, isIterable } from \"@ixfx/iterables\";\nimport { func } from \"./from/function.js\";\nimport { iterator } from \"./from/iterator.js\";\nimport { isReactive, isWrapped } from \"./util.js\";\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n *\n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source\n * @returns\n */\nexport const resolveSource = (source, options = {}) => {\n    if (isReactive(source))\n        return source;\n    const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 };\n    const functionOptions = options.function ?? { lazy: `very` };\n    if (Array.isArray(source)) {\n        return iterator(source.values(), generatorOptions);\n    }\n    else if (typeof source === `function`) {\n        return func(source, functionOptions);\n    }\n    else if (typeof source === `object`) {\n        //console.log(`resolveSource is object`);\n        if (isWrapped(source)) {\n            //console.log(`resolveSource is object - wrapped`);\n            return source.source;\n        }\n        if (isIterable(source) || isAsyncIterable(source)) {\n            //console.log(`resolveSource is object - iterable`);\n            return iterator(source, generatorOptions);\n        }\n    }\n    throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof source}`);\n};\n","import { DispatchList } from \"@ixfx/flow\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsSignal } from \"./util.js\";\nimport { cache } from \"./cache.js\";\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n *\n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource\n * @param options\n * @returns\n */\nexport function initUpstream(upstreamSource, options) {\n    const lazy = options.lazy ?? `initial`;\n    const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n    const onValue = options.onValue ?? ((_v) => { });\n    const source = resolveSource(upstreamSource);\n    let unsub;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    //console.log(`initUpstream${ debugLabel } creating`);\n    const onStop = () => {\n        //console.log(`Rx.initStream${ debugLabel } stop`);\n        if (unsub === undefined)\n            return;\n        unsub();\n        unsub = undefined;\n        if (options.onStop)\n            options.onStop();\n    };\n    const onStart = () => {\n        //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n        if (unsub !== undefined)\n            return;\n        if (options.onStart)\n            options.onStart();\n        unsub = source.on(value => {\n            //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n            if (messageIsSignal(value)) {\n                if (value.signal === `done`) {\n                    onStop();\n                    events.signal(value.signal, value.context);\n                    if (disposeIfSourceDone)\n                        events.dispose(`Upstream source ${debugLabel} has completed (${value.context ?? ``})`);\n                }\n                else {\n                    //events.through_(value);\n                    events.signal(value.signal, value.context);\n                }\n            }\n            else if (messageHasValue(value)) {\n                //lastValue = value.value;\n                onValue(value.value);\n            }\n        });\n    };\n    //const initOpts = \n    // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n    //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n    //   initLazyStream<Out>(initOpts);\n    //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart,\n        onStop\n    });\n    return events;\n}\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options\n * @returns\n */\nexport function initLazyStreamWithInitial(options) {\n    const r = initLazyStream(options);\n    const c = cache(r, options.initialValue);\n    return c;\n}\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n *\n * @param options\n * @returns\n */\nexport function initLazyStream(options) {\n    const lazy = options.lazy ?? `initial`;\n    const onStop = options.onStop ?? (() => { });\n    const onStart = options.onStart ?? (() => { });\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const events = initStream({\n        ...options,\n        onFirstSubscribe() {\n            if (lazy !== `never`) {\n                //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n                onStart();\n            }\n        },\n        onNoSubscribers() {\n            if (lazy === `very`) {\n                //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n                onStop();\n            }\n        },\n    });\n    if (lazy === `never`)\n        onStart();\n    return events;\n}\n/**\n * Initialises a new stream.\n *\n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n *\n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options\n * @returns\n */\nexport function initStream(options = {}) {\n    let dispatcher;\n    let disposed = false;\n    let firstSubscribe = false;\n    let emptySubscriptions = true;\n    const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n    const onNoSubscribers = options.onNoSubscribers ?? undefined;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const isEmpty = () => {\n        if (dispatcher === undefined)\n            return;\n        if (!dispatcher.isEmpty)\n            return;\n        if (!emptySubscriptions) {\n            emptySubscriptions = true;\n            firstSubscribe = false;\n            if (onNoSubscribers)\n                onNoSubscribers();\n        }\n    };\n    const subscribe = (handler) => {\n        if (disposed)\n            throw new Error(`Disposed, cannot subscribe ${debugLabel}`);\n        if (dispatcher === undefined)\n            dispatcher = new DispatchList();\n        //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n        const id = dispatcher.add(handler);\n        emptySubscriptions = false;\n        if (!firstSubscribe) {\n            firstSubscribe = true;\n            //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n            if (onFirstSubscribe)\n                onFirstSubscribe();\n        }\n        return () => {\n            dispatcher?.remove(id);\n            isEmpty();\n        };\n    };\n    return {\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${reason}` });\n            disposed = true;\n            if (options.onDispose)\n                options.onDispose(reason);\n        },\n        isDisposed: () => {\n            return disposed;\n        },\n        removeAllSubscribers: () => {\n            dispatcher?.clear();\n            isEmpty();\n        },\n        set: (v) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot set`);\n            dispatcher?.notify({ value: v });\n        },\n        // through: (pass: Passed<V>) => {\n        //   if (disposed) throw new Error(`Disposed, cannot through`);\n        //   dispatcher?.notify(pass)\n        // },\n        signal: (signal, context) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot signal`);\n            dispatcher?.notify({ signal, value: undefined, context });\n        },\n        on: (handler) => subscribe(handler),\n        onValue: (handler) => {\n            const unsub = subscribe(message => {\n                //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n                if (messageHasValue(message)) {\n                    handler(message.value);\n                }\n            });\n            return unsub;\n        }\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport { Pathed } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { isEqualContextString } from \"@ixfx/core\";\nimport { wildcard } from \"@ixfx/core/text\";\nimport { resultIsError, resultThrow, resultThrowSingle, resultToError } from \"@ixfx/guards\";\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n *\n * Changing the wrapped object directly does not update the Reactive.\n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n *\n * Consider using {@link From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n *\n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n *\n * Use `last()` to get the most recently set value.\n *\n * `onDiff` subscribes to a rough diff of the object.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n *\n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n *\n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns\n */\nexport function object(initialValue, options = {}) {\n    const eq = options.eq ?? isEqualContextString;\n    const setEvent = initStream();\n    const diffEvent = initStream();\n    //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n    const fieldChangeEvents = [];\n    let value = initialValue;\n    let disposed = false;\n    const set = (v) => {\n        const diff = [...Pathed.compareData(value ?? {}, v, { ...options, includeMissingFromA: true })];\n        if (diff.length === 0)\n            return;\n        value = v;\n        setEvent.set(v);\n        diffEvent.set(diff);\n    };\n    const fireFieldUpdate = (field, value) => {\n        for (const [matcher, pattern, list] of fieldChangeEvents) {\n            if (matcher(field)) {\n                list.notify({ fieldName: field, pattern, value });\n            }\n        }\n        //const l = fieldChangeEvents.get(field.toLowerCase());\n        //if (l === undefined) return;\n        //l.notify(value);\n    };\n    const updateCompareOptions = {\n        asPartial: true,\n        includeParents: true\n    };\n    const update = (toMerge) => {\n        //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n        if (value === undefined) {\n            value = toMerge;\n            setEvent.set(value);\n            for (const [k, v] of Object.entries(toMerge)) {\n                fireFieldUpdate(k, v);\n            }\n            return value;\n        }\n        else {\n            const diff = [...Pathed.compareData(value, toMerge, updateCompareOptions)];\n            //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n            if (diff.length === 0)\n                return value; // No changes\n            value = {\n                ...value,\n                ...toMerge\n            };\n            setEvent.set(value);\n            diffEvent.set(diff);\n            //console.log(`diff`, diff);\n            for (const d of diff) {\n                fireFieldUpdate(d.path, d.value);\n            }\n            return value;\n        }\n    };\n    const updateField = (path, valueForField) => {\n        if (value === undefined)\n            throw new Error(`Cannot update value when it has not already been set`);\n        //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n        const existing = Pathed.getField(value, path);\n        //resultThrowSingle(existing);\n        if (resultIsError(existing)) {\n            throw resultToError(existing);\n        }\n        //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n        if (eq(existing.value, valueForField, path)) {\n            //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n            return;\n        }\n        let diff = [...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true })];\n        diff = diff.map(d => {\n            if (d.path.length > 0)\n                return { ...d, path: path + `.` + d.path };\n            return { ...d, path };\n        });\n        //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n        const o = Pathed.updateByPath(value, path, valueForField, true);\n        value = o;\n        //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n        setEvent.set(o);\n        diffEvent.set(diff);\n        fireFieldUpdate(path, valueForField);\n        //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n    };\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    return {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        /**\n         * Update a field.\n         * Exception is thrown if field does not exist\n         */\n        updateField,\n        last: () => value,\n        on: setEvent.on,\n        onValue: setEvent.onValue,\n        onDiff: diffEvent.onValue,\n        onField(fieldPattern, handler) {\n            const matcher = wildcard(fieldPattern);\n            const listeners = new DispatchList();\n            fieldChangeEvents.push([matcher, fieldPattern, listeners]);\n            const id = listeners.add(handler);\n            return () => listeners.remove(id);\n            // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n            // if (listeners === undefined) {\n            //   listeners = new DispatchList();\n            //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n            // }\n            // const id = listeners.add((value) => {\n            //   setTimeout(() => { handler(value, fieldName) }, 1);\n            // });\n            // return () => listeners.remove(id);\n        },\n        /**\n         * Set the whole object\n         */\n        set,\n        /**\n         * Update the object with a partial set of fields and values\n         */\n        update\n    };\n}\n","/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = (stream) => ({\n    on: stream.on,\n    dispose: stream.dispose,\n    isDisposed: stream.isDisposed,\n    onValue: stream.onValue\n});\n","import { field } from \"../ops/field.js\";\nimport { object } from \"./object.js\";\nimport { initLazyStream, initLazyStreamWithInitial, initStream } from \"../init-stream.js\";\nimport { elapsedInterval } from \"@ixfx/core/elapsed\";\n/**\n * Fired when `eventName` fires on `target`.\n *\n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n *\n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId')\n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField(targetOrQuery, eventName, fieldName, initialValue, options = {}) {\n    const initial = {};\n    initial[fieldName] = initialValue;\n    const rxField = field(event(targetOrQuery, eventName, initial, options), fieldName, options);\n    return rxField;\n}\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n// export function event(targetOrQuery: EventTarget | null | string, name: `pointermove` | `pointerover` | `pointerup` | `pointerdown` | `pointerenter` | `pointercancel` | `pointerout` | `pointerleave` | `gotpointercapture` | `lostpointer`, initialValue: Partial<PointerEvent> | undefined, options: Partial<EventSourceOptions>): ReactiveInitial<PointerEvent> & Reactive<PointerEvent>;\n/**\n * Subscribes to an event, emitting data\n *\n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n *\n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n *\n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns\n */\nexport function event(targetOrQuery, name, initialValue, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const diff = options.diff ?? false;\n    const lazy = options.lazy ?? false;\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    if (initialValue === undefined)\n        initialValue = {};\n    const rxObject = object(initialValue, { deepEntries: true });\n    let eventAdded = false;\n    let disposed = false;\n    const callback = (args) => {\n        if (debugFiring)\n            console.log(`Reactive.event '${name}' firing '${JSON.stringify(args)}`);\n        rxObject.set(args);\n    };\n    const remove = () => {\n        if (!eventAdded)\n            return;\n        eventAdded = false;\n        target.removeEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event remove '${name}'`);\n        }\n    };\n    const add = () => {\n        if (eventAdded)\n            return;\n        eventAdded = true;\n        target.addEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event add '${name}'`);\n        }\n    };\n    if (!lazy)\n        add();\n    return {\n        last: () => {\n            if (lazy)\n                add();\n            return rxObject.last();\n        },\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            disposed = true;\n            remove();\n            rxObject.dispose(reason);\n        },\n        isDisposed() {\n            return disposed;\n        },\n        on: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.on(handler);\n        },\n        onValue: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.onValue(handler);\n        }\n    };\n}\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of\n * times event has been fired.\n * @param targetOrQuery\n * @param name\n * @param options\n * @returns\n */\nexport function eventTrigger(targetOrQuery, name, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const fireInitial = options.fireInitial ?? false;\n    let count = 0;\n    const elapsed = elapsedInterval();\n    const stream = initLazyStream({\n        lazy: options.lazy ?? `very`,\n        onStart() {\n            target.addEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger add '${name}'`);\n            }\n            if (fireInitial && count === 0) {\n                if (debugLifecycle || debugFiring)\n                    console.log(`Rx.From.eventTrigger: firing initial`);\n                callback();\n            }\n        },\n        onStop() {\n            target.removeEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger remove '${name}'`);\n            }\n        },\n    });\n    const callback = (_args) => {\n        if (debugFiring)\n            console.log(`Rx.From.eventTrigger '${name}' triggered'`);\n        stream.set({\n            sinceLast: elapsed(),\n            total: ++count\n        });\n    };\n    return stream;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer\n * @returns\n */\nexport function transform(input, transformer, options = {}) {\n    const traceInput = options.traceInput ?? false;\n    const traceOutput = options.traceOutput ?? false;\n    const upstream = initUpstream(input, {\n        lazy: `initial`,\n        ...options,\n        onValue(value) {\n            const t = transformer(value);\n            if (traceInput && traceOutput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)} output: ${JSON.stringify(t)}`);\n            }\n            else if (traceInput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)}`);\n            }\n            else if (traceOutput) {\n                console.log(`Rx.Ops.transform output: ${JSON.stringify(t)}`);\n            }\n            upstream.set(t);\n        },\n    });\n    return toReadable(upstream);\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n *\n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n *\n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n *\n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source\n * @param options\n * @returns\n */\nexport function debounce(source, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 50);\n    let lastValue;\n    const timer = timeout(() => {\n        const v = lastValue;\n        if (v) {\n            upstream.set(v);\n            lastValue = undefined;\n        }\n    }, elapsed);\n    const upstream = initUpstream(source, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            timer.start();\n        }\n    });\n    return toReadable(upstream);\n}\n","import { debounce as debounceReactive } from \"../reactives/debounce.js\";\nexport function debounce(options) {\n    return (source) => {\n        return debounceReactive(source, options);\n    };\n}\n","import { intervalToMs } from '@ixfx/core';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./util.js\";\nimport { initStream } from \"./init-stream.js\";\nimport { resolveSource } from './resolve-source.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\nexport * as From from './from/index.js';\nexport * as Collections from './collections/index.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * from './init-stream.js';\nexport function run(source, ...ops) {\n    let s = resolveSource(source);\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    return s;\n}\nexport function writable(source, ...ops) {\n    let s = resolveSource(source);\n    const head = s;\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    const ss = s;\n    return {\n        ...ss,\n        set(value) {\n            if (isWritable(head)) {\n                head.set(value);\n            }\n            else\n                throw new Error(`Original source is not writable`);\n        }\n    };\n    //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n    //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n    //return raw(source);\n}\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns\n */\nexport function manual(options = {}) {\n    const events = initStream(options);\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        set(value) {\n            events.set(value);\n        },\n        on: events.on,\n        onValue: events.onValue\n    };\n}\nexport const Sinks = {\n    setHtmlText: (options) => {\n        return (source) => {\n            SinkFns.setHtmlText(source, options);\n        };\n    }\n};\nexport const Ops = {\n    /**\n   * Annotates values with the result of a function.\n   * The input value needs to be an object.\n   *\n   * For every value `input` emits, run it through `annotator`, which should\n   * return the original value with additional fields.\n   *\n   * Conceptually the same as `transform`, just with typing to enforce result\n   * values are V & TAnnotation\n   * @param annotator\n   * @returns\n   */\n    annotate: (annotator) => opify(OpFns.annotate, annotator),\n    /**\n     * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n     * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n     * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n     *\n     * ```js\n     * // Emit values from an array\n     * const r1 = Rx.run(\n     *  Rx.From.array([ 1, 2, 3 ]),\n     *  Rx.Ops.annotateWithOp(\n     *    // Add the 'max' operator to emit the largest-seen value\n     *    Rx.Ops.sum()\n     *  )\n     * );\n     * const data = await Rx.toArray(r1);\n     * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n     * ```\n     * @param annotatorOp\n     * @returns\n     */\n    annotateWithOp: (annotatorOp) => opify(OpFns.annotateWithOp, annotatorOp),\n    /**\n     * Takes a stream of values and chunks them up (by quantity or time elapsed),\n     * emitting them as an array.\n     * @param options\n     * @returns\n     */\n    chunk: (options) => {\n        return (source) => {\n            return OpFns.chunk(source, options);\n        };\n    },\n    cloneFromFields: () => {\n        return (source) => {\n            return OpFns.cloneFromFields(source);\n        };\n    },\n    /**\n   * Merges values from several sources into a single source that emits values as an array.\n   * @param options\n   * @returns\n   */\n    combineLatestToArray: (options = {}) => {\n        return (sources) => {\n            return OpFns.combineLatestToArray(sources, options);\n        };\n    },\n    /**\n     * Merges values from several sources into a single source that emits values as an object.\n     * @param options\n     * @returns\n     */\n    combineLatestToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.combineLatestToObject(reactiveSources, options);\n        };\n    },\n    /**\n   * Debounce values from the stream. It will wait until a certain time\n   * has elapsed before emitting latest value.\n   *\n   * Effect is that no values are emitted if input emits faster than the provided\n   * timeout.\n   *\n   * See also: throttle\n   * @param options\n   * @returns\n   */\n    // debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    //   return (source: ReactiveOrSource<V>) => {\n    //     return OpFns.debounce(source, options);\n    //   }\n    // },\n    /**\n     * Drops values from the input stream that match `predicate`\n     * @param predicate If it returns _true_ value is ignored\n     * @returns\n     */\n    drop: (predicate) => opify(OpFns.drop, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @returns\n     */\n    elapsed: () => opify(OpFns.elapsed),\n    /**\n     * Yields the value of a field from an input stream of values.\n     * Eg if the source reactive emits `{ colour: string, size: number }`,\n     * we might use `field` to pluck out the `colour` field, thus returning\n     * a stream of string values.\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    field: (fieldName, options = {}) => {\n        return (source) => {\n            return OpFns.field(source, fieldName, options);\n        };\n    },\n    /**\n     * Filters the input stream, only re-emitting values that pass the predicate\n     * @param predicate If it returns _true_ value is allowed through\n     * @returns\n     */\n    filter: (predicate) => opify(OpFns.filter, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @param options\n     * @returns\n     */\n    interpolate: (options) => opify(OpFns.interpolate, options),\n    /**\n   * Outputs the minimum numerical value of the stream.\n   * A value is only emitted when minimum decreases.\n   * @returns\n   */\n    min: (options) => opify(OpFns.min, options),\n    /**\n     * Outputs the maxium numerical value of the stream.\n     * A value is only emitted when maximum increases.\n     * @returns\n     */\n    max: (options) => opify(OpFns.max, options),\n    sum: (options) => opify(OpFns.sum, options),\n    average: (options) => opify(OpFns.average, options),\n    tally: (options) => opify(OpFns.tally, options),\n    rank: (rank, options) => opify(OpFns.rank, rank, options),\n    pipe: (...streams) => {\n        return (source) => {\n            const resolved = resolveSource(source);\n            const s = [resolved, ...streams];\n            return OpFns.pipe(...s);\n        };\n    },\n    singleFromArray: (options = {}) => {\n        return (source) => {\n            return OpFns.singleFromArray(source, options);\n        };\n    },\n    split: (options = {}) => {\n        return (source) => {\n            return OpFns.split(source, options);\n        };\n    },\n    splitLabelled: (labels) => {\n        return (source) => {\n            return OpFns.splitLabelled(source, labels);\n        };\n    },\n    switcher: (cases, options = {}) => {\n        return (source) => {\n            return OpFns.switcher(source, cases, options);\n        };\n    },\n    syncToArray: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToArray(reactiveSources, options);\n        };\n    },\n    syncToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToObject(reactiveSources, options);\n        };\n    },\n    tapProcess: (processor) => {\n        return (source) => {\n            return OpFns.tapProcess(source, processor);\n        };\n    },\n    tapStream: (divergedStream) => {\n        return (source) => {\n            return OpFns.tapStream(source, divergedStream);\n        };\n    },\n    tapOps: (...ops) => {\n        return (source) => {\n            return OpFns.tapOps(source, ...ops);\n        };\n    },\n    /**\n   * Throttle values from the stream.\n   * Only emits a value if some minimum time has elapsed.\n   * @param options\n   * @returns\n   */\n    throttle: (options) => opify(OpFns.throttle, options),\n    /**\n     * Trigger a value if 'source' does not emit a value within an interval.\n     * Trigger value can be a fixed value, result of function, or step through an iterator.\n     * @param options\n     * @returns\n     */\n    timeoutValue: (options) => {\n        return (source) => {\n            return OpFns.timeoutValue(source, options);\n        };\n    },\n    timeoutPing: (options) => {\n        return (source) => {\n            return OpFns.timeoutPing(source, options);\n        };\n    },\n    transform: (transformer, options = {}) => {\n        return (source) => {\n            return OpFns.transform(source, transformer, options);\n        };\n    },\n    /**\n    * Reactive where last (or a given initial) value is available to read\n    * @param opts\n    * @returns\n    */\n    withValue: (opts) => {\n        return opify(OpFns.withValue, opts);\n    },\n};\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n *\n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n *\n * Throws an error if the source closes without\n * a value or the timeout is reached.\n *\n * @param source\n * @param maximumWait\n * @returns\n */\nexport async function takeNextValue(source, maximumWait = 1000) {\n    const rx = resolveSource(source);\n    let off = () => { };\n    let watchdog;\n    const p = new Promise((resolve, reject) => {\n        off = rx.on(message => {\n            if (watchdog)\n                clearTimeout(watchdog);\n            if (messageHasValue(message)) {\n                off();\n                resolve(message.value);\n            }\n            else {\n                if (messageIsDoneSignal(message)) {\n                    reject(new Error(`Source closed. ${message.context ?? ``}`));\n                    off();\n                }\n            }\n        });\n        watchdog = setTimeout(() => {\n            watchdog = undefined;\n            off();\n            reject(new Error(`Timeout waiting for value (${JSON.stringify(maximumWait)})`));\n        }, intervalToMs(maximumWait));\n    });\n    return p;\n}\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n *\n * Returns a function to unsubcribe A->B\n * @param a\n * @param b\n * @param transform\n */\nexport const to = (a, b, transform, closeBonA = false) => {\n    const unsub = a.on(message => {\n        if (messageHasValue(message)) {\n            const value = transform ? transform(message.value) : message.value;\n            b.set(value);\n        }\n        else if (messageIsDoneSignal(message)) {\n            unsub();\n            if (closeBonA) {\n                b.dispose(`Source closed (${message.context ?? ``})`);\n            }\n        }\n        else {\n            // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n        }\n    });\n    return unsub;\n};\n","import { messageHasValue } from \"../util.js\";\nimport { manual } from \"../index.js\";\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n *\n *  // To send a value:\n *  stream.set(someValue);\n *\n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n *\n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n *\n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init\n * @returns\n */\nexport function observable(init) {\n    const ow = observableWritable(init);\n    return {\n        dispose: ow.dispose,\n        isDisposed: ow.isDisposed,\n        on: ow.on,\n        onValue: ow.onValue\n    };\n}\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init\n * @returns\n */\nexport function observableWritable(init) {\n    let onCleanup = () => { };\n    const ow = manual({\n        onFirstSubscribe() {\n            onCleanup = init(ow);\n        },\n        onNoSubscribers() {\n            if (onCleanup)\n                onCleanup();\n        },\n    });\n    return {\n        ...ow,\n        onValue: (callback) => {\n            return ow.on(message => {\n                if (messageHasValue(message)) {\n                    callback(message.value);\n                }\n            });\n        }\n    };\n}\n","import type { Interval } from \"@ixfx/core\";\nimport { observable } from \"@ixfx/rx/from\";\nimport { debounce } from \"@ixfx/rx/op/debounce\";\nimport * as Rx from \"@ixfx/rx\";\n/**\n * Observe when element resizes. Specify `interval` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param interval Tiemout before event gets triggered\n * @returns\n */\nexport const browserResizeObservable = (\n  elem: Readonly<Element>,\n  interval?: Interval\n) => {\n  if (elem === null) {\n    throw new Error(`Param 'elem' is null. Expected element to observe`);\n  }\n  if (elem === undefined) {\n    throw new Error(`Param 'elem' is undefined. Expected element to observe`);\n  }\n\n  const m = observable<ResizeObserverEntry[]>(stream => {\n    const ro = new ResizeObserver((entries) => {\n      stream.set(entries);\n    });\n    ro.observe(elem);\n\n    return () => {\n      ro.unobserve(elem);\n    };\n  });\n  //return debounce({ elapsed: interval ?? 100 })(m);\n  return debounce<ResizeObserverEntry[]>({ elapsed: interval ?? 100 })(m);\n}\n\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param elapsed\n * @returns\n */\nexport const windowResize = (elapsed?: Interval) => debounce<{ innerWidth: number, innerHeight: number }>({ elapsed: elapsed ?? 100 })(Rx.From.event(window, `resize`, { innerWidth: 0, innerHeight: 0 }));\n","import { observable } from \"@ixfx/rx/from/observable\";\n\n/**\n * Observe when a class changes on a target element, by default the document.\n * Useful for tracking theme changes.\n *\n * ```js\n * const c = cssClassChange();\n * c.on(msg => {\n *  // some class has changed on the document\n * });\n * ```\n */\nexport const cssClassChange = (target = document.documentElement) => {\n  const m = observable<MutationRecord[]>(stream => {\n    const ro = new MutationObserver((entries) => {\n      stream.set(entries);\n    });\n    const opts: MutationObserverInit = {\n      attributeFilter: [ `class` ],\n      attributes: true,\n    };\n    ro.observe(target, opts);\n\n    return () => {\n      ro.disconnect();\n    }\n  });\n  return m;\n}","\nimport { initStream, type ReactiveInitial, type ReactiveNonInitial, type ReactiveWritable } from \"@ixfx/rx\";\nimport type { HslScalar } from \"@ixfx/visual/colour\";\n\nexport type ReactiveColour = ReactiveWritable<HslScalar> & {\n  setHsl: (hsl: HslScalar) => void;\n}\n\nexport function colour(initialValue: HslScalar): ReactiveColour & ReactiveInitial<HslScalar>;\nexport function colour(): ReactiveColour & ReactiveNonInitial<HslScalar>;\nexport function colour(initialValue?: HslScalar): ReactiveColour & (ReactiveNonInitial<HslScalar> | ReactiveInitial<HslScalar>) {\n  let value = initialValue;\n  const events = initStream<HslScalar>();\n\n  const set = (v: HslScalar) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set,\n    setHsl: (hsl: HslScalar) => {\n      set(hsl);\n    }\n  }\n}\n","//import {Colour} from '@ixfx/visual';\nimport type { ReactiveInitial, ReactiveWritable, Reactive } from \"@ixfx/rx\";\nimport type { DomFormOptions, DomNumberInputValueOptions, DomValueOptions } from \"./dom-types.js\";\nimport { resolveEl } from '@ixfx/dom';\nimport { transform } from '@ixfx/rx';\nimport { hasLast } from '@ixfx/rx';\nimport { Colour } from \"@ixfx/visual\";\nimport { eventTrigger } from \"@ixfx/rx/from\";\n//import type { Colourish } from '@ixfx/visual/colour';\n\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n * \n * Options:\n * - relative: if _true_, values are 0..1 (default: false)\n * - inverted: if _true_, values are 1..0 (default: false)\n * \n * If element is missing a 'type' attribute, this will be set to 'range'.\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domNumberInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomNumberInputValueOptions> = {}): ReactiveInitial<number> & ReactiveWritable<number> {\n  const input = domInputValue(targetOrQuery, options);\n  const el = input.el;\n  const relative = options.relative ?? false;\n  const inverted = options.inverted ?? false;\n\n  const rx = transform(input, v => {\n    return Number.parseFloat(v);\n  });\n\n  if (relative) {\n    //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n    el.max = inverted ? \"0\" : \"1\";\n    //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n    el.min = inverted ? \"1\" : \"0\";\n    if (!el.hasAttribute(`step`)) {\n      //el.setAttribute(`step`, \"0.1\");\n      el.step = \"0.1\";\n    }\n  }\n  if (el.getAttribute(`type`) === null) {\n    el.type = `range`;\n  }\n\n  const set = (value: number) => {\n    input.set(value.toString());\n  }\n\n  return {\n    ...rx,\n    last() {\n      //console.log(`domNumberInputValue last: ${ input.last() }`);\n      return Number.parseFloat(input.last())\n    },\n    set\n  };\n}\n\nexport function domHslInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): ReactiveInitial<Colour.HslScalar> & Reactive<Colour.HslScalar> & ReactiveWritable<Colour.HslScalar> {\n\n  const input = domInputValue(targetOrQuery, {\n    ...options,\n    upstreamFilter: (value) => {\n      return (typeof value === `object`) ? Colour.toCssColour(value as Colour.HslScalar) : value as string;\n    },\n  });\n  const rx = transform(input, v => {\n    return Colour.HslSpace.fromCss(v, { scalar: true, ensureSafe: true });\n  });\n  return {\n    ...rx,\n    last() {\n      return Colour.HslSpace.fromCss(input.last(), { scalar: true, ensureSafe: true })\n    },\n    set(value) {\n      input.set(Colour.HslSpace.toCssString(value));\n    },\n  };\n}\n\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n * \n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): { el: HTMLInputElement } & ReactiveInitial<string> & ReactiveWritable<string> {\n  const target: HTMLInputElement | null = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${ targetOrQuery }'`);\n  if (target === null) throw new Error(`targetOrQuery is null`)\n\n  const el = resolveEl(targetOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const fallbackValue = options.fallbackValue ?? ``;\n  const upstreamSource = options.upstreamSource;\n  let upstreamSourceUnsub = () => {}\n\n  let attribName = options.attributeName;\n  let fieldName = options.fieldName;\n\n  if (fieldName === undefined && attribName === undefined) {\n    attribName = fieldName = `value`;\n  }\n\n  const readValue = () => {\n    let value: string | null | undefined;\n    if (attribName) {\n      value = el.getAttribute(attribName);\n      //console.log(`  attrib: ${ attribName } value: ${ value }`);\n    }\n    if (fieldName) {\n      value = (el as any)[ fieldName ]\n    }\n    if (value === undefined || value === null) value = fallbackValue;\n    //console.log(`domInputValue readValue: ${ value }. attrib: ${ attribName } field: ${ fieldName }`);\n    return value;\n  }\n\n  const setValue = (value: string) => {\n    if (attribName) {\n      el.setAttribute(attribName, value);\n    }\n    if (fieldName) {\n      (el as any)[ fieldName ] = value;\n    }\n  }\n\n  const setUpstream = (v: any) => {\n    v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n    setValue(v);\n  }\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n    if (hasLast(upstreamSource)) {\n      setUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(el, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el,\n    last() {\n      return readValue()\n    },\n    set(value) {\n      setValue(value);\n    },\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}\n\n/**\n * Listens for data changes from elements within a HTML form element.\n * Input elements must have a 'name' attribute.\n * \n * Simple usage:\n * ```js\n * const rx = Rx.From.domForm(`#my-form`);\n * rx.onValue(value => {\n *  // Object containing values from form\n * });\n * \n * rx.last(); // Read current values of form\n * ```\n * \n * UI can be updated\n * ```js\n * // Set using an object of key-value pairs\n * rx.set({\n *  size: 'large'\n * });\n * \n * // Or set a single name-value pair\n * rx.setNamedValue(`size`, `large`);\n * ```\n * \n * If an 'upstream' reactive is provided, this is used to set initial values of the UI, overriding\n * whatever may be in the HTML. Upstream changes modify UI elements, but UI changes do not modify the upstream\n * source.\n * \n * ```js\n * // Create a reactive object\n * const obj = Rx.From.object({\n *  when: `2024-10-03`,\n *  size: 12,\n *  checked: true\n * });\n * \n * // Use this as initial values for a HTML form\n * // (assuming appropriate INPUT/SELECT elements exist)\n * const rx = Rx.From.domForm(`form`, { \n *  upstreamSource: obj\n * });\n * \n * // Listen for changes in the UI\n * rx.onValue(value => {\n *  \n * });\n * ```\n * @param formElOrQuery \n * @param options \n * @returns \n */\nexport function domForm<T extends Record<string, any>>(formElOrQuery: HTMLFormElement | string, options: Partial<DomFormOptions<T>> = {}): {\n  setNamedValue: (name: string, value: any) => void,\n  el: HTMLFormElement\n} & ReactiveInitial<T> & ReactiveWritable<T> {\n  const formEl = resolveEl<HTMLFormElement>(formElOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const upstreamSource = options.upstreamSource;\n\n  const typeHints = new Map<string, string>();\n\n  let upstreamSourceUnsub = () => {}\n\n  const readValue = (): T => {\n    const fd = new FormData(formEl);\n    const entries: [ string, unknown ][] = [];\n    for (const [ k, v ] of fd.entries()) {\n      const vString = v.toString();\n\n      // Get type hint for key\n      let typeHint = typeHints.get(k);\n      if (!typeHint) {\n        // If not found, use the kind of input element as a hint\n        const el = getFormElement(k, vString);\n        if (el) {\n          if (el.type === `range` || el.type === `number`) {\n            typeHint = `number`;\n          } else if (el.type === `color`) {\n            typeHint = `colour`;\n          } else if (el.type === `checkbox` && (v === `true` || v === `on`)) {\n            typeHint = `boolean`;\n          } else {\n            typeHint = `string`;\n          }\n          typeHints.set(k, typeHint);\n        }\n      }\n\n      if (typeHint === `number`) {\n        entries.push([ k, Number.parseFloat(vString) ]);\n      } else if (typeHint === `boolean`) {\n        const vBool = (vString === `true`) ? true : false;\n        entries.push([ k, vBool ]);\n      } else if (typeHint === `colour`) {\n        const vRgb = Colour.toCssColour(vString);\n        entries.push([ k, Colour.SrgbSpace.fromCss(vRgb, { scalar: false }) ]);\n      } else {\n        entries.push([ k, v.toString() ]);\n      }\n    }\n\n    // Checkboxes that aren't checked don't give a value, so find those\n    for (const el of formEl.querySelectorAll<HTMLInputElement>(`input[type=\"checkbox\"]`)) {\n      if (!el.checked && el.value === `true`) {\n        entries.push([ el.name, false ]);\n      }\n    }\n    const asObject = Object.fromEntries(entries);\n    //console.log(`readValue`, asObj);\n    return asObject as any as T;\n  }\n\n  const getFormElement = (name: string, value: string): HTMLSelectElement | HTMLInputElement | undefined => {\n    const el = formEl.querySelector<HTMLInputElement | HTMLSelectElement>(`[name=\"${ name }\"]`);\n    if (!el) {\n      console.warn(`Form does not contain an element with name=\"${ name }\"`);\n      return;\n    }\n    if (el.type === `radio`) {\n      // Get right radio option\n      const radioEl = formEl.querySelector<HTMLInputElement>(`[name=\"${ name }\"][value=\"${ value }\"]`);\n      if (!radioEl) {\n        console.warn(`Form does not contain radio option for name=${ name } value=${ value }`);\n        return;\n      }\n      return radioEl;\n    }\n    return el;\n  }\n  const setNamedValue = (name: string, value: any) => {\n    const el = getFormElement(name, value);\n    if (!el) return;\n\n    //let typeHint = typeHints.get(name);\n    // if (typeHint) {\n    //   console.log(`${ name } hint: ${ typeHint } input type: ${ el.type }`);\n    // } else {\n    //   console.warn(`Rx.Sources.Dom.domForm no type hint for: ${ name }`);\n    // }\n    if (el.nodeName === `INPUT` || el.nodeName === `SELECT`) {\n      if (el.type === `color`) {\n        if (typeof value === `object`) {\n          // Try to parse colour if value is an object\n          value = Colour.toCssColour(value);\n        }\n      } else if (el.type === `checkbox`) {\n        if (typeof value === `boolean`) {\n          el.checked = value;\n          return;\n        } else {\n          console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${ name } Value: ${ value } (${ typeof value })`);\n        }\n      } else if (el.type === `radio`) {\n        el.checked = true;\n        return;\n      }\n      el.value = value;\n    }\n  }\n\n  const setFromUpstream = (value: T) => {\n    //console.log(`setUpstream`, value);\n    for (const [ name, v ] of Object.entries(value)) {\n      let hint = typeHints.get(name);\n      if (!hint) {\n        hint = typeof v;\n        if (hint === `object`) {\n          const rgb = Colour.toColour(v);\n          hint = `colour`;\n          // const rgb = Colour.toColour(v);\n          // if (rgb.success) {\n          //   hint = `colour`;\n          // }\n        }\n        typeHints.set(name, hint);\n      }\n      const valueFiltered = options.upstreamFilter ? options.upstreamFilter(name, v) : v;\n      setNamedValue(name, valueFiltered);\n    }\n  }\n\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setFromUpstream);\n    if (hasLast(upstreamSource)) {\n      setFromUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(formEl, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el: formEl,\n    last() {\n      return readValue()\n    },\n    set: setFromUpstream,\n    setNamedValue,\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}","import { resolveEl } from \"@ixfx/dom\";\nimport { Pathed } from \"@ixfx/core\";\nimport * as Rx from \"@ixfx/rx\";\nimport * as RxFrom from \"@ixfx/rx/from\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind, DomBindUnresolvedSource } from './dom-types.js';\nimport { findBySomeKey as mapFindBySomeKey } from \"@ixfx/core/maps\";\nimport { afterMatch, beforeMatch, stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"@ixfx/core/text\";\nimport { QueueMutable } from \"@ixfx/collections\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as HTMLElement[];\n\n  return Rx.From.object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.s\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\nexport const bindValueText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n}\n\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\nconst setupInput = <TSource, TDestination>(b: PipeDomBinding, input: Rx.Reactive<TDestination>, source: Rx.Reactive<TSource>, twoway: boolean, transformFromInput: (value: TDestination) => TSource) => {\n  input.onValue(value => {\n    const v = transformFromInput(value);\n    if (twoway && Rx.isWritable(source)) {\n      source.set(v);\n    }\n  });\n  const dispose = () => {\n    input.dispose(`bindInput twoway dispose`);\n    b.remove(false);\n  }\n  return { ...b, dispose, input };\n}\n\nconst validateElement = (elOrQuery: string | HTMLInputElement | null, type?: string): HTMLInputElement => {\n  const el = resolveEl(elOrQuery);\n  if (el.nodeName !== `INPUT`) throw new Error(`HTML INPUT element expected. Got: ${ el.nodeName }`);\n  if (type !== undefined && el.type !== type) throw new Error(`HTML INPUT element expected with type 'range'. Got: ${ el.type }`);\n  return el;\n}\n\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<TSource, string> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery Element to update to, or query string such as '#someid'\n * @param source Source of data\n * @param binds Bindings\n */\nexport const bindElement = <TSource, TDestination>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, ...binds: (DomBindSourceValue<TSource, TDestination> & DomBindValueTarget)[]): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b: DomBindValueTarget[] = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<TSource, TDestination>;\n    return { ...bind, element: el } as DomBindResolvedSource<TSource, TDestination>\n  });\n  return bind<TSource, TDestination>(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v as string);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v as string);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <TSource, TDestination>(bind: DomBindSourceValue<TSource, TDestination>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: TSource) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: TSource) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <TSource, TDestination>(source: Rx.Reactive<TSource>, ...bindsUnresolvedElements: DomBindUnresolvedSource<TSource, TDestination>[]): PipeDomBinding => {\n  const binds: DomBindResolvedSource<TSource, TDestination>[] = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<TSource, TDestination>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: TSource) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (Rx.messageHasValue(message)) {\n      update(message.value);\n    } else if (Rx.messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (Rx.messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Pathed.PathDataChange<any>[], el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  //const binds = opts.binds;\n  const update = (value: Pathed.PathDataChange<any>[]) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(value => {\n    update(value);\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = mapFindBySomeKey(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: (Pathed.PathDataChange<any> | Pathed.PathData<any>)[]) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (!(`previous` in d) || d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = [ ...Pathed.getPathsAndData(d.value, false, Number.MAX_SAFE_INTEGER, path) ];\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(value => {\n    //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    changes(value);\n  });\n\n  // Source has an initial value, use that\n  if (Rx.hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes([ ...Pathed.getPathsAndData(last as object, false, 1) ]);\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = RxFrom.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = RxFrom.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","export * from './browser-resize.js';\nexport * from './browser-theme-change.js';\nexport * from './colour.js';\nexport * from './dom-source.js';\nexport type * from './dom-types.js';\nexport * from './dom.js';"],"mappings":"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"}