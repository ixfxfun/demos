{"version":3,"file":"ui.js","names":["elem: Readonly<Element>","interval?: Interval","opts: MutationObserverInit","initialValue?: HslScalar","v: HslScalar","hsl: HslScalar","targetOrQuery: HTMLInputElement | string","options: Partial<DomNumberInputValueOptions>","value: number","options: Partial<DomValueOptions>","target: HTMLInputElement | null","value: string | null | undefined","value: string","v: any","formElOrQuery: HTMLFormElement | string","options: Partial<DomFormOptions<T>>","entries: [ string, unknown ][]","name: string","value: any","value: T","query: string","elements","source: Rx.Reactive<TSource>","elOrQuery: string | HTMLElement | null","bindOpts: Partial<DomBindSourceValue<TSource, string>>","elOrQuery: string | HTMLInputElement | null","bindOpts: DomBindSourceValue<TSource, string>","b: DomBindValueTarget[]","bind","bind: DomBindValueTarget","element: HTMLElement","value: any","v: any","_: any","_element: HTMLElement","bind: DomBindSourceValue<TSource, TDestination>","value: TSource","binds: DomBindResolvedSource<TSource, TDestination>[]","removeElements: boolean","source: Rx.Reactive<V>","elOrQuery: string | HTMLElement","updater: (v: V, el: HTMLElement) => void","value: V","removeElement: boolean","source: Rx.ReactiveDiff<V>","updater: (diffs: Pathed.PathDataChange<any>[], el: HTMLElement) => void","opts: Partial<BindUpdateOpts<V>>","value: Pathed.PathDataChange<any>[]","source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>)","options: Partial<ElementsOptions>","path: string","mapFindBySomeKey","el: HTMLElement","changes: (Pathed.PathDataChange<any> | Pathed.PathData<any>)[]","changes","args: Event | undefined"],"sources":["../packages/ui/src/rx/browser-resize.ts","../packages/ui/src/rx/browser-theme-change.ts","../packages/ui/src/rx/colour.ts","../packages/ui/src/rx/dom-source.ts","../packages/ui/src/rx/dom.ts","../packages/ui/src/rx/index.ts"],"sourcesContent":["import type { Interval } from \"@ixfx/core\";\nimport { observable } from \"@ixfx/rx/from\";\nimport { debounce } from \"@ixfx/rx/op/debounce\";\n\n/**\n * Observe when element resizes. Specify `interval` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param interval Tiemout before event gets triggered\n * @returns\n */\nexport const browserResizeObservable = (\n  elem: Readonly<Element>,\n  interval?: Interval\n) => {\n  if (elem === null) {\n    throw new Error(`Param 'elem' is null. Expected element to observe`);\n  }\n  if (elem === undefined) {\n    throw new Error(`Param 'elem' is undefined. Expected element to observe`);\n  }\n\n  const m = observable<ResizeObserverEntry[]>(stream => {\n    const ro = new ResizeObserver((entries) => {\n      stream.set(entries);\n    });\n    ro.observe(elem);\n\n    return () => {\n      ro.unobserve(elem);\n    };\n  });\n  //return debounce({ elapsed: interval ?? 100 })(m);\n  return debounce<ResizeObserverEntry[]>({ elapsed: interval ?? 100 })(m);\n}\n\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param elapsed\n * @returns\n */\n// export const windowResize = (elapsed?: Interval) => Rx.Ops.debounce<{ innerWidth: number, innerHeight: number }>({ elapsed: elapsed ?? 100 })(Rx.From.event(window, `resize`, { innerWidth: 0, innerHeight: 0 }));\n","import { observable } from \"@ixfx/rx/from/observable\";\n\n/**\n * Observe when a class changes on a target element, by default the document.\n * Useful for tracking theme changes.\n *\n * ```js\n * const c = cssClassChange();\n * c.on(msg => {\n *  // some class has changed on the document\n * });\n * ```\n */\nexport const cssClassChange = (target = document.documentElement) => {\n  const m = observable<MutationRecord[]>(stream => {\n    const ro = new MutationObserver((entries) => {\n      stream.set(entries);\n    });\n    const opts: MutationObserverInit = {\n      attributeFilter: [ `class` ],\n      attributes: true,\n    };\n    ro.observe(target, opts);\n\n    return () => {\n      ro.disconnect();\n    }\n  });\n  return m;\n}","\nimport { initStream, type ReactiveInitial, type ReactiveNonInitial, type ReactiveWritable } from \"@ixfx/rx\";\nimport type { HslScalar } from \"@ixfx/visual/colour\";\n\nexport type ReactiveColour = ReactiveWritable<HslScalar> & {\n  setHsl: (hsl: HslScalar) => void;\n}\n\nexport function colour(initialValue: HslScalar): ReactiveColour & ReactiveInitial<HslScalar>;\nexport function colour(): ReactiveColour & ReactiveNonInitial<HslScalar>;\nexport function colour(initialValue?: HslScalar): ReactiveColour & (ReactiveNonInitial<HslScalar> | ReactiveInitial<HslScalar>) {\n  let value = initialValue;\n  const events = initStream<HslScalar>();\n\n  const set = (v: HslScalar) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set,\n    setHsl: (hsl: HslScalar) => {\n      set(hsl);\n    }\n  }\n}\n","//import {Colour} from '@ixfx/visual';\nimport type { ReactiveInitial, ReactiveWritable, Reactive } from \"@ixfx/rx\";\nimport type { DomFormOptions, DomNumberInputValueOptions, DomValueOptions } from \"./dom-types.js\";\nimport { resolveEl } from '@ixfx/dom';\nimport { transform } from '@ixfx/rx';\nimport { hasLast } from '@ixfx/rx';\nimport { Colour } from \"@ixfx/visual\";\nimport { eventTrigger } from \"@ixfx/rx/from\";\n//import type { Colourish } from '@ixfx/visual/colour';\n\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n * \n * Options:\n * - relative: if _true_, values are 0..1 (default: false)\n * - inverted: if _true_, values are 1..0 (default: false)\n * \n * If element is missing a 'type' attribute, this will be set to 'range'.\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domNumberInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomNumberInputValueOptions> = {}): ReactiveInitial<number> & ReactiveWritable<number> {\n  const input = domInputValue(targetOrQuery, options);\n  const el = input.el;\n  const relative = options.relative ?? false;\n  const inverted = options.inverted ?? false;\n\n  const rx = transform(input, v => {\n    return Number.parseFloat(v);\n  });\n\n  if (relative) {\n    //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n    el.max = inverted ? \"0\" : \"1\";\n    //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n    el.min = inverted ? \"1\" : \"0\";\n    if (!el.hasAttribute(`step`)) {\n      //el.setAttribute(`step`, \"0.1\");\n      el.step = \"0.1\";\n    }\n  }\n  if (el.getAttribute(`type`) === null) {\n    el.type = `range`;\n  }\n\n  const set = (value: number) => {\n    input.set(value.toString());\n  }\n\n  return {\n    ...rx,\n    last() {\n      //console.log(`domNumberInputValue last: ${ input.last() }`);\n      return Number.parseFloat(input.last())\n    },\n    set\n  };\n}\n\nexport function domHslInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): ReactiveInitial<Colour.HslScalar> & Reactive<Colour.HslScalar> & ReactiveWritable<Colour.HslScalar> {\n\n  const input = domInputValue(targetOrQuery, {\n    ...options,\n    upstreamFilter: (value) => {\n      return (typeof value === `object`) ? Colour.toCssColour(value as Colour.HslScalar) : value as string;\n    },\n  });\n  const rx = transform(input, v => {\n    return Colour.HslSpace.fromCss(v, { scalar: true, ensureSafe: true });\n  });\n  return {\n    ...rx,\n    last() {\n      return Colour.HslSpace.fromCss(input.last(), { scalar: true, ensureSafe: true })\n    },\n    set(value) {\n      input.set(Colour.HslSpace.toCssString(value));\n    },\n  };\n}\n\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n * \n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): { el: HTMLInputElement } & ReactiveInitial<string> & ReactiveWritable<string> {\n  const target: HTMLInputElement | null = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${ targetOrQuery }'`);\n  if (target === null) throw new Error(`targetOrQuery is null`)\n\n  const el = resolveEl(targetOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const fallbackValue = options.fallbackValue ?? ``;\n  const upstreamSource = options.upstreamSource;\n  let upstreamSourceUnsub = () => {}\n\n  let attribName = options.attributeName;\n  let fieldName = options.fieldName;\n\n  if (fieldName === undefined && attribName === undefined) {\n    attribName = fieldName = `value`;\n  }\n\n  const readValue = () => {\n    let value: string | null | undefined;\n    if (attribName) {\n      value = el.getAttribute(attribName);\n      //console.log(`  attrib: ${ attribName } value: ${ value }`);\n    }\n    if (fieldName) {\n      value = (el as any)[ fieldName ]\n    }\n    if (value === undefined || value === null) value = fallbackValue;\n    //console.log(`domInputValue readValue: ${ value }. attrib: ${ attribName } field: ${ fieldName }`);\n    return value;\n  }\n\n  const setValue = (value: string) => {\n    if (attribName) {\n      el.setAttribute(attribName, value);\n    }\n    if (fieldName) {\n      (el as any)[ fieldName ] = value;\n    }\n  }\n\n  const setUpstream = (v: any) => {\n    v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n    setValue(v);\n  }\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n    if (hasLast(upstreamSource)) {\n      setUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(el, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el,\n    last() {\n      return readValue()\n    },\n    set(value) {\n      setValue(value);\n    },\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}\n\n/**\n * Listens for data changes from elements within a HTML form element.\n * Input elements must have a 'name' attribute.\n * \n * Simple usage:\n * ```js\n * const rx = Rx.From.domForm(`#my-form`);\n * rx.onValue(value => {\n *  // Object containing values from form\n * });\n * \n * rx.last(); // Read current values of form\n * ```\n * \n * UI can be updated\n * ```js\n * // Set using an object of key-value pairs\n * rx.set({\n *  size: 'large'\n * });\n * \n * // Or set a single name-value pair\n * rx.setNamedValue(`size`, `large`);\n * ```\n * \n * If an 'upstream' reactive is provided, this is used to set initial values of the UI, overriding\n * whatever may be in the HTML. Upstream changes modify UI elements, but UI changes do not modify the upstream\n * source.\n * \n * ```js\n * // Create a reactive object\n * const obj = Rx.From.object({\n *  when: `2024-10-03`,\n *  size: 12,\n *  checked: true\n * });\n * \n * // Use this as initial values for a HTML form\n * // (assuming appropriate INPUT/SELECT elements exist)\n * const rx = Rx.From.domForm(`form`, { \n *  upstreamSource: obj\n * });\n * \n * // Listen for changes in the UI\n * rx.onValue(value => {\n *  \n * });\n * ```\n * @param formElOrQuery \n * @param options \n * @returns \n */\nexport function domForm<T extends Record<string, any>>(formElOrQuery: HTMLFormElement | string, options: Partial<DomFormOptions<T>> = {}): {\n  setNamedValue: (name: string, value: any) => void,\n  el: HTMLFormElement\n} & ReactiveInitial<T> & ReactiveWritable<T> {\n  const formEl = resolveEl<HTMLFormElement>(formElOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const upstreamSource = options.upstreamSource;\n\n  const typeHints = new Map<string, string>();\n\n  let upstreamSourceUnsub = () => {}\n\n  const readValue = (): T => {\n    const fd = new FormData(formEl);\n    const entries: [ string, unknown ][] = [];\n    for (const [ k, v ] of fd.entries()) {\n      const vString = v.toString();\n\n      // Get type hint for key\n      let typeHint = typeHints.get(k);\n      if (!typeHint) {\n        // If not found, use the kind of input element as a hint\n        const el = getFormElement(k, vString);\n        if (el) {\n          if (el.type === `range` || el.type === `number`) {\n            typeHint = `number`;\n          } else if (el.type === `color`) {\n            typeHint = `colour`;\n          } else if (el.type === `checkbox` && (v === `true` || v === `on`)) {\n            typeHint = `boolean`;\n          } else {\n            typeHint = `string`;\n          }\n          typeHints.set(k, typeHint);\n        }\n      }\n\n      if (typeHint === `number`) {\n        entries.push([ k, Number.parseFloat(vString) ]);\n      } else if (typeHint === `boolean`) {\n        const vBool = (vString === `true`) ? true : false;\n        entries.push([ k, vBool ]);\n      } else if (typeHint === `colour`) {\n        const vRgb = Colour.toCssColour(vString);\n        entries.push([ k, Colour.SrgbSpace.fromCss(vRgb, { scalar: false }) ]);\n      } else {\n        entries.push([ k, v.toString() ]);\n      }\n    }\n\n    // Checkboxes that aren't checked don't give a value, so find those\n    for (const el of formEl.querySelectorAll<HTMLInputElement>(`input[type=\"checkbox\"]`)) {\n      if (!el.checked && el.value === `true`) {\n        entries.push([ el.name, false ]);\n      }\n    }\n    const asObject = Object.fromEntries(entries);\n    //console.log(`readValue`, asObj);\n    return asObject as any as T;\n  }\n\n  const getFormElement = (name: string, value: string): HTMLSelectElement | HTMLInputElement | undefined => {\n    const el = formEl.querySelector<HTMLInputElement | HTMLSelectElement>(`[name=\"${ name }\"]`);\n    if (!el) {\n      console.warn(`Form does not contain an element with name=\"${ name }\"`);\n      return;\n    }\n    if (el.type === `radio`) {\n      // Get right radio option\n      const radioEl = formEl.querySelector<HTMLInputElement>(`[name=\"${ name }\"][value=\"${ value }\"]`);\n      if (!radioEl) {\n        console.warn(`Form does not contain radio option for name=${ name } value=${ value }`);\n        return;\n      }\n      return radioEl;\n    }\n    return el;\n  }\n  const setNamedValue = (name: string, value: any) => {\n    const el = getFormElement(name, value);\n    if (!el) return;\n\n    //let typeHint = typeHints.get(name);\n    // if (typeHint) {\n    //   console.log(`${ name } hint: ${ typeHint } input type: ${ el.type }`);\n    // } else {\n    //   console.warn(`Rx.Sources.Dom.domForm no type hint for: ${ name }`);\n    // }\n    if (el.nodeName === `INPUT` || el.nodeName === `SELECT`) {\n      if (el.type === `color`) {\n        if (typeof value === `object`) {\n          // Try to parse colour if value is an object\n          value = Colour.toCssColour(value);\n        }\n      } else if (el.type === `checkbox`) {\n        if (typeof value === `boolean`) {\n          el.checked = value;\n          return;\n        } else {\n          console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${ name } Value: ${ value } (${ typeof value })`);\n        }\n      } else if (el.type === `radio`) {\n        el.checked = true;\n        return;\n      }\n      el.value = value;\n    }\n  }\n\n  const setFromUpstream = (value: T) => {\n    //console.log(`setUpstream`, value);\n    for (const [ name, v ] of Object.entries(value)) {\n      let hint = typeHints.get(name);\n      if (!hint) {\n        hint = typeof v;\n        if (hint === `object`) {\n          const rgb = Colour.toColour(v);\n          hint = `colour`;\n          // const rgb = Colour.toColour(v);\n          // if (rgb.success) {\n          //   hint = `colour`;\n          // }\n        }\n        typeHints.set(name, hint);\n      }\n      const valueFiltered = options.upstreamFilter ? options.upstreamFilter(name, v) : v;\n      setNamedValue(name, valueFiltered);\n    }\n  }\n\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setFromUpstream);\n    if (hasLast(upstreamSource)) {\n      setFromUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(formEl, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el: formEl,\n    last() {\n      return readValue()\n    },\n    set: setFromUpstream,\n    setNamedValue,\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}","import { resolveEl } from \"@ixfx/dom\";\nimport { Pathed } from \"@ixfx/core\";\nimport * as Rx from \"@ixfx/rx\";\nimport * as RxFrom from \"@ixfx/rx/from\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind, DomBindUnresolvedSource } from './dom-types.js';\nimport { findBySomeKey as mapFindBySomeKey } from \"@ixfx/core/maps\";\nimport { afterMatch, beforeMatch, stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"@ixfx/core/text\";\nimport { QueueMutable } from \"@ixfx/collections\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as HTMLElement[];\n\n  return Rx.From.object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.s\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\nexport const bindValueText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n}\n\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\nconst setupInput = <TSource, TDestination>(b: PipeDomBinding, input: Rx.Reactive<TDestination>, source: Rx.Reactive<TSource>, twoway: boolean, transformFromInput: (value: TDestination) => TSource) => {\n  input.onValue(value => {\n    const v = transformFromInput(value);\n    if (twoway && Rx.isWritable(source)) {\n      source.set(v);\n    }\n  });\n  const dispose = () => {\n    input.dispose(`bindInput twoway dispose`);\n    b.remove(false);\n  }\n  return { ...b, dispose, input };\n}\n\nconst validateElement = (elOrQuery: string | HTMLInputElement | null, type?: string): HTMLInputElement => {\n  const el = resolveEl(elOrQuery);\n  if (el.nodeName !== `INPUT`) throw new Error(`HTML INPUT element expected. Got: ${ el.nodeName }`);\n  if (type !== undefined && el.type !== type) throw new Error(`HTML INPUT element expected with type 'range'. Got: ${ el.type }`);\n  return el;\n}\n\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<TSource, string> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery Element to update to, or query string such as '#someid'\n * @param source Source of data\n * @param binds Bindings\n */\nexport const bindElement = <TSource, TDestination>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, ...binds: (DomBindSourceValue<TSource, TDestination> & DomBindValueTarget)[]): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b: DomBindValueTarget[] = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<TSource, TDestination>;\n    return { ...bind, element: el } as DomBindResolvedSource<TSource, TDestination>\n  });\n  return bind<TSource, TDestination>(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v as string);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v as string);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <TSource, TDestination>(bind: DomBindSourceValue<TSource, TDestination>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: TSource) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: TSource) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <TSource, TDestination>(source: Rx.Reactive<TSource>, ...bindsUnresolvedElements: DomBindUnresolvedSource<TSource, TDestination>[]): PipeDomBinding => {\n  const binds: DomBindResolvedSource<TSource, TDestination>[] = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<TSource, TDestination>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: TSource) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (Rx.messageHasValue(message)) {\n      update(message.value);\n    } else if (Rx.messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (Rx.messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (Rx.hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Pathed.PathDataChange<any>[], el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  //const binds = opts.binds;\n  const update = (value: Pathed.PathDataChange<any>[]) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(value => {\n    update(value);\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = mapFindBySomeKey(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: (Pathed.PathDataChange<any> | Pathed.PathData<any>)[]) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (!(`previous` in d) || d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = [ ...Pathed.getPathsAndData(d.value, false, Number.MAX_SAFE_INTEGER, path) ];\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(value => {\n    //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    changes(value);\n  });\n\n  // Source has an initial value, use that\n  if (Rx.hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes([ ...Pathed.getPathsAndData(last as object, false, 1) ]);\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = RxFrom.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = RxFrom.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","export * from './browser-resize.js';\nexport * from './browser-theme-change.js';\nexport * from './colour.js';\nexport * from './dom-source.js';\nexport type * from './dom-types.js';\nexport * from './dom.js';"],"mappings":"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"}