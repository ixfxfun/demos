{"version":3,"file":"interpolate-BoOK0bgP.js","names":[],"sources":["../../numbers/dist/src/pi-pi.js","../../numbers/dist/src/interpolate.js"],"sourcesContent":["export const piPi = Math.PI * 2;\n","import { wrap } from './wrap.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link @ixfx/modulation.interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        resultThrow(numberTest(_a, ``, `a`), numberTest(_b, ``, `b`), numberTest(_amt, ``, `amount`));\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        resultThrow(numberTest(amount, ``, `amount`));\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link @ixfx/numbers.interpolatorInterval}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n"],"mappings":";;;;;AAAA,MAAa,OAAO,KAAK,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACiC9B,SAAgB,YAAY,MAAM,MAAM,MAAM,MAAM;CAChD,IAAI;CACJ,IAAI,SAAS,CAAC,KAAK,CAAC;CACpB,MAAM,eAAe,CAAC,WAAW;AAC7B,MAAI,eACA,SAAS,cAAc,OAAO;AAClC,MAAI,WAAW,UAAa,WAAW,CAAC,KAAK,CAAC,EAC1C,SAAS,MAAM,OAAO;WAEjB,WAAW,CAAC,IAAI,CAAC,EACtB;OAAI,SAAS,GACT,SAAS,SAAS;YACb,SAAS,GACd,SAAS,IAAK,SAAS;EAC1B;AAEL,SAAO;CACV;CACD,MAAM,YAAY,CAAC,MAAM,IAAI,OAAO;EAChC,YAAY,WAAW,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,WAAW,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,WAAW,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;EAC7F,OAAO,aAAa,KAAK;AACzB,UAAQ,IAAI,QAAQ,KAAK,OAAO;CACnC;CACD,MAAM,WAAW,CAAC,IAAI,CAAE,MAAK;AACzB,MAAI,EAAE,WAAW;AACb,OAAI,OAAO,EAAE,cAAc,CAAC,QAAQ,CAAC,CACjC,OAAM,IAAI,MAAM,CAAC,qDAAqD,EAAE,OAAO,EAAE,WAAW;GAChG,gBAAgB,EAAE;EACrB;EACD,SAAS,EAAE,UAAU,CAAC,KAAK,CAAC;CAC/B;CACD,MAAM,UAAU,CAAC,MAAM,IAAI,QAAQ,IAAI,QAAQ,KAAK,OAAO;AAC3D,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CACxB,OAAM,IAAI,UAAU,CAAC,6CAA6C,EAAE,OAAO,MAAM;AACrF,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;EAC1B,IAAI;EACJ,IAAI;AACJ,MAAI,SAAS,UAAa,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;GAEhD,IAAI;GACJ,IAAI;GACJ,SAAS,KAAK;AACd,UAAO,CAAC,WAAW,UAAU,QAAQ,GAAG,EAAE;EAC7C,WACQ,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;GAE/B,IAAI;GACJ,IAAI;GACJ,SAAS,KAAK;AACd,UAAO,UAAU,MAAM,GAAG,EAAE;EAC/B,MAEG,OAAM,IAAI,MAAM,CAAC,kCAAkC,CAAC;CAE3D,WACQ,SAAS,UAAa,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;EAErD,MAAM,SAAS,aAAa,KAAK;EACjC,SAAS,KAAK;EACd,YAAY,WAAW,QAAQ,EAAE,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;AAC7C,SAAO,CAAC,QAAQ,WAAW,QAAQ,QAAQ,QAAQ,OAAO;CAC7D;AACJ;;;;;;;;;;;;AA8DD,MAAa,mBAAmB,CAAC,QAAQ,UAAU,UAAU,YAAY;CACrE,MAAM,IAAI,KAAK,WAAW,UAAU,GAAG,KAAK;AAC5C,QAAO,YAAY,QAAQ,UAAU,YAAY,IAAI,KAAK,KAAK,IAAI,OAAO,IAAI,QAAQ;AACzF"}