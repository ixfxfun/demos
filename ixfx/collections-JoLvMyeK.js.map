{"version":3,"file":"collections-JoLvMyeK.js","names":["#capacity","#pointer","value","array: V[] | readonly V[]","sourceArray: readonly V[] | V[]","toRemove: V | V[]","comparer: IsEqual<V>","isEqualDefault","returnArray: V[]","peek","isEmpty","isFull","mutable","mutable","compare","toString","value","depthFirst","breadthFirst","root","children","parents","hasChild","findChildByValue","hasAnyChild","findAnyChildByValue","hasAnyParent","hasParent","add","childrenLength","asDynamicTraversable","toStringDeep","followValue","toStringDeep","filter","value","depthFirst","create","create","root","add","value","prettyPrint","remove","childrenLength","getRoot","value","root","find","children","immutable","mutable","value","map","immutable","#depth","#maxDepth","set","value","#getChild","#dumpToArray","create","priority","item","#data","immutable","#maintain","value","key","existing","map","value","value","data","value","#map","set","value","map","value","value","value","value","map","value","value","value","without","del","value","value","createVertex","graph","toAdjacencyMatrix","dumpGraph","debugGraphToArray","vertices","adjacentVertices","getOrCreate","updateGraphVertex","connectTo","connect","connectWithEdges","edges","stringForEdge","resolveVertex","graph","edges"],"sources":["../../packages/collections/dist/src/circular-array.js","../../packages/arrays/src/contains.ts","../../packages/arrays/src/filter.ts","../../packages/collections/dist/src/queue/queue-fns.js","../../packages/collections/dist/src/queue/queue-mutable.js","../../packages/collections/dist/src/stack/StackFns.js","../../packages/collections/dist/src/stack/StackMutable.js","../../packages/collections/dist/src/tree/compare.js","../../packages/collections/dist/src/tree/tree-mutable.js","../../packages/collections/dist/src/tree/traverse-object.js","../../packages/collections/dist/src/tree/pathed.js","../../packages/collections/dist/src/tree/traversable-tree.js","../../packages/collections/dist/src/tree/index.js","../../packages/collections/dist/src/stack/StackImmutable.js","../../packages/collections/dist/src/stack/index.js","../../packages/collections/dist/src/set/set-mutable.js","../../packages/collections/dist/src/set/SetImmutable.js","../../packages/collections/dist/src/set/massive-set.js","../../packages/collections/dist/src/set/index.js","../../packages/collections/dist/src/queue/priority-mutable.js","../../packages/collections/dist/src/queue/queue-immutable.js","../../packages/collections/dist/src/queue/index.js","../../packages/collections/dist/src/map/expiring-map.js","../../packages/collections/dist/src/map/map-immutable-fns.js","../../packages/collections/dist/src/map/map.js","../../packages/collections/dist/src/map/map-mutable.js","../../packages/collections/dist/src/map/map-of-multi-impl.js","../../packages/collections/dist/src/map/map-of-set-mutable.js","../../packages/collections/dist/src/map/map-of-circular-mutable.js","../../packages/collections/dist/src/map/number-map.js","../../packages/collections/dist/src/map/map-of-array-mutable.js","../../packages/collections/dist/src/map/map-multi-fns.js","../../packages/collections/dist/src/map/map-of-simple-base.js","../../packages/collections/dist/src/map/map-of-simple-mutable.js","../../packages/collections/dist/src/map/map-of-simple.js","../../packages/collections/dist/src/map/index.js","../../packages/collections/dist/src/table.js","../../packages/collections/dist/src/graph/directed-graph.js","../../packages/collections/dist/src/graph/undirected-graph.js","../../packages/collections/dist/src/graph/index.js","../src/collections.ts"],"sourcesContent":["import { integerTest, resultThrow } from \"@ixfx/guards\";\nclass CircularArray extends Array {\n    #capacity;\n    #pointer;\n    constructor(capacity = 0) {\n        super();\n        // Allowed to create with capacity zero\n        resultThrow(integerTest(capacity, `positive`, `capacity`));\n        // Can't throw because .filter won't use ctor proprly\n        this.#capacity = capacity;\n        this.#pointer = 0;\n    }\n    /**\n     * Add to array\n     * @param value Thing to add\n     * @returns\n     */\n    add(value) {\n        const ca = CircularArray.from(this);\n        ca[this.#pointer] = value;\n        ca.#capacity = this.#capacity;\n        if (this.#capacity > 0) {\n            ca.#pointer =\n                this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n        }\n        else {\n            ca.#pointer = this.#pointer + 1;\n        }\n        return ca;\n    }\n    get pointer() {\n        return this.#pointer;\n    }\n    get isFull() {\n        if (this.#capacity === 0)\n            return false;\n        return this.length === this.#capacity;\n    }\n}\n/**\n * Returns a new circular array. Immutable. A circular array only keeps up to `capacity` items.\n * Old items are overridden with new items.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = circularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = circularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport const circularArray = (capacity) => new CircularArray(capacity);\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n\n\n/**\n * Returns _true_ if contents of `needles` is contained by `haystack`.\n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * @param haystack\n * @param needles\n * @param eq\n */\nexport const contains = <V>(\n  haystack: ArrayLike<V>,\n  needles: ArrayLike<V>,\n  eq = isEqualDefault<V>\n) => {\n  if (!Array.isArray(haystack)) {\n    throw new TypeError(`Expects haystack parameter to be an array`);\n  }\n  if (!Array.isArray(needles)) {\n    throw new TypeError(`Expects needles parameter to be an array`);\n  }\n\n  for (const needle of needles) {\n    let found = false;\n    for (const element of haystack) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      if (eq(needle, element)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n * \n * Uses JSON.toString() by default to compare values.\n * \n * See also:\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link unique} Get unique set of values in an array\n * @param array Array to examine\n * @param keyFunction Function to generate key string for object, uses JSON.stringify by default.\n * @returns\n */\nexport const containsDuplicateValues = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>\n): boolean => {\n  if (typeof data !== `object`) throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${ typeof data }`);\n  const set = new Set<string>();\n  for (const v of data) {\n    const string_ = keyFunction(v);\n    if (set.has(string_)) return true;\n    set.add(string_);\n  }\n  return false;\n};\n\n/**\n * Returns _true_ if array contains duplicate instances based on `===` equality checking\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array \n * @returns \n */\nexport const containsDuplicateInstances = <V>(array: V[] | readonly V[]): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  for (let index = 0; index < array.length; index++) {\n    for (let x = 0; x < array.length; x++) {\n      if (index === x) continue;\n      if (array[ index ] === array[ x ]) return true;\n    }\n  }\n  return false;\n}","import { isEqualDefault, type IsEqual } from \"./util/is-equal.js\";\nimport { arrayIndexTest, arrayTest, resultThrow } from \"@ixfx/guards\";\n\nexport const withoutUndefined = <V>(data: readonly V[] | V[]): V[] => {\n  return data.filter(v => v !== undefined);\n}\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: readonly V[],\n  filter: (a: V) => boolean\n): [ a: V[], b: V[] ] => {\n  const a: V[] = [];\n  const b: V[] = [];\n  for (const datum of data) {\n    if (filter(datum)) a.push(datum);\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween<V>(\n  array: readonly V[] | V[],\n  predicate: (\n    value: V,\n    index: number,\n    array: readonly V[] | V[]\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Generator<V> {\n  resultThrow(arrayTest(array, `array`));\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n\n  resultThrow(arrayIndexTest(array, startIndex, `startIndex`));\n  resultThrow(arrayIndexTest(array, endIndex - 1, `endIndex`));\n\n  for (let index = startIndex; index < endIndex; index++) {\n    if (predicate(array[ index ], index, array)) yield array[ index ];//t.push(array[ index ]);\n  }\n};\n\n\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const filtered = Arrays.without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * Arrays.without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * Arrays.without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * Arrays.without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  sourceArray: readonly V[] | V[],\n  toRemove: V | V[],\n  comparer: IsEqual<V> = isEqualDefault\n): V[] => {\n  if (Array.isArray(toRemove)) {\n    const returnArray: V[] = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}","export const debug = (opts, message) => {\n    opts.debug ? console.log(`queue:${message}`) : undefined;\n};\nexport const trimQueue = (opts, queue, toAdd) => {\n    const potentialLength = queue.length + toAdd.length;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    const policy = opts.discardPolicy ?? `additions`;\n    // debug(\n    //   opts,\n    //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n    // );\n    // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n    switch (policy) {\n        // Only add what we can from toAdd\n        case `additions`: {\n            // debug(\n            //   opts,\n            //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n            //     potentialLength - capacity\n            //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n            // );\n            if (queue.length === 0)\n                return toAdd.slice(0, toAdd.length - toRemove);\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (queue.length === opts.capacity) {\n                return queue; // Completely full\n            }\n            else {\n                // Only add some from the new array (from the front)\n                return [...queue, ...toAdd.slice(0, toRemove - 1)];\n            }\n        }\n        // Remove from rear of queue (last index) before adding new things\n        case `newer`: {\n            if (toRemove >= queue.length) {\n                // New items will completely flush out old\n                //debug(opts, `slice start: ${toAdd.length - capacity}`);\n                if (queue.length === 0) {\n                    // Special case when queue starts off empty\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];\n                }\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n                //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n                //return tmp;\n            }\n            else {\n                // Keep some of the old\n                // const toAddFinal = toAdd.slice(\n                //   0,\n                //   Math.min(toAdd.length, capacity - toRemove + 1)\n                // );\n                // Cap 5, queue 5, toAdd: 10.\n                const countToAdd = Math.max(1, toAdd.length - queue.length);\n                const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n                const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n                // debug(\n                //   opts,\n                //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n                //     queue.length\n                //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n                //     toKeep\n                //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n                //     toAddFinal\n                //   )}`\n                // );\n                const t = [...toKeep, ...toAddFinal];\n                //debug(opts, `final: ${JSON.stringify(t)}`);\n                return t;\n            }\n        }\n        // Remove from the front of the queue (0 index). ie. older items are discarded\n        case `older`: {\n            // If queue is A, B and toAdd is C, D this yields A, B, C, D\n            return [...queue, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown overflow policy ${policy}`);\n        }\n    }\n};\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = (opts, queue, ...toAdd) => {\n    if (opts === undefined)\n        throw new Error(`opts parameter undefined`);\n    const potentialLength = queue.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimQueue(opts, queue, toAdd)\n        : [...queue, ...toAdd];\n    if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n        throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\n    }\n    if (!opts.capacity && toReturn.length !== potentialLength) {\n        throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\n    }\n    return toReturn;\n};\n// Remove from front of queue (0 index)\nexport const dequeue = (opts, queue) => {\n    if (queue.length === 0)\n        throw new Error(`Queue is empty`);\n    return queue.slice(1);\n};\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, queue) => queue[0];\nexport const isEmpty = (opts, queue) => queue.length === 0;\nexport const isFull = (opts, queue) => {\n    if (opts.capacity) {\n        return queue.length >= opts.capacity;\n    }\n    return false;\n};\n","import {} from './iqueue-mutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './queue-fns.js';\nimport {} from './queue-types.js';\nimport { isEqualDefault } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\n/**\n * Mutable queue that fires events when manipulated.\n *\n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n *\n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n *\n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @typeParam V - Data type of items\n */\nexport class QueueMutable extends SimpleEventEmitter {\n    options;\n    data;\n    eq;\n    constructor(opts = {}, data = []) {\n        super();\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.options = opts;\n        this.data = data;\n        this.eq = opts.eq ?? isEqualDefault;\n    }\n    clear() {\n        const copy = [...this.data];\n        this.data = [];\n        this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n        this.onClear();\n    }\n    /**\n     * Called when all data is cleared\n     */\n    onClear() {\n    }\n    at(index) {\n        if (index >= this.data.length)\n            throw new Error(`Index outside bounds of queue`);\n        const v = this.data.at(index);\n        if (v === undefined)\n            throw new Error(`Index appears to be outside range of queue`);\n        return v;\n    }\n    enqueue(...toAdd) {\n        this.data = enqueue(this.options, this.data, ...toAdd);\n        const length = this.data.length;\n        this.onEnqueue(this.data, toAdd);\n        return length;\n    }\n    onEnqueue(result, attemptedToAdd) {\n        this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n    }\n    dequeue() {\n        const v = peek(this.options, this.data);\n        if (v === undefined)\n            return;\n        /* eslint-disable-next-line functional/immutable-data */\n        this.data = dequeue(this.options, this.data);\n        this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n        this.onRemoved([v], this.data);\n        return v;\n    }\n    onRemoved(removed, finalData) {\n        this.fireEvent(`removed`, { removed, finalData });\n    }\n    /**\n     * Removes values that match `predicate`.\n     * @param predicate\n     * @returns Returns number of items removed.\n     */\n    removeWhere(predicate) {\n        const countPre = this.data.length;\n        const toRemove = this.data.filter(v => predicate(v));\n        if (toRemove.length === 0)\n            return 0;\n        this.data = this.data.filter((element) => !predicate(element));\n        this.onRemoved(toRemove, this.data);\n        return countPre - this.data.length;\n    }\n    /**\n   * Return a copy of the array\n   * @returns\n   */\n    toArray() {\n        return [...this.data];\n    }\n    get isEmpty() {\n        return isEmpty(this.options, this.data);\n    }\n    get isFull() {\n        return isFull(this.options, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n    get peek() {\n        return peek(this.options, this.data);\n    }\n}\n/**\n * Creates a new QueueMutable\n * @param options\n * @param startingItems\n * @returns\n */\nexport function mutable(options = {}, ...startingItems) {\n    return new QueueMutable({ ...options }, [...startingItems]);\n}\n","export const trimStack = (opts, stack, toAdd) => {\n    const potentialLength = stack.length + toAdd.length;\n    const policy = opts.discardPolicy ?? `additions`;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    if (opts.debug) {\n        console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);\n    }\n    switch (policy) {\n        case `additions`: {\n            if (opts.debug) {\n                console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`);\n            }\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (stack.length === opts.capacity) {\n                return stack; // Completely full\n            }\n            else {\n                // Only add some from the new array\n                return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];\n            }\n        }\n        case `newer`: {\n            if (toRemove >= stack.length) {\n                // New items will completely flush out old\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n            }\n            else {\n                // Keep some of the old (from 0)\n                //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n                if (opts.debug) {\n                    console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);\n                }\n                return [\n                    ...stack.slice(0, stack.length - toRemove),\n                    ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n                ];\n            }\n        }\n        case `older`: {\n            // Oldest item in stack is position 0\n            return [...stack, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown discard policy ${policy}`);\n        }\n    }\n};\n// Add to top (last index)\nexport const push = (opts, stack, ...toAdd) => {\n    // If stack is A, B and toAdd is C, D this yields A, B, C, D\n    //const mutated = [...stack, ...toAdd];\n    const potentialLength = stack.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimStack(opts, stack, toAdd)\n        : [...stack, ...toAdd];\n    return toReturn;\n};\n// Remove from top (last index)\nexport const pop = (opts, stack) => {\n    if (stack.length === 0)\n        throw new Error(`Stack is empty`);\n    return stack.slice(0, -1);\n};\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, stack) => stack.at(-1);\nexport const isEmpty = (opts, stack) => stack.length === 0;\nexport const isFull = (opts, stack) => {\n    if (opts.capacity) {\n        return stack.length >= opts.capacity;\n    }\n    return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable {\n    opts;\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    /**\n     * Push data onto the stack.\n     * If `toAdd` is empty, nothing happens\n     * @param toAdd Data to add\n     * @returns Length of stack\n     */\n    push(...toAdd) {\n        if (toAdd.length === 0)\n            return this.data.length;\n        this.data = push(this.opts, this.data, ...toAdd);\n        return this.data.length;\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    pop() {\n        const v = peek(this.opts, this.data);\n        this.data = pop(this.opts, this.data);\n        return v;\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = (opts = {}, ...startingItems) => new StackMutable({ ...opts }, [...startingItems]);\n","import { isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport * as TreeMutable from './tree-mutable.js';\nexport const compare = (a, b, eq = isEqualValueIgnoreOrder, parent) => {\n    const valueEqual = valueOrIdentityEqual(a, b, eq);\n    // if (!valueEqual) {\n    //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n    // }\n    const childrenCompare = compareChildren(a, b, eq);\n    const diff = {\n        valueChanged: !valueEqual, a, b,\n        added: childrenCompare.added,\n        removed: childrenCompare.removed,\n        childChanged: false\n    };\n    const diffNode = {\n        value: diff,\n        childrenStore: [],\n        parent\n    };\n    const childrenDiff = childrenCompare.identical.map(c => compare(c[0], c[1], eq, diffNode));\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value));\n    TreeMutable.setChildren(diffNode, childrenDiff);\n    //diffNode.childrenStore = childrenDiff;\n    diffNode.toString = () => toString(diffNode, 0);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    diffNode.value.childChanged = someChildChange;\n    TreeMutable.throwTreeTest(diffNode);\n    return diffNode;\n};\nconst hasChange = (vv) => {\n    if (vv === undefined)\n        return false;\n    if (vv.valueChanged)\n        return true;\n    if (vv.childChanged)\n        return true;\n    if (vv.added.length > 0)\n        return true;\n    if (vv.removed.length > 0)\n        return true;\n    return false;\n};\nconst compareChildren = (a, b, eq = isEqualValueIgnoreOrder) => {\n    const childrenOfA = [...a.children()];\n    const childrenOfB = [...b.children()];\n    const identical = [];\n    const removed = [];\n    for (const childA of childrenOfA) {\n        let foundIndex = -1;\n        for (const [index, childOfB] of childrenOfB.entries()) {\n            const d = valueOrIdentityEqual(childA, childOfB, eq);\n            if (d) {\n                identical.push([childA, childOfB]);\n                foundIndex = index;\n                break;\n            }\n        }\n        if (foundIndex === -1) {\n            // A's child not found in B's children\n            removed.push(childA);\n        }\n        else {\n            // Found, remove it from list of B's children\n            childrenOfB.splice(foundIndex, 1);\n        }\n    }\n    const added = [...childrenOfB];\n    return { added, identical, removed };\n};\nconst valueOrIdentityEqual = (a, b, eq) => {\n    if (a.getIdentity() === b.getIdentity())\n        return true;\n    if (eq(a.getValue(), b.getValue()))\n        return true;\n    return false;\n};\nconst toStringSingle = (n) => {\n    return JSON.stringify(n.getValue());\n};\nconst toString = (n, indent = 0) => {\n    if (n === undefined)\n        return `(undefined)`;\n    let t = toStringDiff(n.value, indent);\n    for (const c of n.childrenStore) {\n        t += toString(c, indent + 2);\n    }\n    return t;\n};\nconst toStringDiff = (n, indent) => {\n    const spaces = ` `.repeat(indent);\n    if (n === undefined)\n        return `${spaces}(undefined)`;\n    const t = [];\n    t.push(`a: ${toStringSingle(n.a)} b: ${toStringSingle(n.b)}`);\n    if (n.valueChanged)\n        t.push(`Value changed. Child changed: ${n.childChanged}`);\n    else\n        t.push(`Value unchanged. Child changed: ${n.childChanged}`);\n    if (n.added.length > 0) {\n        t.push(`Added:`);\n        for (const c of n.added) {\n            t.push(` - ` + toStringSingle(c));\n        }\n    }\n    if (n.removed.length > 0) {\n        t.push(`Removed: ${n.removed.length}`);\n        for (const c of n.removed) {\n            t.push(` - ` + toStringSingle(c));\n        }\n    }\n    t.push(`----\\n`);\n    return t.map(line => spaces + line).join(`\\n`);\n};\n","import { isEqualDefault } from \"@ixfx/core\";\nimport { without } from '@ixfx/arrays';\nimport { containsDuplicateInstances } from \"@ixfx/arrays\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { compare as treeCompare } from './compare.js';\nimport { toStringAbbreviate } from \"@ixfx/core/text\";\n/**\n * Compares two nodes.\n *\n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a\n * @param b\n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = (a, b, eq) => {\n    return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n};\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n *\n * Recursive: strips parentage of all children and so on too.\n * @param node\n * @returns\n */\nexport const stripParentage = (node) => {\n    const n = {\n        value: node.value,\n        childrenStore: node.childrenStore.map(c => stripParentage(c))\n    };\n    return n;\n};\nconst unwrapped = (node) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = (node) => (`wraps` in node) ? node : wrap(node);\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns\n */\nexport const wrap = (n) => {\n    return {\n        *children() {\n            for (const c of n.childrenStore) {\n                yield wrap(c);\n            }\n        },\n        getValue: () => n.value,\n        getIdentity: () => n,\n        *queryValue(value) {\n            for (const v of queryByValue(value, unwrapped(n))) {\n                yield wrap(v);\n            }\n        },\n        getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n        hasParent: (parent) => {\n            return hasParent(n, unwrapped(parent));\n        },\n        hasAnyParent: (parent) => {\n            return hasAnyParent(n, unwrapped(parent));\n        },\n        hasChild: (child) => {\n            return hasChild(unwrapped(child), n);\n        },\n        hasAnyChild: (child) => {\n            return hasAnyChild(unwrapped(child), n);\n        },\n        remove: () => {\n            remove(n);\n        },\n        addValue: (value) => {\n            const nodeValue = addValue(value, n);\n            return wrap(nodeValue);\n        },\n        add: (child) => {\n            add(unwrapped(child), n);\n            return wrapped(child);\n        },\n        wraps: n\n    };\n};\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child\n * @returns\n */\nexport const remove = (child) => {\n    const p = child.parent;\n    if (p === undefined)\n        return;\n    child.parent = undefined;\n    p.childrenStore = without(p.childrenStore, child);\n};\n/**\n * Depth-first iteration of the children of `node`\n * @param node\n * @returns\n */\nexport function* depthFirst(node) {\n    if (!root)\n        return;\n    const stack = new StackMutable();\n    stack.push(...node.childrenStore);\n    let entry = stack.pop();\n    while (entry) {\n        yield entry;\n        if (entry) {\n            stack.push(...entry.childrenStore);\n        }\n        if (stack.isEmpty)\n            break;\n        entry = stack.pop();\n    }\n}\n/**\n * Breadth-first iteration of the children of `node`\n * @param node\n * @returns\n */\nexport function* breadthFirst(node) {\n    if (!node)\n        return;\n    const queue = new QueueMutable();\n    queue.enqueue(...node.childrenStore);\n    let entry = queue.dequeue();\n    while (entry) {\n        yield entry;\n        if (entry) {\n            queue.enqueue(...entry.childrenStore);\n        }\n        if (queue.isEmpty)\n            break;\n        entry = queue.dequeue();\n    }\n}\n/**\n * Validates the tree from `root` downwards.\n * @param root\n * @param seen\n * @returns\n */\nexport function treeTest(root, seen = []) {\n    if (root.parent === root)\n        return [false, `Root has itself as parent`, root];\n    if (seen.includes(root))\n        return [false, `Same node instance is appearing further in tree`, root];\n    seen.push(root);\n    if (containsDuplicateInstances(root.childrenStore))\n        return [false, `Children list contains duplicates`, root];\n    for (const c of root.childrenStore) {\n        if (c.parent !== root)\n            return [false, `Member of childrenStore does not have .parent set`, c];\n        if (hasAnyChild(root, c))\n            return [false, `Child has parent as its own child`, c];\n        const v = treeTest(c, seen);\n        if (!v[0])\n            return v;\n    }\n    return [true, ``, root];\n}\n/**\n * Throws an exception if `root` fails tree validation\n * @param root\n * @returns\n */\nexport function throwTreeTest(root) {\n    const v = treeTest(root);\n    if (v[0])\n        return;\n    throw new Error(`${v[1]} Node: ${toStringAbbreviate(v[2].value, 30)}`, { cause: v[2] });\n}\n/**\n * Iterate over direct children of `root`\n * @param root\n */\nexport function* children(root) {\n    for (const c of root.childrenStore) {\n        yield c;\n    }\n}\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root\n */\nexport function* parents(root) {\n    let p = root.parent;\n    while (p) {\n        yield p;\n        p = p.parent;\n    }\n}\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node\n * @returns\n */\nexport function nodeDepth(node) {\n    const p = [...parents(node)];\n    return p.length;\n}\nexport const hasChild = (child, parent) => {\n    for (const c of parent.childrenStore) {\n        if (c === child)\n            return true;\n    }\n    return false;\n};\nexport const findChildByValue = (value, parent, eq = isEqualDefault) => {\n    for (const c of parent.childrenStore) {\n        if (eq(value, c.value))\n            return c;\n    }\n};\nexport function* queryByValue(value, parent, eq = isEqualDefault) {\n    for (const c of parent.childrenStore) {\n        if (eq(value, c.value))\n            yield c;\n    }\n}\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n *\n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild\n * @param parent\n * @returns\n */\nexport const hasAnyChild = (prospectiveChild, parent) => {\n    for (const c of breadthFirst(parent)) {\n        if (c === prospectiveChild)\n            return true;\n    }\n    return false;\n};\nexport const findAnyChildByValue = (value, parent, eq = isEqualDefault) => {\n    for (const c of breadthFirst(parent)) {\n        if (eq(c.value, value))\n            return c;\n    }\n};\nexport const getRoot = (node) => {\n    if (node.parent)\n        return getRoot(node.parent);\n    return node;\n};\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n *\n * Use {@link hasParent} to only check immediate parent.\n * @param child\n * @param prospectiveParent\n * @returns\n */\nexport const hasAnyParent = (child, prospectiveParent) => {\n    for (const p of parents(child)) {\n        if (p === prospectiveParent)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n *\n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child\n * @param prospectiveParent\n * @returns\n */\nexport const hasParent = (child, prospectiveParent) => {\n    return child.parent === prospectiveParent;\n};\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root);\n * ```\n * @param node\n * @returns\n */\nexport const computeMaxDepth = (node) => {\n    return computeMaxDepthImpl(node, 0);\n};\nconst computeMaxDepthImpl = (node, startingDepth = 0) => {\n    let depth = startingDepth;\n    for (const c of node.childrenStore) {\n        depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n    }\n    return depth;\n};\nexport const add = (child, parent) => {\n    throwAttemptedChild(child, parent);\n    //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n    //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n    const p = child.parent;\n    parent.childrenStore = [...parent.childrenStore, child];\n    child.parent = parent;\n    if (p) {\n        p.childrenStore = without(p.childrenStore, child);\n    }\n};\nexport const addValue = (value, parent) => {\n    return createNode(value, parent);\n};\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value\n * @returns\n */\nexport const root = (value) => {\n    return createNode(value);\n};\nexport const fromPlainObject = (value, label = ``, parent, seen = []) => {\n    const entries = Object.entries(value);\n    parent = parent === undefined ? root() : addValue({ label, value }, parent);\n    for (const entry of entries) {\n        const value = entry[1];\n        // Avoid circular references\n        if (seen.includes(value))\n            continue;\n        seen.push(value);\n        if (typeof entry[1] === `object`) {\n            fromPlainObject(value, entry[0], parent, seen);\n        }\n        else {\n            addValue({ label: entry[0], value: value }, parent);\n        }\n    }\n    return parent;\n};\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link root} alternatively.\n * @param value\n * @returns\n */\nexport const rootWrapped = (value) => {\n    return wrap(createNode(value));\n};\nexport const createNode = (value, parent) => {\n    const n = {\n        childrenStore: [],\n        parent: parent,\n        value: value\n    };\n    if (parent !== undefined) {\n        parent.childrenStore = [...parent.childrenStore, n];\n    }\n    return n;\n};\nexport const childrenLength = (node) => {\n    return node.childrenStore.length;\n};\nexport const value = (node) => {\n    return node.value;\n};\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node\n * @returns\n */\nexport const asDynamicTraversable = (node) => {\n    const t = {\n        *children() {\n            for (const c of node.childrenStore) {\n                yield asDynamicTraversable(c);\n            }\n        },\n        getParent() {\n            if (node.parent === undefined)\n                return;\n            return asDynamicTraversable(node.parent);\n        },\n        getValue() {\n            return node.value;\n        },\n        getIdentity() {\n            return node;\n        },\n    };\n    return t;\n};\nconst throwAttemptedChild = (c, parent) => {\n    if (parent === c)\n        throw new Error(`Cannot add self as child`);\n    if (c.parent === parent)\n        return; // skip if it's already a child\n    if (hasAnyParent(parent, c))\n        throw new Error(`Child contains parent (1)`, { cause: c });\n    if (hasAnyParent(c, parent))\n        throw new Error(`Parent already contains child`, { cause: c });\n    if (hasAnyChild(parent, c))\n        throw new Error(`Child contains parent (2)`, { cause: c });\n};\nexport const setChildren = (parent, children) => {\n    // Verify children are legit\n    for (const c of children) {\n        throwAttemptedChild(c, parent);\n    }\n    parent.childrenStore = [...children];\n    for (const c of children) {\n        c.parent = parent;\n    }\n};\nexport const toStringDeep = (node, indent = 0) => {\n    const t = `${`  `.repeat(indent)} + ${node.value ? JSON.stringify(node.value) : `-`}`;\n    return node.childrenStore.length > 0 ? (t +\n        `\\n` +\n        node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)) : t;\n};\nexport function* followValue(root, continuePredicate, depth = 1) {\n    for (const c of root.childrenStore) {\n        const value = c.value;\n        if (value === undefined)\n            continue;\n        if (continuePredicate(value, depth)) {\n            yield c.value;\n            yield* followValue(c, continuePredicate, depth + 1);\n        }\n    }\n}\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }\n","import { toStringAbbreviate } from '@ixfx/core/text';\nimport { last } from '@ixfx/iterables/sync';\nimport * as TreeArrayBacked from './tree-mutable.js';\nimport { isPrimitive } from '@ixfx/core'; //'../../util/IsPrimitive.js';\nimport { nullUndefTest, resultThrow } from '@ixfx/guards'; //'../../util/GuardEmpty.js';\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link Entry}.\n * @param entries\n * @returns\n */\nexport function prettyPrintEntries(entries) {\n    if (entries.length === 0)\n        return `(empty)`;\n    let t = ``;\n    for (const [index, entry] of entries.entries()) {\n        t += `  `.repeat(index);\n        t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n    }\n    return t;\n}\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const prettyPrint = (node, indent = 0, options = {}) => {\n    resultThrow(nullUndefTest(node, `node`));\n    const defaultName = options.name ?? `node`;\n    const entry = getNamedEntry(node, defaultName);\n    const t = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.nodeValue)}`;\n    const childrenAsArray = [...children(node, options)];\n    return childrenAsArray.length > 0 ? (t +\n        `\\n` +\n        childrenAsArray.map((d) => prettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)) : t;\n};\n/**\n * Returns a debug string representation of the node (recursive)\n * @param node\n * @param indent\n * @returns\n */\nexport const toStringDeep = (node, indent = 0) => {\n    let t = ` `.repeat(indent) + ` ${node.value?.name}`;\n    if (node.value !== undefined) {\n        if (`sourceValue` in node.value && `nodeValue` in node.value) {\n            let sourceValue = toStringAbbreviate(node.value.sourceValue, 20);\n            const nodeValue = toStringAbbreviate(node.value.nodeValue, 20);\n            sourceValue = sourceValue === nodeValue ? `` : `source: ` + sourceValue;\n            t += ` = ${nodeValue} ${sourceValue}`;\n        }\n        else if (`value` in node.value && node.value.value !== undefined)\n            t += ` = ${node.value.value}`;\n        if (`ancestors` in node.value) {\n            t += ` (ancestors: ${(node.value.ancestors).join(`, `)})`;\n        }\n    }\n    t += `\\n`;\n    for (const c of node.childrenStore) {\n        t += toStringDeep(c, indent + 1);\n    }\n    return t;\n};\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * Sub-children are included as an object blob.\n *\n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n *\n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport function* children(node, options = {}) {\n    resultThrow(nullUndefTest(node, `node`));\n    const filter = options.filter ?? `none`;\n    const filterByValue = (v) => {\n        if (filter === `none`)\n            return [true, isPrimitive(v)];\n        else if (filter === `leaves` && isPrimitive(v))\n            return [true, true];\n        else if (filter === `branches` && !isPrimitive(v))\n            return [true, false];\n        return [false, isPrimitive(v)];\n    };\n    if (Array.isArray(node)) {\n        //if (options.name === undefined) defaultName = `array`;\n        for (const [index, element] of node.entries()) {\n            const f = filterByValue(element);\n            if (f[0]) {\n                yield { name: index.toString(), sourceValue: element, nodeValue: f[1] ? element : undefined };\n                //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n            }\n        }\n    }\n    else if (typeof node === `object`) {\n        const entriesIter = (`entries` in node) ? node.entries() : Object.entries(node);\n        for (const [name, value] of entriesIter) {\n            //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n            const f = filterByValue(value);\n            if (f[0]) {\n                yield { name: name, sourceValue: value, nodeValue: f[1] ? value : undefined };\n            }\n        }\n    }\n}\nexport function* depthFirst(node, options = {}, ancestors = []) {\n    for (const c of children(node, options)) {\n        //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n        yield { ...c, ancestors: [...ancestors] };\n        yield* depthFirst(c.sourceValue, options, [...ancestors, c.name]);\n    }\n}\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName(name, node) {\n    for (const d of children(node)) {\n        if (d.name === name)\n            return d;\n    }\n}\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath(path, node, options = {}) {\n    //  Unit tested\n    const v = last(traceByPath(path, node, options));\n    if (!v)\n        throw new Error(`Could not trace path: ${path} `);\n    return v;\n}\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceByPath(path, node, options = {}) {\n    resultThrow(nullUndefTest(path, `path`), nullUndefTest(node, `node`));\n    const separator = options.separator ?? `.`;\n    // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n    const pathSplit = path.split(separator);\n    const ancestors = [];\n    for (const p of pathSplit) {\n        const entry = childByName(p, node);\n        //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n        // if (allowArrayIndexes) {\n        //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n        //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n        //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n        //   if (arrayIndex >= 0) {\n        //     // Get array by name without the []\n        //     entry = childByName(withoutBrackets, node);\n        //     //onsole.log(`  entry: ${ entry?.name }`);\n        //     if (entry && Array.isArray(entry.sourceValue)) {\n        //       // Result was array as expected\n        //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], nodeValue: entry.sourceValue[ arrayIndex ] };\n        //     }\n        //   }\n        // }\n        if (!entry) {\n            yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n            return;\n        }\n        node = entry.sourceValue;\n        yield { ...entry, ancestors: [...ancestors] };\n        ancestors.push(p);\n    }\n}\n/**\n * Returns a projection of `node` as a dynamic traversable.\n * This means that the tree structure is dynamically created as last-minute as possible.\n *\n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n *\n * ```js\n * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n *\n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n *\n * Instead .getIdentity() to get a stable identity:\n * ```js\n * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n * @param node Object to read\n * @param options Options when creating traversable\n * @param ancestors Do not use\n * @param parent Do not use\n * @returns\n */\nexport const asDynamicTraversable = (node, options = {}, ancestors = [], parent) => {\n    const name = options.name ?? `object`;\n    const t = {\n        *children() {\n            for (const c of children(node, options)) {\n                yield asDynamicTraversable(c.sourceValue, { ...options, name: c.name }, [...ancestors, name], t);\n            }\n        },\n        getParent() {\n            return parent;\n        },\n        getValue() {\n            return { name, value: node, ancestors };\n        },\n        getIdentity() {\n            return node;\n        }\n    };\n    return t;\n};\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node\n * @param options\n * @returns\n */\nexport const createWrapped = (node, options) => {\n    return TreeArrayBacked.wrap(create(node, options));\n};\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure.\n * The structure is a snapshot of the object. If the object changes afterwards, the tree will\n * remain the same.\n *\n * Alternatively, consider {@link asDynamicTraversable} which reads the object dynamically.\n * @param node\n * @param options\n * @returns\n */\nexport const create = (node, options = {}) => {\n    const valuesAtLeaves = options.valuesAtLeaves ?? false;\n    const valueFor = valuesAtLeaves ? (v) => { if (isPrimitive(v))\n        return v; } : (v) => v;\n    return createImpl(node, valueFor(node), options, []);\n};\nconst createImpl = (sourceValue, nodeValue, options = {}, ancestors) => {\n    const defaultName = options.name ?? `object_ci`;\n    //onsole.log(`createImpl name: ${ defaultName } nodeValue: ${ JSON.stringify(nodeValue) }`);\n    const r = TreeArrayBacked.root({ name: defaultName, value: nodeValue, ancestors: [...ancestors] });\n    ancestors = [...ancestors, defaultName];\n    for (const c of children(sourceValue, options)) {\n        const v = options.valuesAtLeaves ? c.nodeValue : c.sourceValue;\n        TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n    }\n    return r;\n};\n/**\n * Returns a copy of `node` with its (and all its children's) parent information removed.\n * @param node\n * @param options\n * @returns\n */\nexport const createSimplified = (node, options = {}) => {\n    return TreeArrayBacked.stripParentage(create(node, options));\n};\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry(node, defaultName = ``) {\n    if (`name` in node && `nodeValue` in node && `sourceValue` in node)\n        return node;\n    if (`name` in node) {\n        return { name: node.name, nodeValue: node, sourceValue: node };\n    }\n    return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }\n","import * as TreeArrayBacked from \"./tree-mutable.js\";\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n *\n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n *\n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n *\n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n *\n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts\n * @returns\n */\nexport const create = (pathOpts = {}) => {\n    let root;\n    const add = (value, path) => {\n        const n = addValueByPath(value, path, root, pathOpts);\n        if (root === undefined) {\n            root = TreeArrayBacked.getRoot(n);\n        }\n    };\n    const prettyPrint = () => {\n        if (root === undefined)\n            return `(empty)`;\n        return TreeArrayBacked.toStringDeep(root);\n    };\n    const getValue = (path) => {\n        if (root === undefined)\n            return;\n        return valueByPath(path, root, pathOpts);\n    };\n    const remove = (path) => {\n        if (root === undefined)\n            return false;\n        return removeByPath(path, root, pathOpts);\n    };\n    const hasPath = (path) => {\n        if (root === undefined)\n            return false;\n        const c = findChildByPath(path, root, pathOpts);\n        return c !== undefined;\n    };\n    const getNode = (path) => {\n        if (root === undefined)\n            return;\n        const c = findChildByPath(path, root, pathOpts);\n        return c;\n    };\n    const childrenLength = (path) => {\n        if (root === undefined)\n            return 0;\n        const c = findChildByPath(path, root, pathOpts);\n        if (c === undefined)\n            return 0;\n        return c.childrenStore.length;\n    };\n    const getValues = (path) => {\n        if (root === undefined)\n            return [];\n        return valuesByPath(path, root, pathOpts);\n    };\n    const getRoot = () => {\n        return root;\n    };\n    const clearValues = (path) => {\n        if (root === undefined)\n            return false;\n        return clearValuesByPath(path, root, pathOpts);\n    };\n    return { getRoot, add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues };\n};\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n *\n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = (value, path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n    const split = path.split(separator);\n    let count = 0;\n    for (const p of split) {\n        const lastEntry = count === split.length - 1;\n        //onsole.log(`p: ${ p }`);\n        const found = findChildByLabel(p, node);\n        if (found === undefined) {\n            //onsole.log(`  - not found`);\n            const labelled = {\n                value: (lastEntry ? value : undefined),\n                label: p\n            };\n            node = TreeArrayBacked.createNode(labelled, node);\n        }\n        else {\n            node = found;\n            if (lastEntry) {\n                switch (duplicatePath) {\n                    case `ignore`: {\n                        break;\n                    }\n                    case `allow`: {\n                        const existing = getValuesFromNode(node);\n                        node.value = {\n                            values: [...existing, value],\n                            label: p\n                        };\n                        break;\n                    }\n                    case `overwrite`: {\n                        node.value = {\n                            value,\n                            label: p\n                        };\n                        break;\n                    }\n                }\n            }\n            else {\n                //onsole.log(`  - found!`, found.value);\n                node = found;\n            }\n        }\n        count++;\n    }\n    if (node === undefined)\n        throw new Error(`Could not create tree`);\n    return node;\n};\nexport const removeByPath = (path, root, pathOpts = {}) => {\n    if (root === undefined)\n        return false;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined)\n        return false;\n    TreeArrayBacked.remove(c);\n    return true;\n};\nexport const clearValuesByPath = (path, root, pathOpts = {}) => {\n    if (root === undefined)\n        return false;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined)\n        return false;\n    c.value = {\n        label: c.value?.label ?? ``,\n        value: undefined\n    };\n    return true;\n};\nexport const childrenLengthByPath = (path, node, pathOpts = {}) => {\n    if (node === undefined)\n        return 0;\n    const c = findChildByPath(path, node, pathOpts);\n    if (c === undefined)\n        return 0;\n    return c.childrenStore.length;\n};\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = (label, node) => {\n    if (node === undefined)\n        return undefined;\n    if (label === undefined)\n        throw new Error(`Parameter 'label' cannot be undefined`);\n    if (node.value?.label === label)\n        return node;\n    for (const c of node.childrenStore) {\n        if (c.value?.label === label)\n            return c;\n    }\n};\nexport const valueByPath = (path, node, pathOpts = {}) => {\n    const values = valuesByPath(path, node, pathOpts);\n    if (values.length === 0)\n        return undefined;\n    if (values.length > 1)\n        throw new Error(`Multiple values at path. Use getValues instead`);\n    return values[0];\n};\nconst getValuesFromNode = (c) => {\n    if (c.value === undefined)\n        return [];\n    if (`values` in c.value)\n        return c.value.values;\n    if (`value` in c.value) {\n        if (c.value.value === undefined)\n            return [];\n        return [c.value.value];\n    }\n    return [];\n};\nconst findChildByPath = (path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const split = path.split(separator);\n    let c = node;\n    for (const p of split) {\n        c = findChildByLabel(p, c);\n        if (c === undefined) {\n            return;\n        }\n    }\n    return c;\n};\nexport const valuesByPath = (path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const split = path.split(separator);\n    let c = node;\n    for (const p of split) {\n        //onsole.log(`getValue p: ${ p }`);\n        c = findChildByLabel(p, c);\n        if (c === undefined) {\n            //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n            return [];\n        }\n    }\n    return getValuesFromNode(c);\n};\n","import { toStringAbbreviate } from \"@ixfx/core/text\";\nimport { isEqualDefault } from \"@ixfx/core\"; //\"../../util/IsEqual.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { isTraversable } from \"./index.js\";\nexport const childrenLength = (tree) => {\n    return [...tree.children()].length;\n};\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = (child, possibleParent, eq) => {\n    return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const hasAnyParentValue = (child, possibleParentValue, eq) => {\n    return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const findAnyParentByValue = (child, possibleParentValue, eq) => {\n    return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = (child, possibleParent, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    const isChildTrav = isTraversable(child);\n    const isParentTrav = isTraversable(possibleParent);\n    const p = (isChildTrav ? child.getParent() : child.parent);\n    if (typeof p === `undefined`)\n        return false;\n    if (eq(p, possibleParent))\n        return true;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const pId = isChildTrav ? p.getIdentity() : p.value;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const ppId = isParentTrav ? (possibleParent).getIdentity() : possibleParent.value;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    if (eq(pId, ppId))\n        return true;\n    //if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n    return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\nexport const hasParentValue = (child, possibleParentValue, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    const p = `getParent` in child ? child.getParent() : child.parent;\n    if (p === undefined)\n        return false;\n    const value = `getValue` in p ? p.getValue() : p.value;\n    if (eq(value, possibleParentValue))\n        return true;\n    return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\nexport const findParentByValue = (child, possibleParentValue, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return;\n    const p = (`getParent` in child ? child.getParent() : child.parent);\n    if (p === undefined)\n        return;\n    const value = `getValue` in p ? p.getValue() : p.value;\n    if (eq(value, possibleParentValue))\n        return p;\n    return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = (parent, prospectiveChild, eq = isEqualDefault) => {\n    if (eq(parent, prospectiveChild))\n        throw new Error(`Child equals parent`);\n    if (hasAnyChild(parent, prospectiveChild, eq)) {\n        throw new Error(`Circular. Parent already has child`);\n    }\n    if (hasAnyChild(prospectiveChild, parent, eq)) {\n        throw new Error(`Prospective child has parent as child relation`);\n    }\n};\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = (parent, possibleChild, eq = isEqualDefault) => {\n    return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const hasAnyChildValue = (parent, possibleChildValue, eq = isEqualDefault) => {\n    return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = (parent, possibleChild, eq = isEqualDefault, maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    if (eq(parent, possibleChild))\n        return true;\n    const pId = `getIdentity` in parent ? parent.getIdentity() : parent.value;\n    const pcId = `getIdentity` in possibleChild ? possibleChild.getIdentity() : possibleChild.value;\n    if (eq(pId, pcId))\n        return true;\n    for (const c of breadthFirst(parent, maxDepth)) {\n        const cId = `getIdentity` in c ? c.getIdentity() : c.value;\n        if (eq(c, possibleChild))\n            return true;\n        if (eq(cId, pcId))\n            return true;\n    }\n    return false;\n};\nexport const hasChildValue = (parent, possibleValue, eq = isEqualDefault, maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    if (eq(parent.getValue(), possibleValue))\n        return true;\n    for (const c of breadthFirst(parent, maxDepth)) {\n        if (eq(c.getValue(), possibleValue))\n            return true;\n    }\n    return false;\n};\n/**\n * Iterates over siblings of `node`.\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns\n */\nexport function* siblings(node) {\n    const p = node.getParent();\n    if (p === undefined)\n        return;\n    for (const s of p.children()) {\n        if (s === node)\n            continue;\n        yield s;\n    }\n}\n// export function parents<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>>;\n// export function parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>>;\n/**\n * Iterates over parents of `node`, starting with immediate parent\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns\n */\nexport function* parents(node) {\n    if (isTraversable(node)) {\n        let p = node.getParent();\n        while (p !== undefined) {\n            yield p;\n            p = p.getParent();\n        }\n    }\n    else {\n        let p = node.parent;\n        while (p !== undefined) {\n            yield p;\n            p = p.parent;\n        }\n    }\n}\n// export function findAnyChildByValue<TValue>(parent: TraversableTree<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TraversableTree<TValue> | undefined;\n// export function findAnyChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TreeNode<TValue> | undefined;\n/**\n * Descends `parent`, breadth-first, looking for a particular value.\n * Returns _undefined_ if not found.\n * @param parent\n * @param possibleValue\n * @param eq\n * @returns\n */\nexport function findAnyChildByValue(parent, possibleValue, eq = isEqualDefault) {\n    return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n}\n;\n// export function findChildByValue<T extends TraversableTree<TV> | TreeNode<TV>, TV>(parent: T,\n//   possibleValue: TV,\n//   eq?: IsEqual<TV>,\n//   maxDepth?: number\n// ): TraversableTree<TV> | undefined;\n// export function findChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>,\n//   maxDepth?: number\n// ): TreeNode<TValue> | undefined;\n/**\n * Searches breadth-first for `possibleValue` under and including `parent`.\n * `maxDepth` sets he maximum level to which the tree is searched.\n * @param parent\n * @param possibleValue\n * @param eq\n * @param maxDepth\n * @returns\n */\nexport function findChildByValue(parent, possibleValue, eq = isEqualDefault, maxDepth = 0) {\n    if (maxDepth < 0)\n        return;\n    const isTraver = isTraversable(parent);\n    if (isTraver) {\n        if (eq(parent.getValue(), possibleValue))\n            return parent;\n    }\n    else {\n        if (eq(parent.value, possibleValue))\n            return parent;\n    }\n    for (const d of breadthFirst(parent, maxDepth)) {\n        // This child matches\n        if (isTraver) {\n            if (eq(d.getValue(), possibleValue))\n                return d;\n        }\n        else {\n            if (eq(d.value, possibleValue))\n                return d;\n        }\n    }\n    return;\n}\n;\n/**\n * Iterates over children of `root`, depth-first.\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @returns\n */\nexport function* depthFirst(root) {\n    if (!root)\n        return;\n    const stack = new StackMutable();\n    let entry = root;\n    while (entry) {\n        const entries = isTraversable(entry) ?\n            [...entry.children()] :\n            [...entry.childrenStore];\n        stack.push(...entries);\n        if (stack.isEmpty)\n            break;\n        entry = stack.pop();\n        if (entry)\n            yield entry;\n    }\n}\n//export function breadthFirst<T>(root: TraversableTree<T>, depth?: number): IterableIterator<TraversableTree<T>>;\n//export function breadthFirst<T>(root: TreeNode<T>, depth?: number): IterableIterator<TreeNode<T>>;\n/**\n * Iterates over the children of `root`, breadth-first\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @param depth How many levels to traverse\n * @returns\n */\nexport function* breadthFirst(root, depth = Number.MAX_SAFE_INTEGER) {\n    if (!root)\n        return;\n    const isTrav = isTraversable(root);\n    const queue = isTrav ? new QueueMutable() : new QueueMutable();\n    let entry = root;\n    while (entry) {\n        if (depth < 0)\n            return;\n        if (entry !== undefined) {\n            const kids = `childrenStore` in entry ? entry.childrenStore : entry.children();\n            for (const c of kids) {\n                yield c;\n                queue.enqueue(c);\n            }\n        }\n        entry = queue.dequeue();\n        depth--;\n    }\n}\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root\n * @param predicate\n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns\n */\nexport function find(root, predicate, order = `breadth`) {\n    if (predicate(root))\n        return root;\n    const iter = order === `breadth` ? breadthFirst : depthFirst;\n    for (const c of iter(root)) {\n        if (predicate(c))\n            return c;\n    }\n}\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n *\n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root\n * @param predicate\n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns\n */\nexport function findByValue(root, predicate, order = `breadth`) {\n    if (predicate(root.getValue()))\n        return root;\n    const iter = order === `breadth` ? breadthFirst : depthFirst;\n    for (const c of iter(root)) {\n        if (predicate(c.getValue()))\n            return c;\n    }\n}\n/**\n * Search through children in a path-like manner.\n *\n * It finds the first child of `root` that matches `continuePredicate`.\n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n *\n * If it can't find a child, it stops.\n *\n * This is different to 'find' functions, which exhausively search all possible child nodes, regardless of position in tree.\n *\n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n *\n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root\n * @param continuePredicate\n * @param depth\n */\nexport function* followValue(root, continuePredicate, depth = 1) {\n    for (const c of root.children()) {\n        if (continuePredicate(c.getValue(), depth)) {\n            yield c.getValue();\n            yield* followValue(c, continuePredicate, depth + 1);\n        }\n    }\n}\nexport function toStringDeep(node, depth = 0) {\n    if (node === undefined)\n        return `(undefined)`;\n    if (node === null)\n        return `(null)`;\n    const v = node.getValue();\n    let type = typeof v;\n    if (Array.isArray(v))\n        type = `array`;\n    let t = `  `.repeat(depth) + `value: ${JSON.stringify(v)} (${type})\\n`;\n    for (const n of node.children()) {\n        t += toStringDeep(n, depth + 1);\n    }\n    return t;\n}\nexport function toString(...nodes) {\n    let t = ``;\n    for (const node of nodes) {\n        const v = node.getValue();\n        const vString = toStringAbbreviate(v);\n        const children = [...node.children()];\n        const parent = node.getParent();\n        let type = typeof v;\n        if (Array.isArray(v))\n            type = `array`;\n        t += `value: ${vString} (${type}) kids: ${children.length} parented: ${parent ? `y` : `n`}\\n`;\n    }\n    return t;\n}\n","import { asDynamicTraversable as ObjectToTraversable } from './traverse-object.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './tree-mutable.js';\nexport * as Mutable from './tree-mutable.js';\nexport * as Pathed from './pathed.js';\nexport * as FromObject from './traverse-object.js';\nexport * as Traverse from './traversable-tree.js';\nexport * from './compare.js';\nexport const toTraversable = (node) => {\n    if (isTraversable(node))\n        return node;\n    if (isTreeNode(node))\n        return TreeNodeToTraversable(node);\n    if (typeof node === `object`)\n        return ObjectToTraversable(node);\n    throw new Error(`Parameter 'node' not convertible`);\n};\nexport const isTreeNode = (node) => {\n    if (`parent` in node && `childrenStore` in node && `value` in node) {\n        if (Array.isArray(node.childrenStore))\n            return true;\n    }\n    return false;\n};\nexport const isTraversable = (node) => {\n    return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n};\n","import { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nexport class StackImmutable {\n    opts;\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    push(...toAdd) {\n        return new StackImmutable(this.opts, push(this.opts, this.data, ...toAdd));\n    }\n    pop() {\n        return new StackImmutable(this.opts, pop(this.opts, this.data));\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = (options = {}, ...startingItems) => new StackImmutable({ ...options }, [...startingItems]);\n","export * from './StackImmutable.js';\nexport * from './StackMutable.js';\nexport * from './StackFns.js';\n","//  UNIT TESTED\nimport { defaultKeyer } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\nimport {} from './ISetMutable.js';\nimport {} from './Types.js';\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = (keyString) => new SetStringMutable(keyString);\n/**\n * Mutable string set\n */\nexport class SetStringMutable extends SimpleEventEmitter {\n    //  UNIT TESTED\n    /* eslint-disable functional/prefer-readonly-type */\n    store = new Map();\n    keyString;\n    /**\n     * Constructor\n     * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n     */\n    constructor(keyString) {\n        super();\n        this.keyString = keyString ?? (defaultKeyer);\n    }\n    /**\n     * Number of items stored in set\n     */\n    get size() {\n        return this.store.size;\n    }\n    /**\n     * Adds one or more items to set. `add` event is fired for each item\n     * @param values items to add\n     */\n    add(...values) {\n        //eslint-disable-next-line functional/no-let\n        let somethingAdded = false;\n        for (const value of values) {\n            const isUpdated = this.has(value);\n            this.store.set(this.keyString(value), value);\n            super.fireEvent(`add`, { value: value, updated: isUpdated });\n            if (!isUpdated)\n                somethingAdded = true;\n        }\n        return somethingAdded;\n    }\n    /**\n     * Returns values from set as an iterable\n     * @returns\n     */\n    //eslint-disable-next-line functional/prefer-tacit\n    values() {\n        return this.store.values();\n    }\n    /**\n     * Clear items from set\n     */\n    clear() {\n        this.store.clear();\n        super.fireEvent(`clear`, true);\n    }\n    /**\n     * Delete value from set.\n     * @param v Value to delete\n    * @returns _True_ if item was found and removed\n     */\n    delete(v) {\n        const isDeleted = this.store.delete(this.keyString(v));\n        if (isDeleted)\n            super.fireEvent(`delete`, v);\n        return isDeleted;\n    }\n    /**\n     * Returns _true_ if item exists in set\n     * @param v\n     * @returns\n     */\n    has(v) {\n        return this.store.has(this.keyString(v));\n    }\n    /**\n     * Returns array copy of set\n     * @returns Array copy of set\n     */\n    toArray() {\n        return [...this.store.values()];\n    }\n}\n","import { defaultKeyer, toStringDefault } from '@ixfx/core';\nimport {} from './ISetImmutable.js';\nexport class SetStringImmutable {\n    store;\n    keyString;\n    //eslint-disable-next-line functional/prefer-immutable-types\n    constructor(keyString, map) {\n        this.store = map ?? new Map();\n        this.keyString = keyString ?? (defaultKeyer);\n    }\n    get size() {\n        return this.store.size;\n    }\n    add(...values) {\n        const s = new Map(this.store);\n        for (const v of values) {\n            const key = this.keyString(v);\n            s.set(key, v);\n        }\n        return new SetStringImmutable(this.keyString, s);\n    }\n    delete(v) {\n        const s = new Map(this.store);\n        const key = this.keyString(v);\n        if (s.delete(key))\n            return new SetStringImmutable(this.keyString, s);\n        return this;\n    }\n    has(v) {\n        const key = this.keyString(v);\n        return this.store.has(key);\n    }\n    toArray() {\n        return [...this.store.values()];\n    }\n    *values() {\n        yield* this.store.values();\n    }\n}\n/**\n * Immutable set that uses a `keyString` function to determine uniqueness\n *\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`.\n * @returns\n */\nexport const immutable = (keyString = toStringDefault) => new SetStringImmutable(keyString);\n","/**\n * MassiveSet supports semantics similar to Set, but without the\n * limitation on how much data is stored.\n *\n * It only supports strings, and stores data in a hierarchy.\n *\n * ```js\n * const set = new MassiveSet(); // maxDepth=1 default\n * set.add(`test`);\n * set.add(`bloorp`);\n * ```\n *\n * In the above example, it will create a subtree for the first letter\n * of each key, putting the value underneath it. So we'd get a sub\n * MassiveSet for every key starting with 't' and every one starting with 'b'.\n *\n * If `maxDepth` was 2, we'd get the same two top-level nodes, but then\n * another sub-node based on the _second_ character of the value.\n *\n * It's not a very smart data-structure since it does no self-balancing\n * or tuning.\n */\nexport class MassiveSet {\n    #depth;\n    #maxDepth;\n    children = new Map();\n    values = [];\n    constructor(maxDepth = 1, depth = 0) {\n        this.#depth = depth;\n        this.#maxDepth = maxDepth;\n    }\n    /**\n     * Returns the number of values stored in just this level of the set\n     * @returns\n     */\n    sizeLocal() {\n        return this.values.length;\n    }\n    /**\n     * Returns the number of branches at this node\n     * Use {@link sizeChildrenDeep} to count all branches recursively\n     * @returns\n     */\n    sizeChildren() {\n        return [...this.children.values()].length;\n    }\n    sizeChildrenDeep() {\n        let t = this.sizeChildren();\n        for (const c of this.children.values()) {\n            t += c.sizeChildrenDeep();\n        }\n        return t;\n    }\n    /**\n     * Returns the total number of values stored in the set\n     */\n    size() {\n        let x = this.values.length;\n        for (const set of this.children.values()) {\n            x += set.size();\n        }\n        return x;\n    }\n    add(value) {\n        if (typeof value !== `string`)\n            throw new Error(`Param 'value' must be a string. Got: ${typeof value}`);\n        if (value.length === 0)\n            throw new Error(`Param 'value' is empty`);\n        const destination = this.#getChild(value, true);\n        if (destination === this) {\n            if (!this.hasLocal(value)) {\n                this.values.push(value);\n            }\n            return;\n        }\n        if (!destination)\n            throw new Error(`Could not create child set for: ${value}`);\n        destination.add(value);\n    }\n    remove(value) {\n        if (typeof value !== `string`)\n            throw new Error(`Param 'value' must be a string. Got: ${typeof value}`);\n        if (value.length === 0)\n            throw new Error(`Param 'value' is empty`);\n        const destination = this.#getChild(value, false);\n        if (destination === undefined)\n            return false;\n        if (destination === this) {\n            if (this.hasLocal(value)) {\n                this.values = this.values.filter(v => v !== value);\n                return true;\n            }\n            return false; // Not found\n        }\n        return destination.remove(value);\n    }\n    debugDump() {\n        const r = this.#dumpToArray();\n        for (const rr of r) {\n            console.log(rr);\n        }\n    }\n    #dumpToArray(depth = 0) {\n        const r = [];\n        r.push(`Depth: ${this.#depth} Max: ${this.#maxDepth}`);\n        for (const [key, value] of this.children.entries()) {\n            const dumped = value.#dumpToArray(depth + 1);\n            r.push(` key: ${key}`);\n            for (const d of dumped) {\n                r.push(` `.repeat(depth + 1) + d);\n            }\n        }\n        r.push(`Values: (${this.values.length})`);\n        for (const v of this.values) {\n            r.push(` ${v}`);\n        }\n        return r.map(line => ` `.repeat(depth) + line);\n    }\n    #getChild(value, create) {\n        if (value === undefined)\n            throw new Error(`Param 'value' undefined`);\n        if (this.#depth === this.#maxDepth)\n            return this;\n        if (value.length <= this.#depth)\n            return this;\n        const k = value[this.#depth];\n        if (k === undefined)\n            throw new Error(`Logic error. Depth: ${this.#depth} Len: ${value.length}`);\n        let child = this.children.get(k);\n        if (child === undefined && create) {\n            child = new MassiveSet(this.#maxDepth, this.#depth + 1);\n            this.children.set(k, child);\n        }\n        return child;\n    }\n    /**\n     * Returns _true_ if `value` stored on this node\n     * @param value\n     * @returns\n     */\n    hasLocal(value) {\n        for (const v of this.values) {\n            if (v === value)\n                return true;\n        }\n        return false;\n    }\n    has(value) {\n        if (typeof value !== `string`)\n            return false;\n        const destination = this.#getChild(value, false);\n        if (destination === undefined)\n            return false;\n        if (destination === this)\n            return this.hasLocal(value);\n        return destination.has(value);\n    }\n}\n","export * from './set-mutable.js';\nexport * from './SetImmutable.js';\nexport {} from './ISetMutable.js';\nexport {} from './ISetImmutable.js';\nexport * from './massive-set.js';\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { isEqualDefault } from \"@ixfx/core\";\nimport { max as IterablesMax, min as IterablesMin, last as IterablesLast } from \"@ixfx/iterables\";\nimport { QueueMutable } from \"./queue-mutable.js\";\n/**\n * Simple priority queue implementation.\n * Higher numbers mean higher priority.\n *\n * ```js\n * const pm = new PriorityMutable();\n *\n * // Add items with a priority (higher numeric value = higher value)\n * pm.enqueueWithPriority(`hello`, 4);\n * pm.enqueueWithPriotity(`there`, 1);\n *\n * ```\n */\nexport class PriorityMutable extends QueueMutable {\n    constructor(opts = {}) {\n        if (opts.eq === undefined) {\n            opts = {\n                ...opts,\n                eq: (a, b) => {\n                    return isEqualDefault(a.item, b.item);\n                }\n            };\n        }\n        super(opts);\n    }\n    /**\n     * Adds an item with a given priority\n     * @param item Item\n     * @param priority Priority (higher numeric value means higher priority)\n     */\n    enqueueWithPriority(item, priority) {\n        resultThrow(numberTest(priority, `positive`));\n        super.enqueue({ item, priority });\n    }\n    changePriority(item, priority, addIfMissing = false, eq) {\n        if (item === undefined)\n            throw new Error(`Item cannot be undefined`);\n        let toDelete;\n        for (const d of this.data) {\n            if (eq) {\n                if (eq(d.item, item)) {\n                    toDelete = d;\n                    break;\n                }\n            }\n            else {\n                if (this.eq(d, { item, priority: 0 })) {\n                    toDelete = d;\n                    break;\n                }\n            }\n        }\n        if (toDelete === undefined && !addIfMissing)\n            throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(item)}`);\n        if (toDelete !== undefined) {\n            this.removeWhere(item => toDelete === item);\n        }\n        this.enqueueWithPriority(item, priority);\n    }\n    dequeueMax() {\n        //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        this.removeWhere(item => item === m);\n        return m.item;\n    }\n    dequeueMin() {\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        //const m = IterablesLast(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        this.removeWhere(item => item.item === m);\n        return m.item;\n    }\n    peekMax() {\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n        if (m === undefined)\n            return;\n        return m.item;\n    }\n    peekMin() {\n        //const m = IterablesLast<V>(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n        const m = IterablesLast(IterablesMin(this.data, (a, b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        return m.item;\n    }\n}\n/**\n * Creates a {@link PriorityMutable} queue.\n *\n * Options:\n * * eq: Equality function\n * * capacity: limit on number of items\n * * discardPolicy: what to do if capacity is reached\n * @param opts\n * @returns\n */\nexport function priority(opts = {}) {\n    return new PriorityMutable(opts);\n}\n","import { peek, isFull, isEmpty, enqueue, dequeue } from './queue-fns.js';\nimport {} from './queue-types.js';\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable {\n    opts;\n    #data;\n    /**\n     * Creates an instance of Queue.\n     * @param {QueueOpts} opts Options foor queue\n     * @param {V[]} data Initial data. Index 0 is front of queue\n     */\n    constructor(opts = {}, data = []) {\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.opts = opts;\n        this.#data = data;\n    }\n    forEach(fn) {\n        //eslint-disable-next-line functional/no-let\n        for (let index = this.#data.length - 1; index >= 0; index--) {\n            fn(this.#data[index]);\n        }\n    }\n    forEachFromFront(fn) {\n        // From front of queue\n        // eslint-disable-next-line unicorn/no-array-for-each\n        this.#data.forEach(item => { fn(item); }); //(vv) => fn(vv));\n    }\n    enqueue(...toAdd) {\n        return new QueueImmutable(this.opts, enqueue(this.opts, this.#data, ...toAdd));\n    }\n    dequeue() {\n        return new QueueImmutable(this.opts, dequeue(this.opts, this.#data));\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.#data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.#data);\n    }\n    get length() {\n        return this.#data.length;\n    }\n    get peek() {\n        return peek(this.opts, this.#data);\n    }\n    toArray() {\n        return [...this.#data];\n    }\n}\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * import { Queues } from \"https://unpkg.com/ixfx/dist/collections.js\"\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @typeParam V - Type of values stored\n * @param options\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = (options = {}, ...startingItems) => {\n    options = { ...options }; // Make a copy of options\n    return new QueueImmutable(options, [...startingItems]); // Make a copy of array so it can't be modified\n};\n","export * from './priority-mutable.js';\nexport { immutable } from './queue-immutable.js';\nexport { mutable } from './queue-mutable.js';\n//export * from './Responsive.js';\nexport * from './queue-fns.js';\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { sortByValueProperty } from '@ixfx/core/maps';\nimport { intervalToMs } from '@ixfx/core';\nimport { integerTest, resultThrow } from '@ixfx/guards';\n/**\n * Create a ExpiringMap instance\n * @param options Options when creating map\n * @returns\n */\nexport const create = (options = {}) => new ExpiringMap(options);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using {@link touch}.\n *\n *\n * Events:\n * * 'expired': when an item is automatically removed.\n * * 'removed': when an item is manually or automatically removed.\n * * 'newKey': when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example\n * Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example\n * Automatically delete the oldest item if we reach a capacity limit\n * ```js\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n * @typeParam K - Type of keys\n * @typeParam V - Type of values\n */\nexport class ExpiringMap extends SimpleEventEmitter {\n    capacity;\n    store;\n    //private keyCount: number;\n    evictPolicy;\n    autoDeleteElapsedMs;\n    autoDeletePolicy;\n    autoDeleteTimer;\n    disposed = false;\n    constructor(opts = {}) {\n        super();\n        this.capacity = opts.capacity ?? -1;\n        resultThrow(integerTest(this.capacity, `nonZero`, `capacity`));\n        this.store = new Map();\n        //this.keyCount = 0;\n        if (opts.evictPolicy && this.capacity <= 0) {\n            throw new Error(`evictPolicy is set, but no capacity limit is set`);\n        }\n        this.evictPolicy = opts.evictPolicy ?? `none`;\n        this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n        this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n        if (this.autoDeleteElapsedMs > 0) {\n            this.autoDeleteTimer = setInterval(() => { this.#maintain(); }, Math.max(1000, this.autoDeleteElapsedMs * 2));\n        }\n    }\n    dispose() {\n        if (this.disposed)\n            return;\n        this.disposed = true;\n        if (this.autoDeleteTimer) {\n            clearInterval(this.autoDeleteTimer);\n            this.autoDeleteTimer = undefined;\n        }\n    }\n    /**\n     * Returns the number of keys being stored.\n     */\n    get keyLength() {\n        return this.store.size; // keyCount;\n    }\n    *entries() {\n        for (const entry of this.store.entries()) {\n            yield [entry[0], entry[1].value];\n        }\n    }\n    *values() {\n        for (const v of this.store.values()) {\n            yield v.value;\n        }\n    }\n    *keys() {\n        yield* this.store.keys();\n    }\n    /**\n     * Returns the elapsed time since `key`\n     * was set. Returns _undefined_ if `key`\n     * does not exist\n     */\n    elapsedSet(key) {\n        const v = this.store.get(key);\n        if (typeof v === `undefined`)\n            return;\n        return Date.now() - v.lastSet;\n    }\n    /**\n     * Returns the elapsed time since `key`\n     * was accessed. Returns _undefined_ if `key`\n     * does not exist\n     */\n    elapsedGet(key) {\n        const v = this.store.get(key);\n        if (typeof v === `undefined`)\n            return;\n        return Date.now() - v.lastGet;\n    }\n    /**\n     * Returns true if `key` is stored.\n     * Does not affect the key's last access time.\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.store.has(key);\n    }\n    /**\n     * Gets an item from the map by key, returning\n     * undefined if not present\n     * @param key Key\n     * @returns Value, or undefined\n     */\n    get(key) {\n        const v = this.store.get(key);\n        if (v) {\n            if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) {\n                this.store.set(key, {\n                    ...v,\n                    lastGet: performance.now(),\n                });\n            }\n            return v.value;\n        }\n    }\n    /**\n     * Deletes the value under `key`, if present.\n     *\n     * Returns _true_ if something was removed.\n     * @param key\n     * @returns\n     */\n    delete(key) {\n        const value = this.store.get(key);\n        if (!value)\n            return false;\n        const d = this.store.delete(key);\n        //this.keyCount = this.keyCount - 1;\n        this.fireEvent(`removed`, {\n            key,\n            value: value.value,\n        });\n        return d;\n    }\n    /**\n     * Clears the contents of the map.\n     * Note: does not fire `removed` event\n     */\n    clear() {\n        this.store.clear();\n    }\n    /**\n     * Updates the lastSet/lastGet time for a value\n     * under `k`.\n     *\n     * Returns false if key was not found\n     * @param key\n     * @returns\n     */\n    touch(key) {\n        const v = this.store.get(key);\n        if (!v)\n            return false;\n        this.store.set(key, {\n            ...v,\n            lastSet: Date.now(),\n            lastGet: Date.now(),\n        });\n        return true;\n    }\n    findEvicteeKey() {\n        if (this.evictPolicy === `none`)\n            return;\n        let sortBy = ``;\n        if (this.evictPolicy === `oldestGet`)\n            sortBy = `lastGet`;\n        else if (this.evictPolicy === `oldestSet`)\n            sortBy = `lastSet`;\n        else\n            throw new Error(`Unknown eviction policy ${this.evictPolicy}`);\n        const sorted = sortByValueProperty(this.store, sortBy);\n        return sorted[0][0];\n    }\n    #maintain() {\n        if (this.autoDeletePolicy === `none`)\n            return;\n        this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n    }\n    /**\n     * Deletes all values where elapsed time has past\n     * for get/set or either.\n     * ```js\n     * // Delete all keys (and associated values) not accessed for a minute\n     * em.deleteWithElapsed({mins:1}, `get`);\n     * // Delete things that were set 1s ago\n     * em.deleteWithElapsed(1000, `set`);\n     * ```\n     *\n     * @param interval Interval\n     * @param property Basis for deletion 'get','set' or 'either'\n     * @returns Items removed\n     */\n    deleteWithElapsed(interval, property) {\n        const entries = [...this.store.entries()];\n        const prune = [];\n        const intervalMs = intervalToMs(interval, 1000);\n        const now = performance.now();\n        for (const entry of entries) {\n            const elapsedGet = now - entry[1].lastGet;\n            const elapsedSet = now - entry[1].lastSet;\n            const elapsed = property === `get`\n                ? elapsedGet\n                : (property === `set`\n                    ? elapsedSet\n                    : Math.max(elapsedGet, elapsedSet));\n            if (elapsed >= intervalMs) {\n                prune.push([entry[0], entry[1].value]);\n            }\n        }\n        for (const entry of prune) {\n            this.store.delete(entry[0]);\n            //this.keyCount = this.keyCount - 1;\n            const eventArguments = {\n                key: entry[0],\n                value: entry[1],\n            };\n            this.fireEvent(`expired`, eventArguments);\n            this.fireEvent(`removed`, eventArguments);\n        }\n        return prune;\n    }\n    /**\n     * Sets the `key` to be `value`.\n     *\n     * If the key already exists, it is updated.\n     *\n     * If the map is full, according to its capacity,\n     * another value is selected for removal.\n     * @param key\n     * @param value\n     * @returns\n     */\n    set(key, value) {\n        const existing = this.store.get(key);\n        if (existing) {\n            // Update set time\n            this.store.set(key, {\n                ...existing,\n                lastSet: performance.now(),\n            });\n            return;\n        }\n        // New key\n        if (this.keyLength === this.capacity && this.capacity > 0) {\n            // Evict first\n            const key = this.findEvicteeKey();\n            if (!key) {\n                throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);\n            }\n            const existing = this.store.get(key);\n            this.store.delete(key);\n            //this.keyCount = this.keyCount - 1;\n            if (existing) {\n                const eventArguments = { key, value: existing.value };\n                this.fireEvent(`expired`, eventArguments);\n                this.fireEvent(`removed`, eventArguments);\n            }\n        }\n        //this.keyCount++;\n        this.store.set(key, {\n            lastGet: 0,\n            lastSet: performance.now(),\n            value: value,\n        });\n        this.fireEvent(`newKey`, { key, value });\n    }\n}\n","/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = (map, data) => {\n    const x = new Map(map.entries());\n    for (const d of data) {\n        if (d[0] === undefined)\n            throw new Error(`key cannot be undefined`);\n        if (d[1] === undefined)\n            throw new Error(`value cannot be undefined`);\n        x.set(d[0], d[1]);\n    }\n    return x;\n};\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = (map, data) => {\n    const x = new Map(map.entries());\n    for (const d of data) {\n        if (d.key === undefined)\n            throw new Error(`key cannot be undefined`);\n        if (d.value === undefined)\n            throw new Error(`value cannot be undefined`);\n        x.set(d.key, d.value);\n    }\n    return x;\n};\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = (map, key) => map.has(key);\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = (map, ...data) => {\n    if (map === undefined)\n        throw new Error(`map parameter is undefined`);\n    if (data === undefined)\n        throw new Error(`data parameter i.s undefined`);\n    if (data.length === 0)\n        return map;\n    const firstRecord = data[0];\n    const isObject = typeof firstRecord.key !==\n        `undefined` &&\n        typeof firstRecord.value !==\n            `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n    return isObject\n        ? addObjects(map, data)\n        : addArray(map, data);\n};\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = (map, key, value) => {\n    const x = new Map(map.entries());\n    x.set(key, value);\n    return x;\n};\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = (map, key) => {\n    const x = new Map(map.entries());\n    x.delete(key);\n    return x;\n};\n","import {} from '../types.js';\nimport { add, del, set } from './map-immutable-fns.js';\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = (dataOrMap) => {\n    if (dataOrMap === undefined)\n        return immutable([]);\n    if (Array.isArray(dataOrMap))\n        return immutable(add(new Map(), ...dataOrMap));\n    const data = dataOrMap;\n    return {\n        add: (...itemsToAdd) => {\n            const s = add(data, ...itemsToAdd);\n            return immutable(s);\n        },\n        set: (key, value) => {\n            const s = set(data, key, value);\n            return immutable(s);\n        },\n        get: (key) => data.get(key),\n        delete: (key) => immutable(del(data, key)),\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        clear: () => immutable(),\n        has: (key) => data.has(key),\n        entries: () => data.entries(),\n        values: () => data.values(),\n        isEmpty: () => data.size === 0,\n    };\n};\n","import {} from '../types.js';\nimport { add, del, set, has } from './map-immutable-fns.js';\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = (...data) => {\n    // eslint-disable-next-line functional/no-let\n    let m = add(new Map(), ...data);\n    return {\n        add: (...data) => {\n            m = add(m, ...data);\n        },\n        delete: (key) => {\n            m = del(m, key);\n        },\n        clear: () => {\n            m = add(new Map());\n        },\n        set: (key, value) => {\n            m = set(m, key, value);\n        },\n        get: (key) => m.get(key),\n        entries: () => m.entries(),\n        values: () => m.values(),\n        isEmpty: () => m.size === 0,\n        has: (key) => has(m, key),\n    };\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { toStringDefault } from '@ixfx/core';\n/**\n * @internal\n */\nexport class MapOfMutableImpl extends SimpleEventEmitter {\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    #map = new Map();\n    groupBy;\n    type;\n    constructor(type, opts = {}) {\n        super();\n        this.type = type;\n        this.groupBy = opts.groupBy ?? toStringDefault;\n    }\n    /**\n     * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n     */\n    get typeName() {\n        return this.type.name;\n    }\n    /**\n     * Returns the number of keys\n     */\n    get lengthKeys() {\n        return this.#map.size;\n    }\n    /**\n     * Returns the length of the longest child list\n     */\n    get lengthMax() {\n        //eslint-disable-next-line functional/no-let\n        let m = 0;\n        for (const v of this.#map.values()) {\n            m = Math.max(m, this.type.count(v));\n        }\n        return m;\n    }\n    debugString() {\n        const keys = [...this.#map.keys()];\n        // eslint-disable-next-line functional/no-let\n        let r = `Keys: ${keys.join(`, `)}\\r\\n`;\n        for (const k of keys) {\n            const v = this.#map.get(k);\n            if (v === undefined) {\n                r += ` - ${k} (undefined)\\r\\n`;\n            }\n            else {\n                const asArray = this.type.toArray(v);\n                if (asArray !== undefined) {\n                    r += ` - ${k} (${this.type.count(v)}) = ${JSON.stringify(asArray)}\\r\\n`;\n                }\n            }\n        }\n        ;\n        return r;\n    }\n    get isEmpty() {\n        return this.#map.size === 0;\n    }\n    clear() {\n        this.#map.clear();\n        super.fireEvent(`clear`, true);\n    }\n    //eslint-disable-next-line functional/prefer-immutable-types\n    addKeyedValues(key, ...values) {\n        const set = this.#map.get(key);\n        if (set === undefined) {\n            this.#map.set(key, this.type.add(undefined, values));\n            super.fireEvent(`addedKey`, { key: key });\n            super.fireEvent(`addedValues`, { values: values });\n        }\n        else {\n            // eslint-disable-next-line functional/immutable-data\n            this.#map.set(key, this.type.add(set, values));\n            super.fireEvent(`addedValues`, { values: values });\n        }\n    }\n    //eslint-disable-next-line functional/prefer-immutable-types\n    set(key, values) {\n        this.addKeyedValues(key, ...values);\n        return this;\n    }\n    addValue(...values) {\n        for (const v of values)\n            this.addKeyedValues(this.groupBy(v), v);\n    }\n    hasKeyValue(key, value, eq) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return false;\n        return this.type.has(m, value, eq);\n    }\n    //eslint-disable-next-line functional/prefer-tacit\n    has(key) {\n        return this.#map.has(key);\n    }\n    deleteKeyValue(key, value) {\n        const a = this.#map.get(key);\n        if (a === undefined)\n            return false;\n        return this.deleteKeyValueFromMap(a, key, value);\n    }\n    deleteKeyValueFromMap(map, key, value) {\n        const preCount = this.type.count(map);\n        const filtered = this.type.without(map, value);\n        const postCount = filtered.length;\n        this.#map.set(key, this.type.add(undefined, filtered));\n        return preCount > postCount;\n    }\n    deleteByValue(value) {\n        //eslint-disable-next-line functional/no-let\n        let something = false;\n        [...this.#map.keys()].filter((key) => {\n            const a = this.#map.get(key);\n            if (!a)\n                throw new Error(`Bug: map could not be accessed`);\n            if (this.deleteKeyValueFromMap(a, key, value)) {\n                something = true; // note that something was deleted\n                // If key is empty, delete it\n                if (this.count(key) === 0)\n                    this.delete(key);\n            }\n        });\n        return something;\n    }\n    delete(key) {\n        const a = this.#map.get(key);\n        if (a === undefined)\n            return false;\n        this.#map.delete(key);\n        this.fireEvent(`deleteKey`, { key: key });\n        return true;\n    }\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const keys = [...this.#map.keys()];\n        const found = keys.find((key) => {\n            const a = this.#map.get(key);\n            if (a === undefined)\n                throw new Error(`Bug: map could not be accessed`);\n            const r = this.type.has(a, value, eq);\n            return r;\n        });\n        return found;\n    }\n    count(key) {\n        const entry = this.#map.get(key);\n        if (entry === undefined)\n            return 0;\n        return this.type.count(entry);\n    }\n    /**\n     * Iterates over values stored under `key`\n     * An empty array is returned if there are no values\n     */\n    *get(key) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return;\n        yield* this.type.iterable(m);\n    }\n    /**\n     * Iterate over the values stored under `key`.\n     * If key does not exist, iteration is essentially a no-op\n     * @param key\n     * @returns\n     */\n    *valuesFor(key) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return;\n        yield* this.type.iterable(m);\n    }\n    //eslint-disable-next-line functional/prefer-tacit\n    getSource(key) {\n        return this.#map.get(key);\n    }\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    *keys() {\n        yield* this.#map.keys();\n        //return Array.from(this.#map.keys());\n    }\n    *entriesFlat() {\n        for (const entry of this.#map.entries()) {\n            for (const v of this.type.iterable(entry[1])) {\n                yield [entry[0], v];\n            }\n        }\n    }\n    *valuesFlat() {\n        for (const entry of this.#map.entries()) {\n            yield* this.type.iterable(entry[1]);\n        }\n    }\n    *entries() {\n        for (const [k, v] of this.#map.entries()) {\n            const temporary = [...this.type.iterable(v)];\n            yield [k, temporary];\n        }\n    }\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    *keysAndCounts() {\n        for (const key of this.keys()) {\n            yield [key, this.count(key)];\n        }\n    }\n    merge(other) {\n        for (const key of other.keys()) {\n            const data = other.get(key);\n            this.addKeyedValues(key, ...data);\n        }\n    }\n    get size() {\n        return this.#map.size;\n    }\n    get [Symbol.toStringTag]() {\n        return this.#map[Symbol.toStringTag];\n    }\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { without } from '@ixfx/arrays';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\nimport { hasAnyValue as mapHasAnyValue, toArray as mapToArray, find as mapFind, filter as mapFilter, addKeepingExisting, } from '@ixfx/core/maps';\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is a {@link Util.ToString} function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = mapOfSetMutable();\n * map.add(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = mapOfSetMutable(hash);\n * map.add(`hello`, {age:40, name: `Mary`});\n * map.add(`hello`, {age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param options\n * @returns\n */\nexport const ofSetMutable = (options) => {\n    const hash = options?.hash ?? toStringDefault;\n    const comparer = (a, b) => hash(a) === hash(b);\n    const t = {\n        get name() {\n            return `set`;\n        },\n        iterable: (source) => source.values(),\n        add: (dest, values) => addKeepingExisting(dest, hash, ...values),\n        count: (source) => source.size,\n        find: (source, predicate) => mapFind(source, predicate),\n        filter: (source, predicate) => mapFilter(source, predicate),\n        toArray: (source) => mapToArray(source),\n        has: (source, value) => mapHasAnyValue(source, value, comparer),\n        without: (source, value) => without(mapToArray(source), value, comparer),\n    };\n    const m = new MapOfMutableImpl(t, options);\n    return m;\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { circularArray } from '../circular-array.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param options\n * @returns\n */\nexport const ofCircularMutable = (options) => {\n    const comparer = isEqualDefault;\n    const t = {\n        get name() {\n            return `circular`;\n        },\n        add: (destination, values) => {\n            if (destination === undefined)\n                destination = circularArray(options.capacity);\n            for (const v of values) {\n                //values.forEach(v => dest = dest?.add(v));\n                destination = destination.add(v);\n            }\n            return destination;\n        },\n        count: (source) => source.length,\n        find: (source, predicate) => source.find(predicate),\n        filter: (source, predicate) => source.filter(predicate),\n        toArray: (source) => source,\n        iterable: (source) => source.values(),\n        has: (source, value) => source.find((v) => comparer(v, value)) !== undefined,\n        without: (source, value) => source.filter((v) => !comparer(v, value)),\n    };\n    return new MapOfMutableImpl(t, options);\n};\n","/**\n * Simple map for numbers.\n *\n * Keys not present in map return the `defaultValue` given in the constructor\n * ```js\n * // All keys default to zero.\n * const map = new NumberMap();\n * map.get(`hello`); // 0\n * ```\n *\n * To check if a key is present, use `has`:\n * ```js\n * map.has(`hello`); // false\n * ```\n *\n * Math:\n * ```js\n * // Adds 1 by default to value of `hello`\n * map.add(`hello`);         // 1\n * map.multiply(`hello`, 2); // 2\n *\n * // Reset key to default value\n * map.reset(`hello`); // 0\n * ```\n *\n * Different default value:\n * ```js\n * const map = new NumberMap(10);\n * map.get(`hello`); // 10\n * ```\n *\n * Regular `set` works as well:\n * ```js\n * map.set(`hello`, 5);\n * map.add(`hello`, 2); // 7\n * ```\n */\nexport class NumberMap extends Map {\n    defaultValue;\n    constructor(defaultValue = 0) {\n        super();\n        this.defaultValue = defaultValue;\n    }\n    get(key) {\n        const v = super.get(key);\n        if (v === undefined)\n            return this.defaultValue;\n        return v;\n    }\n    reset(key) {\n        super.set(key, this.defaultValue);\n        return this.defaultValue;\n    }\n    multiply(key, amount) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value *= amount;\n        super.set(key, value);\n        return value;\n    }\n    add(key, amount = 1) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value += amount;\n        super.set(key, value);\n        return value;\n    }\n    subtract(key, amount = 1) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value -= amount;\n        super.set(key, value);\n        return value;\n    }\n}\n","import { isEqualDefault } from '@ixfx/core';\nimport {} from './imap-of-mutable-extended.js';\nimport {} from './map-multi.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: {@link Util.ToString}\n *\n * A custom {@link Util.ToString} function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param options Optiosn for mutable array\n * @typeParam V - Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = (options = {}) => {\n    // const toStringFunction = opts.toString === undefined ?  \n    // const comparer =\n    //   opts.comparer === undefined\n    //     ? (opts.toString === undefined\n    //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n    //       : isEqualDefault)\n    //     : opts.comparer;\n    // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n    //   const r = opts.convertToString(a) === opts.convertToString(b)\n    //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n    //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n    //   return r;\n    // };\n    const convertToString = options.convertToString;\n    const toStringFunction = typeof convertToString === `undefined` ? isEqualDefault : (a, b) => convertToString(a) === convertToString(b);\n    const comparer = options.comparer ?? toStringFunction;\n    const t = {\n        get name() {\n            return `array`;\n        },\n        add: (destination, values) => {\n            if (destination === undefined)\n                return [...values];\n            return [...destination, ...values];\n        },\n        iterable: (source) => source.values(),\n        count: (source) => source.length,\n        find: (source, predicate) => source.find(f => predicate(f)),\n        filter: (source, predicate) => source.filter(f => predicate(f)),\n        toArray: (source) => source,\n        has: (source, value) => source.some((v) => comparer(v, value)),\n        without: (source, value) => source.filter((v) => !comparer(v, value)),\n        //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n    };\n    const m = new MapOfMutableImpl(t, options);\n    return m;\n};\n","//  UNIT TESTED\nimport { isEqualDefault } from '@ixfx/core';\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = (map, predicate) => {\n    for (const e of map.entries()) {\n        const value = e[1];\n        for (const subValue of value) {\n            if (predicate(subValue, e[0]))\n                return e;\n        }\n    }\n};\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = (map) => {\n    //eslint-disable-next-line functional/no-let\n    let largest = ['', 0];\n    for (const e of map.keysAndCounts()) {\n        if (e[1] > largest[1]) {\n            largest = e;\n        }\n    }\n    return largest[1];\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const e of map.entries()) {\n        const value_ = e[1];\n        for (const subValue of value_) {\n            if (isEqual(subValue, value))\n                return e;\n        }\n    }\n};\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { firstEntryByValue } from './map-multi-fns.js';\nexport class MapOfSimpleBase {\n    map;\n    groupBy;\n    valueEq;\n    /**\n     * Constructor\n     * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n     * @param valueEq Compare values. By default uses JS logic for equality\n     */\n    constructor(groupBy = defaultKeyer, valueEq = (isEqualDefault), initial = []) {\n        this.groupBy = groupBy;\n        this.valueEq = valueEq;\n        this.map = new Map(initial);\n    }\n    /**\n     * Returns _true_ if `key` exists\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.map.has(key);\n    }\n    /**\n     * Returns _true_ if `value` exists under `key`.\n     * @param key Key\n     * @param value Value to seek under `key`\n     * @returns _True_ if `value` exists under `key`.\n     */\n    hasKeyValue(key, value) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        for (const v of values) {\n            if (this.valueEq(v, value))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Debug dump of contents\n     * @returns\n     */\n    debugString() {\n        let r = ``;\n        const keys = [...this.map.keys()];\n        keys.every((k) => {\n            const v = this.map.get(k);\n            if (v === undefined)\n                return;\n            r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\n        });\n        return r;\n    }\n    /**\n     * Return number of values stored under `key`.\n     * Returns 0 if `key` is not found.\n     * @param key\n     * @returns\n     */\n    count(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return 0;\n        return values.length;\n    }\n    /**\n   * Returns first key that contains `value`\n   * @param value\n   * @param eq\n   * @returns\n   */\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const entry = firstEntryByValue(this, value, eq);\n        if (entry)\n            return entry[0];\n    }\n    /**\n     * Iterate over all entries\n     */\n    *entriesFlat() {\n        for (const key of this.map.keys()) {\n            for (const value of this.map.get(key)) {\n                yield [key, value];\n            }\n        }\n    }\n    /**\n     * Iterate over keys and array of values for that key\n     */\n    *entries() {\n        for (const [k, v] of this.map.entries()) {\n            yield [k, [...v]];\n        }\n    }\n    /**\n     * Get all values under `key`\n     * @param key\n     * @returns\n     */\n    *get(key) {\n        const m = this.map.get(key);\n        if (!m)\n            return;\n        yield* m.values();\n    }\n    /**\n     * Iterate over all keys\n     */\n    *keys() {\n        yield* this.map.keys();\n    }\n    /**\n     * Iterate over all values (regardless of key).\n     * Use {@link values} to iterate over a set of values per key\n     */\n    *valuesFlat() {\n        for (const entries of this.map) {\n            yield* entries[1];\n        }\n    }\n    /**\n     * Yields the values for each key in sequence, returning an array.\n     * Use {@link valuesFlat} to iterate over all keys regardless of key.\n     */\n    *values() {\n        for (const entries of this.map) {\n            yield entries[1];\n        }\n    }\n    /**\n     * Iterate over keys and length of values stored under keys\n     */\n    *keysAndCounts() {\n        for (const entries of this.map) {\n            yield [entries[0], entries[1].length];\n        }\n    }\n    /**\n     * Returns the count of keys.\n     */\n    get lengthKeys() {\n        return this.map.size;\n    }\n    /**\n    * _True_ if empty\n    */\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        const existing = this.map.get(key);\n        if (existing === undefined) {\n            this.map.set(key, values);\n        }\n        else {\n            this.map.set(key, [...existing, ...values]);\n        }\n    }\n    /**\n     * Set `values` to `key`.\n     * Previous data stored under `key` is thrown away.\n     * @param key\n     * @param values\n     */\n    setValues(key, values) {\n        this.map.set(key, values);\n    }\n    /**\n     * Adds a value, automatically extracting a key via the\n     * `groupBy` function assigned in the constructor options.\n     * @param values Adds several values\n     */\n    addValue(...values) {\n        for (const v of values) {\n            const key = this.groupBy(v);\n            this.addKeyedValues(key, v);\n        }\n    }\n    /**\n     * Delete `value` under a particular `key`\n     * @param key\n     * @param value\n     * @returns _True_ if `value` was found under `key`\n     */\n    deleteKeyValue(key, value) {\n        const existing = this.map.get(key);\n        if (existing === undefined)\n            return false;\n        const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n        this.map.set(key, without);\n        return without.length < existing.length;\n    }\n    /**\n     * Deletes `value` regardless of key.\n     *\n     * Uses the constructor-defined equality function.\n     * @param value Value to delete\n     * @returns\n     */\n    deleteByValue(value) {\n        let del = false;\n        const entries = [...this.map.entries()];\n        for (const keyEntries of entries) {\n            for (const values of keyEntries[1]) {\n                if (this.valueEq(values, value)) {\n                    del = true;\n                    this.deleteKeyValue(keyEntries[0], value);\n                }\n            }\n        }\n        return del;\n    }\n    /**\n     * Deletes all values under `key`,\n     * @param key\n     * @returns _True_ if `key` was found and values stored\n     */\n    delete(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        if (values.length === 0)\n            return false;\n        this.map.delete(key);\n        return true;\n    }\n    /**\n     * Clear contents\n     */\n    clear() {\n        this.map.clear();\n    }\n}\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimpleMutable(groupBy, valueEq);\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * Simple immutable MapOf\n */\nexport class MapOfSimple extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        //const asEntries = values.map(v => [key, v]) as [string, V[]][];\n        //return this.addBatch(asEntries);\n        return this.addBatch([[key, values]]);\n    }\n    addValue(...values) {\n        const asEntries = values.map((v) => [this.groupBy(v), v]);\n        return this.addBatch(asEntries);\n    }\n    //eslint-disable-next-line functional/prefer-immutable-types\n    addBatch(entries) {\n        // Deep copy Map\n        const temporary = new Map([...this.map.entries()].map((e) => [e[0], [...e[1]]]));\n        for (const [key, list] of entries) {\n            // Does key exist already\n            const existingList = temporary.get(key);\n            if (typeof existingList === `undefined`) {\n                // No, use the batch input as the data for this key\n                // @ts-expect-error\n                temporary.set(key, list);\n            }\n            else {\n                // Yes\n                existingList.push(...list);\n            }\n        }\n        return new MapOfSimple(this.groupBy, this.valueEq, [...temporary.entries()]);\n    }\n    clear() {\n        return new MapOfSimple(this.groupBy, this.valueEq);\n    }\n    deleteKeyValue(_key, _value) {\n        throw new Error(`Method not implemented.`);\n    }\n    deleteByValue(value, eq) {\n        const entries = [...this.map.entries()];\n        const eqFunction = eq ?? this.valueEq;\n        const x = entries.map((entry) => {\n            const key = entry[0];\n            const values = entry[1].filter((vv) => !eqFunction(vv, value));\n            return [key, values];\n        });\n        return new MapOfSimple(this.groupBy, this.valueEq, x);\n    }\n    delete(key) {\n        const entries = [...this.map.entries()].filter((e) => e[0] !== key);\n        return new MapOfSimple(this.groupBy, this.valueEq, entries);\n    }\n}\n/**\n * A simple immutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * let m = mapSimple();\n * m = m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m = m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimple = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimple(groupBy, valueEq);\n","export { create as expiringMap } from './expiring-map.js';\nexport { immutable } from './map.js';\nexport { mutable } from './map-mutable.js';\nexport { ofSetMutable } from './map-of-set-mutable.js';\nexport { ofCircularMutable } from './map-of-circular-mutable.js';\nexport { NumberMap } from './number-map.js';\nexport * from './map-multi.js';\n//export type { IDictionary as IMappish, IWithEntries } from '../../data/maps/IMappish.js';\n","export class Table {\n    rows = [];\n    rowLabels = [];\n    colLabels = [];\n    labelColumns(...labels) {\n        this.colLabels = labels;\n    }\n    labelColumn(columnNumber, label) {\n        this.colLabels[columnNumber] = label;\n    }\n    getColumnLabelIndex(label) {\n        for (const [index, l] of this.colLabels.entries()) {\n            if (l === label)\n                return index;\n        }\n    }\n    print() {\n        console.table([...this.rowsWithLabelsObject()]);\n    }\n    *rowsWithLabelsArray() {\n        for (let index = 0; index < this.rows.length; index++) {\n            const labelledRow = this.getRowWithLabelsArray(index);\n            yield labelledRow;\n        }\n    }\n    /**\n     * Return a copy of table as nested array\n     * ```js\n     * const t = new Table();\n     * // add stuff\n     * // ...\n     * const m = t.asArray();\n     * for (const row of m) {\n     *  for (const colValue of row) {\n     *    // iterate over all column values for this row\n     *  }\n     * }\n     * ```\n     *\n     * Alternative: get value at row Y and column X\n     * ```js\n     * const value = m[y][x];\n     * ```\n     * @returns\n     */\n    asArray() {\n        const r = [];\n        for (const row of this.rows) {\n            if (row === undefined)\n                r.push([]);\n            else\n                r.push([...row]);\n        }\n        return r;\n    }\n    /**\n     * Return the number of rows\n     */\n    get rowCount() {\n        return this.rows.length;\n    }\n    /**\n     * Return the maximum number of columns in any row\n     */\n    get columnCount() {\n        const lengths = this.rows.map(row => row.length);\n        return Math.max(...lengths);\n    }\n    *rowsWithLabelsObject() {\n        for (let index = 0; index < this.rows.length; index++) {\n            const labelledRow = this.getRowWithLabelsObject(index);\n            yield labelledRow;\n        }\n    }\n    labelRows(...labels) {\n        this.rowLabels = labels;\n    }\n    appendRow(...data) {\n        this.rows.push(data);\n    }\n    getRowWithLabelsArray(rowNumber) {\n        const row = this.rows.at(rowNumber);\n        if (row === undefined)\n            return undefined;\n        return row.map((value, index) => [this.colLabels.at(index), value]);\n    }\n    /**\n     * Return a row of objects. Keys use the column labels.\n     *\n     * ```js\n     * const row = table.getRowWithLabelsObject(10);\n     * // eg:\n     * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n     * ```\n     * @param rowNumber\n     * @returns\n     */\n    getRowWithLabelsObject(rowNumber) {\n        const row = this.rows.at(rowNumber);\n        if (row === undefined)\n            return undefined;\n        const object = {};\n        for (let index = 0; index < this.colLabels.length; index++) {\n            const label = this.colLabels.at(index) ?? index.toString();\n            object[label] = row[index];\n        }\n        return object;\n    }\n    /**\n     * Gets or creates a row at `rowNumber`.\n     * @param rowNumber\n     * @returns\n     */\n    getOrCreateRow(rowNumber) {\n        let row = this.rows.at(rowNumber);\n        if (row === undefined) {\n            row = [];\n            this.rows[rowNumber] = row;\n        }\n        return row;\n    }\n    /**\n     * Gets the values at `rowNumber`\n     * @param rowNumber\n     * @returns\n     */\n    row(rowNumber) {\n        return this.rows.at(rowNumber);\n    }\n    /**\n     * Set the value of row,column to `value`\n     * @param rowNumber\n     * @param columnNumber\n     * @param value\n     */\n    set(rowNumber, columnNumber, value) {\n        const row = this.getOrCreateRow(rowNumber);\n        row[columnNumber] = value;\n    }\n    get(rowNumber, column) {\n        const row = this.getOrCreateRow(rowNumber);\n        const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n        if (index === undefined)\n            throw new Error(`Column not found: ${column}`);\n        return row[index];\n    }\n    /**\n     * For a given row number, set all the columns to `value`.\n     * `cols` gives the number of columns to set\n     * @param rowNumber\n     * @param cols\n     * @param value\n     */\n    setRow(rowNumber, cols, value) {\n        const row = this.getOrCreateRow(rowNumber);\n        for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n            row[columnNumber] = value;\n        }\n    }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { PriorityMutable } from \"../queue/priority-mutable.js\";\nimport { immutable as immutableMap } from \"../map/map.js\";\nimport { NumberMap } from \"../map/number-map.js\";\nimport * as Sync from \"@ixfx/iterables/sync\";\nimport { Table } from \"../table.js\";\nimport { resultThrow, stringTest } from \"@ixfx/guards\";\n/**\n * Create a vertex with given id\n * @param id\n * @returns\n */\nexport const createVertex = (id) => {\n    return {\n        id,\n        out: []\n    };\n};\n/**\n * Returns _true_ if graph contains `key`.\n *\n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key\n * @returns\n */\nexport function hasKey(graph, key) {\n    resultThrow(graphTest(graph));\n    return graph.vertices.has(key);\n}\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n *\n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph\n * @param key\n * @returns\n */\nexport function get(graph, key) {\n    resultThrow(graphTest(graph));\n    resultThrow(stringTest(key, `non-empty`, `key`));\n    return graph.vertices.get(key);\n}\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph\n * @returns\n */\nexport function toAdjacencyMatrix(graph) {\n    resultThrow(graphTest(graph));\n    const v = [...graph.vertices.values()];\n    //const m: Array<Array<boolean>> = [];\n    const table = new Table();\n    table.labelColumns(...v.map(vv => vv.id));\n    table.labelRows(...v.map(vv => vv.id));\n    // const row: Array<boolean> = [];\n    // for (let index = 0; index < v.length; index++) {\n    //   row[ index ] = false;\n    // }\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (let i = 0; i < v.length; i++) {\n        //m[ i ] = [ ...row ];\n        table.setRow(i, v.length, false);\n        const ii = v[i];\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        for (const [j, jj] of v.entries()) {\n            if (ii.out.some(o => o.id === jj.id)) {\n                //m[ i ][ j ] = true;\n                table.set(i, j, true);\n            }\n        }\n    }\n    return table;\n}\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph\n * @returns\n */\nexport const dumpGraph = (graph) => {\n    const lines = debugGraphToArray(graph);\n    return lines.join(`\\n`);\n};\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph\n * @returns\n */\nconst debugGraphToArray = (graph) => {\n    const r = [];\n    const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n    for (const v of vertices) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const str = debugDumpVertex(v);\n        r.push(...str.map(line => ` ${line}`));\n    }\n    return r;\n};\nexport const distance = (graph, edge) => {\n    if (edge.weight !== undefined)\n        return edge.weight;\n    return 1;\n};\n/**\n * Iterate over all the edges in the graph\n * @param graph\n */\nexport function* edges(graph) {\n    resultThrow(graphTest(graph));\n    const vertices = [...graph.vertices.values()];\n    for (const vertex of vertices) {\n        for (const edge of vertex.out) {\n            yield edge;\n        }\n    }\n}\n/**\n * Iterate over all the vertices of the graph\n * @param graph\n */\nexport function* vertices(graph) {\n    resultThrow(graphTest(graph));\n    const vertices = [...graph.vertices.values()];\n    for (const vertex of vertices) {\n        yield vertex;\n    }\n}\nfunction graphTest(g, parameterName = `graph`) {\n    if (g === undefined)\n        return { success: false, error: `Param '${parameterName}' is undefined. Expected Graph` };\n    if (g === null)\n        return { success: false, error: `Param '${parameterName}' is null. Expected Graph` };\n    if (typeof g === `object`) {\n        if (!(`vertices` in g))\n            return {\n                success: false, error: `Param '${parameterName}.vertices' does not exist. Is it a Graph type?`\n            };\n    }\n    else {\n        return { success: false, error: `Param '${parameterName} is type '${typeof g}'. Expected an object Graph` };\n    }\n    return { success: true, value: g };\n}\n// function throwGraphTest(g: DirectedGraph, parameterName = `graph`) {\n//   const r = testGraph(g, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ] as string)\n// }\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns\n */\nexport function* adjacentVertices(graph, context) {\n    resultThrow(graphTest(graph));\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of vertex.out) {\n        const edgeV = graph.vertices.get(edge.id);\n        if (edgeV === undefined)\n            throw new Error(`Could not find vertex: ${edge.id}`);\n        yield edgeV;\n    }\n}\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n *\n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns\n */\nexport const vertexHasOut = (vertex, outIdOrVertex) => {\n    if (vertex === undefined)\n        return false;\n    const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n    return vertex.out.some(edge => edge.id === outId);\n};\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph\n * @param vertex\n * @returns\n */\nexport const hasNoOuts = (graph, vertex) => {\n    resultThrow(graphTest(graph));\n    const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n    if (context === undefined)\n        return false;\n    return context.out.length === 0;\n};\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph\n * @param vertex\n * @param outIdOrVertex\n * @returns\n */\nexport const hasOnlyOuts = (graph, vertex, ...outIdOrVertex) => {\n    resultThrow(graphTest(graph));\n    const context = resolveVertex(graph, vertex);\n    const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n    if (outs.length !== context.out.length) {\n        //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n        return false;\n    }\n    for (const out of outs) {\n        //console.log(`Testing ${ context.id } -> ${ out.id }`);\n        if (!hasOut(graph, context, out)) {\n            //console.log(`  no`);\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph\n * @param vertex\n * @param outIdOrVertex\n * @returns\n */\nexport const hasOut = (graph, vertex, outIdOrVertex) => {\n    resultThrow(graphTest(graph));\n    const context = resolveVertex(graph, vertex);\n    const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n    return context.out.some(edge => edge.id === outId);\n};\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph\n * @param id\n * @returns\n */\nexport const getOrCreate = (graph, id) => {\n    resultThrow(graphTest(graph));\n    const v = graph.vertices.get(id);\n    if (v !== undefined)\n        return { graph, vertex: v };\n    const vv = createVertex(id);\n    const gg = updateGraphVertex(graph, vv);\n    return { graph: gg, vertex: vv };\n};\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph\n * @param id\n * @returns\n */\nexport const getOrFail = (graph, id) => {\n    resultThrow(graphTest(graph));\n    const v = graph.vertices.get(id);\n    if (v === undefined)\n        throw new Error(`Vertex '${id}' not found in graph`);\n    return v;\n};\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns\n */\nexport const updateGraphVertex = (graph, vertex) => {\n    resultThrow(graphTest(graph));\n    const gr = {\n        ...graph,\n        vertices: graph.vertices.set(vertex.id, vertex)\n    };\n    return gr;\n};\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph\n * @param edge\n * @returns\n */\nexport const distanceDefault = (graph, edge) => {\n    if (edge.weight !== undefined)\n        return edge.weight;\n    return 1;\n};\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n *\n * If edge was not there, original graph is returned.\n * @param graph\n * @param from\n * @param to\n * @returns\n */\nexport function disconnect(graph, from, to) {\n    resultThrow(graphTest(graph));\n    const fromV = resolveVertex(graph, from);\n    const toV = resolveVertex(graph, to);\n    return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n        ...fromV,\n        out: fromV.out.filter(t => t.id !== toV.id)\n    }) : graph;\n}\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph\n * @param from\n * @param to\n * @param weight\n * @returns\n */\nexport function connectTo(graph, from, to, weight) {\n    resultThrow(graphTest(graph));\n    const fromResult = getOrCreate(graph, from);\n    graph = fromResult.graph;\n    const toResult = getOrCreate(graph, to);\n    graph = toResult.graph;\n    const edge = {\n        id: to,\n        weight\n    };\n    if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n        graph = updateGraphVertex(graph, {\n            ...fromResult.vertex,\n            // Add new edge to list of edges for this node\n            out: [...fromResult.vertex.out, edge]\n        });\n    }\n    return { graph, edge };\n}\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n *\n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n *\n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph\n * @param options\n * @returns\n */\nexport function connect(graph, options) {\n    if (typeof graph !== `object`)\n        throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof graph}`);\n    if (typeof options !== `object`)\n        throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof options}`);\n    const result = connectWithEdges(graph, options);\n    return result.graph;\n}\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well.\n *\n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n *\n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph\n * @param options\n * @returns\n */\nexport function connectWithEdges(graph, options) {\n    resultThrow(graphTest(graph));\n    const { to, weight, from } = options;\n    const bidi = options.bidi ?? false;\n    const toList = Array.isArray(to) ? to : [to];\n    const edges = [];\n    // Connect from -> to\n    for (const toSingle of toList) {\n        const result = connectTo(graph, from, toSingle, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    if (!bidi)\n        return { graph, edges };\n    // Bidirectional connection\n    // Connect to -> from\n    for (const toSingle of toList) {\n        const result = connectTo(graph, toSingle, from, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    return { graph, edges };\n}\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v\n * @returns\n */\nconst debugDumpVertex = (v) => {\n    const r = [\n        v.id\n    ];\n    const stringForEdge = (edge) => edge.weight === undefined ? edge.id : `${edge.id} (${edge.weight})`;\n    // for (const edge of v.in) {\n    //   r.push(` <- ${ stringForEdge(edge) }`);\n    // }\n    for (const edge of v.out) {\n        r.push(` -> ${stringForEdge(edge)}`);\n    }\n    if (v.out.length === 0)\n        r[0] += ` (terminal)`;\n    return r;\n};\n/**\n * Returns _true_ if a->b or b->a\n * @param graph\n * @param a\n * @param b\n * @returns\n */\nexport function areAdjacent(graph, a, b) {\n    resultThrow(graphTest(graph));\n    if (hasOut(graph, a, b.id))\n        return true;\n    if (hasOut(graph, b, a.id))\n        return true;\n}\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph\n * @param idOrVertex\n * @returns\n */\nfunction resolveVertex(graph, idOrVertex) {\n    resultThrow(graphTest(graph));\n    if (idOrVertex === undefined)\n        throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n    const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n    if (v === undefined)\n        throw new Error(`Id not found ${idOrVertex}`);\n    return v;\n}\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph\n * @param startIdOrVertex\n * @param targetIdOrVertex\n * @returns\n */\nexport function* bfs(graph, startIdOrVertex, targetIdOrVertex) {\n    resultThrow(graphTest(graph));\n    const start = resolveVertex(graph, startIdOrVertex);\n    const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n    const queue = new QueueMutable();\n    const seen = new Set();\n    queue.enqueue(start);\n    while (!queue.isEmpty) {\n        const v = queue.dequeue();\n        yield v;\n        if (target !== undefined && target === v)\n            return;\n        for (const edge of adjacentVertices(graph, v)) {\n            if (!seen.has(edge.id)) {\n                seen.add(edge.id);\n                queue.enqueue(resolveVertex(graph, edge.id));\n            }\n        }\n    }\n}\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph\n * @param startIdOrVertex\n */\nexport function* dfs(graph, startIdOrVertex) {\n    resultThrow(graphTest(graph));\n    const source = resolveVertex(graph, startIdOrVertex);\n    const s = new StackMutable();\n    const seen = new Set();\n    s.push(source);\n    while (!s.isEmpty) {\n        const v = s.pop();\n        if (v === undefined)\n            continue;\n        if (!seen.has(v.id)) {\n            seen.add(v.id);\n            yield v;\n            for (const edge of v.out) {\n                const destination = graph.vertices.get(edge.id);\n                if (destination) {\n                    s.push(destination);\n                }\n            }\n        }\n    }\n}\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph\n * @param sourceOrId\n * @returns\n */\nexport const pathDijkstra = (graph, sourceOrId) => {\n    resultThrow(graphTest(graph));\n    const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n    if (source === undefined)\n        throw new Error(`source vertex not found`);\n    const distances = new Map();\n    const previous = new Map();\n    distances.set(source.id, 0);\n    const pq = new PriorityMutable();\n    const vertices = [...graph.vertices.values()];\n    for (const v of vertices) {\n        if (v.id !== source.id) {\n            distances.set(v.id, Number.MAX_SAFE_INTEGER);\n            previous.set(v.id, null);\n        }\n        pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n    }\n    while (!pq.isEmpty) {\n        const u = pq.dequeueMin();\n        if (u === undefined)\n            throw new Error(`Bug. Queue unexpectedly empty`);\n        const vertexU = graph.vertices.get(u);\n        for (const neighbour of vertexU.out) {\n            //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n            const alt = distances.get(u) + distance(graph, neighbour);\n            if (alt < distances.get(neighbour.id)) {\n                distances.set(neighbour.id, alt);\n                previous.set(neighbour.id, vertexU);\n                pq.changePriority(neighbour.id, alt, true);\n            }\n        }\n    }\n    const pathTo = (id) => {\n        const path = [];\n        while (true) {\n            if (id === source.id)\n                break;\n            const v = previous.get(id);\n            if (v === undefined || v === null)\n                throw new Error(`Id not present: ${id}`);\n            path.push({ id, weight: distances.get(id) });\n            id = v.id;\n        }\n        return path;\n    };\n    return {\n        distances, previous, pathTo\n    };\n};\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph\n * @returns\n */\nexport const clone = (graph) => {\n    resultThrow(graphTest(graph));\n    const g = {\n        vertices: immutableMap([...graph.vertices.entries()])\n    };\n    return g;\n};\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n *\n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections\n * @returns\n */\nexport const graph = (...initialConnections) => {\n    let g = {\n        vertices: immutableMap()\n    };\n    for (const ic of initialConnections) {\n        g = connect(g, ic);\n    }\n    return g;\n};\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph\n */\nexport function isAcyclic(graph) {\n    resultThrow(graphTest(graph));\n    const cycles = getCycles(graph);\n    return cycles.length === 0;\n}\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph\n */\nexport function topologicalSort(graph) {\n    resultThrow(graphTest(graph));\n    const indegrees = new NumberMap(0);\n    // Increment indegrees for each edge leading to a vertex\n    for (const edge of edges(graph)) {\n        indegrees.add(edge.id, 1);\n    }\n    // Enqueue all vertices with an indegree of 0\n    const queue = new QueueMutable();\n    let vertexCount = 0;\n    for (const vertex of vertices(graph)) {\n        if (indegrees.get(vertex.id) === 0) {\n            queue.enqueue(vertex);\n        }\n        vertexCount++;\n    }\n    const topOrder = [];\n    while (!queue.isEmpty) {\n        // Add to topological order\n        const u = queue.dequeue();\n        topOrder.push(u);\n        // Iterate through neighbours\n        for (const neighbour of u.out) {\n            const result = indegrees.subtract(neighbour.id, 1);\n            if (result === 0) {\n                queue.enqueue(graph.vertices.get(neighbour.id));\n            }\n        }\n    }\n    if (topOrder.length !== vertexCount) {\n        throw new Error(`Graph contains cycles`);\n    }\n    return graphFromVertices(topOrder);\n}\n/**\n * Create a graph from an iterable of vertices\n * @param vertices\n * @returns\n */\nexport function graphFromVertices(vertices) {\n    const keyValues = Sync.map(vertices, f => {\n        return [f.id, f];\n    });\n    const m = immutableMap([...keyValues]);\n    return {\n        vertices: m\n    };\n}\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph\n * @returns\n */\nexport function getCycles(graph) {\n    resultThrow(graphTest(graph));\n    let index = 0;\n    const stack = new StackMutable();\n    const vertices = new Map();\n    const scc = [];\n    for (const v of graph.vertices.values()) {\n        vertices.set(v.id, {\n            ...v,\n            lowlink: Number.NaN,\n            index: Number.NaN,\n            onStack: false\n        });\n    }\n    const strongConnect = (vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index++;\n        stack.push(vertex);\n        vertex.onStack = true;\n        for (const edge of vertex.out) {\n            const edgeV = vertices.get(edge.id);\n            if (Number.isNaN(edgeV.index)) {\n                strongConnect(edgeV);\n                vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n            }\n            else if (edgeV.onStack) {\n                vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n            }\n        }\n        if (vertex.lowlink === vertex.index) {\n            const stronglyConnected = [];\n            let w;\n            while (vertex !== w) {\n                w = stack.pop();\n                w.onStack = false;\n                stronglyConnected.push({ id: w.id, out: w.out });\n            }\n            if (stronglyConnected.length > 1)\n                scc.push(stronglyConnected);\n        }\n    };\n    for (const v of vertices.values()) {\n        if (Number.isNaN(v.index)) {\n            strongConnect(v);\n        }\n    }\n    return scc;\n}\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph\n * @returns\n */\nexport function transitiveReduction(graph) {\n    resultThrow(graphTest(graph));\n    for (const u of vertices(graph)) {\n        for (const v of adjacentVertices(graph, u)) {\n            for (const v1 of dfs(graph, v)) {\n                if (v.id === v1.id)\n                    continue;\n                if (hasOut(graph, u, v1)) {\n                    const g = disconnect(graph, u, v1);\n                    return transitiveReduction(g);\n                }\n            }\n        }\n    }\n    return graph;\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { immutable as immutableMap } from \"../map/map.js\";\nimport { Table } from \"../table.js\";\nexport const createVertex = (id) => {\n    return {\n        id\n    };\n};\nexport const updateGraphVertex = (graph, vertex) => {\n    const gr = {\n        ...graph,\n        vertices: graph.vertices.set(vertex.id, vertex)\n    };\n    return gr;\n};\nexport const getOrCreate = (graph, id) => {\n    const v = graph.vertices.get(id);\n    if (v !== undefined)\n        return { graph, vertex: v };\n    const vv = createVertex(id);\n    const gg = updateGraphVertex(graph, vv);\n    return { graph: gg, vertex: vv };\n};\nfunction resolveVertex(graph, idOrVertex) {\n    if (idOrVertex === undefined)\n        throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n    if (graph === undefined)\n        throw new Error(`Param 'graph' is undefined. Expected Graph`);\n    const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n    if (v === undefined)\n        throw new Error(`Id not found ${idOrVertex}`);\n    return v;\n}\n/**\n * Returns _true/false_ if there is a connection between `a` and `b` in `graph`.\n * Use {@link getConnection} if you want to the edge.\n * @param graph Graph to search\n * @param a\n * @param b\n * @returns _true_ if edge exists\n */\nexport const hasConnection = (graph, a, b) => {\n    const edge = getConnection(graph, a, b);\n    return edge !== undefined;\n};\n/**\n * Gets the connection, if it exists between `a` and `b` in `graph`.\n * If it doesn't exist, _undefined_ is returned.\n * Use {@link hasConnection} for a simple true/false if edge exists.\n * @param graph Graph\n * @param a\n * @param b\n * @returns\n */\nexport const getConnection = (graph, a, b) => {\n    if (a === undefined)\n        throw new Error(`Param 'a' is undefined. Expected string or Vertex`);\n    if (b === undefined)\n        throw new Error(`Param 'b' is undefined. Expected string or Vertex`);\n    if (graph === undefined)\n        throw new Error(`Param 'graph' is undefined. Expected Graph`);\n    const aa = resolveVertex(graph, a);\n    const bb = resolveVertex(graph, b);\n    for (const edge of graph.edges) {\n        if (edge.a == aa.id && edge.b === bb.id)\n            return edge;\n        if (edge.a == bb.id && edge.b === aa.id)\n            return edge;\n    }\n    return;\n};\n/**\n * Connects A with B, returning the changed graph and created edge.\n * If the connection already exists, the original graph & edge is returned.\n * @param graph\n * @param a\n * @param b\n * @param weight\n * @returns\n */\nexport function connectTo(graph, a, b, weight) {\n    const aResult = getOrCreate(graph, a);\n    graph = aResult.graph;\n    const bResult = getOrCreate(graph, b);\n    graph = bResult.graph;\n    let edge = getConnection(graph, a, b);\n    if (edge !== undefined)\n        return { graph, edge };\n    edge = {\n        a,\n        b,\n        weight\n    };\n    const graphChanged = {\n        ...graph,\n        edges: [...graph.edges, edge]\n    };\n    return { graph: graphChanged, edge };\n}\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connectWithEdges} but only the {@link Graph} is returned.\n *\n * ```js\n * let g = graph(); // Create an empty graph\n * // Make a connection between `red` and `orange`\n * g = connect(g, { a: `red`, b: `orange` });\n *\n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * g = connect(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connect(graph, options) {\n    const result = connectWithEdges(graph, options);\n    return result.graph;\n}\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connect} but graph and edges are returned.\n *\n * ```js\n * let g = graph(); // Create an empty graph\n *\n * // Make a connection between `red` and `orange`\n * result = connectWithEdges(g, { a: `red`, b: `orange` });\n *\n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * result = connectWithEdges(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connectWithEdges(graph, options) {\n    const { a, weight, b } = options;\n    const destinations = Array.isArray(b) ? b : [b];\n    let edges = [];\n    for (const destination of destinations) {\n        const result = connectTo(graph, a, destination, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    return { graph, edges };\n}\nexport const graph = (...initialConnections) => {\n    let g = {\n        vertices: immutableMap(),\n        edges: []\n    };\n    for (const ic of initialConnections) {\n        g = connect(g, ic);\n    }\n    return g;\n};\nexport function toAdjacencyMatrix(graph) {\n    const v = [...graph.vertices.values()];\n    const table = new Table();\n    table.labelColumns(...v.map(vv => vv.id));\n    table.labelRows(...v.map(vv => vv.id));\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n    for (let i = 0; i < v.length; i++) {\n        table.setRow(i, v.length, false);\n        const ii = v[i];\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        for (const [j, jj] of v.entries()) {\n            const connected = hasConnection(graph, ii, jj);\n            if (connected) {\n                table.set(i, j, true);\n            }\n        }\n    }\n    return table;\n}\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph\n * @returns\n */\nexport const dumpGraph = (graph) => {\n    const lines = debugGraphToArray(graph);\n    return lines.join(`\\n`);\n};\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph\n * @returns\n */\nconst debugGraphToArray = (graph) => {\n    const r = [];\n    r.push(`Vertices: ${[...graph.vertices.values()].map(v => v.id).join(`, `)}`);\n    // eslint-disable-next-line unicorn/no-array-push-push\n    r.push(`Edges:`);\n    for (const edge of graph.edges) {\n        r.push(stringForEdge(edge));\n    }\n    return r;\n};\nconst stringForEdge = (edge) => {\n    const weight = edge.weight ? ` (${edge.weight})` : ``;\n    return `${edge.a} <-> ${edge.b}${weight}`;\n};\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns\n */\nexport function* adjacentVertices(graph, context) {\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of graph.edges) {\n        if (edge.a === context)\n            yield resolveVertex(graph, edge.b);\n        else if (edge.b === context)\n            yield resolveVertex(graph, edge.a);\n    }\n}\nexport function* edgesForVertex(graph, context) {\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of graph.edges) {\n        if (edge.a === context)\n            yield edge;\n        else if (edge.b === context)\n            yield edge;\n    }\n}\n","export * as Directed from './directed-graph.js';\nexport * as Undirected from './undirected-graph.js';\n","export * from '@ixfx/collections';"],"mappings":"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"}