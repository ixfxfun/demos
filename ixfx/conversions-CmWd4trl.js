import{d as e,u as t,y as n}from"./numbers-BlBexQl9.js";import{A as r,I as i,L as a,g as o,h as s,j as c,k as l,x as u}from"./angles-DwQpnVfp.js";const d=(e,t=`Dimension`)=>{if(e===void 0)throw Error(`${t} is undefined`);if(Number.isNaN(e))throw Error(`${t} is NaN`);if(e<0)throw Error(`${t} cannot be negative`)},f=(e,t=`rect`)=>{if(e===void 0)throw Error(`{$name} undefined`);g(e)&&r(e,t),d(e.width,t+`.width`),d(e.height,t+`.height`)},p=(e,t)=>{if(f(e),g(e)&&t===void 0)return e;if(t===void 0)throw Error(`Unpositioned rect needs origin parameter`);return Object.freeze({...e,...t})},m=(e,t=`rect`)=>{if(!g(e))throw Error(`Expected ${t} to have x,y`);f(e,t)},ee=e=>e.width===0&&e.height===0,h=e=>Number.isNaN(e.width)&&Number.isNaN(e.height),g=e=>e.x!==void 0&&e.y!==void 0,_=e=>!(e===void 0||e.width===void 0||e.height===void 0),te=e=>_(e)&&g(e),v=(e,t)=>{let n=p(e,t);return[{x:n.x,y:n.y},{x:n.x+n.width,y:n.y},{x:n.x+n.width,y:n.y+n.height},{x:n.x,y:n.y+n.height}]};function y(e,t,n,r,o,s){if(a(e)&&a(t)||i(e)&&i(t))return[e,t];if(a(e)){let i={x:t,y:n,z:r};if(!a(i))throw Error(`Expected x, y & z parameters`);return[e,i]}if(i(e)){let r={x:t,y:n};if(!i(r))throw Error(`Expected x & y parameters`);return[e,r]}if(o!==void 0&&r!==void 0){let i={x:e,y:t,z:n},c={x:r,y:o,z:s};if(!a(i))throw Error(`Expected x,y,z for first point`);if(!a(c))throw Error(`Expected x,y,z for second point`);return[i,c]}let c={x:e,y:t},l={x:n,y:r};if(!i(c))throw Error(`Expected x,y for first point`);if(!i(l))throw Error(`Expected x,y for second point`);return[c,l]}function b(e,t,n){if(e===void 0)return{x:0,y:0};if(Array.isArray(e)){if(e.length===0)return Object.freeze({x:0,y:0});if(e.length===1)return Object.freeze({x:e[0],y:0});if(e.length===2)return Object.freeze({x:e[0],y:e[1]});if(e.length===3)return Object.freeze({x:e[0],y:e[1],z:e[2]});throw Error(`Expected array to be 1-3 elements in length. Got ${e.length}.`)}if(i(e))return e;if(typeof e!=`number`||typeof t!=`number`)throw TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(e)} b: ${JSON.stringify(t)}`);return typeof n==`number`?Object.freeze({x:e,y:t,z:n}):Object.freeze({x:e,y:t})}function ne(e,t,n,i,o,s){let[c,l]=y(e,t,n,i,o,s);r(c,`a`),r(l,`b`);let u={x:c.x+l.x,y:c.y+l.y};return(a(c)||a(l))&&(u.z=(c.z??0)+(l.z??0)),Object.freeze(u)}function x(e,t,n,i,o,s){let[c,l]=y(e,t,n,i,o,s);r(c,`a`),r(l,`b`);let u={x:c.x-l.x,y:c.y-l.y};return(a(c)||a(l))&&(u.z=(c.z??0)-(l.z??0)),Object.freeze(u)}function S(e,t,n,i){let o=b(t,n,i);return r(o,`b`),r(e,`a`),a(o)&&a(e)?Math.hypot(o.x-e.x,o.y-e.y,o.z-e.z):Math.hypot(o.x-e.x,o.y-e.y)}function C(e,t,n){let i=b(t,n);return r(i,`b`),r(e,`a`),Math.hypot(i.x-e.x,i.y-e.y)}const re=(e,t=Math.round)=>(r(e,`pt`),Object.freeze({x:t(e.x),y:t(e.y)})),ie=e=>{r(e,`pt`);let t={...e};return delete t.z,Object.freeze(t)},ae=(e,t=0)=>(r(e,`pt`),Object.freeze({...e,z:t}));function w(e,t){if(e===void 0)return`(undefined)`;if(e===null)return`(null)`;r(e,`pt`);let n=t?e.x.toFixed(t):e.x,i=t?e.y.toFixed(t):e.y;return e.z===void 0?`(${n},${i})`:`(${n},${i},${t?e.z.toFixed(t):e.z})`}const T=(e,t)=>(r(e,`a`),r(t,`b`),e=Object.freeze({...e}),t=Object.freeze({...t}),Object.freeze({a:e,b:t})),E=(...e)=>{let t=[],n=e[0];for(let r=1;r<e.length;r++)t.push(T(n,e[r])),n=e[r];return t},oe=(e,t=!1)=>{if(t){let t=[],n=new Set;for(let r of e){let e=w(r.a),i=w(r.b);n.has(e)||(n.add(e),t.push(r.a)),n.has(i)&&(n.add(i),t.push(r.b))}return t}else{let t=[];for(let n of e)t.push(n.a,n.b);return t}},D=e=>!(e===void 0||e.a===void 0||e.b===void 0||!i(e.a)||!i(e.b)),O=e=>Array.isArray(e)?!e.some(e=>!D(e)):!1,k=(e,t=`line`)=>{if(e===void 0)throw Error(`${t} undefined`);if(e.a===void 0)throw Error(`${t}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(e)}`);if(e.b===void 0)throw Error(`${t}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(e)}`)},A=(e,t)=>{let n;if(D(e))t=e.b,n=e.a;else if(n=e,t===void 0)throw Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(n)} b: ${JSON.stringify(t)}`);return r(n,`a`),r(n,`b`),[n,t]};function j(e,t,n){if(O(e)){let n=typeof t==`boolean`?t:!1;return e.reduce((e,t)=>j(t,n)+e,0)}if(e===void 0)throw TypeError(`Parameter 'aOrLine' is undefined`);let[r,i]=typeof t==`object`?A(e,t):A(e),a=i.x-r.x,o=i.y-r.y;if(!(typeof t==`boolean`?t:typeof n==`boolean`&&n)&&r.z!==void 0&&i.z!==void 0){let e=i.z-r.z;return Math.hypot(a,o,e)}else return Math.hypot(a,o)}function se(e){if(a(e))return Object.freeze({...e,x:Math.abs(e.x),y:Math.abs(e.y),z:Math.abs(e.z)});if(i(e))return Object.freeze({...e,x:Math.abs(e.x),y:Math.abs(e.y)});throw TypeError(`Param 'pt' is not a point`)}const M=(e,t,n)=>(r(e,`a`),t===void 0?Math.atan2(e.y,e.x):(r(t,`b`),n===void 0?Math.atan2(t.y-e.y,t.x-e.x):(r(n,`c`),Math.atan2(t.y-e.y,t.x-e.x)-Math.atan2(n.y-e.y,n.x-e.x)))),N=(e,t,n)=>{let r=M(e,t,n);return r<0?r+l:r},P=(e,t,n)=>{let r=Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2),i=Math.sqrt((t.x-n.x)**2+(t.y-n.y)**2),a=Math.sqrt((n.x-e.x)**2+(n.y-e.y)**2);return Math.acos((i*i+r*r-a*a)/(2*i*r))},F=(e,t)=>e.x<t.x&&e.y<t.y?-2:e.x>t.x&&e.y>t.y?2:e.x<t.x||e.y<t.y?-1:e.x>t.x||e.y>t.y?1:e.x===t.x&&e.x===t.y?0:NaN,I=(e,t)=>e.x===t.x?0:e.x<t.x?-1:1,L=(e,t)=>e.y===t.y?0:e.y<t.y?-1:1,R=(e,t)=>e.z===t.z?0:e.z<t.z?-1:1;function z(e,t,n,i,o,s){let[c,l]=y(e,t,n,i,o,s);if(r(c,`a`),r(l,`b`),l.x===0)throw TypeError(`Cannot divide by zero (b.x is 0)`);if(l.y===0)throw TypeError(`Cannot divide by zero (b.y is 0)`);let u={x:c.x/l.x,y:c.y/l.y};if(a(c)||a(l)){if(l.z===0)throw TypeError(`Cannot divide by zero (b.z is 0)`);u.z=(c.z??0)/(l.z??0)}return Object.freeze(u)}function B(e,t,n){let r=b(e,t,n);return c(r,`divisor`),(e,t,n)=>{let i=b(e,t,n);return i.z===void 0?Object.freeze({x:i.x/r.x,y:i.y/r.y}):Object.freeze({x:i.x/r.x,y:i.y/r.y,z:i.z/(r.z??1)})}}const V={x:0,y:0},H={x:1,y:1},U={x:0,y:0,z:0},W={x:1,y:1,z:1};function G(e){return k(e,`line`),{a:e.b,b:e.a}}function K(r,i,a,o){typeof a==`boolean`&&(o=a,a=void 0),n(o?t(r,``,`amount`):e(r,`amount`));let[s,c]=A(i,a),l=j(s,c),u=l*(1-r);if(l===0&&u===0)return Object.freeze({...c});let d=c.x-u*(c.x-s.x)/l,f=c.y-u*(c.y-s.y)/l;return Object.freeze({...c,x:d,y:f})}function ce(e,t,n=!0){n||(e=G(e));let r=e.b.x-e.a.x,i=e.b.y-e.a.y,a=Math.atan2(i,r),o=t*Math.cos(a),s=t*Math.sin(a);return{x:o+e.a.x,y:s+e.a.y}}const le=(e,t,n,r=!1)=>K(e,t,n,r),ue=(e,t=`both`)=>{switch(t){case`both`:return a(e)?Object.freeze({...e,x:e.x*-1,y:e.y*-1,z:e.z*-1}):Object.freeze({...e,x:e.x*-1,y:e.y*-1});case`x`:return Object.freeze({...e,x:e.x*-1});case`y`:return Object.freeze({...e,y:e.y*-1});case`z`:if(a(e))return Object.freeze({...e,z:e.z*-1});throw Error(`pt parameter is missing z`);default:throw Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`)}};function q(e,t,n,i,o,s){let[c,l]=y(e,t,n,i,o,s);r(c,`a`),r(l,`b`);let u={x:c.x*l.x,y:c.y*l.y};return(a(c)||a(l))&&(u.z=(c.z??0)*(l.z??0)),Object.freeze(u)}const de=(e,t)=>a(e)?Object.freeze({...e,x:e.x*t,y:e.y*t,z:e.z*t}):Object.freeze({...e,x:e.x*t,y:e.y*t}),fe=(e,t=1,n=0)=>{let r=S(e),i=1;return r>t?i=t/r:r<n&&(i=n/r),i===1?e:q(e,i,i)},pe=(e,t)=>{if(i(e)&&(t=e.y,e=e.x),t===void 0)throw Error(`Expected y`);return Math.hypot(e,t)},me=(e,t)=>{let n=b(e,t),r=pe(n);return r===0?V:Object.freeze({...n,x:n.x/r,y:n.y/r})},he=(e,...t)=>J(...t)(e),J=(...e)=>t=>e.reduce((e,t)=>t(e),t),Y=e=>!(e.distance===void 0||e.angleRadian===void 0),X=(e,t=`Point`)=>{if(e===void 0)throw Error(`'${t}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e===null)throw Error(`'${t}' is null. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e.angleRadian===void 0)throw Error(`'${t}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(e.distance===void 0)throw Error(`'${t}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(e)}`);if(typeof e.angleRadian!=`number`)throw TypeError(`'${t}.angleRadian' must be a number. Got ${e.angleRadian}`);if(typeof e.distance!=`number`)throw TypeError(`'${t}.distance' must be a number. Got ${e.distance}`);if(e.angleRadian===null)throw Error(`'${t}.angleRadian' is null`);if(e.distance===null)throw Error(`'${t}.distance' is null`);if(Number.isNaN(e.angleRadian))throw TypeError(`'${t}.angleRadian' is NaN`);if(Number.isNaN(e.distance))throw Error(`'${t}.distance' is NaN`)},ge=(e,t)=>({a:t,b:Z(e,t)}),Z=(e,t,n)=>{if(Y(e)){if(t===void 0&&(t=V),i(t))return $(e.distance,e.angleRadian,t);throw Error(`Expecting (Coord, Point). Second parameter is not a point`)}else if(typeof e==`object`)throw TypeError(`First param is an object, but not a Coord: ${JSON.stringify(e)}`);else if(typeof e==`number`&&typeof t==`number`){if(n===void 0&&(n=V),!i(n))throw Error(`Expecting (number, number, Point). Point param wrong type`);return $(e,t,n)}else throw TypeError(`Expecting parameters of (number, number). Got: (${typeof e}, ${typeof t}, ${typeof n}). a: ${JSON.stringify(e)}`)},Q=(e,t,n={})=>{if(typeof e!=`object`)throw TypeError(`Param 'point' wrong. Expecting a Point, got: ${typeof e}`);let r=n.fullCircle??!0;typeof t==`object`&&(e=x(e,t));let i=Math.atan2(e.y,e.x);r&&(i=u(i));let a=Math.hypot(e.x,e.y);typeof n.digits==`number`&&(i=parseFloat(i.toFixed(n.digits)),a=parseFloat(a.toFixed(n.digits)));let o={...e,angleRadian:i,distance:a};return delete o.x,delete o.y,Object.freeze(o)},$=(e,t,n=V)=>(r(n),Object.freeze({x:n.x+e*Math.cos(t),y:n.y+e*Math.sin(t)})),_e=(e,t)=>{if(e===void 0)return`(undefined)`;if(e===null)return`(null)`;let n=o(e.angleRadian);return`(${t?e.distance.toFixed(t):e.distance},${t?n.toFixed(t):n})`},ve=(e,t=V)=>(X(e,`v`),Object.freeze({x:t.x+e.distance*Math.cos(e.angleRadian),y:t.y+e.distance*Math.sin(e.angleRadian)}));function ye(e,t,n={}){let r=Array.isArray(e)?e:[e];if(r.length===0)return[];let i=n.orderBy??`none`,a=r.map(e=>{let r=Q(e.a,t,n),a=Q(e.b,t,n),o=s(r.angleRadian,a.angleRadian);return(i===`angle-min`&&o.min.start!==r.angleRadian||i===`angle-max`&&o.max.start<r.angleRadian||i===`distance`&&a.distance<r.distance)&&([r,a]=[a,r]),Object.freeze({a:r,b:a,origin:t})});return Array.isArray(e)?a:a[0]}function be(e,t=2){return`angle: ${e.a.angleRadian.toFixed(t)}-${e.b.angleRadian.toFixed(t)} dist: ${e.a.distance.toFixed(t)}-${e.b.distance.toFixed(t)}`}function xe(e,t){let n=Array.isArray(e)?e:[e];if(n.length===0)return[];let r=n.map(e=>Object.freeze({a:Z(e.a,t),b:Z(e.b,t)}));return Array.isArray(e)?r:r[0]}export{y as $,L as A,O as B,U as C,B as D,z as E,se as F,ae as G,oe as H,j as I,S as J,re as K,A as L,M,N,F as O,P,b as Q,k as R,V as S,W as T,T as U,E as V,ie as W,x as X,C as Y,ne as Z,ue as _,ge as a,ee as at,ce as b,_e as c,_ as ct,J as d,v as et,he as f,de as g,q as h,Z as i,m as it,R as j,I as k,X as l,te as lt,fe as m,xe as n,f as nt,ve as o,h as ot,me as p,w as q,be as r,d as rt,ye as s,g as st,Q as t,p as tt,Y as u,le as v,H as w,G as x,K as y,D as z};