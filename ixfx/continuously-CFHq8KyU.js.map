{"version":3,"file":"continuously-CFHq8KyU.js","names":["interval"],"sources":["../../core/dist/src/continuously.js"],"sourcesContent":["import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport const continuously = (callback, interval = 0, options = {}) => {\n    let intervalMs = intervalToMs(interval, 0);\n    resultThrow(integerTest(intervalMs, `positive`, `interval`));\n    const fireBeforeWait = options.fireBeforeWait ?? false;\n    const onStartCalled = options.onStartCalled;\n    const signal = options.signal;\n    let disposed = false;\n    let runState = `idle`;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let startedAt = performance.now();\n    let intervalUsed = interval ?? 0;\n    let cancelled = false;\n    let currentTimer;\n    const deschedule = () => {\n        if (currentTimer === undefined)\n            return;\n        globalThis.clearTimeout(currentTimer);\n        currentTimer = undefined;\n        startCount = 0;\n        startedAt = Number.NaN;\n    };\n    const schedule = (scheduledCallback) => {\n        if (intervalMs === 0) {\n            if (typeof requestAnimationFrame === `undefined`) {\n                currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n            }\n            else {\n                currentTimer = undefined;\n                requestAnimationFrame(scheduledCallback);\n            }\n        }\n        else {\n            currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n        }\n    };\n    const cancel = () => {\n        if (cancelled)\n            return;\n        cancelled = true;\n        if (runState === `idle`)\n            return; // No need to cancel\n        runState = `idle`;\n        deschedule();\n    };\n    const loop = async () => {\n        if (signal?.aborted) {\n            runState = `idle`;\n        }\n        if (runState === `idle`)\n            return;\n        runState = `running`;\n        startCount++;\n        startCountTotal++;\n        const valueOrPromise = callback(startCount, performance.now() - startedAt);\n        const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n        if (cancelled) {\n            return;\n        }\n        runState = `scheduled`;\n        // Didn't get a value, exit out\n        if (value !== undefined && !value) {\n            cancel();\n            return;\n        }\n        if (cancelled)\n            return; // has been cancelled\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop);\n    };\n    const start = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        if (onStartCalled !== undefined) {\n            // A function governs whether to allow .start() to go ahead\n            const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n            switch (doWhat) {\n                case `cancel`: {\n                    cancel();\n                    return;\n                }\n                case `reset`: {\n                    reset();\n                    return;\n                }\n                case `dispose`: {\n                    disposed = true;\n                    cancel();\n                    return;\n                }\n                // No default\n            }\n        }\n        if (runState === `idle`) {\n            // Start running\n            startCount = 0;\n            startedAt = performance.now();\n            runState = `scheduled`;\n            if (fireBeforeWait) {\n                void loop(); // Exec first, then wait\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                schedule(loop); // Wait first, then exec\n            }\n        } // else: already running, ignore\n    };\n    const reset = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        startCount = 0;\n        startedAt = Number.NaN;\n        // Cancel scheduled iteration\n        if (runState !== `idle`) {\n            cancel();\n        }\n        start();\n    };\n    return {\n        start,\n        reset,\n        cancel,\n        get interval() {\n            return intervalUsed;\n        },\n        get runState() {\n            return runState;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        },\n        get startCount() {\n            return startCount;\n        },\n        set interval(interval) {\n            const ms = intervalToMs(interval, 0);\n            resultThrow(integerTest(ms, `positive`, `interval`));\n            intervalMs = ms;\n            intervalUsed = interval;\n        },\n        get isDisposed() {\n            return disposed;\n        },\n        get elapsedMs() {\n            return performance.now() - startedAt;\n        },\n    };\n};\n"],"mappings":"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"}