{"version":3,"file":"tracker-base-lIhvOloS.js","names":["creator: (key: string, start: V | undefined) => T","id: string","opts: TrackedValueOpts"],"sources":["../../packages/core/src/trackers/tracked-value.ts","../../packages/core/src/trackers/tracker-base.ts"],"sourcesContent":["import { type GetOrGenerate, getOrGenerate } from '../maps.js';\nimport { TrackerBase } from './tracker-base.js';\n\nexport type Timestamped = {\n  readonly at: number\n}\nexport type TimestampedObject<V> = V & Timestamped;\n\n/**\n * Options\n */\nexport type TrackedValueOpts = {\n  readonly id?: string;\n\n  /**\n   * If true, intermediate points are stored. False by default\n   */\n  readonly storeIntermediate?: boolean;\n  /**\n   * If above zero, tracker will reset after this many samples\n   */\n  readonly resetAfterSamples?: number;\n\n  /**\n   * If above zero, there will be a limit to intermediate values kept.\n   *\n   * When the seen values is twice `sampleLimit`, the stored values will be trimmed down\n   * to `sampleLimit`. We only do this when the values are double the size so that\n   * the collections do not need to be trimmed repeatedly whilst we are at the limit.\n   *\n   * Automatically implies storeIntermediate\n   */\n  readonly sampleLimit?: number;\n\n  /**\n   * If _true_, prints debug info\n   */\n  readonly debug?: boolean\n};\n\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class PointsTracker extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap<V, T extends TrackerBase<V, TResult>, TResult> {\n  store: Map<string, T>;\n  gog: GetOrGenerate<string, T, V>;\n\n  constructor(creator: (key: string, start: V | undefined) => T) {\n    this.store = new Map();\n    this.gog = getOrGenerate<string, T, V>(this.store, creator);\n  }\n\n  /**\n   * Number of named values being tracked\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Returns _true_ if `id` is stored\n   * @param id\n   * @returns\n   */\n  has(id: string) {\n    return this.store.has(id);\n  }\n\n  /**\n   * For a given id, note that we have seen one or more values.\n   * @param id Id\n   * @param values Values(s)\n   * @returns Information about start to last value\n   */\n\n  //eslint-disable-next-line functional/prefer-immutable-types\n  public async seen(id: string, ...values: V[]): Promise<TResult> {\n    const trackedValue = await this.getTrackedValue(id, ...values);\n\n    // Pass it over to the TrackedValue\n    const result = trackedValue.seen(...values);\n\n    return result;\n  }\n\n  /**\n   * Creates or returns a TrackedValue instance for `id`.\n   * @param id\n   * @param values\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  protected async getTrackedValue(id: string, ...values: V[]) {\n    if (id === null) throw new Error(`id parameter cannot be null`);\n    if (id === undefined) throw new Error(`id parameter cannot be undefined`);\n\n    // Create or recall TrackedValue by id\n    const trackedValue = await this.gog(id, values[ 0 ]);\n    return trackedValue;\n  }\n\n  /**\n   * Remove a tracked value by id.\n   * Use {@link reset} to clear them all.\n   * @param id\n   */\n  delete(id: string) {\n    this.store.delete(id);\n  }\n\n  /**\n   * Remove all tracked values.\n   * Use {@link delete} to remove a single value by id.\n   */\n  reset() {\n    this.store = new Map();\n  }\n\n  /**\n   * Enumerate ids\n   */\n  *ids() {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Enumerate tracked values\n   */\n  *tracked() {\n    yield* this.store.values();\n  }\n\n  /**\n   * Iterates TrackedValues ordered with oldest first\n   * @returns\n   */\n  *trackedByAge() {\n    const tp = [ ...this.store.values() ];\n    tp.sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa > bb) return -1;\n      return 1;\n    });\n\n    for (const t of tp) {\n      yield t;\n    }\n  }\n\n  /**\n   * Iterates underlying values, ordered by age (oldest first)\n   * First the named values are sorted by their `elapsed` value, and then\n   * we return the last value for that group.\n   */\n  *valuesByAge() {\n    for (const tb of this.trackedByAge()) {\n      yield tb.last;\n    }\n  }\n\n  /**\n   * Enumerate last received values\n   *\n   * @example Calculate centroid of latest-received values\n   * ```js\n   * const pointers = pointTracker();\n   * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n   * ```\n   */\n  *last() {\n    for (const p of this.store.values()) {\n      yield p.last;\n    }\n  }\n\n  /**\n   * Enumerate starting values\n   */\n  *initialValues() {\n    for (const p of this.store.values()) {\n      yield p.initial;\n    }\n  }\n\n  /**\n   * Returns a tracked value by id, or undefined if not found\n   * @param id\n   * @returns\n   */\n  get(id: string): TrackerBase<V, TResult> | undefined {\n    return this.store.get(id);\n  }\n}\n","import { type Timestamped, type TrackedValueOpts } from './tracked-value.js';\n\n/**\n * Base tracker class\n */\nexport abstract class TrackerBase<V, SeenResultType> {\n  /**\n   * @ignore\n   */\n  seenCount: number;\n\n  /**\n   * @ignore\n   */\n  protected storeIntermediate: boolean;\n\n  /**\n   * @ignore\n   */\n  protected resetAfterSamples: number;\n\n  /**\n   * @ignore\n   */\n  protected sampleLimit: number;\n\n  public readonly id: string;\n\n  protected debug: boolean;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    this.id = opts.id ?? `tracker`;\n    this.debug = opts.debug ?? false;\n    this.sampleLimit = opts.sampleLimit ?? -1;\n    this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n\n    this.storeIntermediate =\n      opts.storeIntermediate ??\n      (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n    this.seenCount = 0;\n\n    if (this.debug) {\n      console.log(`TrackerBase: sampleLimit: ${ this.sampleLimit } resetAfter: ${ this.resetAfterSamples } store: ${ this.storeIntermediate }`);\n    }\n  }\n\n  /**\n   * Reset tracker\n   */\n  reset() {\n    this.seenCount = 0;\n    this.onReset();\n  }\n\n  /**\n   * Adds a value, returning computed result.\n   *  \n   * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.\n   * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is\n   * called to take it down to sample limit, and `onTrimmed()` is called.\n   * @param p \n   * @returns \n   */\n  seen(...p: Array<V>): SeenResultType {\n    if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n      this.reset();\n    } else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n      this.seenCount = this.trimStore(this.sampleLimit);\n      this.onTrimmed(`resize`);\n    }\n\n    this.seenCount += p.length;\n    const t = this.filterData(p);\n    return this.computeResults(t);\n  }\n\n  /**\n   * @ignore\n   * @param p\n   */\n  abstract filterData(p: Array<V>): Array<Timestamped>;\n\n  abstract get last(): V | undefined;\n\n  /**\n   * Returns the initial value, or undefined\n   */\n  abstract get initial(): V | undefined;\n\n  /**\n   * Returns the elapsed milliseconds since the initial value\n   */\n  abstract get elapsed(): number;\n\n  /**\n   * @ignore\n   */\n  //eslint-disable-next-line @typescript-eslint/no-empty-function\n  abstract computeResults(_p: Array<Timestamped>): SeenResultType;\n\n  /**\n   * @ignore\n   */\n  abstract onReset(): void;\n\n\n  /**\n   * Notification that buffer has been trimmed\n   */\n  abstract onTrimmed(reason: TrimReason): void;\n  abstract trimStore(limit: number): number;\n}\n\nexport type TrimReason = `reset` | `resize`\n"],"mappings":"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"}