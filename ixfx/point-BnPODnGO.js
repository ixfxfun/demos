import{n as e}from"./chunk-CVLEGGlw.js";import{u as t,y as n}from"./numbers-BlBexQl9.js";import{c as r,n as i,s as a}from"./numeric-arrays-CRg0aU_z.js";import{t as o}from"./clamp-dSm2UU4N.js";import{t as s}from"./wrap-BvLZW4rK.js";import{n as c,t as l}from"./quantise-BF6gOUEX.js";import{A as u,D as d,F as f,I as p,L as m,M as h,N as ee,O as te,P as ne,R as re,j as ie,m as ae,o as oe,x as se,y as ce}from"./angles-DwQpnVfp.js";import{$ as le,A as ue,B as de,C as fe,D as pe,E as g,F as me,G as he,H as ge,I as _,J as v,K as _e,L as ve,M as y,N as ye,O as be,P as xe,Q as b,R as x,S as Se,T as Ce,U as we,V as Te,W as Ee,X as S,Y as De,Z as C,_ as Oe,a as ke,b as Ae,c as je,ct as Me,d as Ne,f as Pe,g as Fe,h as w,i as T,it as Ie,j as Le,k as Re,l as E,lt as D,m as ze,n as Be,nt as Ve,o as He,p as Ue,q as O,r as We,s as Ge,st as k,t as A,tt as Ke,u as qe,v as Je,w as Ye,x as Xe,y as j,z as M}from"./conversions-CmWd4trl.js";import{n as Ze,t as Qe}from"./tracked-value-BJVpL2jS.js";function $e(e,t,n){let r=typeof t==`number`?t:t.width,i=typeof t==`number`?n:t.height;if(r===void 0)throw Error(`Param 'width' undefined`);if(i===void 0)throw Error(`Param 'height' undefined`);if(r=e(r,`width`),i=e(i,`height`),typeof t==`object`)if(k(t)){let n=e(t.x,`x`),a=e(t.y,`y`);return{...t,width:r,height:i,x:n,y:a}}else return{...t,width:r,height:i};return{width:r,height:i}}function N(e,t,n,r){if(Ve(t,`a`),Me(n))return D(t)?Object.freeze({...t,x:e(t.x,n.width),y:e(t.y,n.height),width:e(t.width,n.width),height:e(t.height,n.height)}):Object.freeze({...t,width:e(t.width,n.width),height:e(t.height,n.height)});if(typeof n!=`number`)throw TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(n)}`);if(typeof r!=`number`)throw Error(`Expected third param as height. Got ${JSON.stringify(r)}`);return D(t)?Object.freeze({...t,x:e(t.x,n),y:e(t.y,r),width:e(t.width,n),height:e(t.height,r)}):Object.freeze({...t,width:e(t.width,n),height:e(t.height,r)})}function et(e,t,n){return k(t)?Object.freeze({...t,x:e(t.x,n),y:e(t.y,n),width:e(t.width,n),height:e(t.height,n)}):Object.freeze({...t,width:e(t.width,n),height:e(t.height,n)})}function tt(e,t,n){return Object.freeze({...t,width:e(t.width,n),height:e(t.height,n)})}const nt=(e,t)=>(Ve(e),t===void 0&&p(e)?t=e:t===void 0&&(t={x:0,y:0}),Ke(e,t),Object.freeze({x:t.x+e.width/2,y:t.y+e.height/2})),rt=(e,t=`circle`)=>{if(F(e)&&u(e,`circle`),Number.isNaN(e.radius))throw Error(`${t}.radius is NaN`);if(e.radius<=0)throw Error(`${t}.radius must be greater than zero`)},P=(e,t=`circle`)=>{if(!F(e))throw Error(`Expected a positioned circle with x,y`);rt(e,t)},it=e=>!!(Number.isNaN(e.radius)||F(e)&&(Number.isNaN(e.x)||Number.isNaN(e.y))),at=e=>e.x!==void 0&&e.y!==void 0,ot=e=>e.radius!==void 0,F=e=>ot(e)&&at(e),st=(e,t)=>e.radius===t.radius?F(e)&&F(t)?!(e.x!==t.x||e.y!==t.y||e.z!==t.z):(!F(e)&&F(t),!1):!1,ct=(e,t)=>{let n={x:t.b.x-t.a.x,y:t.b.y-t.a.y},r={x:t.a.x-e.x,y:t.a.y-e.y},i=(n.x*r.x+n.y*r.y)*-2,a=2*(n.x*n.x+n.y*n.y),o=Math.sqrt(i*i-2*a*(r.x*r.x+r.y*r.y-e.radius*e.radius));if(Number.isNaN(o))return[];let s=(i-o)/a,c=(i+o)/a,l=[];return s<=1&&s>=0&&l.push({x:t.a.x+n.x*s,y:t.a.y+n.y*s}),c<=1&&c>=0&&l.push({x:t.a.x+n.x*c,y:t.a.y+n.y*c}),l},lt=(e,t)=>{let n=S(t,e),r=Math.hypot(n.y,n.x);if(r>e.radius+t.radius||r<Math.abs(e.radius-t.radius)||st(e,t))return[];let i=(e.radius*e.radius-t.radius*t.radius+r*r)/(2*r),a={x:e.x+n.x*i/r,y:e.y+n.y*i/r},o=Math.sqrt(e.radius*e.radius-i*i),s={x:-n.y*(o/r),y:n.x*(o/r)};return[C(a,s),S(a,s)]},ut=(e,t)=>{let n=e.x-Math.max(t.x,Math.min(e.x,t.x+t.width)),r=e.y-Math.max(t.y,Math.min(e.y,t.y+t.height));return n*n+r*r<e.radius*e.radius},dt=(e,t)=>lt(e,t).length===2;function I(e,t,n){Ve(e,`rect`);let r=0,i=0;if(typeof t==`number`){if(n===void 0)throw Error(`x and y coordinate needed`);r=t,i=n}else r=t.x,i=t.y;if(k(e)){if(r-e.x>e.width||r<e.x||i-e.y>e.height||i<e.y)return!1}else if(r>e.width||r<0||i>e.height||i<0)return!1;return!0}const ft=(e,t)=>{if(!D(e))throw Error(`a parameter should be RectPositioned`);if(F(t))return ut(t,e);if(p(t))return I(e,t);throw Error(`Unknown shape for b: ${JSON.stringify(t)}`)},L=(e,t)=>{if(Ie(e,`rect`),u(t,`pt`),I(e,t))return 0;let n=Math.max(e.x-t.x,0,t.x-e.x+e.width),r=Math.max(e.y-t.y,0,t.y-e.y+e.height);return Math.hypot(n,r)},pt=(e,t)=>v(nt(e),t),mt=Object.freeze({width:0,height:0}),ht=Object.freeze({x:0,y:0,width:0,height:0}),gt=Object.freeze({width:NaN,height:NaN}),_t=Object.freeze({x:NaN,y:NaN,width:NaN,height:NaN}),R=(...e)=>{if(e===void 0)throw Error(`parameter 'p' is undefined`);if(e.length<2)return!0;for(let t=1;t<e.length;t++)if(e[t].x!==e[0].x||e[t].y!==e[0].y)return!1;return!0},vt=(e,t)=>{if(e===void 0)throw Error(`a undefined`);if(t===void 0)throw Error(`b undefined`);return e.width===t.width&&e.height===t.height},yt=(e,t)=>k(e)&&k(t)?R(e,t)?e.width===t.width&&e.height===t.height:!1:!k(e)&&!k(t)?e.width===t.width&&e.height===t.height:!1,bt=(e,t,n,r)=>{if(e.y>n.y)throw Error(`topLeft.y greater than bottomRight.y`);if(e.y>r.y)throw Error(`topLeft.y greater than bottomLeft.y`);let i=t.x-e.x,a=n.x-r.x,o=Math.abs(r.y-e.y),s=Math.abs(n.y-t.y);return{x:Math.min(e.x,r.x),y:Math.min(t.y,e.y),width:Math.max(i,a),height:Math.max(o,s)}},z=(e,t)=>e*t;function xt(e,t,n){return N(z,e,t,n)}function St(e,t){return et(z,e,t)}function Ct(e,t){return tt(z,e,t)}const wt=(e,t)=>e-t;function Tt(e,t,n){return N(wt,e,t,n)}function Et(e,t,n){let r=typeof t==`number`?t:t.width,i=typeof t==`number`?n:t.height;if(i===void 0)throw Error(`Expected height as third parameter`);return{...e,width:e.width-r,height:e.height-i}}function Dt(e,t){let n=0,r=0;k(e)&&(n=e.x,r=e.y);let i=0,a=0;return k(t)&&(i=t.x,a=t.y),Object.freeze({...e,x:n-i,y:r-a,width:e.width-t.width,height:e.height-t.height})}function Ot(e,t){return u(e,`pt`),m(e)?Object.freeze({...e,x:t(e.x,`x`),y:t(e.y,`y`),z:t(e.z,`z`)}):Object.freeze({...e,x:t(e.x,`x`),y:t(e.y,`y`)})}function B(e,...t){if(t.length===0)throw Error(`No points provided`);let n=t[0];for(let r of t)n=(m(n)&&m(r),e(n,r));return n}const V=(...e)=>{let t=B((e,t)=>e.x<t.x?e:t,...e),n=B((e,t)=>e.x>t.x?e:t,...e),r=B((e,t)=>e.y<t.y?e:t,...e),i=B((e,t)=>e.y>t.y?e:t,...e);return bt({x:t.x,y:r.y},{x:n.x,y:r.y},{x:n.x,y:i.y},{x:t.x,y:i.y})},kt=(...e)=>{let t=V(...e),n=B((e,t)=>e.z<t.z?e:t,...e),r=B((e,t)=>e.z>t.z?e:t,...e);return{...t,z:n.z,depth:r.z-n.z}},At=(...e)=>{if(!Array.isArray(e))throw Error(`Expected list of points`);let t=e.reduce((e,t)=>{if(t===void 0)return e;if(Array.isArray(t))throw TypeError(`'points' list contains an array. Did you mean: centroid(...myPoints)?`);if(!p(t))throw Error(`'points' contains something which is not a point: ${JSON.stringify(t)}`);return{x:e.x+t.x,y:e.y+t.y}},{x:0,y:0});return Object.freeze({x:t.x/e.length,y:t.y/e.length})};function jt(e,t=0,n=1){return m(e)?Object.freeze({x:o(e.x,t,n),y:o(e.y,t,n),z:o(e.z,t,n)}):Object.freeze({x:o(e.x,t,n),y:o(e.y,t,n)})}const Mt=(...e)=>{let t=[...e].sort(Re);if(t.length===1)return t;let n=e=>{let t=[];for(let n of e){for(;t.length>=2;){let e=t.at(-1),r=t.at(-2);if((e.x-r.x)*(n.y-r.y)>=(e.y-r.y)*(n.x-r.x))t.pop();else break}t.push(n)}return t.pop(),t},r=n(t),i=n(t.reverse());return r.length===1&&i.length===1&&R(i[0],r[0])?r:[...r,...i]},Nt=(e,t)=>(P(e,`a`),F(t)&&P(t,`b`),v(e,t)),H=(e,t)=>{if(P(e,`a`),F(t))return Math.max(0,Nt(e,t)-e.radius-t.radius);if(p(t)){let n=v(e,t);return n<e.radius?0:n}else throw Error(`Second parameter invalid type`)},Pt=(e,t)=>{if(D(t))return L(t,e);if(F(t))return H(t,e);if(p(t))return v(e,t);throw Error(`Unknown shape`)},Ft=(e,t)=>{if(D(t))return L(t,e);if(F(t))return H(t,e);if(p(t))return v(e,t);throw Error(`Unknown shape`)},It=e=>[e.x,e.y],Lt=(...e)=>i(e.map(e=>It(e)));function Rt(e,t){return e.x*t.y-e.y*t.x}function zt(e,t,n,r){return e*r-t*n}function Bt(e,t,n){if(Array.isArray(e)){if(e.length===3)return Object.freeze({x:e[0],y:e[1],z:e[2]});if(e.length===2)return Object.freeze({x:e[0],y:e[1]});throw Error(`Expected array of length two or three, got ${e.length}`)}else{if(e===void 0)throw Error(`Requires an array of [x,y] or x,y parameters at least`);if(Number.isNaN(e))throw Error(`x is NaN`);if(t===void 0)throw Error(`Param 'y' is missing`);if(Number.isNaN(t))throw Error(`y is NaN`);return n===void 0?Object.freeze({x:e,y:t}):Object.freeze({x:e,y:t,z:n})}}const Vt=e=>{if(typeof e!=`string`)throw TypeError(`Param 'str' ought to be a string. Got: ${typeof e}`);let t=e.indexOf(`,`),n=Number.parseFloat(e.substring(0,t)),r=e.indexOf(`,`,t+1);return r>0?{x:n,y:Number.parseFloat(e.substring(t+1,r-t+2)),z:Number.parseFloat(e.substring(r+1))}:{x:n,y:Number.parseFloat(e.substring(t+1))}},Ht=(...e)=>{let t=[];if(Array.isArray(e[0]))for(let n of e){if(n.length%2!=0)throw Error(`coords array should be even-numbered`);t.push(Object.freeze({x:n[0],y:n[1]}))}else{if(e.length%2!=0)throw Error(`Expected even number of elements: [x,y,x,y...]`);for(let n=0;n<e.length;n+=2)t.push(Object.freeze({x:e[n],y:e[n+1]}))}return t},Ut=(...e)=>B((e,t)=>e.x<=t.x?e:t,...e),Wt=(...e)=>B((e,t)=>e.x>=t.x?e:t,...e);function U(e,r,i,a){if(p(e)){if(typeof r==`number`&&i!==void 0)n(t(r,`positive`,`width`),t(i,`positive`,`height`));else{if(!Me(r))throw Error(`Expected second parameter to be a rect`);i=r.height,r=r.width}return Object.freeze({x:e.x/r,y:e.y/i})}else{if(n(t(e,`positive`,`x`)),typeof r!=`number`)throw TypeError(`Expecting second parameter to be a number (width)`);if(typeof i!=`number`)throw TypeError(`Expecting third parameter to be a number (height)`);if(n(t(r,`positive`,`y`)),n(t(i,`positive`,`width`)),a===void 0)throw Error(`Expected height parameter`);return n(t(a,`positive`,`height`)),Object.freeze({x:e/i,y:r/a})}}const Gt=(e,t)=>Object.freeze({...e,angleRadian:e.angleRadian+t}),Kt=e=>(E(e,`c`),Object.freeze({...e,angleRadian:e.angleRadian-Math.PI})),qt=(e,t)=>(E(e,`a`),E(t,`b`),e.distance===t.distance?e.angleRadian===-t.angleRadian:!1),Jt=(e,t)=>(E(e,`a`),E(t,`b`),e.angleRadian===t.angleRadian),Yt=(e,t)=>(E(e,`a`),E(t,`b`),e.angleRadian===-t.angleRadian),Xt=(e,t)=>Object.freeze({...e,angleRadian:e.angleRadian+oe(t)}),Zt=e=>{if(e.distance===0)throw Error(`Cannot normalise vector of length 0`);return Object.freeze({...e,distance:1})},Qt=(e,t=1,n=0)=>{let r=e.distance;return r>t&&(r=t),r<n&&(r=n),Object.freeze({...e,distance:r})},$t=(e,t)=>(E(e,`a`),E(t,`b`),e.distance*t.distance*Math.cos(t.angleRadian-e.angleRadian)),en=(e,r)=>(E(e),n(t(r,``,`amt`)),Object.freeze({...e,distance:e.distance*r})),tn=(e,r)=>(E(e),n(t(r,``,`amt`)),Object.freeze({...e,distance:e.distance/r})),nn=(e,t,n)=>ce(e.angleRadian,t.angleRadian,n.angleRadian);var rn=e({fromLine:()=>ln,isParallel:()=>on,toCartesian:()=>an,toString:()=>cn});function an(e,t){let n=Array.isArray(e)?e:[e];if(n.length===0)return[];let r=n.map(e=>{let n=sn(e,t);return{a:T(e.offset??0,e.angleRadian,n),b:T((e.offset??0)+e.length,e.angleRadian,n)}});return Array.isArray(e)?r:r[0]}const on=(e,t)=>e.angleRadian===t.angleRadian,sn=(e,t)=>t===void 0?e.origin===void 0?{x:0,y:0}:e.origin:t,cn=e=>{let t=`PolarRay(angle: ${e.angleRadian} offset: ${e.offset} len: ${e.length}`;return e.origin&&(t+=` origin: ${O(e.origin)}`),t+=`)`,t};function ln(e,t){let n=Array.isArray(e)?e:[e];if(n.length===0)return[];let r=n.map(e=>t?{angleRadian:y(e.a,t),offset:v(e.a,t),length:v(e.b,e.a),origin:t}:{angleRadian:y(e.a,e.b),length:v(e.b,e.a),origin:e.a});return Array.isArray(e)?r:r[0]}function*un(e,t){let n=0;for(;;){let r=e*n++;yield{distance:t*r,angleRadian:r,step:n}}}const dn=(e,t,n)=>{let r=t*e;return Object.freeze({distance:n*r,angleRadian:r})},fn=(...e)=>{let t=e=>{let t=Math.min(e.a.angleRadian,e.b.angleRadian),n=Math.max(e.a.angleRadian,e.b.angleRadian);return{...e,sinBA:Math.sin(e.b.angleRadian-e.a.angleRadian),angleMin:t,angleMax:n,wraps:Math.abs(e.b.angleRadian-e.a.angleRadian)>Math.PI}},n=e.map(e=>t(e)),r=(t=1e-6)=>{let r=[];e.forEach(e=>{r.push(e.a.angleRadian,e.b.angleRadian,e.a.angleRadian-t,e.a.angleRadian+t,e.b.angleRadian-t,e.b.angleRadian+t)}),r.sort((e,t)=>e-t);let a=[];for(let e of r){let t=1/0;for(let r of n){let n=i(e,r);n<t&&(t=n)}t<1/0&&a.push({angleRadian:e,distance:t})}return a},i=(e,t)=>{if(!(t.wraps?e>=t.angleMax||e<=t.angleMin:e>=t.angleMin&&e<=t.angleMax))return NaN;let n=Math.sin(t.b.angleRadian-e),r=Math.sin(e-t.a.angleRadian),i=t.b.distance*n+t.a.distance*r;return i<=0?NaN:t.a.distance*t.b.distance*t.sinBA/i};function*a(t){for(let r=0;r<n.length;r++){let a=i(t,n[r]);Number.isNaN(a)||(yield{distance:a,line:e[r]})}}return{compute:a,visibilityPolygon:r}},pn=(e,t)=>{let n=se(e),r=se(t.a.angleRadian),i=se(t.b.angleRadian);if(!ce(n,r,i))return 1/0;let a=t.a.distance,o=t.b.distance,s=Math.sin(i-r),c=Math.sin(i-n),l=Math.sin(n-r),u=o*c+a*l;if(Math.abs(u)<1e-10)return 1/0;let d=a*o*s/u;return d<0?1/0:d};var mn=e({Ray:()=>rn,between:()=>nn,clampMagnitude:()=>Qt,divide:()=>tn,dotProduct:()=>$t,fromCartesian:()=>A,guard:()=>E,intersectionDistance:()=>pn,intersectionDistanceCompute:()=>fn,invert:()=>Kt,isAntiParallel:()=>Yt,isOpposite:()=>qt,isParallel:()=>Jt,isPolarCoord:()=>qe,lineToCartesian:()=>Be,multiply:()=>en,normalise:()=>Zt,polarLineToString:()=>We,rotate:()=>Gt,rotateDegrees:()=>Xt,spiral:()=>un,spiralRaw:()=>dn,toCartesian:()=>T,toLine:()=>ke,toPoint:()=>He,toPolarLine:()=>Ge,toString:()=>je}),hn=e({clampMagnitude:()=>Dn,divide:()=>jn,dotProduct:()=>En,fromLineCartesian:()=>xn,fromLinePolar:()=>Sn,fromPointPolar:()=>bn,fromRadians:()=>vn,multiply:()=>An,normalise:()=>Cn,quadrantOffsetAngle:()=>wn,subtract:()=>kn,sum:()=>On,toCartesian:()=>J,toPolar:()=>q,toRadians:()=>yn,toString:()=>Tn});const gn=Object.freeze({x:0,y:0}),W=Math.PI*2,_n=Math.PI,vn=e=>Object.freeze({x:Math.cos(e),y:Math.sin(e)}),yn=e=>Math.atan2(e.y,e.x),bn=(e,t=``,n=gn)=>{e=S(e,n);let r=Math.atan2(e.y,e.x);return t===`unipolar`&&r<0?r+=W:t===`bipolar`&&(r>_n?r-=W:r<=-_n&&(r+=W)),Object.freeze({distance:v(e),angleRadian:r})},xn=e=>S(e.b,e.a),Sn=e=>(x(e,`line`),bn(S(e.b,e.a))),G=e=>!!qe(e),K=e=>!!p(e),Cn=e=>{if(G(e))return Zt(e);if(K(e))return Ue(e);throw Error(`Expected polar/cartesian vector. Got: ${e}`)},wn=e=>e.x>=0&&e.y>=0?0:e.x<0&&e.y>=0||e.x<0&&e.y<0?_n:W,q=(e,t=Se)=>{if(G(e))return e;if(K(e))return A(e,t);throw Error(`Expected polar/cartesian vector. Got: ${e}`)},J=e=>{if(G(e))return He(e);if(K(e))return e;throw Error(`Expected polar/cartesian vector. Got: ${e}`)},Tn=(e,t)=>{if(G(e))return je(e,t);if(K(e))return O(e,t);throw Error(`Expected polar/cartesian vector. Got: ${e}`)},En=(e,t)=>{if(G(e)&&G(t))return $t(e,t);if(K(e)&&K(t))return Lt(e,t);throw Error(`Expected two polar/Cartesian vectors.`)},Dn=(e,t=1,n=0)=>{if(G(e))return Qt(e,t,n);if(K(e))return ze(e,t,n);throw Error(`Expected either polar or Cartesian vector`)},On=(e,t)=>{let n=G(e);e=J(e),t=J(t);let r=C(e,t);return n?q(r):r},kn=(e,t)=>{let n=G(e);e=J(e),t=J(t);let r=S(e,t);return n?q(r):r},An=(e,t)=>{let n=G(e);e=J(e),t=J(t);let r=w(e,t);return n?q(r):r},jn=(e,t)=>{let n=G(e);e=J(e),t=J(t);let r=g(e,t);return n?q(r):r},Mn=(e,t)=>{let n=e=>{let{a:n,b:r}=e,i={x:r.x-n.x,y:r.y-n.y},a={x:t.x-n.x,y:t.y-n.y},o=i.x*i.x+i.y*i.y,s=a.x*i.x+a.y*i.y,c=Math.min(1,Math.max(0,s/o));return s=(r.x-n.x)*(t.y-n.y)-(r.y-n.y)*(t.x-n.x),{x:n.x+i.x*c,y:n.y+i.y*c}};if(Array.isArray(e)){let i=e.map(e=>n(e)),a=i.map(e=>v(e,t));return Object.freeze(i[r(a)])}else return Object.freeze(n(e))},Y=(e,t)=>(x(e,`line`),u(t,`point`),_(e)===0?_(e.a,t):_(Mn(e,t),t)),Nn=e=>({x:e.b.x-e.a.x,y:e.b.y-e.a.y}),Pn=e=>{let t=_(e),n=Nn(e);return{x:n.x/t,y:n.y/t}},Fn=(e,t)=>{let n=Nn(e),r=Pn(e),i={x:e.a.x-r.y*t,y:e.a.y+r.x*t};return{a:i,b:{x:i.x+n.x,y:i.y+n.y}}},In=(e,t,n=0)=>{let r=j(n,e),i=Pn(e);return{x:r.x-i.y*t,y:r.y+i.x*t}},Ln=e=>V(e.a,e.b),Rn=(e,t)=>Object.freeze({...e,a:g(e.a,t),b:g(e.b,t)}),zn=(e,t,n,r)=>{if(Number.isNaN(e))throw Error(`x1 is NaN`);if(Number.isNaN(n))throw Error(`x2 is NaN`);if(Number.isNaN(t))throw Error(`y1 is NaN`);if(Number.isNaN(r))throw Error(`y2 is NaN`);return we({x:e,y:t},{x:n,y:r})},Bn=e=>{if(!Array.isArray(e))throw Error(`arr parameter is not an array`);if(e.length!==4)throw Error(`array is expected to have length four`);return zn(e[0],e[1],e[2],e[3])},Vn=(e={x:.5,y:.5},t=1,n=0,r=.5)=>{let i=t*r,a=t*(1-r),o=T(i,ae(n),e),s=T(a,n,e);return Object.freeze({a:o,b:s})},Hn=(e,t)=>{let[n,r]=ve(e,t);return j(.5,n,r)},Un=(e,t)=>v(e.a,t)/_(e),Wn=(e,t)=>Object.freeze({...e,a:C(e.a,t),b:C(e.b,t)}),Gn=(e,t,n)=>t===void 0||t===0?e:(n===void 0&&(n=.5),typeof n==`number`&&(n=j(n,e.a,e.b)),Object.freeze({...e,a:$(e.a,t,n),b:$(e.b,t,n)})),Kn=(e,t)=>R(e.a,t.a)&&R(e.b,t.b),qn=(e,t)=>Object.freeze({...e,a:w(e.a,t),b:w(e.b,t)}),Jn=(e,t)=>Object.freeze({...e,a:S(e.a,t),b:S(e.b,t)});function Yn(e,t){if(M(e))x(e,`a`),t=e.b,e=e.a;else if(t===void 0)throw Error(`Expect second point if first is a point`);return O(e)+`-`+O(t)}const X=e=>{let{a:t,b:n}=e;return Object.freeze({...e,length:()=>_(t,n),interpolate:e=>j(e,t,n),relativePosition:t=>Un(e,t),bbox:()=>Ln(e),toString:()=>Yn(t,n),toFlatArray:()=>fr(t,n),toSvgString:()=>mr(t,n),toPoints:()=>[t,n],rotate:(t,n)=>X(Gn(e,t,n)),nearest:t=>Mn(e,t),sum:t=>X(Wn(e,t)),divide:t=>X(Rn(e,t)),multiply:t=>X(qn(e,t)),subtract:t=>X(Jn(e,t)),midpoint:()=>Hn(t,n),distanceToPoint:t=>Y(e,t),parallel:t=>Fn(e,t),perpendicularPoint:(t,n)=>In(e,t,n),slope:()=>or(e),withinRange:(t,n)=>ar(e,t,n),isEqual:t=>Kn(e,t),apply:t=>X(nr(e,t)),kind:`line`})},Xn=(e,t)=>X(we(e,t));var Zn=e({Empty:()=>Qn,Placeholder:()=>$n,angleRadian:()=>rr,apply:()=>nr,asPoints:()=>pr,bbox:()=>Ln,distance:()=>dr,distanceSingleLine:()=>Y,divide:()=>Rn,extendFromA:()=>lr,fromFlatArray:()=>Bn,fromNumbers:()=>zn,fromPivot:()=>Vn,fromPoints:()=>we,fromPointsToPath:()=>Xn,getPointParameter:()=>ve,guard:()=>x,interpolate:()=>j,isEmpty:()=>er,isEqual:()=>Kn,isLine:()=>M,isPlaceholder:()=>tr,isPolyLine:()=>de,joinPointsToLines:()=>Te,length:()=>_,midpoint:()=>Hn,multiply:()=>qn,nearest:()=>Mn,normaliseByRect:()=>ir,parallel:()=>Fn,perpendicularPoint:()=>In,pointAtDistance:()=>Ae,pointAtX:()=>cr,pointsOf:()=>ur,polyLineToPoints:()=>ge,relativePosition:()=>Un,reverse:()=>Xe,rotate:()=>Gn,scaleFromMidpoint:()=>sr,slope:()=>or,subtract:()=>Jn,sum:()=>Wn,toFlatArray:()=>fr,toPath:()=>X,toString:()=>Yn,toSvgString:()=>mr,withinRange:()=>ar});const Qn=Object.freeze({a:Object.freeze({x:0,y:0}),b:Object.freeze({x:0,y:0})}),$n=Object.freeze({a:Object.freeze({x:NaN,y:NaN}),b:Object.freeze({x:NaN,y:NaN})}),er=e=>h(e.a)&&h(e.b),tr=e=>f(e.a)&&f(e.b),nr=(e,t)=>Object.freeze({...e,a:t(e.a),b:t(e.b)}),rr=(e,t)=>{let n;if(M(e))n=e.a,t=e.b;else if(n=e,t===void 0)throw Error(`b point must be provided`);return Math.atan2(t.y-n.y,t.x-n.x)},ir=(e,t,n)=>Object.freeze({...e,a:U(e.a,t,n),b:U(e.b,t,n)}),ar=(e,t,n)=>dr(e,t)<=n,or=(e,t)=>{let n;if(M(e))n=e.a,t=e.b;else if(n=e,t===void 0)throw Error(`b parameter required`);if(t===void 0)throw TypeError(`Second point missing`);return(t.y-n.y)/(t.x-n.x)},sr=(e,t)=>({a:j(t/2,e),b:j(.5+t/2,e)}),cr=(e,t)=>{let n=e.a.y+(t-e.a.x)*or(e);return Object.freeze({x:t,y:n})},lr=(e,t)=>{let n=_(e);return Object.freeze({...e,a:e.a,b:Object.freeze({x:e.b.x+(e.b.x-e.a.x)/n*t,y:e.b.y+(e.b.y-e.a.y)/n*t})})};function*ur(e){let{a:t,b:n}=e,r=Math.floor(t.x),i=Math.floor(t.y),a=Math.floor(n.x),o=Math.floor(n.y),s=Math.abs(a-r),c=-Math.abs(o-i),l=r<a?1:-1,u=i<o?1:-1,d=s+c;for(;yield{x:r,y:i},!(r===a&&i===o);){let e=2*d;e>=c&&(d+=c,r+=l),e<=s&&(d+=s,i+=u)}}const dr=(e,t)=>Array.isArray(e)?a(e.map(e=>Y(e,t))):Y(e,t),fr=(e,t)=>{if(M(e))return[e.a.x,e.a.y,e.b.x,e.b.y];if(p(e)&&p(t))return[e.x,e.y,t.x,t.y];throw Error(`Expected single line parameter, or a and b points`)};function*pr(e){for(let t of e)yield t.a,yield t.b}const mr=(e,t)=>[`M${e.x} ${e.y} L ${t.x} ${t.y}`],Z=(e,t)=>{let n=b(e,t),r=0,i=0,a=0,o=performance.now(),s=n;return(e,t)=>{let c=b(e,t);r+=c.x,i+=c.y,a++;let l=v(c,n),u=v(c,s),d=performance.now(),f=u/(d-o);return o=d,s=c,Object.freeze({angle:y(c,n),distanceFromStart:l,distanceFromLast:u,speed:f,centroid:At(c,n),average:{x:r/a,y:i/a}})}},hr=Object.freeze({x:NaN,y:NaN}),gr=Object.freeze({x:NaN,y:NaN,z:NaN});var Q=class extends Ze{initialRelation;markRelation;lastResult;constructor(e={}){super(e)}onTrimmed(e){this.initialRelation=void 0}onReset(){super.onReset(),this.lastResult=void 0,this.initialRelation=void 0,this.markRelation=void 0}mark(){this.markRelation=Z(this.last)}computeResults(e){let t=this.last,n=this.values.at(-2);if(this.initialRelation===void 0&&this.initial)this.initialRelation=Z(this.initial);else if(this.initialRelation===void 0)throw Error(`Bug: No initialRelation, and this.inital is undefined?`);let r=Z(n===void 0?t:n),i=this.initialRelation(t),a=this.markRelation===void 0?void 0:this.markRelation(t),o=n===void 0?0:_(n,t,!0)/(t.at-n.at),s={fromInitial:i,fromLast:{...r(t),speed:o},fromMark:a,values:[...this.values]};return this.lastResult=s,s}get line(){return this.values.length===1?[]:Te(...this.values)}get vectorPolar(){return Sn(this.lineStartEnd)}get vectorCartesian(){return xn(this.lineStartEnd)}get lineStartEnd(){let e=this.initial;return this.values.length<2||!e?Qn:{a:e,b:this.last}}distanceFromStart(e=!1){let t=this.initial;return this.values.length>=2&&t!==void 0?e?De(t,this.last):v(t,this.last):0}speedFromStart(e=!1){let t=this.lengthTotal(e),n=this.timespan;return Number.isNaN(n)||t===0?0:Math.abs(t)/n}speedFromLast(e=!1){let t=this.lastResult;return t?t.fromLast.speed:0}difference(){let e=this.initial;return this.values.length>=2&&e!==void 0?S(this.last,e):hr}angleFromStart(){let e=this.initial;if(e!==void 0&&this.values.length>2)return y(e,this.last)}lengthTotal(e=!1){if(this.values.length===1)return 0;let t=this.line;return _(t,e)}lengthAverage(e=!1){return this.lengthTotal(e)/this.values.length}get x(){return this.last.x}get y(){return this.last.y}get z(){return this.last.z}},_r=class extends Qe{constructor(e={}){super((t,n)=>{if(n===void 0)throw Error(`Requires start point`);let r=new Q({...e,id:t});return r.seen(n),r})}get(e){return super.get(e)}},vr=class extends Q{seenEvent(e){if(`getCoalescedEvents`in e){let t=e.getCoalescedEvents().map(e=>({x:e.clientX,y:e.clientY}));return this.seen(...t)}else return this.seen({x:e.clientX,y:e.clientY})}},yr=class extends Qe{constructor(e={}){super((t,n)=>{if(n===void 0)throw Error(`Requires start point`);let r=new vr({...e,id:t});return r.seen(n),r})}get(e){return super.get(e)}seenEvent(e){if(`getCoalescedEvents`in e){let t=e.getCoalescedEvents().map(e=>super.seen(e.pointerId.toString(),e));return Promise.all(t)}else return Promise.all([super.seen(e.pointerId.toString(),e)])}};const br=(e,t,n)=>{let r=S(e,t),i=S(n,t);return m(r)&&m(i)?(r.x*i.x+r.y*i.y+r.z*i.z)/(i.x*i.x+i.y*i.y+i.z*i.z):(r.x*i.x+r.y*i.y)/(i.x*i.x+i.y*i.y)},xr=(e,t,n)=>({x:Math.cos(n)*t+e.x,y:Math.sin(n)*t+e.y});function Sr(e,t,n=!0){if(u(e,`pt`),u(t,`snap`),m(e)){if(!m(t))throw TypeError(`Param 'snap' is missing 'z' field`);return Object.freeze({x:l(e.x,t.x,n),y:l(e.y,t.y,n),z:l(e.z,t.z,n)})}return Object.freeze({x:l(e.x,t.x,n),y:l(e.y,t.y,n)})}const Cr=e=>(e===void 0&&(e=Math.random),Object.freeze({x:e(),y:e()})),wr=e=>(e===void 0&&(e=Math.random),Object.freeze({x:e(),y:e(),z:e()})),Tr=(e,t,n)=>{n===void 0&&(n={x:0,y:0});let r=n;for(let n of e)r=t(n,r);return r};function $(e,r,i){i===void 0&&(i={x:0,y:0}),u(i,`origin`),n(t(r,``,`amountRadian`));let a=Array.isArray(e);if(r===0)return e;a||(e=[e]);let o=e;for(let[e,t]of o.entries())u(t,`pt[${e}]`);let s=o.map(e=>A(e,i)).map(e=>Gt(e,r)).map(e=>T(e,i));return a?s:s[0]}const Er=(e,t)=>{let n=[[Math.cos(t),-Math.sin(t)],[Math.sin(t),Math.cos(t)]],r=[];for(let[t,i]of e.entries())r[t]=[n[0][0]*i[0]+n[0][1]*i[1],n[1][0]*i[0]+n[1][1]*i[1]];return r},Dr=(e,t,n)=>{let r=b(e,t);return n??=t,n??=2,Object.freeze({...r,x:c(n,r.x),y:c(n,r.y)})},Or=(e,r,i)=>{u(e,`a`),u(r,`b`),typeof i==`number`?(n(t(i,`positive`,`maxRange`)),i={x:i,y:i}):u(i,`maxRange`);let a=Math.abs(r.x-e.x),o=Math.abs(r.y-e.y);return a<=i.x&&o<=i.y},kr=(e,t,n)=>(t===void 0&&(t={x:1,y:1}),n===void 0&&(n={x:0,y:0}),u(e,`pt`),u(t,`ptMax`),u(n,`ptMin`),Object.freeze({x:s(e.x,n.x,t.x),y:s(e.y,n.y,t.y)}));var Ar=e({Empty:()=>Se,Empty3d:()=>fe,Placeholder:()=>hr,Placeholder3d:()=>gr,PointTracker:()=>Q,PointsTracker:()=>_r,Unit:()=>Ye,Unit3d:()=>Ce,UserPointerTracker:()=>vr,UserPointersTracker:()=>yr,abs:()=>me,angleRadian:()=>y,angleRadianCircle:()=>ye,angleRadianThreePoint:()=>xe,apply:()=>Ot,average:()=>d,averager:()=>te,bbox:()=>V,bbox3d:()=>kt,centroid:()=>At,clamp:()=>jt,clampMagnitude:()=>ze,compare:()=>be,compareByX:()=>Re,compareByY:()=>ue,compareByZ:()=>Le,convexHull:()=>Mt,cross:()=>Rt,crossProductRaw:()=>zt,distance:()=>v,distance2d:()=>De,distanceToCenter:()=>Pt,distanceToExterior:()=>Ft,divide:()=>g,divider:()=>pe,dotProduct:()=>Lt,findMinimum:()=>B,from:()=>Bt,fromNumbers:()=>Ht,fromString:()=>Vt,getPointParameter:()=>b,getTwoPointParameters:()=>le,guard:()=>u,guardNonZeroPoint:()=>ie,interpolate:()=>Je,invert:()=>Oe,isEmpty:()=>h,isEqual:()=>R,isNaN:()=>ee,isNull:()=>ne,isPlaceholder:()=>f,isPoint:()=>p,isPoint3d:()=>m,leftmost:()=>Ut,multiply:()=>w,multiplyScalar:()=>Fe,normalise:()=>Ue,normaliseByRect:()=>U,pipeline:()=>Ne,pipelineApply:()=>Pe,progressBetween:()=>br,project:()=>xr,quantiseEvery:()=>Sr,random:()=>Cr,random3d:()=>wr,reduce:()=>Tr,relation:()=>Z,rightmost:()=>Wt,rotate:()=>$,rotatePointArray:()=>Er,round:()=>Dr,subtract:()=>S,sum:()=>C,test:()=>re,to2d:()=>Ee,to3d:()=>he,toArray:()=>It,toIntegerValues:()=>_e,toString:()=>O,withinRange:()=>Or,wrap:()=>kr});export{$e as $,vt as A,dt as B,Dt as C,St as D,Ct as E,_t as F,rt as G,ct as H,pt as I,F as J,P as K,L,mt as M,ht as N,bt as O,gt as P,tt as Q,I as R,Tt as S,xt as T,lt as U,ut as V,st as W,at as X,it as Y,nt as Z,Ht as _,Q as a,Nt as b,yr as c,X as d,N as et,zn as f,an as g,ln as h,xr as i,R as j,yt as k,hr as l,mn as m,$ as n,_r as o,hn as p,ot as q,Tr as r,vr as s,Ar as t,et as tt,Zn as u,zt as v,Et as w,V as x,H as y,ft as z};