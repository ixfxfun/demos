{"version":3,"file":"index-pdF5CCTk.d.ts","names":["applyToValues","Record","T","averageWeighted","clamp","clamper","clampIndex","maxAbs","count","Generator","DifferenceKind","differenceFromFixed","differenceFromLast","filterIterable","Iterable","Generator","thresholdAtLeast","rangeInclusive","flip","numericRangeRaw","Generator","numericRange","numericPercent","isValid","isApprox","isCloseToAny","NumbersComputeResult","NumbersComputeOptions","Readonly","NumberScaler","NumberScalerTwoWay","BipolarWrapper","Symbol","toPrimitive","BipolarWrapper","immutable","toScalar","fromScalar","scale","scaleUnclamped","clamp","towardZero","BasicInterpolateOptions","interpolate","Partial","interpolatorStepped","interpolateAngle","linearSpace","IterableIterator","movingAverageLight","movingAverage","noiseFilter","stream","array","NumbersComputeOptions","NumbersComputeResult","numberArrayCompute","weight","validNumbers","dotProduct","average","min","maxIndex","minIndex","max","total","maxFast","Float32Array","totalFast","minFast","proportion","quantiseEvery","round","NumberScaler","NumberScalerTwoWay","scale","scaler","scalerNull","scaleClamped","scalePercentages","scalePercent","scalerPercent","scalerTwoWay","softmax","wrapInteger","wrap","wrapRange","Bipolar","Normalise"],"sources":["../../numbers/dist/src/apply-to-values.d.ts","../../numbers/dist/src/average-weighted.d.ts","../../numbers/dist/src/clamp.d.ts","../../numbers/dist/src/count.d.ts","../../numbers/dist/src/difference.d.ts","../../numbers/dist/src/filter.d.ts","../../numbers/dist/src/flip.d.ts","../../numbers/dist/src/generate.d.ts","../../numbers/dist/src/guard.d.ts","../../numbers/dist/src/is-approx.d.ts","../../numbers/dist/src/types.d.ts","../../numbers/dist/src/bipolar.d.ts","../../numbers/dist/src/interpolate.d.ts","../../numbers/dist/src/linear-space.d.ts","../../numbers/dist/src/moving-average.d.ts","../../numbers/dist/src/normalise.d.ts","../../numbers/dist/src/number-array-compute.d.ts","../../numbers/dist/src/numeric-arrays.d.ts","../../numbers/dist/src/proportion.d.ts","../../numbers/dist/src/quantise.d.ts","../../numbers/dist/src/round.d.ts","../../numbers/dist/src/scale.d.ts","../../numbers/dist/src/softmax.d.ts","../../numbers/dist/src/wrap.d.ts","../../numbers/dist/src/index.d.ts"],"sourcesContent":["/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n *\n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object\n * @param apply\n * @returns\n */\nexport declare const applyToValues: <T extends Record<string, any>>(object: T, apply: (v: number) => number) => T;\n//# sourceMappingURL=apply-to-values.d.ts.map","/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * averageWeighted[1,2,3], Random.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * const data = [1,2,3];\n * const w = weight(data, Random.gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport declare const averageWeighted: (data: number[] | readonly number[], weightings: number[] | readonly number[] | ((value: number) => number)) => number;\n//# sourceMappingURL=average-weighted.d.ts.map","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link https://api.ixfx.fun/_ixfx/geometry/Points/clamp/ @ixfx/geometry/Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport declare const clamp: (value: number, min?: number, max?: number) => number;\n/**\n * Returns a function that clamps values.\n *\n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport declare const clamper: (min?: number, max?: number) => (v: number) => number;\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport declare const clampIndex: (v: number, arrayOrLength: number | readonly any[]) => number;\n/**\n * Returns the largest value, ignoring the sign of numbers\n *\n * ```js\n * maxAbs(1, 5);    // 5\n * maxAbs(-10, 5);  // -10 (since sign is ignored)\n * ```\n * @param values\n * @returns\n */\nexport declare const maxAbs: (...values: number[]) => number;\n//# sourceMappingURL=clamp.d.ts.map","/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport declare function count(amount: number, offset?: number): Generator<number, void, void>;\n//# sourceMappingURL=count.d.ts.map","export type DifferenceKind = `numerical` | `relative` | `relativeSigned` | `absolute`;\n/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n *\n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n *\n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n *\n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport declare const differenceFromFixed: (initial: number, kind?: DifferenceKind) => (value: number) => number;\n/**\n * Returns a function which yields difference compared to last value.\n *\n * If no initial value is provided, the first difference will be returned as 0.\n *\n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n *\n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n *\n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n *\n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value\n * @returns\n */\nexport declare const differenceFromLast: (kind?: DifferenceKind, initialValue?: number) => (v: number) => number;\n//# sourceMappingURL=difference.d.ts.map","/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filterIterable(data)) {\n *  // 10\n * }\n * ```\n * @param it\n */\nexport declare function filterIterable(it: Iterable<unknown>): Generator<unknown, void, unknown>;\n/**\n * Returns a function that yields _true_ if a value\n * is at least `threshold`\n * ```js\n * const t = thresholdAtLeast(50);\n * t(50); // true\n * t(0);  // false\n * t(55); // true\n * ```\n * @param threshold\n * @returns\n */\nexport declare const thresholdAtLeast: (threshold: number) => (v: number) => boolean;\n/**\n * Returns a function that yields _true_\n * if a number is at least _min_ and no greater than _max_\n *\n * ```js\n * const t = rangeInclusive(50, 100);\n * t(40); // false\n * t(50); // true\n * t(60); // true\n * t(100); // true\n * t(101);  // false\n * ```\n * @param min\n * @param max\n * @returns\n */\nexport declare const rangeInclusive: (min: number, max: number) => (v: number) => boolean;\n//# sourceMappingURL=filter.d.ts.map","/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport declare const flip: (v: number | (() => number)) => number;\n//# sourceMappingURL=flip.d.ts.map","/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport declare const numericRangeRaw: (interval: number, start?: number, end?: number, repeating?: boolean) => Generator<number, void, unknown>;\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport declare const numericRange: (interval: number, start?: number, end?: number, repeating?: boolean, rounding?: number) => Generator<number, void, unknown>;\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport declare const numericPercent: (interval?: number, repeating?: boolean, start?: number, end?: number) => Generator<number, void, unknown>;\n//# sourceMappingURL=generate.d.ts.map","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport declare const isValid: (possibleNumber: unknown) => boolean;\n//# sourceMappingURL=guard.d.ts.map","/**\n * Returns a function that checks if a value is within range of a base value\n * ```js\n * const tenPercent = isApprox(0.1);\n * // Check if 101 is within 10% range of 100\n * tenPercent(100, 101);\n * ```\n * @param rangePercent\n */\nexport declare function isApprox(rangePercent: number): (baseValue: number, value: number) => boolean;\n/**\n * Returns a function to check if a value is within range of a base value\n * ```js\n * const close = isApprox(0.1, 100);\n * // Check if 101 is within 10% range of 100\n * close(101);\n * ```\n * @param rangePercent\n * @param baseValue\n */\nexport declare function isApprox(rangePercent: number, baseValue: number): (value: number) => boolean;\n/**\n * Returns _true/false_ if `value` is within `rangePercent` of `baseValue`.\n *\n * ```js\n * isApprox(0.1, 100, 101);\n * ```\n * @param rangePercent\n * @param baseValue\n * @param value\n */\nexport declare function isApprox(rangePercent: number, baseValue: number, value: number): boolean;\n/**\n * Yields a function that checks if a value is close to any target value\n * ```js\n * const c = isCloseToAny(1, 10, 20, 30, 40);\n * c(11); // True - within 1 range of 10\n * c(19); // True - within 1 range of 20\n * c(0);  // False\n * ```\n *\n * Returned function accepts multiple values, returning\n * _true_ if any of them are within range\n * ```js\n * c(0, 1, 11); // Would return true based on 11\n * ```\n * @param allowedRangeAbsolute\n * @param targets\n * @returns\n */\nexport declare const isCloseToAny: (allowedRangeAbsolute: number, ...targets: number[]) => (...values: number[]) => boolean;\n//# sourceMappingURL=is-approx.d.ts.map","export type NumbersComputeResult = {\n    /**\n     * Tally of number of items\n     */\n    readonly count: number;\n    /**\n     * Smallest value in array\n     */\n    readonly min: number;\n    /**\n     * Total of all items\n     */\n    readonly total: number;\n    /**\n     * Largest value in array\n     */\n    readonly max: number;\n    /**\n     * Average value in array\n     */\n    readonly avg: number;\n};\nexport type NumbersComputeOptions = Readonly<{\n    /**\n     * Start index, inclusive\n     */\n    /**\n     * End index, exclusive\n     */\n    nonNumbers?: `throw` | `ignore` | `nan`;\n}>;\nexport type NumberScaler = (v: number) => number;\nexport type NumberScalerTwoWay = {\n    out: NumberScaler;\n    in: NumberScaler;\n};\n/**\n * Wrapper around a bipolar value. Immutable.\n *\n * ```js\n * let b = Bipolar.immutable();\n * let b = Bipolar.immutable(0.5);\n * b = b.add(0.1);\n * ```\n */\nexport type BipolarWrapper = {\n    value: number;\n    towardZero: (amt: number) => BipolarWrapper;\n    add: (amt: number) => BipolarWrapper;\n    multiply: (amt: number) => BipolarWrapper;\n    inverse: () => BipolarWrapper;\n    asScalar: () => number;\n    interpolate: (amt: number, b: number) => BipolarWrapper;\n    [Symbol.toPrimitive]: (hint: string) => number | string | boolean;\n};\n//# sourceMappingURL=types.d.ts.map","import type { BipolarWrapper } from './types.js';\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n *\n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n *\n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n *\n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns\n */\nexport declare const immutable: (startingValueOrBipolar?: number | BipolarWrapper) => BipolarWrapper;\n/**\n * Converts bipolar value to a scalar. That is, converts from\n * -1..1 range to 0..1.\n *\n * ```js\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n *\n * Range can be changed:\n * ```js\n * Bipolar.toScalar(0, 100); // Uses 0..100 scale, so output is 50\n * Bipolar.toScalar(0, 100, 50); // Uses 50..1000 scale, so output is 75\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport declare const toScalar: (bipolarValue: number, max?: number, min?: number) => number;\n/**\n * Makes a scalar into a bipolar value.\n *\n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n *\n * Throws an error if `scalarValue` is outside 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport declare const fromScalar: (scalarValue: number) => number;\n/**\n * Scale & clamp value to bipolar range (-1..1).\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport declare const scale: (inputValue: number, inMin: number, inMax: number) => number;\n/**\n * Scale a number to bipolar range (-1..1). Not clamped, so we might exceed range.\n *\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scaleUnclamped(100, 0, 100); // 1\n * Bipolar.scaleUnclamped(50, 0, 100);  // 0\n * Bipolar.scaleUnclamped(0, 0, 100);   // -1\n * ```\n *\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport declare const scaleUnclamped: (inputValue: number, inMin: number, inMax: number) => number;\n/**\n * Clamp a bipolar value\n * ```js\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport declare const clamp: (bipolarValue: number) => number;\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n *\n * ```js\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n *\n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport declare const towardZero: (bipolarValue: number, amount: number) => number;\n//# sourceMappingURL=bipolar.d.ts.map","/**\n * Interpolation options.\n *\n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n *\n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n *\n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result.\n *\n */\nexport type BasicInterpolateOptions = {\n    limits: `clamp` | `wrap` | `ignore`;\n    transform: (v: number) => number;\n};\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n *\n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n *\n * ```js\n * // Create function\n * const fn = interpolate(0.1);\n *\n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n *\n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport declare function interpolate(amount: number, options?: Partial<BasicInterpolateOptions>): (a: number, b: number) => number;\n/**\n * Interpolates between `a` and `b` by `amount`.\n *\n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n *\n * ```js\n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n *\n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport declare function interpolate(amount: number, a: number, b: number, options?: Partial<BasicInterpolateOptions>): number;\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n *\n * ```js\n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n *\n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport declare function interpolate(a: number, b: number, options?: Partial<BasicInterpolateOptions>): (amount: number) => number;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link https://api.ixfx.fun/_ixfx/modulation/interpolatorInterval/}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport declare const interpolatorStepped: (incrementAmount: number, a?: number, b?: number, startInterpolationAt?: number, options?: Partial<BasicInterpolateOptions>) => (retargetB?: number, retargetA?: number) => number;\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport declare const interpolateAngle: (amount: number, aRadians: number, bRadians: number, options?: Partial<BasicInterpolateOptions>) => number;\n//# sourceMappingURL=interpolate.d.ts.map","/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport declare function linearSpace(start: number, end: number, steps: number, precision?: number): IterableIterator<number>;\n//# sourceMappingURL=linear-space.d.ts.map","/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport declare const movingAverageLight: (scaling?: number) => (value?: number) => number;\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from '@ixfx/numbers.js';\n * import { gaussian } from '@ixfx/modulation.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport declare const movingAverage: (samples?: number, weighter?: (v: number) => number) => (value?: number) => number;\n/**\n * Noise filtering\n *\n * Algorithm: https://gery.casiez.net/1euro/\n *\n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport declare const noiseFilter: (cutoffMin?: number, speedCoefficient?: number, cutoffDefault?: number) => (value: number, timestamp?: number) => number;\n//# sourceMappingURL=moving-average.d.ts.map","/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * @example\n * ```js\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport declare const stream: (minDefault?: number, maxDefault?: number) => (v: number) => number;\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * ```js\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport declare const array: (values: readonly number[], minForced?: number, maxForced?: number) => number[];\n//# sourceMappingURL=normalise.d.ts.map","import type { NumbersComputeOptions, NumbersComputeResult } from \"./types.js\";\n/**\n * Calculate the min, max, total, average and count of input array `data`.\n * ```js\n * const { total, min, max, avg, count } = numberArrayCompute([ 1, 2, 3 ]);\n * ```\n * @param data\n * @param opts\n * @returns\n */\nexport declare const numberArrayCompute: (data: number[] | readonly number[], opts?: NumbersComputeOptions) => NumbersComputeResult;\n//# sourceMappingURL=number-array-compute.d.ts.map","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport declare const weight: (data: number[] | readonly number[], fn?: (relativePos: number) => number) => number[];\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport declare const validNumbers: (data: readonly number[]) => number[];\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport declare const dotProduct: (values: readonly (readonly number[])[]) => number;\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link numberArrayCompute} if you want min, max and total as well.\n *\n * @example\n * ```js\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport declare const average: (data: readonly number[]) => number;\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport declare const min: (data: readonly number[]) => number;\n/**\n * Returns the index of the largest value.\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport declare const maxIndex: (data: readonly number[]) => number;\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport declare const minIndex: (...data: readonly number[]) => number;\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport declare const max: (data: readonly number[]) => number;\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport declare const total: (data: readonly number[]) => number;\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport declare const maxFast: (data: readonly number[] | Float32Array) => number;\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport declare const totalFast: (data: readonly number[] | Float32Array) => number;\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport declare const minFast: (data: readonly number[] | Float32Array) => number;\n//# sourceMappingURL=numeric-arrays.d.ts.map","/**\n * Scales a percentage-scale number, ie: `v * t`.\n *\n * The utility of this function is that it sanity-checks that\n * both parameters are in the 0..1 scale.\n *\n * Parameters can also be a function that takes no parameters\n * and returns a number. It will be invoked when `proportion` is called.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport declare const proportion: (v: number | (() => number), t: number | (() => number)) => number;\n//# sourceMappingURL=proportion.d.ts.map","/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n *\n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport declare const quantiseEvery: (v: number, every: number, middleRoundsUp?: boolean) => number;\n//# sourceMappingURL=quantise.d.ts.map","export declare function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport declare function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n//# sourceMappingURL=round.d.ts.map","import type { NumberScaler, NumberScalerTwoWay } from './types.js';\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport declare const scale: (v: number, inMin: number, inMax: number, outMin?: number, outMax?: number, easing?: (v: number) => number) => number;\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport declare const scaler: (inMin: number, inMax: number, outMin?: number, outMax?: number, easing?: (v: number) => number, clamped?: boolean) => NumberScaler;\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns\n */\nexport declare const scalerNull: () => NumberScaler;\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport declare const scaleClamped: (v: number, inMin: number, inMax: number, outMin?: number, outMax?: number, easing?: (v: number) => number) => number;\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport declare const scalePercentages: (percentage: number, outMin: number, outMax?: number) => number;\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport declare const scalePercent: (v: number, outMin: number, outMax: number) => number;\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport declare const scalerPercent: (outMin: number, outMax: number) => (v: number) => number;\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n *\n * // Scale from input to output\n * s.out(50); // 0.5\n *\n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin\n * @param inMax\n * @param outMin\n * @param outMax\n * @returns\n */\nexport declare const scalerTwoWay: (inMin: number, inMax: number, outMin?: number, outMax?: number, clamped?: boolean, easing?: (v: number) => number) => NumberScalerTwoWay;\n//# sourceMappingURL=scale.d.ts.map","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits\n * @returns\n */\nexport declare const softmax: (logits: number[]) => number[];\n//# sourceMappingURL=softmax.d.ts.map","/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport declare const wrapInteger: (v: number, min?: number, max?: number) => number;\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport declare const wrap: (v: number, min?: number, max?: number) => number;\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport declare const wrapRange: (min: number, max: number, fn: (distance: number) => number, a: number, b: number) => number;\n//# sourceMappingURL=wrap.d.ts.map","export * from './apply-to-values.js';\nexport * from './average-weighted.js';\nexport * from './clamp.js';\nexport * from './count.js';\nexport * from './difference.js';\nexport * from './filter.js';\nexport * from './flip.js';\nexport * from './generate.js';\nexport * from './guard.js';\nexport * from './is-approx.js';\nexport * as Bipolar from './bipolar.js';\nexport * from './interpolate.js';\nexport * from './linear-space.js';\nexport * from './moving-average.js';\nexport * as Normalise from './normalise.js';\nexport * from './number-array-compute.js';\nexport * from './numeric-arrays.js';\nexport * from './proportion.js';\nexport * from './quantise.js';\nexport * from './round.js';\nexport * from './scale.js';\nexport * from './softmax.js';\nexport * from './wrap.js';\nexport * from './types.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}