{"version":3,"file":"flow-C0yYgfyb.js","names":["resolve","timeout","#handlers","#counter","#id","rateMinimum","options: RateMinimumOptions<TInput>","args: TInput","#data","#lastUsersChange","#resourcesWithoutUserExpireAfterMs","#capacityPerResource","#users","#state","r","#allocateResource","resolve","timeout","resolve","#maintainLoop","#maintain","#outgoing","#requestCallback","#requestAwait","resolve","run","#resolve","#promise","#reject","resolve","#initPromise","resolve","#promise","#resolve","resolve","#written"],"sources":["../../packages/flow/dist/src/behaviour-tree.js","../../packages/flow/dist/src/delay.js","../../packages/flow/dist/src/dispatch-list.js","../../packages/flow/dist/src/every.js","../../packages/flow/dist/src/execute.js","../../packages/flow/src/rate-minimum.ts","../../packages/flow/dist/src/moving-average.js","../../packages/flow/dist/src/pool.js","../../packages/flow/dist/src/promise-with-resolvers.js","../../packages/flow/dist/src/timeout.js","../../packages/flow/dist/src/rate-minimum.js","../../packages/flow/dist/src/repeat.js","../../packages/flow/dist/src/req-resp-match.js","../../packages/flow/dist/src/retry.js","../../packages/flow/dist/src/run-once.js","../../packages/flow/dist/src/sync-wait.js","../../packages/flow/dist/src/task-queue-mutable.js","../../packages/flow/dist/src/throttle.js","../../packages/flow/dist/src/timer.js","../../packages/flow/dist/src/update-outdated.js","../../packages/flow/dist/src/wait-for-value.js","../../packages/flow/dist/src/wait-for.js","../src/flow.ts"],"sourcesContent":["const t = {\n    name: `root`,\n    seq: [\n        `walk_to_door`,\n        {\n            name: `door_locked`,\n            sel: [\n                `open_door`,\n                {\n                    name: `open_locked_door`,\n                    seq: [`unlock_door`, `open_door`]\n                },\n                `smash_door`\n            ]\n        },\n        `walk_through_door`,\n        `close_door`\n    ]\n};\nconst getName = (t, defaultValue = ``) => {\n    if (typeof t === `object` && `name` in t && t.name !== undefined)\n        return t.name;\n    return defaultValue;\n};\n//eslint-disable-next-line func-style\nexport function* iterateBreadth(t, pathPrefix) {\n    if (typeof pathPrefix === `undefined`) {\n        pathPrefix = getName(t);\n    }\n    for (const [index, n] of entries(t)) {\n        yield [n, pathPrefix];\n    }\n    for (const [index, n] of entries(t)) {\n        const name = getName(n, `?`);\n        const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n        yield* iterateBreadth(n, prefix);\n    }\n}\n//eslint-disable-next-line func-style\nexport function* iterateDepth(t, pathPrefix) {\n    if (typeof pathPrefix === `undefined`) {\n        pathPrefix = getName(t);\n    }\n    for (const [index, n] of entries(t)) {\n        yield [n, pathPrefix];\n        const name = getName(n, `?`);\n        const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n        yield* iterateBreadth(n, prefix);\n    }\n}\n//eslint-disable-next-line func-style\nfunction isSeqNode(n) {\n    return n.seq !== undefined;\n}\n//eslint-disable-next-line func-style\nfunction isSelNode(n) {\n    return n.sel !== undefined;\n}\n//eslint-disable-next-line func-style\nfunction* entries(n) {\n    if (isSeqNode(n)) {\n        yield* n.seq.entries();\n    }\n    else if (isSelNode(n)) {\n        yield* n.sel.entries();\n    }\n    else if (typeof n === `string`) {\n        // no-op\n    }\n    else {\n        throw new TypeError(`Unexpected shape of node. seq/sel missing`);\n    }\n}\n// for (const tn of iterateBreadth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n// console.log(`---`);\n// for (const tn of iterateDepth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n","import { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async (callback, \n//eslint-disable-next-line functional/prefer-immutable-types\noptsOrMillis) => {\n    const opts = typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n    const delayWhen = opts.delay ?? `before`;\n    if (delayWhen === `before` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    const r = Promise.resolve(await callback());\n    if (delayWhen === `after` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    return r;\n};\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//     // Yield value\n//     yield v;\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n *\n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n *\n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n *\n * The below example shows how to do this.\n *\n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n *\n * // Execution continues while loop also runs\n * ```\n *\n */\nasync function* delayAnimationLoop() {\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer = 0;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.requestAnimationFrame(callback);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        globalThis.cancelAnimationFrame(timer);\n    }\n}\n/**\n * Async generator that loops at a given interval.\n *\n * @example\n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n *\n * @example\n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport async function* delayLoop(timeout) {\n    const timeoutMs = intervalToMs(timeout);\n    if (typeof timeoutMs === `undefined`)\n        throw new Error(`timeout is undefined`);\n    if (timeoutMs < 0)\n        throw new Error(`Timeout is less than zero`);\n    if (timeoutMs === 0)\n        return yield* delayAnimationLoop();\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.setTimeout(callback, timeoutMs);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        if (timer !== undefined)\n            globalThis.clearTimeout(timer);\n        timer = undefined;\n    }\n}\n","export class DispatchList {\n    #handlers;\n    #counter = 0;\n    #id = Math.floor(Math.random() * 100);\n    constructor() {\n        this.#handlers = [];\n    }\n    /**\n     * Returns _true_ if list is empty\n     * @returns\n     */\n    isEmpty() {\n        return this.#handlers.length === 0;\n    }\n    /**\n     * Adds a handler\n     * @param handler\n     * @param options\n     * @returns\n     */\n    add(handler, options = {}) {\n        this.#counter++;\n        const once = options.once ?? false;\n        const wrap = {\n            id: `${this.#id} - ${this.#counter}`,\n            handler,\n            once\n        };\n        this.#handlers.push(wrap);\n        return wrap.id;\n    }\n    remove(id) {\n        const length = this.#handlers.length;\n        this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n        return this.#handlers.length !== length;\n    }\n    notify(value) {\n        for (const handler of this.#handlers) {\n            handler.handler(value);\n            if (handler.once) {\n                this.remove(handler.id);\n            }\n        }\n    }\n    clear() {\n        this.#handlers = [];\n    }\n}\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = (nth, callback) => {\n    resultThrow(integerTest(nth, `positive`, `nth`));\n    let counter = 0;\n    return (data) => {\n        counter++;\n        if (counter === nth) {\n            counter = 0;\n            if (callback)\n                callback(data);\n            return true;\n        }\n        return false;\n    };\n};\n","import { defaultComparer } from '@ixfx/core';\nimport { shuffle } from '@ixfx/arrays';\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = runSingle([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async (expressions, opts = {}, args) => {\n    const results = [];\n    const compareFunction = opts.rank ?? defaultComparer;\n    let expressionsArray = Array.isArray(expressions)\n        ? (expressions)\n        : [expressions];\n    if (opts.shuffle)\n        expressionsArray = shuffle(expressionsArray);\n    for (let index = 0; index < expressionsArray.length; index++) {\n        const exp = expressionsArray[index];\n        let r;\n        if (typeof exp === 'function') {\n            // @ts-ignore\n            r = await exp(args);\n        }\n        else {\n            r = exp;\n        }\n        if (r !== undefined) {\n            results.push(r);\n            results.sort(compareFunction);\n        }\n        if (typeof opts.stop !== 'undefined') {\n            if (opts.stop(r, results)) {\n                break;\n            }\n        }\n    }\n    if (opts.filter) {\n        return results.filter(opts.filter);\n    }\n    return results;\n};\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async (expressions, opts = {}, args) => {\n    const results = await run(expressions, opts, args);\n    if (!results)\n        return;\n    if (results.length === 0)\n        return;\n    const at = opts.at ?? -1;\n    return results.at(at);\n};\n","import type { Interval } from \"@ixfx/core\";\nimport { timeout } from \"./timeout.js\";\n\nexport type RateMinimumOptions<TInput> = Readonly<{\n  whatToCall: (args: TInput) => void\n  fallback: () => TInput\n  interval: Interval\n  abort?: AbortSignal\n}>;\n\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n * \n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n * \n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n * \n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ``` \n * \n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n * \n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n * \n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n * \n * @param options \n * @returns \n */\nexport const rateMinimum = <TInput>(options: RateMinimumOptions<TInput>) => {\n  let disposed = false;\n\n  const t = timeout(() => {\n    if (disposed) return;\n    t.start();\n    options.whatToCall(options.fallback());\n  }, options.interval);\n\n\n  if (options.abort) {\n    options.abort.addEventListener(`abort`, _ => {\n      disposed = true;\n      t.cancel();\n    });\n  }\n  t.start();\n\n  return (args: TInput) => {\n    if (disposed) throw new Error(`AbortSignal has been fired`);\n    t.start();\n    options.whatToCall(args);\n  }\n}","import { movingAverageLight } from \"@ixfx/numbers\";\nimport { rateMinimum } from \"@ixfx/flow\";\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n *\n * mat(); // Get current average\n * ```\n *\n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n *\n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options) => {\n    const average = movingAverageLight();\n    const rm = rateMinimum({\n        ...options,\n        whatToCall: (distance) => {\n            average(distance);\n        },\n        fallback() {\n            return options.default ?? 0;\n        }\n    });\n    return (v) => {\n        rm(v);\n        return average();\n    };\n};\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as Debug from '@ixfx/debug';\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser extends SimpleEventEmitter {\n    key;\n    resource;\n    _lastUpdate;\n    _pool;\n    _state;\n    _userExpireAfterMs;\n    /**\n     * Constructor\n     * @param key User key\n     * @param resource Resource being used\n     */\n    //eslint-disable-next-line functional/prefer-immutable-types\n    constructor(key, resource) {\n        super();\n        this.key = key;\n        this.resource = resource;\n        this._lastUpdate = performance.now();\n        this._pool = resource.pool;\n        this._userExpireAfterMs = this._pool.userExpireAfterMs;\n        this._state = `idle`;\n        this._pool.log.log(`PoolUser ctor key: ${this.key}`);\n    }\n    /**\n     * Returns a human readable debug string\n     * @returns\n     */\n    toString() {\n        if (this.isDisposed)\n            return `PoolUser. State: disposed`;\n        return `PoolUser. State: ${this._state} Elapsed: ${performance.now() - this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`;\n    }\n    /**\n     * Resets countdown for instance expiry.\n     * Throws an error if instance is disposed.\n     */\n    keepAlive() {\n        if (this._state === `disposed`)\n            throw new Error(`PoolItem disposed`);\n        this._lastUpdate = performance.now();\n    }\n    /**\n     * @internal\n     * @param reason\n     * @returns\n     */\n    _dispose(reason, data) {\n        if (this._state === `disposed`)\n            return;\n        const resource = this.resource;\n        //const data = resource.data;\n        this._state = `disposed`;\n        resource._release(this);\n        this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${reason}`);\n        this.fireEvent(`disposed`, { data, reason });\n        super.clearEventListeners();\n    }\n    /**\n     * Release this instance\n     * @param reason\n     */\n    release(reason) {\n        if (this.isDisposed)\n            throw new Error(`User disposed`);\n        const resource = this.resource;\n        const data = resource.data;\n        this._pool.log.log(`PoolUser release key: ${this.key} reason: ${reason}`);\n        this.fireEvent(`released`, { data, reason });\n        this._dispose(`release-${reason}`, data);\n    }\n    // #region Properties\n    get data() {\n        if (this.isDisposed)\n            throw new Error(`User disposed`);\n        return this.resource.data;\n    }\n    /**\n     * Returns true if this instance has expired.\n     * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n     */\n    get isExpired() {\n        if (this._userExpireAfterMs > 0) {\n            return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n        }\n        return false;\n    }\n    /**\n     * Returns elapsed time since last 'update'\n     */\n    get elapsed() {\n        return performance.now() - this._lastUpdate;\n    }\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed() {\n        return this._state === `disposed`;\n    }\n    /**\n     * Returns true if instance is neither disposed nor expired\n     */\n    get isValid() {\n        if (this.isDisposed || this.isExpired)\n            return false;\n        if (this.resource.isDisposed)\n            return false;\n        return true;\n    }\n}\n/**\n * A resource allocated in the Pool\n */\nexport class Resource {\n    pool;\n    #state;\n    #data;\n    #users;\n    #capacityPerResource;\n    #resourcesWithoutUserExpireAfterMs;\n    #lastUsersChange;\n    /**\n     * Constructor.\n     * @param pool Pool\n     * @param data Data\n     */\n    constructor(pool, data) {\n        this.pool = pool;\n        if (data === undefined)\n            throw new Error(`Parameter 'data' is undefined`);\n        if (pool === undefined)\n            throw new Error(`Parameter 'pool' is undefined`);\n        this.#data = data;\n        this.#lastUsersChange = 0;\n        this.#resourcesWithoutUserExpireAfterMs =\n            pool.resourcesWithoutUserExpireAfterMs;\n        this.#capacityPerResource = pool.capacityPerResource;\n        this.#users = [];\n        this.#state = `idle`;\n    }\n    /**\n     * Gets data associated with resource.\n     * Throws an error if disposed\n     */\n    get data() {\n        if (this.#state === `disposed`)\n            throw new Error(`Resource disposed`);\n        return this.#data;\n    }\n    /**\n     * Changes the data associated with this resource.\n     * Throws an error if disposed or `data` is undefined.\n     * @param data\n     */\n    updateData(data) {\n        if (this.#state === `disposed`)\n            throw new Error(`Resource disposed`);\n        if (data === undefined)\n            throw new Error(`Parameter 'data' is undefined`);\n        this.#data = data;\n    }\n    /**\n     * Returns a human-readable debug string for resource\n     * @returns\n     */\n    toString() {\n        return `Resource (expired: ${this.isExpiredFromUsers} users: ${this.#users.length}, state: ${this.#state}) data: ${JSON.stringify(this.data)}`;\n    }\n    /**\n     * Assigns a user to this resource.\n     * @internal\n     * @param user\n     */\n    _assign(user) {\n        const existing = this.#users.find((u) => u === user || u.key === user.key);\n        if (existing)\n            throw new Error(`User instance already assigned to resource`);\n        this.#users.push(user);\n        this.#lastUsersChange = performance.now();\n    }\n    /**\n     * Releases a user from this resource\n     * @internal\n     * @param user\n     */\n    _release(user) {\n        this.#users = this.#users.filter((u) => u !== user);\n        this.pool._release(user);\n        this.#lastUsersChange = performance.now();\n    }\n    /**\n     * Returns true if resource can have additional users allocated\n     */\n    get hasUserCapacity() {\n        return this.usersCount < this.#capacityPerResource;\n    }\n    /**\n     * Returns number of uses of the resource\n     */\n    get usersCount() {\n        return this.#users.length;\n    }\n    /**\n     * Returns true if automatic expiry is enabled, and that interval\n     * has elapsed since the users list has changed for this resource\n     */\n    get isExpiredFromUsers() {\n        if (this.#resourcesWithoutUserExpireAfterMs <= 0)\n            return false;\n        if (this.#users.length > 0)\n            return false;\n        return (performance.now() >\n            this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange);\n    }\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed() {\n        return this.#state === `disposed`;\n    }\n    /**\n     * Disposes the resource.\n     * If it is already disposed, it does nothing.\n     * @param reason\n     * @returns\n     */\n    dispose(reason) {\n        if (this.#state === `disposed`)\n            return;\n        const data = this.#data;\n        this.#state = `disposed`;\n        this.pool.log.log(`Resource disposed (${reason})`);\n        for (const u of this.#users) {\n            u._dispose(`resource-${reason}`, data);\n        }\n        this.#users = [];\n        this.#lastUsersChange = performance.now();\n        this.pool._releaseResource(this, reason);\n        if (this.pool.freeResource)\n            this.pool.freeResource(data);\n    }\n}\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'.\n * All resources in the Pool are meant to be the same kind of object.\n *\n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n *\n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n *\n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport class Pool {\n    _resources;\n    _users;\n    capacity;\n    userExpireAfterMs;\n    resourcesWithoutUserExpireAfterMs;\n    capacityPerResource;\n    fullPolicy;\n    generateResource;\n    freeResource;\n    log;\n    /**\n     * Constructor.\n     *\n     * By default, no capacity limit, one user per resource\n     * @param options Pool options\n     */\n    constructor(options = {}) {\n        this.capacity = options.capacity ?? -1;\n        this.fullPolicy = options.fullPolicy ?? `error`;\n        this.capacityPerResource = options.capacityPerResource ?? 1;\n        this.userExpireAfterMs = options.userExpireAfterMs ?? -1;\n        this.resourcesWithoutUserExpireAfterMs =\n            options.resourcesWithoutUserExpireAfterMs ?? -1;\n        this.generateResource = options.generate;\n        this.freeResource = options.free;\n        this._users = new Map();\n        this._resources = [];\n        this.log = Debug.logSet(`Pool`, options.debug ?? false);\n        // If we have a time-based expiry, set an interval to\n        // automatically do the housekeeping\n        const timer = Math.max(this.userExpireAfterMs, this.resourcesWithoutUserExpireAfterMs);\n        if (timer > 0) {\n            setInterval(() => {\n                this.maintain();\n            }, timer * 1.1);\n        }\n    }\n    /**\n     * Returns a debug string of Pool state\n     * @returns\n     */\n    dumpToString() {\n        //eslint-disable-next-line functional/no-let\n        let r = `Pool\n    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}\n    resources count: ${this._resources.length}`;\n        const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n        r += `\\r\\nResources:\\r\\n\\t` + resource;\n        r += `\\r\\nUsers: \\r\\n`;\n        for (const [k, v] of this._users.entries()) {\n            r += `\\tk: ${k} v: ${v.toString()}\\r\\n`;\n        }\n        return r;\n    }\n    /**\n     * Sorts users by longest elapsed time since update\n     * @returns\n     */\n    getUsersByLongestElapsed() {\n        return [...this._users.values()].sort((a, b) => {\n            const aa = a.elapsed;\n            const bb = b.elapsed;\n            if (aa === bb)\n                return 0;\n            if (aa < bb)\n                return 1;\n            return -1;\n        });\n    }\n    /**\n     * Returns resources sorted with least used first\n     * @returns\n     */\n    getResourcesSortedByUse() {\n        return [...this._resources].sort((a, b) => {\n            if (a.usersCount === b.usersCount)\n                return 0;\n            if (a.usersCount < b.usersCount)\n                return -1;\n            return 1;\n        });\n    }\n    /**\n     * Adds a shared resource to the pool\n     * @throws Error if the capacity limit is reached or resource is null\n     * @param resource\n     * @returns\n     */\n    addResource(resource) {\n        if (resource === undefined) {\n            throw new Error(`Cannot add undefined resource`);\n        }\n        if (resource === null)\n            throw new TypeError(`Cannot add null resource`);\n        if (this.capacity > 0 && this._resources.length === this.capacity) {\n            throw new Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);\n        }\n        this.log.log(`Adding resource: ${JSON.stringify(resource)}`);\n        const pi = new Resource(this, resource);\n        this._resources.push(pi);\n        return pi;\n    }\n    /**\n     * Performs maintenance, removing disposed/expired resources & users.\n     * This is called automatically when using a resource.\n     */\n    maintain() {\n        //eslint-disable-next-line functional/no-let\n        let changed = false;\n        // Find all disposed resources\n        const nuke = [];\n        for (const p of this._resources) {\n            if (p.isDisposed) {\n                this.log.log(`Maintain, disposed resource: ${JSON.stringify(p.data)}`);\n                nuke.push(p);\n            }\n            else if (p.isExpiredFromUsers) {\n                this.log.log(`Maintain, expired resource: ${JSON.stringify(p.data)}`);\n                nuke.push(p);\n            }\n        }\n        // Remove them\n        if (nuke.length > 0) {\n            for (const resource of nuke) {\n                resource.dispose(`diposed/expired`);\n            }\n            changed = true;\n        }\n        // Find 'users' to clean up\n        const userKeysToRemove = [];\n        for (const [key, user] of this._users.entries()) {\n            if (!user.isValid) {\n                this.log.log(`Maintain. Invalid user: ${user.key} (Disposed: ${user.isDisposed} Expired: ${user.isExpired} Resource disposed: ${user.resource.isDisposed})`);\n                userKeysToRemove.push(key);\n                user._dispose(`invalid`, user.data);\n            }\n        }\n        for (const userKey of userKeysToRemove) {\n            this._users.delete(userKey);\n            changed = true;\n        }\n        if (changed) {\n            this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`);\n        }\n    }\n    /**\n     * Iterate over resources in the pool.\n     * To iterate over the data associated with each resource, use\n     * `values`.\n     */\n    *resources() {\n        const resource = [...this._resources];\n        for (const r of resource) {\n            yield r;\n        }\n    }\n    /**\n     * Iterate over resource values in the pool.\n     * to iterate over the resources, use `resources`.\n     *\n     * Note that values may be returned even though there is no\n     * active user.\n     */\n    *values() {\n        const resource = [...this._resources];\n        for (const r of resource) {\n            yield r.data;\n        }\n    }\n    /**\n     * Unassociate a key with a pool item\n     * @param userKey\n     */\n    release(userKey, reason) {\n        const pi = this._users.get(userKey);\n        if (!pi)\n            return;\n        pi.release(reason ?? `Pool.release`);\n    }\n    /**\n     * @internal\n     * @param user\n     */\n    //eslint-disable-next-line functional/prefer-immutable-types\n    _release(user) {\n        this._users.delete(user.key);\n    }\n    /**\n     * @internal\n     * @param resource\n     * @param _\n     */\n    //eslint-disable-next-line functional/prefer-immutable-types\n    _releaseResource(resource, _) {\n        this._resources = this._resources.filter((v) => v !== resource);\n    }\n    /**\n     * Returns true if `v` has an associted resource in the pool\n     * @param resource\n     * @returns\n     */\n    hasResource(resource) {\n        const found = this._resources.find((v) => v.data === resource);\n        return found !== undefined;\n    }\n    /**\n     * Returns true if a given `userKey` is in use.\n     * @param userKey\n     * @returns\n     */\n    hasUser(userKey) {\n        return this._users.has(userKey);\n    }\n    /**\n     * @internal\n     * @param key\n     * @param resource\n     * @returns\n     */\n    //eslint-disable-next-line functional/prefer-immutable-types\n    _assign(key, resource) {\n        const u = new PoolUser(key, resource);\n        this._users.set(key, u);\n        resource._assign(u);\n        return u;\n    }\n    /**\n     * Allocates a resource for `userKey`\n     * @internal\n     * @param userKey\n     * @returns\n     */\n    #allocateResource(userKey) {\n        // Sort items by number of users per pool item\n        const sorted = this.getResourcesSortedByUse();\n        //eslint-disable-next-line functional/no-let\n        // for (let i=0;i<sorted.length;i++) {\n        //   console.log(i +`. users: ` + sorted[i].usersCount);\n        // }\n        if (sorted.length > 0 && sorted[0].hasUserCapacity) {\n            // No problem, resource has capacity\n            //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n            const u = this._assign(userKey, sorted[0]);\n            return u;\n        }\n        // If resource count is below capacity, can we generate more?\n        if (this.generateResource &&\n            (this.capacity < 0 || this._resources.length < this.capacity)) {\n            this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);\n            const resourceGenerated = this.addResource(this.generateResource());\n            const u = this._assign(userKey, resourceGenerated);\n            return u;\n        }\n    }\n    /**\n     * Return the number of users\n     */\n    get usersLength() {\n        return [...this._users.values()].length;\n    }\n    /**\n     * 'Uses' a resource, returning the value\n     * @param userKey\n     * @returns\n     */\n    useValue(userKey) {\n        const resource = this.use(userKey);\n        return resource.resource.data;\n    }\n    /**\n     * Gets a pool item based on a 'user' key.\n     *\n     * The same key should return the same pool item,\n     * for as long as it still exists.\n     *\n     * If a 'user' already has a resource, it will 'keep alive' their use.\n     * If a 'user' does not already have resource\n     *  - if there is capacity, a resource is allocated to user\n     *  - if pool is full\n     *    - fullPolicy = 'error': an error is thrown\n     *    - fullPolicy = 'evictOldestUser': evicts an older user\n     *    - Throw error\n     * @param userKey\n     * @throws Error If all resources are used and fullPolicy = 'error'\n     * @returns\n     */\n    use(userKey) {\n        const pi = this._users.get(userKey);\n        if (pi) {\n            pi.keepAlive();\n            return pi;\n        }\n        this.maintain();\n        const match = this.#allocateResource(userKey);\n        if (match)\n            return match;\n        // Throw an error if all items are being used\n        if (this.fullPolicy === `error`) {\n            //console.log(this.dumpToString());\n            throw new Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);\n        }\n        // Evict oldest user\n        if (this.fullPolicy === `evictOldestUser`) {\n            const users = this.getUsersByLongestElapsed();\n            if (users.length > 0) {\n                this.release(users[0].key, `evictedOldestUser`);\n                const match2 = this.#allocateResource(userKey);\n                if (match2)\n                    return match2;\n            }\n        }\n        // Evict newest user\n        // Evict from random pool item\n        throw new Error(`Pool is fully used (${this.fullPolicy})`);\n    }\n}\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport const create = (options = {}) => new Pool(options);\n","export function promiseWithResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: resolve, reject: reject };\n}\n","import { integerTest, resultToError, resultIsError, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n *\n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (callback, interval) => {\n    if (callback === undefined) {\n        throw new Error(`callback parameter is undefined`);\n    }\n    const intervalMs = intervalToMs(interval);\n    resultThrow(integerTest(intervalMs, `aboveZero`, `interval`));\n    let timer;\n    let startedAt = 0;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let state = `idle`;\n    const clear = () => {\n        startedAt = 0;\n        globalThis.clearTimeout(timer);\n        state = `idle`;\n    };\n    const start = async (altInterval = interval, args) => {\n        const p = new Promise((resolve, reject) => {\n            startedAt = performance.now();\n            const altTimeoutMs = intervalToMs(altInterval);\n            const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n            if (resultIsError(it)) {\n                reject(resultToError(it));\n                return;\n            }\n            switch (state) {\n                case `scheduled`: {\n                    // Cancel other scheduled execution\n                    cancel();\n                    break;\n                }\n                case `running`: {\n                    //console.warn(`Timeout being rescheduled while task is already running`);\n                    break;\n                }\n            }\n            state = `scheduled`;\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            timer = globalThis.setTimeout(async () => {\n                if (state !== `scheduled`) {\n                    console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n                    clear();\n                    return;\n                }\n                const args_ = args ?? [];\n                startCount++;\n                startCountTotal++;\n                state = `running`;\n                await callback(performance.now() - startedAt, ...args_);\n                state = `idle`;\n                clear();\n                resolve();\n            }, altTimeoutMs);\n        });\n        return p;\n    };\n    const cancel = () => {\n        if (state === `idle`)\n            return;\n        clear();\n    };\n    return {\n        start,\n        cancel,\n        get runState() {\n            return state;\n        },\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        }\n    };\n};\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });\n","import { timeout } from \"./timeout.js\";\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n *\n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n *\n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n *\n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ```\n *\n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n *\n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n *\n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n *\n * @param options\n * @returns\n */\nexport const rateMinimum = (options) => {\n    let disposed = false;\n    const t = timeout(() => {\n        if (disposed)\n            return;\n        t.start();\n        options.whatToCall(options.fallback());\n    }, options.interval);\n    if (options.abort) {\n        options.abort.addEventListener(`abort`, _ => {\n            disposed = true;\n            t.cancel();\n        });\n    }\n    t.start();\n    return (args) => {\n        if (disposed)\n            throw new Error(`AbortSignal has been fired`);\n        t.start();\n        options.whatToCall(args);\n    };\n};\n","import { resolve, resolveSync } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat(produce, opts) {\n    const signal = opts.signal ?? undefined;\n    const delayWhen = opts.delayWhen ?? `before`;\n    const count = opts.count ?? undefined;\n    const allowUndefined = opts.allowUndefined ?? false;\n    const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n    const whileFunction = opts.while;\n    let cancelled = false;\n    let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n    let started = performance.now();\n    const doDelay = async () => {\n        const elapsed = performance.now() - started;\n        if (typeof minIntervalMs !== `undefined`) {\n            sleepMs = Math.max(0, minIntervalMs - elapsed);\n        }\n        if (sleepMs) {\n            await sleep({ millis: sleepMs, signal });\n        }\n        started = performance.now();\n        if (signal?.aborted)\n            throw new Error(`Signal aborted ${signal.reason}`);\n    };\n    if (Array.isArray(produce))\n        produce = produce.values();\n    if (opts.onStart)\n        opts.onStart();\n    let errored = true;\n    let loopedTimes = 0;\n    try {\n        while (!cancelled) {\n            loopedTimes++;\n            if (delayWhen === `before` || delayWhen === `both`)\n                await doDelay();\n            const result = await resolve(produce);\n            if (typeof result === `undefined` && !allowUndefined) {\n                cancelled = true;\n            }\n            else {\n                yield result;\n                if (delayWhen === `after` || delayWhen === `both`)\n                    await doDelay();\n                if (count !== undefined && loopedTimes >= count)\n                    cancelled = true;\n            }\n            if (whileFunction) {\n                if (!whileFunction(loopedTimes)) {\n                    cancelled = true;\n                }\n            }\n        }\n        errored = false;\n    }\n    finally {\n        cancelled = true;\n        if (opts.onComplete)\n            opts.onComplete(errored);\n    }\n}\n;\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync(produce, opts) {\n    const signal = opts.signal ?? undefined;\n    const count = opts.count ?? undefined;\n    const allowUndefined = opts.allowUndefined ?? false;\n    let cancelled = false;\n    if (Array.isArray(produce))\n        produce = produce.values();\n    if (opts.onStart)\n        opts.onStart();\n    let errored = true;\n    let loopedTimes = 0;\n    try {\n        while (!cancelled) {\n            loopedTimes++;\n            const result = resolveSync(produce);\n            if (typeof result === `undefined` && !allowUndefined) {\n                cancelled = true;\n            }\n            else {\n                yield result;\n                if (count !== undefined && loopedTimes >= count)\n                    cancelled = true;\n                if (signal?.aborted)\n                    cancelled = true;\n            }\n        }\n        errored = false;\n    }\n    finally {\n        cancelled = true;\n        if (opts.onComplete)\n            opts.onComplete(errored);\n    }\n}\n;\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { continuously } from \"@ixfx/core\";\nimport { SimpleEventEmitter } from \"@ixfx/events\";\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n *\n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n *\n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n *\n *\n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id;\n *  }\n * });\n * ```\n *\n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id;\n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n *\n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport class RequestResponseMatch extends SimpleEventEmitter {\n    timeoutMs;\n    whenUnmatchedResponse;\n    keyRequest;\n    keyResponse;\n    #outgoing = new Map();\n    #maintainLoop;\n    constructor(options = {}) {\n        super();\n        if (typeof window === `undefined`) {\n            globalThis.window = {\n                setTimeout: setTimeout,\n                clearTimeout: clearTimeout\n            };\n        }\n        this.timeoutMs = options.timeoutMs ?? 1000;\n        this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;\n        this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);\n        if (options.key) {\n            if (options.keyRequest)\n                throw new Error(`Cannot set 'keyRequest' when 'key' is set `);\n            if (options.keyResponse)\n                throw new Error(`Cannot set 'keyResponse' when 'key' is set `);\n            this.keyRequest = options.key;\n            this.keyResponse = options.key;\n        }\n        else {\n            if (!options.keyRequest || !options.keyResponse) {\n                throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);\n            }\n            this.keyRequest = options.keyRequest;\n            this.keyResponse = options.keyResponse;\n        }\n    }\n    #maintain() {\n        const values = [...this.#outgoing.values()];\n        const now = Date.now();\n        for (const v of values) {\n            if (v.expiresAt <= now) {\n                if (v.promiseReject) {\n                    v.promiseReject(`Request timeout`);\n                }\n                const callback = v.callback;\n                if (callback) {\n                    setTimeout(() => {\n                        callback(true, `Request timeout`);\n                    }, 1);\n                }\n                this.fireEvent(`completed`, { request: v.req, response: `Request timeout`, success: false });\n                this.#outgoing.delete(v.id);\n            }\n        }\n        this.debugDump();\n        return this.#outgoing.size > 0;\n    }\n    debugDump() {\n        const values = [...this.#outgoing.values()];\n        const now = Date.now();\n        for (const v of values) {\n            const expire = now - v.expiresAt;\n            console.log(`${v.id} Expires in: ${Math.floor(expire / 1000).toString()}s`);\n        }\n    }\n    /**\n     * Makes a request.\n     * If `callback` is set, it's equivalent to calling `requestCallback`.\n     * If `callback` is not set, a promise is returned\n     * @param request\n     * @param callback\n     * @returns\n     */\n    request(request, callback) {\n        if (callback !== undefined) {\n            this.#requestCallback(request, callback);\n            return;\n        }\n        return this.#requestAwait(request);\n    }\n    /**\n     * Make a request and don't wait for the outcome.\n     * @param request\n     */\n    requestAndForget(request) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const r = {\n            expiresAt: Date.now() + this.timeoutMs,\n            id,\n            req: request\n        };\n        this.#outgoing.set(id, r);\n        this.#maintainLoop.start();\n    }\n    /**\n     * Make a request, returning a Promise for the outcome.\n     * Errors will throw an exception.\n     * @param request\n     * @returns\n     */\n    #requestAwait(request) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const p = new Promise((resolve, reject) => {\n            const r = {\n                expiresAt: Date.now() + this.timeoutMs,\n                id,\n                req: request,\n                promiseResolve: resolve,\n                promiseReject: reject\n            };\n            this.#outgoing.set(id, r);\n            this.#maintainLoop.start();\n        });\n        return p;\n    }\n    /**\n     * Make a request, and get notified of outcome with a callback\n     * @param request\n     * @param callback\n     */\n    #requestCallback(request, callback) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const r = {\n            expiresAt: Date.now() + this.timeoutMs,\n            id,\n            req: request,\n            callback\n        };\n        this.#outgoing.set(id, r);\n        this.#maintainLoop.start();\n    }\n    /**\n     * Response has been received\n     * @param response Response\n     * @returns _True_ if response matched a request\n     */\n    response(response, keepAlive) {\n        const id = this.keyResponse(response);\n        const request = this.#outgoing.get(id);\n        if (!request) {\n            if (this.whenUnmatchedResponse === `throw`)\n                throw new Error(`Unmatched response with id: '${id}'`, { cause: response });\n            // otherwise ignore\n            return false;\n        }\n        if (keepAlive) {\n            // Continue life of request\n            request.expiresAt = Date.now() + this.timeoutMs;\n        }\n        else {\n            this.#outgoing.delete(id);\n        }\n        if (request.promiseResolve) {\n            request.promiseResolve(response);\n        }\n        if (request.callback) {\n            request.callback(false, response);\n        }\n        this.fireEvent(`match`, { request: request.req, response: response });\n        if (!keepAlive) {\n            this.fireEvent(`completed`, { request: request.req, response: response, success: true });\n        }\n        return true;\n    }\n}\n","import { elapsedSince, sleep } from '@ixfx/core';\nimport { resolveLogOption } from '@ixfx/debug';\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { getErrorMessage } from '@ixfx/debug';\nimport { elapsedToHumanString } from '@ixfx/core';\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n *\n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n *\n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n *\n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n *\n * @param options\n * @returns\n */\nexport function* backoffGenerator(options = {}) {\n    const startAt = options.startAt ?? 1;\n    let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n    const limitValue = options.limitValue;\n    const power = options.power ?? 1.1;\n    let value = startAt;\n    resultThrow(integerTest(limitAttempts, `aboveZero`, `limitAttempts`), numberTest(startAt, ``, `startAt`), numberTest(limitAttempts, ``, `limitAttempts`), () => (limitValue !== undefined) ? numberTest(limitValue, ``, `limitValue`) : undefined, numberTest(power, ``, `power`));\n    while (limitAttempts > 0) {\n        // Value has climbed to the limit\n        if (limitValue && value >= limitValue)\n            return;\n        limitAttempts--;\n        yield value;\n        // Increase value for next iteration\n        value += Math.pow(value, power);\n    }\n}\n/**\n * Keeps calling `callback` until it returns something other than _undefined_.\n * There is an exponentially-increasing delay between each retry attempt.\n *\n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport const retryFunction = (callback, options = {}) => {\n    const task = {\n        async probe() {\n            try {\n                const v = await callback();\n                if (v === undefined)\n                    return { value: options.taskValueFallback, error: `Fallback`, success: false };\n                return { value: v, success: true };\n            }\n            catch (error) {\n                return { success: false, error: error };\n            }\n        },\n    };\n    return retryTask(task, options);\n};\n/**\n * Keeps trying to run `task`.\n *\n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *\n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n *\n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task\n * @param opts\n * @returns\n */\nexport const retryTask = async (task, opts = {}) => {\n    const signal = opts.abort;\n    const log = resolveLogOption(opts.log);\n    const predelayMs = opts.predelayMs ?? 0;\n    const startedAt = elapsedSince();\n    let attempts = 0;\n    const initialValue = opts.startAt ?? 1000;\n    const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n    const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n    if (initialValue <= 0)\n        throw new Error(`Param 'initialValue' must be above zero`);\n    if (predelayMs > 0) {\n        try {\n            await sleep({ millis: predelayMs, signal: signal });\n        }\n        catch (error) {\n            // Could happen due to abort signal\n            return {\n                success: false,\n                attempts,\n                value: opts.taskValueFallback,\n                elapsed: startedAt(),\n                message: getErrorMessage(error),\n            };\n        }\n    }\n    for (const t of backoffGen) {\n        attempts++;\n        // Run task\n        const result = await task.probe(attempts);\n        if (result.success) {\n            return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n        }\n        log({\n            msg: `retry attempts: ${attempts.toString()} t: ${elapsedToHumanString(t)}`,\n        });\n        // Did not succeed.\n        if (attempts >= limitAttempts) {\n            break; // Out of attempts, no point sleeping again\n        }\n        // Sleep\n        try {\n            await sleep({ millis: t, signal });\n        }\n        catch (error) {\n            // Eg if abort signal fires\n            return {\n                success: false,\n                attempts,\n                value: opts.taskValueFallback,\n                message: getErrorMessage(error),\n                elapsed: startedAt(),\n            };\n        }\n    }\n    return {\n        message: `Giving up after ${attempts.toString()} attempts.`,\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n    };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun) => {\n    let run = false;\n    let success = false;\n    return () => {\n        if (run)\n            return success;\n        run = true;\n        success = onRun();\n        return success;\n    };\n};\n","/**\n * Simple synchronisation. Supports only a single signal/waiter.\n * Expects one or more calls to .signal() for .forSignal() to resolve\n *\n * ```js\n * const sw = new SyncWait();\n * obj.addEventListener(`click`, () => {\n *  sw.signal();\n * });\n *\n * // Wait until click event\n * await sw.forSignal();\n * ```\n *\n * `forSignal` can also take a maximum time to wait. If the\n * time elapses, an exception is thrown.\n *\n * {@link didSignal} returns _true_/_false_ if signal happened rather\n * than throwing an exception.\n *\n */\nexport class SyncWait {\n    #resolve;\n    #reject;\n    #promise;\n    signal() {\n        if (this.#resolve) {\n            this.#resolve();\n            this.#resolve = undefined;\n        }\n        this.#promise = Promise.resolve();\n    }\n    /**\n     * Throw away any previous signalled state.\n     * This will cause any currently waiters to throw\n     */\n    flush() {\n        if (this.#reject) {\n            this.#reject(`Flushed`);\n            this.#reject = undefined;\n        }\n        this.#resolve = undefined;\n        this.#promise = undefined;\n    }\n    #initPromise() {\n        const p = new Promise((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n        this.#promise = p;\n        return p;\n    }\n    /**\n     * Call with `await` to wait until .signal() happens.\n     * If a wait period is specified, an exception is thrown if signal does not happen within this time.\n     * @param maximumWaitMs\n     */\n    async forSignal(maximumWaitMs) {\n        let p = this.#promise;\n        p ??= this.#initPromise();\n        if (maximumWaitMs) {\n            const reject = this.#reject;\n            setTimeout(() => {\n                if (reject) {\n                    reject(`Timeout elapsed ${maximumWaitMs.toString()}`);\n                }\n            }, maximumWaitMs);\n        }\n        await p;\n        this.#promise = undefined;\n        this.#resolve = undefined;\n        this.#reject = undefined;\n    }\n    /**\n     * An alternative to {@link forSignal}, returning _true_\n     * if signalled, or _false_ if wait period was exceeded\n     *\n     * ```js\n     * const s = await sw.didSignal(5000);\n     * ```\n     * @param maximumWaitMs\n     * @returns\n     */\n    async didSignal(maximumWaitMs) {\n        try {\n            await this.forSignal(maximumWaitMs);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { Queues } from '@ixfx/collections';\nimport { continuously } from '@ixfx/core';\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n *\n * The TaskQueueMutable is shared across your code,\n * so you don't create it directly. Rather, use:\n *\n * ```js\n * import { TaskQueueMutable } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const queue = TaskQueueMutable.shared;\n * ```\n *\n * @example Usage\n * ```js\n * import { TaskQueueMutable, sleep } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const queue = TaskQueueMutable.shared;\n * q.enqueue(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n *\n * You can listen to events from the TaskQueue:\n * ```js\n * TaskQueueMutable.shared.addEventListener(`started`, () => {\n *  // Queue was empty, now started processing\n * });\n *\n * TaskQueueMutable.shared.addEventListener(`empty`, () => {\n *  // Queue has finished processing all items\n * });\n * ```\n */\nexport class TaskQueueMutable extends SimpleEventEmitter {\n    static shared = new TaskQueueMutable();\n    _loop;\n    _queue;\n    constructor() {\n        super();\n        this._queue = Queues.mutable();\n        this._loop = continuously(() => {\n            return this.processQueue();\n        }, 100);\n    }\n    /**\n     * Adds a task. This triggers processing loop if not already started.\n     *\n     * ```js\n     * queue.add(async () => {\n     *  await sleep(1000);\n     * });\n     * ```\n     * @param task Task to run\n     */\n    enqueue(task) {\n        const length = this._queue.enqueue(task);\n        if (this._loop.runState === `idle`) {\n            this.fireEvent(`started`, {});\n            this._loop.start();\n        }\n        return length;\n    }\n    dequeue() {\n        return this._queue.dequeue();\n    }\n    async processQueue() {\n        const task = this._queue.dequeue();\n        if (task === undefined) {\n            this.fireEvent(`empty`, {});\n            return false;\n        }\n        try {\n            await task();\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }\n    /**\n     * Clears all tasks, and stops any scheduled processing.\n     * Currently running tasks will continue.\n     * @returns\n     */\n    clear() {\n        if (this._queue.length === 0)\n            return;\n        this._queue.clear();\n        this._loop.cancel();\n        this.fireEvent(`empty`, {});\n    }\n    /**\n    * Returns true if queue is empty\n    */\n    get isEmpty() {\n        return this._queue.isEmpty;\n    }\n    /**\n     * Number of items in queue\n     */\n    get length() {\n        return this._queue.length;\n    }\n}\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (callback, intervalMinMs) => {\n    let trigger = 0;\n    return async (...args) => {\n        const elapsed = performance.now() - trigger;\n        if (elapsed >= intervalMinMs) {\n            const r = callback(elapsed, ...args);\n            if (typeof r === `object`)\n                await r;\n            trigger = performance.now();\n        }\n    };\n};\n","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * import { hasElapsed } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const oneSecond = hasElapsed(1000);\n *\n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n *\n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed) {\n    const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n    return () => t.isDone;\n}\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotal(1000);\n *\n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n *\n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(duration, opts = {}) {\n    const totalMs = intervalToMs(duration);\n    if (!totalMs)\n        throw new Error(`Param 'duration' not valid`);\n    const timerOpts = {\n        ...opts,\n        timer: elapsedMillisecondsAbsolute(),\n    };\n    let t;\n    return () => {\n        t ??= relative(totalMs, timerOpts);\n        return t.elapsed;\n    };\n}\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks, opts = {}) {\n    const timerOpts = {\n        ...opts,\n        timer: elapsedTicksAbsolute(),\n    };\n    let t;\n    return () => {\n        t ??= relative(totalTicks, timerOpts);\n        return t.elapsed;\n    };\n}\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns\n */\nexport const timerAlwaysDone = () => ({\n    elapsed: 1,\n    isDone: true,\n    reset() {\n    },\n    mod(amt) {\n    },\n});\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns\n */\nexport const timerNeverDone = () => ({\n    elapsed: 0,\n    isDone: false,\n    reset() {\n    },\n    mod() {\n    }\n});\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n *\n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n *\n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n *\n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (total, options = {}) => {\n    if (!Number.isFinite(total)) {\n        return timerAlwaysDone();\n    }\n    else if (Number.isNaN(total)) {\n        return timerNeverDone();\n    }\n    const clampValue = options.clampValue ?? false;\n    const wrapValue = options.wrapValue ?? false;\n    if (clampValue && wrapValue)\n        throw new Error(`clampValue and wrapValue cannot both be enabled`);\n    let modulationAmount = 1;\n    // Create and starts timer\n    const timer = options.timer ?? elapsedMillisecondsAbsolute();\n    // Keep track of value to avoid over-advancing the tick counter\n    let lastValue = 0;\n    const computeElapsed = (value) => {\n        lastValue = value;\n        let v = value / (total * modulationAmount);\n        if (clampValue)\n            v = clamp(v);\n        else if (wrapValue && v >= 1)\n            v = v % 1;\n        return v;\n    };\n    return {\n        mod(amt) {\n            modulationAmount = amt;\n        },\n        get isDone() {\n            //const tmp = computeElapsed();\n            //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n            return computeElapsed(lastValue) >= 1;\n        },\n        get elapsed() {\n            return computeElapsed(timer.elapsed);\n        },\n        reset: () => {\n            timer.reset();\n        }\n    };\n};\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (frequency, options = {}) => {\n    const timer = options.timer ?? elapsedMillisecondsAbsolute();\n    const cyclesPerSecond = frequency / 1000;\n    let modulationAmount = 1;\n    const computeElapsed = () => {\n        // Get position in a cycle\n        const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n        // Get fractional part\n        const f = v - Math.floor(v);\n        if (f < 0) {\n            throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v} f: ${f}`);\n        }\n        if (f > 1) {\n            throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v} f: ${f}`);\n        }\n        return f;\n    };\n    return {\n        mod: (amt) => {\n            modulationAmount = amt;\n        },\n        reset: () => {\n            timer.reset();\n        },\n        get isDone() {\n            return computeElapsed() >= 1;\n        },\n        get elapsed() {\n            return computeElapsed();\n        },\n    };\n};\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = () => {\n    let start = performance.now();\n    return {\n        /**\n         * Reset timer\n         */\n        reset: () => {\n            start = performance.now();\n        },\n        /**\n         * Returns elapsed time since start\n         */\n        get elapsed() {\n            return performance.now() - start;\n        }\n    };\n};\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n *\n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = () => {\n    let start = 0;\n    return {\n        /**\n         * Reset ticks to 0. The next call to `elapsed` will return 1.\n         */\n        reset: () => {\n            start = 0;\n        },\n        /**\n         * Get current ticks without incrementing.\n         */\n        get peek() {\n            return start;\n        },\n        /**\n         * Returns the number of elapsed ticks as well as\n         * incrementing the tick count.\n         *\n         * Minimum is 1\n         *\n         * Use {@link peek} to get the current ticks without incrementing.\n         */\n        get elapsed() {\n            return ++start;\n        }\n    };\n};\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n *\n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n *\n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n *\n * @param fn\n * @param timer\n * @returns\n */\nexport const timerWithFunction = (fn, timer) => {\n    if (typeof fn !== `function`)\n        throw new Error(`Param 'fn' should be a function. Got: ${typeof fn}`);\n    let startCount = 1;\n    return {\n        get elapsed() {\n            return timer.elapsed;\n        },\n        get isDone() {\n            return timer.isDone;\n        },\n        get runState() {\n            if (timer.isDone)\n                return `idle`;\n            return `scheduled`;\n        },\n        /**\n         * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n         */\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCount;\n        },\n        compute: () => {\n            const elapsed = timer.elapsed;\n            return fn(elapsed);\n        },\n        reset: () => {\n            timer.reset();\n            startCount++;\n        },\n    };\n};\n","import { intervalToMs } from \"@ixfx/core\";\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `interval` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. Its minimum value will be `interval`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `interval` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param interval Maximum age of cached result\n * @param updateFail `slow` by default\n * @typeParam V - Return type of `fn`\n * @returns Value\n */\nexport const updateOutdated = (fn, interval, updateFail = `slow`) => {\n    let lastRun = 0;\n    let lastValue;\n    let intervalMsCurrent = intervalToMs(interval, 1000);\n    return () => \n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    new Promise(async (resolve, reject) => {\n        const elapsed = performance.now() - lastRun;\n        if (lastValue === undefined || elapsed > intervalMsCurrent) {\n            try {\n                lastRun = performance.now();\n                lastValue = await fn(elapsed);\n                intervalMsCurrent = intervalToMs(interval, 1000);\n            }\n            catch (error) {\n                if (updateFail === `fast`) {\n                    lastValue = undefined;\n                    lastRun = 0;\n                }\n                else if (updateFail === `backoff`) {\n                    intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n                }\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(error);\n                return;\n            }\n        }\n        resolve(lastValue);\n    });\n};\n","import { promiseWithResolvers } from \"./promise-with-resolvers.js\";\n/**\n * Queue of a single item, only once.\n *\n * Allows for simple synchronisation.\n * ```js\n * const q = Flow.waitForValue();\n *\n * // In some part of the code add a value\n * const value = q.add();\n *\n * // Somewhere else, wait for value\n * await q.get(value);\n * ```\n *\n * It is not possible to `add` a second item, however\n * it is possible to call `get` as many times as you need.\n *\n * The `.isUsed` property allows you to to check if a value\n * has been already added to the queue.\n *\n * Based on: https://2ality.com/2024/05/proposal-promise-with-resolvers.html\n */\nexport class WaitForValue {\n    #promise;\n    #resolve;\n    #written = false;\n    constructor() {\n        const { promise, resolve } = promiseWithResolvers();\n        this.#promise = promise;\n        this.#resolve = resolve;\n    }\n    get() {\n        return this.#promise;\n    }\n    add(value) {\n        if (this.#written)\n            throw new Error(`QueueSingleUse has already been used`);\n        this.#written = true;\n        this.#resolve(value);\n    }\n    /**\n     * Returns _true_ if a value has been added\n     * and therefore no more values can be written\n     */\n    get isUsed() {\n        return this.#written;\n    }\n}\nexport const singleItem = () => new WaitForValue();\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n *\n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n *\n * ```js\n * waitFor(1000,\n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n *\n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n *\n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n *\n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (timeoutMs, onAborted, onComplete) => {\n    let t;\n    let success = false;\n    const done = (error) => {\n        if (t !== undefined) {\n            window.clearTimeout(t);\n            t = undefined;\n        }\n        if (error) {\n            onAborted(error);\n        }\n        else {\n            success = true;\n        }\n        if (onComplete !== undefined)\n            onComplete(success);\n    };\n    t = globalThis.setTimeout(() => {\n        t = undefined;\n        try {\n            onAborted(`Timeout after ${timeoutMs}ms`);\n        }\n        finally {\n            if (onComplete !== undefined)\n                onComplete(success);\n        }\n    }, timeoutMs);\n    return done;\n};\n","export * from '@ixfx/flow';"],"mappings":"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"}