{"version":3,"file":"with-events-BvXAGayK.js","names":["m: V","opts: StateMachineWithEventsOptions<V>","#debug","#sm","#smInitial","v: boolean","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt","newState: StateNames<V>"],"sources":["../../../ixfx/packages/flow/src/state-machine/with-events.ts"],"sourcesContent":["import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport type { StateNames, Transitions, MachineState } from './types.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type StateMachineWithEventsOptions<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\n/**\n * A state machine that fires events when state changes.\n * \n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = elapsedInfinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param m Machine description\n   * @param opts Options for machine (defaults to `{debug:false}`)\n   */\n  constructor(m: V, opts: StateMachineWithEventsOptions<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): readonly (StateNames<V> | null)[] {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): readonly StateNames<V>[] {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[ 0 ]!;\n    return p[ 0 ]!;\n  }\n\n  /**\n   * Returns _true_ if state machine is in its final state\n   *\n   * @returns\n   */\n  get isDone(): boolean {\n    return StateMachine.isDone(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n    this.#changedAt = elapsedSince();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `isValid()` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${ priorState } -> ${ newState }`);\n    }\n    this.#changedAt = elapsedSince();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.isDone(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAsCA,IAAa,yBAAb,cAEU,mBAA4C;CACpD;CACA;CAEA;CACA,qBAAqB;CACrB,UAAU;CACV,aAAa,iBAAiB;;;;;;CAO9B,YAAYA,GAAMC,OAAyC,CAAE,GAAE;AAC7D,SAAO;AAEP,OAAKC,SAAS,KAAK,SAAS;AAC5B,OAAKC,MAAM,KAAkB,GAAG,KAAK,QAAQ;AAC7C,OAAKC,aAAa,WAAwB,KAAKD,IAAI;CACpD;CAID,WAAWE,GAAY;AACrB,MAAI,KAAKC,YAAY,EAAG;AACxB,OAAKA,UAAU;AACf,MAAI,GAAG;AACL,QAAKC,qBAAqB;AAC1B,cAAW,MAAM;AACf,SAAK,KAAKA,mBAAoB;AAC9B,SAAKA,qBAAqB;AAE1B,SAAK,WAAW,OAAO,EAAE,OAAO,KAAKJ,IAAI,MAAO,EAAC;GAClD,GAAE,EAAE;EACN,MACC,MAAKI,qBAAqB;CAE7B;;;;;;;CAQD,IAAI,iBAAoD;AACtD,SAAO,SAAsB,KAAKJ,IAAI;CACvC;;;;CAKD,IAAI,gBAA0C;AAC5C,SAAO,OAAO,KAAK,KAAKA,IAAI,QAAQ;CACrC;;;;;;;CAQD,OAAsB;EACpB,MAAM,IAAI,SAAsB,KAAKA,IAAI;AACzC,MAAI,EAAE,WAAW,EAAG,QAAO;AAC3B,OAAK,QAAQ,EAAG;AAChB,SAAO,EAAG;CACX;;;;;;CAOD,IAAI,SAAkB;AACpB,SAAO,OAAoB,KAAKA,IAAI;CACrC;;;;CAKD,QAAQ;AACN,OAAKK,WAAW,MAAM;AACtB,OAAKL,MAAM,WAAwB,KAAKC,WAAW;AACnD,OAAKK,aAAa,cAAc;CACjC;;;;;;CAOD,mBAAmBC,UAA+B;AAChD,qBAAgC,KAAKP,KAAK,SAAS;CACpD;;;;;;;CAQD,QAAQO,UAAkC;AACxC,SAAO,kBAA+B,KAAKP,KAAK,SAAS;CAC1D;;;;;;;CAQD,IAAI,MAAMO,UAAyB;EACjC,MAAM,aAAa,KAAKP,IAAI;AAC5B,MAAI,aAAa,KAAKA,IAAI,MAAO;AAGjC,OAAKA,MAAM,GAAgB,KAAKA,KAAK,SAAS;AAC9C,MAAI,KAAKD,OACP,SAAQ,KAAK,gBAAiB,WAAY,MAAO,SAAU,EAAE;AAE/D,OAAKO,aAAa,cAAc;AAChC,aAAW,MAAM;AACf,QAAK,WAAW,SAAS;IAAY;IAAsB;GAAY,EAAC;EACzE,GAAE,EAAE;AAEL,MAAI,OAAoB,KAAKN,IAAI,CAAE,MAAKK,WAAW,KAAK;CACzD;CAED,IAAI,QAAgB;AAClB,SAAO,KAAKL,IAAI;CACjB;;;;;CAMD,IAAI,YAAoB;AACtB,SAAO,KAAKM,YAAY;CACzB;;;;;CAMD,IAAI,UAAkB;AACpB,SAAO,KAAKA,YAAY;CACzB;AACF"}