{"version":3,"file":"io-C01q53eY.js","names":["target: EventTarget","eventNames: Array<string>","options: Partial<{ timeoutMs: number, signal: AbortSignal }>","timeout: ReturnType<typeof setTimeout> | undefined","event: Event","lengthOrOptions: number | StringOptions","options: Partial<BackoffOptions>","callback: () => Promise<T | undefined>","options: Partial<RetryOpts<T>>","task: RetryTask<T>","task: RetryTask<V>","opts: Partial<RetryOpts<V>>","timeoutMs: number","onAborted: (reason: string) => void","onComplete?: (success: boolean) => void","t: ReturnType<typeof globalThis.setTimeout> | undefined","error?: string","reason: TrimReason","values: TimestampedPrimitive<number>[]","r: NumberTrackerResults","opts: TrackedValueOpts","#initInProgress","#isPaused","#initialised","#sources","error","SerialDevice","NordicDefaults","start","startWithVideoEl","sourceVideoEl: HTMLVideoElement","opts: ManualCaptureOpts","c: CanvasRenderingContext2D | undefined | null","c","c: ManualCapturer"],"sources":["../../../ixfx/packages/events/src/race.ts","../../../ixfx/packages/random/src/string.ts","../../../ixfx/packages/flow/src/retry.ts","../../../ixfx/packages/flow/src/wait-for.ts","../../../ixfx/packages/io/dist/src/codec.js","../../../ixfx/packages/io/dist/src/string-receive-buffer.js","../../../ixfx/packages/io/dist/src/string-write-buffer.js","../../../ixfx/packages/io/dist/src/generic-state-transitions.js","../../../ixfx/packages/io/dist/src/ble-device.js","../../../ixfx/packages/io/dist/src/nordic-ble-device.js","../../../ixfx/packages/trackers/src/number-tracker.ts","../../../ixfx/packages/io/dist/src/audio/visualiser.js","../../../ixfx/packages/io/dist/src/audio/analyser.js","../../../ixfx/packages/io/dist/src/audio/from-audio-element.js","../../../ixfx/packages/io/dist/src/audio/from-oscillator.js","../../../ixfx/packages/io/dist/src/audio/index.js","../../../ixfx/packages/io/dist/src/espruino-ble-device.js","../../../ixfx/packages/io/dist/src/json-device.js","../../../ixfx/packages/io/dist/src/serial.js","../../../ixfx/packages/io/dist/src/espruino-serial-device.js","../../../ixfx/packages/io/dist/src/espruino.js","../../../ixfx/packages/io/dist/src/camera.js","../../../ixfx/packages/io/dist/src/video-file.js","../../../ixfx/packages/visual/src/video.ts","../../../ixfx/packages/io/dist/src/frame-processor.js","../../../ixfx/packages/io/dist/src/reconnecting-web-socket.js","../../../ixfx/src-bundle/src/io.ts"],"sourcesContent":["/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n * \n * By default waits a maximum of 1 minute.\n * \n * Automatically unsubscribes on success or failure (ie. timeout)\n * \n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns \n */\nexport const eventRace = (target: EventTarget, eventNames: Array<string>, options: Partial<{ timeoutMs: number, signal: AbortSignal }> = {}) => {\n  const intervalMs = options.timeoutMs ?? 60_1000; //intervalToMs(options.timeout, 60 * 1000);\n  const signal = options.signal;\n  let triggered = false;\n  let disposed = false;\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n\n  const promise = new Promise<Event>((resolve, reject) => {\n    const onEvent = (event: Event) => {\n      if (`type` in event) {\n        if (eventNames.includes(event.type)) {\n          triggered = true;\n          resolve(event);\n          dispose();\n        } else {\n          console.warn(`eventRace: Got event '${ event.type }' that is not in race list`);\n        }\n      } else {\n        console.warn(`eventRace: Event data does not have expected 'type' field`);\n        console.log(event);\n      }\n    }\n\n    for (const name of eventNames) {\n      target.addEventListener(name, onEvent);\n    }\n\n    const dispose = () => {\n      if (disposed) return;\n      if (timeout !== undefined) clearTimeout(timeout);\n      timeout = undefined;\n      disposed = true;\n      for (const name of eventNames) {\n        target.removeEventListener(name, onEvent);\n      }\n    }\n\n    timeout = setTimeout(() => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`eventRace: Events not fired within interval. Events: ${ JSON.stringify(eventNames) } Interval: ${ intervalMs }`));\n    }, intervalMs);\n\n\n    signal?.addEventListener(`abort`, () => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`Abort signal received ${ signal.reason }`));\n    });\n  });\n  return promise;\n}","import {  type StringOptions } from \"./types.js\";\n\n/**\n * Returns a string of random letters and numbers of a given `length`.\n *\n * ```js\n * string();  // Random string of length 5\n * string(4); // eg. `4afd`\n * ```\n * @param lengthOrOptions Length of random string, or options.\n * @returns Random string\n */\nexport const string = (lengthOrOptions: number | StringOptions = 5) => {\n  const options =\n    typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;\n  const calculate = options.source ?? Math.random;\n  return calculate()\n    .toString(36)\n    .slice(2, length + 2);\n};","import { elapsedSince, sleep } from '@ixfx/core';\nimport { resolveLogOption } from '@ixfx/debug';\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { getErrorMessage } from '@ixfx/debug';\nimport type { Result } from '@ixfx/guards';\nimport { elapsedToHumanString } from '@ixfx/core';\n/**\n * Result of backoff\n */\nexport type RetryResult<V> = {\n  /**\n   * Message describing outcome.\n   *\n   * If retry was aborted, message will be abort reason.\n   */\n  readonly message?: string;\n  /**\n   * True if callback function was invoked once where it returned _true_\n   */\n  readonly success: boolean;\n  /**\n   * Number of times callback was attempted\n   */\n  readonly attempts: number;\n  /**\n   * Total elapsed time since beginning of call to `retry`\n   */\n  readonly elapsed: number;\n\n  /**\n   * Value returned by succeeding function,\n   * or _undefined_ if it failed\n   */\n  readonly value: V | undefined;\n};\n\nexport type BackoffOptions = {\n  /**\n   * Initial value.\n   * Default: 1\n   */\n  startAt: number,\n  /**\n   * Maximum times to run.\n   * Default: continues forever\n   */\n  limitAttempts: number,\n  /**\n   * Stop retrying if this maximum is reached\n   * Default: no limit\n   */\n  limitValue: number\n  /**\n   * Math power. \n   * Default: 1.1\n   */\n  power: number\n};\n\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n * \n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n * \n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n * \n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n * \n * @param options \n * @returns \n */\nexport function* backoffGenerator(options: Partial<BackoffOptions> = {}) {\n  const startAt = options.startAt ?? 1;\n  let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = options.limitValue;\n  const power = options.power ?? 1.1;\n  let value = startAt;\n  resultThrow(\n    integerTest(limitAttempts, `aboveZero`, `limitAttempts`),\n    numberTest(startAt, ``, `startAt`),\n    numberTest(limitAttempts, ``, `limitAttempts`),\n    () => (limitValue !== undefined) ? numberTest(limitValue, ``, `limitValue`) : undefined,\n    numberTest(power, ``, `power`)\n  );\n\n  while (limitAttempts > 0) {\n    // Value has climbed to the limit\n    if (limitValue && value >= limitValue) return;\n    limitAttempts--;\n    yield value;\n\n    // Increase value for next iteration\n    value += Math.pow(value, power);\n  }\n}\n\n/**\n * Backoff options\n */\nexport type RetryOpts<T> = BackoffOptions & {\n  /**\n   * Initial waiting period before first attempt (optional)\n   */\n  readonly predelayMs: number;\n  /**\n   * Optional abort signal\n   */\n  readonly abort: AbortSignal;\n  /**\n   * Log: _true_ monitors the task execution by logging to console\n   */\n  readonly log: boolean;\n\n  /***\n   * Default task value to return if it fails\n   */\n  readonly taskValueFallback: T;\n};\n\nexport type RetryTask<T> = {\n  /**\n   * If `probe` returns {success:true} task is considered\n   * complete and retrying stops\n   * @returns \n   */\n  probe: (attempts: number) => Promise<Result<T, any>>\n}\n\n/**\n * Keeps calling `callback` until it returns something other than _undefined_. \n * There is an exponentially-increasing delay between each retry attempt.\n * \n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport const retryFunction = <T>(callback: () => Promise<T | undefined>, options: Partial<RetryOpts<T>> = {}) => {\n  const task: RetryTask<T> = {\n    async probe() {\n      try {\n        const v = await callback();\n        if (v === undefined) return { value: options.taskValueFallback, error: `Fallback`, success: false };\n        return { value: v, success: true };\n      } catch (error) {\n        return { success: false, error: error as Error };\n      }\n    },\n  }\n  return retryTask(task, options);\n}\n\n/**\n * Keeps trying to run `task`.\n * \n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *  \n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n * \n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task \n * @param opts \n * @returns \n */\nexport const retryTask = async <V>(\n  task: RetryTask<V>,\n  opts: Partial<RetryOpts<V>> = {}\n): Promise<RetryResult<V>> => {\n  const signal = opts.abort;\n  const log = resolveLogOption(opts.log);\n  const predelayMs = opts.predelayMs ?? 0;\n  const startedAt = elapsedSince();\n\n  let attempts = 0;\n  const initialValue = opts.startAt ?? 1000;\n  const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n\n  if (initialValue <= 0) throw new Error(`Param 'initialValue' must be above zero`);\n\n  if (predelayMs > 0) {\n    try {\n      await sleep({ millis: predelayMs, signal: signal });\n    } catch (error) {\n      // Could happen due to abort signal\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n        message: getErrorMessage(error),\n      };\n    }\n  }\n\n  for (const t of backoffGen) {\n    attempts++;\n\n    // Run task\n    const result = await task.probe(attempts);\n    if (result.success) {\n      return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n    }\n    log({\n      msg: `retry attempts: ${ attempts.toString() } t: ${ elapsedToHumanString(t) }`,\n    });\n\n    // Did not succeed.\n    if (attempts >= limitAttempts) {\n      break; // Out of attempts, no point sleeping again\n    }\n    // Sleep\n    try {\n      await sleep({ millis: t, signal });\n    } catch (error) {\n      // Eg if abort signal fires\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        message: getErrorMessage(error),\n        elapsed: startedAt(),\n      };\n    }\n  }\n\n  return {\n    message: `Giving up after ${ attempts.toString() } attempts.`,\n    success: false,\n    attempts,\n    value: opts.taskValueFallback,\n    elapsed: startedAt(),\n  };\n};\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n * \n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n * \n * ```js\n * waitFor(1000, \n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n * \n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n * \n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n * \n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (\n  timeoutMs: number,\n  onAborted: (reason: string) => void,\n  onComplete?: (success: boolean) => void\n) => {\n  let t: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  let success = false;\n  const done = (error?: string) => {\n    if (t !== undefined) {\n      window.clearTimeout(t);\n      t = undefined;\n    }\n    if (error) {\n      onAborted(error);\n    } else {\n      success = true;\n    }\n    if (onComplete !== undefined) onComplete(success);\n  };\n\n  t = globalThis.setTimeout(() => {\n    t = undefined;\n    try {\n      onAborted(`Timeout after ${ timeoutMs }ms`);\n    } finally {\n      if (onComplete !== undefined) onComplete(success);\n    }\n  }, timeoutMs);\n\n  return done;\n};\n","/**\n * Handles utf-8 text encoding/decoding\n */\nexport class Codec {\n    enc = new TextEncoder();\n    dec = new TextDecoder(`utf-8`);\n    /**\n     * Convert string to Uint8Array buffer\n     * @param text\n     * @returns\n     */\n    toBuffer(text) {\n        return this.enc.encode(text);\n    }\n    /**\n     * Returns a string from a provided buffer\n     * @param buffer\n     * @returns\n     */\n    fromBuffer(buffer) {\n        return this.dec.decode(buffer);\n    }\n}\n","/**\n * Receives text\n */\nexport class StringReceiveBuffer {\n    onData;\n    separator;\n    buffer = ``;\n    stream;\n    constructor(onData, separator = `\\n`) {\n        this.onData = onData;\n        this.separator = separator;\n    }\n    async close() {\n        const s = this.stream;\n        if (!s)\n            return;\n        await s.abort();\n        await s.close();\n    }\n    clear() {\n        this.buffer = ``;\n    }\n    writable() {\n        if (this.stream === undefined)\n            this.stream = this.createWritable();\n        return this.stream;\n    }\n    createWritable() {\n        //eslint-disable-next-line @typescript-eslint/no-this-alias\n        const b = this;\n        return new WritableStream({\n            write(chunk) {\n                b.add(chunk);\n            },\n            close() {\n                b.clear();\n            },\n        });\n    }\n    addImpl(string_) {\n        // Look for separator in new string\n        const pos = string_.indexOf(this.separator);\n        if (pos < 0) {\n            // Not found, just add to buffer and return\n            this.buffer += string_;\n            return ``;\n        }\n        // Found! Trigger callback for existing buffer and part of new string\n        const part = string_.substring(0, pos);\n        try {\n            this.onData(this.buffer + part);\n            string_ = string_.substring(part.length + this.separator.length);\n        }\n        catch (ex) {\n            console.warn(ex);\n        }\n        this.buffer = ``;\n        return string_;\n    }\n    add(string_) {\n        while (string_.length > 0) {\n            string_ = this.addImpl(string_);\n        }\n    }\n}\n","import { QueueMutable } from '@ixfx/collections/queue';\nimport { continuously } from '@ixfx/core';\nimport { splitByLength } from '@ixfx/core/text';\n/**\n * Buffers a queue of strings.\n *\n * When text is queued via {@link add}, it is chopped up\n * into chunks and sent in serial to the `dataHandler` function.\n * Data is processed at a set rate, by default 10ms.\n *\n * ```js\n * const dataHandler = (data:string) => {\n *  // Do something with queued data.\n *  // eg. send to serial port\n * }\n *\n * // Create a buffer with a chunk size of 100 characters\n * const b = new StringWriteBuffer(dataHandler, { chunkSize: 100 });\n * b.add('some text'); // Write to buffer\n * // dataHandler will be called until queued data is empty\n * ```\n *\n * It's also possible to get the buffer as a WritableStream<string>:\n * ```js\n * const dataHandler = (data:string) => { ... }\n * const b = new StringWriteBuffer(dataHandler, 100);\n * const s = b.writable();\n * ```\n *\n * Other functions:\n * ```js\n * b.close(); // Close buffer\n * b.clear(); // Clear queued data, but don't close anything\n * ```\n */\nexport class StringWriteBuffer {\n    dataHandler;\n    paused = false;\n    queue = new QueueMutable();\n    writer;\n    stream;\n    closed = false;\n    chunkSize;\n    /**\n     * Constructor\n     * @param dataHandler Calback to 'send' data onwards\n     * @param opts Options\n     */\n    constructor(dataHandler, opts = {}) {\n        this.dataHandler = dataHandler;\n        this.chunkSize = opts.chunkSize ?? -1;\n        this.writer = continuously(async () => {\n            await this.onWrite();\n        }, opts.interval ?? 10);\n    }\n    /**\n     * Close writer (async)\n     */\n    async close() {\n        if (this.closed)\n            return;\n        const w = this.stream?.getWriter();\n        w?.releaseLock();\n        await w?.close();\n        this.closed = true;\n    }\n    /**\n     * Clear queued data.\n     *\n     * Throws an error if {@link close} has been called.\n     */\n    clear() {\n        if (this.closed)\n            throw new Error(`Buffer closed`);\n        this.queue = new QueueMutable();\n    }\n    /**\n     * Gets the buffer as a writable stream.\n     *\n     * Do not close stream directly, use .close on this class instead.\n     *\n     * Throws an error if .close() has been called.\n     * @returns Underlying stream\n     */\n    writable() {\n        if (this.closed)\n            throw new Error(`Buffer closed`);\n        if (this.stream === undefined)\n            this.stream = this.createWritable();\n        return this.stream;\n    }\n    createWritable() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const b = this;\n        return new WritableStream({\n            write(chunk) {\n                b.add(chunk);\n            },\n            close() {\n                b.clear();\n            },\n        });\n    }\n    /**\n     * Run in a `continunously` loop to process queued data\n     * @returns _False_ if queue is empty and loop should stop. _True_ if it shoud continue.\n     */\n    async onWrite() {\n        if (this.queue.isEmpty) {\n            //console.warn(`WriteBuffer.onWrite: queue empty`);\n            return false; // Stop continuously\n        }\n        if (this.paused) {\n            console.warn(`WriteBuffer.onWrite: paused...`);\n            return true; // Keep going tho\n        }\n        // Dequeue and send\n        const s = this.queue.dequeue();\n        if (s === undefined)\n            return false;\n        await this.dataHandler(s);\n        return true;\n    }\n    /**\n     * Returns _true_ if {@link close} has been called.\n     */\n    get isClosed() {\n        return this.closed;\n    }\n    /**\n     * Adds some queued data to send.\n     * Longer strings are automatically chunked up according to the buffer's settings.\n     *\n     * Throws an error if {@link close} has been called.\n     * @param stringToQueue\n     */\n    add(stringToQueue) {\n        if (this.closed)\n            throw new Error(`Buffer closed`);\n        // Add whole string or chunked string\n        if (this.chunkSize > 0) {\n            this.queue.enqueue(...splitByLength(stringToQueue, this.chunkSize));\n        }\n        else {\n            this.queue.enqueue(stringToQueue);\n        }\n        // Run continuously loop if it's not already running\n        this.writer.start();\n    }\n}\n","export const genericStateTransitionsInstance = Object.freeze({\n    ready: `connecting`,\n    connecting: [`connected`, `closed`],\n    connected: [`closed`],\n    closed: `connecting`,\n});\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\nimport { retryFunction } from '@ixfx/flow';\nimport { indexOfCharCode, omitChars } from '@ixfx/core/text';\nimport { Codec } from './codec.js';\nimport { StringReceiveBuffer } from './string-receive-buffer.js';\nimport { StringWriteBuffer } from './string-write-buffer.js';\nimport {} from './types.js';\nimport { genericStateTransitionsInstance } from './generic-state-transitions.js';\nconst reconnect = async () => {\n    console.log(`Connect?`);\n    if (!(`bluetooth` in navigator))\n        return false;\n    if (!(`getDevices` in navigator.bluetooth))\n        return false;\n    const devices = await navigator.bluetooth.getDevices();\n    console.log(devices);\n    for (const device of devices) {\n        console.log(device);\n        // Start a scan for each device before connecting to check that they're in\n        // range.\n        const abortController = new AbortController();\n        await device.watchAdvertisements({ signal: abortController.signal });\n        device.addEventListener(`advertisementreceived`, async (event) => {\n            console.log(event);\n            // Stop the scan to conserve power on mobile devices.\n            abortController.abort();\n            // At this point, we know that the device is in range, and we can attempt\n            // to connect to it.\n            await event.device.gatt?.connect();\n            console.log(`Connected!`);\n        });\n    }\n};\nexport class BleDevice extends SimpleEventEmitter {\n    device;\n    config;\n    states;\n    codec;\n    rx;\n    tx;\n    gatt;\n    verboseLogging = false;\n    rxBuffer;\n    txBuffer;\n    constructor(device, config) {\n        super();\n        this.device = device;\n        this.config = config;\n        this.verboseLogging = config.debug;\n        this.txBuffer = new StringWriteBuffer(async (data) => {\n            await this.writeInternal(data);\n        }, config);\n        this.rxBuffer = new StringReceiveBuffer((line) => {\n            this.fireEvent(`data`, { data: line });\n        });\n        this.codec = new Codec();\n        this.states = new StateMachineWithEvents(genericStateTransitionsInstance, {\n            initial: `ready`,\n        });\n        this.states.addEventListener(`change`, (event) => {\n            this.fireEvent(`change`, event);\n            this.verbose(`${event.priorState} -> ${event.newState}`);\n            if (event.priorState === `connected`) {\n                // Clear out buffers\n                this.rxBuffer.clear();\n                this.txBuffer.clear();\n            }\n        });\n        device.addEventListener(`gattserverdisconnected`, () => {\n            if (this.isClosed)\n                return;\n            this.verbose(`GATT server disconnected`);\n            this.states.state = `closed`;\n        });\n        this.verbose(`ctor ${device.name} ${device.id}`);\n    }\n    get isConnected() {\n        return this.states.state === `connected`;\n    }\n    get isClosed() {\n        return this.states.state === `closed`;\n    }\n    write(txt) {\n        if (this.states.state !== `connected`) {\n            throw new Error(`Cannot write while state is ${this.states.state}`);\n        }\n        this.txBuffer.add(txt);\n    }\n    async writeInternal(txt) {\n        this.verbose(`writeInternal ${txt}`);\n        const tx = this.tx;\n        if (tx === undefined) {\n            throw new Error(`Unexpectedly without tx characteristic`);\n        }\n        try {\n            await tx.writeValue(this.codec.toBuffer(txt));\n        }\n        catch (error) {\n            this.warn(error);\n        }\n    }\n    disconnect() {\n        if (this.states.state !== `connected`)\n            return;\n        this.gatt?.disconnect();\n    }\n    async connect() {\n        const attempts = this.config.connectAttempts ?? 3;\n        this.states.state = `connecting`;\n        this.verbose(`connect`);\n        const gatt = this.device.gatt;\n        if (gatt === undefined)\n            throw new Error(`Gatt not available on device`);\n        await retryFunction(async () => {\n            this.verbose(`connect.retry`);\n            const server = await gatt.connect();\n            this.verbose(`Getting primary service`);\n            const service = await server.getPrimaryService(this.config.service);\n            this.verbose(`Getting characteristics`);\n            const rx = await service.getCharacteristic(this.config.rxGattCharacteristic);\n            const tx = await service.getCharacteristic(this.config.txGattCharacteristic);\n            rx.addEventListener(`characteristicvaluechanged`, (event) => { this.onRx(event); });\n            this.rx = rx;\n            this.tx = tx;\n            this.gatt = gatt;\n            this.states.state = `connected`;\n            await rx.startNotifications();\n            return true;\n        }, {\n            limitAttempts: attempts,\n            startAt: 200,\n        });\n    }\n    onRx(event) {\n        const rx = this.rx;\n        if (rx === undefined)\n            return;\n        const view = event.target.value;\n        if (view === undefined)\n            return;\n        let text = this.codec.fromBuffer(view.buffer);\n        // Check for flow control chars\n        const plzStop = indexOfCharCode(text, 19);\n        const plzStart = indexOfCharCode(text, 17);\n        // Remove if found\n        if (plzStart && plzStop < plzStart) {\n            this.verbose(`Tx plz start`);\n            text = omitChars(text, plzStart, 1);\n            this.txBuffer.paused = false;\n        }\n        if (plzStop && plzStop > plzStart) {\n            this.verbose(`Tx plz stop`);\n            text = omitChars(text, plzStop, 1);\n            this.txBuffer.paused = true;\n        }\n        this.rxBuffer.add(text);\n    }\n    verbose(m) {\n        if (this.verboseLogging)\n            console.info(this.config.name, m);\n    }\n    log(m) {\n        console.log(this.config.name, m);\n    }\n    warn(m) {\n        console.warn(this.config.name, m);\n    }\n}\n","import { BleDevice } from './ble-device.js';\nexport const defaultOpts = {\n    chunkSize: 20,\n    service: `6e400001-b5a3-f393-e0a9-e50e24dcca9e`,\n    txGattCharacteristic: `6e400002-b5a3-f393-e0a9-e50e24dcca9e`,\n    rxGattCharacteristic: `6e400003-b5a3-f393-e0a9-e50e24dcca9e`,\n    name: `NordicDevice`,\n    connectAttempts: 5,\n    debug: false,\n};\nexport class NordicBleDevice extends BleDevice {\n    constructor(device, opts = {}) {\n        super(device, { ...defaultOpts, ...opts });\n    }\n}\n","import { PrimitiveTracker, type TimestampedPrimitive, type TrackedValueOpts, type TrimReason } from \"@ixfx/core/trackers\";\n\nimport { minFast, maxFast, totalFast } from \"@ixfx/numbers\";\n\nexport type NumberTrackerResults = {\n  readonly total: number\n  readonly min: number\n  readonly max: number\n  readonly avg: number\n};\n\nexport class NumberTracker extends PrimitiveTracker<number, NumberTrackerResults> {\n  total = 0;\n  min = Number.MAX_SAFE_INTEGER;\n  max = Number.MIN_SAFE_INTEGER;\n\n\n  get avg() {\n    return this.total / this.seenCount;\n  }\n\n  /**\n   * Difference between last value and initial.\n   * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)\n   * If either of those is missing, undefined is returned\n   */\n  difference(): number | undefined {\n    if (this.last === undefined) return;\n    if (this.initial === undefined) return;\n    return this.last - this.initial;\n  }\n\n  /**\n   * Relative difference between last value and initial.\n   * Eg if last value was 10 and initial value was 5, 2 is returned (200%)\n   */\n  relativeDifference(): number | undefined {\n    if (this.last === undefined) return;\n    if (this.initial === undefined) return;\n    return this.last / this.initial;\n  }\n\n  onReset() {\n    this.min = Number.MAX_SAFE_INTEGER;\n    this.max = Number.MIN_SAFE_INTEGER;\n    this.total = 0;\n    super.onReset();\n  }\n\n  /**\n   * When trimmed, recomputes to set total/min/max to be based on\n   * current values.\n   * @param reason \n   */\n  onTrimmed(reason: TrimReason) {\n    this.min = minFast(this.values);\n    this.max = maxFast(this.values);\n    this.total = totalFast(this.values);\n  }\n\n  computeResults(values: TimestampedPrimitive<number>[]): NumberTrackerResults {\n    if (values.some((v) => Number.isNaN(v))) throw new Error(`Cannot add NaN`);\n    const numbers = values.map(value => value.value);\n\n    this.total = numbers.reduce((accumulator, v) => accumulator + v, this.total);\n    this.min = Math.min(...numbers, this.min);\n    this.max = Math.max(...numbers, this.max);\n    const r: NumberTrackerResults = {\n      max: this.max,\n      min: this.min,\n      total: this.total,\n      avg: this.avg\n    }\n    return r;\n  }\n\n  getMinMaxAvg() {\n    return {\n      min: this.min,\n      max: this.max,\n      avg: this.avg,\n    };\n  }\n}\n\n/**\n * Keeps track of the total, min, max and avg in a stream of values. By default values\n * are not stored.\n *\n * Usage:\n *\n * ```js\n * import { number } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = number();\n * t.seen(10);\n *\n * t.avg / t.min/ t.max\n * t.initial; // initial value\n * t.size;    // number of seen values\n * t.elapsed; // milliseconds since intialisation\n * t.last;    // last value\n * ```\n *\n * To get `{ avg, min, max, total }`\n * ```\n * t.getMinMax()\n * ```\n *\n * Use `t.reset()` to clear everything.\n *\n * Trackers can automatically reset after a given number of samples\n * ```\n * // reset after 100 samples\n * const t = number({ resetAfterSamples: 100 });\n * ```\n *\n * To store values, use the `storeIntermediate` option:\n *\n * ```js\n * const t = number({ storeIntermediate: true });\n * ```\n *\n * Difference between last value and initial value:\n * ```js\n * t.relativeDifference();\n * ```\n *\n * Get raw data (if it is being stored):\n * ```js\n * t.values; // array of numbers\n * t.timestampes; // array of millisecond times, indexes correspond to t.values\n * ```\n */\nexport const number = (opts: TrackedValueOpts = {}) => new NumberTracker(opts);\n","/**\n * Visualiser component\n *\n * Usage: import visualiser.js. Instantiate on document load, and pass in the\n * parent element into the constructor.\n *\n * eg: const v = new Visualiser(document.getElementById('renderer'));\n *\n * Data must be passed to the component via renderFreq or renderWave.\n *\n * Draws on https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\n */\nimport { number as numberTracker } from '@ixfx/trackers';\nimport { AudioAnalyser } from './analyser.js';\nimport { numberArrayCompute } from '@ixfx/numbers';\n// TODO: This is an adaption of old code. Needs to be smartened up further\nexport class AudioVisualiser {\n    freqMaxRange = 200;\n    audio;\n    parent;\n    lastPointer = { x: 0, y: 0 };\n    pointerDown = false;\n    pointerClicking = false;\n    pointerClickDelayMs = 100;\n    pointerDelaying = false;\n    waveTracker;\n    freqTracker;\n    el;\n    constructor(parentElement, audio) {\n        this.audio = audio;\n        this.parent = parentElement;\n        this.waveTracker = numberTracker();\n        this.freqTracker = numberTracker();\n        // Add HTML\n        parentElement.innerHTML = `\n    <section>\n      <button id=\"rendererComponentToggle\">🔼</button>\n      <div>\n        <h1>Visualiser</h1>\n        <div style=\"display:flex; flex-wrap: wrap\">\n          <div class=\"visPanel\">\n            <h2>Frequency distribution</h2>\n            <br />\n            <canvas id=\"rendererComponentFreqData\" height=\"200\" width=\"400\"></canvas>\n          </div>\n          <div class=\"visPanel\">\n            <h2>Waveform</h2>\n            <button id=\"rendererComponentWaveReset\">Reset</button>\n            <div>\n              Press and hold on wave to measure\n            </div>\n            <br />\n            <canvas id=\"rendererComponentWaveData\" height=\"200\" width=\"400\"></canvas>\n          </div>\n        </div>\n      </div>\n    </section>\n    `;\n        this.el = parentElement.children[0];\n        document\n            .getElementById(`rendererComponentToggle`)\n            ?.addEventListener(`click`, () => {\n            this.setExpanded(!this.isExpanded());\n        });\n        this.el.addEventListener(`pointermove`, (e) => { this.onPointer(e); });\n        //this.el.addEventListener(`touchbegin`, (e) => this.onPointer(e));\n        this.el.addEventListener(`pointerup`, () => {\n            this.pointerDelaying = false;\n            this.pointerDown = false;\n        });\n        this.el.addEventListener(`pointerdown`, () => {\n            this.pointerDelaying = true;\n            setTimeout(() => {\n                if (this.pointerDelaying) {\n                    this.pointerDelaying = false;\n                    this.pointerDown = true;\n                }\n            }, this.pointerClickDelayMs);\n        });\n        this.el.addEventListener(`pointerleave`, () => {\n            this.pointerDelaying = false;\n            this.pointerDown = false;\n        });\n        document\n            .getElementById(`rendererComponentWaveReset`)\n            ?.addEventListener(`click`, () => {\n            this.clear();\n        });\n    }\n    renderFreq(freq) {\n        if (!this.isExpanded())\n            return; // Don't render if collapsed\n        if (!freq)\n            return; // Data is undefined/null\n        const canvas = document.getElementById(`rendererComponentFreqData`);\n        if (canvas === null)\n            throw new Error(`Cannot find canvas element`);\n        const g = canvas.getContext(`2d`);\n        if (g === null)\n            throw new Error(`Cannot create drawing context`);\n        const bins = freq.length;\n        const canvasWidth = canvas.clientWidth;\n        const canvasHeight = canvas.clientHeight;\n        g.clearRect(0, 0, canvasWidth, canvasHeight);\n        const pointer = this.getPointerRelativeTo(canvas);\n        const width = canvasWidth / bins;\n        const minMax = numberArrayCompute(freq);\n        for (let index = 0; index < bins; index++) {\n            if (!Number.isFinite(freq[index]))\n                continue;\n            const value = freq[index] - minMax.min;\n            const valueRelative = value / this.freqMaxRange;\n            const height = Math.abs(canvasHeight * valueRelative);\n            const offset = canvasHeight - height;\n            const hue = (index / bins) * 360;\n            const left = index * width;\n            g.fillStyle = `hsl(${hue}, 100%, 50%)`;\n            // Show info about data under pointer\n            if (pointer.y > 0 &&\n                pointer.y <= canvasHeight &&\n                pointer.x >= left &&\n                pointer.x <= left + width) {\n                // Keep track of data\n                if (this.freqTracker.id !== index.toString()) {\n                    this.freqTracker = numberTracker({ id: index.toString() });\n                }\n                this.freqTracker.seen(freq[index]);\n                const freqMma = this.freqTracker.getMinMaxAvg();\n                // Display\n                g.fillStyle = `black`;\n                if (this.audio) {\n                    g.fillText(`Frequency (${index}) at pointer: ${this.audio\n                        .getFrequencyAtIndex(index)\n                        .toLocaleString(`en`)} - ${this.audio\n                        .getFrequencyAtIndex(index + 1)\n                        .toLocaleString(`en`)}`, 2, 10);\n                }\n                g.fillText(`Raw value: ${freq[index].toFixed(2)}`, 2, 20);\n                g.fillText(`Min: ${freqMma.min.toFixed(2)}`, 2, 40);\n                g.fillText(`Max: ${freqMma.max.toFixed(2)}`, 60, 40);\n                g.fillText(`Avg: ${freqMma.avg.toFixed(2)}`, 120, 40);\n            }\n            g.fillRect(left, offset, width, height);\n        }\n    }\n    isExpanded() {\n        const contentsElement = this.el.querySelector(`div`);\n        if (contentsElement === null)\n            throw new Error(`contents div not found`);\n        return contentsElement.style.display === ``;\n    }\n    setExpanded(value) {\n        const contentsElement = this.el.querySelector(`div`);\n        const button = this.el.querySelector(`button`);\n        if (button === null)\n            throw new Error(`Button element not found`);\n        if (contentsElement === null)\n            throw new Error(`Contents element not found`);\n        if (value) {\n            contentsElement.style.display = ``;\n            button.innerText = `🔼`;\n        }\n        else {\n            contentsElement.style.display = `none`;\n            button.innerText = `🔽`;\n        }\n    }\n    clear() {\n        this.clearCanvas(document.getElementById(`rendererComponentFreqData`));\n        this.clearCanvas(document.getElementById(`rendererComponentWaveData`));\n    }\n    // Clears a canvas to white\n    clearCanvas(canvas) {\n        if (canvas === null)\n            throw new Error(`Canvas is null`);\n        const g = canvas.getContext(`2d`);\n        if (g === null)\n            throw new Error(`Cannot create drawing context`);\n        g.fillStyle = `white`;\n        g.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n    }\n    // Renders waveform data.\n    // Adapted from MDN's AnalyserNode.getFloatTimeDomainData() example\n    renderWave(wave, bipolar = true) {\n        if (!this.isExpanded())\n            return; // Don't render if collapsed\n        if (!wave)\n            return; // Undefined or null data\n        const canvas = document.getElementById(`rendererComponentWaveData`);\n        if (canvas === null)\n            throw new Error(`Cannot find wave canvas`);\n        const g = canvas.getContext(`2d`);\n        if (g === null)\n            throw new Error(`Cannot create drawing context for wave`);\n        const canvasWidth = canvas.clientWidth;\n        const canvasHeight = canvas.clientHeight;\n        const pointer = this.getPointerRelativeTo(canvas);\n        const infoAreaHeight = 20;\n        const infoAreaWidth = 60;\n        const bins = wave.length;\n        g.fillStyle = `white`;\n        g.fillRect(0, 0, infoAreaWidth, infoAreaHeight);\n        const width = canvasWidth / bins;\n        // Clears the screen with very light tint of white\n        // to fade out last waveform. Set this higher to remove effect\n        g.fillStyle = `rgba(255, 255, 255, 0.03)`;\n        g.fillRect(0, 20, canvasWidth, canvasHeight);\n        g.fillStyle = `red`;\n        if (bipolar) {\n            g.fillRect(0, canvasHeight / 2, canvasWidth, 1);\n        }\n        else {\n            g.fillRect(0, canvasHeight - 1, canvasWidth, 1);\n        }\n        g.lineWidth = 1;\n        g.strokeStyle = `black`;\n        g.beginPath();\n        //eslint-disable-next-line functional/no-let\n        let x = 0;\n        //eslint-disable-next-line functional/no-let\n        for (let index = 0; index < bins; index++) {\n            const height = wave[index] * canvasHeight;\n            const y = bipolar ? canvasHeight / 2 - height : canvasHeight - height;\n            if (index === 0) {\n                g.moveTo(x, y);\n            }\n            else {\n                g.lineTo(x, y);\n            }\n            x += width;\n            if (this.pointerDown)\n                this.waveTracker.seen(wave[index]);\n        }\n        g.lineTo(canvasWidth, bipolar ? canvasHeight / 2 : canvasHeight); //canvas.height / 2);\n        g.stroke();\n        // Draw\n        if (this.pointerDown) {\n            const waveMma = this.waveTracker.getMinMaxAvg();\n            g.fillStyle = `rgba(255,255,0,1)`;\n            g.fillRect(infoAreaWidth, 0, 150, 20);\n            g.fillStyle = `black`;\n            g.fillText(`Min: ` + waveMma.min.toFixed(2), 60, 10);\n            g.fillText(`Max: ` + waveMma.max.toFixed(2), 110, 10);\n            g.fillText(`Avg: ` + waveMma.avg.toFixed(2), 160, 10);\n        }\n        else {\n            this.waveTracker.reset();\n        }\n        // Show info about data under pointer\n        if (pointer.y > 0 &&\n            pointer.y <= canvasHeight &&\n            pointer.x >= 0 &&\n            pointer.x <= canvasWidth) {\n            g.fillStyle = `black`;\n            g.fillText(`Level: ` + (1.0 - pointer.y / canvasHeight).toFixed(2), 2, 10);\n        }\n    }\n    // Yields pointer position relative to given element\n    getPointerRelativeTo(elem) {\n        const rect = elem.getBoundingClientRect();\n        return {\n            x: this.lastPointer.x - rect.left - window.scrollX, //elem.offsetLeft + window.scrollX,\n            y: this.lastPointer.y - rect.top - window.scrollY, //elem.offsetTop + window.scrollY\n        };\n    }\n    // Keeps track of last pointer position in page coordinate space\n    onPointer(event) {\n        this.lastPointer = {\n            x: event.pageX,\n            y: event.pageY,\n        };\n        event.preventDefault();\n    }\n}\n","import { numberTest, integerTest, isPowerOfTwo, resultThrow } from '@ixfx/guards';\nimport { max, maxFast } from '@ixfx/numbers';\nimport { AudioVisualiser } from './visualiser.js';\n/**\n * Basic audio analyser. Returns back waveform and FFT analysis. Use {@link analyserPeakLevel} if you want sound level, or {@link analyserFrequency} if you just want FFT results.\n *\n * ```js\n * const onData = (freq, wave, analyser) => {\n *  // Demo: Get FFT results just for 100Hz-1KHz.\n *  const freqSlice = analyser.sliceByFrequency(100,1000,freq);\n *\n *  // Demo: Get FFT value for a particular frequency (1KHz)\n *  const amt = freq[analyser.getIndexForFrequency(1000)];\n * }\n * analyserBasic(onData, {fftSize: 512});\n * ```\n *\n * An `Analyser` instance is returned and can be controlled:\n * ```js\n * const analyser = analyserBasic(onData);\n * analyser.paused = true;\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n* @param onData Handler for data\n * @param opts Options\n * @returns Analyser instance\n */\nexport const analyserBasic = (onData, opts = {}) => new AudioAnalyser((node, analyser) => {\n    // Get frequency and amplitude data\n    const freq = new Float32Array(node.frequencyBinCount);\n    const wave = new Float32Array(node.fftSize);\n    // Load arrays with data\n    node.getFloatFrequencyData(freq);\n    node.getFloatTimeDomainData(wave);\n    // Send back\n    onData(freq, wave, analyser);\n}, opts);\n/**\n * Basic audio analyser. Returns FFT analysis. Use {@link analyserPeakLevel} if you want the sound level, or {@link analyserBasic} if you also want the waveform.\n *\n * ```js\n * const onData = (freq, analyser) => {\n *  // Demo: Print out each sound frequency (Hz) and amount of energy in that band\n *  for (let i=0;i<freq.length;i++) {\n *    const f = analyser.getFrequencyAtIndex(0);\n *    console.log(`${i}. frequency: ${f} amount: ${freq[i]}`);\n *  }\n * }\n * analyserFrequency(onData, {fftSize:512});\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n * @param onData\n * @param opts\n * @returns\n */\nexport const analyserFrequency = (onData, opts = {}) => new AudioAnalyser((node, analyser) => {\n    const freq = new Float32Array(node.frequencyBinCount);\n    node.getFloatFrequencyData(freq);\n    onData(freq, analyser);\n}, opts);\n/**\n * Basic audio analyser which reports the peak sound level.\n *\n * ```js\n * analyserPeakLevel(level => {\n *  console.log(level);\n * });\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n * @param onData\n * @param opts\n * @returns\n */\nexport const analyserPeakLevel = (onData, opts = {}) => new AudioAnalyser((node, analyser) => {\n    const wave = new Float32Array(node.fftSize);\n    node.getFloatTimeDomainData(wave);\n    onData(maxFast(wave), analyser);\n}, opts);\n/**\n * Helper for doing audio analysis. It takes case of connecting the audio stream, running in a loop and pause capability.\n *\n * Provide a function which works with an [AnalyserNode](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode), and does something with the result.\n * ```js\n * const myAnalysis = (node, analyser) => {\n *  const freq = new Float32Array(node.frequencyBinCount);\n *  node.getFloatFrequencyData(freq);\n *  // Do something with frequency data...\n * }\n * const a = new Analyser(myAnalysis);\n * ```\n *\n * Helper functions provide ready-to-use Analysers:\n * * {@link analyserPeakLevel} peak decibel reading\n * * {@link analyserFrequency} FFT results\n * * {@link analyserBasic} FFT results and waveform\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n */\nexport class AudioAnalyser {\n    showVis;\n    fftSize;\n    smoothingTimeConstant;\n    #isPaused = false;\n    debug;\n    #initInProgress = false;\n    visualiser;\n    audioCtx;\n    analyserNode;\n    analyse;\n    constructor(analyse, opts = {}) {\n        this.showVis = opts.showVis ?? false;\n        this.fftSize = opts.fftSize ?? 1024;\n        this.debug = opts.debug ?? false;\n        this.smoothingTimeConstant = opts.smoothingTimeConstant ?? 0.8;\n        resultThrow(integerTest(this.fftSize, `positive`, `opts.fftSize`), numberTest(this.smoothingTimeConstant, `percentage`, `opts.smoothingTimeConstant`));\n        if (!isPowerOfTwo(this.fftSize)) {\n            throw new Error(`fftSize must be a power of two from 32 to 32768 (${this.fftSize})`);\n        }\n        if (this.fftSize < 32)\n            throw new Error(`fftSize must be at least 32`);\n        if (this.fftSize > 32_768) {\n            throw new Error(`fftSize must be no greater than 32768`);\n        }\n        this.analyse = analyse;\n        this.paused = false;\n        this.init();\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        const visualiserEl = document.querySelector(`#audio-visualiser`);\n        if (visualiserEl) {\n            const visualiser = new AudioVisualiser(visualiserEl, this);\n            visualiser.setExpanded(this.showVis);\n            this.visualiser = visualiser;\n        }\n    }\n    init() {\n        if (this.#initInProgress) {\n            if (this.debug)\n                console.debug(`Init already in progress`);\n            return;\n        }\n        this.#initInProgress = true;\n        // Initalise microphone\n        navigator.mediaDevices\n            .getUserMedia({ audio: true })\n            .then((stream) => {\n            this.onMicSuccess(stream);\n        })\n            .catch((error) => {\n            this.#initInProgress = false;\n            console.error(error);\n        });\n    }\n    get paused() {\n        return this.#isPaused;\n    }\n    set paused(v) {\n        if (v === this.#isPaused)\n            return;\n        this.#isPaused = v;\n        if (v) {\n            if (this.debug)\n                console.log(`Paused`);\n        }\n        else {\n            if (this.debug)\n                console.log(`Unpaused`);\n            window.requestAnimationFrame(this.analyseLoop.bind(this));\n        }\n    }\n    setup(context, stream) {\n        const analyser = context.createAnalyser();\n        // fftSize must be a power of 2. Higher values slower, more detailed\n        // Range is 32-32768\n        analyser.fftSize = this.fftSize;\n        // smoothingTimeConstant ranges from 0.0 to 1.0\n        // 0 = no averaging. Fast response, jittery\n        // 1 = maximum averaging. Slow response, smooth\n        analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n        // Microphone -> analyser\n        const micSource = context.createMediaStreamSource(stream);\n        micSource.connect(analyser);\n        return analyser;\n    }\n    // Microphone successfully initalised, now have access to audio data\n    onMicSuccess(stream) {\n        try {\n            const context = new AudioContext();\n            context.addEventListener(`statechange`, () => {\n                if (this.debug)\n                    console.log(`Audio context state: ${context.state}`);\n            });\n            this.audioCtx = context;\n            this.analyserNode = this.setup(context, stream);\n            // Start loop\n            window.requestAnimationFrame(this.analyseLoop.bind(this));\n        }\n        catch (error) {\n            this.#initInProgress = false;\n            console.error(error);\n        }\n    }\n    analyseLoop() {\n        if (this.paused) {\n            if (this.debug)\n                console.log(`Paused`);\n            return;\n        }\n        const a = this.analyserNode;\n        if (a === undefined) {\n            console.warn(`Analyser undefined`);\n            return;\n        }\n        try {\n            // Perform analysis\n            this.analyse(a, this);\n        }\n        catch (error) {\n            console.error(error);\n        }\n        // Run again\n        window.requestAnimationFrame(this.analyseLoop.bind(this));\n    }\n    // visualise(wave, freq) {\n    //   if (!this.visualiser) return;\n    //   this.visualiser.renderWave(wave, true);\n    //   this.visualiser.renderFreq(freq);\n    // }\n    /**\n     * Returns the maximum FFT value within the given frequency range\n     */\n    getFrequencyRangeMax(lowFreq, highFreq, freqData) {\n        const samples = this.sliceByFrequency(lowFreq, highFreq, freqData);\n        return max(samples);\n    }\n    /**\n     * Returns a sub-sampling of frequency analysis data that falls between\n     * `lowFreq` and `highFreq`.\n     * @param lowFreq Low frequency\n     * @param highFreq High frequency\n     * @param freqData Full-spectrum frequency data\n     * @returns Sub-sampling of analysis\n     */\n    sliceByFrequency(lowFreq, highFreq, freqData) {\n        const lowIndex = this.getIndexForFrequency(lowFreq);\n        const highIndex = this.getIndexForFrequency(highFreq);\n        // Grab a 'slice' of the array between these indexes\n        const samples = freqData.slice(lowIndex, highIndex);\n        return samples;\n    }\n    /**\n     * Returns the starting frequency for a given binned frequency index.\n     * @param index Array index\n     * @returns Sound frequency\n     */\n    getFrequencyAtIndex(index) {\n        const a = this.analyserNode;\n        const ctx = this.audioCtx;\n        if (a === undefined)\n            throw new Error(`Analyser not available`);\n        if (ctx === undefined)\n            throw new Error(`Audio context not available`);\n        resultThrow(integerTest(index, `positive`, `index`));\n        if (index > a.frequencyBinCount) {\n            throw new Error(`Index ${index} exceeds frequency bin count ${a.frequencyBinCount}`);\n        }\n        return (index * ctx.sampleRate) / (a.frequencyBinCount * 2);\n    }\n    /**\n     * Returns a binned array index for a given frequency\n     * @param freq Sound frequency\n     * @returns Array index into frequency bins\n     */\n    getIndexForFrequency(freq) {\n        const a = this.analyserNode;\n        if (a === undefined)\n            throw new Error(`Analyser not available`);\n        const nyquist = a.context.sampleRate / 2;\n        const index = Math.round((freq / nyquist) * a.frequencyBinCount);\n        if (index < 0)\n            return 0;\n        if (index >= a.frequencyBinCount)\n            return a.frequencyBinCount - 1;\n        return index;\n    }\n}\n","import { resolveEl } from \"@ixfx/dom\";\nimport { shortGuid } from \"@ixfx/random\";\n/**\n * Scans page for <AUDIO> elements and creates playable controllers for them.\n * It uses the element's 'id' attribute as a way of fetching one later.\n *\n * ```js\n * const ae = new AudioElements();\n * ae.init(); // Initialise\n *\n * const a = ae.get('kick'); // Get the source that had id 'kick'\n * ```\n */\nexport class AudioElements {\n    #initialised = false;\n    #sources = new Map();\n    filterType = `lowpass`;\n    constructor() { }\n    init() {\n        if (this.#initialised)\n            return;\n        this.#initialised = true;\n        for (const element of document.querySelectorAll(`audio`)) {\n            this.#sources.set(element.id, createFromAudioElement(element, this.filterType));\n        }\n    }\n    /**\n     * Gets a BasicAudio instance by key\n     * @param key\n     * @returns BasicAudio instance, or undefined\n     */\n    get(key) {\n        this.init();\n        return this.#sources.get(key);\n    }\n}\n/**\n * Create a BasicAudioElement instance from an <AUDIO> tag in the HTML document.\n *\n * See {@link AudioElements} to automatically create sources from all <AUDIO> elements.\n * @param audioElementOrQuery Element or query (eg '#some-id')\n * @param filterType Filter type. Defaults to 'lowpass'\n * @returns\n */\nexport function createFromAudioElement(audioElementOrQuery, filterType = `lowpass`) {\n    const el = resolveEl(audioElementOrQuery);\n    const context = new AudioContext();\n    // Source from AUDIO element\n    const source = context.createMediaElementSource(el);\n    // Create stereo panner\n    const pan = context.createStereoPanner();\n    // Create gain node\n    const gain = context.createGain();\n    // Create filter\n    const filter = context.createBiquadFilter();\n    filter.type = filterType;\n    // Patch in\n    // AUDIO elem -> gain -> panner -> speakers\n    source.connect(gain);\n    gain.connect(pan);\n    pan.connect(filter);\n    filter.connect(context.destination);\n    return {\n        pan, gain, filter,\n        id: el.id,\n        ctx: context,\n        el\n    };\n}\n","import { shortGuid } from \"@ixfx/random\";\n/**\n * Initialise audio with an oscillator source\n * @param oscillatorOptions\n * @returns BasicAudio instance\n */\nexport function createOscillator(oscillatorOptions = {}) {\n    const context = new AudioContext();\n    const oscType = oscillatorOptions.type ?? `sawtooth`;\n    const oscFreq = oscillatorOptions.frequency ?? 440;\n    const id = oscillatorOptions.id ?? shortGuid();\n    // Source oscillator\n    const source = context.createOscillator();\n    source.type = oscType;\n    source.frequency.setValueAtTime(oscFreq, context.currentTime);\n    // Create stereo panner\n    const pan = context.createStereoPanner();\n    // Create gain node\n    const gain = context.createGain();\n    // Create filter\n    const filter = context.createBiquadFilter();\n    // Patch in\n    // Oscillator -> gain -> panner -> speakers\n    source.connect(gain);\n    gain.connect(pan);\n    pan.connect(filter);\n    filter.connect(context.destination);\n    return {\n        pan, gain, filter,\n        ctx: context,\n        osc: source,\n        id\n    };\n}\n","export * from './analyser.js';\nexport * from './visualiser.js';\nexport * from './from-audio-element.js';\nexport * from './from-oscillator.js';\n","import { deviceEval } from './espruino.js';\nimport { NordicBleDevice } from './nordic-ble-device.js';\n/**\n * An Espruino BLE-connection\n *\n * See [online demos](https://demos.ixfx.fun/io/)\n *\n * Use the `puck` function to initialise and connect to a Puck.js.\n * It must be called in a UI event handler for browser security reasons.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.puck();\n * ```\n *\n * To connect to a particular device:\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.puck({name:`Puck.js a123`});\n * ```\n *\n * Listen for events:\n * ```js\n * // Received something\n * e.addEventListener(`data`, d => console.log(d.data));\n * // Monitor connection state\n * e.addEventListener(`change`, c => console.log(`${d.priorState} -> ${d.newState}`));\n * ```\n *\n * Write to the device (note the \\n for a new line at the end of the string). This will\n * execute the code on the Espruino.\n *\n * ```js\n * e.write(`digitalPulse(LED1,1,[10,500,10,500,10]);\\n`);\n * ```\n *\n * Run some code and return result:\n * ```js\n * const result = await e.eval(`2+2\\n`);\n * ```\n */\nexport class EspruinoBleDevice extends NordicBleDevice {\n    evalTimeoutMs;\n    evalReplyBluetooth = true;\n    /**\n     * Creates instance. You probably would rather use {@link puck} to create.\n     * @param device\n     * @param opts\n     */\n    constructor(device, opts = {}) {\n        super(device, opts);\n        this.evalTimeoutMs = opts.evalTimeoutMs ?? 5 * 1000;\n    }\n    /**\n     * Writes a script to Espruino.\n     *\n     * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n     * and then the provided `code` followed by a new line.\n     *\n     * Use {@link eval} instead to execute remote code and get the result back.\n     *\n     * ```js\n     * // Eg from https://www.espruino.com/Web+Bluetooth\n     * writeScript(`\n     *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n     *  NRF.on('disconnect',()=>reset());\n     * `);\n     * ```\n     *\n     * @param code Code to send. A new line is added automatically.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async writeScript(code) {\n        this.write(`\\u0003\\u0010reset();\\n`);\n        this.write(`\\u0010${code}\\n`);\n    }\n    /**\n     * Sends some code to be executed on the Espruino. The result\n     * is packaged into JSON and sent back to your code. An exception is\n     * thrown if code can't be executed for some reason.\n     *\n     * ```js\n     * const sum = await e.eval(`2+2`);\n     * ```\n     *\n     * It will wait for a period of time for a well-formed response from the\n     * Espruino. This might not happen if there is a connection problem\n     * or a syntax error in the code being evaled. In cases like the latter,\n     * it will take up to `timeoutMs` (default 5 seconds) before we give up\n     * waiting for a correct response and throw an error.\n     *\n     * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n     * or too slowly. A default timeout can be given when creating the class.\n     *\n     * Options:\n     *  timeoutMs: Timeout for execution. 5 seconds by default\n     *  assumeExclusive If true, eval assumes all replies from controller are in response to eval. True by default\n     *  debug: If true, execution is traced via `warn` callback\n     * @param code Code to run on the Espruino.\n     * @param opts Options\n     * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n     */\n    async eval(code, opts = {}, warn) {\n        const debug = opts.debug ?? false;\n        const warnCallback = warn ?? ((m) => { this.warn(m); });\n        return deviceEval(code, opts, this, `Bluetooth.println`, debug, warnCallback);\n    }\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\n//import { type StateChangeEvent } from '../flow/StateMachineWithEvents.js';\nimport { indexOfCharCode, omitChars } from '@ixfx/core/text';\nimport { retryFunction } from '@ixfx/flow';\nimport { Codec } from './codec.js';\nimport { StringReceiveBuffer } from './string-receive-buffer.js';\nimport { StringWriteBuffer } from './string-write-buffer.js';\nimport {} from './types.js';\nimport { genericStateTransitionsInstance } from './generic-state-transitions.js';\nexport class JsonDevice extends SimpleEventEmitter {\n    states;\n    codec;\n    verboseLogging = false;\n    name;\n    connectAttempts;\n    chunkSize;\n    rxBuffer;\n    txBuffer;\n    constructor(config = {}) {\n        super();\n        // Init\n        this.verboseLogging = config.debug ?? false;\n        this.chunkSize = config.chunkSize ?? 1024;\n        this.connectAttempts = config.connectAttempts ?? 3;\n        this.name = config.name ?? `JsonDevice`;\n        // Transmit buffer\n        this.txBuffer = new StringWriteBuffer(async (data) => {\n            // When we have data to actually write to device\n            // eslint-disable-next-line @typescript-eslint/await-thenable\n            await this.writeInternal(data);\n        }, config);\n        // Receive buffer\n        this.rxBuffer = new StringReceiveBuffer((line) => {\n            this.fireEvent(`data`, { data: line });\n        });\n        this.codec = new Codec();\n        this.states = new StateMachineWithEvents(genericStateTransitionsInstance, {\n            initial: `ready`,\n        });\n        this.states.addEventListener(`change`, (event) => {\n            this.fireEvent(`change`, event);\n            this.verbose(`${event.priorState} -> ${event.newState}`);\n            if (event.priorState === `connected`) {\n                // Clear out buffers\n                this.rxBuffer.clear();\n                this.txBuffer.clear();\n            }\n        });\n    }\n    get isConnected() {\n        return this.states.state === `connected`;\n    }\n    get isClosed() {\n        return this.states.state === `closed`;\n    }\n    write(txt) {\n        if (this.states.state !== `connected`) {\n            throw new Error(`Cannot write while state is ${this.states.state}`);\n        }\n        this.txBuffer.add(txt);\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async close() {\n        if (this.states.state !== `connected`)\n            return;\n        // console.log(`rxBuffer closing`);\n        // try {\n        //   await this.rxBuffer.close();\n        // } catch (e) {\n        //   console.warn(e);\n        // }\n        // console.log(`txBuffer closing`);\n        // try {\n        //   await this.txBuffer.close();\n        // } catch (e) {\n        //   console.warn(e);\n        // }\n        // console.log(`calling onClose`);\n        this.onClosed();\n    }\n    async connect() {\n        const attempts = this.connectAttempts;\n        this.states.state = `connecting`;\n        await this.onPreConnect();\n        await retryFunction(async () => {\n            await this.onConnectAttempt();\n            this.states.state = `connected`;\n            return true;\n        }, {\n            limitAttempts: attempts,\n            startAt: 200,\n        });\n    }\n    onRx(event) {\n        //const rx = this.rx;\n        //if (rx === undefined) return;\n        const view = event.target.value;\n        if (view === undefined)\n            return;\n        let string_ = this.codec.fromBuffer(view.buffer);\n        // Check for flow control chars\n        const plzStop = indexOfCharCode(string_, 19);\n        const plzStart = indexOfCharCode(string_, 17);\n        // Remove if found\n        if (plzStart && plzStop < plzStart) {\n            this.verbose(`Tx plz start`);\n            string_ = omitChars(string_, plzStart, 1);\n            this.txBuffer.paused = false;\n        }\n        if (plzStop && plzStop > plzStart) {\n            this.verbose(`Tx plz stop`);\n            string_ = omitChars(string_, plzStop, 1);\n            this.txBuffer.paused = true;\n        }\n        this.rxBuffer.add(string_);\n    }\n    verbose(m) {\n        if (this.verboseLogging)\n            console.info(this.name, m);\n    }\n    log(m) {\n        console.log(this.name, m);\n    }\n    warn(m) {\n        console.warn(this.name, m);\n    }\n}\n","import { JsonDevice, } from './json-device.js';\n/**\n * Serial device. Assumes data is sent with new line characters (\\r\\n) between messages.\n *\n * ```\n * import { Serial } from 'https://unpkg.com/ixfx/dist/io.js'\n * const s = new Serial.Device();\n * s.addEventListener(`change`, evt => {\n *  console.log(`State change ${evt.priorState} -> ${evt.newState}`);\n *  if (evt.newState === `connected`) {\n *    // Do something when connected...\n *  }\n * });\n *\n * // In a UI event handler...\n * s.connect();\n * ```\n *\n * Reading incoming data:\n * ```\n * // Parse incoming data as JSON\n * s.addEventListener(`data`, evt => {\n *  try {\n *    const o = JSON.parse(evt.data);\n *    // If we get this far, JSON is legit\n *  } catch (ex) {\n *  }\n * });\n * ```\n *\n * Writing to the microcontroller\n * ```\n * s.write(JSON.stringify({msg:\"hello\"}));\n * ```\n */\nexport class Device extends JsonDevice {\n    config;\n    port;\n    tx;\n    abort;\n    baudRate;\n    constructor(config = {}) {\n        super(config);\n        this.config = config;\n        this.abort = new AbortController();\n        const eol = config.eol ?? `\\r\\n`;\n        this.baudRate = config.baudRate ?? 9600;\n        if (config.name === undefined)\n            this.name = `Serial.Device`;\n        // Serial.println on microcontroller == \\r\\n\n        this.rxBuffer.separator = eol;\n    }\n    /**\n     * Writes text collected in buffer\n     * @param txt\n     */\n    async writeInternal(txt) {\n        if (this.tx === undefined)\n            throw new Error(`tx not ready`);\n        try {\n            this.tx.write(txt);\n        }\n        catch (error) {\n            this.warn(error);\n        }\n    }\n    onClosed() {\n        this.tx?.releaseLock();\n        this.abort.abort(`closing port`);\n        // try {\n        //   this.port?.close();\n        // } catch (ex) {\n        //   this.warn(ex);\n        // }\n        this.states.state = `closed`;\n    }\n    onPreConnect() {\n        return Promise.resolve();\n    }\n    async onConnectAttempt() {\n        let reqOpts = {\n            filters: []\n        };\n        const openOpts = {\n            baudRate: this.baudRate,\n        };\n        if (this.config.filters)\n            reqOpts = { filters: [...this.config.filters] };\n        this.port = await navigator.serial.requestPort(reqOpts);\n        this.port.addEventListener(`disconnect`, (_) => {\n            this.close();\n        });\n        await this.port.open(openOpts);\n        const txW = this.port.writable;\n        const txText = new TextEncoderStream();\n        if (txW !== null) {\n            txText.readable\n                .pipeTo(txW, { signal: this.abort.signal })\n                .catch((error) => {\n                console.log(`Serial.onConnectAttempt txText pipe:`);\n                console.log(error);\n            });\n            this.tx = txText.writable.getWriter();\n        }\n        const rxR = this.port.readable;\n        const rxText = new TextDecoderStream();\n        if (rxR !== null) {\n            rxR\n                .pipeTo(rxText.writable, { signal: this.abort.signal })\n                .catch((error) => {\n                console.log(`Serial.onConnectAttempt rxR pipe:`);\n                console.log(error);\n            });\n            rxText.readable\n                .pipeTo(this.rxBuffer.writable(), { signal: this.abort.signal })\n                .catch((error) => {\n                console.log(`Serial.onConnectAttempt rxText pipe:`);\n                console.log(error);\n                try {\n                    this.port?.close();\n                }\n                catch (error) {\n                    console.log(error);\n                }\n            });\n        }\n    }\n}\nexport {} from './json-device.js';\n","import { deviceEval } from './espruino.js';\nimport { Device as SerialDevice } from './serial.js';\nexport class EspruinoSerialDevice extends SerialDevice {\n    evalTimeoutMs;\n    evalReplyBluetooth = false;\n    constructor(opts) {\n        super(opts);\n        if (opts === undefined)\n            opts = {};\n        this.evalTimeoutMs = opts.evalTimeoutMs ?? 5 * 1000;\n    }\n    async disconnect() {\n        return super.close();\n    }\n    /**\n     * Writes a script to Espruino.\n     *\n     * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n     * and then the provided `code` followed by a new line.\n     *\n     * Use {@link eval} instead to execute remote code and get the result back.\n     *\n     * ```js\n     * // Eg from https://www.espruino.com/Web+Bluetooth\n     * writeScript(`\n     *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n     *  NRF.on('disconnect',()=>reset());\n     * `);\n     * ```\n     *\n     * @param code Code to send. A new line is added automatically.\n     */\n    writeScript(code) {\n        this.write(`\\u0003\\u0010reset();\\n`);\n        this.write(`\\u0010${code}\\n`);\n    }\n    /**\n     * Sends some code to be executed on the Espruino. The result\n     * is packaged into JSON and sent back to your code. An exception is\n     * thrown if code can't be executed for some reason.\n     *\n     * ```js\n     * const sum = await e.eval(`2+2`);\n     * ```\n     *\n     * It will wait for a period of time for a well-formed response from the\n     * Espruino. This might not happen if there is a connection problem\n     * or a syntax error in the code being evaled. In cases like the latter,\n     * it will take up to `timeoutMs` (default 5 seconds) before we give up\n     * waiting for a correct response and throw an error.\n     *\n     * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n     * or too slowly. A default timeout can be given when creating the class.\n     *\n     * Options:\n     *  timeoutMs: Timeout for execution. 5 seconds by default\n     *  assumeExclusive: If true, eval assumes all replies from controller are in response to eval. True by default\n     *  debug: If true, execution is traced via `warn` callback\n     * @param code Code to run on the Espruino.\n     * @param opts Options\n     * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n     */\n    async eval(code, opts = {}, warn) {\n        const debug = opts.debug ?? false;\n        const warner = warn ?? ((m) => { this.warn(m); });\n        return deviceEval(code, opts, this, `USB.println`, debug, warner);\n    }\n}\n","import {} from '@ixfx/flow/state-machine';\nimport {} from '@ixfx/events';\nimport { string as randomString } from '@ixfx/random';\nimport { waitFor } from '@ixfx/flow';\nimport { EspruinoBleDevice } from './espruino-ble-device.js';\nimport { defaultOpts as NordicDefaults } from './nordic-ble-device.js';\nimport { getErrorMessage } from '@ixfx/debug';\nimport { EspruinoSerialDevice, } from './espruino-serial-device.js';\nexport { EspruinoSerialDevice } from './espruino-serial-device.js';\nexport { EspruinoBleDevice } from './espruino-ble-device.js';\n/**\n * Instantiates a Puck.js. See {@link EspruinoBleDevice} for more info.\n * [Online demos](https://demos.ixfx.fun/io/)\n *\n * If `opts.name` is specified, this will the the Bluetooth device sought.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.puck({ name:`Puck.js a123` });\n * ```\n *\n * If no name is specified, a list of all devices starting with `Puck.js` are shown.\n *\n * To get more control over filtering, pass in `opts.filter`. `opts.name` is not used as a filter in this scenario.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const filters = [\n *  { namePrefix: `Puck.js` },\n *  { namePrefix: `Pixl.js` },\n *  {services: [NordicDefaults.service] }\n * ]\n * const e = await Espruino.puck({ filters });\n * ```\n *\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const puck = async (opts = {}) => {\n    const name = opts.name ?? `Puck`;\n    const debug = opts.debug ?? false;\n    const device = await navigator.bluetooth.requestDevice({\n        filters: getFilters(opts, `Puck.js`),\n        optionalServices: [NordicDefaults.service],\n    });\n    if (opts.debug) {\n        console.info(`Espruino.puck device name: ${device.name}`);\n    }\n    const d = new EspruinoBleDevice(device, { name, debug });\n    await d.connect();\n    return d;\n};\nexport const bangle = async (opts = {}) => {\n    const name = opts.name ?? `Bangle`;\n    const debug = opts.debug ?? false;\n    const device = await navigator.bluetooth.requestDevice({\n        filters: getFilters(opts, `Bangle.js`),\n        optionalServices: [NordicDefaults.service],\n    });\n    if (opts.debug) {\n        console.info(`Espruino.bangle device name: ${device.name}`);\n    }\n    const d = new EspruinoBleDevice(device, { name, debug });\n    await d.connect();\n    return d;\n};\n/**\n * Create a serial-connected Espruino device.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruio.serial();\n * e.connect();\n * ```\n *\n * Options:\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const e = await Espruino.serial({ debug: true, evalTimeoutMs: 1000, name: `My Pico` });\n * e.connect();\n * ```\n *\n * Listen for events:\n * ```js\n * e.addEventListener(`change`, evt => {\n *  console.log(`State change ${evt.priorState} -> ${evt.newState}`);\n *  if (evt.newState === `connected`) {\n *    // Do something when connected...\n *  }\n * });\n * ```\n *\n * Reading incoming data:\n * ```\n * // Parse incoming data as JSON\n * s.addEventListener(`data`, evt => {\n *  try {\n *    const o = JSON.parse(evt.data);\n *    // If we get this far, JSON is legit\n *  } catch (ex) {\n *  }\n * });\n * ```\n *\n * Writing to the microcontroller\n * ```\n * s.write(JSON.stringify({msg:\"hello\"}));\n * ```\n * @param opts\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const serial = async (opts = {}) => {\n    const d = new EspruinoSerialDevice(opts);\n    await d.connect();\n    return d;\n};\n/**\n * Returns a list of BLE scan filters, given the\n * connect options.\n * @param opts\n * @returns\n */\nconst getFilters = (opts, defaultNamePrefix) => {\n    const filters = [];\n    if (opts.filters) {\n        filters.push(...opts.filters);\n    }\n    else if (opts.name) {\n        // Name filter\n        filters.push({ name: opts.name });\n        console.info(`Filtering Bluetooth devices by name '${opts.name}'`);\n    }\n    else {\n        // Default filter\n        filters.push({ namePrefix: defaultNamePrefix }); //`Puck.js` });\n    }\n    // {namePrefix: 'Pixl.js'},\n    // {namePrefix: 'MDBT42Q'},\n    // {namePrefix: 'RuuviTag'},\n    // {namePrefix: 'iTracker'},\n    // {namePrefix: 'Thingy'},\n    // {namePrefix: 'Bangle.js'},\n    // {namePrefix: 'Espruino'},\n    //{services: [NordicDefaults.service]}\n    return filters;\n};\n/**\n * Connects to a generic Espruino BLE device. See  {@link EspruinoBleDevice} for more info.\n * Use {@link puck} if you're connecting to a Puck.js\n *\n * If `opts.name` is specified, only this BLE device will be shown.\n * ```js\n * const e = await connectBle({ name: `Puck.js a123` });\n * ```\n *\n * `opts.filters` overrides and sets arbitary filters.\n *\n * ```js\n * import { Espruino } from 'https://unpkg.com/ixfx/dist/io.js'\n * const filters = [\n *  { namePrefix: `Puck.js` },\n *  { namePrefix: `Pixl.js` },\n *  {services: [NordicDefaults.service] }\n * ]\n * const e = await Espruino.connectBle({ filters });\n * ```\n *\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const connectBle = async (opts = {}) => {\n    const device = await navigator.bluetooth.requestDevice({\n        filters: getFilters(opts, `Puck.js`),\n        optionalServices: [NordicDefaults.service],\n    });\n    const d = new EspruinoBleDevice(device, { name: `Espruino`, ...opts });\n    await d.connect();\n    return d;\n};\n/**\n * Evaluates some code on an Espruino device.\n *\n * Options:\n * * timeoutMs: how many millis to wait before assuming code failed. If not specified, `device.evalTimeoutMs` is used as a default.\n * * assumeExlusive: assume device is not producing any other output than for our evaluation\n *\n * A random string is created to pair eval requests and responses. `code` will be run on the device, with the result\n * wrapped in JSON, and in turn wrapped in a object that is sent back.\n *\n * The actual code that gets sent to the device is then:\n * `\\x10${evalReplyPrefix}(JSON.stringify({reply:\"${id}\", result:JSON.stringify(${code})}))\\n`\n *\n * For example, it might end up being:\n * `\\x10Bluetooth.println(JSON.stringify({reply: \"a35gP\", result: \"{ 'x': '10' }\" }))\\n`\n *\n * @param code Code to evaluation\n * @param opts Options for evaluation\n * @param device Device to execute on\n * @param evalReplyPrefix How to send code back (eg `Bluetooth.println`, `console.log`)\n * @param debug If true, the full evaled code is printed locally to the console\n * @param warn Callback to display warnings\n * @returns\n */\nexport const deviceEval = async (code, opts = {}, device, evalReplyPrefix, debug, warn) => {\n    const timeoutMs = opts.timeoutMs ?? device.evalTimeoutMs;\n    const assumeExclusive = opts.assumeExclusive ?? true;\n    if (typeof code !== `string`) {\n        throw new TypeError(`Param 'code' should be a string. Got: ${typeof code}`);\n    }\n    return new Promise((resolve, reject) => {\n        // Generate a random id so reply can be matched up with this request\n        const id = randomString(5);\n        const onData = (d) => {\n            try {\n                let cleaned = d.data.trim();\n                // Prefixed with angled bracket sometimes?\n                if (cleaned.startsWith(`>{`) && cleaned.endsWith(`}`)) {\n                    cleaned = cleaned.slice(1);\n                }\n                // Parse reply, expecting JSON.\n                const dd = JSON.parse(cleaned);\n                // Check for reply field, and that it matches\n                if (`reply` in dd) {\n                    if (dd.reply === id) {\n                        done(); // Stop waiting for result\n                        if (`result` in dd) {\n                            resolve(dd.result);\n                        }\n                    }\n                    else {\n                        warn(`Expected reply ${id}, got ${dd.reply}`);\n                    }\n                }\n                else {\n                    warn(`Expected packet, missing 'reply' field. Got: ${d.data}`);\n                }\n            }\n            catch (error) {\n                // If there was a syntax error, response won't be JSON\n                if (assumeExclusive) {\n                    // Fail with unexpected reply as the message\n                    done(`Unexpected reply: ${d.data}. Error: ${getErrorMessage(error)}`);\n                }\n                else {\n                    // Unexpected reply, but we cannot be sure if it's in response to eval or\n                    // some other code running on board. So just warn and eventually timeout\n                    warn(getErrorMessage(error));\n                }\n            }\n        };\n        const onStateChange = (event) => {\n            if (event.newState !== `connected`) {\n                done(`State changed to '${event.newState}', aborting`);\n            }\n        };\n        device.addEventListener(`data`, onData);\n        device.addEventListener(`change`, onStateChange);\n        // Init waitFor\n        const done = waitFor(timeoutMs, (reason) => {\n            reject(new Error(reason));\n        }, (_success) => {\n            // If we got a response or there was a timeout, remove event listeners\n            device.removeEventListener(`data`, onData);\n            device.removeEventListener(`change`, onStateChange);\n        });\n        const source = `\\u0010${evalReplyPrefix}(JSON.stringify({reply:\"${id}\", result:JSON.stringify(${code})}))\\n`;\n        if (debug)\n            warn(source);\n        device.write(source);\n    });\n};\n","import { waitFor } from '@ixfx/flow';\nimport { getErrorMessage } from '@ixfx/debug';\nconst startTimeoutMs = 10_000;\n/**\n * Print available media devices to console\n *\n * ```js\n * import { Camera } from 'https://unpkg.com/ixfx/dist/io.js'\n * camera.dumpDevices(); // Will print results to console\n * ```\n * @param filterKind Defaults `videoinput`\n */\nexport const dumpDevices = async (filterKind = `videoinput`) => {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    for (const d of devices) {\n        if (d.kind !== filterKind)\n            continue;\n        console.log(d.label);\n        console.log(` Kind: ${d.kind}`);\n        console.log(` Device id: ${d.deviceId}`);\n    }\n};\n/**\n * Attempts to start a video-only stream from a camera into a hidden\n * VIDEO element for frame capture. The VIDEO element is created automatically.\n *\n *\n * ```js\n * import { Camera } from 'https://unpkg.com/ixfx/dist/io.js'\n * import { Video } from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * try {\n *  const { videoEl, dispose } = await Camera.start();\n *  for await (const frame of Video.frames(videoEl)) {\n *    // Do something with pixels...\n *  }\n * } catch (ex) {\n *  console.error(`Video could not be started`);\n * }\n * ```\n *\n * Be sure to call the dispose() function to stop the video stream and remov\n * the created VIDEO element.\n *\n * _Constraints_ can be specified to select a camera and resolution:\n * ```js\n * import { Camera } from 'https://unpkg.com/ixfx/dist/io.js'\n * import { Video } from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * try {\n *  const { videoEl, dispose } = await Camera.start({\n *    facingMode: `environment`,\n *    max: { width: 640, height: 480 }\n *  });\n *\n *  for await (const frame of Video.frames(videoEl)) {\n *    // Do something with pixels...\n *  }\n * } catch (ex) {\n *  // Can happen if user cancels camera request, for example.\n *  console.error(`Video could not be started`, ex);\n * }\n * ```\n *\n * An alternative to Video.frames is Video.capture.\n * @param constraints\n * @returns Returns `{ videoEl, dispose }`, where `videoEl` is the created VIDEO element, and `dispose` is a function for removing the element and stopping the video.\n */\nexport const start = async (constraints = {}) => {\n    const videoEl = document.createElement(`VIDEO`);\n    //eslint-disable-next-line functional/immutable-data\n    videoEl.style.display = `none`;\n    //eslint-disable-next-line functional/immutable-data\n    videoEl.playsInline = true;\n    //eslint-disable-next-line functional/immutable-data\n    videoEl.muted = true;\n    videoEl.classList.add(`ixfx-camera`);\n    document.body.append(videoEl);\n    //eslint-disable-next-line functional/no-let\n    let stopVideo = () => {\n        /* no-op */\n    };\n    const dispose = () => {\n        try {\n            // Stop source\n            stopVideo();\n        }\n        catch {\n            /* no-op */\n        }\n        // Remove the element we created\n        videoEl.remove();\n    };\n    try {\n        // Attempt to start video\n        const r = await startWithVideoEl(videoEl, constraints);\n        stopVideo = r.dispose;\n        return { videoEl, dispose };\n    }\n    catch (error) {\n        // If it didn't work, delete the created element\n        console.error(error);\n        dispose();\n        throw error;\n    }\n};\n/**\n * Attempts to start a video-only stream from a camera into the designated VIDEO element.\n * @param videoEl\n * @param constraints\n * @returns Result contains videoEl and dispose function\n */\nconst startWithVideoEl = async (videoEl, constraints = {}) => {\n    if (videoEl === undefined)\n        throw new Error(`videoEl undefined`);\n    if (videoEl === null)\n        throw new Error(`videoEl null`);\n    const maxResolution = constraints.max;\n    const minResolution = constraints.min;\n    const idealResolution = constraints.ideal;\n    // Setup constraints\n    const c = {\n        audio: false,\n        video: {\n            width: {},\n            height: {},\n        },\n    };\n    // Just in case some intuitive values are passed in...\n    if (constraints.facingMode === `front`) {\n        constraints = { ...constraints, facingMode: `user` };\n    }\n    if (constraints.facingMode === `back`) {\n        constraints = { ...constraints, facingMode: `environment` };\n    }\n    if (constraints.facingMode) {\n        c.video.facingMode = constraints.facingMode;\n    }\n    if (constraints.deviceId) {\n        c.video.deviceId = constraints.deviceId;\n    }\n    if (idealResolution) {\n        c.video.width = {\n            ...c.video.width,\n            ideal: idealResolution.width,\n        };\n        c.video.height = {\n            ...c.video.height,\n            ideal: idealResolution.height,\n        };\n    }\n    if (maxResolution) {\n        c.video.width = {\n            ...c.video.width,\n            max: maxResolution.width,\n        };\n        c.video.height = {\n            ...c.video.height,\n            max: maxResolution.height,\n        };\n    }\n    if (minResolution) {\n        c.video.width = {\n            ...c.video.width,\n            min: minResolution.width,\n        };\n        c.video.height = {\n            ...c.video.height,\n            min: minResolution.height,\n        };\n    }\n    // Request stream\n    const done = waitFor(constraints.startTimeoutMs ?? startTimeoutMs, (reason) => {\n        throw new Error(`Camera getUserMedia failed: ${reason}`);\n    });\n    try {\n        const stream = await navigator.mediaDevices.getUserMedia(c);\n        // Clean-up function\n        const dispose = () => {\n            videoEl.pause();\n            const t = stream.getTracks();\n            for (const track of t)\n                track.stop();\n        };\n        // Assign to VIDEO element\n        //eslint-disable-next-line functional/immutable-data\n        videoEl.srcObject = stream;\n        done();\n        const returnValue = { videoEl, dispose };\n        const p = new Promise((resolve, reject) => {\n            videoEl.addEventListener(`loadedmetadata`, () => {\n                videoEl\n                    .play()\n                    .then(() => {\n                    resolve(returnValue);\n                })\n                    .catch((error) => {\n                    reject(error);\n                });\n            });\n        });\n        return p;\n    }\n    catch (error) {\n        done(getErrorMessage(error));\n        throw error;\n    }\n};\n","/**\n * Starts video file playback, creating a VIDEO element automatically.\n * @param file File\n * @returns StartResult\n */\nexport const start = async (file) => {\n    const videoEl = document.createElement(`VIDEO`);\n    videoEl.style.display = `none`;\n    videoEl.playsInline = true;\n    videoEl.muted = true;\n    videoEl.classList.add(`ixfx-video`);\n    document.body.appendChild(videoEl);\n    //eslint-disable-next-line functional/no-let\n    let stopVideo = () => {\n        /* no-op */\n    };\n    const dispose = () => {\n        try {\n            // Stop source\n            stopVideo();\n        }\n        catch {\n            /* no-op */\n        }\n        // Remove the element we created\n        videoEl.remove();\n    };\n    try {\n        // Attempt to start video\n        const r = await startWithVideoEl(videoEl, file);\n        stopVideo = r.dispose;\n        return { videoEl, dispose };\n    }\n    catch (ex) {\n        // If it didn't work, delete the created element\n        console.error(ex);\n        dispose();\n        throw ex;\n    }\n};\n/**\n * Starts playback of a video file in the provided VIDEO element.\n * @param videoEl\n * @param file\n * @returns\n */\nconst startWithVideoEl = async (videoEl, file) => {\n    if (videoEl === undefined)\n        throw new Error(`videoEl undefined`);\n    if (videoEl === null)\n        throw new Error(`videoEl null`);\n    const url = URL.createObjectURL(file);\n    videoEl.src = url;\n    videoEl.loop = true;\n    // Clean-up function\n    const dispose = () => {\n        videoEl.pause();\n    };\n    const returnValue = { videoEl, dispose };\n    const p = new Promise((resolve, reject) => {\n        videoEl.addEventListener(`loadedmetadata`, () => {\n            videoEl\n                .play()\n                .then(() => {\n                resolve(returnValue);\n            })\n                .catch((ex) => {\n                reject(ex);\n            });\n        });\n    });\n    return p;\n};\n","import { continuously } from '@ixfx/core';\nimport { delayLoop } from '@ixfx/flow';\n\nexport type Capturer = {\n  start(): void;\n  cancel(): void;\n  readonly canvasEl: HTMLCanvasElement;\n};\n\nexport type ManualCapturer = {\n  capture(): ImageData;\n  readonly canvasEl: HTMLCanvasElement;\n  dispose(): void;\n};\n\nexport type CaptureOpts = {\n  /**\n   * Delay between reading frames.\n   * Default: 0, reading as fast as possible\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * Whether to show the created capture canvas.\n   * Default: false\n   */\n  readonly showCanvas?: boolean;\n  readonly workerScript?: string;\n  readonly onFrame?: (pixels: ImageData) => void;\n};\n\nexport type ManualCaptureOpts = {\n  /**\n   * If true, the intermediate canvas is shown\n   * The intermediate canvas is where captures from the source are put in order\n   * to get the ImageData\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * If specified, this is the canvas captured to\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Options for frames generator\n */\nexport type FramesOpts = {\n  /**\n   * Max frame rate (millis per frame), or 0 for animation speed\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * False by default, created canvas will be hidden\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If provided, this canvas will be used as the buffer rather than creating one.\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import { Video } from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\n\nexport async function* frames(\n  sourceVideoEl: HTMLVideoElement,\n  opts: FramesOpts = {}\n): AsyncIterable<ImageData> {\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n\n  const showCanvas = opts.showCanvas ?? false;\n  let canvasEl = opts.canvasEl;\n  let w, h;\n  w = h = 0;\n\n  // Create & setup canvas\n  if (canvasEl === undefined) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-frames`);\n    if (!showCanvas) {\n      canvasEl.style.display = `none`;\n    }\n    document.body.appendChild(canvasEl);\n  }\n\n  // Update size of canvas based on video\n  const updateSize = () => {\n    if (canvasEl === undefined) return;\n    w = sourceVideoEl.videoWidth;\n    h = sourceVideoEl.videoHeight;\n    canvasEl.width = w;\n    canvasEl.height = h;\n  };\n\n  let c: CanvasRenderingContext2D | null = null;\n\n  const looper = delayLoop(maxIntervalMs);\n  for await (const _ of looper) {\n    // If we don't yet have the size of video, get it\n    if (w === 0 || h === 0) updateSize();\n\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n    if (w === 0 || h === 0) continue;\n\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    // Get pixels\n    const pixels = c.getImageData(0, 0, w, h);\n    yield pixels;\n  }\n}\n\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: CaptureOpts = {}\n): Capturer => {\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  const showCanvas = opts.showCanvas ?? false;\n  const onFrame = opts.onFrame;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n  canvasEl.classList.add(`ixfx-capture`);\n\n  if (!showCanvas) {\n    canvasEl.style.display = `none`;\n  }\n  canvasEl.width = w;\n  canvasEl.height = h;\n  let c: CanvasRenderingContext2D | null = null;\n  let worker: Worker | undefined;\n  if (opts.workerScript) {\n    worker = new Worker(opts.workerScript);\n  }\n\n  // Should we get image data?\n  const getPixels = worker || onFrame;\n  if (!getPixels && !showCanvas) {\n    console.warn(\n      `Video will be captured to hidden element without any processing. Is this what you want?`\n    );\n  }\n\n  const loop = continuously(() => {\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n    let pixels: ImageData | undefined;\n\n    if (getPixels) {\n      // ImageData necessary\n      pixels = c.getImageData(0, 0, w, h);\n    }\n\n    if (worker) {\n      // Send to worker\n      worker.postMessage(\n        {\n          pixels: pixels!.data.buffer,\n          width: w,\n          height: h,\n          channels: 4,\n        },\n        [ pixels!.data.buffer ]\n      );\n    }\n    if (onFrame) {\n      // Send to callback\n      try {\n        onFrame(pixels!);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, maxIntervalMs);\n\n  return {\n    start: () => { loop.start(); },\n    cancel: () => { loop.cancel(); },\n    canvasEl,\n  };\n};\n\nexport const manualCapture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: ManualCaptureOpts = {}\n): ManualCapturer => {\n  const showCanvas = opts.showCanvas ?? false;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas if necessary\n  const definedCanvasEl = opts.canvasEl !== undefined;\n  let canvasEl = opts.canvasEl;\n  if (!canvasEl) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-capture`);\n    document.body.append(canvasEl);\n    if (!showCanvas) canvasEl.style.display = `none`;\n  }\n\n  canvasEl.width = w;\n  canvasEl.height = h;\n\n  const capture = (): ImageData => {\n    let c: CanvasRenderingContext2D | undefined | null;\n\n    // Draw current frame from video element to canvas\n    if (!c) c = canvasEl.getContext(`2d`, { willReadFrequently: true });\n    if (!c) throw new Error(`Could not create graphics context`);\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    const pixels = c.getImageData(0, 0, w, h);\n\n    (pixels as any).currentTime = sourceVideoEl.currentTime;\n\n    if (opts.postCaptureDraw) opts.postCaptureDraw(c, w, h);\n    return pixels;\n  };\n\n  const dispose = (): void => {\n    if (definedCanvasEl) return; // we didn't create it\n    try {\n      canvasEl.remove();\n    } catch (_) {\n      // no-op\n    }\n  };\n\n  const c: ManualCapturer = {\n    canvasEl,\n    capture,\n    dispose,\n  };\n  return c;\n};\n","import { Video } from '@ixfx/visual';\nimport * as Camera from './camera.js';\nimport * as VideoFile from './video-file.js';\n/**\n * Frame Processor\n * Simplifies grabbing frames from a camera or video file.\n *\n * First, create:\n * ```js\n * import { FrameProcessor } from 'https://unpkg.com/ixfx/dist/io.js'\n * const fp = new FrameProcessor();\n * ```\n *\n * Then either use the camera or a video file:\n * ```js\n * fp.useCamera(constraints);\n * // or:\n * gp.useVideo(file);\n * ```\n *\n * With `useCamera`, optionally specify {@link Io.Camera.Constraints} to pick which camera and resolution.\n *\n * ```js\n * fp.getFrame(); // Gets the last frame\n * fp.dispose(); // Close down camera/file\n * ```\n *\n * See {@link FrameProcessorOpts} for details on available options.\n */\nexport class FrameProcessor {\n    _source;\n    _state;\n    _teardownNeeded = false;\n    _cameraConstraints;\n    _cameraStartResult;\n    _videoSourceCapture;\n    _videoFile;\n    _videoStartResult;\n    _showCanvas;\n    _showPreview;\n    _postCaptureDraw;\n    _timer;\n    _captureCanvasEl;\n    /**\n     * Create a new frame processor\n     * @param opts\n     */\n    constructor(opts = {}) {\n        this._state = `ready`;\n        this._source = ``;\n        this._timer = performance.now();\n        this._showCanvas = opts.showCanvas ?? false;\n        this._showPreview = opts.showPreview ?? false;\n        this._cameraConstraints = opts.cameraConstraints ?? undefined;\n        this._captureCanvasEl = opts.captureCanvasEl ?? undefined;\n        this._postCaptureDraw = opts.postCaptureDraw;\n    }\n    /**\n     * Hides or shows the raw source in the DOM\n     * @param enabled Preview enabled\n     */\n    showPreview(enabled) {\n        if (this._state === `disposed`)\n            throw new Error(`Disposed`);\n        //eslint-disable-next-line functional/no-let\n        let el;\n        switch (this._source) {\n            case `camera`: {\n                el = this._cameraStartResult?.videoEl;\n                if (el !== undefined)\n                    el.style.display = enabled ? `block` : `none`;\n                break;\n            }\n        }\n        this._showPreview = enabled;\n    }\n    /**\n     * Shows or hides the Canvas we're capturing to\n     * @param enabled\n     */\n    showCanvas(enabled) {\n        if (this._state === `disposed`)\n            throw new Error(`Disposed`);\n        //eslint-disable-next-line functional/no-let\n        let el;\n        if (this._source === `camera` || this._source === `video`) {\n            el = this._videoSourceCapture?.canvasEl;\n            if (el !== undefined)\n                el.style.display = enabled ? `block` : `none`;\n        }\n        else\n            throw new Error(`Source not implemented: ${this._source}`);\n        this._showCanvas = enabled;\n    }\n    /**\n     * Returns the current capturer instance\n     * @returns\n     */\n    getCapturer() {\n        if (this._state === `disposed`)\n            throw new Error(`Disposed`);\n        if (this._source === `camera` || this._source === `video`) {\n            return this._videoSourceCapture;\n        }\n        throw new Error(`Source kind not supported ${this._source}`);\n    }\n    /**\n     * Grab frames from a video camera source and initialises\n     * frame processor.\n     *\n     * If `constraints` are not specified, it will use the ones\n     * provided when creating the class, or defaults.\n     *\n     * @param constraints Override of constraints when requesting camera access\n     */\n    async useCamera(constraints) {\n        if (this._state === `disposed`)\n            throw new Error(`Disposed`);\n        this._source = `camera`;\n        if (this._teardownNeeded)\n            this.teardown();\n        if (constraints)\n            this._cameraConstraints;\n        await this.init();\n    }\n    async useVideo(file) {\n        if (this._state === `disposed`)\n            throw new Error(`Disposed`);\n        this._source = `video`;\n        if (this._teardownNeeded)\n            this.teardown();\n        this._videoFile = file;\n        await this.init();\n    }\n    /**\n     * Initialises camera\n     */\n    async initCamera() {\n        const r = await Camera.start(this._cameraConstraints);\n        if (r === undefined)\n            throw new Error(`Could not start camera`);\n        this._cameraStartResult = r;\n        this.postInit(r);\n    }\n    async initVideo() {\n        if (!this._videoFile)\n            throw new Error(`Video file not defined`);\n        const r = await VideoFile.start(this._videoFile);\n        this._videoStartResult = r;\n        this.postInit(r);\n    }\n    async postInit(r) {\n        if (this._showPreview)\n            r.videoEl.style.display = `block`;\n        // Set up manual capturer\n        this._videoSourceCapture = Video.manualCapture(r.videoEl, {\n            postCaptureDraw: this._postCaptureDraw,\n            showCanvas: this._showCanvas,\n            canvasEl: this._captureCanvasEl,\n        });\n        this._teardownNeeded = true;\n        this._cameraStartResult = r;\n    }\n    /**\n     * Closes down connections and removes created elements.\n     * Once disposed, the frame processor cannot be used\n     * @returns\n     */\n    dispose() {\n        if (this._state === `disposed`)\n            return;\n        this.teardown();\n        this._state = `disposed`;\n    }\n    async init() {\n        this._timer = performance.now();\n        switch (this._source) {\n            case `camera`: {\n                await this.initCamera();\n                break;\n            }\n            case `video`: {\n                await this.initVideo();\n                break;\n            }\n        }\n        this._state = `initialised`;\n    }\n    teardown() {\n        if (!this._teardownNeeded)\n            return;\n        if (this._source === `camera` || this._source === `video`) {\n            this._videoSourceCapture?.dispose();\n        }\n        switch (this._source) {\n            case `camera`: {\n                this._cameraStartResult?.dispose();\n                break;\n            }\n            case `video`: {\n                this._videoStartResult?.dispose();\n                break;\n            }\n        }\n        this._teardownNeeded = false;\n    }\n    /**\n     * Get the last frame\n     * @returns\n     */\n    getFrame() {\n        if (this._state === `disposed`)\n            throw new Error(`Disposed`);\n        switch (this._source) {\n            case `camera`: {\n                return this.getFrameCamera();\n            }\n            case `video`: {\n                return this.getFrameCamera();\n            }\n            default: {\n                throw new Error(`source type unhandled ${this._source}`);\n            }\n        }\n    }\n    /**\n     * Get the timestamp of the processor (elapsed time since starting)\n     * @returns\n     */\n    getTimestamp() {\n        return performance.now() - this._timer;\n    }\n    getFrameCamera() {\n        return this._videoSourceCapture?.capture();\n    }\n}\n","import { retryTask } from \"@ixfx/flow\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { eventRace } from \"@ixfx/events\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\nimport { getErrorMessage } from \"@ixfx/debug\";\n/**\n * Maintains a web socket connection. Connects automatically.\n *\n * The essential usage is:\n * ```js\n * import { reconnectingWebsocket } from 'https://unpkg.com/ixfx/dist/io.js'\n * const ws = reconnectingWebsocket(`wss://somehost.com/ws`, {\n *  onMessage: (msg) => {\n *    // Do something with received message...\n *  }\n * }\n *\n * // Send some data\n * ws.send(JSON.stringify(someData));\n *\n * // Check state of connection\n * ws.isConnected();\n * ```\n *\n * More options can be provided to monitor state\n * ```js\n * import { reconnectingWebsocket } from 'https://unpkg.com/ixfx/dist/io.js'\n * const ws = reconnectingWebsocket(`wss://somehost.com/ws`, {\n *  onError: (err) => {\n *    console.error(err)\n *  },\n *  onMessage: (msg) => {\n *    // Received data\n *    console.log(msg);\n *  },\n *  onConnected: () => {\n *    // Connected!\n *  },\n *  onDisconnected: () => {\n *    // Disconnected :(\n *  }\n * });\n * ```\n * @param url\n * @param opts\n * @returns\n */\nexport const reconnectingWebsocket = (url, opts = {}) => {\n    const startDelayMs = intervalToMs(opts.startDelay, 2000);\n    const maxDelayMs = intervalToMs(opts.maxDelay, startDelayMs * 10);\n    const checkStateMs = intervalToMs(opts.checkStateMs, 5000);\n    if (startDelayMs > maxDelayMs)\n        throw new Error(`startDelay should be less than maxDelay`);\n    if (checkStateMs < 0)\n        throw new Error(`Param 'checkState' should be above zero`);\n    let reconnect = true;\n    let currentState = StateMachine.init({\n        closed: `connecting`,\n        open: `closed`,\n        connecting: [`closed`, `open`]\n    }); //`closed`;\n    let ws;\n    const onError = (event_) => {\n        if (opts.onError) {\n            opts.onError(event_);\n        }\n        else {\n            console.log(`rw on error`, event_);\n            console.error(` error: ${event_.error}`);\n            console.error(` type: ${event_.type}`);\n            console.error(` error msg: ${event_.message}`);\n        }\n    };\n    const onMessage = (message) => {\n        if (opts.onMessage)\n            opts.onMessage(message.data);\n    };\n    const connect = async () => {\n        if (currentState.value === `connecting`)\n            throw new Error(`Cannot connect twice`);\n        currentState = StateMachine.to(currentState, `connecting`);\n        if (ws !== undefined) {\n            ws.removeEventListener(`error`, onError);\n            if (opts.onMessage) {\n                ws.removeEventListener(`message`, onMessage);\n            }\n            ws = undefined;\n        }\n        // Keep trying to connect\n        const retry = await retryTask({\n            async probe(_attempts) {\n                try {\n                    const wss = new WebSocket(url);\n                    const r = await eventRace(wss, [`open`, `error`], { timeoutMs: 1000 });\n                    return r.type === `open` ? { success: true, value: wss } : { success: false, error: `Could not open` };\n                }\n                catch (error) {\n                    return { success: false, error: getErrorMessage(error) };\n                }\n            },\n        }, { predelayMs: startDelayMs, limitAttempts: opts.limitAttempts });\n        // Final result\n        ws = retry.value;\n        let result = false;\n        if (retry.success && ws) {\n            //      ws.addEventListener(`error`, onError);\n            if (opts.onMessage) {\n                //        ws.addEventListener(`message`, onMessage);\n            }\n            result = true;\n            currentState = StateMachine.to(currentState, `open`);\n            if (opts.onConnected)\n                opts.onConnected();\n        }\n        else {\n            currentState = StateMachine.to(currentState, `closed`);\n        }\n        return result;\n    };\n    const send = (data) => {\n        if (ws) {\n            if (ws.readyState === ws.OPEN) {\n                ws.send(data);\n            }\n            else {\n                onDisconnected();\n            }\n        }\n        else {\n            throw new Error(`Not connected`);\n        }\n    };\n    const onDisconnected = () => {\n        if (currentState.value === `closed`)\n            return;\n        if (currentState.value === `open`) {\n            currentState = StateMachine.to(currentState, `closed`);\n            if (opts.onDisconnected)\n                opts.onDisconnected();\n        }\n        if (reconnect && currentState.value !== `connecting`) {\n            console.log(`Scheduling connect`);\n            setTimeout(() => {\n                void connect();\n            }, 100);\n        }\n    };\n    const isConnected = () => {\n        if (!ws)\n            return false;\n        return ws.readyState === ws.OPEN;\n    };\n    const close = () => {\n        reconnect = false;\n        currentState = StateMachine.to(currentState, `closed`);\n        ws?.close();\n        if (opts.onDisconnected)\n            opts.onDisconnected();\n    };\n    const open = () => {\n        reconnect = true;\n        if (currentState.value === `open`)\n            return Promise.resolve(true);\n        if (currentState.value === `connecting`)\n            return Promise.resolve(false);\n        return connect();\n    };\n    void connect();\n    setInterval(() => {\n        if (!ws)\n            return;\n        switch (ws.readyState) {\n            case ws.CLOSED: {\n                if (currentState.value === `open`) {\n                    onDisconnected();\n                }\n                break;\n            }\n        }\n    }, checkStateMs);\n    return { send, isConnected, close, open };\n};\n","export * from '@ixfx/io';"],"mappings":"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"}