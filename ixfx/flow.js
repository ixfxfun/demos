import{h as e,n as t,z as n}from"./src-DdJCbM4z.js";import{a as r,y as i}from"./numbers-BlBexQl9.js";import{n as a}from"./logger-o11drWM0.js";import{n as o}from"./queue-mutable-DkFlFSVY.js";import{t as s}from"./simple-event-emitter-DdjYDCSw.js";import{n as c}from"./moving-average-CQgRiq9V.js";import{n as l,t as u}from"./delay-Bc8RsQAS.js";import{t as d}from"./timeout-BnV_k5ts.js";import{a as f,i as p,n as m,o as h,r as g,t as _}from"./wait-for-Dri4FnkY.js";import{t as v}from"./dispatch-list-Cg3WNfvI.js";import{a as y,o as b,t as x}from"./state-machine-C0DUbIyp.js";import{a as S,c as C,d as w,f as T,i as E,l as D,n as O,o as k,r as A,s as j,t as M,u as N}from"./timer-DaWe-yIt.js";const P=(e,t=``)=>typeof e==`object`&&`name`in e&&e.name!==void 0?e.name:t;function*F(e,t){t===void 0&&(t=P(e));for(let[n,r]of R(e))yield[r,t];for(let[n,r]of R(e)){let e=P(r,`?`);yield*F(r,t.length>0?t+`.`+e:e)}}function*I(e,t){t===void 0&&(t=P(e));for(let[n,r]of R(e)){yield[r,t];let e=P(r,`?`);yield*F(r,t.length>0?t+`.`+e:e)}}function ee(e){return e.seq!==void 0}function L(e){return e.sel!==void 0}function*R(e){if(ee(e))yield*e.seq.entries();else if(L(e))yield*e.sel.entries();else if(typeof e!=`string`)throw TypeError(`Unexpected shape of node. seq/sel missing`)}const z=(e,t)=>{i(r(e,`positive`,`nth`));let n=0;return r=>(n++,n===e?(n=0,t&&t(r),!0):!1)},B=e=>{let t=c(),n=K({...e,whatToCall:e=>{t(e)},fallback(){return e.default??0}});return e=>(n(e),t())};var V=class extends s{_lastUpdate;_pool;_state;_userExpireAfterMs;constructor(e,t){super(),this.key=e,this.resource=t,this._lastUpdate=performance.now(),this._pool=t.pool,this._userExpireAfterMs=this._pool.userExpireAfterMs,this._state=`idle`,this._pool.log.log(`PoolUser ctor key: ${this.key}`)}toString(){return this.isDisposed?`PoolUser. State: disposed`:`PoolUser. State: ${this._state} Elapsed: ${performance.now()-this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`}keepAlive(){if(this._state===`disposed`)throw Error(`PoolItem disposed`);this._lastUpdate=performance.now()}_dispose(e,t){if(this._state===`disposed`)return;let n=this.resource;this._state=`disposed`,n._release(this),this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${e}`),this.fireEvent(`disposed`,{data:t,reason:e}),super.clearEventListeners()}release(e){if(this.isDisposed)throw Error(`User disposed`);let t=this.resource.data;this._pool.log.log(`PoolUser release key: ${this.key} reason: ${e}`),this.fireEvent(`released`,{data:t,reason:e}),this._dispose(`release-${e}`,t)}get data(){if(this.isDisposed)throw Error(`User disposed`);return this.resource.data}get isExpired(){return this._userExpireAfterMs>0?performance.now()>this._lastUpdate+this._userExpireAfterMs:!1}get elapsed(){return performance.now()-this._lastUpdate}get isDisposed(){return this._state===`disposed`}get isValid(){return!(this.isDisposed||this.isExpired||this.resource.isDisposed)}},H=class{#e;#t;#n;#r;#i;#a;constructor(e,t){if(this.pool=e,t===void 0)throw Error(`Parameter 'data' is undefined`);if(e===void 0)throw Error(`Parameter 'pool' is undefined`);this.#t=t,this.#a=0,this.#i=e.resourcesWithoutUserExpireAfterMs,this.#r=e.capacityPerResource,this.#n=[],this.#e=`idle`}get data(){if(this.#e===`disposed`)throw Error(`Resource disposed`);return this.#t}updateData(e){if(this.#e===`disposed`)throw Error(`Resource disposed`);if(e===void 0)throw Error(`Parameter 'data' is undefined`);this.#t=e}toString(){return`Resource (expired: ${this.isExpiredFromUsers} users: ${this.#n.length}, state: ${this.#e}) data: ${JSON.stringify(this.data)}`}_assign(e){if(this.#n.find(t=>t===e||t.key===e.key))throw Error(`User instance already assigned to resource`);this.#n.push(e),this.#a=performance.now()}_release(e){this.#n=this.#n.filter(t=>t!==e),this.pool._release(e),this.#a=performance.now()}get hasUserCapacity(){return this.usersCount<this.#r}get usersCount(){return this.#n.length}get isExpiredFromUsers(){return this.#i<=0||this.#n.length>0?!1:performance.now()>this.#i+this.#a}get isDisposed(){return this.#e===`disposed`}dispose(e){if(this.#e===`disposed`)return;let t=this.#t;this.#e=`disposed`,this.pool.log.log(`Resource disposed (${e})`);for(let n of this.#n)n._dispose(`resource-${e}`,t);this.#n=[],this.#a=performance.now(),this.pool._releaseResource(this,e),this.pool.freeResource&&this.pool.freeResource(t)}},U=class{_resources;_users;capacity;userExpireAfterMs;resourcesWithoutUserExpireAfterMs;capacityPerResource;fullPolicy;generateResource;freeResource;log=a(`Pool`);constructor(e={}){this.capacity=e.capacity??-1,this.fullPolicy=e.fullPolicy??`error`,this.capacityPerResource=e.capacityPerResource??1,this.userExpireAfterMs=e.userExpireAfterMs??-1,this.resourcesWithoutUserExpireAfterMs=e.resourcesWithoutUserExpireAfterMs??-1,this.generateResource=e.generate,this.freeResource=e.free,this._users=new Map,this._resources=[],this.log=a(`Pool`,e.debug??!1);let t=Math.max(this.userExpireAfterMs,this.resourcesWithoutUserExpireAfterMs);t>0&&setInterval(()=>{this.maintain()},t*1.1)}dumpToString(){let e=`Pool
    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}
    resources count: ${this._resources.length}`,t=this._resources.map(e=>e.toString()).join(`\r
	`);e+=`\r
Resources:\r
	`+t,e+=`\r
Users: \r
`;for(let[t,n]of this._users.entries())e+=`\tk: ${t} v: ${n.toString()}\r\n`;return e}getUsersByLongestElapsed(){return[...this._users.values()].sort((e,t)=>{let n=e.elapsed,r=t.elapsed;return n===r?0:n<r?1:-1})}getResourcesSortedByUse(){return[...this._resources].sort((e,t)=>e.usersCount===t.usersCount?0:e.usersCount<t.usersCount?-1:1)}addResource(e){if(e===void 0)throw Error(`Cannot add undefined resource`);if(e===null)throw TypeError(`Cannot add null resource`);if(this.capacity>0&&this._resources.length===this.capacity)throw Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);this.log.log(`Adding resource: ${JSON.stringify(e)}`);let t=new H(this,e);return this._resources.push(t),t}maintain(){let e=!1,t=[];for(let e of this._resources)e.isDisposed?(this.log.log(`Maintain, disposed resource: ${JSON.stringify(e.data)}`),t.push(e)):e.isExpiredFromUsers&&(this.log.log(`Maintain, expired resource: ${JSON.stringify(e.data)}`),t.push(e));if(t.length>0){for(let e of t)e.dispose(`diposed/expired`);e=!0}let n=[];for(let[e,t]of this._users.entries())t.isValid||(this.log.log(`Maintain. Invalid user: ${t.key} (Disposed: ${t.isDisposed} Expired: ${t.isExpired} Resource disposed: ${t.resource.isDisposed})`),n.push(e),t._dispose(`invalid`,t.data));for(let t of n)this._users.delete(t),e=!0;e&&this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`)}*resources(){let e=[...this._resources];for(let t of e)yield t}*values(){let e=[...this._resources];for(let t of e)yield t.data}release(e,t){let n=this._users.get(e);n&&n.release(t??`Pool.release`)}_release(e){this._users.delete(e.key)}_releaseResource(e,t){this._resources=this._resources.filter(t=>t!==e)}hasResource(e){return this._resources.find(t=>t.data===e)!==void 0}hasUser(e){return this._users.has(e)}_assign(e,t){let n=new V(e,t);return this._users.set(e,n),t._assign(n),n}#e(e){let t=this.getResourcesSortedByUse();if(t.length>0&&t[0].hasUserCapacity)return this._assign(e,t[0]);if(this.generateResource&&(this.capacity<0||this._resources.length<this.capacity)){this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);let t=this.addResource(this.generateResource());return this._assign(e,t)}}get usersLength(){return[...this._users.values()].length}useValue(e){return this.use(e).resource.data}use(e){let t=this._users.get(e);if(t)return t.keepAlive(),t;this.maintain();let n=this.#e(e);if(n)return n;if(this.fullPolicy===`error`)throw Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);if(this.fullPolicy===`evictOldestUser`){let t=this.getUsersByLongestElapsed();if(t.length>0){this.release(t[0].key,`evictedOldestUser`);let n=this.#e(e);if(n)return n}}throw Error(`Pool is fully used (${this.fullPolicy})`)}};const W=(e={})=>new U(e);function G(){let e,t;return{promise:new Promise((n,r)=>{e=n,t=r}),resolve:e,reject:t}}const K=e=>{let t=!1,n=d(()=>{t||(n.start(),e.whatToCall(e.fallback()))},e.interval);return e.abort&&e.abort.addEventListener(`abort`,e=>{t=!0,n.cancel()}),n.start(),r=>{if(t)throw Error(`AbortSignal has been fired`);n.start(),e.whatToCall(r)}};var q=class extends s{timeoutMs;whenUnmatchedResponse;keyRequest;keyResponse;#e=new Map;#t;constructor(e={}){if(super(),typeof window>`u`&&(globalThis.window={setTimeout,clearTimeout}),this.timeoutMs=e.timeoutMs??1e3,this.whenUnmatchedResponse=e.whenUnmatchedResponse??`throw`,this.#t=n(()=>this.#n(),this.timeoutMs*2),e.key){if(e.keyRequest)throw Error(`Cannot set 'keyRequest' when 'key' is set `);if(e.keyResponse)throw Error(`Cannot set 'keyResponse' when 'key' is set `);this.keyRequest=e.key,this.keyResponse=e.key}else{if(!e.keyRequest||!e.keyResponse)throw Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);this.keyRequest=e.keyRequest,this.keyResponse=e.keyResponse}}#n(){let e=[...this.#e.values()],t=Date.now();for(let n of e)if(n.expiresAt<=t){n.promiseReject&&n.promiseReject(`Request timeout`);let e=n.callback;e&&setTimeout(()=>{e(!0,`Request timeout`)},1),this.fireEvent(`completed`,{request:n.req,response:`Request timeout`,success:!1}),this.#e.delete(n.id)}return this.debugDump(),this.#e.size>0}debugDump(){let e=[...this.#e.values()],t=Date.now();for(let n of e){let e=t-n.expiresAt;console.log(`${n.id} Expires in: ${Math.floor(e/1e3).toString()}s`)}}request(e,t){if(t!==void 0){this.#i(e,t);return}return this.#r(e)}requestAndForget(e){let t=this.keyRequest(e);if(this.#e.has(t))throw Error(`Already a request pending with id '${t}'`);let n={expiresAt:Date.now()+this.timeoutMs,id:t,req:e};this.#e.set(t,n),this.#t.start()}#r(e){let t=this.keyRequest(e);if(this.#e.has(t))throw Error(`Already a request pending with id '${t}'`);return new Promise((n,r)=>{let i={expiresAt:Date.now()+this.timeoutMs,id:t,req:e,promiseResolve:n,promiseReject:r};this.#e.set(t,i),this.#t.start()})}#i(e,t){let n=this.keyRequest(e);if(this.#e.has(n))throw Error(`Already a request pending with id '${n}'`);let r={expiresAt:Date.now()+this.timeoutMs,id:n,req:e,callback:t};this.#e.set(n,r),this.#t.start()}response(e,t){let n=this.keyResponse(e),r=this.#e.get(n);if(!r){if(this.whenUnmatchedResponse===`throw`)throw Error(`Unmatched response with id: '${n}'`,{cause:e});return!1}return t?r.expiresAt=Date.now()+this.timeoutMs:this.#e.delete(n),r.promiseResolve&&r.promiseResolve(e),r.callback&&r.callback(!1,e),this.fireEvent(`match`,{request:r.req,response:e}),t||this.fireEvent(`completed`,{request:r.req,response:e,success:!0}),!0}};const J=e=>{let t=!1,n=!1;return()=>t?n:(t=!0,n=e(),n)};var Y=class{#e;#t;#n;signal(){this.#e&&=(this.#e(),void 0),this.#n=Promise.resolve()}flush(){this.#t&&=(this.#t(`Flushed`),void 0),this.#e=void 0,this.#n=void 0}#r(){let e=new Promise((e,t)=>{this.#e=e,this.#t=t});return this.#n=e,e}async forSignal(e){let t=this.#n;if(t??=this.#r(),e){let t=this.#t;setTimeout(()=>{t&&t(`Timeout elapsed ${e.toString()}`)},e)}await t,this.#n=void 0,this.#e=void 0,this.#t=void 0}async didSignal(e){try{return await this.forSignal(e),!0}catch{return!1}}},X=class e extends s{static shared=new e;_loop;_queue;constructor(){super(),this._queue=o(),this._loop=n(()=>this.processQueue(),100)}enqueue(e){let t=this._queue.enqueue(e);return this._loop.runState===`idle`&&(this.fireEvent(`started`,{}),this._loop.start()),t}dequeue(){return this._queue.dequeue()}async processQueue(){let e=this._queue.dequeue();if(e===void 0)return this.fireEvent(`empty`,{}),!1;try{await e()}catch(e){console.error(e)}}clear(){this._queue.length!==0&&(this._queue.clear(),this._loop.cancel(),this.fireEvent(`empty`,{}))}get isEmpty(){return this._queue.isEmpty}get length(){return this._queue.length}};const Z=(e,t)=>{let n=0;return async(...r)=>{let i=performance.now()-n;if(i>=t){let t=e(i,...r);typeof t==`object`&&await t,n=performance.now()}}},Q=(t,n,r=`slow`)=>{let i=0,a,o=e(n,1e3);return()=>new Promise(async(s,c)=>{let l=performance.now()-i;if(a===void 0||l>o)try{i=performance.now(),a=await t(l),o=e(n,1e3)}catch(e){r===`fast`?(a=void 0,i=0):r===`backoff`&&(o=Math.floor(o*1.2)),c(e);return}s(a)})};var $=class{#e;#t;#n=!1;constructor(){let{promise:e,resolve:t}=G();this.#e=e,this.#t=t}get(){return this.#e}add(e){if(this.#n)throw Error(`QueueSingleUse has already been used`);this.#n=!0,this.#t(e)}get isUsed(){return this.#n}};const te=()=>new $;export{v as DispatchList,U as Pool,V as PoolUser,q as RequestResponseMatch,H as Resource,x as StateMachine,Y as SyncWait,X as TaskQueueMutable,$ as WaitForValue,m as backoffGenerator,n as continuously,W as create,h as debounce,u as delay,l as delayLoop,M as elapsedMillisecondsAbsolute,O as elapsedTicksAbsolute,f as eventRace,z as everyNth,A as frequencyTimer,E as hasElapsed,F as iterateBreadth,I as iterateDepth,B as movingAverageTimed,S as ofTotal,k as ofTotalTicks,G as promiseWithResolvers,K as rateMinimum,j as relative,w as repeat,T as repeatSync,g as retryFunction,p as retryTask,y as run,J as runOnce,b as runSingle,te as singleItem,t as sleep,Z as throttle,d as timeout,C as timerAlwaysDone,D as timerNeverDone,N as timerWithFunction,Q as updateOutdated,_ as waitFor};