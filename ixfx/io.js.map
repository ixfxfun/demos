{"version":3,"file":"io.js","names":["text: string","buffer: AllowSharedBufferSource","onData: (data: string) => void","string_: string","dataHandler: (data: string) => Promise<void>","opts: Opts","stringToQueue: string","device: BluetoothDevice","config: BleDeviceOptions","txt: string","error: unknown","event: Event","m: string","m: unknown","device: BluetoothDevice","opts: Opts","parentElement: HTMLElement","audio: AudioAnalyser","numberTracker","freq: readonly number[]","value: boolean","canvas: HTMLCanvasElement | null","wave: readonly number[]","elem: HTMLElement","event: MouseEvent | PointerEvent","onData: (\n    freq: Float32Array,\n    wave: Float32Array,\n    analyser: AudioAnalyser\n  ) => void","opts: Opts","onData: (freq: Float32Array, analyser: AudioAnalyser) => void","onData: (level: number, analyser: AudioAnalyser) => void","analyse: DataAnalyser","#initInProgress","error: unknown","#isPaused","v: boolean","context: AudioContext","stream: MediaStream","lowFreq: number","highFreq: number","freqData: readonly number[]","index: number","freq: number","#initialised","#sources","key: string","audioElementOrQuery: HTMLMediaElement | string","filterType: BiquadFilterType","oscillatorOptions: Partial<AudioOscillatorOptions>","device: BluetoothDevice","opts: Options","code: string","opts: EvalOpts","warn?: (message: string) => void","config: JsonDeviceOpts","txt: string","event: Event","m: string","m: unknown","config: SerialOpts","txt: string","error: unknown","reqOpts: SerialPortRequestOptions","openOpts: SerialOptions","error","SerialDevice","opts?: EspruinoSerialDeviceOpts","code: string","opts: EvalOpts","warn?: (message: string) => void","opts: EspruinoBleOpts","NordicDefaults","opts: {\n    readonly name?: string;\n    readonly debug?: boolean;\n    readonly evalTimeoutMs?: number;\n  }","defaultNamePrefix: string","filters: BluetoothLEScanFilter[]","code: string","opts: EvalOpts","device: EspruinoDevice","evalReplyPrefix: string","debug: boolean","warn: (m: string) => void","randomString","d: IoDataEvent","error: unknown","event: StateChangeEvent<GenericStateTransitions>","reason: string","start","constraints: Constraints","startWithVideoEl","videoEl: HTMLVideoElement","file: File","videoEl: HTMLVideoElement","opts: FrameProcessorOpts","enabled: boolean","el: HTMLElement | undefined","constraints?: Camera.Constraints","file: File","r: Camera.StartResult | VideoFile.StartResult","url: string | URL","opts: Partial<ReconnectingOptions>","ws: WebSocket | undefined","event_: any","message: MessageEvent","_attempts: number","data: string | ArrayBufferLike | ArrayBufferView | Blob"],"sources":["../packages/io/src/codec.ts","../packages/io/src/string-receive-buffer.ts","../packages/io/src/string-write-buffer.ts","../packages/io/src/generic-state-transitions.ts","../packages/io/src/ble-device.ts","../packages/io/src/nordic-ble-device.ts","../packages/io/src/audio/visualiser.ts","../packages/io/src/audio/analyser.ts","../packages/io/src/audio/from-audio-element.ts","../packages/io/src/audio/from-oscillator.ts","../packages/io/src/audio/index.ts","../packages/io/src/espruino-ble-device.ts","../packages/io/src/json-device.ts","../packages/io/src/serial.ts","../packages/io/src/espruino-serial-device.ts","../packages/io/src/espruino.ts","../packages/io/src/camera.ts","../packages/io/src/video-file.ts","../packages/io/src/frame-processor.ts","../packages/io/src/reconnecting-web-socket.ts"],"sourcesContent":["/**\n * Handles utf-8 text encoding/decoding\n */\nexport class Codec {\n  enc = new TextEncoder();\n  dec = new TextDecoder(`utf-8`);\n\n  /**\n   * Convert string to Uint8Array buffer\n   * @param text\n   * @returns\n   */\n  toBuffer(text: string) {\n    return this.enc.encode(text);\n  }\n\n  /**\n   * Returns a string from a provided buffer\n   * @param buffer\n   * @returns\n   */\n  fromBuffer(buffer: AllowSharedBufferSource) {\n    return this.dec.decode(buffer);\n  }\n}\n","/**\n * Receives text\n */\nexport class StringReceiveBuffer {\n  buffer = ``;\n  stream: WritableStream<string> | undefined;\n\n  constructor(\n    private onData: (data: string) => void,\n    public separator = `\\n`\n  ) {}\n\n  async close() {\n    const s = this.stream;\n    if (!s) return;\n    await s.abort();\n\n    await s.close();\n  }\n\n  clear() {\n    this.buffer = ``;\n  }\n\n  writable() {\n    if (this.stream === undefined) this.stream = this.createWritable();\n    return this.stream;\n  }\n\n  private createWritable() {\n    //eslint-disable-next-line @typescript-eslint/no-this-alias\n    const b = this;\n    return new WritableStream<string>({\n      write(chunk) {\n        b.add(chunk);\n      },\n      close() {\n        b.clear();\n      },\n    });\n  }\n\n  addImpl(string_: string): string {\n    // Look for separator in new string\n    const pos = string_.indexOf(this.separator);\n    if (pos < 0) {\n      // Not found, just add to buffer and return\n      this.buffer += string_;\n      return ``;\n    }\n\n    // Found! Trigger callback for existing buffer and part of new string\n    const part = string_.substring(0, pos);\n    try {\n      this.onData(this.buffer + part);\n      string_ = string_.substring(part.length + this.separator.length);\n    } catch (ex) {\n      console.warn(ex);\n    }\n\n    this.buffer = ``;\n\n    return string_;\n  }\n\n  add(string_: string) {\n    while (string_.length > 0) {\n      string_ = this.addImpl(string_);\n    }\n  }\n}\n","import type { Interval } from '@ixfx/core';\nimport { QueueMutable } from '@ixfx/collections/queue';\nimport {\n  type Continuously,\n  continuously\n} from '@ixfx/core';\nimport { splitByLength } from '@ixfx/core/text';\n\nexport type Opts = {\n  readonly chunkSize?: number;\n  readonly interval?: Interval;\n};\n\n/**\n * Buffers a queue of strings.\n *\n * When text is queued via {@link add}, it is chopped up\n * into chunks and sent in serial to the `dataHandler` function.\n * Data is processed at a set rate, by default 10ms.\n *\n * ```js\n * const dataHandler = (data:string) => {\n *  // Do something with queued data.\n *  // eg. send to serial port\n * }\n *\n * // Create a buffer with a chunk size of 100 characters\n * const b = new StringWriteBuffer(dataHandler, { chunkSize: 100 });\n * b.add('some text'); // Write to buffer\n * // dataHandler will be called until queued data is empty\n * ```\n *\n * It's also possible to get the buffer as a WritableStream<string>:\n * ```js\n * const dataHandler = (data:string) => { ... }\n * const b = new StringWriteBuffer(dataHandler, 100);\n * const s = b.writable();\n * ```\n *\n * Other functions:\n * ```js\n * b.close(); // Close buffer\n * b.clear(); // Clear queued data, but don't close anything\n * ```\n */\nexport class StringWriteBuffer {\n  paused = false;\n  queue = new QueueMutable<string>();\n  writer: Continuously;\n  stream: WritableStream<string> | undefined;\n  closed = false;\n  chunkSize: number;\n\n  /**\n   * Constructor\n   * @param dataHandler Calback to 'send' data onwards\n   * @param opts Options\n   */\n  constructor(\n    private dataHandler: (data: string) => Promise<void>,\n    opts: Opts = {}\n  ) {\n    this.chunkSize = opts.chunkSize ?? -1;\n    this.writer = continuously(async () => {\n      await this.onWrite()\n    }, opts.interval ?? 10);\n  }\n\n  /**\n   * Close writer (async)\n   */\n  async close() {\n    if (this.closed) return;\n    const w = this.stream?.getWriter();\n    w?.releaseLock();\n    await w?.close();\n    this.closed = true;\n  }\n\n  /**\n   * Clear queued data.\n   *\n   * Throws an error if {@link close} has been called.\n   */\n  clear() {\n    if (this.closed) throw new Error(`Buffer closed`);\n    this.queue = new QueueMutable<string>();\n  }\n\n  /**\n   * Gets the buffer as a writable stream.\n   *\n   * Do not close stream directly, use .close on this class instead.\n   *\n   * Throws an error if .close() has been called.\n   * @returns Underlying stream\n   */\n  writable() {\n    if (this.closed) throw new Error(`Buffer closed`);\n    if (this.stream === undefined) this.stream = this.createWritable();\n    return this.stream;\n  }\n\n  private createWritable() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const b = this;\n    return new WritableStream<string>({\n      write(chunk) {\n        b.add(chunk);\n      },\n      close() {\n        b.clear();\n      },\n    });\n  }\n\n  /**\n   * Run in a `continunously` loop to process queued data\n   * @returns _False_ if queue is empty and loop should stop. _True_ if it shoud continue.\n   */\n  async onWrite(): Promise<boolean> {\n    if (this.queue.isEmpty) {\n      //console.warn(`WriteBuffer.onWrite: queue empty`);\n      return false; // Stop continuously\n    }\n\n    if (this.paused) {\n      console.warn(`WriteBuffer.onWrite: paused...`);\n      return true; // Keep going tho\n    }\n\n    // Dequeue and send\n    const s = this.queue.dequeue();\n    if (s === undefined) return false;\n    await this.dataHandler(s);\n\n    return true;\n  }\n\n  /**\n   * Returns _true_ if {@link close} has been called.\n   */\n  get isClosed() {\n    return this.closed;\n  }\n\n  /**\n   * Adds some queued data to send.\n   * Longer strings are automatically chunked up according to the buffer's settings.\n   *\n   * Throws an error if {@link close} has been called.\n   * @param stringToQueue\n   */\n  add(stringToQueue: string) {\n    if (this.closed) throw new Error(`Buffer closed`);\n    // Add whole string or chunked string\n    if (this.chunkSize > 0) {\n      this.queue.enqueue(...splitByLength(stringToQueue, this.chunkSize));\n    } else {\n      this.queue.enqueue(stringToQueue);\n    }\n\n    // Run continuously loop if it's not already running\n    this.writer.start();\n  }\n}\n","export const genericStateTransitionsInstance = Object.freeze({\n  ready: `connecting`,\n  connecting: [ `connected`, `closed` ],\n  connected: [ `closed` ],\n  closed: `connecting`,\n});","\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\nimport { retryFunction } from '@ixfx/flow';\nimport { indexOfCharCode, omitChars } from '@ixfx/core/text';\n\nimport { Codec } from './codec.js';\nimport { StringReceiveBuffer } from './string-receive-buffer.js';\nimport { StringWriteBuffer } from './string-write-buffer.js';\nimport {\n  type BleDeviceOptions,\n  type GenericStateTransitions,\n  type IoEvents,\n} from './types.js';\nimport { genericStateTransitionsInstance } from './generic-state-transitions.js';\n\n\n\nconst reconnect = async () => {\n  console.log(`Connect?`);\n  if (!(`bluetooth` in navigator)) return false;\n  if (!(`getDevices` in navigator.bluetooth)) return false;\n\n  const devices = await navigator.bluetooth.getDevices();\n  console.log(devices);\n\n  for (const device of devices) {\n    console.log(device);\n    // Start a scan for each device before connecting to check that they're in\n    // range.\n    const abortController = new AbortController();\n    await device.watchAdvertisements({ signal: abortController.signal });\n\n    device.addEventListener(`advertisementreceived`, async (event) => {\n      console.log(event);\n      // Stop the scan to conserve power on mobile devices.\n      abortController.abort();\n\n      // At this point, we know that the device is in range, and we can attempt\n      // to connect to it.\n      await event.device.gatt?.connect();\n      console.log(`Connected!`);\n    });\n  }\n};\n\nexport class BleDevice extends SimpleEventEmitter<\n  IoEvents<GenericStateTransitions>\n> {\n  states: StateMachineWithEvents<GenericStateTransitions>;\n  codec: Codec;\n  rx: BluetoothRemoteGATTCharacteristic | undefined;\n  tx: BluetoothRemoteGATTCharacteristic | undefined;\n  gatt: BluetoothRemoteGATTServer | undefined;\n  verboseLogging = false;\n\n  rxBuffer: StringReceiveBuffer;\n  txBuffer: StringWriteBuffer;\n\n  constructor(\n    private device: BluetoothDevice,\n    private config: BleDeviceOptions\n  ) {\n    super();\n    this.verboseLogging = config.debug;\n    this.txBuffer = new StringWriteBuffer(async (data) => {\n      await this.writeInternal(data);\n    }, config);\n\n    this.rxBuffer = new StringReceiveBuffer((line) => {\n      this.fireEvent(`data`, { data: line });\n    });\n\n    this.codec = new Codec();\n    this.states = new StateMachineWithEvents<GenericStateTransitions>(\n      genericStateTransitionsInstance,\n      {\n        initial: `ready`,\n      }\n    );\n    this.states.addEventListener(`change`, (event) => {\n      this.fireEvent(`change`, event);\n      this.verbose(`${ event.priorState } -> ${ event.newState }`);\n\n      if (event.priorState === `connected`) {\n        // Clear out buffers\n        this.rxBuffer.clear();\n        this.txBuffer.clear();\n      }\n    });\n\n    device.addEventListener(`gattserverdisconnected`, () => {\n      if (this.isClosed) return;\n      this.verbose(`GATT server disconnected`);\n      this.states.state = `closed`;\n    });\n\n    this.verbose(`ctor ${ device.name } ${ device.id }`);\n  }\n\n  get isConnected(): boolean {\n    return this.states.state === `connected`;\n  }\n\n  get isClosed(): boolean {\n    return this.states.state === `closed`;\n  }\n\n  write(txt: string) {\n    if (this.states.state !== `connected`) {\n      throw new Error(`Cannot write while state is ${ this.states.state }`);\n    }\n    this.txBuffer.add(txt);\n  }\n\n  private async writeInternal(txt: string) {\n    this.verbose(`writeInternal ${ txt }`);\n    const tx = this.tx;\n    if (tx === undefined) {\n      throw new Error(`Unexpectedly without tx characteristic`);\n    }\n    try {\n      await tx.writeValue(this.codec.toBuffer(txt));\n    } catch (error: unknown) {\n      this.warn(error);\n    }\n  }\n\n  disconnect() {\n    if (this.states.state !== `connected`) return;\n    this.gatt?.disconnect();\n  }\n\n  async connect() {\n    const attempts = this.config.connectAttempts ?? 3;\n\n    this.states.state = `connecting`;\n\n    this.verbose(`connect`);\n    const gatt = this.device.gatt;\n    if (gatt === undefined) throw new Error(`Gatt not available on device`);\n\n    await retryFunction(\n      async () => {\n        this.verbose(`connect.retry`);\n        const server = await gatt.connect();\n        this.verbose(`Getting primary service`);\n        const service = await server.getPrimaryService(this.config.service);\n        this.verbose(`Getting characteristics`);\n        const rx = await service.getCharacteristic(\n          this.config.rxGattCharacteristic\n        );\n        const tx = await service.getCharacteristic(\n          this.config.txGattCharacteristic\n        );\n\n        rx.addEventListener(`characteristicvaluechanged`, (event) => { this.onRx(event); }\n        );\n        this.rx = rx;\n        this.tx = tx;\n        this.gatt = gatt;\n        this.states.state = `connected`;\n\n        await rx.startNotifications();\n        return true;\n      },\n      {\n        limitAttempts: attempts,\n        startAt: 200,\n      }\n    );\n  }\n\n  private onRx(event: Event) {\n    const rx = this.rx;\n    if (rx === undefined) return;\n\n    const view = (event.target as any).value as DataView;\n    if (view === undefined) return;\n\n    let text = this.codec.fromBuffer(view.buffer as ArrayBuffer);\n\n    // Check for flow control chars\n    const plzStop = indexOfCharCode(text, 19);\n    const plzStart = indexOfCharCode(text, 17);\n\n    // Remove if found\n    if (plzStart && plzStop < plzStart) {\n      this.verbose(`Tx plz start`);\n      text = omitChars(text, plzStart, 1);\n      this.txBuffer.paused = false;\n    }\n    if (plzStop && plzStop > plzStart) {\n      this.verbose(`Tx plz stop`);\n      text = omitChars(text, plzStop, 1);\n      this.txBuffer.paused = true;\n    }\n\n    this.rxBuffer.add(text);\n  }\n\n  protected verbose(m: string) {\n    if (this.verboseLogging) console.info(this.config.name, m);\n  }\n\n  protected log(m: string) {\n    console.log(this.config.name, m);\n  }\n\n  protected warn(m: unknown) {\n    console.warn(this.config.name, m);\n  }\n}\n","import { BleDevice } from './ble-device.js';\n\nexport const defaultOpts = {\n  chunkSize: 20,\n  service: `6e400001-b5a3-f393-e0a9-e50e24dcca9e`,\n  txGattCharacteristic: `6e400002-b5a3-f393-e0a9-e50e24dcca9e`,\n  rxGattCharacteristic: `6e400003-b5a3-f393-e0a9-e50e24dcca9e`,\n  name: `NordicDevice`,\n  connectAttempts: 5,\n  debug: false,\n};\n\nexport type Opts = {\n  readonly chunkSize?: number;\n  readonly name?: string;\n  readonly connectAttempts?: number;\n  readonly debug?: boolean;\n};\n\nexport class NordicBleDevice extends BleDevice {\n  constructor(device: BluetoothDevice, opts: Opts = {}) {\n    super(device, { ...defaultOpts, ...opts });\n  }\n}\n","/**\n * Visualiser component\n *\n * Usage: import visualiser.js. Instantiate on document load, and pass in the\n * parent element into the constructor.\n *\n * eg: const v = new Visualiser(document.getElementById('renderer'));\n *\n * Data must be passed to the component via renderFreq or renderWave.\n *\n * Draws on https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Visualizations_with_Web_Audio_API\n */\n\nimport { number as numberTracker } from '@ixfx/trackers';\nimport { AudioAnalyser } from './analyser.js';\nimport type { Point } from '@ixfx/geometry/point';\nimport { numberArrayCompute } from '@ixfx/numbers';\n\n// TODO: This is an adaption of old code. Needs to be smartened up further\nexport class AudioVisualiser {\n  freqMaxRange = 200;\n  audio: AudioAnalyser;\n  parent: HTMLElement;\n\n  lastPointer: Point = { x: 0, y: 0 };\n  pointerDown = false;\n  pointerClicking = false;\n  pointerClickDelayMs = 100;\n  pointerDelaying = false;\n\n  waveTracker;\n  freqTracker;\n  el: HTMLElement;\n\n  constructor(parentElement: HTMLElement, audio: AudioAnalyser) {\n    this.audio = audio;\n    this.parent = parentElement;\n    this.waveTracker = numberTracker();\n    this.freqTracker = numberTracker();\n\n    // Add HTML\n    parentElement.innerHTML = `\n    <section>\n      <button id=\"rendererComponentToggle\">🔼</button>\n      <div>\n        <h1>Visualiser</h1>\n        <div style=\"display:flex; flex-wrap: wrap\">\n          <div class=\"visPanel\">\n            <h2>Frequency distribution</h2>\n            <br />\n            <canvas id=\"rendererComponentFreqData\" height=\"200\" width=\"400\"></canvas>\n          </div>\n          <div class=\"visPanel\">\n            <h2>Waveform</h2>\n            <button id=\"rendererComponentWaveReset\">Reset</button>\n            <div>\n              Press and hold on wave to measure\n            </div>\n            <br />\n            <canvas id=\"rendererComponentWaveData\" height=\"200\" width=\"400\"></canvas>\n          </div>\n        </div>\n      </div>\n    </section>\n    `;\n    this.el = parentElement.children[ 0 ] as HTMLElement;\n\n    document\n      .getElementById(`rendererComponentToggle`)\n      ?.addEventListener(`click`, () => {\n        this.setExpanded(!this.isExpanded());\n      });\n    this.el.addEventListener(`pointermove`, (e) => { this.onPointer(e); });\n    //this.el.addEventListener(`touchbegin`, (e) => this.onPointer(e));\n    this.el.addEventListener(`pointerup`, () => {\n      this.pointerDelaying = false;\n      this.pointerDown = false;\n    });\n    this.el.addEventListener(`pointerdown`, () => {\n      this.pointerDelaying = true;\n      setTimeout(() => {\n        if (this.pointerDelaying) {\n          this.pointerDelaying = false;\n          this.pointerDown = true;\n        }\n      }, this.pointerClickDelayMs);\n    });\n    this.el.addEventListener(`pointerleave`, () => {\n      this.pointerDelaying = false;\n      this.pointerDown = false;\n    });\n\n    document\n      .getElementById(`rendererComponentWaveReset`)\n      ?.addEventListener(`click`, () => {\n        this.clear();\n      });\n  }\n\n  renderFreq(freq: readonly number[]) {\n    if (!this.isExpanded()) return; // Don't render if collapsed\n    if (!freq) return; // Data is undefined/null\n\n    const canvas = document.getElementById(\n      `rendererComponentFreqData`\n    ) as HTMLCanvasElement;\n    if (canvas === null) throw new Error(`Cannot find canvas element`);\n    const g = canvas.getContext(`2d`);\n    if (g === null) throw new Error(`Cannot create drawing context`);\n\n    const bins = freq.length;\n    const canvasWidth = canvas.clientWidth;\n    const canvasHeight = canvas.clientHeight;\n    g.clearRect(0, 0, canvasWidth, canvasHeight);\n\n    const pointer = this.getPointerRelativeTo(canvas);\n    const width = canvasWidth / bins;\n    const minMax = numberArrayCompute(freq);\n\n    for (let index = 0; index < bins; index++) {\n      if (!Number.isFinite(freq[ index ])) continue;\n\n      const value = freq[ index ] - minMax.min;\n      const valueRelative = value / this.freqMaxRange;\n      const height = Math.abs(canvasHeight * valueRelative);\n      const offset = canvasHeight - height;\n\n      const hue = (index / bins) * 360;\n      const left = index * width;\n      g.fillStyle = `hsl(${ hue }, 100%, 50%)`;\n\n      // Show info about data under pointer\n      if (\n        pointer.y > 0 &&\n        pointer.y <= canvasHeight &&\n        pointer.x >= left &&\n        pointer.x <= left + width\n      ) {\n        // Keep track of data\n        if (this.freqTracker.id !== index.toString()) {\n          this.freqTracker = numberTracker({ id: index.toString() });\n        }\n        this.freqTracker.seen(freq[ index ]);\n\n        const freqMma = this.freqTracker.getMinMaxAvg();\n\n        // Display\n        g.fillStyle = `black`;\n        if (this.audio) {\n          g.fillText(\n            `Frequency (${ index }) at pointer: ${ this.audio\n              .getFrequencyAtIndex(index)\n              .toLocaleString(`en`) } - ${ this.audio\n                .getFrequencyAtIndex(index + 1)\n                .toLocaleString(`en`) }`,\n            2,\n            10\n          );\n        }\n        g.fillText(`Raw value: ${ freq[ index ].toFixed(2) }`, 2, 20);\n        g.fillText(`Min: ${ freqMma.min.toFixed(2) }`, 2, 40);\n        g.fillText(`Max: ${ freqMma.max.toFixed(2) }`, 60, 40);\n        g.fillText(`Avg: ${ freqMma.avg.toFixed(2) }`, 120, 40);\n      }\n      g.fillRect(left, offset, width, height);\n    }\n  }\n\n  isExpanded() {\n    const contentsElement = this.el.querySelector(`div`);\n    if (contentsElement === null) throw new Error(`contents div not found`);\n    return contentsElement.style.display === ``;\n  }\n\n  setExpanded(value: boolean) {\n    const contentsElement = this.el.querySelector(`div`);\n    const button = this.el.querySelector(`button`);\n\n    if (button === null) throw new Error(`Button element not found`);\n    if (contentsElement === null) throw new Error(`Contents element not found`);\n    if (value) {\n      contentsElement.style.display = ``;\n      button.innerText = `🔼`;\n    } else {\n      contentsElement.style.display = `none`;\n      button.innerText = `🔽`;\n    }\n  }\n\n  clear() {\n    this.clearCanvas(\n      document.getElementById(`rendererComponentFreqData`) as HTMLCanvasElement\n    );\n    this.clearCanvas(\n      document.getElementById(`rendererComponentWaveData`) as HTMLCanvasElement\n    );\n  }\n\n  // Clears a canvas to white\n  clearCanvas(canvas: HTMLCanvasElement | null) {\n    if (canvas === null) throw new Error(`Canvas is null`);\n    const g = canvas.getContext(`2d`);\n    if (g === null) throw new Error(`Cannot create drawing context`);\n    g.fillStyle = `white`;\n    g.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n  }\n\n  // Renders waveform data.\n  // Adapted from MDN's AnalyserNode.getFloatTimeDomainData() example\n  renderWave(wave: readonly number[], bipolar = true) {\n    if (!this.isExpanded()) return; // Don't render if collapsed\n    if (!wave) return; // Undefined or null data\n    const canvas = document.getElementById(\n      `rendererComponentWaveData`\n    ) as HTMLCanvasElement;\n    if (canvas === null) throw new Error(`Cannot find wave canvas`);\n\n    const g = canvas.getContext(`2d`);\n    if (g === null) throw new Error(`Cannot create drawing context for wave`);\n\n    const canvasWidth = canvas.clientWidth;\n    const canvasHeight = canvas.clientHeight;\n    const pointer = this.getPointerRelativeTo(canvas);\n    const infoAreaHeight = 20;\n    const infoAreaWidth = 60;\n    const bins = wave.length;\n    g.fillStyle = `white`;\n    g.fillRect(0, 0, infoAreaWidth, infoAreaHeight);\n\n    const width = canvasWidth / bins;\n\n    // Clears the screen with very light tint of white\n    // to fade out last waveform. Set this higher to remove effect\n    g.fillStyle = `rgba(255, 255, 255, 0.03)`;\n    g.fillRect(0, 20, canvasWidth, canvasHeight);\n\n    g.fillStyle = `red`;\n    if (bipolar) {\n      g.fillRect(0, canvasHeight / 2, canvasWidth, 1);\n    } else {\n      g.fillRect(0, canvasHeight - 1, canvasWidth, 1);\n    }\n\n    g.lineWidth = 1;\n    g.strokeStyle = `black`;\n    g.beginPath();\n\n    //eslint-disable-next-line functional/no-let\n    let x = 0;\n\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < bins; index++) {\n      const height = wave[ index ] * canvasHeight;\n      const y = bipolar ? canvasHeight / 2 - height : canvasHeight - height;\n\n      if (index === 0) {\n        g.moveTo(x, y);\n      } else {\n        g.lineTo(x, y);\n      }\n      x += width;\n\n      if (this.pointerDown) this.waveTracker.seen(wave[ index ]);\n    }\n    g.lineTo(canvasWidth, bipolar ? canvasHeight / 2 : canvasHeight); //canvas.height / 2);\n    g.stroke();\n\n    // Draw\n    if (this.pointerDown) {\n      const waveMma = this.waveTracker.getMinMaxAvg();\n      g.fillStyle = `rgba(255,255,0,1)`;\n      g.fillRect(infoAreaWidth, 0, 150, 20);\n      g.fillStyle = `black`;\n      g.fillText(`Min: ` + waveMma.min.toFixed(2), 60, 10);\n      g.fillText(`Max: ` + waveMma.max.toFixed(2), 110, 10);\n      g.fillText(`Avg: ` + waveMma.avg.toFixed(2), 160, 10);\n    } else {\n      this.waveTracker.reset();\n    }\n\n    // Show info about data under pointer\n    if (\n      pointer.y > 0 &&\n      pointer.y <= canvasHeight &&\n      pointer.x >= 0 &&\n      pointer.x <= canvasWidth\n    ) {\n      g.fillStyle = `black`;\n      g.fillText(\n        `Level: ` + (1.0 - pointer.y / canvasHeight).toFixed(2),\n        2,\n        10\n      );\n    }\n  }\n\n  // Yields pointer position relative to given element\n  getPointerRelativeTo(elem: HTMLElement) {\n    const rect = elem.getBoundingClientRect();\n    return {\n      x: this.lastPointer.x - rect.left - window.scrollX, //elem.offsetLeft + window.scrollX,\n      y: this.lastPointer.y - rect.top - window.scrollY, //elem.offsetTop + window.scrollY\n    };\n  }\n\n  // Keeps track of last pointer position in page coordinate space\n  onPointer(event: MouseEvent | PointerEvent) {\n    this.lastPointer = {\n      x: event.pageX,\n      y: event.pageY,\n    };\n    event.preventDefault();\n  }\n\n  // getMinMax(data, start = 0, end = data.length) {\n  //   if (end > data.length) throw new Error(`end is past size of array`);\n  //   if (start < 0) throw new Error(`start should be at least 0`);\n  //   if (end <= start) throw new Error(`end should be greater than start`);\n\n  //   let max = Number.MIN_SAFE_INTEGER;\n  //   let min = Number.MAX_SAFE_INTEGER;\n  //   for (let i = start; i < end; i++) {\n  //     max = Math.max(data[i], max);\n  //     min = Math.min(data[i], min);\n  //   }\n  //   if (!Number.isFinite(max)) max = 0;\n  //   if (!Number.isFinite(min)) min = 0;\n\n  //   return {max: max, min: min};\n  // }\n}\n","\nimport { numberTest, integerTest, isPowerOfTwo, resultThrow } from '@ixfx/guards';\nimport { max, maxFast } from '@ixfx/numbers';\nimport { AudioVisualiser } from './visualiser.js';\n\n/**\n * Options for audio processing\n *\n * fftSize: Must be a power of 2, from 32 - 32768. Higher number means\n * more precision and higher CPU overhead\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\n *\n * smoothingTimeConstant: Range from 0-1, default is 0.8.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\n *\n * debug: If true, additonal console logging will happen\n */\nexport type Opts = {\n  readonly showVis?: boolean;\n  /**\n   * FFT size. Must be a power of 2, from 32 - 32768. Higher number means\n   * more precision and higher CPU overhead\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/fftSize\n   */\n  readonly fftSize?: number;\n  /**\n   * Range from 0-1, default is 0.8\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/smoothingTimeConstant\n   */\n  readonly smoothingTimeConstant?: number;\n  readonly debug?: boolean;\n};\n\nexport type DataAnalyser = (\n  node: AnalyserNode,\n  analyser: AudioAnalyser\n) => void;\n\n/**\n * Basic audio analyser. Returns back waveform and FFT analysis. Use {@link analyserPeakLevel} if you want sound level, or {@link analyserFrequency} if you just want FFT results.\n *\n * ```js\n * const onData = (freq, wave, analyser) => {\n *  // Demo: Get FFT results just for 100Hz-1KHz.\n *  const freqSlice = analyser.sliceByFrequency(100,1000,freq);\n *\n *  // Demo: Get FFT value for a particular frequency (1KHz)\n *  const amt = freq[analyser.getIndexForFrequency(1000)];\n * }\n * analyserBasic(onData, {fftSize: 512});\n * ```\n *\n * An `Analyser` instance is returned and can be controlled:\n * ```js\n * const analyser = analyserBasic(onData);\n * analyser.paused = true;\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n* @param onData Handler for data\n * @param opts Options\n * @returns Analyser instance\n */\nexport const analyserBasic = (\n  onData: (\n    freq: Float32Array,\n    wave: Float32Array,\n    analyser: AudioAnalyser\n  ) => void,\n  opts: Opts = {}\n): AudioAnalyser =>\n  new AudioAnalyser((node, analyser) => {\n    // Get frequency and amplitude data\n    const freq = new Float32Array(node.frequencyBinCount);\n    const wave = new Float32Array(node.fftSize);\n\n    // Load arrays with data\n    node.getFloatFrequencyData(freq);\n    node.getFloatTimeDomainData(wave);\n\n    // Send back\n    onData(freq, wave, analyser);\n  }, opts);\n\n/**\n * Basic audio analyser. Returns FFT analysis. Use {@link analyserPeakLevel} if you want the sound level, or {@link analyserBasic} if you also want the waveform.\n *\n * ```js\n * const onData = (freq, analyser) => {\n *  // Demo: Print out each sound frequency (Hz) and amount of energy in that band\n *  for (let i=0;i<freq.length;i++) {\n *    const f = analyser.getFrequencyAtIndex(0);\n *    console.log(`${i}. frequency: ${f} amount: ${freq[i]}`);\n *  }\n * }\n * analyserFrequency(onData, {fftSize:512});\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n * @param onData\n * @param opts\n * @returns\n */\nexport const analyserFrequency = (\n  onData: (freq: Float32Array, analyser: AudioAnalyser) => void,\n  opts: Opts = {}\n): AudioAnalyser =>\n  new AudioAnalyser((node, analyser) => {\n    const freq = new Float32Array(node.frequencyBinCount);\n    node.getFloatFrequencyData(freq);\n    onData(freq, analyser);\n  }, opts);\n\n/**\n * Basic audio analyser which reports the peak sound level.\n *\n * ```js\n * analyserPeakLevel(level => {\n *  console.log(level);\n * });\n * ```\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n * @param onData\n * @param opts\n * @returns\n */\nexport const analyserPeakLevel = (\n  onData: (level: number, analyser: AudioAnalyser) => void,\n  opts: Opts = {}\n): AudioAnalyser =>\n  new AudioAnalyser((node, analyser) => {\n    const wave = new Float32Array(node.fftSize);\n    node.getFloatTimeDomainData(wave);\n    onData(maxFast(wave), analyser);\n  }, opts);\n\n/**\n * Helper for doing audio analysis. It takes case of connecting the audio stream, running in a loop and pause capability.\n *\n * Provide a function which works with an [AnalyserNode](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode), and does something with the result.\n * ```js\n * const myAnalysis = (node, analyser) => {\n *  const freq = new Float32Array(node.frequencyBinCount);\n *  node.getFloatFrequencyData(freq);\n *  // Do something with frequency data...\n * }\n * const a = new Analyser(myAnalysis);\n * ```\n *\n * Helper functions provide ready-to-use Analysers:\n * * {@link analyserPeakLevel} peak decibel reading\n * * {@link analyserFrequency} FFT results\n * * {@link analyserBasic} FFT results and waveform\n *\n * Note: Browers won't allow microphone access unless the call has come from a user-interaction, eg pointerup event handler.\n *\n */\nexport class AudioAnalyser {\n  showVis: boolean;\n  fftSize: number;\n  smoothingTimeConstant: number;\n  #isPaused = false;\n  debug: boolean;\n  #initInProgress = false;\n\n  visualiser: AudioVisualiser | undefined;\n  audioCtx: AudioContext | undefined;\n  analyserNode: AnalyserNode | undefined;\n\n  analyse: DataAnalyser;\n\n  constructor(analyse: DataAnalyser, opts: Opts = {}) {\n    this.showVis = opts.showVis ?? false;\n    this.fftSize = opts.fftSize ?? 1024;\n    this.debug = opts.debug ?? false;\n    this.smoothingTimeConstant = opts.smoothingTimeConstant ?? 0.8;\n\n    resultThrow(\n      integerTest(this.fftSize, `positive`, `opts.fftSize`),\n      numberTest(\n        this.smoothingTimeConstant,\n        `percentage`,\n        `opts.smoothingTimeConstant`\n      )\n    );\n\n    if (!isPowerOfTwo(this.fftSize)) {\n      throw new Error(\n        `fftSize must be a power of two from 32 to 32768 (${ this.fftSize })`\n      );\n    }\n    if (this.fftSize < 32) throw new Error(`fftSize must be at least 32`);\n    if (this.fftSize > 32_768) { throw new Error(`fftSize must be no greater than 32768`); }\n\n    this.analyse = analyse;\n    this.paused = false;\n\n    this.init();\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    const visualiserEl = document.querySelector(`#audio-visualiser`) as HTMLElement | null;\n    if (visualiserEl) {\n      const visualiser = new AudioVisualiser(visualiserEl, this);\n      visualiser.setExpanded(this.showVis);\n      this.visualiser = visualiser;\n    }\n  }\n\n  init() {\n    if (this.#initInProgress) {\n      if (this.debug) console.debug(`Init already in progress`);\n      return;\n    }\n    this.#initInProgress = true;\n\n    // Initalise microphone\n    navigator.mediaDevices\n      .getUserMedia({ audio: true })\n      .then((stream) => {\n        this.onMicSuccess(stream);\n      })\n      .catch((error: unknown) => {\n        this.#initInProgress = false;\n        console.error(error);\n      });\n  }\n\n  get paused(): boolean {\n    return this.#isPaused;\n  }\n\n  set paused(v: boolean) {\n    if (v === this.#isPaused) return;\n    this.#isPaused = v;\n    if (v) {\n      if (this.debug) console.log(`Paused`);\n    } else {\n      if (this.debug) console.log(`Unpaused`);\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\n\n    }\n  }\n\n  private setup(context: AudioContext, stream: MediaStream) {\n    const analyser = context.createAnalyser();\n\n    // fftSize must be a power of 2. Higher values slower, more detailed\n    // Range is 32-32768\n    analyser.fftSize = this.fftSize;\n\n    // smoothingTimeConstant ranges from 0.0 to 1.0\n    // 0 = no averaging. Fast response, jittery\n    // 1 = maximum averaging. Slow response, smooth\n    analyser.smoothingTimeConstant = this.smoothingTimeConstant;\n\n    // Microphone -> analyser\n    const micSource = context.createMediaStreamSource(stream);\n    micSource.connect(analyser);\n    return analyser;\n  }\n\n  // Microphone successfully initalised, now have access to audio data\n  private onMicSuccess(stream: MediaStream) {\n    try {\n      const context = new AudioContext();\n\n      context.addEventListener(`statechange`, () => {\n        if (this.debug) console.log(`Audio context state: ${ context.state }`);\n      });\n\n      this.audioCtx = context;\n      this.analyserNode = this.setup(context, stream);\n\n      // Start loop\n      window.requestAnimationFrame(this.analyseLoop.bind(this));\n    } catch (error) {\n      this.#initInProgress = false;\n      console.error(error);\n    }\n  }\n\n  private analyseLoop() {\n    if (this.paused) {\n      if (this.debug) console.log(`Paused`);\n      return;\n    }\n\n    const a = this.analyserNode;\n    if (a === undefined) {\n      console.warn(`Analyser undefined`);\n      return;\n    }\n\n    try {\n      // Perform analysis\n      this.analyse(a, this);\n    } catch (error) {\n      console.error(error);\n    }\n\n    // Run again\n    window.requestAnimationFrame(this.analyseLoop.bind(this));\n  }\n\n  // visualise(wave, freq) {\n  //   if (!this.visualiser) return;\n  //   this.visualiser.renderWave(wave, true);\n  //   this.visualiser.renderFreq(freq);\n  // }\n\n  /**\n   * Returns the maximum FFT value within the given frequency range\n   */\n  getFrequencyRangeMax(\n    lowFreq: number,\n    highFreq: number,\n    freqData: readonly number[]\n  ): number {\n    const samples = this.sliceByFrequency(lowFreq, highFreq, freqData);\n    return max(samples);\n  }\n\n  /**\n   * Returns a sub-sampling of frequency analysis data that falls between\n   * `lowFreq` and `highFreq`.\n   * @param lowFreq Low frequency\n   * @param highFreq High frequency\n   * @param freqData Full-spectrum frequency data\n   * @returns Sub-sampling of analysis\n   */\n  sliceByFrequency(\n    lowFreq: number,\n    highFreq: number,\n    freqData: readonly number[]\n  ) {\n    const lowIndex = this.getIndexForFrequency(lowFreq);\n    const highIndex = this.getIndexForFrequency(highFreq);\n\n    // Grab a 'slice' of the array between these indexes\n    const samples = freqData.slice(lowIndex, highIndex);\n    return samples;\n  }\n\n  /**\n   * Returns the starting frequency for a given binned frequency index.\n   * @param index Array index\n   * @returns Sound frequency\n   */\n  getFrequencyAtIndex(index: number): number {\n    const a = this.analyserNode;\n    const ctx = this.audioCtx;\n    if (a === undefined) throw new Error(`Analyser not available`);\n    if (ctx === undefined) throw new Error(`Audio context not available`);\n\n    resultThrow(integerTest(index, `positive`, `index`));\n    if (index > a.frequencyBinCount) {\n      throw new Error(\n        `Index ${ index } exceeds frequency bin count ${ a.frequencyBinCount }`\n      );\n    }\n\n    return (index * ctx.sampleRate) / (a.frequencyBinCount * 2);\n  }\n\n  /**\n   * Returns a binned array index for a given frequency\n   * @param freq Sound frequency\n   * @returns Array index into frequency bins\n   */\n  getIndexForFrequency(freq: number): number {\n    const a = this.analyserNode;\n    if (a === undefined) throw new Error(`Analyser not available`);\n\n    const nyquist = a.context.sampleRate / 2;\n    const index = Math.round((freq / nyquist) * a.frequencyBinCount);\n    if (index < 0) return 0;\n    if (index >= a.frequencyBinCount) return a.frequencyBinCount - 1;\n    return index;\n  }\n}\n","import { resolveEl } from \"@ixfx/dom\";\n\nimport { shortGuid } from \"@ixfx/random\";\nimport type { BasicAudioElement } from \"./types.js\";\n\n/**\n * Scans page for <AUDIO> elements and creates playable controllers for them.\n * It uses the element's 'id' attribute as a way of fetching one later.\n * \n * ```js\n * const ae = new AudioElements();\n * ae.init(); // Initialise\n * \n * const a = ae.get('kick'); // Get the source that had id 'kick'\n * ```\n */\nexport class AudioElements {\n  #initialised = false\n  #sources = new Map<string, BasicAudioElement>();\n  filterType: BiquadFilterType = `lowpass`;\n\n  constructor() {}\n\n  init() {\n    if (this.#initialised) return;\n    this.#initialised = true;\n\n    for (const element of document.querySelectorAll(`audio`)) {\n      this.#sources.set(element.id, createFromAudioElement(element, this.filterType));\n    }\n  }\n\n  /**\n   * Gets a BasicAudio instance by key\n   * @param key \n   * @returns BasicAudio instance, or undefined\n   */\n  get(key: string): BasicAudioElement | undefined {\n    this.init();\n    return this.#sources.get(key);\n  }\n}\n\n/**\n * Create a BasicAudioElement instance from an <AUDIO> tag in the HTML document.\n * \n * See {@link AudioElements} to automatically create sources from all <AUDIO> elements.\n * @param audioElementOrQuery Element or query (eg '#some-id') \n * @param filterType Filter type. Defaults to 'lowpass'\n * @returns \n */\nexport function createFromAudioElement(audioElementOrQuery: HTMLMediaElement | string, filterType: BiquadFilterType = `lowpass`): BasicAudioElement {\n  const el = resolveEl(audioElementOrQuery);\n\n  const context = new AudioContext();\n\n  // Source from AUDIO element\n  const source = context.createMediaElementSource(el);\n\n  // Create stereo panner\n  const pan = context.createStereoPanner();\n\n  // Create gain node\n  const gain = context.createGain();\n\n  // Create filter\n  const filter = context.createBiquadFilter();\n  filter.type = filterType;\n\n  // Patch in\n  // AUDIO elem -> gain -> panner -> speakers\n  source.connect(gain);\n  gain.connect(pan);\n  pan.connect(filter);\n  filter.connect(context.destination);\n\n  return {\n    pan, gain, filter,\n    id: el.id,\n    ctx: context,\n    el\n  };\n}","import { shortGuid } from \"@ixfx/random\";\nimport type { AudioOscillatorOptions, BasicAudioOscillator } from \"./types.js\";\n\n/**\n * Initialise audio with an oscillator source\n * @param oscillatorOptions\n * @returns BasicAudio instance\n */\nexport function createOscillator(oscillatorOptions: Partial<AudioOscillatorOptions> = {}): BasicAudioOscillator {\n  const context = new AudioContext();\n  const oscType = oscillatorOptions.type ?? `sawtooth`;\n  const oscFreq = oscillatorOptions.frequency ?? 440;\n  const id = oscillatorOptions.id ?? shortGuid();\n\n  // Source oscillator\n  const source = context.createOscillator();\n  source.type = oscType;\n  source.frequency.setValueAtTime(oscFreq, context.currentTime);\n\n  // Create stereo panner\n  const pan = context.createStereoPanner();\n\n  // Create gain node\n  const gain = context.createGain();\n\n  // Create filter\n  const filter = context.createBiquadFilter();\n\n  // Patch in\n  // Oscillator -> gain -> panner -> speakers\n  source.connect(gain);\n  gain.connect(pan);\n  pan.connect(filter);\n  filter.connect(context.destination);\n\n  return {\n    pan, gain, filter,\n    ctx: context,\n    osc: source,\n    id\n  };\n}","export * from './analyser.js';\nexport type * from './types.js';\nexport * from './visualiser.js';\nexport * from './from-audio-element.js';\nexport * from './from-oscillator.js';","import { type EvalOpts, type Options, deviceEval } from './espruino.js';\nimport { NordicBleDevice } from './nordic-ble-device.js';\n\n/**\n * An Espruino BLE-connection\n *\n * See [online demos](https://demos.ixfx.fun/io/)\n *\n * Use the `puck` function to initialise and connect to a Puck.js.\n * It must be called in a UI event handler for browser security reasons.\n *\n * ```js\n * const e = await Espruino.puck();\n * ```\n *\n * To connect to a particular device:\n *\n * ```js\n * const e = await Espruino.puck({name:`Puck.js a123`});\n * ```\n *\n * Listen for events:\n * ```js\n * // Received something\n * e.addEventListener(`data`, d => console.log(d.data));\n * // Monitor connection state\n * e.addEventListener(`change`, c => console.log(`${d.priorState} -> ${d.newState}`));\n * ```\n *\n * Write to the device (note the \\n for a new line at the end of the string). This will\n * execute the code on the Espruino.\n *\n * ```js\n * e.write(`digitalPulse(LED1,1,[10,500,10,500,10]);\\n`);\n * ```\n *\n * Run some code and return result:\n * ```js\n * const result = await e.eval(`2+2\\n`);\n * ```\n */\nexport class EspruinoBleDevice extends NordicBleDevice {\n  evalTimeoutMs: number;\n  evalReplyBluetooth = true;\n\n  /**\n   * Creates instance. You probably would rather use {@link puck} to create.\n   * @param device\n   * @param opts\n   */\n  constructor(device: BluetoothDevice, opts: Options = {}) {\n    super(device, opts);\n    this.evalTimeoutMs = opts.evalTimeoutMs ?? 5 * 1000;\n  }\n\n  /**\n   * Writes a script to Espruino.\n   *\n   * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n   * and then the provided `code` followed by a new line.\n   *\n   * Use {@link eval} instead to execute remote code and get the result back.\n   *\n   * ```js\n   * // Eg from https://www.espruino.com/Web+Bluetooth\n   * writeScript(`\n   *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n   *  NRF.on('disconnect',()=>reset());\n   * `);\n   * ```\n   *\n   * @param code Code to send. A new line is added automatically.\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async writeScript(code: string) {\n    this.write(`\\u0003\\u0010reset();\\n`);\n    this.write(`\\u0010${ code }\\n`);\n  }\n\n  /**\n   * Sends some code to be executed on the Espruino. The result\n   * is packaged into JSON and sent back to your code. An exception is\n   * thrown if code can't be executed for some reason.\n   *\n   * ```js\n   * const sum = await e.eval(`2+2`);\n   * ```\n   *\n   * It will wait for a period of time for a well-formed response from the\n   * Espruino. This might not happen if there is a connection problem\n   * or a syntax error in the code being evaled. In cases like the latter,\n   * it will take up to `timeoutMs` (default 5 seconds) before we give up\n   * waiting for a correct response and throw an error.\n   *\n   * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n   * or too slowly. A default timeout can be given when creating the class.\n   *\n   * Options:\n   *  timeoutMs: Timeout for execution. 5 seconds by default\n   *  assumeExclusive If true, eval assumes all replies from controller are in response to eval. True by default\n   *  debug: If true, execution is traced via `warn` callback\n   * @param code Code to run on the Espruino.\n   * @param opts Options\n   * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n   */\n  async eval(\n    code: string,\n    opts: EvalOpts = {},\n    warn?: (message: string) => void\n  ): Promise<string> {\n    const debug = opts.debug ?? false;\n    const warnCallback = warn ?? ((m) => { this.warn(m); });\n    return deviceEval(code, opts, this, `Bluetooth.println`, debug, warnCallback);\n  }\n  /*\n    const timeoutMs = opts.timeoutMs ?? this.evalTimeoutMs;\n    const assumeExclusive = opts.assumeExclusive ?? true;\n\n    if (typeof code !== `string`) throw new Error(`code parameter should be a string`);\n      \n    return new Promise((resolve, reject) => {\n      // Generate a random id so reply can be matched up with this request\n      const id = randomString(5);\n\n      const onData = (d:DataEvent) => {\n        try {\n          // Parse reply, expecting JSON.\n          const dd = JSON.parse(d.data);\n\n          // Check for reply field, and that it matches\n          if (`reply` in dd) {\n            if (dd.reply === id) {\n              done(); // Stop waiting for result\n              if (`result` in dd) {\n                resolve(dd.result);\n              }\n            } else {\n              this.warn(`Expected reply ${id}, got ${dd.reply}`);\n            }\n          }\n        } catch (ex:unknown) {\n          // If there was a syntax error, response won't be JSON\n          if (assumeExclusive) {\n            // Fail with unexpected reply as the message\n            done(d.data);\n          } else {\n            // Unexpected reply, but we cannot be sure if it's in response to eval or\n            // some other code running on board. So just warn and eventually timeout\n            this.warn(ex);\n          }\n        }\n      };\n\n      const onStateChange = (e:StateChangeEvent) => {\n        if (e.newState !== `connected`) done(`State changed to '${e.newState}', aborting`);\n      };\n\n      this.addEventListener(`data`, onData);\n      this.addEventListener(`change`, onStateChange);\n\n      // Init waitFor\n      const done = waitFor(timeoutMs, (reason:string) => {\n        reject(reason);\n      }, () => {\n        // If we got a response or there was a timeout, remove event listeners\n        this.removeEventListener(`data`, onData);\n        this.removeEventListener(`change`, onStateChange);\n      });\n\n      this.write(`\\x10Bluetooth.println(JSON.stringify({reply:\"${id}\", result:JSON.stringify(${code})}))\\n`);\n    });\n  */\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { StateMachineWithEvents, type StateChangeEvent } from '@ixfx/flow/state-machine';\n//import { type StateChangeEvent } from '../flow/StateMachineWithEvents.js';\nimport { indexOfCharCode, omitChars } from '@ixfx/core/text';\nimport { retryFunction } from '@ixfx/flow';\nimport { Codec } from './codec.js';\nimport { StringReceiveBuffer } from './string-receive-buffer.js';\nimport { StringWriteBuffer } from './string-write-buffer.js';\nimport {\n  type GenericStateTransitions,\n} from './types.js';\nimport { genericStateTransitionsInstance } from './generic-state-transitions.js';\n\n/**\n * Options for JsonDevice\n */\nexport type JsonDeviceOpts = {\n  /**\n   * How much data to transfer at a time\n   */\n  readonly chunkSize?: number;\n  /**\n   * Name of device. This is only used for assisting the console.log output\n   */\n  readonly name?: string;\n  /**\n   * Number of times to automatically try to reconnect\n   */\n  readonly connectAttempts?: number;\n  /**\n   * If true, additional logging will be done\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Data received event\n */\nexport type JsonDataEvent = {\n  /**\n   * Data received\n   */\n  readonly data: string;\n};\n\n/**\n * Events emitted by JsonDevice\n */\nexport type JsonDeviceEvents = {\n  /**\n   * Data received\n   */\n  readonly data: JsonDataEvent;\n  /**\n   * State changed\n   */\n  readonly change: StateChangeEvent<GenericStateTransitions>;\n};\n\nexport abstract class JsonDevice extends SimpleEventEmitter<JsonDeviceEvents> {\n  states: StateMachineWithEvents<GenericStateTransitions>;\n  codec: Codec;\n\n  verboseLogging = false;\n  name: string;\n  connectAttempts: number;\n  chunkSize: number;\n\n  rxBuffer: StringReceiveBuffer;\n  txBuffer: StringWriteBuffer;\n\n  constructor(config: JsonDeviceOpts = {}) {\n    super();\n\n    // Init\n    this.verboseLogging = config.debug ?? false;\n    this.chunkSize = config.chunkSize ?? 1024;\n    this.connectAttempts = config.connectAttempts ?? 3;\n    this.name = config.name ?? `JsonDevice`;\n\n    // Transmit buffer\n    this.txBuffer = new StringWriteBuffer(async (data) => {\n      // When we have data to actually write to device\n\n      // eslint-disable-next-line @typescript-eslint/await-thenable\n      await this.writeInternal(data);\n    }, config);\n\n    // Receive buffer\n    this.rxBuffer = new StringReceiveBuffer((line) => {\n      this.fireEvent(`data`, { data: line });\n    });\n\n    this.codec = new Codec();\n    this.states = new StateMachineWithEvents(genericStateTransitionsInstance, {\n      initial: `ready`,\n    });\n\n    this.states.addEventListener(`change`, (event) => {\n      this.fireEvent(`change`, event);\n      this.verbose(`${ event.priorState } -> ${ event.newState }`);\n      if (event.priorState === `connected`) {\n        // Clear out buffers\n        this.rxBuffer.clear();\n        this.txBuffer.clear();\n      }\n    });\n  }\n\n  get isConnected(): boolean {\n    return this.states.state === `connected`;\n  }\n\n  get isClosed(): boolean {\n    return this.states.state === `closed`;\n  }\n\n  write(txt: string) {\n    if (this.states.state !== `connected`) {\n      throw new Error(`Cannot write while state is ${ this.states.state }`);\n    }\n    this.txBuffer.add(txt);\n  }\n\n  /**\n   * Writes text to output device\n   * @param txt\n   */\n  protected abstract writeInternal(txt: string): void;\n\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async close() {\n    if (this.states.state !== `connected`) return;\n\n    // console.log(`rxBuffer closing`);\n    // try {\n    //   await this.rxBuffer.close();\n    // } catch (e) {\n    //   console.warn(e);\n    // }\n\n    // console.log(`txBuffer closing`);\n    // try {\n    //   await this.txBuffer.close();\n    // } catch (e) {\n    //   console.warn(e);\n    // }\n\n    // console.log(`calling onClose`);\n\n    this.onClosed();\n  }\n\n  /**\n   * Must change state\n   */\n  abstract onClosed(): void;\n\n  abstract onPreConnect(): Promise<void>;\n\n  async connect() {\n    const attempts = this.connectAttempts;\n\n    this.states.state = `connecting`;\n    await this.onPreConnect();\n\n    await retryFunction(\n      async () => {\n        await this.onConnectAttempt();\n        this.states.state = `connected`;\n        return true;\n      },\n      {\n        limitAttempts: attempts,\n        startAt: 200,\n      }\n    );\n  }\n\n  /**\n   * Should throw if did not succeed.\n   */\n  protected abstract onConnectAttempt(): Promise<void>;\n\n  private onRx(event: Event) {\n    //const rx = this.rx;\n    //if (rx === undefined) return;\n\n\n    const view = (event.target as any).value as DataView;\n    if (view === undefined) return;\n\n    let string_ = this.codec.fromBuffer(view.buffer as ArrayBuffer);\n\n    // Check for flow control chars\n    const plzStop = indexOfCharCode(string_, 19);\n    const plzStart = indexOfCharCode(string_, 17);\n\n    // Remove if found\n    if (plzStart && plzStop < plzStart) {\n      this.verbose(`Tx plz start`);\n      string_ = omitChars(string_, plzStart, 1);\n      this.txBuffer.paused = false;\n    }\n    if (plzStop && plzStop > plzStart) {\n      this.verbose(`Tx plz stop`);\n      string_ = omitChars(string_, plzStop, 1);\n      this.txBuffer.paused = true;\n    }\n\n    this.rxBuffer.add(string_);\n  }\n\n  protected verbose(m: string) {\n    if (this.verboseLogging) console.info(this.name, m);\n  }\n\n  protected log(m: string) {\n    console.log(this.name, m);\n  }\n\n  protected warn(m: unknown) {\n    console.warn(this.name, m);\n  }\n}\n","import {\n  type JsonDeviceOpts,\n  JsonDevice,\n} from './json-device.js';\n\nexport type SerialOpts = JsonDeviceOpts & {\n  readonly filters?: readonly SerialPortFilter[];\n  readonly baudRate?: number;\n  /**\n   * End-of-line string sequence. \\r\\n by default.\n   */\n  readonly eol?: string;\n};\n\n/**\n * Serial device. Assumes data is sent with new line characters (\\r\\n) between messages.\n *\n * ```\n * import { Serial } from '@ixfx/io.js'\n * const s = new Serial.Device();\n * s.addEventListener(`change`, evt => {\n *  console.log(`State change ${evt.priorState} -> ${evt.newState}`);\n *  if (evt.newState === `connected`) {\n *    // Do something when connected...\n *  }\n * });\n *\n * // In a UI event handler...\n * s.connect();\n * ```\n *\n * Reading incoming data:\n * ```\n * // Parse incoming data as JSON\n * s.addEventListener(`data`, evt => {\n *  try {\n *    const o = JSON.parse(evt.data);\n *    // If we get this far, JSON is legit\n *  } catch (ex) {\n *  }\n * });\n * ```\n *\n * Writing to the microcontroller\n * ```\n * s.write(JSON.stringify({msg:\"hello\"}));\n * ```\n */\nexport class Device extends JsonDevice {\n  port: SerialPort | undefined;\n  tx: WritableStreamDefaultWriter<string> | undefined;\n  abort: AbortController;\n  baudRate: number;\n\n  constructor(private config: SerialOpts = {}) {\n    super(config);\n\n    this.abort = new AbortController();\n\n    const eol = config.eol ?? `\\r\\n`;\n\n    this.baudRate = config.baudRate ?? 9600;\n    if (config.name === undefined) this.name = `Serial.Device`;\n\n    // Serial.println on microcontroller == \\r\\n\n    this.rxBuffer.separator = eol;\n  }\n\n  /**\n   * Writes text collected in buffer\n   * @param txt\n   */\n  protected async writeInternal(txt: string) {\n    if (this.tx === undefined) throw new Error(`tx not ready`);\n    try {\n      this.tx.write(txt);\n    } catch (error: unknown) {\n      this.warn(error);\n    }\n  }\n\n  onClosed(): void {\n    this.tx?.releaseLock();\n\n    this.abort.abort(`closing port`);\n    // try {\n    //   this.port?.close();\n    // } catch (ex) {\n    //   this.warn(ex);\n    // }\n    this.states.state = `closed`;\n  }\n\n  onPreConnect(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async onConnectAttempt(): Promise<void> {\n    let reqOpts: SerialPortRequestOptions = {\n      filters: []\n    };\n    const openOpts: SerialOptions = {\n      baudRate: this.baudRate,\n    };\n\n    if (this.config.filters) reqOpts = { filters: [ ...this.config.filters ] };\n    this.port = await navigator.serial.requestPort(reqOpts);\n\n    this.port.addEventListener(`disconnect`, (_) => {\n      this.close();\n    });\n\n    await this.port.open(openOpts);\n\n    const txW = this.port.writable;\n    const txText = new TextEncoderStream();\n    if (txW !== null) {\n      txText.readable\n        .pipeTo(txW, { signal: this.abort.signal })\n        .catch((error) => {\n          console.log(`Serial.onConnectAttempt txText pipe:`);\n          console.log(error);\n        });\n      this.tx = txText.writable.getWriter();\n    }\n\n    const rxR = this.port.readable;\n    const rxText = new TextDecoderStream();\n    if (rxR !== null) {\n      rxR\n        .pipeTo(rxText.writable, { signal: this.abort.signal })\n        .catch((error) => {\n          console.log(`Serial.onConnectAttempt rxR pipe:`);\n          console.log(error);\n        });\n      rxText.readable\n        .pipeTo(this.rxBuffer.writable(), { signal: this.abort.signal })\n        .catch((error) => {\n          console.log(`Serial.onConnectAttempt rxText pipe:`);\n          console.log(error);\n          try {\n            this.port?.close();\n          } catch (error) {\n            console.log(error);\n          }\n        });\n    }\n  }\n}\n\nexport { type JsonDeviceEvents, type JsonDataEvent, type JsonDeviceOpts } from './json-device.js';","import { deviceEval, type EvalOpts } from './espruino.js';\nimport { Device as SerialDevice, type SerialOpts } from './serial.js';\n\nexport type EspruinoSerialDeviceOpts = SerialOpts & {\n  readonly evalTimeoutMs?: number;\n};\n\nexport class EspruinoSerialDevice extends SerialDevice {\n  evalTimeoutMs: number;\n  evalReplyBluetooth = false;\n\n  constructor(opts?: EspruinoSerialDeviceOpts) {\n    super(opts);\n\n    if (opts === undefined) opts = {};\n    this.evalTimeoutMs = opts.evalTimeoutMs ?? 5 * 1000;\n  }\n\n  async disconnect() {\n    return super.close();\n  }\n\n  /**\n   * Writes a script to Espruino.\n   *\n   * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n   * and then the provided `code` followed by a new line.\n   *\n   * Use {@link eval} instead to execute remote code and get the result back.\n   *\n   * ```js\n   * // Eg from https://www.espruino.com/Web+Bluetooth\n   * writeScript(`\n   *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n   *  NRF.on('disconnect',()=>reset());\n   * `);\n   * ```\n   *\n   * @param code Code to send. A new line is added automatically.\n   */\n  writeScript(code: string) {\n    this.write(`\\u0003\\u0010reset();\\n`);\n    this.write(`\\u0010${ code }\\n`);\n  }\n\n  /**\n   * Sends some code to be executed on the Espruino. The result\n   * is packaged into JSON and sent back to your code. An exception is\n   * thrown if code can't be executed for some reason.\n   *\n   * ```js\n   * const sum = await e.eval(`2+2`);\n   * ```\n   *\n   * It will wait for a period of time for a well-formed response from the\n   * Espruino. This might not happen if there is a connection problem\n   * or a syntax error in the code being evaled. In cases like the latter,\n   * it will take up to `timeoutMs` (default 5 seconds) before we give up\n   * waiting for a correct response and throw an error.\n   *\n   * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n   * or too slowly. A default timeout can be given when creating the class.\n   *\n   * Options:\n   *  timeoutMs: Timeout for execution. 5 seconds by default\n   *  assumeExclusive: If true, eval assumes all replies from controller are in response to eval. True by default\n   *  debug: If true, execution is traced via `warn` callback\n   * @param code Code to run on the Espruino.\n   * @param opts Options\n   * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n   */\n  async eval(\n    code: string,\n    opts: EvalOpts = {},\n    warn?: (message: string) => void\n  ): Promise<string> {\n    const debug = opts.debug ?? false;\n    const warner = warn ?? ((m) => { this.warn(m); });\n\n    return deviceEval(code, opts, this, `USB.println`, debug, warner);\n  }\n}\n","import { type StateChangeEvent } from '@ixfx/flow/state-machine';\nimport { type ISimpleEventEmitter } from '@ixfx/events';\nimport { string as randomString } from '@ixfx/random';\nimport { waitFor } from '@ixfx/flow';\nimport { EspruinoBleDevice } from './espruino-ble-device.js';\nimport { defaultOpts as NordicDefaults } from './nordic-ble-device.js';\nimport { getErrorMessage } from '@ixfx/debug';\nimport {\n  EspruinoSerialDevice,\n} from './espruino-serial-device.js';\nimport type {\n  GenericStateTransitions,\n  IoDataEvent,\n  IoEvents,\n} from './types.js';\n\nexport { type EspruinoSerialDeviceOpts, EspruinoSerialDevice } from './espruino-serial-device.js';\nexport { EspruinoBleDevice } from './espruino-ble-device.js';\nexport type EspruinoStates =\n  | `ready`\n  | `connecting`\n  | `connected`\n  | `closed`\n  | `closing`\n  ;\n\n/**\n * Options for device\n */\nexport type Options = {\n  /**\n   * Default milliseconds to wait before giving up on a well-formed reply. 5 seconds is the default.\n   */\n  readonly evalTimeoutMs?: number;\n  /**\n   * Name of device. Only used for printing log mesages to the console\n   */\n  readonly name?: string;\n\n  /**\n   * If true, additional logging information is printed\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Options for code evaluation\n */\nexport type EvalOpts = {\n  /**\n   * Milliseconds to wait before giving up on well-formed reply. 5 seconds is the default.\n   */\n  readonly timeoutMs?: number;\n  /**\n   * If true (default), it assumes that anything received from the board\n   * is a response to the eval\n   */\n  readonly assumeExclusive?: boolean;\n\n  /**\n   * If true, executed code is traced\n   */\n  readonly debug?: boolean;\n};\n\nexport type EspruinoBleOpts = {\n  /**\n   * If the name is specified, this value is used\n   * for filtering Bluetooth devices\n   */\n  readonly name?: string;\n  /**\n   * If true, additional logging messages are\n   * displayed on the console\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, these filtering options are used instead\n   */\n  readonly filters?: readonly BluetoothLEScanFilter[];\n};\n\n/**\n * Instantiates a Puck.js. See {@link EspruinoBleDevice} for more info.\n * [Online demos](https://demos.ixfx.fun/io/)\n *\n * If `opts.name` is specified, this will the the Bluetooth device sought.\n *\n * ```js\n * import { Espruino } from '@ixfx/io.js'\n * const e = await Espruino.puck({ name:`Puck.js a123` });\n * ```\n *\n * If no name is specified, a list of all devices starting with `Puck.js` are shown.\n *\n * To get more control over filtering, pass in `opts.filter`. `opts.name` is not used as a filter in this scenario.\n *\n * ```js\n * import { Espruino } from '@ixfx/io.js'\n * const filters = [\n *  { namePrefix: `Puck.js` },\n *  { namePrefix: `Pixl.js` },\n *  {services: [NordicDefaults.service] }\n * ]\n * const e = await Espruino.puck({ filters });\n * ```\n *\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const puck = async (opts: EspruinoBleOpts = {}) => {\n  const name = opts.name ?? `Puck`;\n  const debug = opts.debug ?? false;\n\n  const device = await navigator.bluetooth.requestDevice({\n    filters: getFilters(opts, `Puck.js`),\n    optionalServices: [ NordicDefaults.service ],\n  });\n\n  if (opts.debug) {\n    console.info(`Espruino.puck device name: ${ device.name }`);\n  }\n  const d = new EspruinoBleDevice(device, { name, debug });\n  await d.connect();\n  return d;\n};\n\nexport const bangle = async (opts: EspruinoBleOpts = {}) => {\n  const name = opts.name ?? `Bangle`;\n  const debug = opts.debug ?? false;\n\n  const device = await navigator.bluetooth.requestDevice({\n    filters: getFilters(opts, `Bangle.js`),\n    optionalServices: [ NordicDefaults.service ],\n  });\n  if (opts.debug) {\n    console.info(`Espruino.bangle device name: ${ device.name }`);\n  }\n  const d = new EspruinoBleDevice(device, { name, debug });\n  await d.connect();\n  return d;\n};\n\n/**\n * Create a serial-connected Espruino device.\n *\n * ```js\n * import { Espruino } from '@ixfx/io.js'\n * const e = await Espruio.serial();\n * e.connect();\n * ```\n *\n * Options:\n * ```js\n * import { Espruino } from '@ixfx/io.js'\n * const e = await Espruino.serial({ debug: true, evalTimeoutMs: 1000, name: `My Pico` });\n * e.connect();\n * ```\n *\n * Listen for events:\n * ```js\n * e.addEventListener(`change`, evt => {\n *  console.log(`State change ${evt.priorState} -> ${evt.newState}`);\n *  if (evt.newState === `connected`) {\n *    // Do something when connected...\n *  }\n * });\n * ```\n *\n * Reading incoming data:\n * ```\n * // Parse incoming data as JSON\n * s.addEventListener(`data`, evt => {\n *  try {\n *    const o = JSON.parse(evt.data);\n *    // If we get this far, JSON is legit\n *  } catch (ex) {\n *  }\n * });\n * ```\n *\n * Writing to the microcontroller\n * ```\n * s.write(JSON.stringify({msg:\"hello\"}));\n * ```\n * @param opts\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const serial = async (\n  opts: {\n    readonly name?: string;\n    readonly debug?: boolean;\n    readonly evalTimeoutMs?: number;\n  } = {}\n) => {\n  const d = new EspruinoSerialDevice(opts);\n  await d.connect();\n  return d;\n};\n\n/**\n * Returns a list of BLE scan filters, given the\n * connect options.\n * @param opts\n * @returns\n */\nconst getFilters = (opts: EspruinoBleOpts, defaultNamePrefix: string) => {\n  const filters: BluetoothLEScanFilter[] = [];\n\n  if (opts.filters) {\n    filters.push(...opts.filters);\n  } else if (opts.name) {\n    // Name filter\n    filters.push({ name: opts.name });\n    console.info(`Filtering Bluetooth devices by name '${ opts.name }'`);\n  } else {\n    // Default filter\n    filters.push({ namePrefix: defaultNamePrefix });//`Puck.js` });\n  }\n  // {namePrefix: 'Pixl.js'},\n  // {namePrefix: 'MDBT42Q'},\n  // {namePrefix: 'RuuviTag'},\n  // {namePrefix: 'iTracker'},\n  // {namePrefix: 'Thingy'},\n  // {namePrefix: 'Bangle.js'},\n  // {namePrefix: 'Espruino'},\n  //{services: [NordicDefaults.service]}\n\n  return filters;\n};\n/**\n * Connects to a generic Espruino BLE device. See  {@link EspruinoBleDevice} for more info.\n * Use {@link puck} if you're connecting to a Puck.js\n *\n * If `opts.name` is specified, only this BLE device will be shown.\n * ```js\n * const e = await connectBle({ name: `Puck.js a123` });\n * ```\n *\n * `opts.filters` overrides and sets arbitary filters.\n *\n * ```js\n * import { Espruino } from '@ixfx/io.js'\n * const filters = [\n *  { namePrefix: `Puck.js` },\n *  { namePrefix: `Pixl.js` },\n *  {services: [NordicDefaults.service] }\n * ]\n * const e = await Espruino.connectBle({ filters });\n * ```\n *\n * @returns Returns a connected instance, or throws exception if user cancelled or could not connect.\n */\nexport const connectBle = async (opts: EspruinoBleOpts = {}) => {\n  const device = await navigator.bluetooth.requestDevice({\n    filters: getFilters(opts, `Puck.js`),\n    optionalServices: [ NordicDefaults.service ],\n  });\n  const d = new EspruinoBleDevice(device, { name: `Espruino`, ...opts });\n  await d.connect();\n  return d;\n};\n\nexport type Events = IoEvents<GenericStateTransitions>;\n/**\n * EspruinoDevice\n *\n * This base interface is implemented by {@link EspruinoBleDevice} and {@link EspruinoSerialDevice}.\n */\nexport type EspruinoDevice = {\n  /**\n   * Sends some code to be executed on the Espruino. The result\n   * is packaged into JSON and sent back to your code. An exception is\n   * thrown if code can't be executed for some reason.\n   *\n   * ```js\n   * const sum = await e.eval(`2+2`);\n   * ```\n   *\n   * It will wait for a period of time for a well-formed response from the\n   * Espruino. This might not happen if there is a connection problem\n   * or a syntax error in the code being evaled. In cases like the latter,\n   * it will take up to `timeoutMs` (default 5 seconds) before we give up\n   * waiting for a correct response and throw an error.\n   *\n   * Tweaking of the timeout may be required if `eval()` is giving up too quickly\n   * or too slowly. A default timeout can be given when creating the class.\n   *\n   * Options:\n   *  timeoutMs: Timeout for execution. 5 seconds by default\n   *  assumeExclusive If true, eval assumes all replies from controller are in response to eval. True by default\n   *  debug: If true, execution is traced via `warn` callback\n   * @param code Code to run on the Espruino.\n   * @param opts Options\n   * @param warn Function to pass warning/trace messages to. If undefined, this.warn is used, printing to console.\n   */\n  eval(\n    code: string,\n    opts?: EvalOpts,\n    warn?: (message: string) => void\n  ): Promise<string>;\n\n  /**\n   * Write some code for immediate execution. This is a lower-level\n   * alternative to {@link writeScript}. Be sure to include a new line character '\\n' at the end.\n   * @param m Code\n   */\n  write(m: string): void;\n\n  /**\n   * Writes a script to Espruino.\n   *\n   * It will first send a CTRL+C to cancel any previous input, `reset()` to clear the board,\n   * and then the provided `code` followed by a new line.\n   *\n   * Use {@link eval} instead to execute remote code and get the result back.\n   *\n   * ```js\n   * // Eg from https://www.espruino.com/Web+Bluetooth\n   * espruino.writeScript(`\n   *  setInterval(() => Bluetooth.println(E.getTemperature()), 1000);\n   *  NRF.on('disconnect',()=>reset());\n   * `);\n   * ```\n   *\n   * @param code Code to send. A new line is added automatically.\n   */\n  writeScript(code: string): void;\n\n  /**\n   * Disconnect\n   */\n  disconnect(): void;\n\n  /**\n   * Gets the current evaluation (millis)\n   */\n  get evalTimeoutMs(): number;\n\n  get isConnected(): boolean;\n} & ISimpleEventEmitter<Events>\n\n/**\n * Evaluates some code on an Espruino device.\n *\n * Options:\n * * timeoutMs: how many millis to wait before assuming code failed. If not specified, `device.evalTimeoutMs` is used as a default.\n * * assumeExlusive: assume device is not producing any other output than for our evaluation\n *\n * A random string is created to pair eval requests and responses. `code` will be run on the device, with the result\n * wrapped in JSON, and in turn wrapped in a object that is sent back.\n *\n * The actual code that gets sent to the device is then:\n * `\\x10${evalReplyPrefix}(JSON.stringify({reply:\"${id}\", result:JSON.stringify(${code})}))\\n`\n *\n * For example, it might end up being:\n * `\\x10Bluetooth.println(JSON.stringify({reply: \"a35gP\", result: \"{ 'x': '10' }\" }))\\n`\n *\n * @param code Code to evaluation\n * @param opts Options for evaluation\n * @param device Device to execute on\n * @param evalReplyPrefix How to send code back (eg `Bluetooth.println`, `console.log`)\n * @param debug If true, the full evaled code is printed locally to the console\n * @param warn Callback to display warnings\n * @returns\n */\nexport const deviceEval = async (\n  code: string,\n  opts: EvalOpts = {},\n  device: EspruinoDevice,\n  evalReplyPrefix: string,\n  debug: boolean,\n  warn: (m: string) => void\n): Promise<string> => {\n  const timeoutMs = opts.timeoutMs ?? device.evalTimeoutMs;\n  const assumeExclusive = opts.assumeExclusive ?? true;\n\n  if (typeof code !== `string`) {\n    throw new TypeError(`Param 'code' should be a string. Got: ${ typeof code }`);\n  }\n\n  return new Promise((resolve, reject) => {\n    // Generate a random id so reply can be matched up with this request\n    const id = randomString(5);\n\n    const onData = (d: IoDataEvent) => {\n      try {\n        let cleaned = d.data.trim();\n        // Prefixed with angled bracket sometimes?\n        if (cleaned.startsWith(`>{`) && cleaned.endsWith(`}`)) {\n          cleaned = cleaned.slice(1);\n        }\n\n        // Parse reply, expecting JSON.\n        const dd = JSON.parse(cleaned);\n\n        // Check for reply field, and that it matches\n        if (`reply` in dd) {\n\n          if (dd.reply === id) {\n            done(); // Stop waiting for result\n            if (`result` in dd) {\n              resolve(dd.result);\n            }\n          } else {\n            warn(`Expected reply ${ id }, got ${ dd.reply }`);\n          }\n        } else {\n          warn(`Expected packet, missing 'reply' field. Got: ${ d.data }`);\n        }\n      } catch (error: unknown) {\n        // If there was a syntax error, response won't be JSON\n        if (assumeExclusive) {\n          // Fail with unexpected reply as the message\n          done(`Unexpected reply: ${ d.data }. Error: ${ getErrorMessage(error) }`);\n        } else {\n          // Unexpected reply, but we cannot be sure if it's in response to eval or\n          // some other code running on board. So just warn and eventually timeout\n          warn(getErrorMessage(error));\n        }\n      }\n    };\n\n    const onStateChange = (event: StateChangeEvent<GenericStateTransitions>) => {\n      if (event.newState !== `connected`) {\n        done(`State changed to '${ event.newState }', aborting`);\n      }\n    };\n\n    device.addEventListener(`data`, onData);\n    device.addEventListener(`change`, onStateChange);\n\n    // Init waitFor\n    const done = waitFor(\n      timeoutMs,\n      (reason: string) => {\n        reject(new Error(reason));\n      },\n      (_success) => {\n        // If we got a response or there was a timeout, remove event listeners\n        device.removeEventListener(`data`, onData);\n        device.removeEventListener(`change`, onStateChange);\n      }\n    );\n\n    const source = `\\u0010${ evalReplyPrefix }(JSON.stringify({reply:\"${ id }\", result:JSON.stringify(${ code })}))\\n`;\n    if (debug) warn(source);\n    device.write(source);\n  });\n};\n","import type { Rect } from '@ixfx/geometry/rect';\nimport { waitFor } from '@ixfx/flow';\nimport { getErrorMessage } from '@ixfx/debug';\n\nconst startTimeoutMs = 10_000;\n\n/**\n * Print available media devices to console\n * \n * ```js\n * camera.dumpDevices(); // Will print results to console\n * ```\n * @param filterKind Defaults `videoinput`\n */\nexport const dumpDevices = async (filterKind = `videoinput`) => {\n  const devices = await navigator.mediaDevices.enumerateDevices();\n\n  for (const d of devices) {\n    if (d.kind !== filterKind) continue;\n    console.log(d.label);\n    console.log(` Kind: ${ d.kind }`);\n    console.log(` Device id: ${ d.deviceId }`);\n  }\n};\n\n/**\n * Constraints when requesting a camera source\n */\nexport type Constraints = {\n  /**\n   * Camera facing: user is front-facing, environment is a rear camera\n   */\n  readonly facingMode?: `user` | `environment`;\n  /**\n   * Maximum resolution\n   */\n  readonly max?: Rect;\n  /**\n   * Minimum resolution\n   */\n  readonly min?: Rect;\n  /**\n   * Ideal resolution\n   */\n  readonly ideal?: Rect;\n  /**\n   * If specified, will try to use this media device id\n   */\n  readonly deviceId?: string;\n\n  /**\n   * Number of milliseconds to wait on `getUserMedia` before giving up.\n   * Defaults to 30seconds\n   */\n  readonly startTimeoutMs?: number;\n};\n\n/**\n * Result from starting a camera\n */\n//eslint-disable-next-line functional/no-mixed-types\nexport type StartResult = {\n  /**\n   * Call dispose to stop the camera feed and remove any created resources,\n   * such as a VIDEO element\n   */\n  readonly dispose: () => void;\n  /**\n   * Video element camera is connected to\n   */\n  readonly videoEl: HTMLVideoElement;\n};\n\n/**\n * Attempts to start a video-only stream from a camera into a hidden\n * VIDEO element for frame capture. The VIDEO element is created automatically.\n *\n *\n * ```js\n * import { Camera } from '@ixfx/io.js'\n * import { Video } from '@ixfx/visual.js'\n * try {\n *  const { videoEl, dispose } = await Camera.start();\n *  for await (const frame of Video.frames(videoEl)) {\n *    // Do something with pixels...\n *  }\n * } catch (ex) {\n *  console.error(`Video could not be started`);\n * }\n * ```\n *\n * Be sure to call the dispose() function to stop the video stream and remov\n * the created VIDEO element.\n *\n * _Constraints_ can be specified to select a camera and resolution:\n * ```js\n * import { Camera } from '@ixfx/io.js'\n * import { Video } from '@ixfx/visual.js'\n * \n * try {\n *  const { videoEl, dispose } = await Camera.start({\n *    facingMode: `environment`,\n *    max: { width: 640, height: 480 }\n *  });\n *  \n *  for await (const frame of Video.frames(videoEl)) {\n *    // Do something with pixels...\n *  }\n * } catch (ex) {\n *  // Can happen if user cancels camera request, for example.\n *  console.error(`Video could not be started`, ex);\n * }\n * ```\n * \n * An alternative to Video.frames is Video.capture.\n * @param constraints\n * @returns Returns `{ videoEl, dispose }`, where `videoEl` is the created VIDEO element, and `dispose` is a function for removing the element and stopping the video.\n */\nexport const start = async (\n  constraints: Constraints = {}\n): Promise<StartResult> => {\n  const videoEl = document.createElement(`VIDEO`) as HTMLVideoElement;\n  videoEl.style.display = `none`;\n  videoEl.playsInline = true;\n  videoEl.muted = true;\n\n  videoEl.classList.add(`ixfx-camera`);\n\n  document.body.append(videoEl);\n\n  let stopVideo = () => {\n    /* no-op */\n  };\n\n  const dispose = () => {\n    try {\n      // Stop source\n      stopVideo();\n    } catch {\n      /* no-op */\n    }\n\n    // Remove the element we created\n    videoEl.remove();\n  };\n\n  try {\n    // Attempt to start video\n    const r = await startWithVideoEl(videoEl, constraints);\n    stopVideo = r.dispose;\n    return { videoEl, dispose };\n  } catch (error) {\n    // If it didn't work, delete the created element\n    console.error(error);\n    dispose();\n    throw error;\n  }\n};\n\n/**\n * Attempts to start a video-only stream from a camera into the designated VIDEO element.\n * @param videoEl\n * @param constraints\n * @returns Result contains videoEl and dispose function\n */\nconst startWithVideoEl = async (\n  videoEl: HTMLVideoElement,\n  constraints: Constraints = {}\n): Promise<StartResult> => {\n  if (videoEl === undefined) throw new Error(`videoEl undefined`);\n  if (videoEl === null) throw new Error(`videoEl null`);\n\n  const maxResolution = constraints.max;\n  const minResolution = constraints.min;\n  const idealResolution = constraints.ideal;\n\n  // Setup constraints\n  const c = {\n    audio: false,\n    video: {\n      width: {},\n      height: {},\n    },\n  };\n\n  // Just in case some intuitive values are passed in...\n  if ((constraints as any).facingMode === `front`) {\n    constraints = { ...constraints, facingMode: `user` };\n  }\n  if ((constraints as any).facingMode === `back`) {\n    constraints = { ...constraints, facingMode: `environment` };\n  }\n\n  if (constraints.facingMode) {\n    (c.video as any).facingMode = constraints.facingMode;\n  }\n\n  if (constraints.deviceId) {\n    (c.video as any).deviceId = constraints.deviceId;\n  }\n\n  if (idealResolution) {\n    c.video.width = {\n      ...c.video.width,\n      ideal: idealResolution.width,\n    };\n    c.video.height = {\n      ...c.video.height,\n      ideal: idealResolution.height,\n    };\n  }\n\n  if (maxResolution) {\n    c.video.width = {\n      ...c.video.width,\n      max: maxResolution.width,\n    };\n    c.video.height = {\n      ...c.video.height,\n      max: maxResolution.height,\n    };\n  }\n\n  if (minResolution) {\n    c.video.width = {\n      ...c.video.width,\n      min: minResolution.width,\n    };\n    c.video.height = {\n      ...c.video.height,\n      min: minResolution.height,\n    };\n  }\n\n  // Request stream\n  const done = waitFor(\n    constraints.startTimeoutMs ?? startTimeoutMs,\n    (reason) => {\n      throw new Error(`Camera getUserMedia failed: ${ reason }`);\n    }\n  );\n\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(c);\n\n    // Clean-up function\n    const dispose = () => {\n      videoEl.pause();\n      const t = stream.getTracks();\n      for (const track of t) track.stop();\n    };\n\n    // Assign to VIDEO element\n    //eslint-disable-next-line functional/immutable-data\n    videoEl.srcObject = stream;\n    done();\n\n    const returnValue = { videoEl, dispose };\n    const p = new Promise<StartResult>((resolve, reject) => {\n      videoEl.addEventListener(`loadedmetadata`, () => {\n        videoEl\n          .play()\n          .then(() => {\n            resolve(returnValue);\n          })\n          .catch((error) => {\n            reject(error);\n          });\n      });\n    });\n    return p;\n  } catch (error) {\n    done(getErrorMessage(error));\n    throw error;\n  }\n};\n","/**\n * Result from starting a camera\n */\nexport type StartResult = {\n  /**\n   * Call dispose to stop the camera feed and remove any created resources,\n   * such as a VIDEO element\n   */\n  readonly dispose: () => void;\n  /**\n   * Video element camera is connected to\n   */\n  readonly videoEl: HTMLVideoElement;\n};\n\n/**\n * Starts video file playback, creating a VIDEO element automatically.\n * @param file File\n * @returns StartResult\n */\nexport const start = async (file: File): Promise<StartResult> => {\n  const videoEl = document.createElement(`VIDEO`) as HTMLVideoElement;\n  videoEl.style.display = `none`;\n  videoEl.playsInline = true;\n  videoEl.muted = true;\n\n  videoEl.classList.add(`ixfx-video`);\n\n  document.body.appendChild(videoEl);\n\n  //eslint-disable-next-line functional/no-let\n  let stopVideo = () => {\n    /* no-op */\n  };\n\n  const dispose = () => {\n    try {\n      // Stop source\n      stopVideo();\n    } catch {\n      /* no-op */\n    }\n\n    // Remove the element we created\n    videoEl.remove();\n  };\n\n  try {\n    // Attempt to start video\n    const r = await startWithVideoEl(videoEl, file);\n    stopVideo = r.dispose;\n    return { videoEl, dispose };\n  } catch (ex) {\n    // If it didn't work, delete the created element\n    console.error(ex);\n    dispose();\n    throw ex;\n  }\n};\n\n/**\n * Starts playback of a video file in the provided VIDEO element.\n * @param videoEl\n * @param file\n * @returns\n */\nconst startWithVideoEl = async (\n  videoEl: HTMLVideoElement,\n  file: File\n): Promise<StartResult> => {\n  if (videoEl === undefined) throw new Error(`videoEl undefined`);\n  if (videoEl === null) throw new Error(`videoEl null`);\n\n  const url = URL.createObjectURL(file);\n\n  videoEl.src = url;\n  videoEl.loop = true;\n\n  // Clean-up function\n  const dispose = () => {\n    videoEl.pause();\n  };\n\n  const returnValue = { videoEl, dispose };\n  const p = new Promise<StartResult>((resolve, reject) => {\n    videoEl.addEventListener(`loadedmetadata`, () => {\n      videoEl\n        .play()\n        .then(() => {\n          resolve(returnValue);\n        })\n        .catch((ex) => {\n          reject(ex);\n        });\n    });\n  });\n  return p;\n};\n","import { Video } from '@ixfx/visual';\nimport * as Camera from './camera.js';\nimport * as VideoFile from './video-file.js';\nimport type { FrameProcessorSources } from './types.js';\n\ntype State = `ready` | `initialised` | `disposed`;\n\n/**\n * Frame procesor options\n */\nexport type FrameProcessorOpts = {\n  /**\n   * If true, capture canvas will be shown. Default: false\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If true, raw source will be shown. Default: false.\n   */\n  readonly showPreview?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * Default constraints to use for the camera source\n   */\n  readonly cameraConstraints?: Camera.Constraints;\n\n  /**\n   * If specified, this canvas will be used for capturing frames to\n   */\n  readonly captureCanvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Frame Processor\n * Simplifies grabbing frames from a camera or video file.\n * \n * First, create:\n * ```js\n * const fp = new FrameProcessor();\n * ```\n * \n * Then either use the camera or a video file:\n * ```js\n * fp.useCamera(constraints);\n * // or:\n * gp.useVideo(file);\n * ```\n * \n * With `useCamera`, optionally specify {@link Camera.Constraints} to pick which camera and resolution.\n * \n * ```js\n * fp.getFrame(); // Gets the last frame\n * fp.dispose(); // Close down camera/file\n * ```\n * \n * See {@link FrameProcessorOpts} for details on available options.\n */\nexport class FrameProcessor {\n  private _source: FrameProcessorSources;\n  private _state: State;\n  private _teardownNeeded = false;\n\n  private _cameraConstraints: Camera.Constraints | undefined;\n  private _cameraStartResult: Camera.StartResult | undefined;\n  private _videoSourceCapture: Video.ManualCapturer | undefined;\n\n  private _videoFile: File | undefined;\n  private _videoStartResult: VideoFile.StartResult | undefined;\n\n  private _showCanvas: boolean;\n  private _showPreview: boolean;\n  private _postCaptureDraw;\n  private _timer: number;\n  private _captureCanvasEl?: HTMLCanvasElement;\n\n  /**\n   * Create a new frame processor\n   * @param opts\n   */\n  constructor(opts: FrameProcessorOpts = {}) {\n    this._state = `ready`;\n    this._source = ``;\n    this._timer = performance.now();\n    this._showCanvas = opts.showCanvas ?? false;\n    this._showPreview = opts.showPreview ?? false;\n    this._cameraConstraints = opts.cameraConstraints ?? undefined;\n    this._captureCanvasEl = opts.captureCanvasEl ?? undefined;\n    this._postCaptureDraw = opts.postCaptureDraw;\n  }\n\n  /**\n   * Hides or shows the raw source in the DOM\n   * @param enabled Preview enabled\n   */\n  showPreview(enabled: boolean) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    let el: HTMLElement | undefined;\n\n    switch (this._source) {\n      case `camera`: {\n        el = this._cameraStartResult?.videoEl;\n        if (el !== undefined) el.style.display = enabled ? `block` : `none`;\n        break;\n      }\n    }\n\n    this._showPreview = enabled;\n  }\n\n  /**\n   * Shows or hides the Canvas we're capturing to\n   * @param enabled\n   */\n  showCanvas(enabled: boolean) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    let el: HTMLElement | undefined;\n\n    if (this._source === `camera` || this._source === `video`) {\n      el = this._videoSourceCapture?.canvasEl;\n      if (el !== undefined) el.style.display = enabled ? `block` : `none`;\n    } else throw new Error(`Source not implemented: ${ this._source }`);\n\n    this._showCanvas = enabled;\n  }\n\n  /**\n   * Returns the current capturer instance\n   * @returns\n   */\n  getCapturer(): Video.ManualCapturer | undefined {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    if (this._source === `camera` || this._source === `video`) {\n      return this._videoSourceCapture;\n    }\n    throw new Error(`Source kind not supported ${ this._source }`);\n  }\n\n  /**\n   * Grab frames from a video camera source and initialises\n   * frame processor.\n   *\n   * If `constraints` are not specified, it will use the ones\n   * provided when creating the class, or defaults.\n   *\n   * @param constraints Override of constraints when requesting camera access\n   */\n  async useCamera(constraints?: Camera.Constraints) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n\n    this._source = `camera`;\n    if (this._teardownNeeded) this.teardown();\n    if (constraints) this._cameraConstraints = constraints;\n\n    await this.init();\n  }\n\n  async useVideo(file: File) {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n    this._source = `video`;\n    if (this._teardownNeeded) this.teardown();\n    this._videoFile = file;\n    await this.init();\n  }\n\n  /**\n   * Initialises camera\n   */\n  private async initCamera() {\n    const r = await Camera.start(this._cameraConstraints);\n    if (r === undefined) throw new Error(`Could not start camera`);\n    this._cameraStartResult = r;\n    void this.postInit(r);\n  }\n\n  private async initVideo() {\n    if (!this._videoFile) throw new Error(`Video file not defined`);\n    const r = await VideoFile.start(this._videoFile);\n    this._videoStartResult = r;\n\n    void this.postInit(r);\n  }\n\n  private async postInit(r: Camera.StartResult | VideoFile.StartResult) {\n    if (this._showPreview) r.videoEl.style.display = `block`;\n\n    // Set up manual capturer\n    this._videoSourceCapture = Video.manualCapture(r.videoEl, {\n      postCaptureDraw: this._postCaptureDraw,\n      showCanvas: this._showCanvas,\n      canvasEl: this._captureCanvasEl,\n    });\n\n    this._teardownNeeded = true;\n    this._cameraStartResult = r;\n    return Promise.resolve();\n  }\n\n  /**\n   * Closes down connections and removes created elements.\n   * Once disposed, the frame processor cannot be used\n   * @returns\n   */\n  dispose() {\n    if (this._state === `disposed`) return;\n    this.teardown();\n    this._state = `disposed`;\n  }\n\n  private async init() {\n    this._timer = performance.now();\n    switch (this._source) {\n      case `camera`: {\n        await this.initCamera();\n        break;\n      }\n      case `video`: {\n        await this.initVideo();\n        break;\n      }\n    }\n    this._state = `initialised`;\n  }\n\n  private teardown() {\n    if (!this._teardownNeeded) return;\n    if (this._source === `camera` || this._source === `video`) {\n      this._videoSourceCapture?.dispose();\n    }\n    switch (this._source) {\n      case `camera`: {\n        this._cameraStartResult?.dispose();\n        break;\n      }\n      case `video`: {\n        this._videoStartResult?.dispose();\n        break;\n      }\n    }\n    this._teardownNeeded = false;\n  }\n\n  /**\n   * Get the last frame\n   * @returns\n   */\n  getFrame(): ImageData | undefined {\n    if (this._state === `disposed`) throw new Error(`Disposed`);\n\n    switch (this._source) {\n      case `camera`: {\n        return this.getFrameCamera();\n      }\n      case `video`: {\n        return this.getFrameCamera();\n      }\n      default: {\n        throw new Error(`source type unhandled ${ this._source }`);\n      }\n    }\n  }\n\n  /**\n   * Get the timestamp of the processor (elapsed time since starting)\n   * @returns\n   */\n  getTimestamp(): number {\n    return performance.now() - this._timer;\n  }\n\n  private getFrameCamera(): ImageData | undefined {\n    return this._videoSourceCapture?.capture();\n  }\n}\n","import { retryTask, eventRace } from \"@ixfx/flow\"\nimport { intervalToMs, type Interval } from \"@ixfx/core\"\nimport * as StateMachine from \"@ixfx/flow/state-machine\"\nimport { getErrorMessage } from \"@ixfx/debug\"\n\nexport type ReconnectingWebsocket = {\n  /**\n   * Sends data\n   * @param data \n   * @returns \n   */\n  send: (data: string | ArrayBufferLike | ArrayBufferView | Blob) => void\n  /**\n   * Closes websocket, disabling reconnection\n   * @returns\n   */\n  close: () => void\n\n  /**\n   * Opens websocket if it's not already connected or connecting\n   * @returns \n   */\n  open: () => Promise<boolean>\n\n  /**\n   * Returns _true_ if it seems the websocket is connected\n   * @returns \n   */\n  isConnected: () => boolean\n}\n\nexport type ReconnectingWebsocketStates = `connecting` | `open` | `closed`;\n\nexport type ReconnectingOptions = {\n  startDelay: Interval\n  maxDelay: Interval\n  limitAttempts: number\n  /**\n   * How often to check the state of the\n   * underlying websocket.\n   * \n   * Default: 5s\n   */\n  checkStateMs: Interval\n  /**\n   * Callback when message is received\n   * @param message \n   * @returns \n   */\n  onMessage: (message: any) => void\n  onConnected: () => void\n  onDisconnected: () => void\n  onError: (error: any) => void\n}\n\n/**\n * Maintains a web socket connection. Connects automatically.\n * \n * The essential usage is:\n * ```js\n * import { reconnectingWebsocket } from '@ixfx/io.js'\n * const ws = reconnectingWebsocket(`wss://somehost.com/ws`, {\n *  onMessage: (msg) => {\n *    // Do something with received message...\n *  }\n * }\n * \n * // Send some data\n * ws.send(JSON.stringify(someData));\n * \n * // Check state of connection\n * ws.isConnected(); \n * ```\n * \n * More options can be provided to monitor state\n * ```js\n * import { reconnectingWebsocket } from '@ixfx/io.js'\n * const ws = reconnectingWebsocket(`wss://somehost.com/ws`, {\n *  onError: (err) => {\n *    console.error(err)\n *  },\n *  onMessage: (msg) => {\n *    // Received data\n *    console.log(msg);\n *  },\n *  onConnected: () => {\n *    // Connected!\n *  },\n *  onDisconnected: () => {\n *    // Disconnected :(\n *  }\n * });\n * ```\n * @param url \n * @param opts \n * @returns \n */\nexport const reconnectingWebsocket = (url: string | URL, opts: Partial<ReconnectingOptions> = {}): ReconnectingWebsocket => {\n  const startDelayMs = intervalToMs(opts.startDelay, 2000);\n  const maxDelayMs = intervalToMs(opts.maxDelay, startDelayMs * 10);\n  const checkStateMs = intervalToMs(opts.checkStateMs, 5000)\n  if (startDelayMs > maxDelayMs) throw new Error(`startDelay should be less than maxDelay`);\n  if (checkStateMs < 0) throw new Error(`Param 'checkState' should be above zero`);\n  let reconnect = true;\n  let currentState = StateMachine.init({\n    closed: `connecting`,\n    open: `closed`,\n    connecting: [ `closed`, `open` ]\n  });//`closed`;\n\n  let ws: WebSocket | undefined;\n  const onError = (event_: any) => {\n    if (opts.onError) {\n      opts.onError(event_);\n    } else {\n      console.log(`rw on error`, event_);\n      console.error(` error: ${ event_.error }`);\n      console.error(` type: ${ event_.type }`);\n      console.error(` error msg: ${ event_.message }`);\n    }\n  }\n\n  const onMessage = (message: MessageEvent) => {\n    if (opts.onMessage) opts.onMessage(message.data);\n  }\n\n  const connect = async () => {\n    if (currentState.value === `connecting`) throw new Error(`Cannot connect twice`);\n    currentState = StateMachine.to(currentState, `connecting`);\n    if (ws !== undefined) {\n      ws.removeEventListener(`error`, onError);\n      if (opts.onMessage) {\n        ws.removeEventListener(`message`, onMessage);\n      }\n      ws = undefined;\n    }\n\n    // Keep trying to connect\n    const retry = await retryTask({\n      async probe(_attempts: number) {\n        try {\n          const wss = new WebSocket(url);\n          const r = await eventRace(wss, [ `open`, `error` ], { timeoutMs: 1000 });\n          return r.type === `open` ? { success: true, value: wss } : { success: false, error: `Could not open` };\n        } catch (error) {\n          return { success: false, error: getErrorMessage(error) }\n        }\n      },\n    }, { predelayMs: startDelayMs, limitAttempts: opts.limitAttempts });\n\n    // Final result\n    ws = retry.value;\n    let result = false;\n    if (retry.success && ws) {\n      //      ws.addEventListener(`error`, onError);\n      if (opts.onMessage) {\n        //        ws.addEventListener(`message`, onMessage);\n      }\n      result = true;\n      currentState = StateMachine.to(currentState, `open`);\n      if (opts.onConnected) opts.onConnected();\n    } else {\n      currentState = StateMachine.to(currentState, `closed`);\n    }\n    return result;\n  }\n\n  const send = (data: string | ArrayBufferLike | ArrayBufferView | Blob) => {\n    if (ws) {\n      if (ws.readyState === ws.OPEN) {\n        ws.send(data)\n      } else {\n        onDisconnected();\n      }\n    } else {\n      throw new Error(`Not connected`);\n    }\n  }\n\n  const onDisconnected = () => {\n    if (currentState.value === `closed`) return;\n    if (currentState.value === `open`) {\n      currentState = StateMachine.to(currentState, `closed`);\n      if (opts.onDisconnected) opts.onDisconnected();\n    }\n    if (reconnect && currentState.value !== `connecting`) {\n      console.log(`Scheduling connect`);\n      setTimeout(() => {\n        void connect();\n      }, 100)\n    }\n  }\n  const isConnected = () => {\n    if (!ws) return false;\n    return ws.readyState === ws.OPEN;\n  }\n\n  const close = () => {\n    reconnect = false;\n    currentState = StateMachine.to(currentState, `closed`);\n    ws?.close();\n    if (opts.onDisconnected) opts.onDisconnected();\n  }\n\n  const open = () => {\n    reconnect = true;\n    if (currentState.value === `open`) return Promise.resolve(true);\n    if (currentState.value === `connecting`) return Promise.resolve(false);\n    return connect();\n  }\n\n  void connect();\n\n  setInterval(() => {\n    if (!ws) return;\n    switch (ws.readyState) {\n      case ws.CLOSED: {\n        if (currentState.value === `open`) {\n          onDisconnected();\n        }\n        break;\n      }\n    }\n  }, checkStateMs);\n  return { send, isConnected, close, open }\n}"],"mappings":"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"}