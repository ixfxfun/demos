{"version":3,"file":"key-value-xMXxsVY5.js","names":[],"sources":["../../core/dist/src/key-value.js"],"sourcesContent":["//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\nimport { defaultComparer } from './comparers.js';\nconst sorterByValueIndex = (index, reverse = false) => {\n    return (values) => {\n        const s = values.toSorted((a, b) => {\n            return defaultComparer(a[index], b[index]);\n        });\n        if (reverse)\n            return s.reverse();\n        return s;\n    };\n};\nexport const keyValueSorter = (sortStyle) => {\n    switch (sortStyle) {\n        case `value`: {\n            return sorterByValueIndex(1, false);\n        }\n        case `value-reverse`: {\n            return sorterByValueIndex(1, true);\n        }\n        case `key`: {\n            return sorterByValueIndex(0, false);\n        }\n        case `key-reverse`: {\n            return sorterByValueIndex(0, true);\n        }\n        default: {\n            throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, value-reverse, key or key-reverse`);\n        }\n    }\n};\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };\n"],"mappings":";;;AAEA,MAAM,qBAAqB,CAAC,OAAO,UAAU,UAAU;AACnD,QAAO,CAAC,WAAW;EACf,MAAM,IAAI,OAAO,SAAS,CAAC,GAAG,MAAM;AAChC,UAAO,gBAAgB,EAAE,QAAQ,EAAE,OAAO;EAC7C,EAAC;AACF,MAAI,QACA,QAAO,EAAE,SAAS;AACtB,SAAO;CACV;AACJ;AACD,MAAa,iBAAiB,CAAC,cAAc;AACzC,SAAQ,WAAR;EACI,KAAK,CAAC,KAAK,CAAC,CACR,QAAO,mBAAmB,GAAG,MAAM;EAEvC,KAAK,CAAC,aAAa,CAAC,CAChB,QAAO,mBAAmB,GAAG,KAAK;EAEtC,KAAK,CAAC,GAAG,CAAC,CACN,QAAO,mBAAmB,GAAG,MAAM;EAEvC,KAAK,CAAC,WAAW,CAAC,CACd,QAAO,mBAAmB,GAAG,KAAK;EAEtC,QACI,OAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,UAAU,sDAAsD,CAAC;CAElH;AACJ"}