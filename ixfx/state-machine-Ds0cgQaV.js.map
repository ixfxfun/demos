{"version":3,"file":"state-machine-Ds0cgQaV.js","names":["arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[]","t: V[]","toClone: MachineState<V>","stateMachine: Machine<V> | Transitions | TransitionsStrict","initialState?: StateNames<V>","state: StateNames<V>","smOrTransitions: Machine<V> | Transitions | TransitionsStrict","sm: MachineState<V>","targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    | StateTargetStrict<V>","target: string | undefined | null | object","d: Transitions","state: MachineState<V>","toState: StateNames<V>"],"sources":["../../packages/core/src/elapsed.ts","../../packages/arrays/src/unique.ts","../../packages/flow/src/state-machine/state-machine.ts"],"sourcesContent":["//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since the initial call.\n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns the interval between the start and each subsequent call.\n * \n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n * \n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns \n */\nexport const elapsedInterval = (): Since => {\n  let start = performance.now();\n  return (): number => {\n    const now = performance.now();\n    const x = now - start;\n    start = now;\n    return x;\n  }\n}\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n * \n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = (): Since => {\n  const start = Date.now();\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses Javascript's default equality checking\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  comparer = isEqualDefault<V>\n): V[] => {\n  const t: V[] = [];\n  const contains = (v: V) => {\n    for (const tValue of t) {\n      if (comparer(tValue, v)) return true;\n    }\n    return false;\n  }\n\n  const flattened = arrays.flat(10) as V[];\n\n  for (const v of flattened) {\n    if (!contains(v)) t.push(v);\n  }\n  return t;\n};\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n * \n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  toString = toStringDefault\n): V[] => {\n  const matching = new Set<string>();\n  const t: V[] = [];\n  const flattened = arrays.flat(10) as V[];\n  for (const a of flattened) {\n    const stringRepresentation = toString(a);\n    if (matching.has(stringRepresentation)) continue;\n    matching.add(stringRepresentation);\n    t.push(a);\n  }\n  return t;\n}","import { unique } from '@ixfx/arrays';\nimport type { Machine, MachineState, StateNames, StateTarget, StateTargetStrict, TransitionCondition, Transitions, TransitionsStrict } from './types.js';\n\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = <V extends Transitions>(\n  toClone: MachineState<V>\n): MachineState<V> => {\n  return Object.freeze({\n    value: toClone.value,\n    visited: [ ...toClone.visited ],\n    machine: toClone.machine,\n  });\n};\n/**\n * Initialises a state machine\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * StateMachineLight.isDdone(sm); // false\n * StateMachineLight.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = <V extends Transitions>(\n  stateMachine: Machine<V> | Transitions | TransitionsStrict,\n  initialState?: StateNames<V>\n): MachineState<V> => {\n  const [ machine, machineValidationError ] = validateMachine(stateMachine);\n  if (!machine) throw new Error(machineValidationError);\n\n  const state: StateNames<V> =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState!) ?? Object.keys(machine.states)[ 0 ];\n  if (typeof machine.states[ state ] === `undefined`) {\n    throw new TypeError(`Initial state ('${ state }') not found`);\n  }\n\n  // Normalise states\n  const transitions = validateAndNormaliseTransitions(machine.states);\n  if (transitions === undefined) {\n    throw new Error(`Could not normalise transitions`);\n  }\n  return Object.freeze({\n    value: state,\n    visited: [],\n    machine: Object.freeze(Object.fromEntries(transitions)) as any as Readonly<Record<StateNames<V>, readonly StateTargetStrict<V>[]>>,\n  });\n};\n\nexport const reset = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  return init<V>(sm.machine as any);\n};\n\nexport const validateMachine = <V extends Transitions>(\n  smOrTransitions: Machine<V> | Transitions | TransitionsStrict\n): [ machine: Machine<V> | undefined, msg: string ] => {\n  if (typeof smOrTransitions === `undefined`) {\n    return [ undefined, `Parameter undefined` ];\n  }\n  if ((smOrTransitions as unknown) === null) {\n    return [ undefined, `Parameter null` ];\n  }\n  if (`states` in smOrTransitions) {\n    // Assume Machine type\n    return [ smOrTransitions as Machine<V>, `` ];\n  }\n  if (typeof smOrTransitions === `object`) {\n    return [\n      {\n        states: smOrTransitions as V,\n      },\n      ``,\n    ];\n  }\n  return [\n    undefined,\n    `Unexpected type: ${ typeof smOrTransitions }. Expected object`,\n  ];\n};\n\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = <V extends Transitions>(sm: MachineState<V>): boolean => {\n  return possible(sm).length === 0;\n};\n\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = <V extends Transitions>(\n  sm: MachineState<V>\n): readonly StateTargetStrict<V>[] => {\n  // Validate current state\n  validateMachineState(sm);\n  // get list of possible targets\n  const fromS = sm.machine[ sm.value ];\n\n  if (fromS.length === 1 && fromS[ 0 ].state === null) return [];\n  return fromS;\n};\n\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = <V extends Transitions>(\n  sm: MachineState<V>\n): (StateNames<V> | null)[] => {\n  const targets = possibleTargets(sm);\n  return targets.map((v) => v.state);\n};\n\nexport const normaliseTargets = <V extends Transitions>(\n  targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    | StateTargetStrict<V>\n): StateTargetStrict<V>[] | null | undefined => {\n  const normaliseSingleTarget = (\n    target: string | undefined | null | object\n  ): StateTargetStrict<V> | undefined => {\n    // Terminal target\n    if (target === null) return { state: null };\n    // String is the target state\n    if (typeof target === `string`) {\n      return {\n        state: target,\n      };\n    } else if (typeof target === `object` && `state` in target) {\n      const targetState = target.state;\n      if (typeof targetState !== `string`) {\n        throw new TypeError(\n          `Target 'state' field is not a string. Got: ${ typeof targetState }`\n        );\n      }\n      if (`preconditions` in target) {\n        return {\n          state: targetState,\n          preconditions: target.preconditions as TransitionCondition<V>[],\n        };\n      }\n      return { state: targetState };\n    } else {\n      throw new Error(\n        `Unexpected type: ${ typeof target }. Expected string or object with 'state' field.`\n      );\n    }\n  };\n\n  // Array of targets (either strings or objects)\n  if (Array.isArray(targets)) {\n    let containsNull = false;\n    const mapResults = targets.map((t) => {\n      const r = normaliseSingleTarget(t);\n      if (!r) throw new Error(`Invalid target`);\n      containsNull = containsNull || r.state === null;\n      return r;\n    });\n    if (containsNull && mapResults.length > 1) {\n      throw new Error(`Cannot have null as an possible state`);\n    }\n    return mapResults;\n  } else {\n    const target = normaliseSingleTarget(targets);\n    if (!target) return;\n    return [ target ];\n  }\n};\n\nconst validateAndNormaliseTransitions = (\n  d: Transitions\n): Map<string, StateTargetStrict<typeof d>[]> | undefined => {\n  const returnMap = new Map<string, StateTargetStrict<typeof d>[]>();\n\n  // 1. Index top-level states\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    if (typeof topLevelState === `undefined`) {\n      throw new TypeError(`Top-level undefined state`);\n    }\n    if (typeof topLevelTargets === `undefined`) {\n      throw new TypeError(`Undefined target state for ${ topLevelState }`);\n    }\n    if (returnMap.has(topLevelState)) {\n      throw new Error(`State defined twice: ${ topLevelState }`);\n    }\n    if (topLevelState.includes(` `)) {\n      throw new Error(`State names cannot contain spaces`);\n    }\n    returnMap.set(topLevelState, []);\n  }\n\n  // 2. Normalise target\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    const targets = normaliseTargets(topLevelTargets);\n    if (targets === undefined) throw new Error(`Could not normalise target`);\n    if (targets !== null) {\n      // Check that they all exist as top-level states\n      const seenStates = new Set();\n      for (const target of targets) {\n        if (seenStates.has(target.state)) {\n          throw new Error(\n\n            `Target state '${ target.state }' already exists for '${ topLevelState }'`\n          );\n        }\n        seenStates.add(target.state);\n        if (target.state === null) continue;\n        if (!returnMap.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' is not defined as a top-level state. Defined under: '${ topLevelState }'`\n          );\n        }\n      }\n      returnMap.set(topLevelState, targets);\n    }\n  }\n  return returnMap;\n};\n\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = <V extends Transitions>(\n  state: MachineState<V>\n): void => {\n  if (typeof state === `undefined`) {\n    throw new TypeError(`Param 'state' is undefined`);\n  }\n  if (typeof state.value !== `string`) {\n    throw new TypeError(`Existing state is not a string`);\n  }\n};\n\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): MachineState<V> => {\n  validateMachineState(sm); // throws if not OK\n  validateTransition(sm, toState); // throws if not OK\n  return Object.freeze({\n    value: toState,\n    machine: sm.machine,\n    visited: unique<string>([ sm.visited as string[], [ sm.value ] as string[] ]),\n  });\n};\n\nexport const next = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  //validateMachineState(sm);\n  const first = possibleTargets(sm).at(0);\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (!first || first.state === null) {\n    throw new Error(\n      `Not possible to move to a next state from '${ sm.value }`\n    );\n  }\n  return to(sm, first.state);\n};\n\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): boolean => {\n  try {\n    validateTransition(sm, toState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const validateTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): void => {\n  if ((toState as unknown) === null) throw new Error(`Cannot transition to null state`);\n  if (typeof toState === `undefined`) {\n    throw new Error(`Cannot transition to undefined state`);\n  }\n  if (typeof toState !== `string`) {\n    throw new TypeError(\n      `Parameter 'toState' should be a string. Got: ${ typeof toState }`\n    );\n  }\n\n  //const toS = sm.machine[toState];\n  //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n\n  const p = possible(sm);\n  if (p.length === 0) throw new Error(`Machine is in terminal state`);\n  if (!p.includes(toState)) {\n    throw new Error(\n      `Target state '${ toState }' not available at current state '${ sm.value\n      }'. Possible states: ${ p.join(`, `) }`\n    );\n  }\n};\n\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n * \n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states: readonly string[]): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length <= 2) throw new Error(`Expects at least two states`);\n  for (let index = 0; index < states.length; index++) {\n    const s = states[ index ] as string;\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index.toString() }`\n      );\n    }\n    t[ s ] = (index === states.length - 1) ? null : states[ index + 1 ] as string;\n  }\n  return t;\n};\n\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n * \n * See also {@link fromList}.\n * \n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (\n  ...states: readonly string[]\n): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length < 2) throw new Error(`Expects at least two states`);\n\n  for (const [ index, s ] of states.entries()) {\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index.toString() }`\n      );\n    }\n    t[ s ] = [];\n  }\n\n  for (let index = 0; index < states.length; index++) {\n    const v = t[ states[ index ] as string ] as string[];\n    if (index === states.length - 1) {\n      if (states.length > 1) {\n        v.push(states[ index - 1 ] as string);\n      } else {\n        t[ states[ index ] as string ] = null;\n      }\n    } else {\n      v.push(states[ index + 1 ] as string);\n      if (index > 0) v.push(states[ index - 1 ] as string);\n    }\n  }\n  return t;\n};\n\n"],"mappings":"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"}