const e=(e,t)=>{if(!Array.isArray(e))throw TypeError(`Param 'data' is expected to be an array. Got type: ${typeof e}`);let n=t??(e=>e);return e.map((t,r)=>{if(typeof t!=`number`)throw TypeError(`Param 'data' contains non-number at index: '${r}'. Type: '${typeof t}' value: '${t}'`);let i=r/(e.length-1),a=n(i);if(typeof a!=`number`)throw TypeError(`Weighting function returned type '${typeof a}' rather than number for input: '${i}'`);return t*a})},t=e=>e.filter(e=>typeof e==`number`&&!Number.isNaN(e)),n=(e,t=`ignore`)=>{let n=0,r=e[0].length;for(let i=0;i<r;i++){let r=0;for(let[n,a]of e.entries()){let e=a[i];if(Number.isNaN(e)||!Number.isFinite(e)){if(t===`treat-as-zero`)e=0;else if(t===`error`)throw TypeError(`Invalid number at index ${i},${n}`)}n===0?r=e:r*=e}n+=r}return n},r=e=>{if(typeof e!=`object`)throw Error(`Param 'data' should be an array. Got: ${typeof e}`);if(!Array.isArray(e))throw TypeError(`Param 'data' is not an array`);let n=t(e);return n.reduce((e,t)=>e+t,0)/n.length},i=e=>Math.min(...t(e)),a=e=>e.reduce((e,t,n,r)=>t>r[e]?n:e,0),o=e=>e.reduce((e,t,n,r)=>t<r[e]?n:e,0),s=e=>Math.max(...t(e)),c=e=>e.reduce((e,t)=>typeof t!=`number`||Number.isNaN(t)||!Number.isFinite(t)?e:e+t,0),l=e=>{let t=-(2**53-1);for(let n of e)t=Math.max(t,n);return t},u=e=>{let t=0;for(let n of e)t+=n;return t},d=e=>{let t=2**53-1;for(let n of e)t=Math.min(t,n);return t};export{a,o as c,t as d,e as f,l as i,c as l,n,i as o,s as r,d as s,r as t,u};