{"version":3,"sources":["../src/trackers/index.ts","../src/trackers/FrequencyMutable.ts","../src/trackers/IntervalTracker.ts","../src/trackers/RateTracker.ts"],"sourcesContent":["export * from './FrequencyMutable.js';\nexport * from './IntervalTracker.js';\nexport * from './NumberTracker.js';\nexport * from './ObjectTracker.js';\nexport * from './PointTracker.js';\nexport * from './PrimitiveTracker.js';\nexport * from './RateTracker.js';\nexport * from './TrackedValue.js';\nexport * from './TrackerBase.js';\nexport * from './TrackUnique.js';\nexport type * from './Types.js';","/// âœ” Unit tested!\n\nimport { type ToString } from '../util/index.js';\nimport { SimpleEventEmitter } from '../Events.js';\nimport * as KeyValues from '../util/KeyValue.js';\nimport type { KeyValue } from '../PrimitiveTypes.js';\n\nexport type FrequencyEventMap = {\n  readonly change: { context: any };\n};\n\nexport class FrequencyTracker<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString?: ToString<V> | undefined) {\n    super();\n    this.#store = new Map();\n\n    if (keyString === undefined) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        return typeof a === `string` ? a : JSON.stringify(a);\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, { context: this });\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): Array<[ key: string, count: number ]> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    //eslint-disable-next-line functional/no-let\n    let t = ``;\n    for (const [ key, count ] of this.#store.entries()) {\n      t += `${ key }: ${ count }, `;\n    }\n    if (t.endsWith(`, `)) return t.slice(0, Math.max(0, t.length - 2));\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    //eslint-disable-next-line functional/no-let\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.minMaxAvg();\n    return freq / mma.total;\n  }\n\n  /**\n   * @returns Copy of entries as an array\n   */\n  entries(): Array<KeyValue> {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   *\n   * @returns Returns `{min,max,avg,total}`\n   */\n  minMaxAvg() {\n    return KeyValues.minMaxAvg(this.entries());\n  }\n\n  /**\n   *\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: KeyValues.SortSyles = `value`\n  ): ReadonlyArray<KeyValue> {\n    const s = KeyValues.getSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   *\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  add(...values: Array<V>) {\n    if (values === undefined) throw new Error(`value parameter is undefined`);\n\n    const keys = values.map(v => this.#keyString(v));\n\n    //const key = this.#keyString(value);\n    for (const key of keys) {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    }\n    this.fireEvent(`change`, { context: this });\n  }\n}\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link Trackers.frequency}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = Trackers.frequency();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = Trackers.frequency();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = Trackers.frequency( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @typeParam V - Type of items\n */\nexport const frequency = <V>(keyString?: ToString<V> | undefined) =>\n  new FrequencyTracker<V>(keyString);\n","import { NumberTracker } from './NumberTracker.js';\nimport { type TrackedValueOpts as TrackOpts } from './TrackedValue.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(performance.now() - this.lastMark);\n    }\n    this.lastMark = performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = interval();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = interval({ resetAfterSamples: 100} );\n * ```\n * @param options Options for tracker\n * @returns New interval tracker\n */\nexport const interval = (options?: TrackOpts) => new IntervalTracker(options);\n","import { timeout, type Timeout } from \"../flow/Timeout.js\";\nimport type { Interval } from \"../flow/IntervalType.js\";\n\nexport type RateTrackerOpts = Readonly<{\n  /**\n * If above zero, tracker will reset after this many samples\n */\n  resetAfterSamples?: number;\n\n  /**\n   * If set, tracker will reset after this much time\n   * since last `mark()` call.\n   */\n  timeoutInterval?: Interval\n  /**\n   * If above zero, there will be a limit to intermediate values kept.\n   *\n   * When the seen values is twice `sampleLimit`, the stored values will be trimmed down\n   * to `sampleLimit`. We only do this when the values are double the size so that\n   * the collections do not need to be trimmed repeatedly whilst we are at the limit.\n   *\n   * Automatically implies storeIntermediate\n   */\n  sampleLimit?: number;\n}>\n\n/**\n * Tracks the rate of events.\n * It's also able to compute the min,max and average interval between events.\n * \n * @example\n * ```js\n * const clicks = Trackers.rate();\n * \n * // Mark when a click happens\n * document.addEventListener(`click`, () => clicks.mark());\n * \n * // Get details\n * clicks.perSecond; // How many clicks per second\n * clicks.perMinute; // How many clicks per minute\n * ```\n * \n * `timeoutInterval` is a useful option to make the tracker reset\n * after some period without `mark()` being called.\n * \n * Another useful option is `sampleLimit`, which sets an upper bound\n * for how many events to track. A smaller value means the results\n * will more accurately track, but it might be less smooth.\n * \n * ```js\n * // Eg reset tracker after 5 seconds of inactivity\n * const clicks = Trackers.rate({ \n *  sampleLimit: 10,\n *  timeoutInterval: { secs: 5 }\n * });\n * ```\n */\nexport class RateTracker {\n  #events: number[] = []\n  #fromTime;\n  #resetAfterSamples;\n  #sampleLimit;\n  #resetTimer: Timeout | undefined;\n\n  constructor(opts: Partial<RateTrackerOpts> = {}) {\n    this.#resetAfterSamples = opts.resetAfterSamples ?? Number.MAX_SAFE_INTEGER;\n    this.#sampleLimit = opts.sampleLimit ?? Number.MAX_SAFE_INTEGER;\n    if (opts.timeoutInterval) {\n      this.#resetTimer = timeout(() => {\n        this.reset();\n      }, opts.timeoutInterval);\n    }\n    this.#fromTime = performance.now();\n  }\n\n  /**\n   * Mark that an event has happened\n   */\n  mark() {\n    if (this.#events.length >= this.#resetAfterSamples) {\n      this.reset();\n    } else if (this.#events.length >= this.#sampleLimit) {\n      this.#events = this.#events.slice(1);\n      this.#fromTime = this.#events[ 0 ];\n    }\n    this.#events.push(performance.now());\n    if (this.#resetTimer) {\n      this.#resetTimer.start();\n    }\n  }\n\n  /**\n   * Compute {min,max,avg} for the interval _between_ events.\n   * @returns \n   */\n  computeIntervals() {\n    let intervals = [];\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let total = 0;\n    let count = 0;\n    let start = 0;\n    for (let e of this.#events) {\n      if (count > 0) {\n        const i = e - start;\n        min = Math.min(i, min);\n        max = Math.max(i, max);\n        total += i;\n        intervals.push(i);\n      }\n      start = e;\n      count++;\n    }\n    let avg = total / count;\n    return {\n      min, max, avg\n    }\n  }\n\n  /**\n   * Returns the time period (in milliseconds) that encompasses\n   * the data set. Eg, a result of 1000 means there's data that\n   * covers a one second period.\n   */\n  get elapsed() {\n    return performance.now() - this.#fromTime;\n  }\n\n  /**\n   * Resets the tracker.\n   */\n  reset() {\n    this.#events = [];\n    this.#fromTime = performance.now();\n  }\n\n  /**\n   * Get the number of events per second\n   */\n  get perSecond() {\n    return this.#events.length / (this.elapsed / 1000)\n  }\n\n  /**\n   * Get the number of events per minute\n   */\n  get perMinute() {\n    return this.#events.length / (this.elapsed / 1000 / 60)\n  }\n}\n\n/**\n * @inheritdoc RateTracker\n * @param opts \n * @returns \n */\nexport const rate = (opts: Partial<RateTrackerOpts> = {}) => new RateTracker(opts);\n"],"mappings":"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","names":[]}