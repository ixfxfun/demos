{"version":3,"file":"scale-D4tnfavu.js","names":["v: number","inMin: number","inMax: number","outMin?: number","outMax?: number","easing?: (v: number) => number","clamped?: boolean"],"sources":["../../../ixfx/packages/numbers/src/scale.ts"],"sourcesContent":["import { clamp, clamper } from './clamp.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport type { NumberScaler, NumberScalerTwoWay } from './types.js';\n\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => scaler(inMin, inMax, outMin, outMax, easing)(v);\n\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number,\n  clamped?: boolean\n): NumberScaler => {\n\n  resultThrow(\n    numberTest(inMin, `finite`, `inMin`),\n    numberTest(inMax, `finite`, `inMax`)\n  );\n  const oMax = outMax ?? 1;\n  const oMin = outMin ?? 0;\n  const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n\n  return (v: number): number => {\n    if (inMin === inMax) return oMax;\n\n    let a = (v - inMin) / (inMax - inMin);\n    if (easing !== undefined) a = easing(a);\n    const x = a * (oMax - oMin) + oMin;\n    if (clampFunction) return clampFunction(x);\n    return x;\n  };\n};\n\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns \n */\nexport const scalerNull = (): NumberScaler => (v: number) => v;\n\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => {\n  if (typeof outMax === `undefined`) outMax = 1;\n  if (typeof outMin === `undefined`) outMin = 0;\n  if (inMin === inMax) return outMax;\n\n  const x = scale(v, inMin, inMax, outMin, outMax, easing);\n  return clamp(x, outMin, outMax);\n};\n\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * import { scalePercentages } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (\n  percentage: number,\n  outMin: number,\n  outMax = 1\n): number => {\n  resultThrow(\n    numberTest(percentage, `percentage`, `v`),\n    numberTest(outMin, `percentage`, `outMin`),\n    numberTest(outMax, `percentage`, `outMax`)\n  );\n  return scale(percentage, 0, 1, outMin, outMax);\n};\n\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * import { scalePercent } from 'https://unpkg.com/ixfx/dist/data.js';\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (\n  v: number,\n  outMin: number,\n  outMax: number\n): number => scalerPercent(outMin, outMax)(v);\n\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin: number, outMax: number) => {\n  return (v: number) => {\n    resultThrow(numberTest(v, `percentage`, `v`));\n    return scale(v, 0, 1, outMin, outMax);\n  };\n};\n\n\n\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n * \n * // Scale from input to output\n * s.out(50); // 0.5\n * \n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin \n * @param inMax \n * @param outMin \n * @param outMax \n * @returns \n */\nexport const scalerTwoWay = (inMin: number, inMax: number, outMin = 0, outMax = 1, clamped = false, easing?: (v: number) => number): NumberScalerTwoWay => {\n  const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n  const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n  return { out: toOut, in: toIn };\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA,MAAa,QAAQ,CACnBA,GACAC,OACAC,OACAC,QACAC,QACAC,WACW,OAAO,OAAO,OAAO,QAAQ,QAAQ,OAAO,CAAC,EAAE;;;;;;;;;;;AAY5D,MAAa,SAAS,CACpBJ,OACAC,OACAC,QACAC,QACAC,QACAC,YACiB;AAEjB,aACE,WAAW,QAAQ,UAAU,OAAO,EACpC,WAAW,QAAQ,UAAU,OAAO,CACrC;CACD,MAAM,OAAO,UAAU;CACvB,MAAM,OAAO,UAAU;CACvB,MAAM,gBAAgB,UAAU,QAAQ,QAAQ,OAAO;AAEvD,QAAO,CAACN,MAAsB;AAC5B,MAAI,UAAU,MAAO,QAAO;EAE5B,IAAI,KAAK,IAAI,UAAU,QAAQ;AAC/B,MAAI,kBAAsB,KAAI,OAAO,EAAE;EACvC,MAAM,IAAI,KAAK,OAAO,QAAQ;AAC9B,MAAI,cAAe,QAAO,cAAc,EAAE;AAC1C,SAAO;CACR;AACF"}