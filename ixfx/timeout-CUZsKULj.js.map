{"version":3,"file":"timeout-CUZsKULj.js","names":[],"sources":["../../flow/dist/src/timeout.js"],"sourcesContent":["import { integerTest, resultToError, resultIsError, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n *\n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (callback, interval) => {\n    if (callback === undefined) {\n        throw new Error(`callback parameter is undefined`);\n    }\n    const intervalMs = intervalToMs(interval);\n    resultThrow(integerTest(intervalMs, `aboveZero`, `interval`));\n    let timer;\n    let startedAt = 0;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let state = `idle`;\n    const clear = () => {\n        startedAt = 0;\n        globalThis.clearTimeout(timer);\n        state = `idle`;\n    };\n    const start = async (altInterval = interval, args) => {\n        const p = new Promise((resolve, reject) => {\n            startedAt = performance.now();\n            const altTimeoutMs = intervalToMs(altInterval);\n            const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n            if (resultIsError(it)) {\n                reject(resultToError(it));\n                return;\n            }\n            switch (state) {\n                case `scheduled`: {\n                    // Cancel other scheduled execution\n                    cancel();\n                    break;\n                }\n                case `running`: {\n                    //console.warn(`Timeout being rescheduled while task is already running`);\n                    break;\n                }\n            }\n            state = `scheduled`;\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            timer = globalThis.setTimeout(async () => {\n                if (state !== `scheduled`) {\n                    console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n                    clear();\n                    return;\n                }\n                const args_ = args ?? [];\n                startCount++;\n                startCountTotal++;\n                state = `running`;\n                await callback(performance.now() - startedAt, ...args_);\n                state = `idle`;\n                clear();\n                resolve();\n            }, altTimeoutMs);\n        });\n        return p;\n    };\n    const cancel = () => {\n        if (state === `idle`)\n            return;\n        clear();\n    };\n    return {\n        start,\n        cancel,\n        get runState() {\n            return state;\n        },\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        }\n    };\n};\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,MAAa,UAAU,CAAC,UAAU,aAAa;AAC3C,KAAI,aAAa,OACb,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;CAErD,MAAM,aAAa,aAAa,SAAS;CACzC,YAAY,YAAY,YAAY,CAAC,SAAS,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;CAC7D,IAAI;CACJ,IAAI,YAAY;CAChB,IAAI,aAAa;CACjB,IAAI,kBAAkB;CACtB,IAAI,QAAQ,CAAC,IAAI,CAAC;CAClB,MAAM,QAAQ,MAAM;EAChB,YAAY;EACZ,WAAW,aAAa,MAAM;EAC9B,QAAQ,CAAC,IAAI,CAAC;CACjB;CACD,MAAM,QAAQ,OAAO,cAAc,UAAU,SAAS;EAClD,MAAM,IAAI,IAAI,QAAQ,CAAC,SAAS,WAAW;GACvC,YAAY,YAAY,KAAK;GAC7B,MAAM,eAAe,aAAa,YAAY;GAC9C,MAAM,KAAK,YAAY,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC;AACjE,OAAI,cAAc,GAAG,EAAE;IACnB,OAAO,cAAc,GAAG,CAAC;AACzB;GACH;AACD,WAAQ,OAAR;IACI,KAAK,CAAC,SAAS,CAAC,EAAE;KAEd,QAAQ;AACR;IACH;IACD,KAAK,CAAC,OAAO,CAAC,CAEV;GAEP;GACD,QAAQ,CAAC,SAAS,CAAC;GAEnB,QAAQ,WAAW,WAAW,YAAY;AACtC,QAAI,UAAU,CAAC,SAAS,CAAC,EAAE;KACvB,QAAQ,KAAK,CAAC,yDAAyD,CAAC,CAAC;KACzE,OAAO;AACP;IACH;IACD,MAAM,QAAQ,QAAQ,CAAE;IACxB;IACA;IACA,QAAQ,CAAC,OAAO,CAAC;IACjB,MAAM,SAAS,YAAY,KAAK,GAAG,WAAW,GAAG,MAAM;IACvD,QAAQ,CAAC,IAAI,CAAC;IACd,OAAO;IACP,SAAS;GACZ,GAAE,aAAa;EACnB;AACD,SAAO;CACV;CACD,MAAM,SAAS,MAAM;AACjB,MAAI,UAAU,CAAC,IAAI,CAAC,CAChB;EACJ,OAAO;CACV;AACD,QAAO;EACH;EACA;EACA,IAAI,WAAW;AACX,UAAO;EACV;EACD,IAAI,aAAa;AACb,UAAO;EACV;EACD,IAAI,kBAAkB;AAClB,UAAO;EACV;CACJ;AACJ"}