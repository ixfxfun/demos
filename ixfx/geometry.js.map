{"version":3,"file":"geometry.js","names":["a: V","data: readonly V[] | V[]","propertyName: K","dotProduct","values: readonly (readonly number[])[]","length","values","t","data: readonly number[] | Float32Array","round","a: number","b?: number | boolean","roundUp?: boolean","v: number","wrap","v: number","min","max","start: number","end: number","steps: number","precision?: number","v: number","v?: number","v: number","inMin: number","inMax: number","outMin?: number","outMax?: number","easing?: (v: number) => number","scaler","clamped?: boolean","quantiseEvery","v: number","every: number","array: ArrayLike<V>","rand: RandomSource","keyString?: ToString<V>","keyString: ToString<V> | undefined","values","v: V","pi","t","sum","point","bbox","intersections","min","max","reduce","a","b","c","d","v1","q","bbox","offset","pi","point","t","d","ls","le","segments","tlen","alen","intersections","isNaN","guard","isEmpty","isPlaceholder","fromPoints","guard","getPointParameter","length","sum","interpolate","distance","fromA","distance","guard","guardPositioned","isEmpty","isPlaceholder","isPositioned","normaliseByRect","b","a","distance","nearest","point","line","length","t","point","min","bbox","bbox","divide","divide","point","fromNumbers","fromFlatArray","guard","piPi","point","piPi","rotate","invert","subtract","Empty","toCartesian","EmptyPoint","point","distance","toString","normalise","clampMagnitude","max","min","dotProduct","multiply","divide","Placeholder","angleRadian","piPi","toCartesian","toString","length","angleRadian","isEqual","isEqual","apply","point","centroid","sum","clamp","min","max","guard","isPositioned","distanceCenter","distanceFromExterior","isEqual","sum","centroid","isIntersecting","center","toArray","dotProduct","fromNumbers","interpolate","multiply","multiplyScalar","clampMagnitude","max","min","length","length","normalise","Empty","point","pipeline","toString","piPi","pi","point","PointEmpty","toString","max","min","sum","subtract","multiply","divide","asPoints","LinesEmpty","PointsPlaceholder","distance","random","rotate","withinRange","wrap","multiply","point","relativePosition","rotate","subtract","point","sum","point","toString","Empty","Placeholder","isEmpty","isPlaceholder","height","point","distance","toSvgString","toPath","point","distance","fromPoints","nearest","distance","Empty","Placeholder","length","angleRadian","corners","height","from","angleRadian","arrow","piPi","randomPoint","offset","random","randomPoint","center","guard","t","isEqual","t","isIntersecting","PointEmpty","area","fromCenter","height","bbox","piPi","point","angleRadian","length","piPi","interpolate","t","multiplyScalar","toSvg","toSvgFull","toPath","point","t","area","height","height","edges","height","isEqual","lengths","perimeter","interpolate","t","point","lengths","length","bbox","corners","wrap","access","wrap","accessWithGrid","setMutate","setMutateWithGrid","set","setWithGrid","wrapMutable","columns","rows","t","create","wrap","wrap","cells","cardinal","cells","wrap","isEqual","neighbours","t","BezierLibrary","toPath","cubic","t","quadratic","fromDegrees","epsilon","slope","t","Direction","#parent","#children","#items","#subdivide","PlaceholderRect","normalise","abs","angleRadian","piPi","bbox","max","offset","t","t","area","t","lengths","t","t","t","angles","piPi","t","t","t","perimeter","t","t","t","t","fromCenter","height","perimeter","area","circumcircle","incircle","fromA","t","fromB","fromC","height","perimeter","area","medians","circumcircle","incircle","angleRadian","t"],"sources":["../../packages/core/src/default-keyer.ts","../../packages/arrays/src/sort.ts","../../packages/numbers/src/numeric-arrays.ts","../../packages/numbers/src/round.ts","../../packages/numbers/src/wrap.ts","../../packages/numbers/src/linear-space.ts","../../packages/numbers/src/moving-average.ts","../../packages/numbers/src/scale.ts","../../packages/numbers/src/quantise.ts","../../packages/random/src/arrays.ts","../../packages/collections/src/set/set-mutable.ts","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js","../../packages/geometry/dist/src/point/guard.js","../../packages/geometry/dist/src/line/from-points.js","../../packages/geometry/dist/src/line/join-points-to-lines.js","../../packages/geometry/dist/src/line/guard.js","../../packages/geometry/dist/src/line/get-points-parameter.js","../../packages/geometry/dist/src/line/length.js","../../packages/geometry/dist/src/line/reverse.js","../../packages/geometry/dist/src/line/interpolate.js","../../packages/geometry/dist/src/line/angles.js","../../packages/geometry/dist/src/line/midpoint.js","../../packages/geometry/dist/src/rect/guard.js","../../packages/geometry/dist/src/point/normalise-by-rect.js","../../packages/geometry/dist/src/point/get-point-parameter.js","../../packages/geometry/dist/src/point/distance.js","../../packages/geometry/dist/src/line/nearest.js","../../packages/geometry/dist/src/line/distance-single-line.js","../../packages/geometry/dist/src/point/find-minimum.js","../../packages/geometry/dist/src/rect/max.js","../../packages/geometry/dist/src/point/bbox.js","../../packages/geometry/dist/src/line/bbox.js","../../packages/geometry/dist/src/point/divider.js","../../packages/geometry/dist/src/line/divide.js","../../packages/geometry/dist/src/line/from-numbers.js","../../packages/geometry/dist/src/line/from-flat-array.js","../../packages/geometry/dist/src/polar/guard.js","../../packages/geometry/dist/src/pi.js","../../packages/geometry/dist/src/angles.js","../../packages/geometry/dist/src/polar/angles.js","../../packages/geometry/dist/src/point/subtract.js","../../packages/geometry/dist/src/point/empty.js","../../packages/geometry/dist/src/polar/conversions.js","../../packages/geometry/dist/src/polar/math.js","../../packages/geometry/dist/src/point/point-type.js","../../packages/geometry/dist/src/point/angle.js","../../packages/geometry/dist/src/polar/ray.js","../../packages/geometry/dist/src/polar/spiral.js","../../packages/geometry/dist/src/polar/index.js","../../packages/geometry/dist/src/line/from-pivot.js","../../packages/geometry/dist/src/line/from-points-to-path.js","../../packages/geometry/dist/src/point/is-equal.js","../../packages/geometry/dist/src/line/is-equal.js","../../packages/geometry/dist/src/point/abs.js","../../packages/geometry/dist/src/point/apply.js","../../packages/geometry/dist/src/point/averager.js","../../packages/geometry/dist/src/point/centroid.js","../../packages/geometry/dist/src/point/clamp.js","../../packages/geometry/dist/src/point/compare.js","../../packages/geometry/dist/src/point/convex-hull.js","../../packages/geometry/dist/src/circle/guard.js","../../packages/geometry/dist/src/circle/distance-center.js","../../packages/geometry/dist/src/circle/distance-from-exterior.js","../../packages/geometry/dist/src/circle/is-equal.js","../../packages/geometry/dist/src/point/sum.js","../../packages/geometry/dist/src/circle/intersections.js","../../packages/geometry/dist/src/intersects.js","../../packages/geometry/dist/src/rect/Intersects.js","../../packages/geometry/dist/src/rect/center.js","../../packages/geometry/dist/src/rect/distance.js","../../packages/geometry/dist/src/point/distance-to-center.js","../../packages/geometry/dist/src/point/distance-to-exterior.js","../../packages/geometry/dist/src/point/to-array.js","../../packages/geometry/dist/src/point/dot-product.js","../../packages/geometry/dist/src/point/from.js","../../packages/geometry/dist/src/point/interpolate.js","../../packages/geometry/dist/src/point/invert.js","../../packages/geometry/dist/src/point/multiply.js","../../packages/geometry/dist/src/point/magnitude.js","../../packages/geometry/dist/src/point/most.js","../../packages/geometry/dist/src/point/normalise.js","../../packages/geometry/dist/src/point/pipeline.js","../../packages/geometry/dist/src/point/To.js","../../packages/geometry/dist/src/vector.js","../../packages/geometry/dist/src/point/relation.js","../../packages/geometry/dist/src/point/point-tracker.js","../../packages/geometry/dist/src/point/progress-between.js","../../packages/geometry/dist/src/point/project.js","../../packages/geometry/dist/src/point/quantise.js","../../packages/geometry/dist/src/point/random.js","../../packages/geometry/dist/src/point/reduce.js","../../packages/geometry/dist/src/point/rotate.js","../../packages/geometry/dist/src/point/rotate-point-array.js","../../packages/geometry/dist/src/point/round.js","../../packages/geometry/dist/src/point/within-range.js","../../packages/geometry/dist/src/point/wrap.js","../../packages/geometry/dist/src/point/index.js","../../packages/geometry/dist/src/line/multiply.js","../../packages/geometry/dist/src/line/relative-position.js","../../packages/geometry/dist/src/line/rotate.js","../../packages/geometry/dist/src/line/subtract.js","../../packages/geometry/dist/src/line/sum.js","../../packages/geometry/dist/src/line/to-string.js","../../packages/geometry/dist/src/line/index.js","../../packages/geometry/dist/src/line/to-path.js","../../packages/geometry/dist/src/waypoint.js","../../packages/geometry/dist/src/triangle/create.js","../../packages/geometry/dist/src/rect/corners.js","../../packages/geometry/dist/src/rect/from-top-left.js","../../packages/geometry/dist/src/shape/arrow.js","../../packages/geometry/dist/src/circle/random.js","../../packages/geometry/dist/src/rect/random.js","../../packages/geometry/dist/src/circle/center.js","../../packages/geometry/dist/src/triangle/guard.js","../../packages/geometry/dist/src/triangle/centroid.js","../../packages/geometry/dist/src/shape/etc.js","../../packages/geometry/dist/src/circle/is-contained-by.js","../../packages/geometry/dist/src/circle/intersecting.js","../../packages/geometry/dist/src/shape/is-intersecting.js","../../packages/geometry/dist/src/shape/starburst.js","../../packages/geometry/dist/src/shape/index.js","../../packages/geometry/dist/src/circle-packing.js","../../packages/geometry/dist/src/layout.js","../../packages/geometry/dist/src/circle/area.js","../../packages/geometry/dist/src/rect/from-center.js","../../packages/geometry/dist/src/circle/bbox.js","../../packages/geometry/dist/src/circle/exterior-points.js","../../packages/geometry/dist/src/circle/interior-points.js","../../packages/geometry/dist/src/circle/perimeter.js","../../packages/geometry/dist/src/circle/interpolate.js","../../packages/geometry/dist/src/circle/multiply.js","../../packages/geometry/dist/src/circle/svg.js","../../packages/geometry/dist/src/circle/to-path.js","../../packages/geometry/dist/src/circle/to-positioned.js","../../packages/geometry/dist/src/circle/index.js","../../packages/geometry/dist/src/rect/area.js","../../packages/geometry/dist/src/rect/apply.js","../../packages/geometry/dist/src/rect/cardinal.js","../../packages/geometry/dist/src/rect/divide.js","../../packages/geometry/dist/src/rect/edges.js","../../packages/geometry/dist/src/rect/empty.js","../../packages/geometry/dist/src/rect/encompass.js","../../packages/geometry/dist/src/rect/from-element.js","../../packages/geometry/dist/src/rect/from-numbers.js","../../packages/geometry/dist/src/rect/get-rect-positionedparameter.js","../../packages/geometry/dist/src/rect/is-equal.js","../../packages/geometry/dist/src/rect/lengths.js","../../packages/geometry/dist/src/rect/multiply.js","../../packages/geometry/dist/src/rect/nearest.js","../../packages/geometry/dist/src/rect/placeholder.js","../../packages/geometry/dist/src/rect/perimeter.js","../../packages/geometry/dist/src/rect/normalise-by-rect.js","../../packages/geometry/dist/src/rect/subtract.js","../../packages/geometry/dist/src/rect/sum.js","../../packages/geometry/dist/src/rect/to-array.js","../../packages/geometry/dist/src/rect/index.js","../../packages/geometry/dist/src/bezier/guard.js","../../packages/geometry/dist/src/path/start-end.js","../../packages/geometry/dist/src/path/compound-path.js","../../packages/geometry/dist/src/path/index.js","../../packages/geometry/dist/src/grid/inside.js","../../packages/geometry/dist/src/grid/guards.js","../../packages/geometry/dist/src/grid/apply-bounds.js","../../packages/geometry/dist/src/grid/array-1d.js","../../packages/geometry/dist/src/grid/array-2d.js","../../packages/geometry/dist/src/grid/values.js","../../packages/geometry/dist/src/grid/enumerators/cells.js","../../packages/geometry/dist/src/grid/as.js","../../packages/geometry/dist/src/grid/offset.js","../../packages/geometry/dist/src/grid/directions.js","../../packages/geometry/dist/src/grid/enumerators/index.js","../../packages/geometry/dist/src/grid/geometry.js","../../packages/geometry/dist/src/grid/indexing.js","../../packages/geometry/dist/src/grid/is-equal.js","../../packages/geometry/dist/src/grid/neighbour.js","../../packages/geometry/dist/src/grid/to-array.js","../../packages/geometry/dist/src/grid/to-string.js","../../packages/geometry/dist/src/grid/visual.js","../../packages/geometry/dist/src/grid/visitors/breadth.js","../../packages/geometry/dist/src/grid/visitors/cell-neighbours.js","../../packages/geometry/dist/src/grid/visitors/columns.js","../../packages/geometry/dist/src/grid/visitors/depth.js","../../packages/geometry/dist/src/grid/visitors/random.js","../../packages/geometry/dist/src/grid/visitors/random-contiguous.js","../../packages/geometry/dist/src/grid/visitors/rows.js","../../packages/geometry/dist/src/grid/visitors/visitor.js","../../packages/geometry/dist/src/grid/visitors/step.js","../../packages/geometry/dist/src/grid/visitors/index.js","../../packages/geometry/dist/src/grid/index.js","../../packages/geometry/dist/src/bezier/index.js","../../packages/geometry/dist/src/ellipse.js","../../packages/geometry/dist/src/curve-simplification.js","../../packages/geometry/dist/src/quad-tree.js","../../packages/geometry/dist/src/scaler.js","../../packages/geometry/dist/src/arc/index.js","../../packages/geometry/dist/src/surface-points.js","../../packages/geometry/dist/src/triangle/angles.js","../../packages/geometry/dist/src/triangle/edges.js","../../packages/geometry/dist/src/triangle/area.js","../../packages/geometry/dist/src/triangle/barycentric.js","../../packages/geometry/dist/src/triangle/bbox.js","../../packages/geometry/dist/src/triangle/corners.js","../../packages/geometry/dist/src/triangle/from.js","../../packages/geometry/dist/src/triangle/lengths.js","../../packages/geometry/dist/src/triangle/kinds.js","../../packages/geometry/dist/src/triangle/perimeter.js","../../packages/geometry/dist/src/triangle/inner-circle.js","../../packages/geometry/dist/src/triangle/outer-circle.js","../../packages/geometry/dist/src/triangle/rotate.js","../../packages/geometry/dist/src/triangle/equilateral.js","../../packages/geometry/dist/src/triangle/right.js","../../packages/geometry/dist/src/triangle/isosceles.js","../../packages/geometry/dist/src/triangle/index.js"],"sourcesContent":["/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};","import { guardArray } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  guardArray(data, `data`);\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});\n\nexport const sortByProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  guardArray(data, `data`);\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (\n  data: number[] | readonly number[],\n  fn?: (relativePos: number) => number\n): number[] => {\n  if (!Array.isArray(data)) throw new TypeError(`Param 'data' is expected to be an array. Got type: ${ typeof data }`);\n  const weightingFunction = fn ?? ((x: number) => x);\n  return data.map(\n    (value: number, index: number) => {\n      if (typeof value !== `number`) throw new TypeError(`Param 'data' contains non-number at index: '${ index }'. Type: '${ typeof value }' value: '${ value }'`);\n      const relativePos = index / (data.length - 1);\n      const weightForPosition = weightingFunction(relativePos);\n      if (typeof weightForPosition !== `number`) throw new TypeError(`Weighting function returned type '${ typeof weightForPosition }' rather than number for input: '${ relativePos }'`);\n      const finalResult = value * weightForPosition;\n      //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n      return finalResult;\n    }\n  );\n};\n\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data: readonly number[]) =>\n  data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (\n  values: readonly (readonly number[])[]\n): number => {\n  let r = 0;\n  const length = values[ 0 ].length;\n\n  for (let index = 0; index < length; index++) {\n    let t = 0;\n    for (const [ p, value ] of values.entries()) {\n      if (p === 0) t = value[ index ];\n      else {\n        t *= value[ index ];\n      }\n    }\n    r += t;\n  }\n  return r;\n};\n\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link minMaxAvg} if you want min, max and total as well.\n *\n * @example\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data: readonly number[]): number => {\n  // ✔ UNIT TESTED\n  if (data === undefined) throw new Error(`data parameter is undefined`);\n  const valid = validNumbers(data);\n  const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n  return total / valid.length;\n};\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data: readonly number[]): number =>\n  Math.min(...validNumbers(data));\n\n/**\n * Returns the index of the largest value.\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data: readonly number[]): number =>\n\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value > array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data: readonly number[]): number =>\n\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value < array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data: readonly number[]): number =>\n  Math.max(...validNumbers(data));\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data: readonly number[]): number =>\n  data.reduce((previous, current) => {\n    if (typeof current !== `number`) return previous;\n    if (Number.isNaN(current)) return previous;\n    if (!Number.isFinite(current)) return previous;\n    return previous + current;\n  }, 0);\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data: readonly number[] | Float32Array): number => {\n  let m = Number.MIN_SAFE_INTEGER;\n  for (const datum of data) {\n    m = Math.max(m, datum);\n  }\n  return m;\n};\n\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data: readonly number[] | Float32Array): number => {\n  let m = 0;\n  for (const datum of data) {\n    m += datum;\n  }\n  return m;\n};\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data: readonly number[] | Float32Array): number => {\n  let m = Number.MIN_SAFE_INTEGER;\n  for (const datum of data) {\n    m = Math.min(m, datum);\n  }\n  return m;\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\n\nexport function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number | boolean, roundUp?: boolean) {\n  throwIntegerTest(a, `positive`, `decimalPlaces`);\n\n  const up = (typeof b === `boolean`) ? b : (roundUp ?? false)\n  let rounder;\n  if (a === 0) {\n    rounder = Math.round;\n  } else {\n    const p = Math.pow(10, a);\n    if (up) {\n      rounder = (v: number) => Math.ceil(v * p) / p;\n    } else {\n      rounder = (v: number) => Math.floor(v * p) / p;\n    }\n  }\n  if (typeof b === `number`) return rounder(b);\n  return rounder;\n}\n\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { throwNumberTest, throwIntegerTest } from '@ixfx/guards';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min = 0, max = 360) => {\n  throwIntegerTest(v, undefined, `v`);\n  throwIntegerTest(min, undefined, `min`);\n  throwIntegerTest(max, undefined, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min = 0, max = 1) => {\n  throwNumberTest(v, ``, `min`);\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(\n  start: number,\n  end: number,\n  steps: number,\n  precision?: number\n): IterableIterator<number> {\n  throwNumberTest(start, ``, `start`);\n  throwNumberTest(end, ``, `end`);\n\n  throwNumberTest(steps, ``, `steps`);\n  const r = precision ? round(precision) : (v: number) => v;\n  const step = (end - start) / (steps - 1);\n\n  throwNumberTest(step, ``, `step`);\n  if (!Number.isFinite(step)) {\n    throw new TypeError(`Calculated step value is infinite`);\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < steps; index++) {\n    const v = start + step * index;\n    yield r(v);\n  }\n}\n","import { throwNumberTest, numberTest } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r[ 0 ] && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n};\n\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n * \n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * \n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  const q = new BasicQueueMutable<number>();\n  return (v?: number) => {\n    const r = numberTest(v);\n    if (r[ 0 ] && v !== undefined) {\n      q.enqueue(v);\n      while (q.size > samples) {\n        q.dequeue();\n      }\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n};\n\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    timestamp ??= performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { clamp, clamper } from './clamp.js';\nimport { throwNumberTest } from '@ixfx/guards';\nimport type { NumberScaler, NumberScalerTwoWay } from './types.js';\n\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => scaler(inMin, inMax, outMin, outMax, easing)(v);\n\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number,\n  clamped?: boolean\n): NumberScaler => {\n\n  throwNumberTest(inMin, `finite`, `inMin`);\n  throwNumberTest(inMax, `finite`, `inMax`);\n\n  const oMax = outMax ?? 1;\n  const oMin = outMin ?? 0;\n  const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n\n  return (v: number): number => {\n    if (inMin === inMax) return oMax;\n\n    let a = (v - inMin) / (inMax - inMin);\n    if (easing !== undefined) a = easing(a);\n    const x = a * (oMax - oMin) + oMin;\n    if (clampFunction) return clampFunction(x);\n    return x;\n  };\n};\n\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns \n */\nexport const scalerNull = (): NumberScaler => (v: number) => v;\n\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => {\n  if (outMax === undefined) outMax = 1;\n  if (outMin === undefined) outMin = 0;\n  if (inMin === inMax) return outMax;\n\n  const x = scale(v, inMin, inMax, outMin, outMax, easing);\n  return clamp(x, outMin, outMax);\n};\n\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * import { scalePercentages } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (\n  percentage: number,\n  outMin: number,\n  outMax = 1\n): number => {\n  throwNumberTest(percentage, `percentage`, `v`);\n  throwNumberTest(outMin, `percentage`, `outMin`);\n  throwNumberTest(outMax, `percentage`, `outMax`);\n  return scale(percentage, 0, 1, outMin, outMax);\n};\n\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * import { scalePercent } from 'https://unpkg.com/ixfx/dist/data.js';\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (\n  v: number,\n  outMin: number,\n  outMax: number\n): number => scalerPercent(outMin, outMax)(v);\n\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin: number, outMax: number) => {\n  return (v: number) => {\n    throwNumberTest(v, `percentage`, `v`);\n    return scale(v, 0, 1, outMin, outMax);\n  };\n};\n\n\n\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n * \n * // Scale from input to output\n * s.out(50); // 0.5\n * \n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin \n * @param inMax \n * @param outMin \n * @param outMax \n * @returns \n */\nexport const scalerTwoWay = (inMin: number, inMax: number, outMin = 0, outMax = 1, clamped = false, easing?: (v: number) => number): NumberScalerTwoWay => {\n  const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n  const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n  return { out: toOut, in: toIn };\n}","import { throwIntegerTest, throwNumberTest } from \"@ixfx/guards\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyString = every.toString();\n  const decimal = everyString.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    const d = everyString.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n  throwNumberTest(v, ``, `v`);\n  throwIntegerTest(every, ``, `every`);\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { guardArray } from \"@ixfx/guards\";\nimport { weightedIndex } from \"./weighted-index.js\";\nimport type { RandomSource } from \"./types.js\";\n\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = Math.random\n): number => Math.floor(rand() * array.length);\n\n\n/**\n * Removes a random item from an array, returning both the item and the new array as a result.\n * Does not modify the original array unless `mutate` parameter is true.\n *\n * @example Without changing source\n * ```js\n * const data = [100, 20, 40];\n * const {value, array} = randomPluck(data);\n * // value: 20, array: [100, 40], data: [100, 20, 40];\n * ```\n *\n * @example Mutating source\n * ```js\n * const data = [100, 20, 40];\n * const {value} = randomPluck(data, true);\n * // value: 20, data: [100, 40];\n * ```\n *\n * @typeParam V - Type of items in array\n * @param array Array to pluck item from\n * @param mutate If _true_, changes input array. _False_ by default.\n * @param rand Random generatr. `Math.random` by default.\n * @return Returns an object `{value:V|undefined, array:V[]}`\n *\n */\nexport const randomPluck = <V>(\n  array: readonly V[] | V[],\n  mutate = false,\n  rand: RandomSource = Math.random\n): { readonly value: V | undefined; readonly array: V[] } => {\n  if (typeof array === `undefined`) throw new Error(`Param 'array' is undefined`);\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array`);\n  if (array.length === 0) return { value: undefined, array: [] };\n  const index = randomIndex(array, rand);\n  if (mutate) {\n    return {\n      value: array[ index ],\n      array: array.splice(index, 1),\n    };\n  } else {\n    // Copy array, remove item from that\n    const t = [ ...array ];\n    t.splice(index, 1);\n    return {\n      value: array[ index ],\n      array: t,\n    };\n  }\n};\n\n\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = Math.random\n): V => {\n  guardArray(array, `array`);\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n\n/**\n * Selects a random array index, biased by the provided `weightings`.\n * \n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ] \n * ```\n * @param array \n * @param weightings \n * @param randomSource \n */\nexport const randomElementWeightedSource = <V>(array: ArrayLike<V>, weightings: number[], randomSource: RandomSource = Math.random) => {\n  if (array.length !== weightings.length) throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n  const r = weightedIndex(weightings, randomSource);\n  return (): V => {\n    const index = r();\n    return array[ index ];\n  }\n}\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: readonly V[],\n  rand: RandomSource = Math.random\n): V[] => {\n  const array = [ ...dataToShuffle ];\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};","// ✔ UNIT TESTED\nimport { defaultKeyer, type ToString } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';//'../../Events.js';\nimport { type ISetMutable } from './ISetMutable.js';\nimport { type ValueSetEventMap } from './Types.js';\n\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = <V>(\n  keyString?: ToString<V>\n): ISetMutable<V> => new SetStringMutable(keyString);\n\n/**\n * Mutable string set\n */\nexport class SetStringMutable<V>\n  extends SimpleEventEmitter<ValueSetEventMap<V>>\n  implements ISetMutable<V> {\n  // ✔ UNIT TESTED\n  /* eslint-disable functional/prefer-readonly-type */\n  store = new Map<string, V>();\n  keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n   */\n  constructor(keyString: ToString<V> | undefined) {\n    super();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  /**\n   * Number of items stored in set\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Adds one or more items to set. `add` event is fired for each item\n   * @param values items to add\n   */\n  add(...values: V[]): boolean {\n    //eslint-disable-next-line functional/no-let\n    let somethingAdded = false;\n    for (const value of values) {\n      const isUpdated = this.has(value);\n      this.store.set(this.keyString(value), value);\n      super.fireEvent(`add`, { value: value, updated: isUpdated });\n      if (!isUpdated) somethingAdded = true;\n    }\n    return somethingAdded;\n  }\n\n  /**\n   * Returns values from set as an iterable\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  values() {\n    return this.store.values();\n  }\n\n  /**\n   * Clear items from set\n   */\n  clear() {\n    this.store.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  /**\n   * Delete value from set.\n   * @param v Value to delete\n  * @returns _True_ if item was found and removed\n   */\n  delete(v: V): boolean {\n    const isDeleted = this.store.delete(this.keyString(v));\n    if (isDeleted) super.fireEvent(`delete`, v);\n    return isDeleted;\n  }\n\n  /**\n   * Returns _true_ if item exists in set\n   * @param v\n   * @returns\n   */\n  has(v: V): boolean {\n    return this.store.has(this.keyString(v));\n  }\n\n  /**\n   * Returns array copy of set\n   * @returns Array copy of set\n   */\n  toArray(): V[] {\n    return [ ...this.store.values() ];\n  }\n}\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'² + y'²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')² + (z'x\" - z\"x')² + (x'y\" - x\"y')²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'² + y'² + z'²)^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import { throwNumberTest } from '@ixfx/guards';\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport const isNull = (p) => {\n    if (isPoint3d(p)) {\n        if (p.z !== null)\n            return false;\n    }\n    return p.x === null && p.y === null;\n};\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport const isNaN = (p) => {\n    if (isPoint3d(p)) {\n        if (!Number.isNaN(p.z))\n            return false;\n    }\n    return Number.isNaN(p.x) || Number.isNaN(p.y);\n};\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p, name = `Point`) {\n    if (p === undefined) {\n        throw new Error(`'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (p === null) {\n        throw new Error(`'${name}' is null. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (p.x === undefined) {\n        throw new Error(`'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (p.y === undefined) {\n        throw new Error(`'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (typeof p.x !== `number`) {\n        throw new TypeError(`'${name}.x' must be a number. Got ${typeof p.x}`);\n    }\n    if (typeof p.y !== `number`) {\n        throw new TypeError(`'${name}.y' must be a number. Got ${typeof p.y}`);\n    }\n    if (p.z !== undefined) {\n        if (typeof p.z !== `number`)\n            throw new TypeError(`${name}.z must be a number. Got: ${typeof p.z}`);\n        if (Number.isNaN(p.z))\n            throw new Error(`'${name}.z' is NaN. Got: ${JSON.stringify(p)}`);\n    }\n    if (p.x === null)\n        throw new Error(`'${name}.x' is null`);\n    if (p.y === null)\n        throw new Error(`'${name}.y' is null`);\n    if (Number.isNaN(p.x))\n        throw new Error(`'${name}.x' is NaN`);\n    if (Number.isNaN(p.y))\n        throw new Error(`'${name}.y' is NaN`);\n}\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt, name = `pt`) => {\n    guard(pt, name);\n    throwNumberTest(pt.x, `nonZero`, `${name}.x`);\n    throwNumberTest(pt.y, `nonZero`, `${name}.y`);\n    if (typeof pt.z !== `undefined`) {\n        throwNumberTest(pt.z, `nonZero`, `${name}.z`);\n    }\n    return true;\n};\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p) {\n    if (p === undefined)\n        return false;\n    if (p === null)\n        return false;\n    if (p.x === undefined)\n        return false;\n    if (p.y === undefined)\n        return false;\n    return true;\n}\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p) => {\n    if (p === undefined)\n        return false;\n    if (p === null)\n        return false;\n    if (p.x === undefined)\n        return false;\n    if (p.y === undefined)\n        return false;\n    if (p.z === undefined)\n        return false;\n    return true;\n};\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p) => {\n    if (isPoint3d(p)) {\n        if (p.z !== 0)\n            return false;\n    }\n    return p.x === 0 && p.y === 0;\n};\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p) => {\n    if (isPoint3d(p)) {\n        if (!Number.isNaN(p.z))\n            return false;\n    }\n    return Number.isNaN(p.x) && Number.isNaN(p.y);\n};\n","import { guard as guardPoint } from '../point/guard.js';\n/**\n * Returns a line from two points\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns\n */\nexport const fromPoints = (a, b) => {\n    guardPoint(a, `a`);\n    guardPoint(b, `b`);\n    a = Object.freeze({ ...a });\n    b = Object.freeze({ ...b });\n    return Object.freeze({\n        a: a,\n        b: b\n    });\n};\n","import { fromPoints } from \"./from-points.js\";\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n *\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points\n * @returns\n */\nexport const joinPointsToLines = (...points) => {\n    const lines = [];\n    let start = points[0];\n    for (let index = 1; index < points.length; index++) {\n        //eslint-disable-next-line functional/immutable-data\n        lines.push(fromPoints(start, points[index]));\n        start = points[index];\n    }\n    return lines;\n};\n","import { isPoint } from \"../point/guard.js\";\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p) => {\n    if (p === undefined)\n        return false;\n    if (p.a === undefined)\n        return false;\n    if (p.b === undefined)\n        return false;\n    if (!isPoint(p.a))\n        return false;\n    if (!isPoint(p.b))\n        return false;\n    return true;\n};\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p) => {\n    if (!Array.isArray(p))\n        return false;\n    const valid = !p.some(v => !isLine(v));\n    return valid;\n};\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n *\n * Does not validate points\n * @param line\n * @param name\n */\nexport const guard = (line, name = `line`) => {\n    if (line === undefined)\n        throw new Error(`${name} undefined`);\n    if (line.a === undefined)\n        throw new Error(`${name}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(line)}`);\n    if (line.b === undefined)\n        throw new Error(`${name}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(line)}`);\n};\n","import { isLine } from \"./guard.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine\n * @param b\n * @returns\n */\nexport const getPointParameter = (aOrLine, b) => {\n    let a;\n    if (isLine(aOrLine)) {\n        b = aOrLine.b;\n        a = aOrLine.a;\n    }\n    else {\n        a = aOrLine;\n        if (b === undefined)\n            throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n    }\n    guardPoint(a, `a`);\n    guardPoint(a, `b`);\n    return [a, b];\n};\n","import { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\n/**\n * Returns length of line, polyline or between two points\n *\n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine, pointB) {\n    if (isPolyLine(aOrLine)) {\n        const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n        return sum;\n    }\n    if (aOrLine === undefined)\n        throw new TypeError(`Parameter 'aOrLine' is undefined`);\n    const [a, b] = getPointParameter(aOrLine, pointB);\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    if (a.z !== undefined && b.z !== undefined) {\n        const z = b.z - a.z;\n        return Math.hypot(x, y, z);\n    }\n    else {\n        return Math.hypot(x, y);\n    }\n}\n","import { guard } from \"./guard.js\";\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line\n * @returns\n */\nexport function reverse(line) {\n    guard(line, `line`);\n    return { a: line.b, b: line.a };\n}\n","import { throwNumberTest, throwPercentTest } from \"@ixfx/guards\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between a line's start and end points.\n *\n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns\n */\nexport function interpolate(amount, aOrLine, pointBOrAllowOverflow, allowOverflow) {\n    if (typeof pointBOrAllowOverflow === `boolean`) {\n        allowOverflow = pointBOrAllowOverflow;\n        pointBOrAllowOverflow = undefined;\n    }\n    if (!allowOverflow)\n        throwPercentTest(amount, `amount`);\n    else\n        throwNumberTest(amount, ``, `amount`);\n    const [a, b] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n    const d = length(a, b);\n    const d2 = d * (1 - amount);\n    // Points are identical, return a copy of b\n    if (d === 0 && d2 === 0)\n        return Object.freeze({ ...b });\n    const x = b.x - (d2 * (b.x - a.x) / d);\n    const y = b.y - (d2 * (b.y - a.y) / d);\n    return Object.freeze({\n        ...b,\n        x: x,\n        y: y\n    });\n}\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns\n */\nexport function pointAtDistance(line, distance, fromA = true) {\n    if (!fromA)\n        line = reverse(line);\n    const dx = line.b.x - line.a.x;\n    const dy = line.b.y - line.a.y;\n    const theta = Math.atan2(dy, dx);\n    const xp = distance * Math.cos(theta);\n    const yp = distance * Math.sin(theta);\n    return { x: xp + line.a.x, y: yp + line.a.y };\n}\n","import { interpolate } from \"./interpolate.js\";\nimport { length } from \"./length.js\";\nconst directionVector = (line) => ({\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n});\nconst directionVectorNormalised = (line) => {\n    const l = length(line);\n    const v = directionVector(line);\n    return {\n        x: v.x / l,\n        y: v.y / l\n    };\n};\n/**\n * Returns a parallel line to `line` at `distance`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance\n */\nexport const parallel = (line, distance) => {\n    const dv = directionVector(line);\n    const dvn = directionVectorNormalised(line);\n    const a = {\n        x: line.a.x - dvn.y * distance,\n        y: line.a.y + dvn.x * distance\n    };\n    return {\n        a,\n        b: {\n            x: a.x + dv.x,\n            y: a.y + dv.y\n        }\n    };\n};\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line, distance, amount = 0) => {\n    const origin = interpolate(amount, line);\n    const dvn = directionVectorNormalised(line);\n    return {\n        x: origin.x - dvn.y * distance,\n        y: origin.y + dvn.x * distance\n    };\n};\n","import { interpolate } from \"./interpolate.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine\n * @param pointB\n * @returns\n */\nexport const midpoint = (aOrLine, pointB) => {\n    const [a, b] = getPointParameter(aOrLine, pointB);\n    return interpolate(0.5, a, b);\n};\n","import { guard as PointsGuard } from '../point/guard.js';\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d\n * @param name\n */\nexport const guardDim = (d, name = `Dimension`) => {\n    if (d === undefined)\n        throw new Error(`${name} is undefined`);\n    if (Number.isNaN(d))\n        throw new Error(`${name} is NaN`);\n    if (d < 0)\n        throw new Error(`${name} cannot be negative`);\n};\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n *\n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n *\n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect, name = `rect`) => {\n    if (rect === undefined)\n        throw new Error(`{$name} undefined`);\n    if (isPositioned(rect))\n        PointsGuard(rect, name);\n    guardDim(rect.width, name + `.width`);\n    guardDim(rect.height, name + `.height`);\n};\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n *\n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n *\n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *\n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect\n * @param origin\n * @returns\n */\nexport const getRectPositioned = (rect, origin) => {\n    guard(rect);\n    if (isPositioned(rect) && origin === undefined) {\n        return rect;\n    }\n    if (origin === undefined)\n        throw new Error(`Unpositioned rect needs origin parameter`);\n    return Object.freeze({ ...rect, ...origin });\n};\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect\n * @param name\n */\nexport const guardPositioned = (rect, name = `rect`) => {\n    if (!isPositioned(rect))\n        throw new Error(`Expected ${name} to have x,y`);\n    guard(rect, name);\n};\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect\n * @returns\n */\nexport const isEmpty = (rect) => rect.width === 0 && rect.height === 0;\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect\n * @returns\n */\nexport const isPlaceholder = (rect) => Number.isNaN(rect.width) && Number.isNaN(rect.height);\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (rect) => rect.x !== undefined && rect.y !== undefined;\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect) => {\n    if (rect === undefined)\n        return false;\n    if (rect.width === undefined)\n        return false;\n    if (rect.height === undefined)\n        return false;\n    return true;\n};\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (rect) => isRect(rect) && isPositioned(rect);\n","import { throwNumberTest } from \"@ixfx/guards\";\nimport { isRect } from \"../rect/guard.js\";\nimport { isPoint } from \"./guard.js\";\n/**\n * Normalises a point so it is on a 0..1 scale\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(a, b, c, d) {\n    // ✔️ Unit tested\n    if (isPoint(a)) {\n        if (typeof b === `number` && c !== undefined) {\n            throwNumberTest(b, `positive`, `width`);\n            throwNumberTest(c, `positive`, `height`);\n        }\n        else {\n            if (!isRect(b)) {\n                throw new Error(`Expected second parameter to be a rect`);\n            }\n            c = b.height;\n            b = b.width;\n        }\n        return Object.freeze({\n            x: a.x / b,\n            y: a.y / c,\n        });\n    }\n    else {\n        throwNumberTest(a, `positive`, `x`);\n        if (typeof b !== `number`) {\n            throw new TypeError(`Expecting second parameter to be a number (width)`);\n        }\n        if (typeof c !== `number`) {\n            throw new TypeError(`Expecting third parameter to be a number (height)`);\n        }\n        throwNumberTest(b, `positive`, `y`);\n        throwNumberTest(c, `positive`, `width`);\n        if (d === undefined)\n            throw new Error(`Expected height parameter`);\n        throwNumberTest(d, `positive`, `height`);\n        return Object.freeze({\n            x: a / c,\n            y: b / d,\n        });\n    }\n}\n","import { isPoint, isPoint3d } from \"./guard.js\";\nexport function getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6) {\n    if (isPoint3d(a1) && isPoint3d(ab2))\n        return [a1, ab2];\n    if (isPoint(a1) && isPoint(ab2))\n        return [a1, ab2];\n    if (isPoint3d(a1)) {\n        const b = {\n            x: ab2,\n            y: ab3,\n            z: ab4\n        };\n        if (!isPoint3d(b))\n            throw new Error(`Expected x, y & z parameters`);\n        return [a1, b];\n    }\n    if (isPoint(a1)) {\n        const b = {\n            x: ab2,\n            y: ab3\n        };\n        if (!isPoint(b))\n            throw new Error(`Expected x & y parameters`);\n        return [a1, b];\n    }\n    if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n        const a = {\n            x: a1,\n            y: ab2,\n            z: ab3\n        };\n        const b = {\n            x: ab4,\n            y: ab5,\n            z: ab6\n        };\n        if (!isPoint3d(a))\n            throw new Error(`Expected x,y,z for first point`);\n        if (!isPoint3d(b))\n            throw new Error(`Expected x,y,z for second point`);\n        return [a, b];\n    }\n    const a = {\n        x: a1,\n        y: ab2\n    };\n    const b = {\n        x: ab3,\n        y: ab4\n    };\n    if (!isPoint(a))\n        throw new Error(`Expected x,y for first point`);\n    if (!isPoint(b))\n        throw new Error(`Expected x,y for second point`);\n    return [a, b];\n}\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(a, b, c) {\n    if (a === undefined)\n        return { x: 0, y: 0 };\n    if (Array.isArray(a)) {\n        if (a.length === 0)\n            return Object.freeze({ x: 0, y: 0 });\n        if (a.length === 1)\n            return Object.freeze({ x: a[0], y: 0 });\n        if (a.length === 2)\n            return Object.freeze({ x: a[0], y: a[1] });\n        if (a.length === 3)\n            return Object.freeze({ x: a[0], y: a[1], z: a[2] });\n        throw new Error(`Expected array to be 1-3 elements in length. Got ${a.length}.`);\n    }\n    if (isPoint(a)) {\n        return a;\n    }\n    else if (typeof a !== `number` || typeof b !== `number`) {\n        throw new TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n    }\n    // x,y,z\n    if (typeof c === `number`) {\n        return Object.freeze({ x: a, y: b, z: c });\n    }\n    // x,y\n    return Object.freeze({ x: a, y: b });\n}\n","import { guard, isPoint3d } from \"./guard.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(a, xOrB, y, z) {\n    const pt = getPointParameter(xOrB, y, z);\n    guard(pt, `b`);\n    guard(a, `a`);\n    return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line, point) => {\n    const n = (line) => {\n        const { a, b } = line;\n        const atob = { x: b.x - a.x, y: b.y - a.y };\n        const atop = { x: point.x - a.x, y: point.y - a.y };\n        const length = atob.x * atob.x + atob.y * atob.y;\n        let dot = atop.x * atob.x + atop.y * atob.y;\n        const t = Math.min(1, Math.max(0, dot / length));\n        dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n        return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n    };\n    if (Array.isArray(line)) {\n        const pts = line.map(l => n(l));\n        const dists = pts.map(p => PointsDistance(p, point));\n        return Object.freeze(pts[minIndex(...dists)]);\n    }\n    else {\n        return Object.freeze(n(line));\n    }\n};\n","import { guard } from './guard.js';\nimport { guard as guardPoint } from '../point/guard.js';\nimport { length } from \"./length.js\";\nimport { nearest } from \"./nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns\n */\nexport const distanceSingleLine = (line, point) => {\n    guard(line, `line`);\n    guardPoint(point, `point`);\n    if (length(line) === 0) {\n        // Line is really a point\n        return length(line.a, point);\n    }\n    const near = nearest(line, point);\n    return length(near, point);\n};\n","import { isPoint3d } from \"./guard.js\";\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport function findMinimum(comparer, ...points) {\n    if (points.length === 0)\n        throw new Error(`No points provided`);\n    let min = points[0];\n    for (const p of points) {\n        if (isPoint3d(min) && isPoint3d(p)) {\n            min = comparer(min, p);\n        }\n        else {\n            min = comparer(min, p);\n        }\n    }\n    return min;\n}\n;\n","/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Geometry.Points.bbox | Geometry.Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (topLeft, topRight, bottomRight, bottomLeft) => {\n    if (topLeft.y > bottomRight.y) {\n        throw new Error(`topLeft.y greater than bottomRight.y`);\n    }\n    if (topLeft.y > bottomLeft.y) {\n        throw new Error(`topLeft.y greater than bottomLeft.y`);\n    }\n    const w1 = topRight.x - topLeft.x;\n    const w2 = bottomRight.x - bottomLeft.x;\n    const h1 = Math.abs(bottomLeft.y - topLeft.y);\n    const h2 = Math.abs(bottomRight.y - topRight.y);\n    return {\n        x: Math.min(topLeft.x, bottomLeft.x),\n        y: Math.min(topRight.y, topLeft.y),\n        width: Math.max(w1, w2),\n        height: Math.max(h1, h2),\n    };\n};\n","import { findMinimum } from \"./find-minimum.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points) => {\n    const leftMost = findMinimum((a, b) => {\n        return a.x < b.x ? a : b;\n    }, ...points);\n    const rightMost = findMinimum((a, b) => {\n        return a.x > b.x ? a : b;\n    }, ...points);\n    const topMost = findMinimum((a, b) => {\n        return a.y < b.y ? a : b;\n    }, ...points);\n    const bottomMost = findMinimum((a, b) => {\n        return a.y > b.y ? a : b;\n    }, ...points);\n    const topLeft = { x: leftMost.x, y: topMost.y };\n    const topRight = { x: rightMost.x, y: topMost.y };\n    const bottomRight = { x: rightMost.x, y: bottomMost.y };\n    const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n    return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\nexport const bbox3d = (...points) => {\n    const box = bbox(...points);\n    const zMin = findMinimum((a, b) => {\n        return a.z < b.z ? a : b;\n    }, ...points);\n    const zMax = findMinimum((a, b) => {\n        return a.z > b.z ? a : b;\n    }, ...points);\n    return {\n        ...box,\n        z: zMin.z,\n        depth: zMax.z - zMin.z\n    };\n};\n","import { bbox as PointsBbox } from \"../point/bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line) => PointsBbox(line.a, line.b);\n","import { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    if (ptB.x === 0)\n        throw new TypeError('Cannot divide by zero (b.x is 0)');\n    if (ptB.y === 0)\n        throw new TypeError('Cannot divide by zero (b.y is 0)');\n    const pt = {\n        x: ptA.x / ptB.x,\n        y: ptA.y / ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        if (ptB.z === 0)\n            throw new TypeError('Cannot divide by zero (b.z is 0)');\n        pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a, b, c) {\n    const divisor = getPointParameter(a, b, c);\n    guardNonZeroPoint(divisor, `divisor`);\n    return (aa, bb, cc) => {\n        const dividend = getPointParameter(aa, bb, cc);\n        return typeof dividend.z === `undefined` ? Object.freeze({\n            x: dividend.x / divisor.x,\n            y: dividend.y / divisor.y,\n        }) : Object.freeze({\n            x: dividend.x / divisor.x,\n            y: dividend.y / divisor.y,\n            z: dividend.z / (divisor.z ?? 1),\n        });\n    };\n}\n","import { divide as PointDivide } from '../point/divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n *\n * Dividing by zero will give Infinity for that dimension.\n * @param line\n * @param point\n * @returns\n */\nexport const divide = (line, point) => Object.freeze({\n    ...line,\n    a: PointDivide(line.a, point),\n    b: PointDivide(line.b, point)\n});\n","import { fromPoints } from \"./from-points.js\";\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns\n */\nexport const fromNumbers = (x1, y1, x2, y2) => {\n    if (Number.isNaN(x1))\n        throw new Error(`x1 is NaN`);\n    if (Number.isNaN(x2))\n        throw new Error(`x2 is NaN`);\n    if (Number.isNaN(y1))\n        throw new Error(`y1 is NaN`);\n    if (Number.isNaN(y2))\n        throw new Error(`y2 is NaN`);\n    const a = { x: x1, y: y1 };\n    const b = { x: x2, y: y2 };\n    return fromPoints(a, b);\n};\n","import { fromNumbers } from \"./from-numbers.js\";\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n *\n * See {@link toFlatArray} to create an array from a line.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array) => {\n    if (!Array.isArray(array))\n        throw new Error(`arr parameter is not an array`);\n    if (array.length !== 4)\n        throw new Error(`array is expected to have length four`);\n    return fromNumbers(array[0], array[1], array[2], array[3]);\n};\n","/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p) => {\n    if (p.distance === undefined)\n        return false;\n    if (p.angleRadian === undefined)\n        return false;\n    return true;\n};\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p, name = `Point`) => {\n    if (p === undefined) {\n        throw new Error(`'${name}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p === null) {\n        throw new Error(`'${name}' is null. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p.angleRadian === undefined) {\n        throw new Error(`'${name}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p.distance === undefined) {\n        throw new Error(`'${name}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (typeof p.angleRadian !== `number`) {\n        throw new TypeError(`'${name}.angleRadian' must be a number. Got ${p.angleRadian}`);\n    }\n    if (typeof p.distance !== `number`) {\n        throw new TypeError(`'${name}.distance' must be a number. Got ${p.distance}`);\n    }\n    if (p.angleRadian === null)\n        throw new Error(`'${name}.angleRadian' is null`);\n    if (p.distance === null)\n        throw new Error(`'${name}.distance' is null`);\n    if (Number.isNaN(p.angleRadian)) {\n        throw new TypeError(`'${name}.angleRadian' is NaN`);\n    }\n    if (Number.isNaN(p.distance))\n        throw new Error(`'${name}.distance' is NaN`);\n};\n","export const piPi = Math.PI * 2;\n","import { piPi } from './pi.js';\nexport function degreeToRadian(angleInDegrees) {\n    return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : angleInDegrees * (Math.PI / 180);\n}\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians\n * @returns\n */\nexport function radianInvert(angleInRadians) {\n    return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\nexport function radianToDegree(angleInRadians) {\n    return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : angleInRadians * 180 / Math.PI;\n}\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point\n * @returns\n */\nexport const radiansFromAxisX = (point) => Math.atan2(point.x, point.y);\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start, amount, clockwise = true) => {\n    if (clockwise) {\n        let x = start + amount;\n        if (x >= piPi)\n            x = x % piPi;\n        return x;\n    }\n    else {\n        const x = start - amount;\n        if (x < 0) {\n            return piPi + x;\n        }\n        return x;\n    }\n};\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n *\n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start, amount, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n *\n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n *\n * See {@link degreeArc} to operate in degrees.\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start, end, clockwise = true) => {\n    let s = start;\n    if (end < s) {\n        s = 0;\n        end = piPi - start + end;\n    }\n    let d = end - s;\n    if (clockwise)\n        d = piPi - d;\n    if (d >= piPi)\n        return d % piPi;\n    return d;\n};\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n *\n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n *\n * See {@link radianArc} to operate in radians.\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start, end, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));\n","import { guard } from \"./guard.js\";\nimport { degreeToRadian } from '../angles.js';\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c, amountRadian) => Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n});\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p) => {\n    guard(p, `c`);\n    return Object.freeze({\n        ...p,\n        angleRadian: p.angleRadian - Math.PI,\n    });\n};\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    if (a.distance !== b.distance)\n        return false;\n    return a.angleRadian === -b.angleRadian;\n};\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    return a.angleRadian === b.angleRadian;\n};\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    return a.angleRadian === -b.angleRadian;\n};\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c, amountDeg) => Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n});\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n *\n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x - ptB.x,\n        y: ptA.y - ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 };\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 };\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 };\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 };\n","import { guard, isPolarCoord } from \"./guard.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian = (a, b, c) => {\n    if (isPolarCoord(a)) {\n        if (b === undefined)\n            b = EmptyPoint;\n        if (isPoint(b)) {\n            return polarToCartesian(a.distance, a.angleRadian, b);\n        }\n        throw new Error(`Expecting (Coord, Point). Second parameter is not a point`);\n    }\n    else if (typeof a === `object`) {\n        throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(a)}`);\n    }\n    else {\n        if (typeof a === `number` && typeof b === `number`) {\n            if (c === undefined)\n                c = EmptyPoint;\n            if (!isPoint(c)) {\n                throw new Error(`Expecting (number, number, Point). Point param wrong type`);\n            }\n            return polarToCartesian(a, b, c);\n        }\n        else {\n            throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof a}, ${typeof b}, ${typeof c}). a: ${JSON.stringify(a)}`);\n        }\n    }\n};\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (point, origin) => {\n    point = subtractPoint(point, origin);\n    const angle = Math.atan2(point.y, point.x);\n    return Object.freeze({\n        ...point,\n        angleRadian: angle,\n        distance: Math.hypot(point.x, point.y),\n    });\n};\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (distance, angleRadians, origin = EmptyPoint) => {\n    guardPoint(origin);\n    return Object.freeze({\n        x: origin.x + distance * Math.cos(angleRadians),\n        y: origin.y + distance * Math.sin(angleRadians),\n    });\n};\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p, digits) => {\n    if (p === undefined)\n        return `(undefined)`;\n    if (p === null)\n        return `(null)`;\n    const angleDeg = radianToDegree(p.angleRadian);\n    const d = digits ? p.distance.toFixed(digits) : p.distance;\n    const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n    return `(${d},${a})`;\n};\nexport const toPoint = (v, origin = EmptyPoint) => {\n    guard(v, `v`);\n    return Object.freeze({\n        x: origin.x + v.distance * Math.cos(v.angleRadian),\n        y: origin.y + v.distance * Math.sin(v.angleRadian),\n    });\n};\n","import { guard } from \"./guard.js\";\nimport { throwNumberTest } from \"@ixfx/guards\";\nexport const normalise = (c) => {\n    //guard(v, `v`);\n    if (c.distance === 0)\n        throw new Error(`Cannot normalise vector of length 0`);\n    return Object.freeze({\n        ...c,\n        distance: 1,\n    });\n};\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v, max = 1, min = 0) => {\n    let mag = v.distance;\n    if (mag > max)\n        mag = max;\n    if (mag < min)\n        mag = min;\n    return Object.freeze({\n        ...v,\n        distance: mag,\n    });\n};\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v, amt) => {\n    guard(v);\n    throwNumberTest(amt, ``, `amt`);\n    return Object.freeze({\n        ...v,\n        distance: v.distance * amt,\n    });\n};\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v, amt) => {\n    guard(v);\n    throwNumberTest(amt, ``, `amt`);\n    return Object.freeze({\n        ...v,\n        distance: v.distance / amt,\n    });\n};\n","/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });\n","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n *\n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a, b, c) => {\n    guard(a, `a`);\n    if (b === undefined) {\n        return Math.atan2(a.y, a.x);\n    }\n    guard(b, `b`);\n    if (c === undefined) {\n        return Math.atan2(b.y - a.y, b.x - a.x);\n    }\n    guard(c, `c`);\n    return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadianCircle = (a, b, c) => {\n    const angle = angleRadian(a, b, c);\n    if (angle < 0)\n        return angle + piPi;\n    return angle;\n};\n","import {} from \"../line/line-type.js\";\nimport {} from '../point/point-type.js';\nimport { distance } from '../point/distance.js';\nimport { angleRadian } from '../point/angle.js';\nimport {} from \"./types.js\";\nimport { toCartesian as polarToCartesian } from \"./conversions.js\";\n/**\n * Converts a ray to a Line in cartesian coordinates.\n *\n * @param ray\n * @param origin Override or provide origin point\n * @returns\n */\nexport const toCartesian = (ray, origin) => {\n    const o = getOrigin(ray, origin);\n    const a = polarToCartesian(ray.offset, ray.angleRadian, o);\n    const b = polarToCartesian(ray.offset + ray.length, ray.angleRadian, o);\n    return { a, b };\n};\nconst getOrigin = (ray, origin) => {\n    if (origin !== undefined)\n        return origin;\n    if (ray.origin !== undefined)\n        return ray.origin;\n    return { x: 0, y: 0 };\n};\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray\n * @param origin\n * @returns\n */\n// const withOrigin = (ray: PolarRay, origin?: Point): PolarRayWithOrigin => {\n//   if (origin) {\n//     return {\n//       ...ray,\n//       origin\n//     };\n//   }\n//   if (ray.origin !== undefined) return { ...ray } as PolarRayWithOrigin;\n//   return {\n//     ...ray,\n//     origin: { x: 0, y: 0 }\n//   }\n// }\n// function getAngle(a: Point, b: Point) {\n//   const angle = Math.atan2(b.y - a.y, b.x - a.x);// * (180 / Math.PI) + 90;\n//   return angle;//return (angle < 0) ? scale(angle, -90, 0, 0, piPi) : angle;\n// }\nexport const toString = (ray) => {\n    return `PolarRay(angle: ${ray.angleRadian} offset: ${ray.offset} len: ${ray.length})`;\n};\n/**\n * Returns a PolarRay based on a line and origin.\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * @param line\n * @param origin\n * @returns\n */\nexport const fromLine = (line, origin) => {\n    const o = origin ?? line.a;\n    return {\n        angleRadian: angleRadian(line.b, o),\n        offset: distance(line.a, o),\n        length: distance(line.b, line.a),\n        origin: o\n    };\n};\n","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\nexport function* spiral(smoothness, zoom) {\n    let step = 0;\n    while (true) {\n        const a = smoothness * step++;\n        yield {\n            distance: zoom * a,\n            angleRadian: a,\n            step: step,\n        };\n    }\n}\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (step, smoothness, zoom) => {\n    const a = smoothness * step;\n    return Object.freeze({\n        distance: zoom * a,\n        angleRadian: a,\n    });\n};\n","// import { degreeToRadian, radianToDegree } from '../Angles.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js';\n","import * as Polar from \"../polar/index.js\";\nimport { radianInvert } from \"../angles.js\";\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n *\n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n *\n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line.\n * * Angle of 45deg will be angled downwards.\n *\n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin = { x: 0.5, y: 0.5 }, length = 1, angleRadian = 0, balance = 0.5) => {\n    const left = length * balance;\n    const right = length * (1 - balance);\n    const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n    const b = Polar.toCartesian(right, angleRadian, origin);\n    return Object.freeze({\n        a, b\n    });\n};\n","import { fromPoints } from \"./from-points.js\";\nimport { toPath } from \"./to-path.js\";\n/**\n * Returns a {@link LinePath} from two points\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const fromPointsToPath = (a, b) => toPath(fromPoints(a, b));\n","/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p) => {\n    if (p === undefined)\n        throw new Error(`parameter 'p' is undefined`);\n    if (p.length < 2)\n        return true;\n    for (let index = 1; index < p.length; index++) {\n        if (p[index].x !== p[0].x)\n            return false;\n        if (p[index].y !== p[0].y)\n            return false;\n    }\n    return true;\n};\n","import { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a, b) => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);\n","import { isPoint, isPoint3d } from \"./guard.js\";\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt) {\n    if (isPoint3d(pt)) {\n        return Object.freeze({\n            ...pt,\n            x: Math.abs(pt.x),\n            y: Math.abs(pt.y),\n            z: Math.abs(pt.z)\n        });\n    }\n    else if (isPoint(pt)) {\n        return Object.freeze({\n            ...pt,\n            x: Math.abs(pt.x),\n            y: Math.abs(pt.y)\n        });\n    }\n    else\n        throw new TypeError(`Param 'pt' is not a point`);\n}\n;\n","import { guard, isPoint3d } from \"./guard.js\";\n/**\n * Applies `fn` on x,y & z (if present) fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport function apply(pt, fn) {\n    guard(pt, `pt`);\n    if (isPoint3d(pt)) {\n        return Object.freeze({\n            ...pt,\n            x: fn(pt.x, `x`),\n            y: fn(pt.y, `y`),\n            z: fn(pt.z, `z`)\n        });\n    }\n    return Object.freeze({\n        ...pt,\n        x: fn(pt.x, `x`),\n        y: fn(pt.y, `y`),\n    });\n}\n","import { movingAverageLight as mal } from \"@ixfx/numbers\";\nimport { isPoint3d } from \"./guard.js\";\nexport function averager(kind, opts) {\n    let x;\n    let y;\n    let z;\n    switch (kind) {\n        case `moving-average-light`:\n            const scaling = opts.scaling ?? 3;\n            x = mal(scaling);\n            y = mal(scaling);\n            z = mal(scaling);\n            break;\n        default:\n            throw new Error(`Unknown averaging kind '${kind}'. Expected: 'moving-average-light'`);\n    }\n    return (point) => {\n        const ax = x(point.x);\n        const ay = y(point.y);\n        if (isPoint3d(point)) {\n            const az = z(point.z);\n            return Object.freeze({\n                x: ax,\n                y: ay,\n                z: az\n            });\n        }\n        else {\n            return Object.freeze({\n                x: ax,\n                y: ay\n            });\n        }\n    };\n}\n","import { isPoint } from \"./guard.js\";\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points) => {\n    if (!Array.isArray(points))\n        throw new Error(`Expected list of points`);\n    // eslint-disable-next-line unicorn/no-array-reduce\n    const sum = points.reduce((previous, p) => {\n        if (p === undefined)\n            return previous; // Ignore undefined\n        if (Array.isArray(p)) {\n            throw new TypeError(`'points' list contains an array. Did you mean: centroid(...myPoints)?`);\n        }\n        if (!isPoint(p)) {\n            throw new Error(`'points' contains something which is not a point: ${JSON.stringify(p)}`);\n        }\n        return {\n            x: previous.x + p.x,\n            y: previous.y + p.y,\n        };\n    }, { x: 0, y: 0 });\n    return Object.freeze({\n        x: sum.x / points.length,\n        y: sum.y / points.length,\n    });\n};\n","import { clamp as clampNumber } from '@ixfx/numbers';\nimport { throwNumberTest } from \"@ixfx/guards\";\nimport { isPoint, isPoint3d } from \"./guard.js\";\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(a, min = 0, max = 1) {\n    if (isPoint3d(a)) {\n        return Object.freeze({\n            x: clampNumber(a.x, min, max),\n            y: clampNumber(a.y, min, max),\n            z: clampNumber(a.z, min, max)\n        });\n    }\n    else {\n        return Object.freeze({\n            x: clampNumber(a.x, min, max),\n            y: clampNumber(a.y, min, max),\n        });\n    }\n}\n","/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a, b) => {\n    if (a.x < b.x && a.y < b.y)\n        return -2;\n    if (a.x > b.x && a.y > b.y)\n        return 2;\n    if (a.x < b.x || a.y < b.y)\n        return -1;\n    if (a.x > b.x || a.y > b.y)\n        return 1;\n    if (a.x === b.x && a.x === b.y)\n        return 0;\n    return Number.NaN;\n};\n/**\n * Compares points based on x value. Y value is ignored.\n *\n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n *\n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a, b) => {\n    if (a.x === b.x)\n        return 0;\n    if (a.x < b.x)\n        return -1;\n    return 1;\n    // a.x - b.x || a.y - b.y;\n};\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a, b) => {\n    if (a.y === b.y)\n        return 0;\n    if (a.y < b.y)\n        return -1;\n    return 1;\n};\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a, b) => {\n    if (a.z === b.z)\n        return 0;\n    if (a.z < b.z)\n        return -1;\n    return 1;\n};\n","import { compareByX } from \"./compare.js\";\nimport { isEqual } from \"./is-equal.js\";\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts) => {\n    const sorted = [...pts].sort(compareByX);\n    if (sorted.length === 1)\n        return sorted;\n    const x = (points) => {\n        const v = [];\n        for (const p of points) {\n            while (v.length >= 2) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const q = v.at(-1);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const r = v.at(-2);\n                if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n                    //eslint-disable-next-line functional/immutable-data\n                    v.pop();\n                }\n                else\n                    break;\n            }\n            //eslint-disable-next-line functional/immutable-data\n            v.push(p);\n        }\n        //eslint-disable-next-line functional/immutable-data\n        v.pop();\n        return v;\n    };\n    const upper = x(sorted);\n    //eslint-disable-next-line functional/immutable-data\n    const lower = x(sorted.reverse());\n    if (upper.length === 1 && lower.length === 1 && isEqual(lower[0], upper[0])) {\n        return upper;\n    }\n    return [...upper, ...lower];\n};\n","import { guard as guardPoint } from '../point/guard.js';\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle\n * @param parameterName\n */\nexport const guard = (circle, parameterName = `circle`) => {\n    if (isCirclePositioned(circle)) {\n        guardPoint(circle, `circle`);\n    }\n    if (Number.isNaN(circle.radius))\n        throw new Error(`${parameterName}.radius is NaN`);\n    if (circle.radius <= 0)\n        throw new Error(`${parameterName}.radius must be greater than zero`);\n};\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle\n * @param parameterName\n * @returns\n */\nexport const guardPositioned = (circle, parameterName = `circle`) => {\n    if (!isCirclePositioned(circle))\n        throw new Error(`Expected a positioned circle with x,y`);\n    guard(circle, parameterName);\n};\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a) => {\n    if (Number.isNaN(a.radius))\n        return true;\n    if (isCirclePositioned(a)) {\n        if (Number.isNaN(a.x))\n            return true;\n        if (Number.isNaN(a.y))\n            return true;\n    }\n    return false;\n};\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n *\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n *\n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns\n */\nexport const isPositioned = (p) => p.x !== undefined && p.y !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCircle = (p) => p.radius !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCirclePositioned = (p) => isCircle(p) && isPositioned(p);\n","import { distance as pointsDistance } from '../point/distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\n/**\n * Returns the distance between two circle centers.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a\n * @param b\n * @returns Distance\n */\nexport const distanceCenter = (a, b) => {\n    guardPositioned(a, `a`);\n    if (isCirclePositioned(b)) {\n        guardPositioned(b, `b`);\n    }\n    return pointsDistance(a, b);\n};\n","import { distanceCenter } from \"./distance-center.js\";\nimport { isPoint as PointsIsPoint } from \"../point/guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b\n */\nexport const distanceFromExterior = (a, b) => {\n    guardPositioned(a, `a`);\n    if (isCirclePositioned(b)) {\n        return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n    }\n    else if (PointsIsPoint(b)) {\n        const distribution = PointsDistance(a, b);\n        if (distribution < a.radius)\n            return 0;\n        return distribution;\n    }\n    else\n        throw new Error(`Second parameter invalid type`);\n};\n","import { isCirclePositioned } from \"./guard.js\";\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n *\n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n *\n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => {\n    if (a.radius !== b.radius)\n        return false;\n    if (isCirclePositioned(a) && isCirclePositioned(b)) {\n        if (a.x !== b.x)\n            return false;\n        if (a.y !== b.y)\n            return false;\n        if (a.z !== b.z)\n            return false;\n        return true;\n    }\n    else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n        // no-op\n    }\n    else\n        return false; // one is positioned one not\n    return false;\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points added.\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x + ptB.x,\n        y: ptA.y + ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n","import { isEqual } from \"./is-equal.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { subtract as PointsSubtract } from \"../point/subtract.js\";\n/**\n * Returns the point(s) of intersection between a circle and line.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle\n * @param line\n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle, line) => {\n    const v1 = {\n        x: line.b.x - line.a.x,\n        y: line.b.y - line.a.y\n    };\n    const v2 = {\n        x: line.a.x - circle.x,\n        y: line.a.y - circle.y\n    };\n    const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n    const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n    const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n    if (Number.isNaN(d))\n        return []; // no intercept\n    const u1 = (b - d) / c; // these represent the unit distance of point one and two on the line\n    const u2 = (b + d) / c;\n    const returnValue = [];\n    if (u1 <= 1 && u1 >= 0) { // add point if on the line segment\n        returnValue.push({\n            x: line.a.x + v1.x * u1,\n            y: line.a.y + v1.y * u1\n        });\n    }\n    if (u2 <= 1 && u2 >= 0) { // second add point if on the line segment\n        returnValue.push({\n            x: line.a.x + v1.x * u2,\n            y: line.a.y + v1.y * u2\n        });\n    }\n    return returnValue;\n};\n/**\n *\n * Returns the points of intersection betweeen `a` and `b`.\n *\n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a, b) => {\n    const vector = PointsSubtract(b, a);\n    const centerD = Math.hypot((vector.y), (vector.x));\n    // Do not intersect\n    if (centerD > a.radius + b.radius)\n        return [];\n    // Circle contains another\n    if (centerD < Math.abs(a.radius - b.radius))\n        return [];\n    // Circles are the same\n    if (isEqual(a, b))\n        return [];\n    const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n    const centroid = {\n        x: a.x + (vector.x * centroidD / centerD),\n        y: a.y + (vector.y * centroidD / centerD)\n    };\n    const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n    const intersection = {\n        x: -vector.y * (centroidIntersectionD / centerD),\n        y: vector.x * (centroidIntersectionD / centerD)\n    };\n    return [\n        PointsSum(centroid, intersection),\n        PointsSubtract(centroid, intersection)\n    ];\n};\n","import { intersections as circleIntersections } from \"./circle/intersections.js\";\nexport const circleRect = (a, b) => {\n    // https://yal.cc/rectangle-circle-intersection-test/\n    const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n    const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n    return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\nexport const circleCircle = (a, b) => circleIntersections(a, b).length === 2;\n","import { guard } from \"./guard.js\";\nimport { isPositioned, isRectPositioned } from \"./guard.js\";\nimport { isCirclePositioned } from '../circle/guard.js';\nimport * as Intersects from '../intersects.js';\nimport { isPoint } from \"../point/guard.js\";\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function intersectsPoint(rect, a, b) {\n    guard(rect, `rect`);\n    //eslint-disable-next-line functional/no-let\n    let x = 0;\n    //eslint-disable-next-line functional/no-let\n    let y = 0;\n    if (typeof a === `number`) {\n        if (b === undefined)\n            throw new Error(`x and y coordinate needed`);\n        x = a;\n        y = b;\n    }\n    else {\n        x = a.x;\n        y = a.y;\n    }\n    if (isPositioned(rect)) {\n        if (x - rect.x > rect.width || x < rect.x)\n            return false;\n        if (y - rect.y > rect.height || y < rect.y)\n            return false;\n    }\n    else {\n        // Assume 0,0\n        if (x > rect.width || x < 0)\n            return false;\n        if (y > rect.height || y < 0)\n            return false;\n    }\n    return true;\n}\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (a, \n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nb) => {\n    if (!isRectPositioned(a)) {\n        throw new Error(`a parameter should be RectPositioned`);\n    }\n    if (isCirclePositioned(b)) {\n        return Intersects.circleRect(b, a);\n    }\n    else if (isPoint(b)) {\n        return intersectsPoint(a, b);\n    }\n    throw new Error(`Unknown shape for b: ${JSON.stringify(b)}`);\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { getRectPositioned, guard } from \"./guard.js\";\n/**\n * Returns the center of a rectangle as a {@link Geometry.Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (rect, origin) => {\n    guard(rect);\n    if (origin === undefined && isPoint(rect))\n        origin = rect;\n    else if (origin === undefined)\n        origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n    const r = getRectPositioned(rect, origin);\n    return Object.freeze({\n        x: origin.x + rect.width / 2,\n        y: origin.y + rect.height / 2,\n    });\n};\n","import { guardPositioned } from \"./guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./center.js\";\nimport {} from '../point/point-type.js';\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { distance as PointsDistance } from '../point/distance.js';\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (rect, pt) => {\n    guardPositioned(rect, `rect`);\n    PointsGuard(pt, `pt`);\n    if (intersectsPoint(rect, pt))\n        return 0;\n    const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n    const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n    return Math.hypot(dx, dy);\n};\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (rect, pt) => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\nimport { distance } from \"./distance.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (a, shape) => {\n    if (isRectPositioned(shape)) {\n        return rectDistanceFromExterior(shape, a);\n    }\n    if (isCirclePositioned(shape)) {\n        return circleDistanceFromExterior(shape, a);\n    }\n    if (isPoint(shape))\n        return distance(a, shape);\n    throw new Error(`Unknown shape`);\n};\n","import { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distance } from \"./distance.js\";\nimport { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (a, shape) => {\n    if (isRectPositioned(shape)) {\n        return rectDistanceFromExterior(shape, a);\n    }\n    if (isCirclePositioned(shape)) {\n        return circleDistanceFromExterior(shape, a);\n    }\n    if (isPoint(shape))\n        return distance(a, shape);\n    throw new Error(`Unknown shape`);\n};\n","/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p) => [p.x, p.y];\n","import { dotProduct as ArraysDotProduct } from '@ixfx/numbers';\nimport { toArray } from './to-array.js';\nexport const dotProduct = (...pts) => {\n    const a = pts.map(p => toArray(p));\n    return ArraysDotProduct(a);\n};\n","import { guard } from \"./guard.js\";\n/**\n * Returns a point from two or three coordinates or an array of [x,y] or [x,y,z].\n * @example\n * ```js\n * let p = from([10, 5]);    // yields {x:10, y:5}\n * let p = from([10, 5, 2]); // yields: {x:10, y:5, z:2}\n * let p = from(10, 5);      // yields {x:10, y:5}\n * let p = from(10, 5, 2);   // yields: {x:10, y:5, z:2}\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport function from(xOrArray, y, z) {\n    if (Array.isArray(xOrArray)) {\n        if (xOrArray.length === 3) {\n            return Object.freeze({\n                x: xOrArray[0],\n                y: xOrArray[1],\n                z: xOrArray[2]\n            });\n        }\n        else if (xOrArray.length === 2) {\n            return Object.freeze({\n                x: xOrArray[0],\n                y: xOrArray[1],\n            });\n        }\n        else {\n            throw new Error(`Expected array of length two or three, got ${xOrArray.length}`);\n        }\n    }\n    else {\n        if (xOrArray === undefined)\n            throw new Error(`Requires an array of [x,y] or x,y parameters at least`);\n        else if (Number.isNaN(xOrArray))\n            throw new Error(`x is NaN`);\n        if (y === undefined)\n            throw new Error(`Param 'y' is missing`);\n        else if (Number.isNaN(y))\n            throw new Error(`y is NaN`);\n        if (z === undefined) {\n            return Object.freeze({ x: xOrArray, y: y });\n        }\n        else {\n            return Object.freeze({ x: xOrArray, y, z });\n        }\n    }\n}\n;\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n *\n * Throws an error if `str` is not a string.\n *\n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n *\n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param str\n */\nexport const fromString = (str) => {\n    if (typeof str !== `string`)\n        throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof str}`);\n    const comma = str.indexOf(`,`);\n    const x = Number.parseFloat(str.substring(0, comma));\n    const nextComma = str.indexOf(',', comma + 1);\n    if (nextComma > 0) {\n        // z component\n        const y = Number.parseFloat(str.substring(comma + 1, nextComma - comma + 2));\n        const z = Number.parseFloat(str.substring(nextComma + 1));\n        return { x, y, z };\n    }\n    else {\n        const y = Number.parseFloat(str.substring(comma + 1));\n        return { x, y };\n    }\n};\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (...coords) => {\n    const pts = [];\n    if (Array.isArray(coords[0])) {\n        // [[x,y],[x,y]...]\n        for (const coord of coords) {\n            if (!(coord.length % 2 === 0)) {\n                throw new Error(`coords array should be even-numbered`);\n            }\n            //eslint-disable-next-line  functional/immutable-data\n            pts.push(Object.freeze({ x: coord[0], y: coord[1] }));\n        }\n    }\n    else {\n        // [x,y,x,y,x,y]\n        if (coords.length % 2 !== 0) {\n            throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n        }\n        for (let index = 0; index < coords.length; index += 2) {\n            //eslint-disable-next-line  functional/immutable-data\n            pts.push(Object.freeze({ x: coords[index], y: coords[index + 1] }));\n        }\n    }\n    return pts;\n};\n","import { interpolate as lineInterpolate } from '../line/interpolate.js';\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (amount, a, b, allowOverflow = false) => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./guard.js\";\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (pt, what = `both`) => {\n    switch (what) {\n        case `both`: {\n            return isPoint3d(pt) ? Object.freeze({\n                ...pt,\n                x: pt.x * -1,\n                y: pt.y * -1,\n                z: pt.z * -1,\n            }) : Object.freeze({\n                ...pt,\n                x: pt.x * -1,\n                y: pt.y * -1,\n            });\n        }\n        case `x`: {\n            return Object.freeze({\n                ...pt,\n                x: pt.x * -1,\n            });\n        }\n        case `y`: {\n            return Object.freeze({\n                ...pt,\n                y: pt.y * -1,\n            });\n        }\n        case `z`: {\n            if (isPoint3d(pt)) {\n                return Object.freeze({\n                    ...pt,\n                    z: pt.z * -1,\n                });\n            }\n            else\n                throw new Error(`pt parameter is missing z`);\n        }\n        default: {\n            throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n        }\n    }\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x * ptB.x,\n        y: ptA.y * ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (pt, v) => {\n    return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * v,\n        y: pt.y * v,\n        z: pt.z * v,\n    }) : Object.freeze({\n        ...pt,\n        x: pt.x * v,\n        y: pt.y * v,\n    });\n};\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt, max = 1, min = 0) => {\n    const length = distance(pt);\n    let ratio = 1;\n    if (length > max) {\n        ratio = max / length;\n    }\n    else if (length < min) {\n        ratio = min / length;\n    }\n    return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};\n","import { findMinimum } from \"./find-minimum.js\";\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points) => findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points) => findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nconst length = (ptOrX, y) => {\n    if (isPoint(ptOrX)) {\n        y = ptOrX.y;\n        ptOrX = ptOrX.x;\n    }\n    if (y === undefined)\n        throw new Error(`Expected y`);\n    return Math.hypot(ptOrX, y);\n};\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX, y) => {\n    const pt = getPointParameter(ptOrX, y);\n    const l = length(pt);\n    if (l === 0)\n        return Empty;\n    return Object.freeze({\n        ...pt,\n        x: pt.x / l,\n        y: pt.y / l,\n    });\n};\n","/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (point, ...pipelineFns) => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline = (...pipeline) => (pt) => \n// eslint-disable-next-line unicorn/no-array-reduce\npipeline.reduce((previous, current) => current(previous), pt);\n","import { guard } from \"./guard.js\";\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (pt, rounder = Math.round) => {\n    guard(pt, `pt`);\n    return Object.freeze({\n        x: rounder(pt.x),\n        y: rounder(pt.y),\n    });\n};\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt\n * @returns\n */\nexport const to2d = (pt) => {\n    guard(pt, `pt`);\n    let copy = {\n        ...pt\n    };\n    delete copy.z;\n    return Object.freeze(copy);\n};\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns\n */\nexport const to3d = (pt, z = 0) => {\n    guard(pt, `pt`);\n    return Object.freeze({\n        ...pt,\n        z\n    });\n};\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p, digits) {\n    if (p === undefined)\n        return `(undefined)`;\n    if (p === null)\n        return `(null)`;\n    guard(p, `pt`);\n    const x = digits ? p.x.toFixed(digits) : p.x;\n    const y = digits ? p.y.toFixed(digits) : p.y;\n    if (p.z === undefined) {\n        return `(${x},${y})`;\n    }\n    else {\n        const z = digits ? p.z.toFixed(digits) : p.z;\n        return `(${x},${y},${z})`;\n    }\n}\n","import { normalise as PointsNormalise } from './point/normalise.js';\nimport { isPoint } from './point/guard.js';\nimport * as Polar from './polar/index.js';\nimport { divide as PointDivide } from './point/divider.js';\nimport { guard as LinesGuard } from './line/guard.js';\nimport { sum as PointsSum } from './point/sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/dot-product.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/magnitude.js';\nimport { distance as PointsDistance } from './point/distance.js';\nimport { Empty as PointEmpty } from './point/empty.js';\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\nexport const fromRadians = (radians) => {\n    return Object.freeze({\n        x: Math.cos(radians),\n        y: Math.sin(radians)\n    });\n};\nexport const toRadians = (point) => {\n    return Math.atan2(point.y, point.x);\n};\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2π\n * if `bipolar` normalisation is used, direction will be fixed to -π...π\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (pt, angleNormalisation = ``, origin = EmptyCartesian) => {\n    pt = PointsSubtract(pt, origin);\n    //eslint-disable-next-line functional/no-let\n    let direction = Math.atan2(pt.y, pt.x);\n    if (angleNormalisation === `unipolar` && direction < 0)\n        direction += piPi;\n    else if (angleNormalisation === `bipolar`) {\n        if (direction > pi)\n            direction -= piPi;\n        else if (direction <= -pi)\n            direction += piPi;\n    }\n    return Object.freeze({\n        distance: PointsDistance(pt),\n        angleRadian: direction,\n    });\n};\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line) => PointsSubtract(line.b, line.a);\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line) => {\n    LinesGuard(line, `line`);\n    const pt = PointsSubtract(line.b, line.a);\n    return fromPointPolar(pt);\n};\nconst isPolar = (v) => {\n    if (Polar.isPolarCoord(v))\n        return true;\n    return false;\n};\nconst isCartesian = (v) => {\n    if (isPoint(v))\n        return true;\n    return false;\n};\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v) => {\n    if (isPolar(v)) {\n        return Polar.normalise(v);\n    }\n    else if (isCartesian(v)) {\n        return PointsNormalise(v);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\nexport const quadrantOffsetAngle = (p) => {\n    if (p.x >= 0 && p.y >= 0)\n        return 0; // Q1\n    if (p.x < 0 && p.y >= 0)\n        return pi; // Q2\n    if (p.x < 0 && p.y < 0)\n        return pi; // Q3\n    return piPi; // Q4\n};\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v, origin = PointEmpty) => {\n    if (isPolar(v)) {\n        return v;\n    }\n    else if (isCartesian(v)) {\n        return Polar.fromCartesian(v, origin);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v) => {\n    if (isPolar(v)) {\n        return Polar.toPoint(v);\n    }\n    else if (isCartesian(v)) {\n        return v;\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v, digits) => {\n    if (isPolar(v)) {\n        return Polar.toString(v, digits);\n    }\n    else if (isCartesian(v)) {\n        return PointsToString(v, digits);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a, b) => {\n    if (isPolar(a) && isPolar(b)) {\n        return Polar.dotProduct(a, b);\n    }\n    else if (isCartesian(a) && isCartesian(b)) {\n        return PointsDotProduct(a, b);\n    }\n    throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v, max = 1, min = 0) => {\n    if (isPolar(v)) {\n        return Polar.clampMagnitude(v, max, min);\n    }\n    else if (isCartesian(v)) {\n        return PointsClampMagnitude(v, max, min);\n    }\n    throw new Error(`Expected either polar or Cartesian vector`);\n};\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsSum(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsSubtract(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsMultiply(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointDivide(a, b);\n    return polar ? toPolar(c) : c;\n};\n","import { angleRadian } from \"./angle.js\";\nimport { centroid } from \"./centroid.js\";\nimport { distance } from \"./distance.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\n/**\n * Tracks the relation between two points.\n *\n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n *\n * It computes angle, average, centroid, distance and speed.\n *\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n *\n * Or with destructuring:\n *\n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link Trackers.points}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a, b) => {\n    const start = getPointParameter(a, b);\n    let totalX = 0;\n    let totalY = 0;\n    let count = 0;\n    let lastUpdate = performance.now();\n    let lastPoint = start;\n    const update = (aa, bb) => {\n        const p = getPointParameter(aa, bb);\n        totalX += p.x;\n        totalY += p.y;\n        count++;\n        const distanceFromStart = distance(p, start);\n        const distanceFromLast = distance(p, lastPoint);\n        // Track speed\n        const now = performance.now();\n        const speed = distanceFromLast / (now - lastUpdate);\n        lastUpdate = now;\n        lastPoint = p;\n        return Object.freeze({\n            angle: angleRadian(p, start),\n            distanceFromStart,\n            distanceFromLast,\n            speed,\n            centroid: centroid(p, start),\n            average: {\n                x: totalX / count,\n                y: totalY / count,\n            },\n        });\n    };\n    return update;\n};\n","import { TrackedValueMap, } from '@ixfx/core/trackers';\nimport { ObjectTracker } from '@ixfx/core/trackers';\nimport { length as LineLength } from '../line/length.js';\nimport * as Vectors from '../vector.js';\nimport { Empty as LinesEmpty } from '../line/index.js';\nimport { joinPointsToLines } from '../line/join-points-to-lines.js';\nimport { relation } from './relation.js';\nimport { distance } from './distance.js';\nimport { subtract } from './subtract.js';\nimport { angleRadian } from './angle.js';\nimport { Placeholder as PointsPlaceholder } from './point-type.js';\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link points}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport class PointTracker extends ObjectTracker {\n    initialRelation;\n    markRelation;\n    lastResult;\n    constructor(opts = {}) {\n        super(opts);\n    }\n    /**\n     * Notification that buffer has been knocked down to `sampleLimit`.\n     *\n     * This will reset the `initialRelation`, which will use the new oldest value.\n     */\n    onTrimmed(_reason) {\n        // Force new relation calculations\n        this.initialRelation = undefined;\n    }\n    /**\n     * @ignore\n     */\n    onReset() {\n        super.onReset();\n        this.lastResult = undefined;\n        this.initialRelation = undefined;\n        this.markRelation = undefined;\n    }\n    /**\n     * Adds a PointerEvent along with its\n     * coalesced events, if available.\n     * @param p\n     * @returns\n     */\n    seenEvent(p) {\n        if (`getCoalescedEvents` in p) {\n            const events = p.getCoalescedEvents();\n            const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n            return this.seen(...asPoints);\n        }\n        else {\n            return this.seen({ x: (p).clientX, y: (p).clientY });\n        }\n    }\n    /**\n     * Makes a 'mark' in the tracker, allowing you to compare values\n     * to this point.\n     */\n    mark() {\n        this.markRelation = relation(this.last);\n    }\n    /**\n     * Tracks a point, returning data on its relation to the\n     * initial point and the last received point.\n     *\n     * Use {@link seenEvent} to track a raw `PointerEvent`.\n     *\n     * @param _p Point\n     */\n    computeResults(_p) {\n        const currentLast = this.last;\n        const previousLast = this.values.at(-2);\n        if (this.initialRelation === undefined && this.initial) {\n            // Don't yet have an initial relation function\n            // Use the oldest point in the buffer (this.initial)\n            this.initialRelation = relation(this.initial);\n        }\n        else if (this.initialRelation === undefined) {\n            // Don't have an initial relation, but also don't have an initial point :()\n            throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n        }\n        // Make a new relator based on previous point\n        const lastRelation = previousLast === undefined ? relation(currentLast) : relation(previousLast);\n        // Compute relation from initial point to latest\n        const initialRel = this.initialRelation(currentLast);\n        const markRel = (this.markRelation !== undefined) ? this.markRelation(currentLast) : undefined;\n        const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n        // Compute relation from current point to the previous\n        const lastRel = {\n            ...lastRelation(currentLast),\n            speed,\n        };\n        const r = {\n            fromInitial: initialRel,\n            fromLast: lastRel,\n            fromMark: markRel,\n            values: [...this.values],\n        };\n        this.lastResult = r;\n        return r;\n    }\n    /**\n     * Returns a polyline representation of stored points.\n     * Returns an empty array if points were not saved, or there's only one.\n     */\n    get line() {\n        if (this.values.length === 1)\n            return [];\n        return joinPointsToLines(...this.values);\n    }\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a polar coordinate\n     */\n    get vectorPolar() {\n        return Vectors.fromLinePolar(this.lineStartEnd);\n    }\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a Cartesian coordinate\n     */\n    get vectorCartesian() {\n        return Vectors.fromLineCartesian(this.lineStartEnd);\n    }\n    /**\n     * Returns a line from initial point to last point.\n     *\n     * If there are less than two points, Lines.Empty is returned\n     */\n    get lineStartEnd() {\n        const initial = this.initial;\n        if (this.values.length < 2 || !initial)\n            return LinesEmpty;\n        return {\n            a: initial,\n            b: this.last,\n        };\n    }\n    /**\n     * Returns distance from latest point to initial point.\n     * If there are less than two points, zero is returned.\n     *\n     * This is the direct distance from initial to last,\n     * not the accumulated length.\n     * @returns Distance\n     */\n    distanceFromStart() {\n        const initial = this.initial;\n        return this.values.length >= 2 && initial !== undefined ? distance(initial, this.last) : 0;\n    }\n    /**\n     * Difference between last point and the initial point, calculated\n     * as a simple subtraction of x,y & z.\n     *\n     * `Points.Placeholder` is returned if there's only one point so far.\n     */\n    difference() {\n        const initial = this.initial;\n        return this.values.length >= 2 && initial !== undefined ? subtract(this.last, initial) : PointsPlaceholder;\n    }\n    /**\n     * Returns angle (in radians) from latest point to the initial point\n     * If there are less than two points, undefined is return.\n     * @returns Angle in radians\n     */\n    angleFromStart() {\n        const initial = this.initial;\n        if (initial !== undefined && this.values.length > 2) {\n            return angleRadian(initial, this.last);\n        }\n    }\n    /**\n     * Returns the total length of accumulated points.\n     * Returns 0 if points were not saved, or there's only one\n     */\n    get length() {\n        if (this.values.length === 1)\n            return 0;\n        const l = this.line;\n        return LineLength(l);\n    }\n    /**\n   * Returns the last x coord\n   */\n    get x() {\n        return this.last.x;\n    }\n    /**\n     * Returns the last y coord\n     */\n    get y() {\n        return this.last.y;\n    }\n    /**\n     * Returns the last z coord (or _undefined_ if not available)\n     */\n    get z() {\n        return this.last.z;\n    }\n}\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class PointsTracker extends TrackedValueMap {\n    constructor(opts = {}) {\n        super((key, start) => {\n            if (start === undefined)\n                throw new Error(`Requires start point`);\n            const p = new PointTracker({\n                ...opts,\n                id: key,\n            });\n            p.seen(start);\n            return p;\n        });\n    }\n    /**\n     * Track a PointerEvent\n     * @param event\n     */\n    seenEvent(event) {\n        if (`getCoalescedEvents` in event) {\n            const events = event.getCoalescedEvents();\n            const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n            return Promise.all(seens);\n        }\n        else {\n            return Promise.all([super.seen(event.pointerId.toString(), event)]);\n        }\n    }\n}\n/**\n * Track several named points over time, eg a TensorFlow body pose point.\n * Call `seen()` to track a point. Mutable. If you want to compare\n * a single coordinate with a reference coordinate, {@link point} may be a better choice.\n *\n * See also:\n * * {@link Geometry.Points.relation}: Compute relation info between two points\n * * {@link Trackers.point}: Track relation between points over time\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * Basic usage\n * ```js\n * const pt = trackPoints();\n *\n * // Track a point under a given id\n * document.addEventListener(`pointermove`, e => {\n *  const info = await pt.seen(e.pointerId, { x: e.x, y: e.y });\n *  // Yields some info on relation of the point to initial value\n * });\n * ```\n *\n * Do something with last values for all points\n * ```js\n * const c = Points.centroid(...Array.from(pt.last()));\n * ```\n *\n * More functions...\n * ```js\n * pt.size;       // How many named points are being tracked\n * pt.delete(id); // Delete named point\n * pt.reset();    // Clear data\n * ```\n *\n * Accessing by id:\n *\n * ```js\n * pt.get(id);  // Get named point (or _undefined_)\n * pt.has(id);  // Returns true if id exists\n * ```\n *\n * Iterating over data\n *\n * ```js\n * pt.trackedByAge(); // Iterates over tracked points, sorted by age (oldest first)\n * pt.tracked(); // Tracked values\n * pt.ids();     // Iterator over ids\n *\n * // Last received value for each named point\n * pt.last();\n *\n * pt.initialValues(); // Iterator over initial values for each point\n * ```\n *\n * You can work with 'most recently updated' points:\n *\n * ```js\n * // Iterates over points, sorted by age (oldest first)\n * pt.valuesByAge();\n * ```\n *\n * Options:\n * * `id`: Id of this tracker. Optional\n * * `sampleLimit`: How many samples to store\n * * `storeIntermediate`: If _true_, all points are stored internally\n * * `resetAfterSamples`: If set above 0, it will automatically reset after the given number of samples have been seen\n * @param options\n * @returns\n */\nexport const trackPoints = (options = {}) => new PointsTracker(options);\n/**\n * Track a single point. Use {@link trackPoints} to track several points.\n * @param opts\n * @returns\n */\nexport const track = (opts = {}) => new PointTracker(opts);\n","import { isPoint3d } from \"./guard.js\";\nimport { subtract } from \"./subtract.js\";\n/**\n * Computes the progress between two waypoints, given `position`.\n *\n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns\n */\nexport const progressBetween = (position, waypointA, waypointB) => {\n    // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n    // from -> current\n    const a = subtract(position, waypointA);\n    // from -> to\n    const b = subtract(waypointB, waypointA);\n    return isPoint3d(a) && isPoint3d(b) ? ((a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};\n","/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin, distance, angle) => {\n    const x = Math.cos(angle) * distance + origin.x;\n    const y = Math.sin(angle) * distance + origin.y;\n    return { x, y };\n};\n","import { quantiseEvery as quantiseEveryNumber } from '@ixfx/numbers';\nimport { guard, isPoint3d } from './guard.js';\n/**\n * Quantises a point.\n * @param pt\n * @param snap\n * @param middleRoundsUp\n * @returns\n */\nexport function quantiseEvery(pt, snap, middleRoundsUp = true) {\n    guard(pt, `pt`);\n    guard(snap, `snap`);\n    if (isPoint3d(pt)) {\n        if (!isPoint3d(snap))\n            throw new TypeError(`Param 'snap' is missing 'z' field`);\n        return Object.freeze({\n            x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n            y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n            z: quantiseEveryNumber(pt.z, snap.z, middleRoundsUp)\n        });\n    }\n    return Object.freeze({\n        x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n        y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n    });\n}\n","import {} from '@ixfx/random';\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando) => {\n    if (rando === undefined)\n        rando = Math.random;\n    return Object.freeze({\n        x: rando(),\n        y: rando(),\n    });\n};\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random3d = (rando) => {\n    if (rando === undefined)\n        rando = Math.random;\n    return Object.freeze({\n        x: rando(),\n        y: rando(),\n        z: rando()\n    });\n};\n","/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (pts, fn, initial) => {\n    if (initial === undefined)\n        initial = { x: 0, y: 0 };\n    let accumulator = initial;\n    for (const p of pts) {\n        accumulator = fn(p, accumulator);\n    }\n    ;\n    return accumulator;\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\nimport { guard } from \"./guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../polar/index.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../polar/index.js\";\nexport function rotate(pt, amountRadian, origin) {\n    if (origin === undefined)\n        origin = { x: 0, y: 0 };\n    guard(origin, `origin`);\n    throwNumberTest(amountRadian, ``, `amountRadian`);\n    const arrayInput = Array.isArray(pt);\n    // no-op\n    if (amountRadian === 0)\n        return pt;\n    if (!arrayInput) {\n        pt = [pt];\n    }\n    const ptAr = pt;\n    for (const [index, p] of ptAr.entries())\n        guard(p, `pt[${index}]`);\n    const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n    const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n    const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n    return arrayInput ? asCartesisan : asCartesisan[0];\n}\n","//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (v, amountRadian) => {\n    const mat = [\n        [Math.cos(amountRadian), -Math.sin(amountRadian)],\n        [Math.sin(amountRadian), Math.cos(amountRadian)],\n    ];\n    const result = [];\n    for (const [index, element] of v.entries()) {\n        result[index] = [\n            mat[0][0] * element[0] + mat[0][1] * element[1],\n            mat[1][0] * element[0] + mat[1][1] * element[1],\n        ];\n    }\n    return result;\n};\n","import { round as roundNumber } from '@ixfx/numbers';\nimport { getPointParameter } from './get-point-parameter.js';\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX\n * @param yOrDigits\n * @param digits\n * @returns\n */\nexport const round = (ptOrX, yOrDigits, digits) => {\n    const pt = getPointParameter(ptOrX, yOrDigits);\n    digits = digits ?? yOrDigits;\n    digits = digits ?? 2;\n    return Object.freeze({\n        ...pt,\n        x: roundNumber(digits, pt.x),\n        y: roundNumber(digits, pt.y)\n    });\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns true if two points are within a specified range on both axes.\n *\n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (a, b, maxRange) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    if (typeof maxRange === `number`) {\n        throwNumberTest(maxRange, `positive`, `maxRange`);\n        maxRange = { x: maxRange, y: maxRange };\n    }\n    else {\n        guard(maxRange, `maxRange`);\n    }\n    const x = Math.abs(b.x - a.x);\n    const y = Math.abs(b.y - a.y);\n    return x <= maxRange.x && y <= maxRange.y;\n};\n","import { wrap as wrapNumber } from '@ixfx/numbers';\nimport { guard } from './guard.js';\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (pt, ptMax, ptMin) => {\n    if (ptMax === undefined)\n        ptMax = { x: 1, y: 1 };\n    if (ptMin === undefined)\n        ptMin = { x: 0, y: 0 };\n    // ✔️ Unit tested\n    guard(pt, `pt`);\n    guard(ptMax, `ptMax`);\n    guard(ptMin, `ptMin`);\n    return Object.freeze({\n        x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n        y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n    });\n};\n","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\n","import { multiply as PointsMultiply } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport const multiply = (line, point) => (Object.freeze({\n    ...line,\n    a: PointsMultiply(line.a, point),\n    b: PointsMultiply(line.b, point)\n}));\n","import { length } from \"./length.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line\n * @param pt\n */\nexport const relativePosition = (line, pt) => {\n    const fromStart = PointsDistance(line.a, pt);\n    const total = length(line);\n    return fromStart / total;\n};\n","import { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./interpolate.js\";\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n *\n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n *\n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n *\n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns\n */\nexport const rotate = (line, amountRadian, origin) => {\n    if (amountRadian === undefined || amountRadian === 0)\n        return line;\n    if (origin === undefined)\n        origin = 0.5;\n    if (typeof origin === `number`) {\n        origin = interpolate(origin, line.a, line.b);\n    }\n    return Object.freeze({\n        ...line,\n        a: PointRotate(line.a, amountRadian, origin),\n        b: PointRotate(line.b, amountRadian, origin)\n    });\n};\n","import { subtract as PointsSubtract } from \"../point/subtract.js\";\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport const subtract = (line, point) => Object.freeze({\n    ...line,\n    a: PointsSubtract(line.a, point),\n    b: PointsSubtract(line.b, point)\n});\n","import { sum as PointsSum } from '../point/sum.js';\n/**\n * Adds both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport const sum = (line, point) => Object.freeze({\n    ...line,\n    a: PointsSum(line.a, point),\n    b: PointsSum(line.b, point)\n});\n","import { guard, isLine } from \"./guard.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function toString(a, b) {\n    if (isLine(a)) {\n        guard(a, `a`);\n        b = a.b;\n        a = a.a;\n    }\n    else if (b === undefined)\n        throw new Error(`Expect second point if first is a point`);\n    return PointsToString(a) + `-` + PointsToString(b);\n}\n","//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/normalise-by-rect.js';\nimport { minFast } from '@ixfx/numbers';\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isLine } from './guard.js';\nimport { length } from './length.js';\nimport { interpolate } from './interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/guard.js';\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\nexport const Empty = Object.freeze({\n    a: Object.freeze({ x: 0, y: 0 }),\n    b: Object.freeze({ x: 0, y: 0 })\n});\nexport const Placeholder = Object.freeze({\n    a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n    b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l\n * @returns\n */\nexport const isEmpty = (l) => PointIsEmpty(l.a) && PointIsEmpty(l.b);\nexport const isPlaceholder = (l) => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n/**\n * Applies `fn` to both start and end points.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n *\n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n *\n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns\n */\nexport const apply = (line, fn) => Object.freeze({\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n});\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint\n * @param b\n * @returns\n */\nexport const angleRadian = (lineOrPoint, b) => {\n    let a;\n    if (isLine(lineOrPoint)) {\n        a = lineOrPoint.a;\n        b = lineOrPoint.b;\n    }\n    else {\n        a = lineOrPoint;\n        if (b === undefined)\n            throw new Error(`b point must be provided`);\n    }\n    return Math.atan2(b.y - a.y, b.x - a.x);\n};\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line\n * @param width\n * @param height\n * @returns\n */\nexport const normaliseByRect = (line, width, height) => Object.freeze({\n    ...line,\n    a: PointsNormaliseByRect(line.a, width, height),\n    b: PointsNormaliseByRect(line.b, width, height)\n});\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange\n * @returns True if point is within range\n */\nexport const withinRange = (line, point, maxRange) => {\n    const calculatedDistance = distance(line, point);\n    return calculatedDistance <= maxRange;\n};\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n *\n * @example\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns\n */\nexport const slope = (lineOrPoint, b) => {\n    let a;\n    if (isLine(lineOrPoint)) {\n        a = lineOrPoint.a;\n        b = lineOrPoint.b;\n    }\n    else {\n        a = lineOrPoint;\n        if (b === undefined)\n            throw new Error(`b parameter required`);\n    }\n    if (b === undefined) {\n        throw new TypeError(`Second point missing`);\n    }\n    else {\n        return (b.y - a.y) / (b.x - a.x);\n    }\n};\n/**\n * Scales a line from its midpoint\n *\n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor\n */\nexport const scaleFromMidpoint = (line, factor) => {\n    const a = interpolate(factor / 2, line);\n    const b = interpolate(0.5 + factor / 2, line);\n    return { a, b };\n};\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line, x) => {\n    const y = line.a.y + (x - line.a.x) * slope(line);\n    return Object.freeze({ x: x, y });\n};\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line, distance) => {\n    const calculatedLength = length(line);\n    return Object.freeze({\n        ...line,\n        a: line.a,\n        b: Object.freeze({\n            x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n            y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n        })\n    });\n};\n/**\n * Yields every integer point along `line`.\n *\n * @example Basic usage\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n *\n * Some precision is lost as start and end\n * point is also returned as an integer.\n *\n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\nexport function* pointsOf(line) {\n    // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n    const { a, b } = line;\n    let x0 = Math.floor(a.x);\n    let y0 = Math.floor(a.y);\n    const x1 = Math.floor(b.x);\n    const y1 = Math.floor(b.y);\n    const dx = Math.abs(x1 - x0);\n    const dy = -Math.abs(y1 - y0);\n    const sx = x0 < x1 ? 1 : -1;\n    const sy = y0 < y1 ? 1 : -1;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    let err = dx + dy;\n    while (true) {\n        yield { x: x0, y: y0 };\n        if (x0 === x1 && y0 === y1)\n            break;\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const e2 = 2 * err;\n        if (e2 >= dy) {\n            err += dy;\n            x0 += sx;\n        }\n        if (e2 <= dx) {\n            err += dx;\n            y0 += sy;\n        }\n    }\n}\n/**\n * Returns the distance of `point` to the\n * nearest point on `line`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line, point) => {\n    if (Array.isArray(line)) {\n        const distances = line.map(l => distanceSingleLine(l, point));\n        return minFast(distances);\n    }\n    else {\n        return distanceSingleLine(line, point);\n    }\n};\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n *\n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a, b) => {\n    if (isLine(a)) {\n        return [a.a.x, a.a.y, a.b.x, a.b.y];\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        return [a.x, a.y, b.x, b.y];\n    }\n    else {\n        throw new Error(`Expected single line parameter, or a and b points`);\n    }\n};\n/**\n * Yields all the points of all the lines.\n *\n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines\n */\nexport function* asPoints(lines) {\n    for (const l of lines) {\n        yield l.a;\n        yield l.b;\n    }\n}\n/**\n * Returns an SVG description of line\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const toSvgString = (a, b) => [`M${a.x} ${a.y} L ${b.x} ${b.y}`];\n","import { length } from \"./length.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport { parallel, perpendicularPoint } from \"./angles.js\";\nimport { midpoint } from \"./midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./bbox.js\";\nimport { relativePosition } from \"./relative-position.js\";\nimport { sum } from \"./sum.js\";\nimport { divide } from \"./divide.js\";\nimport { rotate } from \"./rotate.js\";\nimport { nearest } from \"./nearest.js\";\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isEqual } from \"./is-equal.js\";\nimport { multiply } from \"./multiply.js\";\nimport { subtract } from \"./subtract.js\";\nimport { toString } from \"./to-string.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n *\n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n *\n * // Now we can use it...\n * l.length();\n *\n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line\n * @returns\n */\nexport const toPath = (line) => {\n    const { a, b } = line;\n    return Object.freeze({\n        ...line,\n        length: () => length(a, b),\n        interpolate: (amount) => interpolate(amount, a, b),\n        relativePosition: (point) => relativePosition(line, point),\n        bbox: () => bbox(line),\n        toString: () => toString(a, b),\n        toFlatArray: () => toFlatArray(a, b),\n        toSvgString: () => toSvgString(a, b),\n        toPoints: () => [a, b],\n        rotate: (amountRadian, origin) => toPath(rotate(line, amountRadian, origin)),\n        nearest: (point) => nearest(line, point),\n        sum: (point) => toPath(sum(line, point)),\n        divide: (point) => toPath(divide(line, point)),\n        multiply: (point) => toPath(multiply(line, point)),\n        subtract: (point) => toPath(subtract(line, point)),\n        midpoint: () => midpoint(a, b),\n        distanceToPoint: (point) => distanceSingleLine(line, point),\n        parallel: (distance) => parallel(line, distance),\n        perpendicularPoint: (distance, amount) => perpendicularPoint(line, distance, amount),\n        slope: () => slope(line),\n        withinRange: (point, maxRange) => withinRange(line, point, maxRange),\n        isEqual: (otherLine) => isEqual(line, otherLine),\n        apply: (fn) => toPath(apply(line, fn)),\n        kind: `line`\n    });\n};\n","import { joinPointsToLines } from './line/join-points-to-lines.js';\nimport { toPath } from './line/to-path.js';\nimport { distance as PointsDistance } from \"./point/distance.js\";\nimport { sortByNumericProperty } from \"@ixfx/arrays\";\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints\n * @param opts\n * @returns\n */\nexport const fromPoints = (waypoints, opts = {}) => {\n    const lines = joinPointsToLines(...waypoints);\n    return init(lines.map((l) => toPath(l)), opts);\n};\n/**\n * Initialise\n *\n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths\n * @param opts\n * @returns\n */\nexport const init = (paths, opts = {}) => {\n    //const enforceOrder = opts.enforceOrder ?? true;\n    const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n    const checkUnordered = (pt) => {\n        const results = paths.map((p, index) => {\n            const nearest = p.nearest(pt);\n            const distance = PointsDistance(pt, nearest);\n            // Relative position of nearest point on this path segment\n            const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);\n            ;\n            return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n        });\n        const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n        const sorted = sortByNumericProperty(filtered, `distance`);\n        // Assign ranks\n        for (let rank = 0; rank < sorted.length; rank++) {\n            sorted[rank].rank = rank;\n        }\n        return sorted;\n    };\n    // const checkUnordered = (p:Point) => {\n    //   // Calculate progress of pointer between all the waypoint lines\n    //   const progresses = lines.map((line, index) => (\n    //     {\n    //       index,\n    //       score: Points.progressBetween(p, line.a, line.b)\n    //     }));\n    //   // Sort by closest\n    //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n    // };\n    return checkUnordered;\n};\n","import { project as PointsProject } from \"../point/project.js\";\n// import { guard as PointGuard } from \"../point/Guard.js\";\n// import { throwNumberTest } from \"@ixfx/guards\";\n// import { piPi } from \"../pi.js\";\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\nexport const Empty = Object.freeze({\n    a: { x: 0, y: 0 },\n    b: { x: 0, y: 0 },\n    c: { x: 0, y: 0 },\n});\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\nexport const Placeholder = Object.freeze({\n    a: { x: Number.NaN, y: Number.NaN },\n    b: { x: Number.NaN, y: Number.NaN },\n    c: { x: Number.NaN, y: Number.NaN },\n});\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (origin, length = 10, angleRadian = Math.PI / 2) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const a = PointsProject(origin, length, Math.PI - -angleRadian / 2);\n    const c = PointsProject(origin, length, Math.PI - angleRadian / 2);\n    return { a, b: origin, c };\n};\n","import {} from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (rect, origin) => {\n    const r = getRectPositioned(rect, origin);\n    return [\n        { x: r.x, y: r.y },\n        { x: r.x + r.width, y: r.y },\n        { x: r.x + r.width, y: r.y + r.height },\n        { x: r.x, y: r.y + r.height },\n    ];\n};\n","import { guardDim } from \"./guard.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (origin, width, height) => {\n    guardDim(width, `width`);\n    guardDim(height, `height`);\n    PointsGuard(origin, `origin`);\n    return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { equilateralFromVertex } from \"../triangle/create.js\";\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { rotate as PointsRotate } from \"../point/rotate.js\";\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (origin, from, opts = {}) => {\n    const tailLength = opts.tailLength ?? 10;\n    const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n    const angleRadian = opts.angleRadian ?? 0;\n    const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n    const triAngle = Math.PI / 2;\n    let tri;\n    let tailPoints;\n    if (from === `tip`) {\n        tri = equilateralFromVertex(origin, arrowSize, triAngle);\n        tailPoints = RectsCorners(RectsFromTopLeft({ x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 }, tailLength, tailThickness));\n    }\n    else if (from === `middle`) {\n        const midX = tailLength + arrowSize / 2;\n        const midY = tailThickness / 2;\n        tri = equilateralFromVertex({\n            x: origin.x + arrowSize * 1.2,\n            y: origin.y,\n        }, arrowSize, triAngle);\n        tailPoints = RectsCorners(RectsFromTopLeft({ x: origin.x - midX, y: origin.y - midY }, tailLength + arrowSize, tailThickness));\n    }\n    else {\n        //const midY = origin.y - tailThickness/2;\n        tailPoints = RectsCorners(RectsFromTopLeft({ x: origin.x, y: origin.y - tailThickness / 2 }, tailLength, tailThickness));\n        tri = equilateralFromVertex({ x: origin.x + tailLength + arrowSize * 0.7, y: origin.y }, arrowSize, triAngle);\n    }\n    const arrow = PointsRotate([\n        tailPoints[0],\n        tailPoints[1],\n        tri.a,\n        tri.b,\n        tri.c,\n        tailPoints[2],\n        tailPoints[3],\n    ], angleRadian, origin);\n    return arrow;\n};\n","import { isCirclePositioned } from \"./guard.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/index.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n *\n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns\n */\nexport const randomPoint = (within, opts = {}) => {\n    const offset = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n    const strategy = opts.strategy ?? `uniform`;\n    const margin = opts.margin ?? 0;\n    const radius = within.radius - margin;\n    const rand = opts.randomSource ?? Math.random;\n    switch (strategy) {\n        case `naive`: {\n            return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n        }\n        case `uniform`: {\n            return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n        }\n        default: {\n            throw new Error(`Unknown strategy '${strategy}'. Expects 'uniform' or 'naive'`);\n        }\n    }\n};\n","import {} from '@ixfx/random';\nimport { sum as PointsSum } from '../point/sum.js';\nimport { isPositioned } from './guard.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando) => {\n    if (rando === undefined)\n        rando = Math.random;\n    return Object.freeze({\n        x: rando(),\n        y: rando(),\n        width: rando(),\n        height: rando(),\n    });\n};\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (within, options = {}) => {\n    // TODO: Does not implement uniform distribution\n    // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n    const rand = options.randomSource ?? Math.random;\n    const margin = options.margin ?? { x: 0, y: 0 };\n    const x = rand() * (within.width - margin.x - margin.x);\n    const y = rand() * (within.height - margin.y - margin.y);\n    const pos = { x: x + margin.x, y: y + margin.y };\n    return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};\n","import { isCirclePositioned } from \"./guard.js\";\n/**\n * Returns the center of a circle\n *\n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circle = { radius: 5, x: 10, y: 10};\n *\n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n *\n * It's a trivial function, but can make for more understandable code\n * @param circle\n * @returns Center of circle\n */\nexport const center = (circle) => {\n    return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};\n","import { isPoint, guard as PointsGuard, isPlaceholder as PointsIsPlaceholder, isEmpty as PointsIsEmpty } from '../point/guard.js';\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t, name = `t`) => {\n    if (t === undefined)\n        throw new Error(`{$name} undefined`);\n    PointsGuard(t.a, name + `.a`);\n    PointsGuard(t.b, name + `.b`);\n    PointsGuard(t.c, name + `.c`);\n};\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p) => {\n    if (p === undefined)\n        return false;\n    const tri = p;\n    if (!isPoint(tri.a))\n        return false;\n    if (!isPoint(tri.b))\n        return false;\n    if (!isPoint(tri.c))\n        return false;\n    return true;\n};\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t) => PointsIsEmpty(t.a) && PointsIsEmpty(t.b) && PointsIsEmpty(t.c);\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t) => PointsIsPlaceholder(t.a) &&\n    PointsIsPlaceholder(t.b) &&\n    PointsIsPlaceholder(t.c);\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => PointsIsEqual(a.a, b.a) &&\n    PointsIsEqual(a.b, b.b) &&\n    PointsIsEqual(a.c, b.c);\n","import { guard } from \"./guard.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t) => {\n    guard(t);\n    const total = PointsReduce([t.a, t.b, t.c], (p, accumulator) => ({\n        x: p.x + accumulator.x,\n        y: p.y + accumulator.y,\n    }));\n    const div = {\n        x: total.x / 3,\n        y: total.y / 3,\n    };\n    return div;\n};\n","import { isCircle, isCirclePositioned } from \"../circle/guard.js\";\nimport { isRect, isRectPositioned } from \"../rect/guard.js\";\nimport { randomPoint as circleRandomPoint } from '../circle/random.js';\nimport { randomPoint as rectRandomPoint } from '../rect/random.js';\nimport { center as circleCenter } from '../circle/center.js';\nimport { isTriangle } from \"../triangle/guard.js\";\nimport { centroid as triangleCentroid } from \"../triangle/centroid.js\";\nimport { center as rectCenter } from '../rect/center.js';\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link CirclePositioned} or {@link RectPositioned}\n * @param shape\n * @param opts\n * @returns\n */\nexport const randomPoint = (shape, opts = {}) => {\n    if (isCirclePositioned(shape)) {\n        return circleRandomPoint(shape, opts);\n    }\n    else if (isRectPositioned(shape)) {\n        return rectRandomPoint(shape, opts);\n    }\n    throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n// }\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (shape) => {\n    if (shape === undefined) {\n        return Object.freeze({ x: 0.5, y: 0.5 });\n    }\n    else if (isRect(shape)) {\n        return rectCenter(shape);\n    }\n    else if (isTriangle(shape)) {\n        return triangleCentroid(shape);\n    }\n    else if (isCircle(shape)) {\n        return circleCenter(shape);\n    }\n    else {\n        throw new Error(`Unknown shape: ${JSON.stringify(shape)}`);\n    }\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { distanceCenter } from \"./distance-center.js\";\nimport { isCircle } from \"./guard.js\";\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n *\n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n *\n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a, b, c) => {\n    const d = distanceCenter(a, b);\n    if (isCircle(b)) {\n        return (d < Math.abs(a.radius - b.radius));\n    }\n    else if (isPoint(b)) {\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (c === undefined) {\n            return d <= a.radius;\n        }\n        else {\n            // Defining a circle\n            return (d < Math.abs(a.radius - c));\n        }\n    }\n    else\n        throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import * as Intersects from '../intersects.js';\nimport { isContainedBy } from \"./is-contained-by.js\";\nimport { isCircle } from \"./guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\nimport { isPoint } from '../point/guard.js';\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n *\n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a, b, c) => {\n    if (PointsIsEqual(a, b))\n        return true;\n    if (isContainedBy(a, b, c))\n        return true;\n    if (isCircle(b)) {\n        return Intersects.circleCircle(a, b);\n    }\n    else if (isRectPositioned(b)) {\n        return Intersects.circleRect(a, b);\n    }\n    else if (isPoint(b) && c !== undefined) {\n        return Intersects.circleCircle(a, { ...b, radius: c });\n    }\n    return false;\n};\n","import { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/intersecting.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link CirclePositioned} or {@link RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (a, b) => {\n    if (isCirclePositioned(a)) {\n        return CirclesIsIntersecting(a, b);\n    }\n    else if (isRectPositioned(a)) {\n        return RectsIsIntersecting(a, b);\n    }\n    throw new Error(`a or b are unknown shapes. a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\nimport { toCartesian } from \"../polar/conversions.js\";\nimport { Empty as PointEmpty } from \"../point/empty.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (outerRadius, points = 5, innerRadius, origin = PointEmpty, opts) => {\n    throwIntegerTest(points, `positive`, `points`);\n    const angle = (Math.PI * 2) / points;\n    const angleHalf = angle / 2;\n    const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n    if (innerRadius === undefined)\n        innerRadius = outerRadius / 2;\n    let a = initialAngle;\n    const pts = [];\n    for (let index = 0; index < points; index++) {\n        const peak = toCartesian(outerRadius, a, origin);\n        const left = toCartesian(innerRadius, a - angleHalf, origin);\n        const right = toCartesian(innerRadius, a + angleHalf, origin);\n        pts.push(left, peak);\n        if (index + 1 < points)\n            pts.push(right);\n        a += angle;\n    }\n    return pts;\n};\n","export * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';\n","import { sortByNumericProperty } from \"@ixfx/arrays\";\nimport { randomPoint as ShapesRandomPoint } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/intersecting.js\";\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles, container, opts = {}) => {\n    if (!Array.isArray(circles))\n        throw new Error(`Parameter 'circles' is not an array`);\n    const attempts = opts.attempts ?? 2000;\n    const sorted = sortByNumericProperty(circles, `radius`);\n    const positionedCircles = [];\n    const willHit = (b, radius) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n    while (sorted.length > 0) {\n        //eslint-disable-next-line functional/immutable-data\n        const circle = sorted.pop();\n        if (!circle)\n            break;\n        const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n        //eslint-disable-next-line functional/no-let\n        for (let index = 0; index < attempts; index++) {\n            const position = ShapesRandomPoint(container, randomPointOpts);\n            if (!willHit(position, circle.radius)) {\n                //eslint-disable-next-line functional/immutable-data\n                positionedCircles.push(Object.freeze({ ...circle, ...position }));\n                break;\n            }\n        }\n    }\n    return positionedCircles;\n};\n","export * as CirclePacking from './circle-packing.js';\n","import { guard } from \"./guard.js\";\n/**\n * Returns the area of `circle`.\n * @param circle\n * @returns\n */\nexport const area = (circle) => {\n    guard(circle);\n    return Math.PI * circle.radius * circle.radius;\n};\n","import {} from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { guardDim } from \"./guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (origin, width, height) => {\n    PointsGuard(origin, `origin`);\n    guardDim(width, `width`);\n    guardDim(height, `height`);\n    const halfW = width / 2;\n    const halfH = height / 2;\n    return {\n        x: origin.x - halfW,\n        y: origin.y - halfH,\n        width: width,\n        height: height,\n    };\n};\n","import { isCirclePositioned } from \"./guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/from-center.js';\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns\n */\nexport const bbox = (circle) => {\n    return isCirclePositioned(circle) ?\n        RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n        { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n *\n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport function* exteriorIntegerPoints(circle) {\n    const { x, y, radius } = circle;\n    let xx = radius;\n    let yy = 0;\n    let radiusError = 1 - x;\n    while (xx >= yy) {\n        yield { x: xx + x, y: yy + y };\n        yield { x: yy + x, y: xx + y };\n        yield { x: -xx + x, y: yy + y };\n        yield { x: -yy + x, y: xx + y };\n        yield { x: -xx + x, y: -yy + y };\n        yield { x: -yy + x, y: -xx + y };\n        yield { x: xx + x, y: -yy + y };\n        yield { x: yy + x, y: -xx + y };\n        yy++;\n        if (radiusError < 0) {\n            radiusError += 2 * yy + 1;\n        }\n        else {\n            xx--;\n            radiusError += 2 * (yy - xx + 1);\n        }\n    }\n}\n","import { distance } from \"../point/distance.js\";\n/**\n * Returns all integer points contained within `circle`.\n *\n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport function* interiorIntegerPoints(circle) {\n    const xMin = circle.x - circle.radius;\n    const xMax = circle.x + circle.radius;\n    const yMin = circle.y - circle.radius;\n    const yMax = circle.y + circle.radius;\n    for (let x = xMin; x < xMax; x++) {\n        for (let y = yMin; y < yMax; y++) {\n            const r = Math.abs(distance(circle, x, y));\n            if (r <= circle.radius)\n                yield { x, y };\n        }\n    }\n}\n","import { guard, isCirclePositioned } from \"./guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\nconst piPi = Math.PI * 2;\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n *\n * ```js\n * import { Circles } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n *\n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle, point) => {\n    const n = (a) => {\n        const l = Math.sqrt(Math.pow(point.x - a.x, 2) + Math.pow(point.y - a.y, 2));\n        const x = a.x + (a.radius * ((point.x - a.x) / l));\n        const y = a.y + (a.radius * ((point.y - a.y) / l));\n        return { x, y };\n    };\n    if (Array.isArray(circle)) {\n        const pts = circle.map(l => n(l));\n        const dists = pts.map(p => PointsDistance(p, point));\n        return Object.freeze(pts[minIndex(...dists)]);\n    }\n    else {\n        return Object.freeze(n(circle));\n    }\n};\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n *\n * // Circle without position\n * const circleA = { radius: 5 };\n *\n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n *\n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle, angleRadian, origin) => {\n    if (origin === undefined) {\n        origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n    }\n    return {\n        x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n        y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n    };\n};\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle\n * @returns\n */\nexport const circumference = (circle) => {\n    guard(circle);\n    return piPi * circle.radius;\n};\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle\n * @returns\n */\nexport const length = (circle) => circumference(circle);\n","import { pointOnPerimeter } from \"./perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circle = { radius: 100, x: 100, y: 100 };\n *\n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle\n * @param t Position, 0-1\n * @returns\n */\nexport const interpolate = (circle, t) => pointOnPerimeter(circle, t * piPi);\n","import { isCirclePositioned } from \"./guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/multiply.js';\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n *\n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n *\n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a, value) {\n    if (isCirclePositioned(a)) {\n        const pt = PointsMultiplyScalar(a, value);\n        return Object.freeze({\n            ...a,\n            ...pt,\n            radius: a.radius * value\n        });\n    }\n    else {\n        return Object.freeze({\n            ...a,\n            radius: a.radius * value\n        });\n    }\n}\n","import { isCircle, isCirclePositioned } from \"./guard.js\";\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns\n */\nexport const toSvg = (a, sweep, origin) => {\n    if (isCircle(a)) {\n        if (origin !== undefined) {\n            return toSvgFull(a.radius, origin, sweep);\n        }\n        if (isCirclePositioned(a)) {\n            return toSvgFull(a.radius, a, sweep);\n        }\n        else\n            throw new Error(`origin parameter needed for non-positioned circle`);\n    }\n    else {\n        if (origin === undefined) {\n            throw new Error(`origin parameter needed`);\n        }\n        else {\n            return toSvgFull(a, origin, sweep);\n        }\n    }\n};\nconst toSvgFull = (radius, origin, sweep) => {\n    // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n    const { x, y } = origin;\n    const s = sweep ? `1` : `0`;\n    return `\n    M ${x}, ${y}\n    m -${radius}, 0\n    a ${radius},${radius} 0 1,${s} ${radius * 2},0\n    a ${radius},${radius} 0 1,${s} -${radius * 2},0\n  `.split(`\\n`);\n};\n","import { bbox } from \"./bbox.js\";\nimport { guard } from \"./guard.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport { nearest } from \"./perimeter.js\";\nimport { toSvg } from \"./svg.js\";\nimport { circumference } from \"./perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle) => {\n    guard(circle);\n    return {\n        ...circle,\n        nearest: (point) => nearest(circle, point),\n        /**\n         * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n         * @param {t} Relative (0.0-1.0) point\n         * @returns {Point} X,y\n         */\n        interpolate: (t) => interpolate(circle, t),\n        bbox: () => bbox(circle),\n        length: () => circumference(circle),\n        toSvgString: (sweep = true) => toSvg(circle, sweep),\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        kind: `circular`\n    };\n};\n","import { isCirclePositioned } from \"./guard.js\";\nimport { getPointParameter } from \"../point/get-point-parameter.js\";\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle\n * @param defaultPositionOrX\n * @param y\n * @returns\n */\nexport const toPositioned = (circle, defaultPositionOrX, y) => {\n    if (isCirclePositioned(circle))\n        return circle;\n    // Returns 0,0 if params are undefined\n    const pt = getPointParameter(defaultPositionOrX, y);\n    return Object.freeze({\n        ...circle,\n        ...pt\n    });\n};\n","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n","import { guard } from \"./guard.js\";\n/**\n * Returns the area of `rect`\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect) => {\n    guard(rect);\n    return rect.height * rect.width;\n};\n","import { guard } from \"./guard.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./guard.js\";\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth\n * @param heightValue\n * @returns\n */\nexport function applyFields(op, rectOrWidth, heightValue) {\n    let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n    let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n    if (width === undefined)\n        throw new Error(`Param 'width' undefined`);\n    if (height === undefined)\n        throw new Error(`Param 'height' undefined`);\n    width = op(width, `width`);\n    height = op(height, `height`);\n    if (typeof rectOrWidth === `object`) {\n        if (isPositioned(rectOrWidth)) {\n            const x = op(rectOrWidth.x, `x`);\n            const y = op(rectOrWidth.y, `y`);\n            return { ...rectOrWidth, width, height, x, y };\n        }\n        else {\n            return {\n                ...rectOrWidth, width, height\n            };\n        }\n    }\n    return { width, height };\n}\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function applyMerge(op, a, b, c) {\n    guard(a, `a`);\n    if (isRect(b)) {\n        // Math op by another rectangle\n        return isRectPositioned(a) ? Object.freeze({\n            ...a,\n            x: op(a.x, b.width),\n            y: op(a.y, b.height),\n            width: op(a.width, b.width),\n            height: op(a.height, b.height),\n        }) : Object.freeze({\n            ...a,\n            width: op(a.width, b.width),\n            height: op(a.height, b.height),\n        });\n    }\n    else {\n        // Math op with a series of values\n        if (typeof b !== `number`) {\n            throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(b)}`);\n        }\n        if (typeof c !== `number`)\n            throw new Error(`Expected third param as height. Got ${JSON.stringify(c)}`);\n        return isRectPositioned(a) ? Object.freeze({\n            ...a,\n            x: op(a.x, b),\n            y: op(a.y, c),\n            width: op(a.width, b),\n            height: op(a.height, c),\n        }) : Object.freeze({\n            ...a,\n            width: op(a.width, b),\n            height: op(a.height, c),\n        });\n    }\n}\nexport function applyScalar(op, rect, parameter) {\n    return isPositioned(rect) ? Object.freeze({\n        ...rect,\n        x: op(rect.x, parameter),\n        y: op(rect.y, parameter),\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    }) : Object.freeze({\n        ...rect,\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    });\n}\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op\n * @param rect\n * @param parameter\n * @returns\n */\nexport function applyDim(op, rect, parameter) {\n    return Object.freeze({\n        ...rect,\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    });\n}\n","/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (rect, card) => {\n    const { x, y, width, height } = rect;\n    switch (card) {\n        case `nw`: {\n            return Object.freeze({ x, y });\n        }\n        case `n`: {\n            return Object.freeze({\n                x: x + width / 2,\n                y,\n            });\n        }\n        case `ne`: {\n            return Object.freeze({\n                x: x + width,\n                y,\n            });\n        }\n        case `sw`: {\n            return Object.freeze({ x, y: y + height });\n        }\n        case `s`: {\n            return Object.freeze({\n                x: x + width / 2,\n                y: y + height,\n            });\n        }\n        case `se`: {\n            return Object.freeze({\n                x: x + width,\n                y: y + height,\n            });\n        }\n        case `w`: {\n            return Object.freeze({ x, y: y + height / 2 });\n        }\n        case `e`: {\n            return Object.freeze({ x: x + width, y: y + height / 2 });\n        }\n        case `center`: {\n            return Object.freeze({\n                x: x + width / 2,\n                y: y + height / 2,\n            });\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown direction: ${card}`);\n        }\n    }\n};\n","import { applyMerge, applyDim, applyScalar } from \"./apply.js\";\nconst divideOp = (a, b) => a / b;\n/**\n * @internal\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function divide(a, b, c) {\n    // @ts-ignore\n    return applyMerge(divideOp, a, b, c);\n}\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(rect, amount) {\n    return applyScalar(divideOp, rect, amount);\n}\nexport function divideDim(rect, amount) {\n    return applyDim(divideOp, rect, amount);\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { guard } from \"./guard.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/join-points-to-lines.js';\nimport { corners } from \"./corners.js\";\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (rect, origin) => {\n    const c = corners(rect, origin);\n    // Connect all the corners, back to first corner again\n    return LinesJoinPointsToLines(...c, c[0]);\n};\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (rect, edge) => {\n    guard(rect);\n    switch (edge) {\n        case `top`: {\n            return isPoint(rect) ? rect.x : 0;\n        }\n        case `bottom`: {\n            return isPoint(rect) ? rect.x : 0;\n        }\n        case `left`: {\n            return isPoint(rect) ? rect.y : 0;\n        }\n        case `right`: {\n            return isPoint(rect) ? rect.x + rect.width : rect.width;\n        }\n    }\n};\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (rect, edge) => {\n    guard(rect);\n    switch (edge) {\n        case `top`: {\n            return (isPoint(rect) ? rect.y : 0);\n        }\n        case `bottom`: {\n            return isPoint(rect) ? rect.y + rect.height : rect.height;\n        }\n        case `left`: {\n            return isPoint(rect) ? rect.y : 0;\n        }\n        case `right`: {\n            return isPoint(rect) ? rect.y : 0;\n        }\n    }\n};\n","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n});\n","/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect\n * @param points\n * @returns\n */\nexport const encompass = (rect, ...points) => {\n    const x = points.map(p => p.x);\n    const y = points.map(p => p.y);\n    let minX = Math.min(...x, rect.x);\n    let minY = Math.min(...y, rect.y);\n    let maxX = Math.max(...x, rect.x + rect.width);\n    let maxY = Math.max(...y, rect.y + rect.height);\n    let rectW = Math.max(rect.width, maxX - minX);\n    let rectH = Math.max(rect.height, maxY - minY);\n    return Object.freeze({\n        ...rect,\n        x: minX,\n        y: minY,\n        width: rectW,\n        height: rectH\n    });\n};\n","/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el) => ({\n    width: el.clientWidth,\n    height: el.clientHeight,\n});\n","/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function fromNumbers(xOrWidth, yOrHeight, width, height) {\n    if (width === undefined || height === undefined) {\n        if (typeof xOrWidth !== `number`)\n            throw new Error(`width is not an number`);\n        if (typeof yOrHeight !== `number`) {\n            throw new TypeError(`height is not an number`);\n        }\n        return Object.freeze({ width: xOrWidth, height: yOrHeight });\n    }\n    if (typeof xOrWidth !== `number`)\n        throw new Error(`x is not an number`);\n    if (typeof yOrHeight !== `number`)\n        throw new Error(`y is not an number`);\n    if (typeof width !== `number`)\n        throw new Error(`width is not an number`);\n    if (typeof height !== `number`)\n        throw new Error(`height is not an number`);\n    return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { isRect, isRectPositioned } from \"./guard.js\";\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport function getRectPositionedParameter(a, b, c, d) {\n    if (typeof a === `number`) {\n        if (typeof b === `number`) {\n            if (typeof c === `number` && typeof d === `number`) {\n                return { x: a, y: b, width: c, height: d };\n            }\n            else if (isRect(c)) {\n                return { x: a, y: b, width: c.width, height: c.height };\n            }\n            else {\n                throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n            }\n        }\n        else {\n            throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n        }\n    }\n    else if (isRectPositioned(a)) {\n        return a;\n    }\n    else if (isRect(a)) {\n        if (typeof b === `number` && typeof c === `number`) {\n            return { width: a.width, height: a.height, x: b, y: c };\n        }\n        else if (isPoint(b)) {\n            return { width: a.width, height: a.height, x: b.x, y: b.y };\n        }\n        else {\n            throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n        }\n    }\n    else if (isPoint(a)) {\n        if (typeof b === `number` && typeof c === `number`) {\n            return { x: a.x, y: a.y, width: b, height: c };\n        }\n        else if (isRect(b)) {\n            return { x: a.x, y: a.y, width: b.width, height: b.height };\n        }\n        else {\n            throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n        }\n    }\n    throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n","import { isPositioned } from \"./guard.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a, b) => {\n    if (a === undefined)\n        throw new Error(`a undefined`);\n    if (b === undefined)\n        throw new Error(`b undefined`);\n    return a.width === b.width && a.height === b.height;\n};\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => {\n    if (isPositioned(a) && isPositioned(b)) {\n        if (!PointsIsEqual(a, b))\n            return false;\n        return a.width === b.width && a.height === b.height;\n    }\n    else if (!isPositioned(a) && !isPositioned(b)) {\n        return a.width === b.width && a.height === b.height;\n    }\n    else {\n        // One param is positioned, the other is not\n        return false;\n    }\n};\n","import { length as LinesLength } from '../line/length.js';\nimport { edges } from './edges.js';\nimport { guardPositioned } from './guard.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect) => {\n    guardPositioned(rect, `rect`);\n    return edges(rect).map((l) => LinesLength(l));\n};\n","import { applyMerge, applyDim, applyScalar } from \"./apply.js\";\nconst multiplyOp = (a, b) => a * b;\n/**\n * @internal\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function multiply(a, b, c) {\n    // @ts-ignore\n    return applyMerge(multiplyOp, a, b, c);\n}\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n *\n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect, amount) {\n    return applyScalar(multiplyOp, rect, amount);\n    // return isPositioned(rect) ? Object.freeze({\n    //   ...rect,\n    //   x: rect.x * amount,\n    //   y: rect.y * amount,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // }) : Object.freeze({\n    //   ...rect,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // });\n}\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n *\n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns\n */\nexport function multiplyDim(rect, amount) {\n    return applyDim(multiplyOp, rect, amount);\n    // return isPositioned(rect) ? Object.freeze({\n    //   ...rect,\n    //   x: rect.x * amount,\n    //   y: rect.y * amount,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // }) : Object.freeze({\n    //   ...rect,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // });\n}\n","/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect\n * @param p\n * @returns\n */\nexport const nearestInternal = (rect, p) => {\n    let { x, y } = p;\n    if (x < rect.x)\n        x = rect.x;\n    else if (x > rect.x + rect.width)\n        x = rect.x + rect.width;\n    if (y < rect.y)\n        y = rect.y;\n    else if (y > rect.y + rect.height)\n        y = rect.y + rect.height;\n    return Object.freeze({ ...p, x, y });\n};\n","export const Placeholder = Object.freeze({\n    width: Number.NaN,\n    height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n    x: Number.NaN,\n    y: Number.NaN,\n    width: Number.NaN,\n    height: Number.NaN,\n});\n","import { guard } from \"./guard.js\";\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const perimeter = (rect) => {\n    guard(rect);\n    return rect.height + rect.height + rect.width + rect.width;\n};\n","import { isPoint, isPoint3d } from \"../point/guard.js\";\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect\n * @returns\n */\nexport const dividerByLargestDimension = (rect) => {\n    const largest = Math.max(rect.width, rect.height);\n    return (value) => {\n        if (typeof value === `number`) {\n            return value / largest;\n        }\n        else if (isPoint3d(value)) {\n            return Object.freeze({\n                ...value,\n                x: value.x / largest,\n                y: value.y / largest,\n                z: value.x / largest\n            });\n        }\n        else if (isPoint(value)) {\n            return Object.freeze({\n                ...value,\n                x: value.x / largest,\n                y: value.y / largest\n            });\n        }\n        else\n            throw new Error(`Param 'value' is neither number nor Point`);\n    };\n};\n","import { applyMerge } from \"./apply.js\";\nimport { isPositioned } from \"./guard.js\";\nconst subtractOp = (a, b) => a - b;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a, b, c) {\n    // @ts-ignore\n    return applyMerge(subtractOp, a, b, c);\n}\nexport function subtractSize(a, b, c) {\n    const w = typeof b === `number` ? b : b.width;\n    const h = typeof b === `number` ? c : b.height;\n    if (h === undefined)\n        throw new Error(`Expected height as third parameter`);\n    const r = {\n        ...a,\n        width: a.width - w,\n        height: a.height - h\n    };\n    return r;\n}\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 },\n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a\n * @param b\n * @returns\n */\nexport function subtractOffset(a, b) {\n    let x = 0;\n    let y = 0;\n    if (isPositioned(a)) {\n        x = a.x;\n        y = a.y;\n    }\n    let xB = 0;\n    let yB = 0;\n    if (isPositioned(b)) {\n        xB = b.x;\n        yB = b.y;\n    }\n    return Object.freeze({\n        ...a,\n        x: x - xB,\n        y: y - yB,\n        width: a.width - b.width,\n        height: a.height - b.height\n    });\n}\n","import { applyMerge } from \"./apply.js\";\nimport { getRectPositioned, isPositioned } from \"./guard.js\";\nconst sumOp = (a, b) => a + b;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function sum(a, b, c) {\n    // @ts-ignore\n    return applyMerge(sumOp, a, b, c);\n}\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a\n * @param b\n * @returns\n */\nexport function sumOffset(a, b) {\n    let x = 0;\n    let y = 0;\n    if (isPositioned(a)) {\n        x = a.x;\n        y = a.y;\n    }\n    let xB = 0;\n    let yB = 0;\n    if (isPositioned(b)) {\n        xB = b.x;\n        yB = b.y;\n    }\n    return Object.freeze({\n        ...a,\n        x: x + xB,\n        y: y + yB,\n        width: a.width + b.width,\n        height: a.height + b.height\n    });\n}\n","import { isPositioned, isRect } from \"./guard.js\";\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n// eslint-disable-next-line func-style\nexport function toArray(rect) {\n    if (isPositioned(rect)) {\n        return [rect.x, rect.y, rect.width, rect.height];\n    }\n    else if (isRect(rect)) {\n        return [rect.width, rect.height];\n    }\n    else {\n        throw new Error(`Param 'rect' is not a rectangle. Got: ${JSON.stringify(rect)}`);\n    }\n}\n","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\n","export const isQuadraticBezier = (path) => path.quadratic !== undefined;\nexport const isCubicBezier = (path) => path.cubic1 !== undefined && path.cubic2 !== undefined;\n","import { isQuadraticBezier } from \"../bezier/guard.js\";\nimport { isLine } from \"../line/guard.js\";\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path) {\n    if (isQuadraticBezier(path))\n        return path.a;\n    else if (isLine(path))\n        return path.a;\n    else\n        throw new Error(`Unknown path type ${JSON.stringify(path)}`);\n};\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path) {\n    if (isQuadraticBezier(path))\n        return path.b;\n    else if (isLine(path))\n        return path.b;\n    else\n        throw new Error(`Unknown path type ${JSON.stringify(path)}`);\n};\n","import { bbox as PointsBbox } from '../point/bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { sortByNumericProperty } from '@ixfx/arrays';\nimport { getEnd, getStart } from './start-end.js';\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath, index, path) => {\n    const existing = [...compoundPath.segments];\n    //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n    existing[index] = path;\n    return fromPaths(...existing);\n};\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths, t, useWidth, dimensions) => {\n    if (dimensions === undefined) {\n        dimensions = computeDimensions(paths);\n    }\n    // Expected value to land on\n    const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n    let soFar = 0;\n    // Use widths or lengths?\n    const l = useWidth ? dimensions.widths : dimensions.lengths;\n    for (const [index, element] of l.entries()) {\n        if (soFar + element >= expected) {\n            const relative = expected - soFar;\n            let amt = relative / element;\n            if (amt > 1)\n                amt = 1;\n            return paths[index].interpolate(amt);\n        }\n        else\n            soFar += element;\n    }\n    return { x: 0, y: 0 };\n};\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths\n * @param point\n * @returns\n */\nexport const distanceToPoint = (paths, point) => {\n    if (paths.length === 0)\n        return 0;\n    let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n    distances = sortByNumericProperty(distances, `distance`);\n    if (distances.length === 0)\n        throw new Error(`Could not look up distances`);\n    return distances[0].distance;\n};\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold\n * @param dimensions Pre-computed dimensions\n * @returns\n */\nexport const relativePosition = (paths, point, intersectionThreshold, dimensions) => {\n    if (dimensions === undefined) {\n        dimensions = computeDimensions(paths);\n    }\n    let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n    distances = sortByNumericProperty(distances, `distance`);\n    if (distances.length < 0)\n        throw new Error(`Point does not intersect with path`);\n    const d = distances[0];\n    if (d.distance > intersectionThreshold)\n        throw new Error(`Point does not intersect with path. Minimum distance: ${d.distance}, threshold: ${intersectionThreshold}`);\n    const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n    // Add up distances\n    let accumulated = 0;\n    for (let index = 0; index < d.index; index++) {\n        // Add up length of paths before closest path segment\n        accumulated += dimensions.lengths[index];\n    }\n    // Add up partial amount of closest path\n    accumulated += dimensions.lengths[d.index] * relativePositionOnPath;\n    const accumulatedRel = accumulated / dimensions.totalLength;\n    console.log(`acc: ${accumulated} rel: ${accumulatedRel} on path: ${relativePositionOnPath} path: ${d.index}`);\n    return accumulatedRel;\n};\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths) => {\n    const widths = paths.map(l => l.bbox().width);\n    const lengths = paths.map(l => l.length());\n    let totalLength = 0;\n    let totalWidth = 0;\n    for (const length of lengths) {\n        totalLength += length;\n    }\n    for (const width of widths) {\n        totalWidth += width;\n    }\n    return { totalLength, totalWidth, widths, lengths };\n};\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths) => {\n    const boxes = paths.map(p => p.bbox());\n    const corners = boxes.flatMap(b => RectsCorners(b));\n    return PointsBbox(...corners);\n};\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths) => paths.map(p => p.toString()).join(`, `);\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths) => {\n    let lastPos = getEnd(paths[0]);\n    for (let index = 1; index < paths.length; index++) {\n        const start = getStart(paths[index]);\n        if (!PointsIsEqual(start, lastPos))\n            throw new Error(`Path index ${index} does not start at prior path end. Start: ${start.x},${start.y} expected: ${lastPos.x},${lastPos.y}`);\n        lastPos = getEnd(paths[index]);\n    }\n};\nexport const toSvgString = (paths) => paths.flatMap(p => p.toSvgString());\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths) => {\n    guardContinuous(paths); // Throws an error if paths are not connected\n    const dims = computeDimensions(paths);\n    return Object.freeze({\n        segments: paths,\n        length: () => dims.totalLength,\n        nearest: (_) => { throw new Error(`not implemented`); },\n        interpolate: (t, useWidth = false) => interpolate(paths, t, useWidth, dims),\n        relativePosition: (point, intersectionThreshold) => relativePosition(paths, point, intersectionThreshold, dims),\n        distanceToPoint: (point) => distanceToPoint(paths, point),\n        bbox: () => bbox(paths),\n        toString: () => toString(paths),\n        toSvgString: () => toSvgString(paths),\n        kind: `compound`\n    });\n};\n","export * from './compound-path.js';\nexport * from './start-end.js';\n","/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid, cell) => {\n    if (cell.x < 0 || cell.y < 0)\n        return false;\n    if (cell.x >= grid.cols || cell.y >= grid.rows)\n        return false;\n    return true;\n};\n","import { inside } from \"./inside.js\";\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell) => {\n    if (cell === undefined)\n        return false;\n    return `x` in cell && `y` in cell;\n};\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (cell, parameterName = `Param`, grid) => {\n    if (cell === undefined) {\n        throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n    }\n    if (cell.x === undefined)\n        throw new Error(parameterName + `.x is undefined`);\n    if (cell.y === undefined)\n        throw new Error(parameterName + `.y is undefined`);\n    if (Number.isNaN(cell.x))\n        throw new Error(parameterName + `.x is NaN`);\n    if (Number.isNaN(cell.y))\n        throw new Error(parameterName + `.y is NaN`);\n    if (!Number.isInteger(cell.x)) {\n        throw new TypeError(parameterName + `.x is non-integer`);\n    }\n    if (!Number.isInteger(cell.y)) {\n        throw new TypeError(parameterName + `.y is non-integer`);\n    }\n    if (grid !== undefined && !inside(grid, cell)) {\n        throw new Error(`${parameterName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid.cols}, ${grid.rows}`);\n    }\n};\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid, parameterName = `Param`) => {\n    if (grid === undefined) {\n        throw new Error(`${parameterName} is undefined. Expecting grid.`);\n    }\n    if (!(`rows` in grid))\n        throw new Error(`${parameterName}.rows is undefined`);\n    if (!(`cols` in grid))\n        throw new Error(`${parameterName}.cols is undefined`);\n    if (!Number.isInteger(grid.rows)) {\n        throw new TypeError(`${parameterName}.rows is not an integer`);\n    }\n    if (!Number.isInteger(grid.cols)) {\n        throw new TypeError(`${parameterName}.cols is not an integer`);\n    }\n};\n","import { clampIndex } from \"@ixfx/numbers\";\nimport { guardCell, guardGrid } from \"./guards.js\";\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid\n * @param cell\n * @param wrap\n * @returns\n */\nexport const applyBounds = function (grid, cell, wrap = `undefined`) {\n    guardGrid(grid, `grid`);\n    guardCell(cell, `cell`);\n    let x = cell.x;\n    let y = cell.y;\n    switch (wrap) {\n        case `wrap`: {\n            x = x % grid.cols;\n            y = y % grid.rows;\n            if (x < 0)\n                x = grid.cols + x;\n            else if (x >= grid.cols) {\n                x -= grid.cols;\n            }\n            if (y < 0)\n                y = grid.rows + y;\n            else if (y >= grid.rows) {\n                y -= grid.rows;\n            }\n            x = Math.abs(x);\n            y = Math.abs(y);\n            break;\n        }\n        case `stop`: {\n            x = clampIndex(x, grid.cols);\n            y = clampIndex(y, grid.rows);\n            break;\n        }\n        case `undefined`: {\n            if (x < 0 || y < 0)\n                return;\n            if (x >= grid.cols || y >= grid.rows)\n                return;\n            break;\n        }\n        case `unbounded`: {\n            break;\n        }\n        default: {\n            throw new Error(`Unknown BoundsLogic '${wrap}'. Expected: wrap, stop, undefined or unbounded`);\n        }\n    }\n    return Object.freeze({ x, y });\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\nimport { indexFromCell } from \"./index.js\";\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n *\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport const access = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    const fn = (cell, wrap = `undefined`) => accessWithGrid(grid, array, cell, wrap);\n    return fn;\n};\nconst accessWithGrid = (grid, array, cell, wrap) => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined)\n        return undefined;\n    return array[index];\n};\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n *\n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport const setMutate = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return (value, cell, wrap = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n};\nconst setMutateWithGrid = (grid, array, value, cell, wrap) => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    array[index] = value;\n    return array;\n};\nexport const set = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return (value, cell, wrap) => setWithGrid(grid, array, value, cell, wrap);\n};\nconst setWithGrid = (grid, array, value, cell, wrap) => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    const copy = [...array];\n    copy[index] = value;\n    array = copy;\n    return copy;\n};\n/**\n * Creates a {@link Grid} from the basis of an array and a given number of columns\n * @param array\n * @param cols\n * @returns\n */\nconst gridFromArrayDimensions = (array, cols) => {\n    const grid = { cols, rows: Math.ceil(array.length / cols) };\n    return grid;\n};\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *\n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n *\n * Use {@link wrap} for an immutable version.\n *\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport const wrapMutable = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return {\n        ...grid,\n        get: access(array, cols),\n        set: setMutate(array, cols),\n        get array() {\n            return array;\n        }\n    };\n};\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * const myArray = [\n *    `a`, `b`, `c`,\n *    `d`, `e`, `f`\n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n *\n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport const wrap = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return {\n        ...grid,\n        get: (cell, boundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n        set: (value, cell, boundsLogic = `undefined`) => {\n            array = setWithGrid(grid, array, value, cell, boundsLogic);\n            return wrap(array, cols);\n        },\n        get array() {\n            return array;\n        }\n    };\n};\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n *\n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n *\n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport const createArray = (initialValue, rowsOrGrid, columns) => {\n    const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n    const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n    if (!cols)\n        throw new Error(`Parameter 'columns' missing`);\n    throwIntegerTest(rows, `aboveZero`, `rows`);\n    throwIntegerTest(cols, `aboveZero`, `cols`);\n    const t = [];\n    const total = rows * cols;\n    for (let index = 0; index < total; index++) {\n        t[index] = initialValue;\n    }\n    return t;\n};\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n *\n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue\n * @param rowsOrGrid\n * @param columns\n * @returns\n */\nexport const createMutable = (initialValue, rowsOrGrid, columns) => {\n    const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n    const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n    if (!cols)\n        throw new Error(`Parameter 'columns' missing`);\n    const array = createArray(initialValue, rows, cols);\n    return wrapMutable(array, cols);\n};\n","import { applyBounds } from \"./apply-bounds.js\";\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array\n * @returns\n */\nexport const create = (array) => {\n    let colLen = NaN;\n    for (const row of array) {\n        if (Number.isNaN(colLen)) {\n            colLen = row.length;\n        }\n        else {\n            if (colLen !== row.length)\n                throw new Error(`Array does not have uniform column length`);\n        }\n    }\n    return { rows: array.length, cols: colLen };\n};\nexport const setMutate = (array) => {\n    const grid = create(array);\n    return (value, cell, wrap = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n};\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.Array2d.setMutateWithGrid(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\nconst setMutateWithGrid = (grid, array, value, cell, bounds) => {\n    let boundCell = applyBounds(grid, cell, bounds);\n    if (boundCell === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    array[boundCell.y][boundCell.x] = value;\n    return array;\n};\n// export const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n//   const fn = (v: V, position: Cell) => {\n//     const pos = cellAtPoint(grid, position);\n//     if (pos === undefined) {\n//       throw new Error(\n//         `Position does not exist. Pos: ${ JSON.stringify(\n//           position\n//         ) } Grid: ${ JSON.stringify(grid) }`\n//       );\n//     }\n//     array[ pos.y ][ pos.x ] = v;\n//   };\n//   return fn;\n// };\nexport const access = (array) => {\n    const grid = create(array);\n    const fn = (cell, wrap = `undefined`) => accessWithGrid(grid, array, cell, wrap);\n    return fn;\n};\nconst accessWithGrid = (grid, array, cell, wrap) => {\n    let boundCell = applyBounds(grid, cell, wrap);\n    if (boundCell === undefined)\n        return undefined;\n    return array[boundCell.y][boundCell.x];\n};\nexport const wrapMutable = (array) => {\n    const grid = create(array);\n    return {\n        ...grid,\n        get: access(array),\n        set: setMutate(array),\n        get array() {\n            return array;\n        }\n    };\n};\nexport const set = (array) => {\n    const grid = create(array);\n    return (value, cell, wrap) => setWithGrid(grid, array, value, cell, wrap);\n};\nconst setWithGrid = (grid, array, value, cell, wrap) => {\n    let boundCell = applyBounds(grid, cell, wrap);\n    if (boundCell === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    let copyWhole = [...array];\n    let copyRow = [...copyWhole[boundCell.y]];\n    copyRow[boundCell.x] = value;\n    copyWhole[boundCell.y] = copyRow;\n    array = copyWhole;\n    return copyWhole;\n};\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns\n */\nexport const wrap = (array) => {\n    const grid = create(array);\n    return {\n        ...grid,\n        get: (cell, boundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n        set: (value, cell, boundsLogic = `undefined`) => {\n            array = setWithGrid(grid, array, value, cell, boundsLogic);\n            return wrap(array);\n        },\n        get array() {\n            return array;\n        }\n    };\n};\n","/**\n * Converts an 1D or 2D array of cell coordinates into values\n *\n * ```js\n * // 1D (ie an array of coordinates)\n * const cells = Grid.As.cells(grid);\n * for (const v of Grid.values(grid, cells)) {\n *\n * }\n * ```\n * ```js\n * // 2D (ie an array of rows)\n * const rows = Grid.As.rows(grid);\n * for (const v of Grid.values(grid, rows)) {\n * }\n * ```\n * @param grid\n * @param iter\n */\nexport function* values(grid, iter) {\n    for (const d of iter) {\n        if (Array.isArray(d)) {\n            yield d.map(v => grid.get(v, `undefined`));\n        }\n        else {\n            yield grid.get(d, `undefined`);\n        }\n    }\n}\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell[]>, wrap?: BoundsLogic): Generator<T[]>\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell>, wrap?: BoundsLogic): Generator<T>\n// /**\n//  * Visits the values of a readable grid\n//  * @param readable Readable grid\n//  * @param visitor Visitor\n//  * @param wrap Wrapping logic, defaultign to 'undefined'\n//  */\n// export function* visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell | Cell[]>, wrap: BoundsLogic = `undefined`) {\n//   for (const cellOrCells of visitor) {\n//     if (Array.isArray(cellOrCells)) {\n//       yield cellOrCells.map(cell => readable.accessor(cell, wrap));\n//     } else {\n//       yield readable.accessor(cellOrCells, wrap);\n//     }\n//   }\n// }\n","import { guardGrid, guardCell } from \"../guards.js\";\nimport { values } from \"../values.js\";\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n *\n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n *\n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n *\n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n *\n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid, start, wrap = true) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`, grid);\n    let { x, y } = start;\n    let canMove = true;\n    do {\n        yield { x, y };\n        x++;\n        if (x === grid.cols) {\n            y++;\n            x = 0;\n        }\n        if (y === grid.rows) {\n            if (wrap) {\n                y = 0;\n                x = 0;\n            }\n            else {\n                canMove = false;\n            }\n        }\n        if (x === start.x && y === start.y)\n            canMove = false; // Complete\n    } while (canMove);\n}\n;\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n *\n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport function* cellValues(grid, start, wrap = true) {\n    yield* values(grid, cells(grid, start, wrap));\n}\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport function* cellsAndValues(grid, start, wrap = true) {\n    for (const cell of cells(grid, start, wrap)) {\n        yield { cell, value: grid.get(cell) };\n    }\n}\n","import { cells } from \"./enumerators/cells.js\";\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n *\n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid, start) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    let row = start.y;\n    let rowCells = [];\n    for (const c of cells(grid, start)) {\n        if (c.y === row) {\n            rowCells.push(c);\n        }\n        else {\n            yield rowCells;\n            rowCells = [c];\n            row = c.y;\n        }\n    }\n    if (rowCells.length > 0)\n        yield rowCells;\n};\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n *\n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n *\n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport function* columns(grid, start) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    for (let x = start.x; x < grid.cols; x++) {\n        let colCells = [];\n        for (let y = start.y; y < grid.rows; y++) {\n            colCells.push({ x, y });\n        }\n        yield colCells;\n    }\n}\n","//import { clampIndex } from '@ixfx/numbers';\nimport { applyBounds } from './apply-bounds.js';\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n *\n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (grid, start, vector, bounds = `undefined`) {\n    return applyBounds(grid, {\n        x: start.x + vector.x,\n        y: start.y + vector.y\n    }, bounds);\n    // guardCell(start, `start`, grid);\n    // guardCell(vector);\n    // guardGrid(grid, `grid`);\n    // // eslint-disable-next-line functional/no-let\n    // let x = start.x;\n    // // eslint-disable-next-line functional/no-let\n    // let y = start.y;\n    // switch (bounds) {\n    //   case `wrap`: {\n    //     x += vector.x % grid.cols;\n    //     y += vector.y % grid.rows;\n    //     if (x < 0) x = grid.cols + x;\n    //     else if (x >= grid.cols) {\n    //       x -= grid.cols;\n    //     }\n    //     if (y < 0) y = grid.rows + y;\n    //     else if (y >= grid.rows) {\n    //       y -= grid.rows;\n    //     }\n    //     break;\n    //   }\n    //   case `stop`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     x = clampIndex(x, grid.cols);\n    //     y = clampIndex(y, grid.rows);\n    //     break;\n    //   }\n    //   case `undefined`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     if (x < 0 || y < 0) return;\n    //     if (x >= grid.cols || y >= grid.rows) return;\n    //     break;\n    //   }\n    //   case `unbounded`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     break;\n    //   }\n    //   default: {\n    //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n    //   }\n    // }\n    // return Object.freeze({ x, y });\n};\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { throwIntegerTest } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n    `n`,\n    `ne`,\n    `nw`,\n    `e`,\n    `s`,\n    `se`,\n    `sw`,\n    `w`,\n]);\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n    `n`,\n    `e`,\n    `s`,\n    `w`,\n]);\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (grid, start, steps, bounds = `stop`) => {\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`);\n    throwIntegerTest(steps, `aboveZero`, `steps`);\n    const directions = allDirections;\n    const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n    const cells = directions.map((d, index) => offset(grid, start, vectors[index], bounds));\n    return zipKeyValue(directions, cells);\n};\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (cardinal, multiplier = 1) => {\n    // eslint-disable-next-line functional/no-let\n    let v;\n    switch (cardinal) {\n        case `n`: {\n            v = { x: 0, y: -1 * multiplier };\n            break;\n        }\n        case `ne`: {\n            v = { x: 1 * multiplier, y: -1 * multiplier };\n            break;\n        }\n        case `e`: {\n            v = { x: 1 * multiplier, y: 0 };\n            break;\n        }\n        case `se`: {\n            v = { x: 1 * multiplier, y: 1 * multiplier };\n            break;\n        }\n        case `s`: {\n            v = { x: 0, y: 1 * multiplier };\n            break;\n        }\n        case `sw`: {\n            v = { x: -1 * multiplier, y: 1 * multiplier };\n            break;\n        }\n        case `w`: {\n            v = { x: -1 * multiplier, y: 0 };\n            break;\n        }\n        case `nw`: {\n            v = { x: -1 * multiplier, y: -1 * multiplier };\n            break;\n        }\n        default: {\n            v = { x: 0, y: 0 };\n        }\n    }\n    return Object.freeze(v);\n};\n","//import type { Cell, GridReadable } from '../Types.js';\nexport * from './cells.js';\n// export function* withValues<T>(grid: GridReadable<T>, iter: IterableIterator<Cell>) {\n//   for (const cell of iter) {\n//     yield { cell, value: grid.get(cell, `undefined`) };\n//   }\n// }\n","import { guardCell } from \"./guards.js\";\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start, end) => {\n    // https://stackoverflow.com/a/4672319\n    guardCell(start);\n    guardCell(end);\n    let startX = start.x;\n    let startY = start.y;\n    const dx = Math.abs(end.x - startX);\n    const dy = Math.abs(end.y - startY);\n    const sx = startX < end.x ? 1 : -1;\n    const sy = startY < end.y ? 1 : -1;\n    let error = dx - dy;\n    const cells = [];\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        cells.push(Object.freeze({ x: startX, y: startY }));\n        if (startX === end.x && startY === end.y)\n            break;\n        const error2 = 2 * error;\n        if (error2 > -dy) {\n            error -= dy;\n            startX += sx;\n        }\n        if (error2 < dx) {\n            error += dx;\n            startY += sy;\n        }\n    }\n    return cells;\n};\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (start, end, endInclusive = false) {\n    const cells = [];\n    if (start.x === end.x) {\n        // Vertical\n        const lastY = endInclusive ? end.y + 1 : end.y;\n        for (let y = start.y; y < lastY; y++) {\n            cells.push({ x: start.x, y: y });\n        }\n    }\n    else if (start.y === end.y) {\n        // Horizontal\n        const lastX = endInclusive ? end.x + 1 : end.x;\n        for (let x = start.x; x < lastX; x++) {\n            cells.push({ x: x, y: start.y });\n        }\n    }\n    else {\n        throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);\n    }\n    return cells;\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\nimport { guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (grid, cell, wrap) => {\n    guardGrid(grid, `grid`);\n    if (cell.x < 0) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, x: 0 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                //cell = { ...cell, x: grid.cols + cell.x };\n                cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`);\n                break;\n            }\n        }\n    }\n    if (cell.y < 0) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, y: 0 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, y: grid.rows + cell.y };\n                break;\n            }\n        }\n    }\n    if (cell.x >= grid.cols) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, x: grid.cols - 1 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, x: cell.x % grid.cols };\n                break;\n            }\n        }\n    }\n    if (cell.y >= grid.rows) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, y: grid.rows - 1 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, y: cell.y % grid.rows };\n                break;\n            }\n        }\n    }\n    const index = cell.y * grid.cols + cell.x;\n    return index;\n};\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (colsOrGrid, index) => {\n    let cols = 0;\n    cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n    throwIntegerTest(cols, `aboveZero`, `colsOrGrid`);\n    return {\n        x: index % cols,\n        y: Math.floor(index / cols),\n    };\n};\n","/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (a, b) => {\n    if (b === undefined)\n        return false;\n    if (a === undefined)\n        return false;\n    if (`rows` in a && `cols` in a) {\n        if (`rows` in b && `cols` in b) {\n            if (a.rows !== b.rows || a.cols !== b.cols)\n                return false;\n        }\n        else\n            return false;\n    }\n    if (`size` in a) {\n        if (`size` in b) {\n            if (a.size !== b.size)\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n};\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (a, b) => {\n    if (b === undefined)\n        return false;\n    if (a === undefined)\n        return false;\n    return a.x === b.x && a.y === b.y;\n};\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { allDirections, getVectorFromCardinal } from \"./directions.js\";\nimport { randomElement } from \"@ixfx/random\";\nimport { offset } from \"./offset.js\";\nexport const randomNeighbour = (nbos) => randomElement(nbos); // .filter(isNeighbour));\n/**\n * Returns _true_ if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (n) => {\n    if (n === undefined)\n        return false;\n    if (n[1] === undefined)\n        return false;\n    return true;\n};\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n *\n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n *\n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions\n * @param bounds Bounds\n * @returns\n */\nexport const neighbourList = (grid, cell, directions, bounds) => {\n    // Get neighbours for cell\n    const cellNeighbours = neighbours(grid, cell, bounds, directions);\n    // Filter out undefined cells\n    const entries = Object.entries(cellNeighbours);\n    return entries.filter(n => isNeighbour(n));\n};\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (grid, cell, bounds = `undefined`, directions) => {\n    const directories = directions ?? allDirections;\n    const points = directories.map((c) => offset(grid, cell, getVectorFromCardinal(c), bounds));\n    return zipKeyValue(directories, points);\n};\n","/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\nexport const toArray2d = (grid, initialValue) => {\n    const returnValue = [];\n    for (let row = 0; row < grid.rows; row++) {\n        returnValue[row] = Array.from({ length: grid.cols });\n        if (initialValue) {\n            for (let col = 0; col < grid.cols; col++) {\n                returnValue[row][col] = initialValue;\n            }\n        }\n    }\n    return returnValue;\n};\n","/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v) => `Cell{${v.x},${v.y}}`;\n","import { guardCell } from \"./guards.js\";\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { throwIntegerTest, throwNumberTest } from '@ixfx/guards';\nimport { cells } from \"./enumerators/cells.js\";\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(grid) {\n    for (const c of cells(grid)) {\n        yield rectangleForCell(grid, c);\n    }\n}\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (grid, position) => {\n    const size = grid.size;\n    throwNumberTest(size, `positive`, `grid.size`);\n    if (position.x < 0 || position.y < 0)\n        return;\n    const x = Math.floor(position.x / size);\n    const y = Math.floor(position.y / size);\n    if (x >= grid.cols)\n        return;\n    if (y >= grid.rows)\n        return;\n    return { x, y };\n};\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (grid, cell) => {\n    guardCell(cell);\n    const size = grid.size;\n    const x = cell.x * size;\n    const y = cell.y * size;\n    const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n    return r;\n};\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid, cell) => {\n    guardCell(cell);\n    const size = grid.size;\n    const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n    const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n    return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};\n","//import { visitor } from \"./Visitor.js\";\n// export const visitorBreadth = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos[ 0 ],\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\nexport const breadthLogic = () => {\n    return {\n        select: (nbos) => nbos[0],\n    };\n};\n","import { allDirections } from \"../directions.js\";\nimport { neighbourList } from \"../neighbour.js\";\n// export function* cellNeigbours(\n//   grid: Grid,\n//   cell: Cell,\n//   bounds: BoundsLogic = `undefined`,\n//   directions?: ReadonlyArray<CardinalDirection>\n// ) {\n//   const dirs = directions ?? allDirections;\n//   const points = dirs.map((c) =>\n//     offset(grid, cell, getVectorFromCardinal(c), bounds)\n//   );\n//   for (const pt of points) {\n//     if (pt !== undefined) yield pt;\n//   }\n// }\nexport const neighboursLogic = () => {\n    return {\n        select: (neighbours) => {\n            return neighbours.at(0);\n        },\n        getNeighbours: (grid, cell) => {\n            return neighbourList(grid, cell, allDirections, `undefined`);\n        }\n    };\n};\n","/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport const columnLogic = (opts = {}) => {\n    const reversed = opts.reversed ?? false;\n    return {\n        select: (nbos) => nbos.find((n) => n[0] === (reversed ? `n` : `s`)),\n        getNeighbours: (grid, cell) => {\n            if (reversed) {\n                // WALK UP COLUMN, RIGHT-TO-LEFT\n                if (cell.y > 0) {\n                    // Easy case\n                    cell = { x: cell.x, y: cell.y - 1 };\n                }\n                else {\n                    // Top of column\n                    if (cell.x === 0) {\n                        // Top-left corner, need to wrap\n                        cell = { x: grid.cols - 1, y: grid.rows - 1 };\n                    }\n                    else {\n                        cell = { x: cell.x - 1, y: grid.rows - 1 };\n                    }\n                }\n            }\n            else {\n                // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n                if (cell.y < grid.rows - 1) {\n                    // Easy case, move down by one\n                    cell = { x: cell.x, y: cell.y + 1 };\n                }\n                else {\n                    // End of column\n                    if (cell.x < grid.cols - 1) {\n                        // Move to next column and start at top\n                        cell = { x: cell.x + 1, y: 0 };\n                    }\n                    else {\n                        // Move to start of grid\n                        cell = { x: 0, y: 0 };\n                    }\n                }\n            }\n            return [[reversed ? `n` : `s`, cell]];\n        }\n    };\n};\n","// export const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos.at(-1),\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\nexport const depthLogic = () => {\n    return {\n        select: (nbos) => nbos.at(-1)\n    };\n};\n","import { randomNeighbour } from \"../neighbour.js\";\nimport { cells } from \"../enumerators/cells.js\";\n// export const visitorRandom = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomLogic = () => {\n    return {\n        getNeighbours: (grid, cell) => {\n            const t = [];\n            for (const c of cells(grid, cell)) {\n                t.push([`n`, c]);\n            }\n            return t;\n        },\n        select: randomNeighbour,\n    };\n};\n","import { randomNeighbour } from \"../neighbour.js\";\n// export const visitorRandomContiguous = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomContiguousLogic = () => {\n    return {\n        select: randomNeighbour,\n    };\n};\n","/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport const rowLogic = (opts = {}) => {\n    const reversed = opts.reversed ?? false;\n    return {\n        select: (nbos) => nbos.find((n) => n[0] === (reversed ? `w` : `e`)),\n        getNeighbours: (grid, cell) => {\n            if (reversed) {\n                // WALKING BACKWARD ALONG ROW\n                if (cell.x > 0) {\n                    // All fine, step to the left\n                    cell = { x: cell.x - 1, y: cell.y };\n                }\n                else {\n                    // At the beginning of a row\n                    if (cell.y > 0) {\n                        // Wrap to next row up\n                        cell = { x: grid.cols - 1, y: cell.y - 1 };\n                    }\n                    else {\n                        // Wrap to end of grid\n                        cell = { x: grid.cols - 1, y: grid.rows - 1 };\n                    }\n                }\n            }\n            else {\n                /*\n                 * WALKING FORWARD ALONG ROWS\n                 */\n                if (cell.x < grid.rows - 1) {\n                    // All fine, step to the right\n                    cell = { x: cell.x + 1, y: cell.y };\n                }\n                else {\n                    // At the end of a row\n                    // eslint-disable-next-line unicorn/prefer-ternary\n                    if (cell.y < grid.rows - 1) {\n                        // More rows available, wrap to next row down\n                        cell = { x: 0, y: cell.y + 1 };\n                    }\n                    else {\n                        // No more rows available, wrap to start of the grid\n                        cell = { x: 0, y: 0 };\n                    }\n                }\n            }\n            return [[reversed ? `w` : `e`, cell]];\n        }\n    };\n};\n","import { mutable } from '@ixfx/collections/set';\nimport { crossDirections } from \"../directions.js\";\nimport { guardGrid, guardCell, isCell } from \"../guards.js\";\nimport { cellEquals } from \"../is-equal.js\";\nimport { neighbourList } from '../neighbour.js';\nimport { cellKeyString } from \"../to-string.js\";\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a {@link Collections.Sets.ISetMutable} instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport function* visitByNeighbours(logic, grid, opts = {}) {\n    guardGrid(grid, `grid`);\n    const start = opts.start ?? { x: 0, y: 0 };\n    guardCell(start, `opts.start`, grid);\n    const v = opts.visited ?? mutable(cellKeyString);\n    const possibleNeighbours = logic.getNeighbours ?? ((g, c) => neighbourList(g, c, crossDirections, `undefined`));\n    let cellQueue = [start];\n    let moveQueue = [];\n    let current = undefined;\n    while (cellQueue.length > 0) {\n        if (current === undefined) {\n            const nv = cellQueue.pop();\n            if (nv === undefined) {\n                break;\n            }\n            current = nv;\n        }\n        if (!v.has(current)) {\n            v.add(current);\n            yield current;\n            const nextSteps = possibleNeighbours(grid, current).filter((step) => {\n                if (step[1] === undefined)\n                    return false;\n                return !v.has(step[1]);\n            });\n            if (nextSteps.length === 0) {\n                // No more moves for this cell\n                if (current !== undefined) {\n                    cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n                }\n            }\n            else {\n                for (const n of nextSteps) {\n                    if (n === undefined)\n                        continue;\n                    if (n[1] === undefined)\n                        continue;\n                    moveQueue.push(n);\n                }\n            }\n        }\n        // Remove steps already made\n        moveQueue = moveQueue.filter((step) => !v.has(step[1]));\n        if (moveQueue.length === 0) {\n            current = undefined;\n        }\n        else {\n            // Pick move\n            const potential = logic.select(moveQueue);\n            if (potential !== undefined) {\n                cellQueue.push(potential[1]);\n                current = potential[1];\n            }\n        }\n    }\n}\n;\n","import { throwIntegerTest } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"../guards.js\";\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n *\n * // Step by 10\n * stepper(10); // GridCell {x,y}\n *\n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport const stepper = (grid, createVisitor, start = { x: 0, y: 0 }, resolution = 1) => {\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`);\n    throwIntegerTest(resolution, ``, `resolution`);\n    // Create a list of steps\n    const steps = [];\n    let count = 0;\n    let position = 0;\n    for (const c of createVisitor(grid, { start, boundsWrap: `undefined` })) {\n        count++;\n        if ((count % resolution) !== 0)\n            continue;\n        steps.push(c);\n    }\n    return (step, fromStart = false) => {\n        throwIntegerTest(step, ``, `step`);\n        if (fromStart)\n            position = step;\n        else\n            position += step;\n        //position = position % steps.length;\n        return steps.at(position % steps.length);\n    };\n};\n// export const step = (\n//   grid: Grid,\n//   start: Cell,\n//   steps: number,\n//   createVisitor: CreateVisitor\n// ): Cell => {\n//   throwIntegerTest(steps, ``, `steps`);\n//   const opts: Partial<VisitorOpts> = {\n//     reversed: steps < 0,\n//     start\n//   };\n//   steps = Math.abs(steps);\n//   let c = start;\n//   let v = createVisitor(grid, opts);\n//   v.next(); // Burn up starting cell\n//   let stepsMade = 0;\n//   while (stepsMade < steps) {\n//     stepsMade++;\n//     const { value } = v.next();\n//     if (value) {\n//       c = value;\n//       if (opts.debug) {\n//         console.log(\n//           `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n//         );\n//       }\n//     } else {\n//       if (steps >= grid.cols * grid.rows) {\n//         steps -= grid.cols * grid.rows;\n//         stepsMade = 0;\n//         v = createVisitor(grid, opts);\n//         v.next();\n//         c = start;\n//         if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n//       } else throw new Error(`Value not received by visitor`);\n//     }\n//   }\n//   return c;\n// };\n","import { breadthLogic } from './breadth.js';\nimport { neighboursLogic } from './cell-neighbours.js';\nimport { columnLogic } from './columns.js';\nimport { depthLogic } from './depth.js';\nimport { randomLogic } from './random.js';\nimport { randomContiguousLogic } from './random-contiguous.js';\nimport { rowLogic } from './rows.js';\nimport { visitByNeighbours } from './visitor.js';\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type\n * @param opts\n * @returns\n */\nexport const create = (type, opts = {}) => {\n    switch (type) {\n        case `random-contiguous`:\n            return withLogic(randomContiguousLogic(), opts);\n        case `random`:\n            return withLogic(randomLogic(), opts);\n        case `depth`:\n            return withLogic(depthLogic(), opts);\n        case `breadth`:\n            return withLogic(breadthLogic(), opts);\n        case `neighbours`:\n            return withLogic(neighboursLogic(), opts);\n        case `row`:\n            return withLogic(rowLogic(opts), opts);\n        case `column`:\n            return withLogic(columnLogic(opts), opts);\n        default:\n            throw new TypeError(`Param 'type' unknown. Value: ${type}`);\n    }\n};\nexport const withLogic = (logic, options = {}) => {\n    return (grid, optionsOverride = {}) => {\n        return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n    };\n};\nfunction isIterator(v) {\n    if (typeof v !== `object`)\n        return false;\n    if (!(`next` in v))\n        return false;\n    if (!(`throw` in v))\n        return false;\n    if (!(`return` in v))\n        return false;\n    return true;\n}\n// export function* withValues<T>(createOrIter: CreateVisitor | Generator<Cell>, grid: GridReadable<T>, opts: Partial<VisitorOpts>) {\n//   const iter = isIterator(createOrIter) ? createOrIter : createOrIter(grid, opts)();\n//   for (const cell of iter) {\n//     yield { cell, value: grid.accessor(cell, `undefined`) }\n//   }\n// }\n// export const byCells = (grid: Grid, options: Partial<VisitorOpts> = {}) => {\n//   return (logic: NeighbourSelectionLogic, optionsOverride: Partial<VisitorOpts> = {}) => {\n//     return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n//   }\n// }\n// export const byCellsLeftToRightTopToBottom = ():CreateVisitor => {\n//   return (grid) => {\n//     return cells(grid)\n//   }\n// }\n","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n *\n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start, end, bend = 0) => {\n    if (Number.isNaN(bend))\n        throw new Error(`bend is NaN`);\n    if (bend < -1 || bend > 1)\n        throw new Error(`Expects bend range of -1 to 1`);\n    const middle = LinesInterpolate(0.5, start, end);\n    let target = middle;\n    if (end.y < start.y) {\n        // Upward slope\n        target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n            { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n    }\n    else {\n        // Downward slope\n        target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n            { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n    }\n    const handle = LinesInterpolate(Math.abs(bend), middle, target);\n    return quadratic(start, end, handle);\n};\n/**\n * Returns a relative point on a simple quadratic\n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n *\n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q\n * @returns\n */\nexport const interpolator = (q) => {\n    //console.log(q);\n    //if (isCubicBezier(q)) console.log(`is cubic`);\n    //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n    const bzr = isCubicBezier(q) ?\n        new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n        new BezierLibrary(q.a, q.quadratic, q.b);\n    return (amount) => bzr.compute(amount);\n};\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start, end, handle) => [`M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`];\nexport const toPath = (cubicOrQuadratic) => {\n    if (isCubicBezier(cubicOrQuadratic)) {\n        return cubicToPath(cubicOrQuadratic);\n    }\n    else if (isQuadraticBezier(cubicOrQuadratic)) {\n        return quadratictoPath(cubicOrQuadratic);\n    }\n    else {\n        throw new Error(`Unknown bezier type`);\n    }\n};\nexport const cubic = (start, end, cubic1, cubic2) => ({\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n});\nconst cubicToPath = (cubic) => {\n    const { a, cubic1, cubic2, b } = cubic;\n    const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n    return Object.freeze({\n        ...cubic,\n        length: () => bzr.length(),\n        interpolate: (t) => bzr.compute(t),\n        nearest: (_) => { throw new Error(`not implemented`); },\n        bbox: () => {\n            const { x, y } = bzr.bbox();\n            const xSize = x.size;\n            const ySize = y.size;\n            if (xSize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            if (ySize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n        },\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        toSvgString: () => [`brrup`],\n        kind: `bezier/cubic`\n    });\n};\nexport const quadratic = (start, end, handle) => ({\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    quadratic: Object.freeze(handle)\n});\nconst quadratictoPath = (quadraticBezier) => {\n    const { a, b, quadratic } = quadraticBezier;\n    const bzr = new BezierLibrary(a, quadratic, b);\n    return Object.freeze({\n        ...quadraticBezier,\n        length: () => bzr.length(),\n        interpolate: (t) => bzr.compute(t),\n        nearest: (_) => { throw new Error(`not implemented`); },\n        bbox: () => {\n            const { x, y } = bzr.bbox();\n            const xSize = x.size;\n            const ySize = y.size;\n            if (xSize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            if (ySize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        toString: () => bzr.toString(),\n        toSvgString: () => quadraticToSvgString(a, b, quadratic),\n        kind: `bezier/quadratic`\n    });\n};\n","import { degreeToRadian } from './angles.js';\nexport const fromDegrees = (radiusX, radiusY, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360) => ({\n    radiusX, radiusY,\n    rotation: degreeToRadian(rotationDeg),\n    startAngle: degreeToRadian(startAngleDeg),\n    endAngle: degreeToRadian(endAngleDeg)\n});\n","import { distance } from \"./point/distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport const rdpShortestDistance = (points, epsilon = 0.1) => {\n    const firstPoint = points[0];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastPoint = points.at(-1);\n    if (points.length < 3) {\n        return points;\n    }\n    let index = -1;\n    let distribution = 0;\n    for (let index_ = 1; index_ < points.length - 1; index_++) {\n        const cDistribution = distanceFromPointToLine(points[index_], firstPoint, lastPoint);\n        if (cDistribution > distribution) {\n            distribution = cDistribution;\n            index = index_;\n        }\n    }\n    if (distribution > epsilon) {\n        // iterate\n        const l1 = points.slice(0, index + 1);\n        const l2 = points.slice(index);\n        const r1 = rdpShortestDistance(l1, epsilon);\n        const r2 = rdpShortestDistance(l2, epsilon);\n        // concat r2 to r1 minus the end/startpoint that will be the same\n        const rs = [...r1.slice(0, -1), ...r2]; //concat(r2);\n        return rs;\n    }\n    else {\n        return [firstPoint, lastPoint];\n    }\n};\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport const rdpPerpendicularDistance = (points, epsilon = 0.1) => {\n    const firstPoint = points[0];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastPoint = points.at(-1);\n    if (points.length < 3) {\n        return points;\n    }\n    let index = -1;\n    let distribution = 0;\n    for (let index_ = 1; index_ < points.length - 1; index_++) {\n        const cDistribution = findPerpendicularDistance(points[index_], firstPoint, lastPoint);\n        if (cDistribution > distribution) {\n            distribution = cDistribution;\n            index = index_;\n        }\n    }\n    if (distribution > epsilon) {\n        // iterate\n        const l1 = points.slice(0, index + 1);\n        const l2 = points.slice(index);\n        const r1 = rdpPerpendicularDistance(l1, epsilon);\n        const r2 = rdpPerpendicularDistance(l2, epsilon);\n        // concat r2 to r1 minus the end/startpoint that will be the same\n        const rs = [...r1.slice(0, -1), ...r2];\n        return rs;\n    }\n    else {\n        return [firstPoint, lastPoint];\n    }\n};\nfunction findPerpendicularDistance(p, p1, p2) {\n    // if start and end point are on the same x the distance is the difference in X.\n    let result;\n    let slope;\n    let intercept;\n    if (p1.x == p2.x) {\n        result = Math.abs(p.x - p1.x);\n    }\n    else {\n        slope = (p2.y - p1.y) / (p2.x - p1.x);\n        intercept = p1.y - (slope * p1.x);\n        result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n    }\n    return result;\n}\nconst distanceFromPointToLine = (p, index, index_) => {\n    const lineLength = distance(index, index_); //First, we need the length of the line segment.\n    if (lineLength == 0) { //if it's 0, the line is actually just a point.\n        return distance(p, index);\n    }\n    const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n    //t is very important. t is a number that essentially compares the individual coordinates\n    //distances between the point and each point on the line.\n    if (t < 0) { //if t is less than 0, the point is behind i, and closest to i.\n        return distance(p, index);\n    } //if greater than 1, it's closest to j.\n    if (t > 1) {\n        return distance(p, index_);\n    }\n    return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n};\n","import {} from '@ixfx/collections';\nimport * as Shapes from './shape/index.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/from-top-left.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/from.js';\n/**\n * Direction\n */\nexport var Direction;\n(function (Direction) {\n    Direction[Direction[\"Nw\"] = 0] = \"Nw\";\n    Direction[Direction[\"Ne\"] = 1] = \"Ne\";\n    Direction[Direction[\"Sw\"] = 2] = \"Sw\";\n    Direction[Direction[\"Se\"] = 3] = \"Se\";\n})(Direction || (Direction = {}));\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds, initialData = [], opts = {}) => {\n    const o = {\n        maxItems: opts.maxItems ?? 4,\n        maxLevels: opts.maxLevels ?? 4\n    };\n    const n = new QuadTreeNode(undefined, bounds, 0, o);\n    for (const d of initialData) {\n        n.add(d);\n    }\n    return n;\n};\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n *\n */\nexport class QuadTreeNode {\n    boundary;\n    level;\n    opts;\n    #items = [];\n    #children = [];\n    #parent;\n    /**\n     * Constructor\n     * @param boundary\n     * @param level\n     * @param opts\n     */\n    constructor(parent, boundary, level, opts) {\n        this.boundary = boundary;\n        this.level = level;\n        this.opts = opts;\n        this.#parent = parent;\n    }\n    getLengthChildren() {\n        return this.#children.length;\n    }\n    *parents() {\n        //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n        let n = this;\n        while (n.#parent !== undefined) {\n            yield n.#parent;\n            n = n.#parent;\n        }\n    }\n    getParent() {\n        return this.#parent;\n    }\n    /**\n     * Iterates over immediate children\n     */\n    *children() {\n        for (const c of this.#children) {\n            yield c;\n        }\n    }\n    /**\n     * Array of QuadTreeItem\n     * @returns\n     */\n    getValue() {\n        return this.#items;\n    }\n    getIdentity() {\n        return this;\n    }\n    /**\n     * Get a descendant node in a given direction\n     * @param d\n     * @returns\n     */\n    direction(d) {\n        return this.#children[d];\n    }\n    /**\n     * Add an item to the quadtree\n     * @param p\n     * @returns False if item is outside of boundary, True if item was added\n     */\n    add(p) {\n        if (!Shapes.isIntersecting(this.boundary, p))\n            return false;\n        if (this.#children.length > 0) {\n            for (const d of this.#children)\n                (d).add(p);\n            return true;\n        }\n        this.#items.push(p);\n        if (this.#items.length > this.opts.maxItems &&\n            this.level < this.opts.maxLevels) {\n            if (this.#children.length === 0) {\n                this.#subdivide();\n            }\n            // Add to child\n            for (const item of this.#items) {\n                for (const d of this.#children)\n                    (d).add(item);\n            }\n            //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n            this.#items = [];\n        }\n        return true;\n    }\n    /**\n     * Returns true if point is inside node's boundary\n     * @param p\n     * @returns\n     */\n    couldHold(p) {\n        return RectsIntersectsPoint(this.boundary, p);\n    }\n    #subdivide() {\n        const w = this.boundary.width / 2;\n        const h = this.boundary.height / 2;\n        const x = this.boundary.x;\n        const y = this.boundary.y;\n        // top-left corners of each of the four new sections\n        const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n        const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n        // rects.forEach((r, index) => {\n        //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n        // });\n        this.#children = rects.map((r) => new QuadTreeNode(this, r, this.level + 1, this.opts));\n    }\n}\n","import { isPoint } from './point/index.js';\nimport { isRect } from './rect/guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/placeholder.js';\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (scaleBy = `both`, defaultRect) => {\n    const defaultBounds = defaultRect ?? PlaceholderRect;\n    let sw = 1;\n    let sh = 1;\n    let s = { x: 1, y: 1 };\n    const computeScale = () => {\n        switch (scaleBy) {\n            case `height`: {\n                return { x: sh, y: sh };\n            }\n            case `width`: {\n                return { x: sw, y: sw };\n            }\n            case `min`: {\n                return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n            }\n            case `max`: {\n                return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n            }\n            default: {\n                return { x: sw, y: sh };\n            }\n        }\n    };\n    const normalise = (a, b, c, d) => {\n        let inX = Number.NaN;\n        let inY = Number.NaN;\n        let outW = defaultBounds.width;\n        let outH = defaultBounds.height;\n        if (typeof a === `number`) {\n            inX = a;\n            if (typeof b === `number`) {\n                inY = b;\n                if (c === undefined)\n                    return [inX, inY, outW, outH];\n                if (isRect(c)) {\n                    outW = c.width;\n                    outH = c.height;\n                }\n                else if (typeof c === `number`) {\n                    outW = c;\n                    if (typeof d === `number`) {\n                        outH = d;\n                    }\n                    else {\n                        throw new TypeError(`Missing final height value`);\n                    }\n                }\n                else\n                    throw new Error(`Missing valid output range`);\n            }\n            else if (isRect(b)) {\n                outW = b.width;\n                outH = b.height;\n            }\n            else {\n                throw new Error(`Expected input y or output Rect to follow first number parameter`);\n            }\n        }\n        else if (isPoint(a)) {\n            inX = a.x;\n            inY = a.y;\n            if (b === undefined)\n                return [inX, inY, outW, outH];\n            if (isRect(b)) {\n                outW = b.width;\n                outH = b.height;\n            }\n            else if (typeof b === `number`) {\n                outW = b;\n                if (typeof c === `number`) {\n                    outH = c;\n                }\n                else {\n                    throw new TypeError(`Expected height as third parameter after Point and output width`);\n                }\n            }\n            else {\n                throw new TypeError(`Expected Rect or width as second parameter when first parameter is a Point`);\n            }\n        }\n        else {\n            throw new Error(`Expected input Point or x value as first parameter`);\n        }\n        return [inX, inY, outW, outH];\n    };\n    const scaleAbs = (a, b, c, d) => {\n        const n = normalise(a, b, c, d);\n        return scaleNormalised(true, ...n);\n    };\n    const scaleRel = (a, b, c, d) => {\n        const n = normalise(a, b, c, d);\n        return scaleNormalised(false, ...n);\n    };\n    const scaleNormalised = (abs, x, y, w, h) => {\n        if (Number.isNaN(w))\n            throw new Error(`Output width range missing`);\n        if (Number.isNaN(h))\n            throw new Error(`Output height range missing`);\n        // If output dimensions has changed since last, create a new scale\n        if (w !== sw || h !== sh) {\n            sw = w;\n            sh = h;\n            s = computeScale();\n        }\n        return abs ? {\n            x: x * s.x,\n            y: y * s.y,\n        } : {\n            x: x / s.x,\n            y: y / s.y,\n        };\n    };\n    return {\n        computeScale,\n        rel: scaleRel,\n        abs: scaleAbs,\n        width: defaultBounds.width,\n        height: defaultBounds.height\n    };\n};\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }\n","import { degreeToRadian, radianArc, radiansSum } from '../angles.js';\nimport { guard as guardPoint, isPoint } from '../point/guard.js';\nimport { distance as pointsDistance } from '../point/distance.js';\nimport { bbox as pointsBbox } from '../point/bbox.js';\nimport { toCartesian } from '../polar/index.js';\nimport { fromPoints as LinesFromPoints } from '../line/from-points.js';\nimport { piPi } from '../pi.js';\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns\n */\nexport const isArc = (p) => typeof p.startRadian !== `undefined` && typeof p.endRadian !== `undefined` && typeof p.clockwise !== `undefined`;\n/**\n * Returns true if parameter has a positioned (x,y)\n * @param p Point, Arc or ArcPositiond\n * @returns\n */\nexport const isPositioned = (p) => typeof p.x !== `undefined` && typeof p.y !== `undefined`;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */\nexport function fromDegrees(radius, startDegrees, endDegrees, clockwise, origin) {\n    const a = {\n        radius,\n        startRadian: degreeToRadian(startDegrees),\n        endRadian: degreeToRadian(endDegrees),\n        clockwise\n    };\n    if (isPoint(origin)) {\n        guardPoint(origin);\n        const ap = {\n            ...a,\n            x: origin.x,\n            y: origin.y\n        };\n        return Object.freeze(ap);\n    }\n    else {\n        return Object.freeze(a);\n    }\n}\n/**\n * Returns a {@link Geometry.Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc) => LinesFromPoints(point(arc, arc.startRadian), point(arc, arc.endRadian));\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc\n * @param origin\n * @returns\n */\nexport const getStartEnd = (arc, origin) => {\n    guard(arc);\n    const start = point(arc, arc.startRadian, origin);\n    const end = point(arc, arc.endRadian, origin);\n    return [start, end];\n};\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate\n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc, angleRadian, origin) => {\n    if (typeof origin === `undefined`) {\n        origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n    }\n    return {\n        x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n        y: (Math.sin(angleRadian) * arc.radius) + origin.y\n    };\n};\n/**\n * Throws an error if arc instance is invalid\n * @param arc\n */\nexport const guard = (arc) => {\n    if (typeof arc === `undefined`)\n        throw new TypeError(`Arc is undefined`);\n    if (isPositioned(arc)) {\n        guardPoint(arc, `arc`);\n    }\n    if (typeof arc.radius === `undefined`)\n        throw new TypeError(`Arc radius is undefined (${JSON.stringify(arc)})`);\n    if (typeof arc.radius !== `number`)\n        throw new TypeError(`Radius must be a number`);\n    if (Number.isNaN(arc.radius))\n        throw new TypeError(`Radius is NaN`);\n    if (arc.radius <= 0)\n        throw new TypeError(`Radius must be greater than zero`);\n    if (typeof arc.startRadian === `undefined`)\n        throw new TypeError(`Arc is missing 'startRadian' field`);\n    if (typeof arc.endRadian === `undefined`)\n        throw new TypeError(`Arc is missing 'startRadian' field`);\n    if (Number.isNaN(arc.endRadian))\n        throw new TypeError(`Arc endRadian is NaN`);\n    if (Number.isNaN(arc.startRadian))\n        throw new TypeError(`Arc endRadian is NaN`);\n    if (typeof arc.clockwise === `undefined`)\n        throw new TypeError(`Arc is missing 'clockwise field`);\n    if (arc.startRadian >= arc.endRadian)\n        throw new TypeError(`startRadian is expected to be les than endRadian`);\n};\n/**\n * Compute relative position on arc.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns\n */\nexport const interpolate = (amount, arc, allowOverflow, origin) => {\n    guard(arc);\n    const overflowOk = allowOverflow ?? false;\n    if (!overflowOk) {\n        if (amount < 0)\n            throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);\n        if (amount > 1)\n            throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);\n    }\n    const span = angularSize(arc); // angular size\n    const rel = span * amount;\n    const angle = radiansSum(arc.startRadian, rel, arc.clockwise);\n    //console.log(`interpolate span: ${ span.toFixed(2) } rel: ${ rel.toFixed(2) } angle: ${ angle.toFixed(2) } amt: ${ amount.toFixed(2) } cw: ${ arc.clockwise } start: ${ arc.startRadian }`);\n    return point(arc, angle, origin);\n    //return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc\n */\nexport const angularSize = (arc) => radianArc(arc.startRadian, arc.endRadian, arc.clockwise);\n/**\n * Creates a {@link Geometry.Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc\n * @returns Path\n */\nexport const toPath = (arc) => {\n    guard(arc);\n    return Object.freeze({\n        ...arc,\n        nearest: (_point) => { throw new Error(`not implemented`); },\n        interpolate: (amount) => interpolate(amount, arc),\n        bbox: () => bbox(arc),\n        length: () => length(arc),\n        toSvgString: () => toSvg(arc),\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        kind: `arc`\n    });\n};\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns\n */\nexport const fromCircle = (circle, startRadian, endRadian, clockwise = true) => {\n    const a = Object.freeze({\n        ...circle,\n        endRadian,\n        startRadian,\n        clockwise\n    });\n    return a;\n};\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns\n */\nexport const fromCircleAmount = (circle, startRadian, sizeRadian, clockwise = true) => {\n    const endRadian = radiansSum(startRadian, sizeRadian, clockwise);\n    return fromCircle(circle, startRadian, endRadian);\n};\n/**\n * Calculates the length of the arc\n * @param arc\n * @returns Length\n */\nexport const length = (arc) => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n/**\n * Calculates a {@link Geometry.Rect | Rect} bounding box for arc.\n * @param arc\n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc) => {\n    if (isPositioned(arc)) {\n        const middle = interpolate(0.5, arc);\n        const asLine = toLine(arc);\n        return pointsBbox(middle, asLine.a, asLine.b);\n    }\n    else {\n        return {\n            width: arc.radius * 2,\n            height: arc.radius * 2\n        };\n    }\n};\n/**\n * Creates an SV path snippet for arc\n * @returns\n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg = (a, b, c, d, e) => {\n    if (isArc(a)) {\n        if (isPositioned(a)) {\n            if (isPoint(b)) {\n                // Passing in a origin override\n                return toSvgFull(b, a.radius, a.startRadian, a.endRadian, c);\n            }\n            else {\n                // Using origin in arc\n                return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b);\n            }\n        }\n        else {\n            return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n        }\n    }\n    else {\n        if (c === undefined)\n            throw new Error(`startAngle undefined`);\n        if (d === undefined)\n            throw new Error(`endAngle undefined`);\n        if (isPoint(a)) {\n            if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n                return toSvgFull(a, b, c, d, e);\n            }\n            else {\n                throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n            }\n        }\n        else {\n            throw new Error(`Expected (point, number, number, number). Missing first point.`);\n        }\n    }\n};\nconst toSvgFull = (origin, radius, startRadian, endRadian, opts) => {\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n    // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n    // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n    if (opts === undefined || typeof opts !== `object`)\n        opts = {};\n    const isFullCircle = endRadian - startRadian === 360;\n    const start = toCartesian(radius, endRadian - 0.01, origin);\n    const end = toCartesian(radius, startRadian, origin);\n    const { largeArc = false, sweep = false } = opts;\n    const d = [`\n    M ${start.x} ${start.y}\n    A ${radius} ${radius} 0 ${largeArc ? `1` : `0`} ${sweep ? `1` : `0`} ${end.x} ${end.y},\n  `];\n    if (isFullCircle)\n        d.push(`z`);\n    return d;\n};\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b\n * @returns Distance\n */\nexport const distanceCenter = (a, b) => pointsDistance(a, b);\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a, b) => {\n    if (a.radius !== b.radius)\n        return false;\n    if (a.endRadian !== b.endRadian)\n        return false;\n    if (a.startRadian !== b.startRadian)\n        return false;\n    if (a.clockwise !== b.clockwise)\n        return false;\n    if (isPositioned(a) && isPositioned(b)) {\n        if (a.x !== b.x)\n            return false;\n        if (a.y !== b.y)\n            return false;\n        if (a.z !== b.z)\n            return false;\n    }\n    else if (!isPositioned(a) && !isPositioned(b)) {\n        // no-op\n    }\n    else\n        return false; // one is positioned one not\n    return true;\n};\n","import { toPositioned as circleToPositioned } from './circle/to-positioned.js';\nimport { scale, linearSpace } from '@ixfx/numbers';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(circle, opts = {}) {\n    const maxPoints = opts.maxPoints ?? 5000;\n    const density = opts.density ?? 0.95;\n    const rotationOffset = opts.rotation ?? 0;\n    const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n    const max = c.radius;\n    //eslint-disable-next-line functional/no-let\n    let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n    if (opts.spacing)\n        spacing = opts.spacing;\n    //eslint-disable-next-line functional/no-let\n    let radius = 0;\n    //eslint-disable-next-line functional/no-let\n    let count = 0;\n    //eslint-disable-next-line functional/no-let\n    let angle = 0;\n    while (count < maxPoints && radius < max) {\n        radius = spacing * count ** 0.5;\n        angle = rotationOffset + (count * 2 * pi) / goldenSection;\n        yield Object.freeze({\n            x: c.x + radius * cos(angle),\n            y: c.y + radius * sin(angle),\n        });\n        count++;\n    }\n}\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(circle, opts = {}) {\n    const rings = opts.rings ?? 5;\n    const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n    const ringR = 1 / rings;\n    const rotationOffset = opts.rotation ?? 0;\n    //eslint-disable-next-line functional/no-let\n    let ringCount = 1;\n    // Origin\n    yield Object.freeze({ x: c.x, y: c.y });\n    //eslint-disable-next-line functional/no-let\n    for (let r = ringR; r <= 1; r += ringR) {\n        const n = Math.round(pi / asin(1 / (2 * ringCount)));\n        for (const theta of linearSpace(0, piPi, n + 1)) {\n            yield Object.freeze({\n                x: c.x + r * cos(theta + rotationOffset) * c.radius,\n                y: c.y + r * sin(theta + rotationOffset) * c.radius,\n            });\n        }\n        ringCount++;\n    }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(samples = 100, rotationRadians = 0, sphere) {\n    const offset = 2 / samples;\n    const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n    for (let index = 0; index < samples; index++) {\n        const y = index * offset - 1 + offset / 2;\n        const r = sqrt(1 - pow(y, 2));\n        const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n        const x = cos(a) * r;\n        const z = sin(a) * r;\n        //eslint-disable-next-line functional/immutable-data\n        yield Object.freeze({\n            x: s.x + x * s.radius,\n            y: s.y + y * s.radius,\n            z: s.z + z * s.radius,\n        });\n    }\n}\n","import { angleRadian as PointsAngleRadian } from '../point/angle.js';\nimport { guard } from \"./guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t) => {\n    guard(t);\n    return [\n        PointsAngleRadian(t.a, t.b),\n        PointsAngleRadian(t.b, t.c),\n        PointsAngleRadian(t.c, t.a),\n    ];\n};\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t) => {\n    guard(t);\n    return radianToDegree(angles(t));\n};\n","import { joinPointsToLines } from \"../line/join-points-to-lines.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t) => {\n    guard(t);\n    return joinPointsToLines(t.a, t.b, t.c, t.a);\n};\n","import { guard } from \"./guard.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t) => {\n    guard(t, `t`);\n    // Get length of edges\n    const lengths = edges(t).map((l) => LinesLength(l));\n    // Add up length of edges, halve\n    const p = (lengths[0] + lengths[1] + lengths[2]) / 2;\n    return Math.sqrt(p * (p - lengths[0]) * (p - lengths[1]) * (p - lengths[2]));\n};\n","import { getPointParameter } from \"../point/get-point-parameter.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (t, a, b) => {\n    const pt = getPointParameter(a, b);\n    const ab = (x, y, pa, pb) => (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n    const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n    const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n    const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n    return {\n        a: alpha,\n        b: theta,\n        c: gamma,\n    };\n};\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (t, bc) => {\n    guard(t);\n    const { a, b, c } = t;\n    const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n    const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n    if (a.z && b.z && c.z) {\n        const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n        return Object.freeze({ x, y, z });\n    }\n    else {\n        return Object.freeze({ x, y });\n    }\n};\n","/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t, inflation = 0) => {\n    const { a, b, c } = t;\n    const xMin = Math.min(a.x, b.x, c.x) - inflation;\n    const xMax = Math.max(a.x, b.x, c.x) + inflation;\n    const yMin = Math.min(a.y, b.y, c.y) - inflation;\n    const yMax = Math.max(a.y, b.y, c.y) + inflation;\n    const r = {\n        x: xMin,\n        y: yMin,\n        width: xMax - xMin,\n        height: yMax - yMin,\n    };\n    return r;\n};\n","import { guard } from \"./guard.js\";\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t) => {\n    guard(t);\n    return [t.a, t.b, t.c];\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\nimport { fromNumbers as PointsFromNumbers } from \"../point/from.js\";\nimport { guard as PointGuard } from \"../point/guard.js\";\nimport { piPi } from \"../pi.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/conversions.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (origin, radius, opts = {}) => {\n    throwNumberTest(radius, `positive`, `radius`);\n    PointGuard(origin, `origin`);\n    const initialAngleRadian = opts.initialAngleRadian ?? 0;\n    const angles = [\n        initialAngleRadian,\n        initialAngleRadian + (piPi * 1) / 3,\n        initialAngleRadian + (piPi * 2) / 3,\n    ];\n    const points = angles.map((a) => PolarToCartesian(radius, a, origin));\n    return fromPoints(points);\n};\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords) => {\n    if (!Array.isArray(coords))\n        throw new Error(`coords expected as array`);\n    if (coords.length !== 6) {\n        throw new Error(`coords array expected with 6 elements. Got ${coords.length}`);\n    }\n    return fromPoints(PointsFromNumbers(...coords));\n};\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points) => {\n    if (!Array.isArray(points))\n        throw new Error(`points expected as array`);\n    if (points.length !== 3) {\n        throw new Error(`points array expected with 3 elements. Got ${points.length}`);\n    }\n    const t = {\n        a: points[0],\n        b: points[1],\n        c: points[2],\n    };\n    return t;\n};\n","import { guard } from \"./guard.js\";\nimport { distance } from \"../point/distance.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t) => {\n    guard(t);\n    return [\n        distance(t.a, t.b),\n        distance(t.b, t.c),\n        distance(t.c, t.a),\n    ];\n};\n","import { angles } from \"./angles.js\";\nimport { guard } from \"./guard.js\";\nimport { lengths } from \"./lengths.js\";\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t) => {\n    guard(t);\n    const [a, b, c] = lengths(t);\n    return a === b && b === c;\n};\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t) => {\n    const [a, b, c] = lengths(t);\n    if (a === b)\n        return true;\n    if (b === c)\n        return true;\n    if (c === a)\n        return true;\n    return false;\n};\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t) => angles(t).includes(Math.PI / 2);\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t) => !isRightAngle(t);\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t) => !angles(t).some((v) => v >= Math.PI / 2);\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t) => angles(t).some((v) => v > Math.PI / 2);\n","import { guard } from \"./guard.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t) => {\n    guard(t);\n    return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};\n","import { area } from \"./area.js\";\nimport { centroid } from \"./centroid.js\";\nimport { perimeter } from \"./perimeter.js\";\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t) => {\n    const c = centroid(t);\n    const p = perimeter(t) / 2;\n    const a = area(t);\n    const radius = a / p;\n    return { radius, ...c };\n};\n","import { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\nimport { centroid } from './centroid.js';\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t) => {\n    const [a, b, c] = edges(t).map((l) => LinesLength(l));\n    const cent = centroid(t);\n    const radius = (a * b * c) /\n        Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n    return {\n        radius,\n        ...cent,\n    };\n};\n","import { centroid } from \"./centroid.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n *\n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport const rotate = (triangle, amountRadian, origin) => {\n    if (amountRadian === undefined || amountRadian === 0)\n        return triangle;\n    if (origin === undefined)\n        origin = centroid(triangle);\n    return Object.freeze({\n        ...triangle,\n        a: PointsRotate(triangle.a, amountRadian, origin),\n        b: PointsRotate(triangle.b, amountRadian, origin),\n        c: PointsRotate(triangle.c, amountRadian, origin),\n    });\n};\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport const rotateByVertex = (triangle, amountRadian, vertex = `b`) => {\n    const origin = vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n    return Object.freeze({\n        a: PointsRotate(triangle.a, amountRadian, origin),\n        b: PointsRotate(triangle.b, amountRadian, origin),\n        c: PointsRotate(triangle.c, amountRadian, origin),\n    });\n};\n","const pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\nconst resolveLength = (t) => {\n    if (typeof t === `number`)\n        return t;\n    return t.length;\n};\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * * ▶️ 0: a and c on vertical, b at the tip\n * * ◀️ Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * * 🔽 Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * * 🔼 Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (t, origin, rotationRad) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const r = resolveLength(t) / Math.sqrt(3);\n    const rot = rotationRad ?? Math.PI * 1.5;\n    const b = {\n        x: r * Math.cos(rot) + origin.x,\n        y: r * Math.sin(rot) + origin.y,\n    };\n    const a = {\n        x: r * Math.cos(rot + pi4over3) + origin.x,\n        y: r * Math.sin(rot + pi4over3) + origin.y,\n    };\n    const c = {\n        x: r * Math.cos(rot + pi2over3) + origin.x,\n        y: r * Math.sin(rot + pi2over3) + origin.y,\n    };\n    return Object.freeze({ a, b, c });\n};\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (t, ptA) => {\n    if (!ptA)\n        ptA = Object.freeze({ x: 0, y: 0 });\n    const r = resolveLength(t);\n    const { radius } = incircle(t);\n    return {\n        x: ptA.x + r / 2,\n        y: ptA.y - radius,\n    };\n};\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (t, ptB) => {\n    if (!ptB)\n        ptB = Object.freeze({ x: 0, y: 0 });\n    const { radius } = incircle(t);\n    return {\n        x: ptB.x,\n        y: ptB.y + radius * 2,\n    };\n};\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (t, ptC) => {\n    if (!ptC)\n        ptC = Object.freeze({ x: 0, y: 0 });\n    const r = resolveLength(t);\n    const { radius } = incircle(t);\n    return {\n        x: ptC.x - r / 2,\n        y: ptC.y - radius,\n    };\n};\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t) => (Math.sqrt(3) / 2) * resolveLength(t);\nexport const perimeter = (t) => resolveLength(t) * 3;\nexport const area = (t) => (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t) => ({\n    radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t) => ({\n    radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const tt = resolveLengths(t);\n    const seg = hypotenuseSegments(t);\n    const h = height(t);\n    const a = { x: origin.x, y: origin.y };\n    const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n    const c = { x: origin.x + seg[1], y: origin.y - h };\n    return { a, b, c };\n};\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const tt = resolveLengths(t);\n    const seg = hypotenuseSegments(t);\n    const h = height(t);\n    const b = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n    const c = { x: origin.x - seg[0], y: origin.y - h };\n    return { a, b, c };\n};\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const seg = hypotenuseSegments(t);\n    const h = height(t);\n    const c = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - seg[1], y: origin.y + h };\n    const b = { x: origin.x + seg[0], y: origin.y + h };\n    return { a, b, c };\n};\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t) => {\n    const a = t.adjacent;\n    const o = t.opposite;\n    const h = t.hypotenuse;\n    if (a !== undefined && o !== undefined) {\n        return {\n            ...t,\n            adjacent: a,\n            opposite: o,\n            hypotenuse: Math.hypot(a, o),\n        };\n    }\n    else if (a && h) {\n        return {\n            ...t,\n            adjacent: a,\n            hypotenuse: h,\n            opposite: h * h - a * a,\n        };\n    }\n    else if (o && h) {\n        return {\n            ...t,\n            hypotenuse: h,\n            opposite: o,\n            adjacent: h * h - o * o,\n        };\n    }\n    else if (t.opposite && t.hypotenuse && t.adjacent) {\n        return t;\n    }\n    throw new Error(`Missing at least two edges`);\n};\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t) => {\n    const tt = resolveLengths(t);\n    const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n    const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n    return Math.sqrt(p * q);\n};\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (t) => {\n    const tt = resolveLengths(t);\n    const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n    const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n    return [p, q];\n};\nexport const perimeter = (t) => {\n    const tt = resolveLengths(t);\n    return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\nexport const area = (t) => {\n    const tt = resolveLengths(t);\n    return (tt.opposite * tt.adjacent) / 2;\n};\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t) => {\n    const tt = resolveLengths(t);\n    return Math.acos((tt.adjacent * tt.adjacent +\n        tt.hypotenuse * tt.hypotenuse -\n        tt.opposite * tt.opposite) /\n        (2 * tt.adjacent * tt.hypotenuse));\n};\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t) => {\n    const tt = resolveLengths(t);\n    return Math.acos((tt.opposite * tt.opposite +\n        tt.hypotenuse * tt.hypotenuse -\n        tt.adjacent * tt.adjacent) /\n        (2 * tt.opposite * tt.hypotenuse));\n};\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (t) => {\n    const tt = resolveLengths(t);\n    const b = tt.adjacent * tt.adjacent;\n    const c = tt.hypotenuse * tt.hypotenuse;\n    const a = tt.opposite * tt.opposite;\n    return [\n        Math.sqrt(2 * (b + c) - a) / 2,\n        Math.sqrt(2 * (c + a) - b) / 2,\n        Math.sqrt(2 * (a + b) - c) / 2,\n    ];\n};\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t) => {\n    const tt = resolveLengths(t);\n    return { radius: tt.hypotenuse / 2 };\n};\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t) => {\n    const tt = resolveLengths(t);\n    return {\n        radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n    };\n};\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (angleRad, adjacent) => Math.tan(angleRad) * adjacent;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (angleRad, hypotenuse) => Math.sin(angleRad) * hypotenuse;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport const adjacentFromHypotenuse = (angleRadian, hypotenuse) => Math.cos(angleRadian) * hypotenuse;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (angleRadian, opposite) => opposite / Math.tan(angleRadian);\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const hypotenuseFromOpposite = (angleRadian, opposite) => opposite / Math.sin(angleRadian);\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (angleRadian, adjacent) => adjacent / Math.cos(angleRadian);\n","export const baseAngle = (t) => Math.acos(t.base / (2 * t.legs));\nexport const apexAngle = (t) => {\n    const aa = t.legs * t.legs;\n    const cc = t.base * t.base;\n    return Math.acos((2 * aa - cc) / (2 * aa));\n};\nexport const height = (t) => {\n    const aa = t.legs * t.legs;\n    const cc = t.base * t.base;\n    return Math.sqrt((4 * aa - cc) / 4);\n};\nexport const legHeights = (t) => {\n    const b = baseAngle(t);\n    return t.base * Math.sin(b);\n};\nexport const perimeter = (t) => 2 * t.legs + t.base;\nexport const area = (t) => {\n    const h = height(t);\n    return (h * t.base) / 2;\n};\nexport const circumcircle = (t) => {\n    const h = height(t);\n    const hh = h * h;\n    const cc = t.base * t.base;\n    return { radius: (4 * hh + cc) / (8 * h) };\n};\nexport const incircle = (t) => {\n    const h = height(t);\n    return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\nexport const medians = (t) => {\n    const aa = t.legs * t.legs;\n    const cc = t.base * t.base;\n    const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n    const medianC = Math.sqrt(4 * aa - cc) / 2;\n    return [medianAB, medianAB, medianC];\n};\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const incircleR = incircle(t).radius;\n    const verticalToApex = h - incircleR;\n    const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n    const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n    const c = { x: origin.x, y: origin.y - verticalToApex };\n    return { a, b, c };\n};\nexport const fromA = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const a = { x: origin.x, y: origin.y };\n    const b = { x: origin.x + t.base, y: origin.y };\n    const c = { x: origin.x + t.base / 2, y: origin.y - h };\n    return { a, b, c };\n};\nexport const fromB = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const b = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - t.base, y: origin.y };\n    const c = { x: origin.x - t.base / 2, y: origin.y - h };\n    return { a, b, c };\n};\nexport const fromC = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const c = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - t.base / 2, y: origin.y + h };\n    const b = { x: origin.x + t.base / 2, y: origin.y + h };\n    return { a, b, c };\n};\n","export * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './kinds.js';\nexport * from './inner-circle.js';\nexport * from './guard.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\nexport * as Isosceles from './isosceles.js';\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n"],"x_google_ignoreList":[11,12,13],"mappings":"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"}