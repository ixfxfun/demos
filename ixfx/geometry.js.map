{"version":3,"file":"geometry.js","names":["p: Point","isNaN","guard","pt: Point | Point3d","p: number | unknown","p: Point | unknown","fromPoints","a: Point","b: Point","guardPoint","lines: Line[]","fromPoints","p: any","guard","line: Line","getPointParameter","aOrLine: Point | Line","b?: Point","guardPoint","aOrLine: Point | Line | PolyLine","pointB?: Point","sum","getPointParameter","line: Line","guard","interpolate","amount: number","aOrLine: Point | Line","pointBOrAllowOverflow?: Point | boolean","allowOverflow?: boolean","getPointParameter","line: Line","distance: number","fromA","distance","line: Line","distance: number","distance","interpolate","aOrLine: Point | Line","pointB?: Point","getPointParameter","interpolate","d: number","guard","rect: Rect","isPositioned","PointsGuard","rect: Rect | RectPositioned","origin?: Point","rect: RectPositioned","isEmpty","isPlaceholder","rect: Point | Rect | RectPositioned","rect: unknown","rect: any","a: Point | number","b: number | Rect","c?: number","d?: number","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","b","a","a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>","b?: number | boolean","c?: number","a: Point | Point3d","xOrB?: Point | Point3d | number","y?: number","z?: number","guard","nearest","line: Line | readonly Line[]","point: Point","line: Line","line","point","length","PointsDistance","line: Line","point: Point","guard","guardPoint","point","nearest","comparer: ((a: Point, b: Point) => Point)|((a: Point3d, b: Point3d) => Point3d)","topLeft: Point","topRight: Point","bottomRight: Point","bottomLeft: Point","bbox","RectsMaxFromCorners","a: Point3d","b: Point3d","bbox","line: Line","PointsBbox","divide","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","guard","pt: Writeable<Point>","a: Point3d | Point | number | number[]","b?: number","c?: number","aa: Point3d | Point | number | number[]","bb?: number","cc?: number","divide","line: Line","point: Point","PointDivide","point","fromNumbers","x1: number","y1: number","x2: number","y2: number","fromPoints","fromFlatArray","array: readonly number[]","fromNumbers","p: unknown","guard","p: Coord","angleInDegrees: number | readonly number[]","angleInRadians: number","angleInDegrees: number","angleInGradians: number","wrap","angleInGradian: number","angleInRadians: number | readonly number[]","point: Point","point","start: number","amount: number","end: number","value: string | number | Angle","v: any","angleOrDegrees: Angle | number | string","destination: Angle[ `unit` ]","turns: number","degrees: number","radians: number","rotate","c: Coord","amountRadian: number","invert","p: Coord","guard","a: Coord","b: Coord","amountDeg: number","subtract","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","guard","pt: Writeable<Point>","Empty","toCartesian: PolarToCartesian","a: Coord | number","b?: Point | number","c?: Point","EmptyPoint","point: Point","origin: Point","point","subtractPoint","distance: number","angleRadians: number","guardPoint","distance","toString","p: Coord","digits?: number","v: Coord","guard","normalise","c: Coord","clampMagnitude","v: Coord","dotProduct","a: Coord","b: Coord","guard","multiply","amt: number","divide","Placeholder","a: Point","b?: Point","c?: Point","guard","pt: Point","rounder: (x: number) => number","guard","z: number","toString","p: Point","digits?: number","toCartesian","ray: PolarRay","origin?: Point","polarToCartesian","toString","pointToString","line: Line","smoothness: number","zoom: number","step: number","origin: Point","length: number","angleRadian: number","balance: number","length","angleRadian","a: Point","b: Point","toPath","fromPoints","isEqual","isEqual","a: Line","b: Line","PointsIsEqual","pt: Point","apply","pt: Point","fn: Point3dApplyFn | PointApplyFn","guard","kind: PointAverageKinds","opts: any","x: (v: number) => number","y: (v: number) => number","z: (v: number) => number","mal","point: Point","point","centroid","sum","clamp","a: Point","clampNumber","a: Point","b: Point","a: Point3d","b: Point3d","points: Array<Point>","v: Array<Point>","isEqual","guard","circle: CirclePositioned | Circle","guardPoint","guardPositioned","circle: CirclePositioned","a: Circle | CirclePositioned","isPositioned","p: Circle | Point","p: any","distanceCenter","a: CirclePositioned","b: CirclePositioned | Point","guardPositioned","pointsDistance","distanceFromExterior","a: CirclePositioned","b: CirclePositioned | Point","guardPositioned","distanceCenter","PointsIsPoint","PointsDistance","isEqual","a: CirclePositioned | Circle","b: CirclePositioned | Circle","sum","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","guard","pt: Writeable<Point>","circle: CirclePositioned","line: Line","returnValue: Point[]","a: CirclePositioned","b: CirclePositioned","PointsSubtract","isEqual","centroid","PointsSum","a: CirclePositioned","b: RectPositioned","b: CirclePositioned","circleIntersections","rect: Rect | RectPositioned","a: Point | number","b?: number","guard","isPositioned","isIntersecting","a: RectPositioned","b: CirclePositioned | Point","center","rect: RectPositioned | Rect","origin?: Point","guard","rect: RectPositioned","pt: Point","PointsGuard","PointsDistance","center","a: Point","shape: PointCalculableShape","rectDistanceFromExterior","circleDistanceFromExterior","a: Point","shape: PointCalculableShape","rectDistanceFromExterior","circleDistanceFromExterior","toArray","p: Point","dotProduct","toArray","ArraysDotProduct","xOrArray?: number | readonly number[]","y?: number","z?: number","string_: string","pts: Point[]","interpolate","amount: number","a: Point","b: Point","lineInterpolate","pt: Point | Point3d","what: `both` | `x` | `y` | `z`","multiply","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","guard","pt: Writeable<Point>","multiplyScalar","pt: Point | Point3d","v: number","pt: Point","length","multiply","length","ptOrX: Point | number","y?: number","Empty","point: Point","point","pipeline","pt: Point","piPi","pi","radians: number","point: Point","point","pt: Point","angleNormalisation: `` | `unipolar` | `bipolar`","origin: Point","PointsSubtract","PointsDistance","line: Line","LinesGuard","v: Vector","normalise","PointsNormalise","p: Point","PointEmpty","toCartesian","toString","digits?: number","PointsToString","dotProduct","a: Vector","b: Vector","PointsDotProduct","clampMagnitude","PointsClampMagnitude","sum","PointsSum","subtract","multiply","PointsMultiply","divide","PointDivide","a: Point | number","b?: number","aa: Point | number","bb?: number","centroid","opts: TrackOpts","_reason: TrimReason","p: PointerEvent | MouseEvent","asPoints","_p: TimestampedObject<Point>[]","initialRel: PointTrack","markRel: PointTrack | undefined","LineLength","lastRel: PointTrack","r: PointTrackerResults","LinesEmpty","subtract","PointsPlaceholder","event: PointerEvent","position: Point | Point3d","waypointA: Point | Point3d","waypointB: Point | Point3d","subtract","origin: Point","distance: number","angle: number","distance","quantiseEvery","pt: Point","snap: Point","guard","quantiseEveryNumber","random","rando?: RandomSource","pts: ReadonlyArray<Point>","fn: (p: Point, accumulated: Point) => Point","initial?: Point","pt: Point | readonly Point[]","amountRadian: number","origin?: Point","guard","PolarFromCartesian","PolarRotate","PolarToCartesian","v: ReadonlyArray<ReadonlyArray<number>>","amountRadian: number","result:number[][]","round","ptOrX: Point | number","yOrDigits?: number","digits?: number","roundNumber","withinRange","a: Point","b: Point","maxRange: Point | number","guard","wrap","pt: Point","ptMax?: Point","ptMin?: Point","guard","wrapNumber","multiply","line: Line","point: Point","PointsMultiply","point","relativePosition","line: Line","pt: Point","PointsDistance","rotate","line: Line","amountRadian?: number","origin?: Point | number","interpolate","PointRotate","subtract","line: Line","point: Point","PointsSubtract","point","sum","line: Line","point: Point","PointsSum","point","toString","a: Point | Line","b?: Point","guard","PointsToString","Empty","Placeholder","isEmpty","l: Line","PointIsEmpty","isPlaceholder","PointIsPlaceholder","apply","line: Line","fn: (p: Point) => Point","angleRadian","lineOrPoint: Line | Point","b?: Point","a: Point","normaliseByRect","width: number","height: number","PointsNormaliseByRect","height","point: Point","maxRange: number","distance","point","factor: number","interpolate","x: number","distance: number","line: Line | readonly Line[]","toFlatArray","a: Point | Line","b: Point","lines: Iterable<Line>","toSvgString","toPath","line: Line","amount: number","interpolate","point: Point","relativePosition","point","bbox","toString","toFlatArray","toSvgString","amountRadian: number","origin: Point","rotate","nearest","sum","divide","multiply","subtract","distance: number","distance","amount?: number","maxRange: number","otherLine: Line","isEqual","fn: (point: Point) => Point","apply","fromPoints","waypoints: readonly Point[]","opts: Partial<WaypointOpts>","toPath","paths: readonly Path[]","pt: Point","nearest","distance","PointsDistance","Empty","Placeholder","origin?: Point","length","angleRadian: number","PointsProject","angleRadian","corners","rect: RectPositioned | Rect","origin?: Point","origin: Point","width: number","height: number","height","PointsGuard","origin: Point","from: `tip` | `tail` | `middle`","opts: ArrowOpts","angleRadian","tri: Triangle","tailPoints: ReadonlyArray<Point>","from","RectsCorners","RectsFromTopLeft","arrow","PointsRotate","piPi","randomPoint","within: Circle | CirclePositioned","opts: Partial<CircleRandomPointOpts>","offset: Point","PointsSum","offset","PolarToCartesian","random","rando?: RandomSource","randomPoint","within: Rect | RectPositioned","options: RectRandomPointOpts","isPositioned","PointsSum","circle: CirclePositioned | Circle","t: Triangle","PointsGuard","p: unknown","isEmpty","PointsIsEmpty","isPlaceholder","PointsIsPlaceholder","isEqual","a: Triangle","b: Triangle","PointsIsEqual","t: Triangle","PointsReduce","p: Point","accumulator: Point","shape: ShapePositioned","opts: Partial<ShapeRandomPointOpts>","circleRandomPoint","rectRandomPoint","center","shape?: Rect | Triangle | Circle","rectCenter","triangleCentroid","circleCenter","a: CirclePositioned","b: CirclePositioned | Point","c?: number","distanceCenter","a: CirclePositioned","b: CirclePositioned | Point | RectPositioned","c?: number","PointsIsEqual","isIntersecting","a: ShapePositioned","b: ShapePositioned | Point","CirclesIsIntersecting","RectsIsIntersecting","outerRadius: number","innerRadius?: number","origin: Point","PointEmpty","opts?: { readonly initialAngleRadian?: number }","pts: Point[]","circles: readonly Circle[]","container: ShapePositioned","opts: RandomOpts","positionedCircles: CirclePositioned[]","b: Point","radius: number","CirclesIsIntersecting","ShapesRandomPoint","area","circle: Circle","guard","fromCenter","origin: Point","width: number","height: number","PointsGuard","height","bbox","circle: CirclePositioned | Circle","RectsFromCenter","circle: CirclePositioned","circle: CirclePositioned","piPi","circle: CirclePositioned | readonly CirclePositioned[]","point: Point","a: CirclePositioned","point","PointsDistance","circle: Circle | CirclePositioned","angleRadian: number","origin?: Point","angleRadian","circle: Circle","guard","length","piPi","interpolate","circle: CirclePositioned","t: number","multiplyScalar","a: Circle | CirclePositioned","value: number","PointsMultiplyScalar","toSvg: CircleToSvg","a: CirclePositioned | number | Circle","sweep: boolean","origin?: Point","toSvgFull","radius: number","origin: Point","toPath","circle: CirclePositioned","guard","point: Point","point","t: number","interpolate","bbox","toSvg","_point: Point","_intersectionThreshold: number","circle: Circle | CirclePositioned","defaultPositionOrX?: Point | number","y?: number","area","rect: Rect","guard","op: ApplyFieldOp","rectOrWidth: RectPositioned | Rect | number","heightValue?: number","height","isPositioned","op: ApplyMergeOp","a: RectPositioned | Rect","b: Rect | number","c?: number","guard","rect: Rect | RectPositioned","parameter: number","rect: RectPositioned","card: GridCardinalDirection | `center`","height","a: number","b: number","a: RectPositioned | Rect","b: Rect | number","c?: number","rect: Rect | RectPositioned","amount: number","edges","rect: RectPositioned | Rect","origin?: Point","corners","LinesJoinPointsToLines","edge: `right` | `bottom` | `left` | `top`","guard","rect: RectPositioned","el: HTMLElement","fromNumbers","xOrWidth: number","yOrHeight: number","width?: number","height?: number","height","a: number | Point | Rect | RectPositioned","b?: Rect | number | Point","c?: number | Rect","d?: number","a: Rect","b: Rect","isEqual","a: Rect | RectPositioned","b: Rect | RectPositioned","isPositioned","PointsIsEqual","lengths","rect: RectPositioned","edges","LinesLength","a: number","b: number","a: RectPositioned | Rect","b: Rect | number","c?: number","rect: Rect | RectPositioned","amount: number","rect: RectPositioned","p: Point","perimeter","rect: Rect","guard","rect: Rect","value: number | Point","a: number","b: number","a: Rect | undefined","b: RectPositioned | Rect | number","c?: number","a: Rect | RectPositioned","b: Rect | number","a: RectPositioned | Rect","b: RectPositioned | Rect","isPositioned","a: number","b: number","a: Rect","b: RectPositioned | Rect | number","c?: number","a: RectPositioned | Rect","b: RectPositioned | Rect","isPositioned","rect: Rect | RectPositioned","isPositioned","path: Path | QuadraticBezier | CubicBezier","path: Path | CubicBezier | QuadraticBezier","path: Path","compoundPath: CompoundPath","index: number","path: Path","interpolate","paths: readonly Path[]","t: number","useWidth?: boolean","dimensions?: Dimensions","point: Point","point","intersectionThreshold: number","lengths","length","bbox","corners","RectsCorners","PointsBbox","PointsIsEqual","_: Point","grid: Grid","cell: GridCell","cell: GridCell | undefined","cell: GridCell","grid?: Grid","grid: Grid","grid: Grid","cell: GridCell","wrap: GridBoundsLogic","wrap","access","array: readonly V[]","cols: number","fn: GridCellAccessor<V>","cell: GridCell","wrap: GridBoundsLogic","accessWithGrid","wrap","grid: Grid","array: readonly T[] | T[]","setMutate","array: V[]","value: V","setMutateWithGrid","set","setWithGrid","wrapMutable","array: T[]","boundsLogic: GridBoundsLogic","value: T","initialValue: T","rowsOrGrid: number | Grid","columns?: number","rows","columns","t: T[]","create","array: ReadonlyArray<T[]> | Array<T[]>","array: V[][]","value: V","cell: GridCell","wrap: GridBoundsLogic","wrap","grid: Grid","bounds: GridBoundsLogic","array: ReadonlyArray<T[]>","fn: GridCellAccessor<T>","array: T[][]","array: readonly V[][]","boundsLogic: GridBoundsLogic","value: T","grid: GridReadable<T>","iter: Iterable<GridCell> | Iterable<GridCell[]>","grid: Grid","start?: GridCell","wrap","grid: GridReadable<T>","grid: Grid","start?: GridCell","rowCells: Array<GridCell>","colCells: Array<GridCell>","grid: Grid","start: GridCell","vector: GridCell","bounds: GridBoundsLogic","grid: Grid","start: GridCell","steps: number","bounds: GridBoundsLogic","cells","cardinal: GridCardinalDirectionOptional","cardinal","start: GridCell","end: GridCell","cells:GridCell[]","cells","cells: Array<GridCell>","grid: Grid","cell: GridCell","wrap: GridBoundsLogic","wrap","colsOrGrid: number | Grid","index: number","isEqual","a: Grid | GridVisual","b: Grid | GridVisual","a: GridCell | undefined","b: GridCell | undefined","nbos: readonly GridNeighbour[]","n: GridNeighbour | GridNeighbourMaybe | undefined","grid: Grid","cell: GridCell","directions: readonly GridCardinalDirection[]","bounds: GridBoundsLogic","directions?: readonly GridCardinalDirection[]","grid: Grid","initialValue?: V","returnValue:V[][]","v: GridCell","grid: GridVisual","position: Point","cell: GridCell","RectsFromTopLeft","neighbours: readonly GridNeighbour[]","neighbours","opts: Partial<GridVisitorOpts>","t: Array<GridNeighbour>","opts: Partial<GridVisitorOpts>","nbos: ReadonlyArray<GridNeighbour>","grid: Grid","cell: GridCell","logic: GridNeighbourSelectionLogic","grid: Grid","opts: Partial<GridVisitorOpts>","g: Grid","c: GridCell","cellQueue: GridCell[]","moveQueue: GridNeighbour[]","current: GridCell | undefined","grid: Grid","createVisitor: GridCreateVisitor","start: GridCell","steps: GridCell[]","step: number","type: VisitorTypes","opts: Partial<GridVisitorOpts>","logic: GridNeighbourSelectionLogic","options: Partial<GridVisitorOpts>","grid: Grid","optionsOverride: Partial<GridVisitorOpts>","start: Point","end: Point","LinesInterpolate","q: QuadraticBezier | CubicBezier","BezierLibrary","amount: number","handle: Point","toPath","cubicOrQuadratic: CubicBezier | QuadraticBezier","cubic1: Point","cubic2: Point","cubic: CubicBezier","cubic","t: number","_: Point","RectsFromTopLeft","_point: Point","_intersectionThreshold: number","quadraticBezier: QuadraticBezier","quadratic","fromDegrees","radiusX: number","radiusY: number","points: Array<Point>","p: Point","p1: Point","p2: Point","slope","index: Point","index_: Point","bounds: RectPositioned","initialData: readonly QuadTreeItem[]","opts: Partial<QuadTreeOpts>","o: QuadTreeOpts","parent: QuadTreeNode | undefined","boundary: RectPositioned","level: number","opts: QuadTreeOpts","#parent","#children","n: QuadTreeNode | undefined","#items","d: Direction","p: QuadTreeItem","#subdivide","p: Point","RectsIntersectsPoint","PointsFromNumbers","RectsFromTopLeft","scaleBy: ScaleBy","defaultRect?: Rect","PlaceholderRect","normalise","a: number | Point","b?: number | Rect","c?: number | Rect","d?: number","abs: boolean","x: number","y: number","w: number","h: number","abs","p: unknown","p: Point | Arc | ArcPositioned","radius: number","startDegrees: number","endDegrees: number","clockwise: boolean","origin?: Point","a: Arc","guardPoint","ap: ArcPositioned","arc: ArcPositioned","LinesFromPoints","arc: ArcPositioned | Arc","guard","arc: Arc | ArcPositioned","angleRadian: number","angleRadian","interpolate: ArcInterpolate","amount: number","allowOverflow?: boolean","arc: Arc","_point: Point","bbox","length","_intersectionThreshold: number","circle: CirclePositioned","startRadian: number","endRadian: number","a: ArcPositioned","sizeRadian: number","pointsBbox","toSvg: ArcToSvg","a: Point | Arc | ArcPositioned","b?: number | Point | ArcSvgOpts","c?: number | ArcSvgOpts","d?: number","e?: ArcSvgOpts","origin: Point","opts?: ArcSvgOpts","b: ArcPositioned","pointsDistance","a: Arc | ArcPositioned","b: Arc | ArcPositioned","piPi","circle?: Circle","opts: VogelSpiralOpts","circleToPositioned","circle?: Circle | CirclePositioned","opts: CircleRingsOpts","sphere?: Sphere","offset","t: Triangle","PointsAngleRadian","t: Triangle","area","t: Triangle","lengths","LinesLength","t: Triangle","a: Point | number","b?: number","x: number","y: number","pa: Point","pb: Point","bc: BarycentricCoord","t: Triangle","r: RectPositioned","t: Triangle","origin: Point","radius: number","opts: { readonly initialAngleRadian?: number }","PointGuard","angles","PolarToCartesian","coords: readonly number[]","PointsFromNumbers","points: readonly Point[]","t: Triangle","perimeter","t: Triangle","LinesLength","t: Triangle","perimeter","area","intersectsPoint","t: Triangle","a: Point | number","b?: number","RectsIntersectsPoint","t: Triangle","t: Triangle","t: Triangle","fn: (p: Point, label?: string) => Point","t: Triangle","LinesLength","rotate","triangle: Triangle","amountRadian?: number","origin?: Point","PointsRotate","amountRadian: number","vertex: `a` | `b` | `c`","t: Triangle","t: TriangleEquilateral","fromCenter","origin?: Point","rotationRad?: number","ptA?: Point","incircle","ptB?: Point","ptC?: Point","height","perimeter","area","circumcircle","fromA","t: Right","origin?: Point","height","fromB","fromC","perimeter","area","medians","circumcircle","incircle","angleRad: number","adjacent: number","hypotenuse: number","angleRadian: number","angleRadian","opposite: number","t: Isosceles","origin?: Point"],"sources":["../packages/geometry/src/point/guard.ts","../packages/geometry/src/line/from-points.ts","../packages/geometry/src/line/join-points-to-lines.ts","../packages/geometry/src/line/guard.ts","../packages/geometry/src/line/get-points-parameter.ts","../packages/geometry/src/line/length.ts","../packages/geometry/src/line/reverse.ts","../packages/geometry/src/line/interpolate.ts","../packages/geometry/src/line/angles.ts","../packages/geometry/src/line/midpoint.ts","../packages/geometry/src/rect/guard.ts","../packages/geometry/src/point/normalise-by-rect.ts","../packages/geometry/src/point/get-point-parameter.ts","../packages/geometry/src/point/distance.ts","../packages/geometry/src/line/nearest.ts","../packages/geometry/src/line/distance-single-line.ts","../packages/geometry/src/point/find-minimum.ts","../packages/geometry/src/rect/max.ts","../packages/geometry/src/point/bbox.ts","../packages/geometry/src/line/bbox.ts","../packages/geometry/src/point/divider.ts","../packages/geometry/src/line/divide.ts","../packages/geometry/src/line/from-numbers.ts","../packages/geometry/src/line/from-flat-array.ts","../packages/geometry/src/polar/guard.ts","../packages/geometry/src/pi.ts","../packages/geometry/src/angles.ts","../packages/geometry/src/polar/angles.ts","../packages/geometry/src/point/subtract.ts","../packages/geometry/src/point/empty.ts","../packages/geometry/src/polar/conversions.ts","../packages/geometry/src/polar/math.ts","../packages/geometry/src/point/point-type.ts","../packages/geometry/src/point/angle.ts","../packages/geometry/src/point/To.ts","../packages/geometry/src/polar/ray.ts","../packages/geometry/src/polar/spiral.ts","../packages/geometry/src/polar/index.ts","../packages/geometry/src/line/from-pivot.ts","../packages/geometry/src/line/from-points-to-path.ts","../packages/geometry/src/point/is-equal.ts","../packages/geometry/src/line/is-equal.ts","../packages/geometry/src/point/abs.ts","../packages/geometry/src/point/apply.ts","../packages/geometry/src/point/averager.ts","../packages/geometry/src/point/centroid.ts","../packages/geometry/src/point/clamp.ts","../packages/geometry/src/point/compare.ts","../packages/geometry/src/point/convex-hull.ts","../packages/geometry/src/circle/guard.ts","../packages/geometry/src/circle/distance-center.ts","../packages/geometry/src/circle/distance-from-exterior.ts","../packages/geometry/src/circle/is-equal.ts","../packages/geometry/src/point/sum.ts","../packages/geometry/src/circle/intersections.ts","../packages/geometry/src/intersects.ts","../packages/geometry/src/rect/Intersects.ts","../packages/geometry/src/rect/center.ts","../packages/geometry/src/rect/distance.ts","../packages/geometry/src/point/distance-to-center.ts","../packages/geometry/src/point/distance-to-exterior.ts","../packages/geometry/src/point/to-array.ts","../packages/geometry/src/point/dot-product.ts","../packages/geometry/src/point/from.ts","../packages/geometry/src/point/interpolate.ts","../packages/geometry/src/point/invert.ts","../packages/geometry/src/point/multiply.ts","../packages/geometry/src/point/magnitude.ts","../packages/geometry/src/point/most.ts","../packages/geometry/src/point/normalise.ts","../packages/geometry/src/point/pipeline.ts","../packages/geometry/src/vector.ts","../packages/geometry/src/point/relation.ts","../packages/geometry/src/point/point-tracker.ts","../packages/geometry/src/point/progress-between.ts","../packages/geometry/src/point/project.ts","../packages/geometry/src/point/quantise.ts","../packages/geometry/src/point/random.ts","../packages/geometry/src/point/reduce.ts","../packages/geometry/src/point/rotate.ts","../packages/geometry/src/point/rotate-point-array.ts","../packages/geometry/src/point/round.ts","../packages/geometry/src/point/within-range.ts","../packages/geometry/src/point/wrap.ts","../packages/geometry/src/point/index.ts","../packages/geometry/src/line/multiply.ts","../packages/geometry/src/line/relative-position.ts","../packages/geometry/src/line/rotate.ts","../packages/geometry/src/line/subtract.ts","../packages/geometry/src/line/sum.ts","../packages/geometry/src/line/to-string.ts","../packages/geometry/src/line/index.ts","../packages/geometry/src/line/to-path.ts","../packages/geometry/src/waypoint.ts","../packages/geometry/src/triangle/create.ts","../packages/geometry/src/rect/corners.ts","../packages/geometry/src/rect/from-top-left.ts","../packages/geometry/src/shape/arrow.ts","../packages/geometry/src/circle/random.ts","../packages/geometry/src/rect/random.ts","../packages/geometry/src/circle/center.ts","../packages/geometry/src/triangle/guard.ts","../packages/geometry/src/triangle/centroid.ts","../packages/geometry/src/shape/etc.ts","../packages/geometry/src/circle/is-contained-by.ts","../packages/geometry/src/circle/intersecting.ts","../packages/geometry/src/shape/is-intersecting.ts","../packages/geometry/src/shape/starburst.ts","../packages/geometry/src/shape/index.ts","../packages/geometry/src/circle-packing.ts","../packages/geometry/src/layout.ts","../packages/geometry/src/circle/area.ts","../packages/geometry/src/rect/from-center.ts","../packages/geometry/src/circle/bbox.ts","../packages/geometry/src/circle/exterior-points.ts","../packages/geometry/src/circle/interior-points.ts","../packages/geometry/src/circle/perimeter.ts","../packages/geometry/src/circle/interpolate.ts","../packages/geometry/src/circle/multiply.ts","../packages/geometry/src/circle/svg.ts","../packages/geometry/src/circle/to-path.ts","../packages/geometry/src/circle/to-positioned.ts","../packages/geometry/src/circle/index.ts","../packages/geometry/src/rect/area.ts","../packages/geometry/src/rect/apply.ts","../packages/geometry/src/rect/cardinal.ts","../packages/geometry/src/rect/divide.ts","../packages/geometry/src/rect/edges.ts","../packages/geometry/src/rect/empty.ts","../packages/geometry/src/rect/encompass.ts","../packages/geometry/src/rect/from-element.ts","../packages/geometry/src/rect/from-numbers.ts","../packages/geometry/src/rect/get-rect-positionedparameter.ts","../packages/geometry/src/rect/is-equal.ts","../packages/geometry/src/rect/lengths.ts","../packages/geometry/src/rect/multiply.ts","../packages/geometry/src/rect/nearest.ts","../packages/geometry/src/rect/placeholder.ts","../packages/geometry/src/rect/perimeter.ts","../packages/geometry/src/rect/normalise-by-rect.ts","../packages/geometry/src/rect/subtract.ts","../packages/geometry/src/rect/sum.ts","../packages/geometry/src/rect/to-array.ts","../packages/geometry/src/rect/index.ts","../packages/geometry/src/bezier/guard.ts","../packages/geometry/src/path/start-end.ts","../packages/geometry/src/path/compound-path.ts","../packages/geometry/src/path/index.ts","../packages/geometry/src/grid/inside.ts","../packages/geometry/src/grid/guards.ts","../packages/geometry/src/grid/apply-bounds.ts","../packages/geometry/src/grid/array-1d.ts","../packages/geometry/src/grid/array-2d.ts","../packages/geometry/src/grid/values.ts","../packages/geometry/src/grid/enumerators/cells.ts","../packages/geometry/src/grid/as.ts","../packages/geometry/src/grid/offset.ts","../packages/geometry/src/grid/directions.ts","../packages/geometry/src/grid/enumerators/index.ts","../packages/geometry/src/grid/geometry.ts","../packages/geometry/src/grid/indexing.ts","../packages/geometry/src/grid/is-equal.ts","../packages/geometry/src/grid/neighbour.ts","../packages/geometry/src/grid/to-array.ts","../packages/geometry/src/grid/to-string.ts","../packages/geometry/src/grid/visual.ts","../packages/geometry/src/grid/visitors/breadth.ts","../packages/geometry/src/grid/visitors/cell-neighbours.ts","../packages/geometry/src/grid/visitors/columns.ts","../packages/geometry/src/grid/visitors/depth.ts","../packages/geometry/src/grid/visitors/random.ts","../packages/geometry/src/grid/visitors/random-contiguous.ts","../packages/geometry/src/grid/visitors/rows.ts","../packages/geometry/src/grid/visitors/visitor.ts","../packages/geometry/src/grid/visitors/step.ts","../packages/geometry/src/grid/visitors/index.ts","../packages/geometry/src/grid/index.ts","../packages/geometry/src/bezier/index.ts","../packages/geometry/src/ellipse.ts","../packages/geometry/src/curve-simplification.ts","../packages/geometry/src/quad-tree.ts","../packages/geometry/src/scaler.ts","../packages/geometry/src/arc/index.ts","../packages/geometry/src/surface-points.ts","../packages/geometry/src/triangle/angles.ts","../packages/geometry/src/triangle/edges.ts","../packages/geometry/src/triangle/area.ts","../packages/geometry/src/triangle/barycentric.ts","../packages/geometry/src/triangle/bbox.ts","../packages/geometry/src/triangle/corners.ts","../packages/geometry/src/triangle/from.ts","../packages/geometry/src/triangle/perimeter.ts","../packages/geometry/src/triangle/inner-circle.ts","../packages/geometry/src/triangle/intersects.ts","../packages/geometry/src/triangle/lengths.ts","../packages/geometry/src/triangle/kinds.ts","../packages/geometry/src/triangle/math.ts","../packages/geometry/src/triangle/outer-circle.ts","../packages/geometry/src/triangle/rotate.ts","../packages/geometry/src/triangle/to.ts","../packages/geometry/src/triangle/equilateral.ts","../packages/geometry/src/triangle/right.ts","../packages/geometry/src/triangle/isosceles.ts","../packages/geometry/src/triangle/index.ts"],"sourcesContent":["import type { Point, Point3d } from \"./point-type.js\";\nimport { numberTest, resultThrow } from '@ixfx/guards';\n\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport const isNull = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== null) return false;\n  }\n  return p.x === null && p.y === null;\n}\n\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport const isNaN = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) || Number.isNaN(p.y)\n}\n\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p: Point, name = `Point`) {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.x === undefined) {\n    throw new Error(\n      `'${ name }.x' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.y === undefined) {\n    throw new Error(\n      `'${ name }.y' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (typeof p.x !== `number`) {\n\n    throw new TypeError(`'${ name }.x' must be a number. Got ${ typeof p.x }`);\n  }\n  if (typeof p.y !== `number`) {\n\n    throw new TypeError(`'${ name }.y' must be a number. Got ${ typeof p.y }`);\n  }\n  if (p.z !== undefined) {\n    if (typeof p.z !== `number`) throw new TypeError(`${ name }.z must be a number. Got: ${ typeof p.z }`)\n    if (Number.isNaN(p.z)) throw new Error(`'${ name }.z' is NaN. Got: ${ JSON.stringify(p) }`);\n  }\n\n  if (p.x === null) throw new Error(`'${ name }.x' is null`);\n  if (p.y === null) throw new Error(`'${ name }.y' is null`);\n\n  if (Number.isNaN(p.x)) throw new Error(`'${ name }.x' is NaN`);\n  if (Number.isNaN(p.y)) throw new Error(`'${ name }.y' is NaN`);\n}\n\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt: Point | Point3d, name = `pt`) => {\n  guard(pt, name);\n  resultThrow(\n    numberTest(pt.x, `nonZero`, `${ name }.x`),\n    numberTest(pt.y, `nonZero`, `${ name }.y`),\n    () => {\n      if (typeof pt.z !== `undefined`) {\n        return numberTest(pt.z, `nonZero`, `${ name }.z`);\n      }\n    }\n  );\n  return true;\n};\n\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p: number | unknown): p is Point {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point).x === undefined) return false;\n  if ((p as Point).y === undefined) return false;\n  return true;\n}\n\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p: Point | unknown): p is Point3d => {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point3d).x === undefined) return false;\n  if ((p as Point3d).y === undefined) return false;\n  if ((p as Point3d).z === undefined) return false;\n  return true;\n};\n\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== 0) return false;\n  }\n  return p.x === 0 && p.y === 0\n\n}\n\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) && Number.isNaN(p.y);\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: readonly Point[]): PolyLine => {\n  const lines: Line[] = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { isPoint } from \"../point/guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/point-type.js\";\nimport { isLine } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/point-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { guard } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\n\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line \n * @returns \n */\nexport function reverse(line: Line): Line {\n  guard(line, `line`);\n  return { a: line.b, b: line.a };\n}","import { numberTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n\n  if (!allowOverflow) resultThrow(percentTest(amount, `amount`));\n  else resultThrow(numberTest(amount, ``, `amount`));\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns \n */\nexport function pointAtDistance(line: Line, distance: number, fromA = true): Point {\n  if (!fromA) line = reverse(line);\n\n  const dx = line.b.x - line.a.x;\n  const dy = line.b.y - line.a.y;\n  const theta = Math.atan2(dy, dx);\n  const xp = distance * Math.cos(theta);\n  const yp = distance * Math.sin(theta);\n  return { x: xp + line.a.x, y: yp + line.a.y };\n}","import { interpolate } from \"./interpolate.js\";\nimport type { Line } from \"./line-type.js\";\nimport { length } from \"./length.js\";\nimport type { Point } from \"../point/point-type.js\";\n\nconst directionVector = (line: Line): Point => ({\n  x: line.b.x - line.a.x,\n  y: line.b.y - line.a.y\n});\n\n\n\nconst directionVectorNormalised = (line: Line): Point => {\n  const l = length(line);\n  const v = directionVector(line);\n  return {\n    x: v.x / l,\n    y: v.y / l\n  };\n};\n\n/**\n * Returns a parallel line to `line` at `distance`.\n * \n * ```js\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance \n */\nexport const parallel = (line: Line, distance: number): Line => {\n  const dv = directionVector(line);\n  const dvn = directionVectorNormalised(line);\n  const a = {\n    x: line.a.x - dvn.y * distance,\n    y: line.a.y + dvn.x * distance\n  };\n  return {\n    a,\n    b: {\n      x: a.x + dv.x,\n      y: a.y + dv.y\n    }\n  };\n};\n\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line: Line, distance: number, amount = 0) => {\n  const origin = interpolate(amount, line);\n  const dvn = directionVectorNormalised(line);\n  return {\n    x: origin.x - dvn.y * distance,\n    y: origin.y + dvn.x * distance\n  };\n};\n","import type { Point } from \"../point/point-type.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport type { Line } from \"./line-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\n\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n * \n * ```js\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine \n * @param pointB \n * @returns \n */\nexport const midpoint = (aOrLine: Point | Line, pointB?: Point): Point => {\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  return interpolate(0.5, a, b);\n};","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d \n * @param name \n */\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n * \n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *  \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect \n * @param name \n */\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect \n * @returns \n */\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\n\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect \n * @returns \n */\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  rect: Point | Rect | RectPositioned\n): rect is Point =>\n  (rect as Point).x !== undefined && (rect as Point).y !== undefined;\n\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect: unknown): rect is Rect => {\n  if (rect === undefined) return false;\n  if ((rect as Rect).width === undefined) return false;\n  if ((rect as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (\n  rect: any\n): rect is RectPositioned => isRect(rect) && isPositioned(rect);\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport { isRect } from \"../rect/guard.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Normalises a point by a given width and height\n * \n * ```js\n * normaliseByRect({ x: 10, y: 10 }, 20, 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport function normaliseByRect(\n  point: Point,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point by a given rect's width and height\n * \n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param pt \n * @param rect \n */\nexport function normaliseByRect(pt: Point, rect: Rect): Point;\n\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n * \n * ```js\n * normaliseByRect(10, 10, 20, 40); // { x: 0.5, y: 0.2 }\n * ```\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function normaliseByRect(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point so it is on a 0..1 scale\n * \n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); \n * normaliseByRect({ x: 10, y: 10 }, 20, 40); \n * normaliseByRect(10, 10, 20, 40);\n * ```\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(\n  a: Point | number,\n  b: number | Rect,\n  c?: number,\n  d?: number\n): Point {\n  if (isPoint(a)) {\n    if (typeof b === `number` && c !== undefined) {\n      resultThrow(\n        numberTest(b, `positive`, `width`),\n        numberTest(c, `positive`, `height`)\n      );\n    } else {\n      if (!isRect(b)) {\n        throw new Error(`Expected second parameter to be a rect`);\n      }\n      c = b.height;\n      b = b.width;\n    }\n    return Object.freeze({\n      x: a.x / b,\n      y: a.y / c,\n    });\n  } else {\n    resultThrow(numberTest(a, `positive`, `x`));\n    if (typeof b !== `number`) {\n      throw new TypeError(`Expecting second parameter to be a number (width)`);\n    }\n    if (typeof c !== `number`) {\n      throw new TypeError(`Expecting third parameter to be a number (height)`);\n    }\n\n    resultThrow(numberTest(b, `positive`, `y`));\n    resultThrow(numberTest(c, `positive`, `width`));\n    if (d === undefined) throw new Error(`Expected height parameter`);\n    resultThrow(numberTest(d, `positive`, `height`));\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function getTwoPointParameters(a: Point, b: Point): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, b: Point3d): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a: Point, x: number, y: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number) {\n  if (isPoint3d(a1) && isPoint3d(ab2)) return [ a1, ab2 ];\n  if (isPoint(a1) && isPoint(ab2)) return [ a1, ab2 ];\n  if (isPoint3d(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3,\n      z: ab4\n    }\n    if (!isPoint3d(b)) throw new Error(`Expected x, y & z parameters`);\n    return [ a1, b ];\n  }\n  if (isPoint(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3\n    }\n    if (!isPoint(b)) throw new Error(`Expected x & y parameters`);\n    return [ a1, b ];\n  }\n\n  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n    const a = {\n      x: a1,\n      y: ab2,\n      z: ab3\n    };\n    const b = {\n      x: ab4,\n      y: ab5,\n      z: ab6\n    }\n    if (!isPoint3d(a)) throw new Error(`Expected x,y,z for first point`);\n    if (!isPoint3d(b)) throw new Error(`Expected x,y,z for second point`);\n    return [ a, b ];\n  }\n\n  const a = {\n    x: a1,\n    y: ab2\n  };\n  const b = {\n    x: ab3,\n    y: ab4\n  }\n  if (!isPoint(a)) throw new Error(`Expected x,y for first point`);\n  if (!isPoint(b)) throw new Error(`Expected x,y for second point`);\n  return [ a, b ];\n\n}\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from './point-type.js';\nimport { getPointParameter } from \"./get-point-parameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n * \n * ```js\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line: Line | readonly Line[], point: Point): Point => {\n\n  const n = (line: Line): Point => {\n    const { a, b } = line;\n    const atob = { x: b.x - a.x, y: b.y - a.y };\n    const atop = { x: point.x - a.x, y: point.y - a.y };\n    const length = atob.x * atob.x + atob.y * atob.y;\n\n\n    let dot = atop.x * atob.x + atop.y * atob.y;\n    const t = Math.min(1, Math.max(0, dot / length));\n    dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n    return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n  };\n\n  if (Array.isArray(line)) {\n    const pts = line.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(line as Line));\n  }\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard } from './guard.js';\nimport { guard as guardPoint } from '../point/guard.js';\nimport { length } from \"./length.js\";\nimport { nearest } from \"./nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n * \n * ```js\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns \n */\nexport const distanceSingleLine = (line: Line, point: Point): number => {\n  guard(line, `line`);\n  guardPoint(point, `point`);\n\n  if (length(line) === 0) {\n    // Line is really a point\n    return length(line.a, point);\n  }\n\n  const near = nearest(line, point);\n  return length(near, point);\n};","import { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function findMinimum(\n  comparer: (a: Point, b: Point) => Point,\n  ...points: ReadonlyArray<Point>\n): Point;\n\nexport function findMinimum(\n  comparer: (a: Point3d, b: Point3d) => Point3d,\n  ...points: ReadonlyArray<Point3d>\n): Point3d;\n\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport function findMinimum(\n  comparer: ((a: Point, b: Point) => Point)|((a: Point3d, b: Point3d) => Point3d),\n  ...points: ReadonlyArray<Point|Point3d>\n): Point|Point3d  {\n  if (points.length === 0) throw new Error(`No points provided`);\n  let min = points[ 0 ];\n  for (const p of points) {\n    if (isPoint3d(min) && isPoint3d(p)) {\n      min = comparer(min, p);\n    } else {\n      min = comparer(min as any, p as any);\n    }\n  }\n  return min;\n};","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (\n  topLeft: Point,\n  topRight: Point,\n  bottomRight: Point,\n  bottomLeft: Point\n): RectPositioned => {\n  if (topLeft.y > bottomRight.y) {\n    throw new Error(`topLeft.y greater than bottomRight.y`);\n  }\n  if (topLeft.y > bottomLeft.y) {\n    throw new Error(`topLeft.y greater than bottomLeft.y`);\n  }\n\n  const w1 = topRight.x - topLeft.x;\n  const w2 = bottomRight.x - bottomLeft.x;\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\n  const h2 = Math.abs(bottomRight.y - topRight.y);\n  return {\n    x: Math.min(topLeft.x, bottomLeft.x),\n    y: Math.min(topRight.y, topLeft.y),\n    width: Math.max(w1, w2),\n    height: Math.max(h1, h2),\n  };\n};\n","import type { Rect3dPositioned, RectPositioned } from \"../rect/rect-types.js\";\nimport { findMinimum } from \"./find-minimum.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points: ReadonlyArray<Point>): RectPositioned => {\n  const leftMost = findMinimum((a, b) => {\n    return a.x < b.x ? a : b;\n  }, ...points);\n  const rightMost = findMinimum((a, b) => {\n    return a.x > b.x ? a : b;\n  }, ...points);\n  const topMost = findMinimum((a, b) => {\n    return a.y < b.y ? a : b;\n  }, ...points);\n  const bottomMost = findMinimum((a, b) => {\n    return a.y > b.y ? a : b;\n  }, ...points);\n\n  const topLeft = { x: leftMost.x, y: topMost.y };\n  const topRight = { x: rightMost.x, y: topMost.y };\n  const bottomRight = { x: rightMost.x, y: bottomMost.y };\n  const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n  return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\n\nexport const bbox3d = (...points: ReadonlyArray<Point3d>): Rect3dPositioned => {\n  const box = bbox(...points);\n  const zMin = findMinimum((a: Point3d, b: Point3d) => {\n    return a.z < b.z ? a : b\n  }, ...points);\n  const zMax = findMinimum((a: Point3d, b: Point3d) => {\n    return a.z > b.z ? a : b\n  }, ...points);\n\n  return {\n    ...box,\n    z: zMin.z,\n    depth: zMax.z - zMin.z\n  }\n}","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Line } from \"./line-type.js\";\nimport { bbox as PointsBbox } from \"../point/bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n * \n * ```js\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line: Line): RectPositioned => PointsBbox(line.a, line.b);\n","\nimport { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  const pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | number[], b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | number[],\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { divide as PointDivide } from '../point/divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n * \n * Dividing by zero will give Infinity for that dimension.\n * @param line \n * @param point \n * @returns \n */\nexport const divide = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointDivide(line.a, point),\n  b: PointDivide(line.b, point)\n});\n\n","import { fromPoints } from \"./from-points.js\";\nimport type { Line } from \"./line-type.js\";\n\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n * \n * ```js\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1 \n * @param y1 \n * @param x2 \n * @param y2 \n * @returns \n */\nexport const fromNumbers = (x1: number, y1: number, x2: number, y2: number): Line => {\n  if (Number.isNaN(x1)) throw new Error(`x1 is NaN`);\n  if (Number.isNaN(x2)) throw new Error(`x2 is NaN`);\n  if (Number.isNaN(y1)) throw new Error(`y1 is NaN`);\n  if (Number.isNaN(y2)) throw new Error(`y2 is NaN`);\n\n  const a = { x: x1, y: y1 };\n  const b = { x: x2, y: y2 };\n  return fromPoints(a, b);\n};","import { fromNumbers } from \"./from-numbers.js\";\nimport type { Line } from \"./line-type.js\";\n\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n * \n * See {@link toFlatArray} to create an array from a line.\n * \n * ```js\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array: readonly number[]): Line => {\n  if (!Array.isArray(array)) throw new Error(`arr parameter is not an array`);\n  if (array.length !== 4) throw new Error(`array is expected to have length four`);\n  return fromNumbers(array[ 0 ], array[ 1 ], array[ 2 ], array[ 3 ]);\n};","import type { Coord } from \"./types.js\";\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};","export const piPi = Math.PI * 2;","import { piPi } from './pi.js';\nimport type { Point } from './point/point-type.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: readonly number[]): readonly number[];\n\n\nexport function degreeToRadian(angleInDegrees: number | readonly number[]): number | readonly number[] {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians \n * @returns \n */\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\nexport function degreeToGradian(angleInDegrees: number) {\n  return angleInDegrees * 1.111111\n}\n\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians \n * @param wrap \n * @returns \n */\nexport function gradianToDegree(angleInGradians: number, wrap = true) {\n  if (wrap) return (angleInGradians * 0.9) % 360;\n  return angleInGradians * 0.9;\n}\n\n\nexport function radianToGradian(angleInRadians: number) {\n  return angleInRadians * 63.6619772368; // 200/pi\n}\n\nexport function gradianToRadian(angleInGradian: number) {\n  return angleInGradian * 0.0157079633; // pi/200\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: readonly number[]): readonly number[];\n\n\nexport function radianToDegree(angleInRadians: number | readonly number[]): number | readonly number[] {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start: number, amount: number, clockwise = true) => {\n  if (clockwise) {\n    let x = start + amount;\n    if (x >= piPi) x = x % piPi;\n    return x;\n  } else {\n    const x = start - amount;\n    if (x < 0) {\n      return piPi + x;\n    }\n    return x;\n  }\n}\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n * \n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start: number, amount: number, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n * \n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n * \n * See {@link degreeArc} to operate in degrees.\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start: number, end: number, clockwise = true) => {\n  let s = start;\n  if (end < s) {\n    s = 0;\n    end = piPi - start + end;\n  }\n  let d = end - s;\n  if (clockwise) d = piPi - d;\n  if (d >= piPi) return d % piPi;\n  return d;\n}\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n * \n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n * \n * See {@link radianArc} to operate in radians.\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start: number, end: number, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));\n\n\nexport type Angle = {\n  value: number\n  unit: `deg` | `rad` | `turn` | `grad`\n}\n\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n * \n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n * \n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n * \n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value \n * @returns \n */\nexport const angleParse = (value: string | number | Angle): Angle => {\n  if (isAngle(value)) return value;\n\n  if (typeof value === `number`) {\n    return {\n      value, unit: `deg`\n    }\n  }\n  value = value.toLowerCase();\n  let unit = `deg`;\n  let numberValue = Number.NaN;\n  if (value.endsWith(`grad`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n    unit = `grad`;\n  } else if (value.endsWith(`rad`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n    unit = `rad`;\n  } else if (value.endsWith(`turn`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n    unit = `turn`;\n  } else if (value.endsWith(`deg`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n    unit = `deg`;\n  } else {\n    numberValue = Number.parseFloat(value);\n  }\n\n  if (Number.isNaN(numberValue)) throw new Error(`Invalid angle (bad value?)`);\n  if (unit.length === 0) throw new Error(`Invalid angle (no unit)`);\n  return {\n    value: numberValue,\n    unit: unit as `deg` | `grad` | `turn` | `rad`\n  }\n}\n\nconst isAngle = (v: any): v is Angle => {\n  if (typeof v !== `object`) return false;\n  if (`unit` in v && `value` in v) {\n    if (typeof v.unit !== `string`) return false;\n    if (typeof v.value !== `number`) return false;\n    return true;\n  }\n  return false;\n}\n\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n * \n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n * \n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n * \n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees \n * @param destination \n * @returns \n */\nexport const angleConvert = (angleOrDegrees: Angle | number | string, destination: Angle[ `unit` ]): Angle => {\n  const angle = typeof angleOrDegrees === `object` ? angleOrDegrees : angleParse(angleOrDegrees);\n  switch (destination) {\n    case `deg`:\n      if (angle.unit === `deg`) return angle;\n      if (angle.unit === `rad`) return { value: radianToDegree(angle.value), unit: `deg` };\n      if (angle.unit === `grad`) return { value: gradianToDegree(angle.value), unit: `deg` };\n      if (angle.unit === `turn`) return { value: turnToDegree(angle.value), unit: `deg` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `grad`:\n      if (angle.unit === `deg`) return { value: degreeToGradian(angle.value), unit: `grad` };\n      if (angle.unit === `rad`) return { value: radianToGradian(angle.value), unit: `grad` };\n      if (angle.unit === `grad`) return angle;\n      if (angle.unit === `turn`) return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `rad`:\n      if (angle.unit === `deg`) return { value: degreeToRadian(angle.value), unit: `rad` };\n      if (angle.unit === `rad`) return angle;\n      if (angle.unit === `grad`) return { value: gradianToRadian(angle.value), unit: `rad` };\n      if (angle.unit === `turn`) return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `turn`:\n      if (angle.unit === `deg`) return { value: degreeToTurn(angle.value), unit: `turn` };\n      if (angle.unit === `rad`) return { value: radianToTurn(angle.value), unit: `turn` };\n      if (angle.unit === `grad`) return { value: radianToTurn(gradianToRadian(angle.value)), unit: `turn` };\n      if (angle.unit === `turn`) return angle;\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    default:\n      throw new Error(`Destination unit unknown ('${ destination }). Expects: deg, grad, rad or turn`);\n  }\n}\n\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so \n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns \n * @param wrap \n * @returns \n */\nexport const turnToDegree = (turns: number, wrap = true) => {\n  if (wrap) return (turns * 360) % 360;\n  return turns * 360;\n}\n\nexport const turnToRadian = (turns: number) => turns * piPi;\nexport const degreeToTurn = (degrees: number) => degrees / 360;\nexport const radianToTurn = (radians: number) => radians / piPi","import { guard } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { degreeToRadian } from '../angles.js';\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c: Coord, amountRadian: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n  });\n\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p: Coord): Coord => {\n  guard(p, `c`);\n  return Object.freeze({\n    ...p,\n    angleRadian: p.angleRadian - Math.PI,\n  });\n};\n\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  if (a.distance !== b.distance) return false;\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === b.angleRadian;\n};\n\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c: Coord, amountDeg: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n  });\n\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function subtract(a: Point, b: Point): Point;\nexport function subtract(a: Point3d, b: Point3d): Point3d;\nexport function subtract(a: Point, x: number, y: number): Point;\nexport function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n * \n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x - ptB.x,\n    y: ptA.y - ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 } as const;\n\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 } as const;\n\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 } as const;\n\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 } as const;","import type { Point } from \"../point/point-type.js\";\nimport { guard, isPolarCoord } from \"./guard.js\";\nimport type { Coord, PolarToCartesian } from \"./types.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n\n\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: PolarToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (typeof b === `undefined`) b = EmptyPoint;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = EmptyPoint;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtractPoint(point, origin);\n\n  const angle = Math.atan2(point.y, point.x);\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = EmptyPoint\n): Point => {\n  guardPoint(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyPoint): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};","import { guard } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { numberTest, resultThrow } from \"@ixfx/guards\"\n\nexport const normalise = (c: Coord): Coord => {\n  //guard(v, `v`);\n  if (c.distance === 0) throw new Error(`Cannot normalise vector of length 0`);\n  return Object.freeze({\n    ...c,\n    distance: 1,\n  });\n};\n\n\n\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v: Coord, max = 1, min = 0): Coord => {\n  let mag = v.distance;\n  if (mag > max) mag = max;\n  if (mag < min) mag = min;\n  return Object.freeze({\n    ...v,\n    distance: mag,\n  });\n};\n\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Coord, b: Coord): number => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n\n\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v: Coord, amt: number): Coord => {\n  guard(v);\n  resultThrow(numberTest(amt, ``, `amt`));\n  return Object.freeze({\n    ...v,\n    distance: v.distance * amt,\n  });\n};\n\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v: Coord, amt: number): Coord => {\n  guard(v);\n  resultThrow(numberTest(amt, ``, `amt`));\n  return Object.freeze({\n    ...v,\n    distance: v.distance / amt,\n  });\n};\n","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","import { guard } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (\n  pt: Point,\n  rounder: (x: number) => number = Math.round\n): Point => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    x: rounder(pt.x),\n    y: rounder(pt.y),\n  });\n};\n\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt \n * @returns \n */\nexport const to2d = (pt: Point): Point => {\n  guard(pt, `pt`);\n  let copy = {\n    ...pt\n  };\n  delete copy.z;\n  return Object.freeze(copy);\n}\n\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns \n */\nexport const to3d = (pt: Point, z: number = 0): Point3d => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    ...pt,\n    z\n  });\n}\n\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p: Point, digits?: number): string {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n  guard(p, `pt`);\n\n  const x = digits ? p.x.toFixed(digits) : p.x;\n  const y = digits ? p.y.toFixed(digits) : p.y;\n\n  if (p.z === undefined) {\n    return `(${ x },${ y })`;\n  } else {\n    const z = digits ? p.z.toFixed(digits) : p.z;\n    return `(${ x },${ y },${ z })`;\n  }\n}","import { type Line } from \"../line/line-type.js\";\nimport { type Point } from '../point/point-type.js';\nimport { distance } from '../point/distance.js';\nimport { angleRadian } from '../point/angle.js';\nimport { toString as pointToString } from '../point/To.js';\nimport { type PolarRay } from \"./types.js\";\nimport { toCartesian as polarToCartesian } from \"./conversions.js\";\n\n/**\n * Converts a ray to a Line in cartesian coordinates.\n * \n * @param ray \n * @param origin Override or provide origin point\n * @returns \n */\nexport const toCartesian = (ray: PolarRay, origin?: Point): Line => {\n  const o = getOrigin(ray, origin);\n  const a = polarToCartesian(ray.offset, ray.angleRadian, o);\n  const b = polarToCartesian(ray.offset + ray.length, ray.angleRadian, o);\n  return { a, b }\n}\n\nconst getOrigin = (ray: PolarRay, origin?: Point): Point => {\n  if (origin !== undefined) return origin;\n  if (ray.origin !== undefined) return ray.origin;\n  return { x: 0, y: 0 };\n}\n\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray \n * @param origin \n * @returns \n */\n// const withOrigin = (ray: PolarRay, origin?: Point): PolarRayWithOrigin => {\n//   if (origin) {\n//     return {\n//       ...ray,\n//       origin\n//     };\n//   }\n//   if (ray.origin !== undefined) return { ...ray } as PolarRayWithOrigin;\n//   return {\n//     ...ray,\n//     origin: { x: 0, y: 0 }\n//   }\n// }\n\n\n\n// function getAngle(a: Point, b: Point) {\n//   const angle = Math.atan2(b.y - a.y, b.x - a.x);// * (180 / Math.PI) + 90;\n//   return angle;//return (angle < 0) ? scale(angle, -90, 0, 0, piPi) : angle;\n// }\n\n/**\n * Returns a string representation of the ray\n * @param ray \n * @returns \n */\nexport const toString = (ray: PolarRay): string => {\n  let basic = `PolarRay(angle: ${ ray.angleRadian } offset: ${ ray.offset } len: ${ ray.length }`;\n  if (ray.origin) {\n    basic += ` origin: ${ pointToString(ray.origin) }`;\n  }\n  basic += `)`;\n  return basic;\n}\n\n/**\n * Returns a PolarRay based on a line and origin.\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * @param line \n * @param origin \n * @returns \n */\nexport const fromLine = (line: Line, origin?: Point): PolarRay => {\n  const o = origin ?? line.a;\n  return {\n    angleRadian: angleRadian(line.b, o),\n    offset: distance(line.a, o),\n    length: distance(line.b, line.a),\n    origin: o\n  }\n}\n\n","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\n\nimport type { Coord } from \"./types.js\";\n\nexport function* spiral(\n  smoothness: number,\n  zoom: number\n): IterableIterator<Coord & { readonly step: number }> {\n  let step = 0;\n\n  while (true) {\n    const a = smoothness * step++;\n    yield {\n      distance: zoom * a,\n      angleRadian: a,\n      step: step,\n    };\n  }\n}\n\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (\n  step: number,\n  smoothness: number,\n  zoom: number\n): Coord => {\n  const a = smoothness * step;\n  return Object.freeze({\n    distance: zoom * a,\n    angleRadian: a,\n  });\n};","// import { degreeToRadian, radianToDegree } from '../Angles.js';\n\n// import type { Point } from '../point/PointType.js';\n// import { subtract } from '../point/Subtract.js';\n// import { Empty } from '../point/Empty.js';\n// import { isPoint, guard as PointGuard } from '../point/Guard.js';\n// import type { Coord } from './Types.js';\n\n//const EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nexport type * from './types.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js'\n\n\n","import type { Point } from \"../point/point-type.js\"\nimport * as Polar from \"../polar/index.js\";\nimport { radianInvert } from \"../angles.js\";\n\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n * \n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n * \n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line. \n * * Angle of 45deg will be angled downwards.\n * \n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin: Point = { x: 0.5, y: 0.5 }, length: number = 1, angleRadian: number = 0, balance: number = 0.5) => {\n  const left = length * balance;\n  const right = length * (1 - balance);\n  const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n  const b = Polar.toCartesian(right, angleRadian, origin);\n  return Object.freeze({\n    a, b\n  });\n}","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { LinePath } from \"./line-path-type.js\";\nimport { toPath } from \"./to-path.js\";\n\n/**\n * Returns a {@link LinePath} from two points\n * \n * ```js\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const fromPointsToPath = (a: Point, b: Point): LinePath => toPath(fromPoints(a, b));\n","import type { Point } from \"./point-type.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import type { Line } from \"./line-type.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n * \n * ```js\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a: Line, b: Line): boolean => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function abs(pt: Point3d): Point3d;\nexport function abs(pt: Point): Point;\n\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt: Point): Point {\n  if (isPoint3d(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y),\n      z: Math.abs(pt.z)\n    });\n  } else if (isPoint(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y)\n    });\n  } else throw new TypeError(`Param 'pt' is not a point`);\n};","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n// type PointFields = `x` | `y`;\n// type Point3dFields = PointFields & 'z';\n\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\n\nexport function apply(pt: Point3d, fn: Point3dApplyFn): Point3d\nexport function apply(pt: Point, fn: PointApplyFn): Point;\n\n/**\n * Applies `fn` on x,y & z (if present) fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport function apply(\n  pt: Point,\n  fn: Point3dApplyFn | PointApplyFn\n): Point {\n  guard(pt, `pt`);\n  if (isPoint3d(pt)) {\n    return Object.freeze<Point3d>({\n      ...pt,\n      x: fn(pt.x, `x`),\n      y: fn(pt.y, `y`),\n      z: (fn as Point3dApplyFn)(pt.z, `z`)\n    });\n  }\n  return Object.freeze<Point>({\n    ...pt,\n    x: fn(pt.x, `x`),\n    y: fn(pt.y, `y`),\n  });\n}","import { movingAverageLight as mal } from \"@ixfx/numbers\"\nimport { isPoint3d } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n\n\n/**\n * Uses =@ixfx/numbers#movingAverageLight to keep track of \n * average x, y and z values.\n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n * \n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns \n */\nexport function averager(kind: `moving-average-light`, opts: Partial<{ scaling: number }>): PointAverager;\n\nexport function averager(kind: PointAverageKinds, opts: any): PointAverager {\n  let x: (v: number) => number;\n  let y: (v: number) => number;\n  let z: (v: number) => number;\n  switch (kind) {\n    case `moving-average-light`:\n      const scaling = opts.scaling ?? 3;\n      x = mal(scaling);\n      y = mal(scaling);\n      z = mal(scaling);\n      break;\n    default:\n      throw new Error(`Unknown averaging kind '${ kind }'. Expected: 'moving-average-light'`);\n  }\n\n  return (point: Point) => {\n    const ax = x(point.x);\n    const ay = y(point.y);\n    if (isPoint3d(point)) {\n      const az = z(point.z);\n      return Object.freeze({\n        x: ax,\n        y: ay,\n        z: az\n      })\n    } else {\n      return Object.freeze({\n        x: ax,\n        y: ay\n      })\n    }\n  }\n}","import { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: ReadonlyArray<Point | undefined>): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import { clamp as clampNumber } from '@ixfx/numbers';\nimport { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function clamp(a: Point, min?: number, max?: number): Point;\nexport function clamp(a: Point3d, min?: number, max?: number): Point3d;\n\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(\n  a: Point,\n  min = 0,\n  max = 1\n): Point {\n\n  if (isPoint3d(a)) {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n      z: clampNumber(a.z, min, max)\n    });\n  } else {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n    });\n  }\n}\n","import type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}\n\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a: Point3d, b: Point3d): number => {\n  if (a.z === b.z) return 0;\n  if (a.z < b.z) return -1;\n  return 1;\n}","import { compareByX } from \"./compare.js\";\nimport { isEqual } from \"./is-equal.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts: ReadonlyArray<Point>): ReadonlyArray<Point> => {\n  const sorted = [ ...pts ].sort(compareByX);\n  if (sorted.length === 1) return sorted;\n\n  const x = (points: Array<Point>) => {\n    const v: Array<Point> = [];\n    for (const p of points) {\n      while (v.length >= 2) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const q = v.at(-1)!;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const r = v.at(-2)!;\n        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n          //eslint-disable-next-line functional/immutable-data\n          v.pop();\n        } else break;\n      }\n      //eslint-disable-next-line functional/immutable-data\n      v.push(p);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    v.pop();\n    return v;\n  };\n\n  const upper = x(sorted);\n  //eslint-disable-next-line functional/immutable-data\n  const lower = x(sorted.reverse());\n\n  if (upper.length === 1 && lower.length === 1 && isEqual(lower[ 0 ], upper[ 0 ])) {\n    return upper;\n  }\n  return [ ...upper, ...lower ];\n};","import { guard as guardPoint } from '../point/guard.js';\nimport type { Point } from '../point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle-type.js';\n\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle \n * @param parameterName \n */\nexport const guard = (circle: CirclePositioned | Circle, parameterName = `circle`) => {\n  if (isCirclePositioned(circle)) {\n    guardPoint(circle, `circle`);\n  }\n\n  if (Number.isNaN(circle.radius)) throw new Error(`${ parameterName }.radius is NaN`);\n  if (circle.radius <= 0) throw new Error(`${ parameterName }.radius must be greater than zero`);\n};\n\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle \n * @param parameterName \n * @returns \n */\nexport const guardPositioned = (circle: CirclePositioned, parameterName = `circle`) => {\n  if (!isCirclePositioned(circle)) throw new Error(`Expected a positioned circle with x,y`);\n  guard(circle, parameterName);\n};\n\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a: Circle | CirclePositioned): boolean => {\n  if (Number.isNaN(a.radius)) return true;\n  if (isCirclePositioned(a)) {\n    if (Number.isNaN(a.x)) return true;\n    if (Number.isNaN(a.y)) return true;\n  }\n  return false;\n};\n\n\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n * \n * ```js\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n * \n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns \n */\nexport const isPositioned = (p: Circle | Point): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n\nexport const isCircle = (p: any): p is Circle => (p as Circle).radius !== undefined;\n\nexport const isCirclePositioned = (p: any): p is CirclePositioned => isCircle(p) && isPositioned(p);","import type { CirclePositioned } from \"./circle-type.js\";\nimport { distance as pointsDistance } from '../point/distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns the distance between two circle centers.\n * \n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a \n * @param b \n * @returns Distance\n */\nexport const distanceCenter = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    guardPositioned(b, `b`);\n  }\n  return pointsDistance(a, b);\n};\n","import type { CirclePositioned } from \"./circle-type.js\";\nimport { distanceCenter } from \"./distance-center.js\";\nimport { isPoint as PointsIsPoint } from \"../point/guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n * \n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b \n */\nexport const distanceFromExterior = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n  } else if (PointsIsPoint(b)) {\n    const distribution = PointsDistance(a, b);\n    if (distribution < a.radius) return 0;\n    return distribution;\n  } else throw new Error(`Second parameter invalid type`);\n};","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\n\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n * \n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n * \n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: CirclePositioned | Circle, b: CirclePositioned | Circle): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isCirclePositioned(a) && isCirclePositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return false;\n};","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { isEqual } from \"./is-equal.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { subtract as PointsSubtract } from \"../point/subtract.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Line } from \"../line/line-type.js\";\n\n/**\n * Returns the point(s) of intersection between a circle and line.\n * \n * ```js\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle \n * @param line \n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle: CirclePositioned, line: Line): readonly Point[] => {\n  const v1 = {\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n  };\n  const v2 = {\n    x: line.a.x - circle.x,\n    y: line.a.y - circle.y\n  };\n\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n  if (Number.isNaN(d)) return []; // no intercept\n\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  const u2 = (b + d) / c;\n\n  const returnValue: Point[] = [];\n  if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment\n    returnValue.push({\n      x: line.a.x + v1.x * u1,\n      y: line.a.y + v1.y * u1\n    });\n  }\n  if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\n    returnValue.push({\n      x: line.a.x + v1.x * u2,\n      y: line.a.y + v1.y * u2\n    });\n  }\n  return returnValue;\n};\n\n\n/**\n * \n * Returns the points of intersection betweeen `a` and `b`.\n * \n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a: CirclePositioned, b: CirclePositioned): readonly Point[] => {\n  const vector = PointsSubtract(b, a);\n  const centerD = Math.hypot((vector.y), (vector.x));\n\n  // Do not intersect\n  if (centerD > a.radius + b.radius) return [];\n\n  // Circle contains another\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\n\n  // Circles are the same\n  if (isEqual(a, b)) return [];\n\n  const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n  const centroid = {\n    x: a.x + (vector.x * centroidD / centerD),\n    y: a.y + (vector.y * centroidD / centerD)\n  };\n\n  const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n\n  const intersection = {\n    x: -vector.y * (centroidIntersectionD / centerD),\n    y: vector.x * (centroidIntersectionD / centerD)\n  };\n  return [\n    PointsSum(centroid, intersection),\n    PointsSubtract(centroid, intersection)\n  ];\n};\n","import { intersections as circleIntersections } from \"./circle/intersections.js\";\nimport type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { RectPositioned } from \"./rect/index.js\";\n\nexport const circleRect = (a: CirclePositioned, b: RectPositioned) => {\n  // https://yal.cc/rectangle-circle-intersection-test/\n  const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n  const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n  return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\n\nexport const circleCircle = (a: CirclePositioned, b: CirclePositioned) => circleIntersections(a, b).length === 2;","import { guard } from \"./guard.js\";\nimport { isPositioned, isRectPositioned } from \"./guard.js\";\nimport { isCirclePositioned } from '../circle/guard.js';\nimport * as Intersects from '../intersects.js';\nimport { isPoint } from \"../point/guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"../circle/circle-type.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  point: Point\n): boolean;\n\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  x: number,\n  y: number\n): boolean;\n\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  a: Point | number,\n  b?: number\n): boolean {\n  guard(rect, `rect`);\n  let x = 0;\n  let y = 0;\n  if (typeof a === `number`) {\n    if (b === undefined) throw new Error(`x and y coordinate needed`);\n    x = a;\n    y = b;\n  } else {\n    x = a.x;\n    y = a.y;\n  }\n  if (isPositioned(rect)) {\n    if (x - rect.x > rect.width || x < rect.x) return false;\n    if (y - rect.y > rect.height || y < rect.y) return false;\n  } else {\n    // Assume 0,0\n    if (x > rect.width || x < 0) return false;\n    if (y > rect.height || y < 0) return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (\n  a: RectPositioned,\n\n  b: CirclePositioned | Point\n): boolean => {\n  if (!isRectPositioned(a)) {\n    throw new Error(`a parameter should be RectPositioned`);\n  }\n\n  if (isCirclePositioned(b)) {\n    return Intersects.circleRect(b, a);\n  } else if (isPoint(b)) {\n    return intersectsPoint(a, b);\n  }\n  throw new Error(`Unknown shape for b: ${ JSON.stringify(b) }`);\n};","import { isPoint } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { getRectPositioned, guard } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the center of a rectangle as a {@link Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): Point => {\n  guard(rect);\n  if (origin === undefined && isPoint(rect)) origin = rect;\n  else if (origin === undefined) origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n\n  const r = getRectPositioned(rect, origin);\n  return Object.freeze({\n    x: origin.x + rect.width / 2,\n    y: origin.y + rect.height / 2,\n  });\n};","import { guardPositioned } from \"./guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./center.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { type Point } from '../point/point-type.js';\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { distance as PointsDistance } from '../point/distance.js';\n\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (\n  rect: RectPositioned,\n  pt: Point\n): number => {\n  guardPositioned(rect, `rect`);\n  PointsGuard(pt, `pt`);\n  if (intersectsPoint(rect, pt)) return 0;\n  const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n  const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n  return Math.hypot(dx, dy);\n};\n\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (\n  rect: RectPositioned,\n  pt: Point\n): number => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\nimport { distance } from \"./distance.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport type { Point } from \"./point-type.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/shape-type.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distance } from \"./distance.js\";\nimport { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p: Point): ReadonlyArray<number> => [ p.x, p.y ];\n","import { dotProduct as ArraysDotProduct } from '@ixfx/numbers';\nimport type { Point } from './point-type.js';\nimport { toArray } from './to-array.js';\n\nexport const dotProduct = (...pts: readonly Point[]): number => {\n  const a = pts.map(p => toArray(p));\n  return ArraysDotProduct(a);\n};","import { guard } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function from(x: number, y: number, z: number): Point3d;\nexport function from(x: number, y: number): Point;\nexport function from(array: [ x: number, y: number, z: number ]): Point3d;\nexport function from(array: [ x: number, y: number ]): Point;\n\n/**\n * Returns a point from two or three coordinates or an array of [x,y] or [x,y,z].\n * @example\n * ```js\n * let p = from([10, 5]);    // yields {x:10, y:5}\n * let p = from([10, 5, 2]); // yields: {x:10, y:5, z:2}\n * let p = from(10, 5);      // yields {x:10, y:5}\n * let p = from(10, 5, 2);   // yields: {x:10, y:5, z:2}\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport function from(\n  xOrArray?: number | readonly number[],\n  y?: number,\n  z?: number\n): Point {\n  if (Array.isArray(xOrArray)) {\n    if (xOrArray.length === 3) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n        z: xOrArray[ 2 ]\n      });\n    } else if (xOrArray.length === 2) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n      });\n    } else {\n      throw new Error(`Expected array of length two or three, got ${ xOrArray.length }`);\n    }\n  } else {\n    if (xOrArray === undefined) throw new Error(`Requires an array of [x,y] or x,y parameters at least`)\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\n    if (y === undefined) throw new Error(`Param 'y' is missing`);\n    else if (Number.isNaN(y)) throw new Error(`y is NaN`);\n    if (z === undefined) {\n      return Object.freeze({ x: xOrArray as number, y: y });\n    } else {\n      return Object.freeze({ x: xOrArray as number, y, z })\n    }\n  }\n};\n\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n * \n * Throws an error if `str` is not a string.\n * \n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n * \n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param string_ \n */\nexport const fromString = (string_: string): Point => {\n  if (typeof string_ !== `string`) throw new TypeError(`Param 'str' ought to be a string. Got: ${ typeof string_ }`);\n  const comma = string_.indexOf(`,`);\n  const x = Number.parseFloat(string_.substring(0, comma));\n  const nextComma = string_.indexOf(',', comma + 1);\n  if (nextComma > 0) {\n    // z component\n    const y = Number.parseFloat(string_.substring(comma + 1, nextComma - comma + 2));\n    const z = Number.parseFloat(string_.substring(nextComma + 1));\n    return { x, y, z };\n  } else {\n    const y = Number.parseFloat(string_.substring(comma + 1));\n    return { x, y };\n  }\n}\n\n\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (\n  ...coords: readonly (readonly number[])[] | readonly number[]\n): readonly Point[] => {\n  const pts: Point[] = [];\n\n  if (Array.isArray(coords[ 0 ])) {\n    // [[x,y],[x,y]...]\n    for (const coord of (coords as number[][])) {\n      if (!(coord.length % 2 === 0)) {\n        throw new Error(`coords array should be even-numbered`);\n      }\n      pts.push(Object.freeze({ x: coord[ 0 ], y: coord[ 1 ] }));\n    }\n  } else {\n    // [x,y,x,y,x,y]\n    if (coords.length % 2 !== 0) {\n      throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n    }\n\n    for (let index = 0; index < coords.length; index += 2) {\n      pts.push(\n        Object.freeze({ x: coords[ index ] as number, y: coords[ index + 1 ] as number })\n      );\n    }\n  }\n  return pts;\n};\n","import type { Point } from \"./point-type.js\";\nimport { interpolate as lineInterpolate } from '../line/interpolate.js';\n\n/**\n * Returns a relative point between two points.\n * \n * ```js\n * interpolate(0.5, { x:0, y:0 }, { x:10, y:10 }); // Halfway { x, y }\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function multiply(a: Point, b: Point): Point;\nexport function multiply(a: Point3d, b: Point3d): Point3d;\nexport function multiply(a: Point, x: number, y: number): Point;\nexport function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x * ptB.x,\n    y: ptA.y * ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { findMinimum } from \"./find-minimum.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","import type { Line } from './line/line-type.js';\nimport type { Point } from './point/point-type.js';\nimport { normalise as PointsNormalise } from './point/normalise.js';\nimport { isPoint } from './point/guard.js';\nimport * as Polar from './polar/index.js';\nimport { divide as PointDivide } from './point/divider.js';\nimport { guard as LinesGuard } from './line/guard.js';\nimport { sum as PointsSum } from './point/sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/dot-product.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/magnitude.js';\nimport { distance as PointsDistance } from './point/distance.js';\nimport { Empty as PointEmpty } from './point/empty.js';\n\nexport type Vector = Point | Polar.Coord;\n\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\n\nexport const fromRadians = (radians: number) => {\n  return Object.freeze({\n    x: Math.cos(radians),\n    y: Math.sin(radians)\n  });\n}\n\nexport const toRadians = (point: Point) => {\n  return Math.atan2(point.y, point.x);\n}\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2π\n * if `bipolar` normalisation is used, direction will be fixed to -π...π\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (\n  pt: Point,\n  angleNormalisation: `` | `unipolar` | `bipolar` = ``,\n  origin: Point = EmptyCartesian\n): Polar.Coord => {\n  pt = PointsSubtract(pt, origin);\n\n  let direction = Math.atan2(pt.y, pt.x);\n  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi;\n  else if (angleNormalisation === `bipolar`) {\n    if (direction > pi) direction -= piPi;\n    else if (direction <= -pi) direction += piPi;\n  }\n\n  return Object.freeze({\n    distance: PointsDistance(pt),\n    angleRadian: direction,\n  });\n};\n\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line: Line): Point =>\n  PointsSubtract(line.b, line.a);\n\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line: Line): Polar.Coord => {\n  LinesGuard(line, `line`);\n  const pt = PointsSubtract(line.b, line.a);\n  return fromPointPolar(pt);\n};\n\nconst isPolar = (v: Vector): v is Polar.Coord => {\n  if (Polar.isPolarCoord(v)) return true;\n  return false;\n};\n\nconst isCartesian = (v: Vector): v is Point => {\n  if (isPoint(v)) return true;\n  return false;\n};\n\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v: Vector): Vector => {\n  if (isPolar(v)) {\n    return Polar.normalise(v);\n  } else if (isCartesian(v)) {\n    return PointsNormalise(v);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\nexport const quadrantOffsetAngle = (p: Point): number => {\n  if (p.x >= 0 && p.y >= 0) return 0; // Q1\n  if (p.x < 0 && p.y >= 0) return pi; // Q2\n  if (p.x < 0 && p.y < 0) return pi; // Q3\n  return piPi; // Q4\n};\n\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v: Vector, origin = PointEmpty): Polar.Coord => {\n  if (isPolar(v)) {\n    return v;\n  } else if (isCartesian(v)) {\n    return Polar.fromCartesian(v, origin);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v: Vector): Point => {\n  if (isPolar(v)) {\n    return Polar.toPoint(v);\n  } else if (isCartesian(v)) {\n    return v;\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v: Vector, digits?: number) => {\n  if (isPolar(v)) {\n    return Polar.toString(v, digits);\n  } else if (isCartesian(v)) {\n    return PointsToString(v, digits);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Vector, b: Vector) => {\n  if (isPolar(a) && isPolar(b)) {\n    return Polar.dotProduct(a, b);\n  } else if (isCartesian(a) && isCartesian(b)) {\n    return PointsDotProduct(a, b);\n  }\n  throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v: Vector, max = 1, min = 0) => {\n  if (isPolar(v)) {\n    return Polar.clampMagnitude(v, max, min);\n  } else if (isCartesian(v)) {\n    return PointsClampMagnitude(v, max, min);\n  }\n  throw new Error(`Expected either polar or Cartesian vector`);\n};\n\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSum(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSubtract(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsMultiply(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointDivide(a, b);\n  return polar ? toPolar(c) : c;\n};\n","import { angleRadian } from \"./angle.js\";\nimport { centroid } from \"./centroid.js\";\nimport { distance } from \"./distance.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport type { PointRelation } from \"./point-relation-types.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link PointsTracker}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angleRadian(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","import {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from '@ixfx/trackers';\nimport { ObjectTracker } from '@ixfx/trackers';\nimport { length as LineLength } from '../line/length.js';\nimport * as Vectors from '../vector.js';\nimport { Empty as LinesEmpty } from '../line/index.js';\nimport type { Coord as PolarCoord } from '../polar/index.js';\nimport type { Line, PolyLine } from '../line/line-type.js';\nimport type { Point, Point3d } from './point-type.js';\nimport type { PointRelation } from './point-relation-types.js';\nimport { joinPointsToLines } from '../line/join-points-to-lines.js';\nimport type { TrimReason } from '@ixfx/trackers';\nimport type { PointRelationResult } from \"./point-relation-types.js\";\nimport { relation } from './relation.js';\nimport { distance } from './distance.js';\nimport { subtract } from './subtract.js';\nimport { angleRadian } from './angle.js';\nimport { Placeholder as PointsPlaceholder } from './point-type.js';\n/**\n * Information about seen points\n */\nexport type PointTrack = PointRelationResult & {\n  // readonly speedFromInitial:number\n};\n\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = Readonly<{\n  /**\n   * Relation of last point to previous point\n   */\n  fromLast: PointTrack;\n  /**\n   * Relation of last point to 'initial' point.\n   * This will be the oldest point in the buffer of the tracker.\n   */\n  fromInitial: PointTrack;\n  /**\n   * Relation of last point to a 'mark' point,\n   * which is manually set.\n   * \n   * Will give _undefined_ if `.mark()` has not been called on tracker.\n   */\n  fromMark: PointTrack | undefined;\n  values: readonly Point[];\n}>;\n\n\n\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link PointsTracker}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n * \n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n  initialRelation: PointRelation | undefined;\n  markRelation: PointRelation | undefined;\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  /**\n   * Notification that buffer has been knocked down to `sampleLimit`.\n   * \n   * This will reset the `initialRelation`, which will use the new oldest value.\n   */\n  onTrimmed(_reason: TrimReason): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n    this.markRelation = undefined\n  }\n\n  /**\n   * Adds a PointerEvent along with its\n   * coalesced events, if available.\n   * @param p \n   * @returns \n   */\n  seenEvent(p: PointerEvent | MouseEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      return this.seen({ x: (p).clientX, y: (p).clientY });\n    }\n  }\n\n  /**\n   * Makes a 'mark' in the tracker, allowing you to compare values\n   * to this point.\n   */\n  mark() {\n    this.markRelation = relation(this.last);\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: TimestampedObject<Point>[]\n  ): PointTrackerResults {\n    const currentLast = this.last;\n\n\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      // Use the oldest point in the buffer (this.initial)\n      this.initialRelation = relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? relation(currentLast) : relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const markRel: PointTrack | undefined = (this.markRelation !== undefined) ? this.markRelation(currentLast) : undefined;\n\n    const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      fromMark: markRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return LinesEmpty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length.\n   * @returns Distance\n   */\n  distanceFromStart(): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? distance(initial, this.last) : 0;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x,y & z.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Point | Point3d {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? subtract(this.last, initial) : PointsPlaceholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return angleRadian(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total length of accumulated points.\n   * Returns 0 if points were not saved, or there's only one\n   */\n  get length(): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return LineLength(l);\n  }\n\n  /**\n * Returns the last x coord\n */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * Returns the last z coord (or _undefined_ if not available)\n   */\n  get z() {\n    return this.last.z;\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class PointsTracker extends TrackedValueMap<\n  Point,\n  PointTracker,\n  PointTrackerResults\n> {\n\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  /**\n   * Track a PointerEvent\n   * @param event\n   */\n  seenEvent(event: PointerEvent): Promise<PointTrackerResults[]> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}\n","\nimport { isPoint3d } from \"./guard.js\";\nimport type { Point3d, Point } from \"./point-type.js\";\nimport { subtract } from \"./subtract.js\";\n\n/**\n * Computes the progress between two waypoints, given `position`.\n * \n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns \n */\nexport const progressBetween = (\n  position: Point | Point3d,\n  waypointA: Point | Point3d,\n  waypointB: Point | Point3d\n) => {\n  // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n  // from -> current\n  const a = subtract(position, waypointA);\n\n  // from -> to\n  const b = subtract(waypointB, waypointA);\n\n  return isPoint3d(a) && isPoint3d(b) ? (\n    (a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)\n  ) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin: Point, distance: number, angle: number) => {\n  const x = Math.cos(angle) * distance + origin.x;\n  const y = Math.sin(angle) * distance + origin.y;\n  return { x, y };\n};","import { quantiseEvery as quantiseEveryNumber } from '@ixfx/numbers';\nimport { guard, isPoint3d } from './guard.js';\nimport type { Point, Point3d } from './point-type.js';\n\nexport function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n\n/**\n * Quantises a point.\n * @param pt \n * @param snap \n * @param middleRoundsUp \n * @returns \n */\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp = true): Point {\n  guard(pt, `pt`);\n  guard(snap, `snap`);\n  if (isPoint3d(pt)) {\n    if (!isPoint3d(snap)) throw new TypeError(`Param 'snap' is missing 'z' field`);\n    return Object.freeze({\n      x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n      y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n      z: quantiseEveryNumber(pt.z, snap.z, middleRoundsUp)\n    });\n  }\n\n  return Object.freeze({\n    x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n    y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n  });\n}","import { type RandomSource } from '@ixfx/random';\nimport type { Point, Point3d } from './point-type.js';\n\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): Point => {\n  if (typeof rando === `undefined`) rando = Math.random;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n  });\n};\n\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random3d = (rando?: RandomSource): Point3d => {\n  if (typeof rando === `undefined`) rando = Math.random;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    z: rando()\n  });\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (\n  pts: ReadonlyArray<Point>,\n  fn: (p: Point, accumulated: Point) => Point,\n  initial?: Point\n): Point => {\n  if (initial === undefined) initial = { x: 0, y: 0 }\n  let accumulator = initial;\n  for (const p of pts) {\n    accumulator = fn(p, accumulator);\n  };\n  return accumulator;\n};","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"./point-type.js\";\nimport { guard } from \"./guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../polar/index.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../polar/index.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport function rotate(\n  pt: readonly Point[],\n  amountRadian: number,\n  origin?: Point\n): readonly Point[];\n\nexport function rotate(\n  pt: Point | readonly Point[],\n  amountRadian: number,\n  origin?: Point\n): Point | readonly Point[] {\n  if (typeof origin === `undefined`) origin = { x: 0, y: 0 };\n  guard(origin, `origin`);\n  resultThrow(numberTest(amountRadian, ``, `amountRadian`));\n  const arrayInput = Array.isArray(pt);\n\n  // no-op\n  if (amountRadian === 0) return pt;\n\n  if (!arrayInput) {\n    pt = [ pt as Point ];\n  }\n\n  const ptAr = pt as readonly Point[];\n  for (const [ index, p ] of ptAr.entries()) guard(p, `pt[${ index }]`);\n\n  const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n  const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n  const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n  return arrayInput ? asCartesisan : asCartesisan[ 0 ];\n}","\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (\n  v: ReadonlyArray<ReadonlyArray<number>>,\n  amountRadian: number\n): Array<Array<number>> => {\n  const mat = [\n    [ Math.cos(amountRadian), -Math.sin(amountRadian) ],\n    [ Math.sin(amountRadian), Math.cos(amountRadian) ],\n  ];\n  const result:number[][] = [];\n  for (const [ index, element ] of v.entries()) {\n    result[ index ] = [\n      mat[ 0 ][ 0 ] * element[ 0 ] + mat[ 0 ][ 1 ] * element[ 1 ],\n      mat[ 1 ][ 0 ] * element[ 0 ] + mat[ 1 ][ 1 ] * element[ 1 ],\n    ];\n  }\n  return result;\n};","import { round as roundNumber } from '@ixfx/numbers';\nimport { getPointParameter } from './get-point-parameter.js';\nimport type { Point } from './point-type.js';\n\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX \n * @param yOrDigits \n * @param digits \n * @returns \n */\nexport const round = (ptOrX: Point | number, yOrDigits?: number, digits?: number): Point => {\n  const pt = getPointParameter(ptOrX, yOrDigits);\n  digits = digits ?? yOrDigits;\n  digits = digits ?? 2;\n  return Object.freeze({\n    ...pt,\n    x: roundNumber(digits, pt.x),\n    y: roundNumber(digits, pt.y)\n  })\n}","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"./point-type.js\";\nimport { guard } from \"./guard.js\";\n\n/**\n * Returns true if two points are within a specified range on both axes.\n * \n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (\n  a: Point,\n  b: Point,\n  maxRange: Point | number\n): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n\n  if (typeof maxRange === `number`) {\n    resultThrow(numberTest(maxRange, `positive`, `maxRange`));\n    maxRange = { x: maxRange, y: maxRange };\n  } else {\n    guard(maxRange, `maxRange`);\n  }\n  const x = Math.abs(b.x - a.x);\n  const y = Math.abs(b.y - a.y);\n  return x <= maxRange.x && y <= maxRange.y;\n};","import { wrap as wrapNumber } from '@ixfx/numbers';\nimport { guard } from './guard.js';\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (\n  pt: Point,\n  ptMax?: Point,\n  ptMin?: Point\n): Point => {\n\n  if (ptMax === undefined) ptMax = { x: 1, y: 1 };\n  if (ptMin === undefined) ptMin = { x: 0, y: 0 };\n\n  // ✔️ Unit tested\n  guard(pt, `pt`);\n  guard(ptMax, `ptMax`);\n  guard(ptMin, `ptMin`);\n\n  return Object.freeze({\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n  });\n};\n","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\nexport type { Point, Point3d } from './point-type.js';\n","import type { Line } from \"./line-type.js\";\nimport { multiply as PointsMultiply, type Point } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n * \n * ```js\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const multiply = (line: Line, point: Point): Line => (Object.freeze({\n  ...line,\n  a: PointsMultiply(line.a, point),\n  b: PointsMultiply(line.b, point)\n}));","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { length } from \"./length.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line \n * @param pt \n */\nexport const relativePosition = (line: Line, pt: Point): number => {\n  const fromStart = PointsDistance(line.a, pt);\n  const total = length(line);\n  return fromStart / total;\n}","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./interpolate.js\";\n\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n * \n * ```js\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n * \n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n * \n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n * \n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns \n */\nexport const rotate = (line: Line, amountRadian?: number, origin?: Point | number): Line => {\n  if (typeof amountRadian === `undefined` || amountRadian === 0) return line;\n  if (typeof origin === `undefined`) origin = 0.5;\n  if (typeof origin === `number`) {\n    origin = interpolate(origin, line.a, line.b);\n  }\n  return Object.freeze({\n    ...line,\n    a: PointRotate(line.a, amountRadian, origin),\n    b: PointRotate(line.b, amountRadian, origin)\n  });\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { subtract as PointsSubtract } from \"../point/subtract.js\";\n\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const subtract = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSubtract(line.a, point),\n  b: PointsSubtract(line.b, point)\n});","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { sum as PointsSum } from '../point/sum.js';\n\n/**\n * Adds both start and end points by given x,y\n * ```js\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line \n * @param point \n * @returns \n */\nexport const sum = (line: Line, point: Point): Line => Object.freeze({\n  ...line,\n  a: PointsSum(line.a, point),\n  b: PointsSum(line.b, point)\n});","import type { Point } from \"../point/point-type.js\";\nimport { guard, isLine } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of two points\n * ```js\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport function toString(a: Point, b: Point): string;\n\n/**\n * Returns a string representation of a line \n * ```js\n * Lines.toString(line);\n * ```\n * @param line \n */\nexport function toString(line: Line): string;\n\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b \n * @returns \n */\n\nexport function toString(a: Point | Line, b?: Point): string {\n  if (isLine(a)) {\n    guard(a, `a`);\n    b = a.b;\n    a = a.a;\n  } else if (b === undefined) throw new Error(`Expect second point if first is a point`);\n  return PointsToString(a) + `-` + PointsToString(b);\n}\n\n","import type { Point } from '../point/point-type.js';\nimport type { Line } from './line-type.js';\n//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/normalise-by-rect.js';\nimport { minFast } from '@ixfx/numbers';\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isLine } from './guard.js';\nimport { length } from './length.js';\nimport { interpolate } from './interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/guard.js';\n\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport type * from './line-path-type.js';\nexport type * from './line-type.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\n\n\nexport const Empty = Object.freeze({\n  a: Object.freeze({ x: 0, y: 0 }),\n  b: Object.freeze({ x: 0, y: 0 })\n});\n\n\nexport const Placeholder = Object.freeze({\n  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n  b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l \n * @returns \n */\nexport const isEmpty = (l: Line): boolean => PointIsEmpty(l.a) && PointIsEmpty(l.b);\n\nexport const isPlaceholder = (l: Line): boolean => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n\n\n\n\n/**\n * Applies `fn` to both start and end points.\n * \n * ```js\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n * \n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n * \n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns \n */\nexport const apply = (line: Line, fn: (p: Point) => Point) => Object.freeze<Line>(\n  {\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n  }\n);\n\n\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint \n * @param b \n * @returns \n */\nexport const angleRadian = (lineOrPoint: Line | Point, b?: Point): number => {\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b point must be provided`);\n  }\n  return Math.atan2(b.y - a.y, b.x - a.x);\n};\n\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n * \n * ```js\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line \n * @param width\n * @param height \n * @returns \n */\nexport const normaliseByRect = (line: Line, width: number, height: number): Line => Object.freeze({\n  ...line,\n  a: PointsNormaliseByRect(line.a, width, height),\n  b: PointsNormaliseByRect(line.b, width, height)\n});\n\n\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n * \n * ```js\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange \n * @returns True if point is within range\n */\nexport const withinRange = (line: Line, point: Point, maxRange: number): boolean => {\n  const calculatedDistance = distance(line, point);\n  return calculatedDistance <= maxRange;\n};\n\n\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n * \n * @example\n * ```js\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns \n */\nexport const slope = (lineOrPoint: Line | Point, b?: Point): number => {\n\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b parameter required`);\n  }\n  if (b === undefined) {\n    throw new TypeError(`Second point missing`)\n  } else {\n    return (b.y - a.y) / (b.x - a.x);\n  }\n};\n\n\n/**\n * Scales a line from its midpoint\n * \n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor \n */\nexport const scaleFromMidpoint = (line: Line, factor: number): Line => {\n  const a = interpolate(factor / 2, line);\n  const b = interpolate(0.5 + factor / 2, line);\n  return { a, b };\n};\n\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line: Line, x: number): Point => {\n  const y = line.a.y + (x - line.a.x) * slope(line);\n  return Object.freeze({ x: x, y });\n};\n\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line: Line, distance: number): Line => {\n  const calculatedLength = length(line);\n  return Object.freeze({\n    ...line,\n    a: line.a,\n    b: Object.freeze({\n      x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n      y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n    })\n  });\n};\n\n/**\n * Yields every integer point along `line`. \n * \n * @example Basic usage\n * ```js\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n * \n * Some precision is lost as start and end\n * point is also returned as an integer.\n * \n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\n\nexport function* pointsOf(line: Line): Generator<Point> {\n  // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n  const { a, b } = line;\n  let x0 = Math.floor(a.x);\n  let y0 = Math.floor(a.y);\n  const x1 = Math.floor(b.x);\n  const y1 = Math.floor(b.y);\n  const dx = Math.abs(x1 - x0);\n  const dy = -Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1;\n  const sy = y0 < y1 ? 1 : -1;\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  let err = dx + dy;\n\n  while (true) {\n    yield { x: x0, y: y0 };\n    if (x0 === x1 && y0 === y1) break;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const e2 = 2 * err;\n    if (e2 >= dy) {\n      err += dy;\n      x0 += sx;\n    }\n    if (e2 <= dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n}\n\n/**\n * Returns the distance of `point` to the \n * nearest point on `line`.\n * \n * ```js\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line: Line | readonly Line[], point: Point): number => {\n  if (Array.isArray(line)) {\n    const distances = line.map(l => distanceSingleLine(l, point));\n    return minFast(distances);\n  } else {\n    return distanceSingleLine(line as Line, point);\n  }\n};\n\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n * \n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a: Point | Line, b: Point): readonly number[] => {\n  if (isLine(a)) {\n    return [ a.a.x, a.a.y, a.b.x, a.b.y ];\n  } else if (isPoint(a) && isPoint(b)) {\n    return [ a.x, a.y, b.x, b.y ];\n  } else {\n    throw new Error(`Expected single line parameter, or a and b points`);\n  }\n};\n\n/**\n * Yields all the points of all the lines.\n * \n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines \n */\n\nexport function* asPoints(lines: Iterable<Line>) {\n  for (const l of lines) {\n    yield l.a;\n    yield l.b;\n  }\n}\n\n/**\n * Returns an SVG description of line\n * ```\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const toSvgString = (a: Point, b: Point): readonly string[] => [ `M${ a.x } ${ a.y } L ${ b.x } ${ b.y }` ];\n","import type { LinePath } from \"./line-path-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { length } from \"./length.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { parallel, perpendicularPoint } from \"./angles.js\";\nimport { midpoint } from \"./midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./bbox.js\";\nimport { relativePosition } from \"./relative-position.js\";\nimport { sum } from \"./sum.js\";\nimport { divide } from \"./divide.js\";\nimport { rotate } from \"./rotate.js\";\nimport { nearest } from \"./nearest.js\";\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isEqual } from \"./is-equal.js\";\nimport { multiply } from \"./multiply.js\";\nimport { subtract } from \"./subtract.js\";\nimport { toString } from \"./to-string.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n * \n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n * \n * ```js\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n * \n * // Now we can use it...\n * l.length();\n * \n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line \n * @returns \n */\nexport const toPath = (line: Line): LinePath => {\n  const { a, b } = line;\n  return Object.freeze({\n    ...line,\n    length: () => length(a, b),\n    interpolate: (amount: number) => interpolate(amount, a, b),\n    relativePosition: (point: Point) => relativePosition(line, point),\n    bbox: () => bbox(line),\n    toString: () => toString(a, b),\n    toFlatArray: () => toFlatArray(a, b),\n    toSvgString: () => toSvgString(a, b),\n    toPoints: () => [ a, b ],\n    rotate: (amountRadian: number, origin: Point) => toPath(rotate(line, amountRadian, origin)),\n    nearest: (point: Point) => nearest(line, point),\n    sum: (point: Point) => toPath(sum(line, point)),\n    divide: (point: Point) => toPath(divide(line, point)),\n    multiply: (point: Point) => toPath(multiply(line, point)),\n    subtract: (point: Point) => toPath(subtract(line, point)),\n    midpoint: () => midpoint(a, b),\n    distanceToPoint: (point: Point) => distanceSingleLine(line, point),\n    parallel: (distance: number) => parallel(line, distance),\n    perpendicularPoint: (distance: number, amount?: number) => perpendicularPoint(line, distance, amount),\n    slope: () => slope(line),\n    withinRange: (point: Point, maxRange: number) => withinRange(line, point, maxRange),\n    isEqual: (otherLine: Line) => isEqual(line, otherLine),\n    apply: (fn: (point: Point) => Point) => toPath(apply(line, fn)),\n    kind: `line`\n  });\n};","import type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Path } from \"./path/path-type.js\";\nimport type { Point } from \"./point/point-type.js\";\nimport { joinPointsToLines } from './line/join-points-to-lines.js';\nimport { toPath } from './line/to-path.js';\nimport { distance as PointsDistance } from \"./point/distance.js\";\nimport { sortByNumericProperty } from \"@ixfx/arrays\";\n\nexport type Waypoint = CirclePositioned;\n\nexport type WaypointOpts = {\n  readonly maxDistanceFromLine: number;\n  readonly enforceOrder: boolean;\n};\n\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints \n * @param opts \n * @returns \n */\nexport const fromPoints = (\n  waypoints: readonly Point[],\n  opts: Partial<WaypointOpts> = {}\n) => {\n  const lines = joinPointsToLines(...waypoints);\n  return init(\n    lines.map((l) => toPath(l)),\n    opts\n  );\n};\n\n/**\n * Result \n */\nexport type WaypointResult = {\n  /**\n   * Path being compared against\n   */\n  path: Path\n  /**\n   * Index of this path in original `paths` array\n   */\n  index: number\n  /**\n   * Nearest point on path. See also {@link distance}\n   */\n  nearest: Point\n  /**\n   * Closest distance to path. See also {@link nearest}\n   */\n  distance: number\n  /**\n   * Rank of this result, 0 being highest.\n   */\n  rank: number\n  /**\n   * Relative position on this path segment\n   * 0 being start, 0.5 middle and so on.\n   */\n  positionRelative: number\n}\n\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => WaypointResult[]\n\n/**\n * Initialise\n * \n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths \n * @param opts \n * @returns \n */\nexport const init = (paths: readonly Path[], opts: Partial<WaypointOpts> = {}): Waypoints => {\n  //const enforceOrder = opts.enforceOrder ?? true;\n  const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n\n  const checkUnordered = (pt: Point): WaypointResult[] => {\n    const results = paths.map((p, index) => {\n      const nearest = p.nearest(pt);\n      const distance = PointsDistance(pt, nearest);\n\n      // Relative position of nearest point on this path segment\n      const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);;\n      return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n    });\n\n    const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n    const sorted = sortByNumericProperty(filtered, `distance`);\n\n    // Assign ranks\n\n    for (let rank = 0; rank < sorted.length; rank++) {\n      sorted[ rank ].rank = rank;\n    }\n    return sorted;\n  };\n\n  // const checkUnordered = (p:Point) => {\n  //   // Calculate progress of pointer between all the waypoint lines\n  //   const progresses = lines.map((line, index) => (\n  //     {\n  //       index,\n  //       score: Points.progressBetween(p, line.a, line.b)\n  //     }));\n  //   // Sort by closest\n  //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n  // };\n  return checkUnordered;\n};\n","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { project as PointsProject } from \"../point/project.js\";\n// import { guard as PointGuard } from \"../point/Guard.js\";\n// import { throwNumberTest } from \"@ixfx/guards\";\n// import { piPi } from \"../pi.js\";\n\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\n\nexport const Empty = Object.freeze({\n  a: { x: 0, y: 0 },\n  b: { x: 0, y: 0 },\n  c: { x: 0, y: 0 },\n});\n\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\n\nexport const Placeholder = Object.freeze({\n  a: { x: Number.NaN, y: Number.NaN },\n  b: { x: Number.NaN, y: Number.NaN },\n  c: { x: Number.NaN, y: Number.NaN },\n});\n\n\n\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (\n  origin?: Point,\n  length = 10,\n  angleRadian: number = Math.PI / 2\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const a = PointsProject(origin, length, Math.PI - -angleRadian / 2);\n  const c = PointsProject(origin, length, Math.PI - angleRadian / 2);\n  return { a, b: origin, c };\n};","import { type Point } from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): readonly Point[] => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import type { Point } from \"../point/point-type.js\";\nimport { guardDim } from \"./guard.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import type { Point } from \"../point/point-type.js\";\nimport { equilateralFromVertex } from \"../triangle/create.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { rotate as PointsRotate } from \"../point/rotate.js\";\nexport type ArrowOpts = {\n  readonly arrowSize?: number;\n  readonly tailLength?: number;\n  readonly tailThickness?: number;\n  readonly angleRadian?: number;\n};\n\n\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (\n  origin: Point,\n  from: `tip` | `tail` | `middle`,\n  opts: ArrowOpts = {}\n): ReadonlyArray<Point> => {\n  const tailLength = opts.tailLength ?? 10;\n  const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n  const angleRadian = opts.angleRadian ?? 0;\n  const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n\n  const triAngle = Math.PI / 2;\n\n  let tri: Triangle;\n  let tailPoints: ReadonlyArray<Point>;\n\n  if (from === `tip`) {\n    tri = equilateralFromVertex(origin, arrowSize, triAngle);\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n  } else if (from === `middle`) {\n    const midX = tailLength + arrowSize / 2;\n    const midY = tailThickness / 2;\n    tri = equilateralFromVertex(\n      {\n        x: origin.x + arrowSize * 1.2,\n        y: origin.y,\n      },\n      arrowSize,\n      triAngle\n    );\n\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x - midX, y: origin.y - midY },\n        tailLength + arrowSize,\n        tailThickness\n      )\n    );\n  } else {\n    //const midY = origin.y - tailThickness/2;\n    tailPoints = RectsCorners(\n      RectsFromTopLeft(\n        { x: origin.x, y: origin.y - tailThickness / 2 },\n        tailLength,\n        tailThickness\n      )\n    );\n    tri = equilateralFromVertex(\n      { x: origin.x + tailLength + arrowSize * 0.7, y: origin.y },\n      arrowSize,\n      triAngle\n    );\n  }\n\n  const arrow = PointsRotate(\n    [\n      tailPoints[ 0 ],\n      tailPoints[ 1 ],\n      tri.a,\n      tri.b,\n      tri.c,\n      tailPoints[ 2 ],\n      tailPoints[ 3 ],\n    ],\n    angleRadian,\n    origin\n  );\n\n  return arrow;\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/index.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n * \n * By default creates a uniform distribution.\n * \n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n * \n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns \n */\nexport const randomPoint = (within: Circle | CirclePositioned, opts: Partial<CircleRandomPointOpts> = {}): Point => {\n  const offset: Point = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n  const strategy = opts.strategy ?? `uniform`;\n  const margin = opts.margin ?? 0;\n  const radius = within.radius - margin;\n  const rand = opts.randomSource ?? Math.random;\n  switch (strategy) {\n    case `naive`: {\n      return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n    }\n    case `uniform`: {\n      return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n    }\n    default: {\n\n      throw new Error(`Unknown strategy '${ strategy }'. Expects 'uniform' or 'naive'`);\n    }\n  }\n};","import { type RandomSource } from '@ixfx/random';\nimport { sum as PointsSum } from '../point/sum.js';\nimport type { Point } from '../point/point-type.js';\nimport { isPositioned } from './guard.js';\nimport type { Rect, RectPositioned } from './rect-types.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): RectPositioned => {\n  rando ??= Math.random;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    width: rando(),\n    height: rando(),\n  });\n};\n\nexport type RectRandomPointOpts = {\n  readonly strategy?: `naive`;\n  readonly randomSource?: RandomSource;\n  readonly margin?: { readonly x: number; readonly y: number };\n};\n\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (\n  within: Rect | RectPositioned,\n  options: RectRandomPointOpts = {}\n): Point => {\n  // TODO: Does not implement uniform distribution\n  // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n  const rand = options.randomSource ?? Math.random;\n  const margin = options.margin ?? { x: 0, y: 0 };\n\n  const x = rand() * (within.width - margin.x - margin.x);\n  const y = rand() * (within.height - margin.y - margin.y);\n\n  const pos = { x: x + margin.x, y: y + margin.y };\n  return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\n\n/**\n * Returns the center of a circle\n * \n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n * \n * ```js\n * const circle = { radius: 5, x: 10, y: 10};\n * \n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n * \n * It's a trivial function, but can make for more understandable code\n * @param circle \n * @returns Center of circle\n */\nexport const center = (circle: CirclePositioned | Circle) => {\n  return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};","import type { Triangle } from \"./triangle-type.js\";\nimport { isPoint, guard as PointsGuard, isPlaceholder as PointsIsPlaceholder, isEmpty as PointsIsEmpty } from '../point/guard.js'\nimport { isEqual as PointsIsEqual} from \"../point/is-equal.js\";\n\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t: Triangle, name = `t`) => {\n  if (t === undefined) throw new Error(`{$name} undefined`);\n  PointsGuard(t.a, name + `.a`);\n  PointsGuard(t.b, name + `.b`);\n  PointsGuard(t.c, name + `.c`);\n};\n\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p: unknown): p is Triangle => {\n  if (p === undefined) return false;\n  const tri = p as Triangle;\n  if (!isPoint(tri.a)) return false;\n  if (!isPoint(tri.b)) return false;\n  if (!isPoint(tri.c)) return false;\n  return true;\n};\n\n\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t: Triangle): boolean =>\n  PointsIsEmpty(t.a) && PointsIsEmpty(t.b) && PointsIsEmpty(t.c);\n\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t: Triangle): boolean =>\n  PointsIsPlaceholder(t.a) &&\n  PointsIsPlaceholder(t.b) &&\n  PointsIsPlaceholder(t.c);\n\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: Triangle, b: Triangle): boolean =>\n  PointsIsEqual(a.a, b.a) &&\n  PointsIsEqual(a.b, b.b) &&\n  PointsIsEqual(a.c, b.c);","import type { Point } from \"../point/point-type.js\";\nimport { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t: Triangle): Point => {\n  guard(t);\n  const total = PointsReduce(\n    [ t.a, t.b, t.c ],\n    (p: Point, accumulator: Point) => ({\n      x: p.x + accumulator.x,\n      y: p.y + accumulator.y,\n    })\n  );\n  const div = {\n    x: total.x / 3,\n    y: total.y / 3,\n  };\n  return div;\n};","import type { RandomSource } from \"@ixfx/random\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport { isCircle, isCirclePositioned } from \"../circle/guard.js\";\nimport { isRect, isRectPositioned } from \"../rect/guard.js\";\nimport { randomPoint as circleRandomPoint } from '../circle/random.js';\nimport { randomPoint as rectRandomPoint } from '../rect/random.js';\nimport type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport type { Circle } from \"../circle/circle-type.js\";\nimport { center as circleCenter } from '../circle/center.js';\nimport { isTriangle } from \"../triangle/guard.js\";\nimport { centroid as triangleCentroid } from \"../triangle/centroid.js\";\nimport { center as rectCenter } from '../rect/center.js';\n\nexport type ShapeRandomPointOpts = {\n  readonly randomSource: RandomSource;\n};\n\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * @param shape \n * @param opts \n * @returns \n */\nexport const randomPoint = (\n  shape: ShapePositioned,\n  opts: Partial<ShapeRandomPointOpts> = {}\n): Point => {\n  if (isCirclePositioned(shape)) {\n    return circleRandomPoint(shape, opts);\n  } else if (isRectPositioned(shape)) {\n    return rectRandomPoint(shape, opts);\n  }\n  throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n\n// }\n\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (\n  shape?: Rect | Triangle | Circle\n): Point => {\n  if (shape === undefined) {\n    return Object.freeze({ x: 0.5, y: 0.5 });\n  } else if (isRect(shape)) {\n    return rectCenter(shape);\n  } else if (isTriangle(shape)) {\n    return triangleCentroid(shape);\n  } else if (isCircle(shape)) {\n    return circleCenter(shape);\n  } else {\n    throw new Error(`Unknown shape: ${ JSON.stringify(shape) }`);\n  }\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { distanceCenter } from \"./distance-center.js\";\nimport { isCircle } from \"./guard.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n * \n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n * \n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a: CirclePositioned, b: CirclePositioned | Point, c?: number): boolean => {\n  const d = distanceCenter(a, b);\n  if (isCircle(b)) {\n    return (d < Math.abs(a.radius - b.radius));\n  } else if (isPoint(b)) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (c === undefined) {\n      return d <= a.radius;\n    } else {\n      // Defining a circle\n      return (d < Math.abs(a.radius - c));\n    }\n  } else throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import type { CirclePositioned } from \"./circle-type.js\";\nimport * as Intersects from '../intersects.js';\nimport { isContainedBy } from \"./is-contained-by.js\";\nimport { isCircle } from \"./guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\nimport type { Point } from '../point/point-type.js';\nimport { isPoint } from '../point/guard.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n * \n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number): boolean => {\n  if (PointsIsEqual(a, b)) return true;\n  if (isContainedBy(a, b, c)) return true;\n  if (isCircle(b)) {\n    return Intersects.circleCircle(a, b);\n  } else if (isRectPositioned(b)) {\n    return Intersects.circleRect(a, b);\n  } else if (isPoint(b) && c !== undefined) {\n    return Intersects.circleCircle(a, { ...b, radius: c });\n  }\n  return false;\n};","import { isCirclePositioned } from \"../circle/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/intersecting.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\n\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (\n  a: ShapePositioned,\n  b: ShapePositioned | Point\n): boolean => {\n  if (isCirclePositioned(a)) {\n    return CirclesIsIntersecting(a, b);\n  } else if (isRectPositioned(a)) {\n    return RectsIsIntersecting(a, b);\n  }\n  throw new Error(\n    `a or b are unknown shapes. a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`\n  );\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { toCartesian } from \"../polar/conversions.js\";\nimport { Empty as PointEmpty } from \"../point/empty.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (\n  outerRadius: number,\n  points = 5,\n  innerRadius?: number,\n  origin: Point = PointEmpty,\n  opts?: { readonly initialAngleRadian?: number }\n): readonly Point[] => {\n  resultThrow(integerTest(points, `positive`, `points`));\n  const angle = (Math.PI * 2) / points;\n  const angleHalf = angle / 2;\n\n  const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n  if (innerRadius === undefined) innerRadius = outerRadius / 2;\n\n  let a = initialAngle;\n  const pts: Point[] = [];\n\n  for (let index = 0; index < points; index++) {\n    const peak = toCartesian(outerRadius, a, origin);\n    const left = toCartesian(innerRadius, a - angleHalf, origin);\n    const right = toCartesian(innerRadius, a + angleHalf, origin);\n\n    pts.push(left, peak);\n    if (index + 1 < points) pts.push(right);\n    a += angle;\n  }\n  return pts;\n};\n","export type * from './shape-type.js';\nexport * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';","import { sortByNumericProperty } from \"@ixfx/arrays\";\nimport type { RandomSource } from \"@ixfx/random\";\nimport { randomPoint as ShapesRandomPoint, type ShapePositioned } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/intersecting.js\";\nimport type { Circle, CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Point } from \"./point/point-type.js\";\n\nexport type RandomOpts = {\n  readonly attempts?: number\n  readonly randomSource?: RandomSource\n}\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles: readonly Circle[], container: ShapePositioned, opts: RandomOpts = {}) => {\n  if (!Array.isArray(circles)) throw new Error(`Parameter 'circles' is not an array`);\n  const attempts = opts.attempts ?? 2000;\n\n  const sorted = sortByNumericProperty(circles, `radius`);\n  const positionedCircles: CirclePositioned[] = [];\n\n  const willHit = (b: Point, radius: number) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n\n  while (sorted.length > 0) {\n    //eslint-disable-next-line functional/immutable-data\n    const circle = sorted.pop();\n    if (!circle) break;\n\n    const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < attempts; index++) {\n      const position = ShapesRandomPoint(container, randomPointOpts);\n      if (!willHit(position, circle.radius)) {\n        //eslint-disable-next-line functional/immutable-data\n        positionedCircles.push(Object.freeze({ ...circle, ...position }));\n        break;\n      }\n    }\n  }\n\n  return positionedCircles;\n};","export * as CirclePacking from './circle-packing.js';","import type { Circle } from \"./circle-type.js\";\nimport { guard } from \"./guard.js\";\n\n/**\n * Returns the area of `circle`.\n * @param circle \n * @returns \n */\nexport const area = (circle: Circle) => {\n  guard(circle);\n  return Math.PI * circle.radius * circle.radius;\n};","import { type RectPositioned } from \"./rect-types.js\";\n\nimport type { Point } from \"../point/point-type.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { guardDim } from \"./guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  PointsGuard(origin, `origin`);\n\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n\n  const halfW = width / 2;\n  const halfH = height / 2;\n  return {\n    x: origin.x - halfW,\n    y: origin.y - halfH,\n    width: width,\n    height: height,\n  };\n};","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/from-center.js';\nimport type { RectPositioned } from \"../rect/rect-types.js\";\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns \n */\nexport const bbox = (circle: CirclePositioned | Circle): RectPositioned => {\n  return isCirclePositioned(circle) ?\n    RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n    { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\n\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n * \n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const { x, y, radius } = circle;\n\n  let xx = radius;\n  let yy = 0;\n  let radiusError = 1 - x;\n  while (xx >= yy) {\n    yield { x: xx + x, y: yy + y };\n    yield { x: yy + x, y: xx + y };\n    yield { x: -xx + x, y: yy + y };\n    yield { x: -yy + x, y: xx + y };\n    yield { x: -xx + x, y: -yy + y };\n    yield { x: -yy + x, y: -xx + y };\n    yield { x: xx + x, y: -yy + y };\n    yield { x: yy + x, y: -xx + y }\n    yy++;\n    if (radiusError < 0) {\n      radiusError += 2 * yy + 1;\n    } else {\n      xx--;\n      radiusError += 2 * (yy - xx + 1);\n    }\n  }\n}\n\n","import type { CirclePositioned } from \"./circle-type.js\";\nimport { distance } from \"../point/distance.js\";\nimport type { Point } from '../point/point-type.js';\n\n/**\n * Returns all integer points contained within `circle`.\n * \n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle \n */\nexport function* interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point> {\n  const xMin = circle.x - circle.radius;\n  const xMax = circle.x + circle.radius;\n  const yMin = circle.y - circle.radius;\n  const yMax = circle.y + circle.radius;\n  for (let x = xMin; x < xMax; x++) {\n    for (let y = yMin; y < yMax; y++) {\n      const r = Math.abs(distance(circle, x, y));\n      if (r <= circle.radius) yield { x, y };\n    }\n  }\n}","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport { guard, isCirclePositioned } from \"./guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\nconst piPi = Math.PI * 2;\n\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n * \n * ```js\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n * \n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle: CirclePositioned | readonly CirclePositioned[], point: Point): Point => {\n  const n = (a: CirclePositioned): Point => {\n    const l = Math.sqrt(Math.pow(point.x - a.x, 2) + Math.pow(point.y - a.y, 2));\n    const x = a.x + (a.radius * ((point.x - a.x) / l));\n    const y = a.y + (a.radius * ((point.y - a.y) / l));\n    return { x, y };\n  };\n\n  if (Array.isArray(circle)) {\n    const pts = circle.map(l => n(l));\n    const dists = pts.map(p => PointsDistance(p, point));\n    return Object.freeze<Point>(pts[ minIndex(...dists) ]);\n  } else {\n    return Object.freeze<Point>(n(circle as CirclePositioned));\n  }\n};\n\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n * \n * ```js\n * // Circle without position\n * const circleA = { radius: 5 };\n * \n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n * \n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point): Point => {\n  if (origin === undefined) {\n    origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n    y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n  };\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle \n * @returns \n */\nexport const circumference = (circle: Circle): number => {\n  guard(circle);\n  return piPi * circle.radius;\n};\n\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle \n * @returns \n */\nexport const length = (circle: Circle): number => circumference(circle);\n","import type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport { pointOnPerimeter } from \"./perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n * \n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * \n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle \n * @param t Position, 0-1\n * @returns \n */\nexport const interpolate = (circle: CirclePositioned, t: number): Point => pointOnPerimeter(circle, t * piPi);\n","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/multiply.js';\n\nexport function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport function multiplyScalar(a: Circle, value: number): Circle;\n\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n * \n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n * \n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a: Circle | CirclePositioned, value: number): Circle | CirclePositioned {\n  if (isCirclePositioned(a)) {\n    const pt = PointsMultiplyScalar(a, value);\n    return Object.freeze({\n      ...a,\n      ...pt,\n      radius: a.radius * value\n    });\n  } else {\n    return Object.freeze({\n      ...a,\n      radius: a.radius * value\n    });\n  }\n}\n\n","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleToSvg } from \"./circle-type.js\";\nimport { isCircle, isCirclePositioned } from \"./guard.js\";\n\n\n\n\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns \n */\nexport const toSvg: CircleToSvg = (a: CirclePositioned | number | Circle, sweep: boolean, origin?: Point): readonly string[] => {\n  if (isCircle(a)) {\n    if (origin !== undefined) {\n      return toSvgFull(a.radius, origin, sweep);\n    }\n    if (isCirclePositioned(a)) {\n      return toSvgFull(a.radius, a, sweep);\n    } else throw new Error(`origin parameter needed for non-positioned circle`);\n  } else {\n    if (origin === undefined) { throw new Error(`origin parameter needed`); } else {\n      return toSvgFull(a, origin, sweep);\n    }\n  }\n};\n\nconst toSvgFull = (radius: number, origin: Point, sweep: boolean): readonly string[] => {\n  // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n  const { x, y } = origin;\n  const s = sweep ? `1` : `0`;\n  return `\n    M ${ x }, ${ y }\n    m -${ radius }, 0\n    a ${ radius },${ radius } 0 1,${ s } ${ radius * 2 },0\n    a ${ radius },${ radius } 0 1,${ s } -${ radius * 2 },0\n  `.split(`\\n`);\n};\n","import type { Point } from \"../point/point-type.js\";\nimport { bbox } from \"./bbox.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { CircularPath } from \"./circular-path.js\";\nimport { guard } from \"./guard.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport { nearest } from \"./perimeter.js\";\nimport { toSvg } from \"./svg.js\";\nimport { circumference } from \"./perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle: CirclePositioned): CircularPath => {\n  guard(circle);\n\n  return {\n    ...circle,\n    nearest: (point: Point) => nearest(circle, point),\n    /**\n     * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n     * @param {t} Relative (0.0-1.0) point\n     * @returns {Point} X,y\n     */\n    interpolate: (t: number) => interpolate(circle, t),\n    bbox: () => bbox(circle),\n    length: () => circumference(circle),\n    toSvgString: (sweep = true) => toSvg(circle, sweep),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `circular`\n  };\n};","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport { isCirclePositioned } from \"./guard.js\";\nimport type { Point } from '../point/point-type.js';\nimport { getPointParameter } from \"../point/get-point-parameter.js\";\n\n\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle \n * @param defaultPositionOrX \n * @param y \n * @returns \n */\nexport const toPositioned = (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number): CirclePositioned => {\n  if (isCirclePositioned(circle)) return circle;\n\n  // Returns 0,0 if params are undefined\n  const pt = getPointParameter(defaultPositionOrX, y);\n  return Object.freeze({\n    ...circle,\n    ...pt\n  });\n};","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport type * from './circle-type.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n\n","import { guard } from \"./guard.js\";\nimport type { Rect } from \"./rect-types.js\";\n\n/**\n * Returns the area of `rect`\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect: Rect): number => {\n  guard(rect);\n  return rect.height * rect.width;\n};","import { guard } from \"./guard.js\";\nimport type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./guard.js\";\n\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number\n\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number\n\nexport function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\n\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth \n * @param heightValue \n * @returns \n */\nexport function applyFields(op: ApplyFieldOp, rectOrWidth: RectPositioned | Rect | number, heightValue?: number): RectPositioned | Rect {\n  let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n  let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n  if (width === undefined) throw new Error(`Param 'width' undefined`);\n  if (height === undefined) throw new Error(`Param 'height' undefined`);\n\n  width = op(width, `width`);\n  height = op(height, `height`);\n\n  if (typeof rectOrWidth === `object`) {\n    if (isPositioned(rectOrWidth)) {\n      const x = op(rectOrWidth.x, `x`);\n      const y = op(rectOrWidth.y, `y`);\n      return { ...rectOrWidth, width, height, x, y };\n    } else {\n      return {\n        ...rectOrWidth, width, height\n      }\n    }\n  }\n  return { width, height };\n}\n\nexport function applyMerge(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op \n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function applyMerge(\n  op: ApplyMergeOp,\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  guard(a, `a`);\n\n  if (isRect(b)) {\n    // Math op by another rectangle\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b.width),\n      y: op(a.y, b.height),\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    });\n  } else {\n    // Math op with a series of values\n    if (typeof b !== `number`) {\n      throw new TypeError(\n        `Expected second parameter of type Rect or number. Got ${ JSON.stringify(\n          b\n        ) }`\n      );\n    }\n    if (typeof c !== `number`) throw new Error(`Expected third param as height. Got ${ JSON.stringify(c) }`);\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b),\n      y: op(a.y, c),\n      width: op(a.width, b),\n      height: op(a.height, c),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b),\n      height: op(a.height, c),\n    });\n  }\n}\n\n/**\n * Uses `op` with `param` to width and height.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  parameter: number\n): RectPositioned;\n\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return isPositioned(rect) ? Object.freeze({\n    ...rect,\n    x: op(rect.x, parameter),\n    y: op(rect.y, parameter),\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  }) : Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}\n\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op \n * @param rect \n * @param parameter \n * @returns \n */\nexport function applyDim(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}","import type { RectPositioned } from \"./rect-types.js\";\nimport type { GridCardinalDirection } from '../grid/index.js';\nimport type { Point } from \"../point/point-type.js\";\n\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (\n  rect: RectPositioned,\n  card: GridCardinalDirection | `center`\n): Point => {\n  const { x, y, width, height } = rect;\n  switch (card) {\n    case `nw`: {\n      return Object.freeze({ x, y });\n    }\n    case `n`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y,\n      });\n    }\n    case `ne`: {\n      return Object.freeze({\n        x: x + width,\n        y,\n      });\n    }\n    case `sw`: {\n      return Object.freeze({ x, y: y + height });\n    }\n    case `s`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height,\n      });\n    }\n    case `se`: {\n      return Object.freeze({\n        x: x + width,\n        y: y + height,\n      });\n    }\n    case `w`: {\n      return Object.freeze({ x, y: y + height / 2 });\n    }\n    case `e`: {\n      return Object.freeze({ x: x + width, y: y + height / 2 });\n    }\n    case `center`: {\n      return Object.freeze({\n        x: x + width / 2,\n        y: y + height / 2,\n      });\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown direction: ${ card }`);\n    }\n  }\n};","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./apply.js\";\n\nconst divideOp = (a: number, b: number) => a / b;\n\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n * x & y value of second parameter are ignored\n * ```js\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport function divide(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport function divide(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Divides rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a \n * @param b \n */\nexport function divide(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function divide(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(divideOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(divideOp, rect, amount);\n}\n\nexport function divideDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(divideOp, rect, amount);\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { guard } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/join-points-to-lines.js';\n\nimport type { Point } from '../point/point-type.js';\nimport { corners } from \"./corners.js\";\nimport type { Line } from \"../line/line-type.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): readonly Line[] => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n});","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect \n * @param points \n * @returns \n */\nexport const encompass = (rect: RectPositioned, ...points: Point[]): RectPositioned => {\n  const x = points.map(p => p.x);\n  const y = points.map(p => p.y);\n\n  let minX = Math.min(...x, rect.x);\n  let minY = Math.min(...y, rect.y);\n  let maxX = Math.max(...x, rect.x + rect.width);\n  let maxY = Math.max(...y, rect.y + rect.height);\n\n  let rectW = Math.max(rect.width, maxX - minX);\n  let rectH = Math.max(rect.height, maxY - minY);\n\n  return Object.freeze({\n    ...rect,\n    x: minX,\n    y: minY,\n    width: rectW,\n    height: rectH\n  })\n} ","import type { Rect } from \"./rect-types.js\";\n\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el: HTMLElement): Rect => ({\n  width: el.clientWidth,\n  height: el.clientHeight,\n});","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport function fromNumbers(width: number, height: number): Rect;\n\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function fromNumbers(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): RectPositioned;\n\n/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n\nexport function fromNumbers(\n  xOrWidth: number,\n  yOrHeight: number,\n  width?: number,\n  height?: number\n): Rect | RectPositioned {\n  if (width === undefined || height === undefined) {\n    if (typeof xOrWidth !== `number`) throw new Error(`width is not an number`);\n    if (typeof yOrHeight !== `number`) {\n      throw new TypeError(`height is not an number`);\n    }\n    return Object.freeze({ width: xOrWidth, height: yOrHeight });\n  }\n  if (typeof xOrWidth !== `number`) throw new Error(`x is not an number`);\n  if (typeof yOrHeight !== `number`) throw new Error(`y is not an number`);\n  if (typeof width !== `number`) throw new Error(`width is not an number`);\n  if (typeof height !== `number`) throw new Error(`height is not an number`);\n\n  return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { isRect, isRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a \n * @param b \n * @param c \n * @param d \n * @returns \n */\nexport function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned {\n  if (typeof a === `number`) {\n    if (typeof b === `number`) {\n      if (typeof c === `number` && typeof d === `number`) {\n        return { x: a, y: b, width: c, height: d }\n      } else if (isRect(c)) {\n        return { x: a, y: b, width: c.width, height: c.height }\n      } else {\n        throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n      }\n    } else {\n      throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n    }\n  } else if (isRectPositioned(a)) {\n    return a;\n  } else if (isRect(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { width: a.width, height: a.height, x: b, y: c };\n    } else if (isPoint(b)) {\n      return { width: a.width, height: a.height, x: b.x, y: b.y };\n    } else {\n      throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n    }\n  } else if (isPoint(a)) {\n    if (typeof b === `number` && typeof c === `number`) {\n      return { x: a.x, y: a.y, width: b, height: c };\n    } else if (isRect(b)) {\n      return { x: a.x, y: a.y, width: b.width, height: b.height };\n    } else {\n      throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n    }\n  }\n  throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n\n","import { isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a: Rect, b: Rect): boolean => {\n  if (a === undefined) throw new Error(`a undefined`);\n  if (b === undefined) throw new Error(`b undefined`);\n  return a.width === b.width && a.height === b.height;\n};\n\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (\n  a: Rect | RectPositioned,\n  b: Rect | RectPositioned\n): boolean => {\n  if (isPositioned(a) && isPositioned(b)) {\n    if (!PointsIsEqual(a, b)) return false;\n    return a.width === b.width && a.height === b.height;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    return a.width === b.width && a.height === b.height;\n  } else {\n    // One param is positioned, the other is not\n    return false;\n  }\n};","import { length as LinesLength } from '../line/length.js';\n\nimport { edges } from './edges.js';\nimport { guardPositioned } from './guard.js';\nimport type { RectPositioned } from './rect-types.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect: RectPositioned): readonly number[] => {\n  guardPositioned(rect, `rect`);\n  return edges(rect).map((l) => LinesLength(l));\n};\n","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./apply.js\";\n\nconst multiplyOp = (a: number, b: number) => a * b;\n\n\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n * x/y value of second parameter are ignored.\n * ```js\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport function multiply(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function multiply(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(multiplyOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * \n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n\n\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n * \n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns \n */\nexport function multiplyDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n\n/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect \n * @param p \n * @returns \n */\nexport const nearestInternal = (rect: RectPositioned, p: Point): Point => {\n  let { x, y } = p;\n  if (x < rect.x) x = rect.x;\n  else if (x > rect.x + rect.width) x = rect.x + rect.width;\n  if (y < rect.y) y = rect.y;\n  else if (y > rect.y + rect.height) y = rect.y + rect.height;\n  return Object.freeze({ ...p, x, y });\n}","export const Placeholder = Object.freeze({\n  width: Number.NaN,\n  height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n  x: Number.NaN,\n  y: Number.NaN,\n  width: Number.NaN,\n  height: Number.NaN,\n});\n","import { guard } from \"./guard.js\";\nimport type { Rect } from \"./rect-types.js\";\n\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const perimeter = (rect: Rect): number => {\n  guard(rect);\n  return rect.height + rect.height + rect.width + rect.width;\n};\n","import { isPoint, isPoint3d } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\"\nimport type { Rect } from \"./rect-types.js\"\n\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n * \n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect \n * @returns \n */\nexport const dividerByLargestDimension = (rect: Rect) => {\n  const largest = Math.max(rect.width, rect.height);\n  return (value: number | Point) => {\n    if (typeof value === `number`) {\n      return value / largest;\n    } else if (isPoint3d(value)) {\n      return Object.freeze({\n        ...value,\n        x: value.x / largest,\n        y: value.y / largest,\n        z: value.x / largest\n      });\n    } else if (isPoint(value)) {\n      return Object.freeze({\n        ...value,\n        x: value.x / largest,\n        y: value.y / largest\n      });\n    } else throw new Error(`Param 'value' is neither number nor Point`);\n  }\n}","import { applyMerge } from \"./apply.js\";\nimport { isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\nconst subtractOp = (a: number, b: number) => a - b;\n\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * x,y of second parameter is ignored.\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function subtract(a: Rect, b: Rect | RectPositioned): Rect;\nexport function subtract(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * const rect = { width: 100, height: 100 };\n * Rects.subtract(rect, 200, 200);\n * // Yields: { width: -100, height: -100 }\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport function subtract(a: Rect, width: number, height: number): Rect;\n\nexport function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a: Rect | undefined, b: RectPositioned | Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return applyMerge(subtractOp, a, b, c);\n}\n\n/**\n * Subtracts a width & height from `a`. Leaves x & y as-is.\n * ```js\n * const rect = { x: 10, y: 20, width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { x:10, y: 20, width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport function subtractSize(a: RectPositioned, b: Rect | number, c?: number): RectPositioned;\n\n\n/**\n * Subtracts a width & height from `a`.\n * ```js\n * const rect = { width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport function subtractSize(a: Rect, b: Rect | number, c?: number): Rect;\n\n\n\nexport function subtractSize(a: Rect | RectPositioned, b: Rect | number, c?: number): Rect | RectPositioned {\n  const w = typeof b === `number` ? b : b.width;\n  const h = typeof b === `number` ? c : b.height;\n  if (h === undefined) throw new Error(`Expected height as third parameter`);\n  const r = {\n    ...a,\n    width: a.width - w,\n    height: a.height - h\n  };\n  return r;\n}\n\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 }, \n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a \n * @param b \n * @returns \n */\nexport function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x - xB,\n    y: y - yB,\n    width: a.width - b.width,\n    height: a.height - b.height\n  })\n}","import { applyMerge } from \"./apply.js\";\nimport { getRectPositioned, isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\nconst sumOp = (a: number, b: number) => a + b;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * x/y of second parameter are ignored\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport function sum(a: Rect, b: Rect | RectPositioned): Rect;\n\n/**\n * Sums width/height of `b` with `a`, returning result.\n * \n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n * \n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a \n * @param b \n */\nexport function sum(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Sums width/height of `rect` with `width` and `height`\n * \n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n\nexport function sum(a: Rect, b: RectPositioned | Rect | number, c?: number): Rect {\n  // @ts-ignore\n  return applyMerge(sumOp, a, b, c);\n}\n\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a \n * @param b \n * @returns \n */\nexport function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned {\n  let x = 0;\n  let y = 0;\n  if (isPositioned(a)) {\n    x = a.x;\n    y = a.y;\n  }\n  let xB = 0;\n  let yB = 0;\n  if (isPositioned(b)) {\n    xB = b.x;\n    yB = b.y;\n  }\n  return Object.freeze({\n    ...a,\n    x: x + xB,\n    y: y + yB,\n    width: a.width + b.width,\n    height: a.height + b.height\n  })\n}","import { isPositioned, isRect } from \"./guard.js\";\nimport type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./rect-types.js\";\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: Rect): RectArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport function toArray(rect: RectPositioned): RectPositionedArray;\n\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n\nexport function toArray(\n  rect: Rect | RectPositioned\n): RectArray | RectPositionedArray {\n  if (isPositioned(rect)) {\n    return [ rect.x, rect.y, rect.width, rect.height ];\n  } else if (isRect(rect)) {\n    return [ rect.width, rect.height ];\n  } else {\n    throw new Error(\n      `Param 'rect' is not a rectangle. Got: ${ JSON.stringify(rect) }`\n    );\n  }\n}\n","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\nexport type * from './rect-types.js';","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n","import { isQuadraticBezier } from \"../bezier/guard.js\";\nimport { isLine } from \"../line/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Path } from \"./path-type.js\";\n\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.a;\n  else if (isLine(path)) return path.a;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};\n\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path: Path): Point {\n  if (isQuadraticBezier(path)) return path.b;\n  else if (isLine(path)) return path.b;\n  else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n};","import { bbox as PointsBbox } from '../point/bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\nimport type { Point } from '../point/point-type.js';\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { sortByNumericProperty } from '@ixfx/arrays';\nimport { getEnd, getStart } from './start-end.js';\nimport type { CompoundPath, Dimensions, Path } from './path-type.js';\nimport type { RectPositioned } from '../rect/rect-types.js';\n\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath: CompoundPath, index: number, path: Path): CompoundPath => {\n  const existing = [ ...compoundPath.segments ];\n  //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n  existing[ index ] = path;\n  return fromPaths(...existing);\n};\n\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths: readonly Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n\n  // Expected value to land on\n  const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n  let soFar = 0;\n\n  // Use widths or lengths?\n  const l = useWidth ? dimensions.widths : dimensions.lengths;\n  for (const [ index, element ] of l.entries()) {\n    if (soFar + element >= expected) {\n      const relative = expected - soFar;\n      let amt = relative / element;\n      if (amt > 1) amt = 1;\n      return paths[ index ].interpolate(amt);\n    } else soFar += element;\n  }\n  return { x: 0, y: 0 };\n};\n\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths \n * @param point \n * @returns \n */\nexport const distanceToPoint = (paths: readonly Path[], point: Point): number => {\n  if (paths.length === 0) return 0;\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length === 0) throw new Error(`Could not look up distances`);\n  return distances[ 0 ].distance;\n}\n\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold \n * @param dimensions Pre-computed dimensions\n * @returns \n */\nexport const relativePosition = (paths: readonly Path[], point: Point, intersectionThreshold: number, dimensions?: Dimensions): number => {\n  if (dimensions === undefined) {\n    dimensions = computeDimensions(paths);\n  }\n  let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n  distances = sortByNumericProperty(distances, `distance`);\n  if (distances.length < 0) throw new Error(`Point does not intersect with path`);\n  const d = distances[ 0 ];\n  if (d.distance > intersectionThreshold) throw new Error(`Point does not intersect with path. Minimum distance: ${ d.distance }, threshold: ${ intersectionThreshold }`);\n\n  const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n\n  // Add up distances\n  let accumulated = 0;\n  for (let index = 0; index < d.index; index++) {\n    // Add up length of paths before closest path segment\n    accumulated += dimensions.lengths[ index ];\n  }\n\n  // Add up partial amount of closest path\n  accumulated += dimensions.lengths[ d.index ] * relativePositionOnPath;\n  const accumulatedRel = accumulated / dimensions.totalLength;\n  console.log(`acc: ${ accumulated } rel: ${ accumulatedRel } on path: ${ relativePositionOnPath } path: ${ d.index }`);\n  return accumulatedRel;\n}\n\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths: readonly Path[]): Dimensions => {\n  const widths = paths.map(l => l.bbox().width);\n  const lengths = paths.map(l => l.length());\n  let totalLength = 0;\n  let totalWidth = 0;\n  for (const length of lengths) {\n    totalLength += length;\n  }\n  for (const width of widths) {\n    totalWidth += width;\n  }\n\n  return { totalLength, totalWidth, widths, lengths };\n};\n\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths: readonly Path[]): RectPositioned => {\n  const boxes = paths.map(p => p.bbox());\n  const corners = boxes.flatMap(b => RectsCorners(b));\n\n  return PointsBbox(...corners);\n};\n\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths: readonly Path[]): string => paths.map(p => p.toString()).join(`, `);\n\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths: readonly Path[]) => {\n  let lastPos = getEnd(paths[ 0 ]);\n  for (let index = 1; index < paths.length; index++) {\n    const start = getStart(paths[ index ]);\n    if (!PointsIsEqual(start, lastPos)) throw new Error(`Path index ${ index } does not start at prior path end. Start: ${ start.x },${ start.y } expected: ${ lastPos.x },${ lastPos.y }`);\n    lastPos = getEnd(paths[ index ]);\n  }\n};\n\nexport const toSvgString = (paths: readonly Path[]): readonly string[] => paths.flatMap(p => p.toSvgString());\n\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths: readonly Path[]): CompoundPath => {\n  guardContinuous(paths); // Throws an error if paths are not connected\n  const dims = computeDimensions(paths);\n\n  return Object.freeze({\n    segments: paths,\n    length: () => dims.totalLength,\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    interpolate: (t: number, useWidth = false) => interpolate(paths, t, useWidth, dims),\n    relativePosition: (point: Point, intersectionThreshold: number) => relativePosition(paths, point, intersectionThreshold, dims),\n    distanceToPoint: (point: Point) => distanceToPoint(paths, point),\n    bbox: () => bbox(paths),\n    toString: () => toString(paths),\n    toSvgString: () => toSvgString(paths),\n    kind: `compound`\n  });\n};\n","export * from './compound-path.js';\nexport type * from './path-type.js';\nexport * from './start-end.js';\n\n","import type { Grid, GridCell } from \"./types.js\";\n\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid: Grid, cell: GridCell): boolean => {\n  if (cell.x < 0 || cell.y < 0) return false;\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\n  return true;\n};\n\n\n","import { inside } from \"./inside.js\";\nimport type { GridCell, Grid } from \"./types.js\";\n\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell: GridCell | undefined): cell is GridCell => {\n  if (cell === undefined) return false;\n  return `x` in cell && `y` in cell;\n};\n\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (\n  cell: GridCell,\n  parameterName = `Param`,\n  grid?: Grid\n) => {\n  if (cell === undefined) {\n    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n  }\n  if (cell.x === undefined) throw new Error(parameterName + `.x is undefined`);\n  if (cell.y === undefined) throw new Error(parameterName + `.y is undefined`);\n  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);\n  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);\n  if (!Number.isInteger(cell.x)) {\n    throw new TypeError(parameterName + `.x is non-integer`);\n  }\n  if (!Number.isInteger(cell.y)) {\n    throw new TypeError(parameterName + `.y is non-integer`);\n  }\n  if (grid !== undefined && !inside(grid, cell)) {\n    throw new Error(\n      `${ parameterName } is outside of grid. Cell: ${ cell.x },${ cell.y } Grid: ${ grid.cols }, ${ grid.rows }`\n    );\n  }\n};\n\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid: Grid, parameterName = `Param`) => {\n  if (grid === undefined) {\n    throw new Error(`${ parameterName } is undefined. Expecting grid.`);\n  }\n  if (!(`rows` in grid)) throw new Error(`${ parameterName }.rows is undefined`);\n  if (!(`cols` in grid)) throw new Error(`${ parameterName }.cols is undefined`);\n\n  if (!Number.isInteger(grid.rows)) {\n    throw new TypeError(`${ parameterName }.rows is not an integer`);\n  }\n  if (!Number.isInteger(grid.cols)) {\n    throw new TypeError(`${ parameterName }.cols is not an integer`);\n  }\n};","import { clampIndex } from \"@ixfx/numbers\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport type { GridBoundsLogic, GridCell, Grid } from \"./types.js\";\n\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid \n * @param cell \n * @param wrap \n * @returns \n */\nexport const applyBounds = function (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  guardGrid(grid, `grid`);\n  guardCell(cell, `cell`);\n\n  let x = cell.x;\n  let y = cell.y;\n  switch (wrap) {\n    case `wrap`: {\n      x = x % grid.cols;\n      y = y % grid.rows;\n      if (x < 0) x = grid.cols + x;\n      else if (x >= grid.cols) {\n        x -= grid.cols;\n      }\n      if (y < 0) y = grid.rows + y;\n      else if (y >= grid.rows) {\n        y -= grid.rows;\n      }\n      x = Math.abs(x);\n      y = Math.abs(y);\n      break;\n    }\n    case `stop`: {\n      x = clampIndex(x, grid.cols);\n      y = clampIndex(y, grid.rows);\n      break;\n    }\n    case `undefined`: {\n      if (x < 0 || y < 0) return;\n      if (x >= grid.cols || y >= grid.rows) return;\n      break;\n    }\n    case `unbounded`: {\n      break;\n    }\n    default: {\n      throw new Error(`Unknown BoundsLogic '${ wrap }'. Expected: wrap, stop, undefined or unbounded`);\n    }\n  }\n  return Object.freeze({ x, y });\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { indexFromCell } from \"./index.js\";\nimport type { GridCellAccessor, GridCell, GridBoundsLogic, Grid, GridCellSetter, GridReadable, GridWritable, GridArray1d } from \"./types.js\";\n\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n * \n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array \n * @param cols \n * @returns \n */\nexport const access = <V>(\n  array: readonly V[],\n  cols: number\n): GridCellAccessor<V> => {\n  const grid = gridFromArrayDimensions(array, cols);\n\n  const fn: GridCellAccessor<V> = (\n    cell: GridCell,\n    wrap: GridBoundsLogic = `undefined`\n  ): V | undefined => accessWithGrid(grid, array, cell, wrap);\n  return fn;\n};\n\nconst accessWithGrid = <T>(grid: Grid, array: readonly T[] | T[], cell: GridCell, wrap: GridBoundsLogic) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) return undefined;\n  return array[ index ];\n}\n\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n * \n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array \n * @param cols \n * @returns \n */\nexport const setMutate = <V>(\n  array: V[],\n  cols: number\n): GridCellSetter<V> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setMutateWithGrid = <V>(\n  grid: Grid,\n  array: V[],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  array[ index ] = value;\n  return array;\n}\n\nexport const set = <V>(\n  array: readonly V[],\n  cols: number\n) => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic) => setWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setWithGrid = <V>(\n  grid: Grid,\n  array: readonly V[],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  const index = indexFromCell(grid, cell, wrap);\n  if (index === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  const copy = [ ...array ];\n  copy[ index ] = value;\n  array = copy;\n  return copy;\n}\n\n/**\n * Creates a {@link Grid} from the basis of an array and a given number of columns\n * @param array \n * @param cols \n * @returns \n */\nconst gridFromArrayDimensions = <T>(array: readonly T[] | T[], cols: number): Grid => {\n  const grid = { cols, rows: Math.ceil(array.length / cols) };\n  return grid;\n}\n\n\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *  \n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n * \n * Use {@link wrap} for an immutable version.\n * \n * @param array Array to wrap\n * @param cols Width of grid\n * @returns \n */\nexport const wrapMutable = <T>(array: T[], cols: number): GridArray1d<T> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return {\n    ...grid,\n    get: access(array, cols),\n    set: setMutate(array, cols),\n    get array() {\n      return array;\n    }\n  }\n}\n\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n * \n * ```js\n * const myArray = [\n *    `a`, `b`, `c`, \n *    `d`, `e`, `f` \n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n * \n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n * \n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns \n */\nexport const wrap = <T>(array: T[], cols: number): GridArray1d<T> => {\n  const grid = gridFromArrayDimensions(array, cols);\n  return {\n    ...grid,\n    get: (cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n    set: (value: T, cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => {\n      array = setWithGrid(grid, array, value, cell, boundsLogic);\n      return wrap(array, cols);\n    },\n    get array() {\n      return array;\n    }\n  }\n}\n\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n * \n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n * \n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport const createArray = <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number): T[] => {\n  const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n  if (!cols) throw new Error(`Parameter 'columns' missing`);\n  resultThrow(\n    integerTest(rows, `aboveZero`, `rows`),\n    integerTest(cols, `aboveZero`, `cols`)\n  );\n\n  const t: T[] = [];\n  const total = rows * cols;\n  for (let index = 0; index < total; index++) {\n    t[ index ] = initialValue;\n  }\n  return t;\n}\n\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n * \n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue \n * @param rowsOrGrid \n * @param columns \n * @returns \n */\nexport const createMutable = <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number): GridArray1d<T> => {\n  const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n  const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n  if (!cols) throw new Error(`Parameter 'columns' missing`);\n  const array = createArray(initialValue, rows, cols);\n  return wrapMutable(array, cols);\n}\n","import { applyBounds } from \"./apply-bounds.js\";\nimport type { GridBoundsLogic, GridCell, GridCellAccessor, GridCellSetter, Grid, GridReadable, GridWritable } from \"./types.js\";\n\nexport type ArrayGrid<T> = GridReadable<T> & GridWritable<T> & {\n  array: T[][]\n}\n\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array \n * @returns \n */\nexport const create = <T>(array: ReadonlyArray<T[]> | Array<T[]>): Grid => {\n  let colLen = NaN;\n  for (const row of array) {\n    if (Number.isNaN(colLen)) {\n      colLen = row.length;\n    } else {\n      if (colLen !== row.length) throw new Error(`Array does not have uniform column length`);\n    }\n  }\n\n  return { rows: array.length, cols: colLen };\n}\n\nexport const setMutate = <V>(\n  array: V[][]\n): GridCellSetter<V> => {\n  const grid = create(array);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n}\n\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.Array2d.setMutateWithGrid(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\nconst setMutateWithGrid = <V>(\n  grid: Grid,\n  array: V[][],\n  value: V, cell: GridCell, bounds: GridBoundsLogic\n) => {\n  let boundCell = applyBounds(grid, cell, bounds);\n  if (boundCell === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  array[ boundCell.y ][ boundCell.x ] = value;\n  return array;\n}\n// export const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n//   const fn = (v: V, position: Cell) => {\n//     const pos = cellAtPoint(grid, position);\n//     if (pos === undefined) {\n//       throw new Error(\n//         `Position does not exist. Pos: ${ JSON.stringify(\n//           position\n//         ) } Grid: ${ JSON.stringify(grid) }`\n//       );\n//     }\n//     array[ pos.y ][ pos.x ] = v;\n//   };\n//   return fn;\n// };\n\nexport const access = <T>(\n  array: ReadonlyArray<T[]>\n): GridCellAccessor<T> => {\n  const grid = create(array);\n\n  const fn: GridCellAccessor<T> = (\n    cell: GridCell,\n    wrap: GridBoundsLogic = `undefined`\n  ): T | undefined => accessWithGrid(grid, array, cell, wrap);\n  return fn;\n};\n\nconst accessWithGrid = <T>(grid: Grid, array: ReadonlyArray<T[]> | Array<T[]>, cell: GridCell, wrap: GridBoundsLogic) => {\n  let boundCell = applyBounds(grid, cell, wrap);\n  if (boundCell === undefined) return undefined;\n  return array[ boundCell.y ][ boundCell.x ];\n}\n\nexport const wrapMutable = <T>(array: T[][]): ArrayGrid<T> => {\n  const grid = create(array);\n  return {\n    ...grid,\n    get: access(array),\n    set: setMutate(array),\n    get array() {\n      return array;\n    }\n  }\n}\n\nexport const set = <V>(\n  array: readonly V[][]\n) => {\n  const grid = create(array);\n  return (value: V, cell: GridCell, wrap: GridBoundsLogic) => setWithGrid(grid, array, value, cell, wrap);\n}\n\nconst setWithGrid = <V>(\n  grid: Grid,\n  array: readonly V[][],\n  value: V, cell: GridCell, wrap: GridBoundsLogic\n) => {\n  let boundCell = applyBounds(grid, cell, wrap);\n  if (boundCell === undefined) throw new RangeError(`Cell (${ cell.x },${ cell.y }) is out of range of grid cols: ${ grid.cols } rows: ${ grid.rows }`);\n  let copyWhole = [ ...array ];\n  let copyRow = [ ...copyWhole[ boundCell.y ] ];\n  copyRow[ boundCell.x ] = value;\n  copyWhole[ boundCell.y ] = copyRow;\n  array = copyWhole;\n  return copyWhole;\n}\n\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n * \n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n * \n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns \n */\nexport const wrap = <T>(array: T[][]): ArrayGrid<T> => {\n  const grid = create(array);\n  return {\n    ...grid,\n    get: (cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n    set: (value: T, cell: GridCell, boundsLogic: GridBoundsLogic = `undefined`) => {\n      array = setWithGrid(grid, array, value, cell, boundsLogic);\n      return wrap(array);\n    },\n    get array() {\n      return array;\n    }\n  }\n}","import type { GridReadable, GridCell, GridBoundsLogic } from \"./types.js\";\n\n\nexport function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell>): Generator<T>\nexport function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell[]>): Generator<T[]>\n\n/**\n * Converts an 1D or 2D array of cell coordinates into values\n * \n * ```js\n * // 1D (ie an array of coordinates)\n * const cells = Grid.As.cells(grid);\n * for (const v of Grid.values(grid, cells)) {\n * \n * }\n * ```\n * ```js\n * // 2D (ie an array of rows)\n * const rows = Grid.As.rows(grid);\n * for (const v of Grid.values(grid, rows)) {\n * }\n * ```\n * @param grid \n * @param iter \n */\nexport function* values<T>(grid: GridReadable<T>, iter: Iterable<GridCell> | Iterable<GridCell[]>) {\n  for (const d of iter) {\n    if (Array.isArray(d)) {\n      yield d.map(v => grid.get(v, `undefined`));\n    } else {\n      yield grid.get(d, `undefined`);\n    }\n  }\n}\n\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell[]>, wrap?: BoundsLogic): Generator<T[]>\n\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell>, wrap?: BoundsLogic): Generator<T>\n\n// /**\n//  * Visits the values of a readable grid\n//  * @param readable Readable grid\n//  * @param visitor Visitor\n//  * @param wrap Wrapping logic, defaultign to 'undefined'\n//  */\n// export function* visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell | Cell[]>, wrap: BoundsLogic = `undefined`) {\n//   for (const cellOrCells of visitor) {\n//     if (Array.isArray(cellOrCells)) {\n//       yield cellOrCells.map(cell => readable.accessor(cell, wrap));\n//     } else {\n//       yield readable.accessor(cellOrCells, wrap);\n//     }\n//   }\n// }","import { guardGrid, guardCell } from \"../guards.js\";\nimport type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../types.js\";\nimport { values } from \"../values.js\";\n\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n * \n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n * \n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n * \n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n * \n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid: Grid, start?: GridCell, wrap = true) {\n  if (!start) start = { x: 0, y: 0 }\n\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  let { x, y } = start;\n  let canMove = true;\n  do {\n    yield { x, y };\n    x++;\n    if (x === grid.cols) {\n      y++;\n      x = 0;\n    }\n    if (y === grid.rows) {\n      if (wrap) {\n        y = 0;\n        x = 0;\n      } else {\n        canMove = false;\n      }\n    }\n    if (x === start.x && y === start.y) canMove = false; // Complete\n  } while (canMove);\n};\n\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n * \n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true) {\n  yield* values(grid, cells(grid, start, wrap));\n}\n\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true): Generator<GridCellAndValue<T>> {\n  for (const cell of cells(grid, start, wrap)) {\n    yield { cell, value: grid.get(cell) }\n  }\n}","import type { GridCell, Grid, GridReadable } from \"./types.js\";\nimport { cells } from \"./enumerators/cells.js\";\n\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n * \n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 }\n  let row = start.y;\n  let rowCells: Array<GridCell> = [];\n\n  for (const c of cells(grid, start)) {\n    if (c.y === row) {\n      rowCells.push(c);\n    } else {\n      yield rowCells;\n      rowCells = [ c ];\n      row = c.y;\n    }\n  }\n  if (rowCells.length > 0) yield rowCells;\n};\n\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n * \n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n * \n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid \n * @param start \n */\nexport function* columns(grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 };\n  for (let x = start.x; x < grid.cols; x++) {\n    let colCells: Array<GridCell> = [];\n    for (let y = start.y; y < grid.rows; y++) {\n      colCells.push({ x, y });\n    }\n    yield colCells;\n  }\n}","//import { clampIndex } from '@ixfx/numbers';\nimport { applyBounds } from './apply-bounds.js';\n//import { guardCell, guardGrid } from './guards.js';\nimport type { Grid, GridCell, GridBoundsLogic } from './types.js';\n\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n * \n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (\n  grid: Grid,\n  start: GridCell,\n  vector: GridCell,\n  bounds: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  return applyBounds(grid, {\n    x: start.x + vector.x,\n    y: start.y + vector.y\n  }, bounds)\n  // guardCell(start, `start`, grid);\n  // guardCell(vector);\n  // guardGrid(grid, `grid`);\n\n  // // eslint-disable-next-line functional/no-let\n  // let x = start.x;\n  // // eslint-disable-next-line functional/no-let\n  // let y = start.y;\n  // switch (bounds) {\n  //   case `wrap`: {\n  //     x += vector.x % grid.cols;\n  //     y += vector.y % grid.rows;\n  //     if (x < 0) x = grid.cols + x;\n  //     else if (x >= grid.cols) {\n  //       x -= grid.cols;\n  //     }\n  //     if (y < 0) y = grid.rows + y;\n  //     else if (y >= grid.rows) {\n  //       y -= grid.rows;\n  //     }\n  //     break;\n  //   }\n  //   case `stop`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     x = clampIndex(x, grid.cols);\n  //     y = clampIndex(y, grid.rows);\n  //     break;\n  //   }\n  //   case `undefined`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     if (x < 0 || y < 0) return;\n  //     if (x >= grid.cols || y >= grid.rows) return;\n  //     break;\n  //   }\n  //   case `unbounded`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     break;\n  //   }\n  //   default: {\n  //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n  //   }\n  // }\n  // return Object.freeze({ x, y });\n};\n\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport type { GridBoundsLogic, GridCardinalDirection, GridCardinalDirectionOptional, GridCell, Grid, GridNeighbours } from \"./types.js\";\nimport { offset } from \"./offset.js\";\n\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n  `n`,\n  `ne`,\n  `nw`,\n  `e`,\n  `s`,\n  `se`,\n  `sw`,\n  `w`,\n]) as readonly GridCardinalDirection[];\n\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n  `n`,\n  `e`,\n  `s`,\n  `w`,\n]) as readonly GridCardinalDirection[];\n\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (\n  grid: Grid,\n  start: GridCell,\n  steps: number,\n  bounds: GridBoundsLogic = `stop`\n): GridNeighbours => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  resultThrow(integerTest(steps, `aboveZero`, `steps`));\n\n  const directions = allDirections;\n  const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n  const cells = directions.map((d, index) =>\n    offset(grid, start, vectors[ index ], bounds)\n  );\n\n  return zipKeyValue(directions, cells) as GridNeighbours;\n};\n\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (\n  cardinal: GridCardinalDirectionOptional,\n  multiplier = 1\n): GridCell => {\n  let v;\n  switch (cardinal) {\n    case `n`: {\n      v = { x: 0, y: -1 * multiplier };\n      break;\n    }\n    case `ne`: {\n      v = { x: 1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    case `e`: {\n      v = { x: 1 * multiplier, y: 0 };\n      break;\n    }\n    case `se`: {\n      v = { x: 1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `s`: {\n      v = { x: 0, y: 1 * multiplier };\n      break;\n    }\n    case `sw`: {\n      v = { x: -1 * multiplier, y: 1 * multiplier };\n      break;\n    }\n    case `w`: {\n      v = { x: -1 * multiplier, y: 0 };\n      break;\n    }\n    case `nw`: {\n      v = { x: -1 * multiplier, y: -1 * multiplier };\n      break;\n    }\n    default: {\n      v = { x: 0, y: 0 };\n    }\n  }\n  return Object.freeze(v);\n};","//import type { Cell, GridReadable } from '../Types.js';\n\nexport * from './cells.js';\n\n// export function* withValues<T>(grid: GridReadable<T>, iter: IterableIterator<Cell>) {\n//   for (const cell of iter) {\n//     yield { cell, value: grid.get(cell, `undefined`) };\n//   }\n// }","import { guardCell } from \"./guards.js\";\nimport type { GridCell } from \"./types.js\";\n\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start: GridCell, end: GridCell): ReadonlyArray<GridCell> => {\n  // https://stackoverflow.com/a/4672319\n  guardCell(start);\n  guardCell(end);\n\n  let startX = start.x;\n  let startY = start.y;\n  const dx = Math.abs(end.x - startX);\n  const dy = Math.abs(end.y - startY);\n  const sx = startX < end.x ? 1 : -1;\n  const sy = startY < end.y ? 1 : -1;\n  let error = dx - dy;\n\n  const cells:GridCell[] = [];\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    cells.push(Object.freeze({ x: startX, y: startY }));\n    if (startX === end.x && startY === end.y) break;\n    const error2 = 2 * error;\n    if (error2 > -dy) {\n      error -= dy;\n      startX += sx;\n    }\n    if (error2 < dx) {\n      error += dx;\n      startY += sy;\n    }\n  }\n  return cells;\n};\n\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (\n  start: GridCell,\n  end: GridCell,\n  endInclusive = false\n): ReadonlyArray<GridCell> {\n  const cells: Array<GridCell> = [];\n  if (start.x === end.x) {\n    // Vertical\n    const lastY = endInclusive ? end.y + 1 : end.y;\n    for (let y = start.y; y < lastY; y++) {\n      cells.push({ x: start.x, y: y });\n    }\n  } else if (start.y === end.y) {\n    // Horizontal\n    const lastX = endInclusive ? end.x + 1 : end.x;\n    for (let x = start.x; x < lastX; x++) {\n      cells.push({ x: x, y: start.y });\n    }\n  } else {\n    throw new Error(\n      `Only does vertical and horizontal: ${ start.x },${ start.y } - ${ end.x },${ end.y }`\n    );\n  }\n  return cells;\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\nimport type { Grid, GridCell, GridBoundsLogic } from \"./types.js\";\n\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic\n): number | undefined => {\n  guardGrid(grid, `grid`);\n\n  if (cell.x < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        //cell = { ...cell, x: grid.cols + cell.x };\n        cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`)!;\n        break;\n      }\n    }\n  }\n  if (cell.y < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: grid.rows + cell.y };\n        break;\n      }\n    }\n  }\n  if (cell.x >= grid.cols) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: grid.cols - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, x: cell.x % grid.cols };\n        break;\n      }\n    }\n  }\n  if (cell.y >= grid.rows) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: grid.rows - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: cell.y % grid.rows };\n        break;\n      }\n    }\n  }\n\n  const index = cell.y * grid.cols + cell.x;\n\n  return index;\n};\n\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (\n  colsOrGrid: number | Grid,\n  index: number\n): GridCell => {\n  let cols = 0;\n  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n  resultThrow(integerTest(cols, `aboveZero`, `colsOrGrid`));\n\n  return {\n    x: index % cols,\n    y: Math.floor(index / cols),\n  };\n};","import type { GridCell, Grid, GridVisual } from \"./types.js\";\n\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (\n  a: Grid | GridVisual,\n  b: Grid | GridVisual\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  if (`rows` in a && `cols` in a) {\n    if (`rows` in b && `cols` in b) {\n      if (a.rows !== b.rows || a.cols !== b.cols) return false;\n    } else return false;\n  }\n  if (`size` in a) {\n    if (`size` in b) {\n      if (a.size !== b.size) return false;\n    } else return false;\n  }\n  return true;\n};\n\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (\n  a: GridCell | undefined,\n  b: GridCell | undefined\n): boolean => {\n  if (b === undefined) return false;\n  if (a === undefined) return false;\n  return a.x === b.x && a.y === b.y;\n};","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { allDirections, getVectorFromCardinal } from \"./directions.js\";\nimport type { GridBoundsLogic, GridCardinalDirection, GridCell, Grid, GridNeighbour, GridNeighbourMaybe, GridNeighbours } from \"./types.js\";\nimport { randomElement } from \"@ixfx/random\";\nimport { offset } from \"./offset.js\";\n\nexport const randomNeighbour = (nbos: readonly GridNeighbour[]) => randomElement(nbos); // .filter(isNeighbour));\n\n/**\n * Returns _true_ if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (\n  n: GridNeighbour | GridNeighbourMaybe | undefined\n): n is GridNeighbour => {\n  if (n === undefined) return false;\n  if (n[ 1 ] === undefined) return false;\n  return true;\n};\n\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n * \n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n * \n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions \n * @param bounds Bounds\n * @returns \n */\nexport const neighbourList = (\n  grid: Grid,\n  cell: GridCell,\n  directions: readonly GridCardinalDirection[],\n  bounds: GridBoundsLogic\n): readonly GridNeighbour[] => {\n  // Get neighbours for cell\n  const cellNeighbours = neighbours(grid, cell, bounds, directions);\n\n  // Filter out undefined cells\n  const entries = Object.entries(cellNeighbours);\n  return (entries as GridNeighbourMaybe[]).filter(n => isNeighbour(n));\n};\n\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (\n  grid: Grid,\n  cell: GridCell,\n  bounds: GridBoundsLogic = `undefined`,\n  directions?: readonly GridCardinalDirection[]\n): GridNeighbours => {\n  const directories = directions ?? allDirections;\n  const points = directories.map((c) =>\n    offset(grid, cell, getVectorFromCardinal(c), bounds)\n  );\n  return zipKeyValue<GridCell>(directories, points) as GridNeighbours;\n};","\n/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\n\nimport type { Grid } from \"./types.js\";\n\nexport const toArray2d = <V>(grid: Grid, initialValue?: V): V[][] => {\n  const returnValue:V[][] = [];\n  for (let row = 0; row < grid.rows; row++) {\n    returnValue[ row ] = Array.from<V>({ length: grid.cols });\n    if (initialValue) {\n      for (let col = 0; col < grid.cols; col++) {\n        returnValue[ row ][ col ] = initialValue;\n      }\n    }\n  }\n  return returnValue;\n};","import type { GridCell } from \"./types.js\";\n\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v: GridCell): string => `Cell{${ v.x },${ v.y }}`;\n","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport { guardCell } from \"./guards.js\";\nimport type { GridCell, GridVisual } from \"./types.js\";\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from \"../point/point-type.js\";\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { cells } from \"./enumerators/cells.js\";\n\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(\n  grid: GridVisual\n): IterableIterator<RectPositioned> {\n  for (const c of cells(grid)) {\n    yield rectangleForCell(grid, c);\n  }\n}\n\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (\n  grid: GridVisual,\n  position: Point\n): GridCell | undefined => {\n  const size = grid.size;\n  resultThrow(numberTest(size, `positive`, `grid.size`));\n  if (position.x < 0 || position.y < 0) return;\n  const x = Math.floor(position.x / size);\n  const y = Math.floor(position.y / size);\n  if (x >= grid.cols) return;\n  if (y >= grid.rows) return;\n  return { x, y };\n};\n\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (\n  grid: GridVisual,\n  cell: GridCell\n): RectPositioned => {\n  guardCell(cell);\n  const size = grid.size;\n  const x = cell.x * size;\n  const y = cell.y * size;\n  const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n  return r;\n};\n\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid: GridVisual, cell: GridCell): Point => {\n  guardCell(cell);\n\n  const size = grid.size;\n  const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n  const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n  return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};","import type { Grid, GridCell, GridVisitorOpts, GridNeighbourSelectionLogic } from \"../types.js\";\n//import { visitor } from \"./Visitor.js\";\n\n// export const visitorBreadth = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos[ 0 ],\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const breadthLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (nbos) => nbos[ 0 ],\n  }\n}","import { allDirections } from \"../directions.js\";\nimport { neighbourList } from \"../neighbour.js\";\nimport type { GridNeighbour, GridNeighbourSelectionLogic } from \"../types.js\";\n\n// export function* cellNeigbours(\n//   grid: Grid,\n//   cell: Cell,\n//   bounds: BoundsLogic = `undefined`,\n//   directions?: ReadonlyArray<CardinalDirection>\n// ) {\n//   const dirs = directions ?? allDirections;\n//   const points = dirs.map((c) =>\n//     offset(grid, cell, getVectorFromCardinal(c), bounds)\n//   );\n//   for (const pt of points) {\n//     if (pt !== undefined) yield pt;\n//   }\n// }\n\nexport const neighboursLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (neighbours: readonly GridNeighbour[]) => {\n      return neighbours.at(0);\n    },\n    getNeighbours: (grid, cell) => {\n      return neighbourList(grid, cell, allDirections, `undefined`)\n    }\n  }\n}\n","import type { GridNeighbour, GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n\n/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport const columnLogic = (opts: Partial<GridVisitorOpts> = {}): GridNeighbourSelectionLogic => {\n  const reversed = opts.reversed ?? false;\n  return {\n    select: (nbos) => nbos.find((n) => n[ 0 ] === (reversed ? `n` : `s`)),\n    getNeighbours: (grid, cell): ReadonlyArray<GridNeighbour> => {\n      if (reversed) {\n        // WALK UP COLUMN, RIGHT-TO-LEFT\n        if (cell.y > 0) {\n          // Easy case\n          cell = { x: cell.x, y: cell.y - 1 };\n        } else {\n          // Top of column\n          if (cell.x === 0) {\n            // Top-left corner, need to wrap\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          } else {\n            cell = { x: cell.x - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n        if (cell.y < grid.rows - 1) {\n          // Easy case, move down by one\n          cell = { x: cell.x, y: cell.y + 1 };\n        } else {\n          // End of column\n          if (cell.x < grid.cols - 1) {\n            // Move to next column and start at top\n            cell = { x: cell.x + 1, y: 0 };\n          } else {\n            // Move to start of grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `n` : `s`, cell ] ];\n    }\n  }\n}","import type { GridNeighbourSelectionLogic } from \"../types.js\";\n\n// export const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos.at(-1),\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const depthLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: (nbos) => nbos.at(-1)\n  }\n}","import { randomNeighbour } from \"../neighbour.js\";\nimport type { GridNeighbour, GridNeighbourSelectionLogic } from \"../types.js\";\nimport { cells } from \"../enumerators/cells.js\";\n\n// export const visitorRandom = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\n\nexport const randomLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    getNeighbours: (grid, cell) => {\n      const t: Array<GridNeighbour> = [];\n      for (const c of cells(grid, cell)) {\n        t.push([ `n`, c ]);\n      }\n      return t;\n    },\n    select: randomNeighbour,\n  }\n}","import { randomNeighbour } from \"../neighbour.js\";\nimport type { GridNeighbourSelectionLogic } from \"../types.js\";\n\n// export const visitorRandomContiguous = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomContiguousLogic = (): GridNeighbourSelectionLogic => {\n  return {\n    select: randomNeighbour,\n  }\n}","import type { GridCell, Grid, GridNeighbour, GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n\n/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport const rowLogic = (opts: Partial<GridVisitorOpts> = {}): GridNeighbourSelectionLogic => {\n  const reversed = opts.reversed ?? false;\n  return {\n    select: (nbos: ReadonlyArray<GridNeighbour>) =>\n      nbos.find((n) => n[ 0 ] === (reversed ? `w` : `e`)),\n    getNeighbours: (\n      grid: Grid,\n      cell: GridCell\n    ): ReadonlyArray<GridNeighbour> => {\n      if (reversed) {\n        // WALKING BACKWARD ALONG ROW\n        if (cell.x > 0) {\n          // All fine, step to the left\n          cell = { x: cell.x - 1, y: cell.y };\n        } else {\n          // At the beginning of a row\n          if (cell.y > 0) {\n            // Wrap to next row up\n            cell = { x: grid.cols - 1, y: cell.y - 1 };\n          } else {\n            // Wrap to end of grid\n            cell = { x: grid.cols - 1, y: grid.rows - 1 };\n          }\n        }\n      } else {\n        /*\n         * WALKING FORWARD ALONG ROWS\n         */\n        if (cell.x < grid.rows - 1) {\n          // All fine, step to the right\n          cell = { x: cell.x + 1, y: cell.y };\n        } else {\n          // At the end of a row\n          // eslint-disable-next-line unicorn/prefer-ternary\n          if (cell.y < grid.rows - 1) {\n            // More rows available, wrap to next row down\n            cell = { x: 0, y: cell.y + 1 };\n          } else {\n            // No more rows available, wrap to start of the grid\n            cell = { x: 0, y: 0 };\n          }\n        }\n      }\n      return [ [ reversed ? `w` : `e`, cell ] ];\n    }\n  }\n}","import { mutable } from '@ixfx/collections/set';\nimport { crossDirections } from \"../directions.js\";\nimport { guardGrid, guardCell, isCell } from \"../guards.js\";\nimport { cellEquals } from \"../is-equal.js\";\nimport { neighbourList } from '../neighbour.js';\nimport { cellKeyString } from \"../to-string.js\";\nimport type { GridNeighbourSelectionLogic, Grid, GridCell, GridVisitorOpts, GridNeighbour } from \"../types.js\";\n\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a @ixfx/collections.Sets.ISetMutable instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport function* visitByNeighbours(\n  logic: GridNeighbourSelectionLogic,\n  grid: Grid,\n  opts: Partial<GridVisitorOpts> = {}\n): Generator<GridCell> {\n  guardGrid(grid, `grid`);\n  const start = opts.start ?? { x: 0, y: 0 };\n\n  guardCell(start, `opts.start`, grid);\n\n  const v = opts.visited ?? mutable<GridCell>(cellKeyString);\n  const possibleNeighbours = logic.getNeighbours ?? ((g: Grid, c: GridCell) => neighbourList(g, c, crossDirections, `undefined`));\n\n  let cellQueue: GridCell[] = [ start ];\n  let moveQueue: GridNeighbour[] = [];\n  let current: GridCell | undefined = undefined;\n\n  while (cellQueue.length > 0) {\n    if (current === undefined) {\n      const nv = cellQueue.pop();\n      if (nv === undefined) {\n        break;\n      }\n      current = nv;\n    }\n\n    if (!v.has(current)) {\n      v.add(current);\n      yield current;\n\n      const nextSteps = possibleNeighbours(grid, current).filter(\n        (step) => {\n          if (step[ 1 ] === undefined) return false;\n          return !v.has(step[ 1 ])\n        }\n      );\n\n      if (nextSteps.length === 0) {\n        // No more moves for this cell\n        if (current !== undefined) {\n          cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n        }\n      } else {\n        for (const n of nextSteps) {\n          if (n === undefined) continue;\n          if (n[ 1 ] === undefined) continue;\n          moveQueue.push(n);\n        }\n      }\n    }\n\n    // Remove steps already made\n    moveQueue = moveQueue.filter((step) => !v.has(step[ 1 ]));\n\n    if (moveQueue.length === 0) {\n      current = undefined;\n    } else {\n      // Pick move\n      const potential = logic.select(moveQueue);\n      if (potential !== undefined) {\n        cellQueue.push(potential[ 1 ]);\n        current = potential[ 1 ];\n      }\n    }\n  }\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"../guards.js\";\nimport type { Grid, GridCell, GridCreateVisitor } from \"../types.js\";\n\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n * \n * // Step by 10\n * stepper(10); // GridCell {x,y}\n * \n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport const stepper = (\n  grid: Grid,\n  createVisitor: GridCreateVisitor,\n  start: GridCell = { x: 0, y: 0 },\n  resolution = 1\n) => {\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`);\n  resultThrow(integerTest(resolution, ``, `resolution`));\n\n  // Create a list of steps\n  const steps: GridCell[] = [];\n  let count = 0;\n  let position = 0;\n  for (const c of createVisitor(grid, { start, boundsWrap: `undefined` })) {\n    count++;\n    if ((count % resolution) !== 0) continue;\n    steps.push(c);\n  }\n\n  return (step: number, fromStart = false) => {\n    resultThrow(integerTest(step, ``, `step`));\n    if (fromStart) position = step;\n    else position += step;\n    //position = position % steps.length;\n    return steps.at(position % steps.length);\n\n  }\n}\n\n// export const step = (\n//   grid: Grid,\n//   start: Cell,\n//   steps: number,\n//   createVisitor: CreateVisitor\n// ): Cell => {\n//   throwIntegerTest(steps, ``, `steps`);\n\n//   const opts: Partial<VisitorOpts> = {\n//     reversed: steps < 0,\n//     start\n//   };\n//   steps = Math.abs(steps);\n\n//   let c = start;\n//   let v = createVisitor(grid, opts);\n//   v.next(); // Burn up starting cell\n\n//   let stepsMade = 0;\n\n//   while (stepsMade < steps) {\n//     stepsMade++;\n//     const { value } = v.next();\n//     if (value) {\n//       c = value;\n//       if (opts.debug) {\n//         console.log(\n//           `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n//         );\n//       }\n//     } else {\n//       if (steps >= grid.cols * grid.rows) {\n//         steps -= grid.cols * grid.rows;\n//         stepsMade = 0;\n//         v = createVisitor(grid, opts);\n//         v.next();\n//         c = start;\n//         if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n//       } else throw new Error(`Value not received by visitor`);\n//     }\n//   }\n//   return c;\n// };\n","import type { GridCell, GridCreateVisitor, Grid, GridReadable, GridNeighbourSelectionLogic, GridVisitorOpts } from '../types.js';\nimport { breadthLogic } from './breadth.js';\nimport { neighboursLogic } from './cell-neighbours.js';\nimport { columnLogic } from './columns.js';\nimport { depthLogic } from './depth.js';\nimport { randomLogic } from './random.js';\nimport { randomContiguousLogic } from './random-contiguous.js';\nimport { rowLogic } from './rows.js';\nimport { visitByNeighbours } from './visitor.js';\n\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\n\nexport type VisitorTypes = `row` | `column` | `neighbours` | `breadth` | `depth` | `random` | `random-contiguous`\n\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type \n * @param opts \n * @returns \n */\nexport const create = (type: VisitorTypes, opts: Partial<GridVisitorOpts> = {}) => {\n  switch (type) {\n    case `random-contiguous`:\n      return withLogic(randomContiguousLogic(), opts);\n    case `random`:\n      return withLogic(randomLogic(), opts);\n    case `depth`:\n      return withLogic(depthLogic(), opts);\n    case `breadth`:\n      return withLogic(breadthLogic(), opts);\n    case `neighbours`:\n      return withLogic(neighboursLogic(), opts);\n    case `row`:\n      return withLogic(rowLogic(opts), opts);\n    case `column`:\n      return withLogic(columnLogic(opts), opts);\n    default:\n      throw new TypeError(`Param 'type' unknown. Value: ${ type }`);\n  }\n}\n\nexport const withLogic = (logic: GridNeighbourSelectionLogic, options: Partial<GridVisitorOpts> = {}) => {\n  return (grid: Grid, optionsOverride: Partial<GridVisitorOpts> = {}) => {\n    return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n  }\n}\n\nfunction isIterator<T>(v: any): v is Generator<T> {\n  if (typeof v !== `object`) return false;\n  if (!(`next` in v)) return false;\n  if (!(`throw` in v)) return false;\n  if (!(`return` in v)) return false;\n  return true;\n\n}\n\n\n// export function* withValues<T>(createOrIter: CreateVisitor | Generator<Cell>, grid: GridReadable<T>, opts: Partial<VisitorOpts>) {\n//   const iter = isIterator(createOrIter) ? createOrIter : createOrIter(grid, opts)();\n//   for (const cell of iter) {\n//     yield { cell, value: grid.accessor(cell, `undefined`) }\n//   }\n// }\n\n// export const byCells = (grid: Grid, options: Partial<VisitorOpts> = {}) => {\n//   return (logic: NeighbourSelectionLogic, optionsOverride: Partial<VisitorOpts> = {}) => {\n//     return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n//   }\n// }\n\n// export const byCellsLeftToRightTopToBottom = ():CreateVisitor => {\n//   return (grid) => {\n//     return cells(grid)\n//   }\n// }","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport type * from './types.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n\n\n\n\n\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","\nimport type { Point } from './point/point-type.js';\nimport { degreeToRadian } from './angles.js';\nimport type { Path } from './path/index.js';\n\n/**\n * An ellipse\n */\nexport type Ellipse = {\n  readonly radiusX: number\n  readonly radiusY: number\n  /**\n   * Rotation, in radians\n   */\n  readonly rotation?: number\n  readonly startAngle?: number\n  readonly endAngle?: number\n}\n\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse\n\n\nexport const fromDegrees = (radiusX: number, radiusY: number, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360): Ellipse => ({\n  radiusX, radiusY,\n  rotation: degreeToRadian(rotationDeg),\n  startAngle: degreeToRadian(startAngleDeg),\n  endAngle: degreeToRadian(endAngleDeg)\n});\n\nexport type EllipticalPath = Ellipse & Path & {\n  readonly kind: `elliptical`\n};","import type { Point } from \"./point/point-type.js\";\nimport { distance } from \"./point/distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpShortestDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = distanceFromPointToLine(points[ index_ ], firstPoint, lastPoint);\n\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpShortestDistance(l1, epsilon);\n    const r2 = rdpShortestDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];//concat(r2);\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n * \n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n * \n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n * \n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n * \n * @param points \n * @param epsilon \n * @returns \n */\nexport const rdpPerpendicularDistance = (points: Array<Point>, epsilon = 0.1): Array<Point> => {\n  const firstPoint = points[ 0 ];\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const lastPoint = points.at(-1)!;\n  if (points.length < 3) {\n    return points;\n  }\n  let index = -1;\n  let distribution = 0;\n  for (let index_ = 1; index_ < points.length - 1; index_++) {\n    const cDistribution = findPerpendicularDistance(points[ index_ ], firstPoint, lastPoint);\n    if (cDistribution > distribution) {\n      distribution = cDistribution;\n      index = index_;\n    }\n  }\n  if (distribution > epsilon) {\n    // iterate\n    const l1 = points.slice(0, index + 1);\n    const l2 = points.slice(index);\n    const r1 = rdpPerpendicularDistance(l1, epsilon);\n    const r2 = rdpPerpendicularDistance(l2, epsilon);\n    // concat r2 to r1 minus the end/startpoint that will be the same\n    const rs = [ ...r1.slice(0, - 1), ...r2 ];\n    return rs;\n  } else {\n    return [ firstPoint, lastPoint ];\n  }\n}\n\n\nfunction findPerpendicularDistance(p: Point, p1: Point, p2: Point) {\n  // if start and end point are on the same x the distance is the difference in X.\n  let result;\n  let slope;\n  let intercept;\n  if (p1.x == p2.x) {\n    result = Math.abs(p.x - p1.x);\n  } else {\n    slope = (p2.y - p1.y) / (p2.x - p1.x);\n    intercept = p1.y - (slope * p1.x);\n    result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n  }\n\n  return result;\n}\n\n\nconst distanceFromPointToLine = (p: Point, index: Point, index_: Point) => {\n  const lineLength = distance(index, index_);//First, we need the length of the line segment.\n  if (lineLength == 0) {\t//if it's 0, the line is actually just a point.\n    return distance(p, index);\n  }\n  const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n\n  //t is very important. t is a number that essentially compares the individual coordinates\n  //distances between the point and each point on the line.\n\n  if (t < 0) {\t//if t is less than 0, the point is behind i, and closest to i.\n    return distance(p, index);\n  }\t//if greater than 1, it's closest to j.\n  if (t > 1) {\n    return distance(p, index_);\n  }\n  return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n}\n\n\n","import { type TraversableTree } from '@ixfx/collections';\nimport * as Shapes from './shape/index.js';\nimport type { Point } from './point/point-type.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/from-top-left.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/from.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/rect-types.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n  /**\n   * Maximum items per node\n   */\n  readonly maxItems: number;\n  /**\n   * Maximum level of sub-division\n   */\n  readonly maxLevels: number;\n};\n\n/**\n * Direction\n */\nexport enum Direction {\n  Nw,\n  Ne,\n  Sw,\n  Se,\n}\n\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds: RectPositioned, initialData: readonly QuadTreeItem[] = [], opts: Partial<QuadTreeOpts> = {}): QuadTreeNode => {\n  const o: QuadTreeOpts = {\n    maxItems: opts.maxItems ?? 4,\n    maxLevels: opts.maxLevels ?? 4\n  };\n\n  const n = new QuadTreeNode(undefined, bounds, 0, o);\n  for (const d of initialData) {\n    n.add(d);\n  }\n  return n;\n};\n\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n * \n */\nexport class QuadTreeNode implements TraversableTree<QuadTreeItem[]> {\n  #items: QuadTreeItem[] = [];\n  #children: QuadTreeNode[] = [];\n  #parent: QuadTreeNode | undefined;\n  /**\n   * Constructor\n   * @param boundary\n   * @param level\n   * @param opts\n   */\n  constructor(\n    parent: QuadTreeNode | undefined,\n    readonly boundary: RectPositioned,\n    readonly level: number,\n    readonly opts: QuadTreeOpts\n  ) {\n    this.#parent = parent;\n  }\n\n  getLengthChildren(): number {\n    return this.#children.length;\n  }\n\n  *parents(): IterableIterator<QuadTreeNode> {\n    //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n    let n: QuadTreeNode | undefined = this;\n    while (n.#parent !== undefined) {\n      yield n.#parent;\n      n = n.#parent;\n    }\n  }\n\n  getParent() {\n    return this.#parent;\n  }\n\n  /**\n   * Iterates over immediate children\n   */\n  *children(): IterableIterator<QuadTreeNode> {\n    for (const c of this.#children) {\n      yield c;\n    }\n  }\n\n  /**\n   * Array of QuadTreeItem\n   * @returns\n   */\n  getValue() {\n    return this.#items;\n  }\n\n  getIdentity() {\n    return this;\n  }\n  /**\n   * Get a descendant node in a given direction\n   * @param d\n   * @returns\n   */\n  direction(d: Direction): QuadTreeNode | undefined {\n    return this.#children[ d ] as QuadTreeNode | undefined;\n  }\n\n  /**\n   * Add an item to the quadtree\n   * @param p\n   * @returns False if item is outside of boundary, True if item was added\n   */\n  add(p: QuadTreeItem): boolean {\n    if (!Shapes.isIntersecting(this.boundary, p)) return false;\n\n    if (this.#children.length > 0) {\n      for (const d of this.#children) (d).add(p);\n      return true;\n    }\n\n    this.#items.push(p);\n\n    if (\n      this.#items.length > this.opts.maxItems &&\n      this.level < this.opts.maxLevels\n    ) {\n      if (this.#children.length === 0) {\n        this.#subdivide();\n      }\n\n      // Add to child\n      for (const item of this.#items) {\n        for (const d of this.#children) (d).add(item);\n      }\n      //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n      this.#items = [];\n    }\n    return true;\n  }\n\n  /**\n   * Returns true if point is inside node's boundary\n   * @param p\n   * @returns\n   */\n  couldHold(p: Point) {\n    return RectsIntersectsPoint(this.boundary, p);\n  }\n\n  #subdivide() {\n    const w = this.boundary.width / 2;\n    const h = this.boundary.height / 2;\n    const x = this.boundary.x;\n    const y = this.boundary.y;\n\n    // top-left corners of each of the four new sections\n    const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n    const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n    // rects.forEach((r, index) => {\n    //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n    // });\n    this.#children = rects.map(\n      (r) => new QuadTreeNode(this, r, this.level + 1, this.opts)\n    );\n  }\n}\n","\nimport type { Point } from './point/point-type.js';\nimport type { Rect } from './rect/index.js';\nimport { isPoint } from './point/index.js';\nimport { isRect } from './rect/guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/placeholder.js';\n\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (\n  a: number | Point,\n  b?: number | Rect,\n  c?: number | Rect,\n  d?: number\n) => Point;\n\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n  /**\n   * Relative to absolute coordinates\n   */\n  readonly abs: Scaler;\n  /**\n   * Absolute to relative coordintes\n   */\n  readonly rel: Scaler;\n\n  readonly width: number;\n\n  readonly height: number;\n\n  computeScale(): Point\n};\n\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (\n  scaleBy: ScaleBy = `both`,\n  defaultRect?: Rect\n): ScalerCombined => {\n  const defaultBounds = defaultRect ?? PlaceholderRect;\n\n  let sw = 1;\n  let sh = 1;\n  let s = { x: 1, y: 1 };\n\n  const computeScale = () => {\n    switch (scaleBy) {\n      case `height`: {\n        return { x: sh, y: sh };\n      }\n      case `width`: {\n        return { x: sw, y: sw };\n      }\n      case `min`: {\n        return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n      }\n      case `max`: {\n        return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n      }\n      default: {\n        return { x: sw, y: sh };\n      }\n    }\n  };\n\n  const normalise = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): [ x: number, y: number, w: number, h: number ] => {\n    let inX = Number.NaN;\n    let inY = Number.NaN;\n    let outW = defaultBounds.width;\n    let outH = defaultBounds.height;\n\n    if (typeof a === `number`) {\n      inX = a;\n      if (typeof b === `number`) {\n        inY = b;\n        if (c === undefined) return [ inX, inY, outW, outH ];\n        if (isRect(c)) {\n          outW = c.width;\n          outH = c.height;\n        } else if (typeof c === `number`) {\n          outW = c;\n          if (typeof d === `number`) {\n            outH = d;\n          } else {\n            throw new TypeError(`Missing final height value`);\n          }\n        } else throw new Error(`Missing valid output range`);\n      } else if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else {\n        throw new Error(\n          `Expected input y or output Rect to follow first number parameter`\n        );\n      }\n    } else if (isPoint(a)) {\n      inX = a.x;\n      inY = a.y;\n      if (b === undefined) return [ inX, inY, outW, outH ];\n      if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else if (typeof b === `number`) {\n        outW = b;\n        if (typeof c === `number`) {\n          outH = c;\n        } else {\n          throw new TypeError(\n            `Expected height as third parameter after Point and output width`\n          );\n        }\n      } else {\n        throw new TypeError(\n          `Expected Rect or width as second parameter when first parameter is a Point`\n        );\n      }\n    } else {\n      throw new Error(`Expected input Point or x value as first parameter`);\n    }\n    return [ inX, inY, outW, outH ];\n  };\n\n  const scaleAbs = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(true, ...n);\n  };\n\n  const scaleRel = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(false, ...n);\n  };\n\n  const scaleNormalised = (\n    abs: boolean,\n    x: number,\n    y: number,\n    w: number,\n    h: number\n  ): Point => {\n    if (Number.isNaN(w)) throw new Error(`Output width range missing`);\n    if (Number.isNaN(h)) throw new Error(`Output height range missing`);\n\n    // If output dimensions has changed since last, create a new scale\n    if (w !== sw || h !== sh) {\n      sw = w;\n      sh = h;\n      s = computeScale();\n    }\n\n    return abs ? {\n      x: x * s.x,\n      y: y * s.y,\n    } : {\n      x: x / s.x,\n      y: y / s.y,\n    };\n  };\n\n  return {\n    computeScale,\n    rel: scaleRel,\n    abs: scaleAbs,\n    width: defaultBounds.width,\n    height: defaultBounds.height\n  };\n};\n\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }","import { degreeToRadian, radianArc, radiansSum } from '../angles.js';\nimport { guard as guardPoint, isPoint } from '../point/guard.js';\nimport { distance as pointsDistance } from '../point/distance.js';\nimport { bbox as pointsBbox } from '../point/bbox.js';\nimport { toCartesian } from '../polar/index.js';\nimport type { Point } from '../point/point-type.js';\nimport type { Line } from '../line/line-type.js';\nimport type { Path } from '../path/path-type.js';\nimport type { Rect, RectPositioned } from '../rect/rect-types.js';\nimport { fromPoints as LinesFromPoints } from '../line/from-points.js';\nimport type { Arc, ArcInterpolate, ArcPositioned, ArcSvgOpts, ArcToSvg } from './arc-type.js';\nimport type { CirclePositioned } from '../circle/circle-type.js';\nimport { piPi } from '../pi.js';\n\nexport type * from './arc-type.js';\n\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns \n */\nexport const isArc = (p: unknown): p is Arc => typeof (p as Arc).startRadian !== `undefined` && typeof (p as Arc).endRadian !== `undefined` && typeof (p as Arc).clockwise !== `undefined`;\n\n/**\n * Returns true if parameter has a positioned (x,y) \n * @param p Point, Arc or ArcPositiond\n * @returns \n */\nexport const isPositioned = (p: Point | Arc | ArcPositioned): p is Point => typeof (p as Point).x !== `undefined` && typeof (p as Point).y !== `undefined`;\n\n//const piPi = Math.PI * 2;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean): Arc;\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */export function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin: Point): ArcPositioned\n\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */\nexport function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin?: Point): Arc | ArcPositioned {\n  const a: Arc = {\n    radius,\n    startRadian: degreeToRadian(startDegrees),\n    endRadian: degreeToRadian(endDegrees),\n    clockwise\n  };\n  if (isPoint(origin)) {\n    guardPoint(origin);\n    const ap: ArcPositioned = {\n      ...a,\n      x: origin.x,\n      y: origin.y\n    };\n    return Object.freeze(ap);\n  } else {\n    return Object.freeze(a);\n  }\n}\n\n/**\n * Returns a {@link Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc: ArcPositioned): Line => LinesFromPoints(\n  point(arc, arc.startRadian),\n  point(arc, arc.endRadian)\n);\n\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n * \n * See also: \n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc \n * @param origin \n * @returns \n */\nexport const getStartEnd = (arc: ArcPositioned | Arc, origin?: Point): [ start: Point, end: Point ] => {\n  guard(arc);\n  const start = point(arc, arc.startRadian, origin);\n  const end = point(arc, arc.endRadian, origin);\n  return [ start, end ];\n}\n\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n * \n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate \n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point): Point => {\n\n  if (typeof origin === `undefined`) {\n    origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n  }\n  return {\n    x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n    y: (Math.sin(angleRadian) * arc.radius) + origin.y\n  };\n};\n\n/**\n * Throws an error if arc instance is invalid\n * @param arc \n */\nexport const guard = (arc: Arc | ArcPositioned) => {\n  if (typeof arc === `undefined`) throw new TypeError(`Arc is undefined`);\n  if (isPositioned(arc)) {\n    guardPoint(arc, `arc`);\n  }\n  if (typeof arc.radius === `undefined`) throw new TypeError(`Arc radius is undefined (${ JSON.stringify(arc) })`);\n  if (typeof arc.radius !== `number`) throw new TypeError(`Radius must be a number`);\n  if (Number.isNaN(arc.radius)) throw new TypeError(`Radius is NaN`);\n  if (arc.radius <= 0) throw new TypeError(`Radius must be greater than zero`);\n\n  if (typeof arc.startRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);\n  if (typeof arc.endRadian === `undefined`) throw new TypeError(`Arc is missing 'startRadian' field`);\n  if (Number.isNaN(arc.endRadian)) throw new TypeError(`Arc endRadian is NaN`);\n  if (Number.isNaN(arc.startRadian)) throw new TypeError(`Arc endRadian is NaN`);\n\n  if (typeof arc.clockwise === `undefined`) throw new TypeError(`Arc is missing 'clockwise field`);\n  if (arc.startRadian >= arc.endRadian) throw new TypeError(`startRadian is expected to be les than endRadian`);\n};\n\n\n\n\n/**\n * Compute relative position on arc.\n * \n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns \n */\nexport const interpolate: ArcInterpolate = (amount: number, arc: ArcPositioned | Arc, allowOverflow?: boolean, origin?: Point): Point => {\n  guard(arc);\n  const overflowOk = allowOverflow ?? false;\n  if (!overflowOk) {\n    if (amount < 0) throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);\n    if (amount > 1) throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);\n  }\n  const span = angularSize(arc); // angular size\n  const rel = span * amount;\n  const angle = radiansSum(arc.startRadian, rel, arc.clockwise);\n  //console.log(`interpolate span: ${ span.toFixed(2) } rel: ${ rel.toFixed(2) } angle: ${ angle.toFixed(2) } amt: ${ amount.toFixed(2) } cw: ${ arc.clockwise } start: ${ arc.startRadian }`);\n  return point(arc, angle, origin);\n  //return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc \n */\nexport const angularSize = (arc: Arc) => radianArc(arc.startRadian, arc.endRadian, arc.clockwise)\n\n/**\n * Creates a {@link Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc \n * @returns Path\n */\nexport const toPath = (arc: ArcPositioned): Path => {\n  guard(arc);\n\n  return Object.freeze({\n    ...arc,\n    nearest: (_point: Point) => { throw new Error(`not implemented`); },\n    interpolate: (amount: number) => interpolate(amount, arc),\n    bbox: () => bbox(arc) as RectPositioned,\n    length: () => length(arc),\n    toSvgString: () => toSvg(arc),\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`)\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`)\n    },\n    kind: `arc`\n  });\n};\n\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns \n */\nexport const fromCircle = (circle: CirclePositioned, startRadian: number, endRadian: number, clockwise = true): ArcPositioned => {\n  const a: ArcPositioned = Object.freeze({\n    ...circle,\n    endRadian,\n    startRadian,\n    clockwise\n  });\n  return a;\n}\n\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns \n */\nexport const fromCircleAmount = (circle: CirclePositioned, startRadian: number, sizeRadian: number, clockwise = true): ArcPositioned => {\n  const endRadian = radiansSum(startRadian, sizeRadian, clockwise);\n  return fromCircle(circle, startRadian, endRadian)\n}\n\n\n/**\n * Calculates the length of the arc\n * @param arc \n * @returns Length\n */\nexport const length = (arc: Arc): number => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n\n/**\n * Calculates a {@link Rect} bounding box for arc.\n * @param arc \n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc: ArcPositioned | Arc): RectPositioned | Rect => {\n  if (isPositioned(arc)) {\n    const middle = interpolate(0.5, arc);\n    const asLine = toLine(arc);\n    return pointsBbox(middle, asLine.a, asLine.b);\n  } else {\n    return {\n      width: arc.radius * 2,\n      height: arc.radius * 2\n    };\n  }\n};\n\n\n\n\n\n/**\n * Creates an SV path snippet for arc\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg: ArcToSvg = (a: Point | Arc | ArcPositioned, b?: number | Point | ArcSvgOpts, c?: number | ArcSvgOpts, d?: number, e?: ArcSvgOpts) => {\n  if (isArc(a)) {\n    if (isPositioned(a)) {\n      if (isPoint(b)) {\n        // Passing in a origin override\n        return toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as ArcSvgOpts)\n      } else {\n        // Using origin in arc\n        return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b as ArcSvgOpts);\n      }\n    } else {\n      return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c as ArcSvgOpts) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n    }\n  } else {\n    if (c === undefined) throw new Error(`startAngle undefined`);\n    if (d === undefined) throw new Error(`endAngle undefined`);\n\n    if (isPoint(a)) {\n      if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n        return toSvgFull(a, b, c, d, e);\n      } else {\n        throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n      }\n    } else {\n      throw new Error(`Expected (point, number, number, number). Missing first point.`);\n    }\n  }\n};\n\n\n\nconst toSvgFull = (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: ArcSvgOpts): readonly string[] => {\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n  // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n  // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n\n  if (opts === undefined || typeof opts !== `object`) opts = {};\n\n  const isFullCircle = endRadian - startRadian === 360;\n  const start = toCartesian(radius, endRadian - 0.01, origin);\n  const end = toCartesian(radius, startRadian, origin);\n\n  const { largeArc = false, sweep = false } = opts;\n\n  const d = [ `\n    M ${ start.x } ${ start.y }\n    A ${ radius } ${ radius } 0 ${ largeArc ? `1` : `0` } ${ sweep ? `1` : `0` } ${ end.x } ${ end.y },\n  `];\n\n  if (isFullCircle) d.push(`z`);\n\n  return d;\n};\n\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b \n * @returns Distance \n */\nexport const distanceCenter = (a: ArcPositioned, b: ArcPositioned): number => pointsDistance(a, b);\n\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a: Arc | ArcPositioned, b: Arc | ArcPositioned): boolean => {\n  if (a.radius !== b.radius) return false;\n  if (a.endRadian !== b.endRadian) return false;\n  if (a.startRadian !== b.startRadian) return false;\n  if (a.clockwise !== b.clockwise) return false;\n\n  if (isPositioned(a) && isPositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return true;\n};","import type { Point, Point3d } from './point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle/circle-type.js';\nimport type { Sphere } from './shape/index.js';\n\nimport { toPositioned as circleToPositioned } from './circle/to-positioned.js';\nimport { scale, linearSpace } from '@ixfx/numbers';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n  /**\n   * Upper limit of points to produce.\n   * By default, 5000.\n   */\n  readonly maxPoints?: number;\n  /**\n   * Density value (0..1) which determines spacing of points.\n   * This is useful because it scales with whatever circle radius is given\n   * Use this parameter OR the `spacing` parameter.\n   */\n  readonly density?: number;\n  /**\n   * Spacing between points.\n   * Use this option OR the density value.\n   */\n  readonly spacing?: number;\n  /**\n   * Rotation offset to apply, in radians. 0 by default\n   */\n  readonly rotation?: number;\n};\n\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(\n  circle?: Circle,\n  opts: VogelSpiralOpts = {}\n): IterableIterator<Point> {\n  const maxPoints = opts.maxPoints ?? 5000;\n  const density = opts.density ?? 0.95;\n  const rotationOffset = opts.rotation ?? 0;\n\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const max = c.radius;\n  //eslint-disable-next-line functional/no-let\n  let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n  if (opts.spacing) spacing = opts.spacing;\n\n  //eslint-disable-next-line functional/no-let\n  let radius = 0;\n  //eslint-disable-next-line functional/no-let\n  let count = 0;\n  //eslint-disable-next-line functional/no-let\n  let angle = 0;\n  while (count < maxPoints && radius < max) {\n    radius = spacing * count ** 0.5;\n    angle = rotationOffset + (count * 2 * pi) / goldenSection;\n    yield Object.freeze({\n      x: c.x + radius * cos(angle),\n      y: c.y + radius * sin(angle),\n    });\n    count++;\n  }\n}\n\nexport type CircleRingsOpts = {\n  readonly rings?: number;\n  /**\n   * Rotation offset, in radians\n   */\n  readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(\n  circle?: Circle | CirclePositioned,\n  opts: CircleRingsOpts = {}\n): IterableIterator<Point> {\n  const rings = opts.rings ?? 5;\n  const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n  const ringR = 1 / rings;\n  const rotationOffset = opts.rotation ?? 0;\n\n  //eslint-disable-next-line functional/no-let\n  let ringCount = 1;\n\n  // Origin\n  yield Object.freeze({ x: c.x, y: c.y });\n\n  //eslint-disable-next-line functional/no-let\n  for (let r = ringR; r <= 1; r += ringR) {\n    const n = Math.round(pi / asin(1 / (2 * ringCount)));\n    for (const theta of linearSpace(0, piPi, n + 1)) {\n      yield Object.freeze({\n        x: c.x + r * cos(theta + rotationOffset) * c.radius,\n        y: c.y + r * sin(theta + rotationOffset) * c.radius,\n      });\n    }\n    ringCount++;\n  }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(\n  samples = 100,\n  rotationRadians = 0,\n  sphere?: Sphere\n): IterableIterator<Point3d> {\n  const offset = 2 / samples;\n  const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n\n  for (let index = 0; index < samples; index++) {\n    const y = index * offset - 1 + offset / 2;\n    const r = sqrt(1 - pow(y, 2));\n    const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n    const x = cos(a) * r;\n    const z = sin(a) * r;\n    //eslint-disable-next-line functional/immutable-data\n    yield Object.freeze({\n      x: s.x + x * s.radius,\n      y: s.y + y * s.radius,\n      z: s.z + z * s.radius,\n    });\n  }\n}\n","import type { Triangle } from \"./triangle-type.js\";\nimport { angleRadian as PointsAngleRadian } from '../point/angle.js';\nimport { guard } from \"./guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    PointsAngleRadian(t.a, t.b),\n    PointsAngleRadian(t.b, t.c),\n    PointsAngleRadian(t.c, t.a),\n  ];\n};\n\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return radianToDegree(angles(t));\n};","\nimport type { Triangle } from \"./triangle-type.js\";\nimport type { PolyLine } from \"../line/line-type.js\";\nimport { joinPointsToLines } from \"../line/join-points-to-lines.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t: Triangle): PolyLine => {\n  guard(t);\n  return joinPointsToLines(t.a, t.b, t.c, t.a);\n};","import { guard } from \"./guard.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t: Triangle): number => {\n  guard(t, `t`);\n\n  // Get length of edges\n  const lengths = edges(t).map((l) => LinesLength(l));\n\n  // Add up length of edges, halve\n  const p = (lengths[ 0 ] + lengths[ 1 ] + lengths[ 2 ]) / 2;\n  return Math.sqrt(p * (p - lengths[ 0 ]) * (p - lengths[ 1 ]) * (p - lengths[ 2 ]));\n};","import { getPointParameter } from \"../point/get-point-parameter.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { guard } from \"./guard.js\";\nimport type { BarycentricCoord, Triangle } from \"./triangle-type.js\";\n\n\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): BarycentricCoord => {\n  const pt = getPointParameter(a, b);\n\n  const ab = (x: number, y: number, pa: Point, pb: Point) =>\n    (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n\n  const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n  const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n  const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n\n  return {\n    a: alpha,\n    b: theta,\n    c: gamma,\n  };\n};\n\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (\n  t: Triangle,\n  bc: BarycentricCoord\n): Point => {\n  guard(t);\n  const { a, b, c } = t;\n\n  const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n  const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n\n  if (a.z && b.z && c.z) {\n    const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n    return Object.freeze({ x, y, z });\n  } else {\n    return Object.freeze({ x, y });\n  }\n};\n","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t: Triangle, inflation = 0): RectPositioned => {\n  const { a, b, c } = t;\n  const xMin = Math.min(a.x, b.x, c.x) - inflation;\n  const xMax = Math.max(a.x, b.x, c.x) + inflation;\n  const yMin = Math.min(a.y, b.y, c.y) - inflation;\n  const yMax = Math.max(a.y, b.y, c.y) + inflation;\n\n  const r: RectPositioned = {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin,\n  };\n  return r;\n};","import type { Point } from \"../point/point-type.js\";\nimport { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t: Triangle): ReadonlyArray<Point> => {\n  guard(t);\n  return [ t.a, t.b, t.c ];\n};","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { fromNumbers as PointsFromNumbers } from \"../point/from.js\";\nimport { guard as PointGuard } from \"../point/guard.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport { piPi } from \"../pi.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/conversions.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (\n  origin: Point,\n  radius: number,\n  opts: { readonly initialAngleRadian?: number } = {}\n): Triangle => {\n  resultThrow(numberTest(radius, `positive`, `radius`));\n  PointGuard(origin, `origin`);\n\n  const initialAngleRadian = opts.initialAngleRadian ?? 0;\n\n  const angles = [\n    initialAngleRadian,\n    initialAngleRadian + (piPi * 1) / 3,\n    initialAngleRadian + (piPi * 2) / 3,\n  ];\n  const points = angles.map((a) => PolarToCartesian(radius, a, origin));\n  return fromPoints(points);\n};\n\n\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords: readonly number[]): Triangle => {\n  if (!Array.isArray(coords)) throw new Error(`coords expected as array`);\n  if (coords.length !== 6) {\n    throw new Error(\n      `coords array expected with 6 elements. Got ${ coords.length }`\n    );\n  }\n  return fromPoints(PointsFromNumbers(...coords));\n};\n\n\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points: readonly Point[]): Triangle => {\n  if (!Array.isArray(points)) throw new Error(`points expected as array`);\n  if (points.length !== 3) {\n    throw new Error(\n      `points array expected with 3 elements. Got ${ points.length }`\n    );\n  }\n  const t: Triangle = {\n    a: points[ 0 ],\n    b: points[ 1 ],\n    c: points[ 2 ],\n  };\n  return t;\n};\n","import { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\n\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t: Triangle): number => {\n  guard(t);\n  return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport { area } from \"./area.js\";\nimport { centroid } from \"./centroid.js\";\nimport { perimeter } from \"./perimeter.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t: Triangle): CirclePositioned => {\n  const c = centroid(t);\n  const p = perimeter(t) / 2;\n  const a = area(t);\n  const radius = a / p;\n  return { radius, ...c };\n};","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { getPointParameter } from \"../point/get-point-parameter.js\";\nimport { bbox } from \"./bbox.js\";\nimport { intersectsPoint as RectsIntersectsPoint } from '../rect/Intersects.js';\nimport { barycentricCoord } from \"./barycentric.js\";\n\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport const intersectsPoint = (\n  t: Triangle,\n  a: Point | number,\n  b?: number\n): boolean => {\n  const box = bbox(t);\n\n  const pt = getPointParameter(a, b);\n\n  // If it's not in the bounding box, can return false straight away\n  if (!RectsIntersectsPoint(box, pt)) return false;\n\n  const bc = barycentricCoord(t, pt);\n\n  return (\n    0 <= bc.a && bc.a <= 1 && 0 <= bc.b && bc.b <= 1 && 0 <= bc.c && bc.c <= 1\n  );\n};\n","import { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { distance } from \"../point/distance.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t: Triangle): ReadonlyArray<number> => {\n  guard(t);\n  return [\n    distance(t.a, t.b),\n    distance(t.b, t.c),\n    distance(t.c, t.a),\n  ];\n};","import { angles } from \"./angles.js\";\nimport { guard } from \"./guard.js\";\nimport { lengths } from \"./lengths.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t: Triangle): boolean => {\n  guard(t);\n  const [ a, b, c ] = lengths(t);\n  return a === b && b === c;\n};\n\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t: Triangle): boolean => {\n  const [ a, b, c ] = lengths(t);\n  if (a === b) return true;\n  if (b === c) return true;\n  if (c === a) return true;\n  return false;\n};\n\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t: Triangle): boolean =>\n  angles(t).includes(Math.PI / 2);\n\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t: Triangle): boolean => !isRightAngle(t);\n\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t: Triangle): boolean =>\n  !angles(t).some((v) => v >= Math.PI / 2);\n\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t: Triangle): boolean =>\n  angles(t).some((v) => v > Math.PI / 2);\n","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport const apply = (\n  t: Triangle,\n  fn: (p: Point, label?: string) => Point\n) =>\n  Object.freeze<Triangle>({\n    ...t,\n    a: fn(t.a, `a`),\n    b: fn(t.b, `b`),\n    c: fn(t.c, `c`),\n  });","import { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\nimport { centroid } from './centroid.js';\nimport type { Triangle } from \"./triangle-type.js\";\nimport type { CirclePositioned } from '../circle/circle-type.js';\n\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t: Triangle): CirclePositioned => {\n  const [ a, b, c ] = edges(t).map((l) => LinesLength(l));\n  const cent = centroid(t);\n  const radius =\n    (a * b * c) /\n    Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n  return {\n    radius,\n    ...cent,\n  };\n};","import type { Point } from \"../point/point-type.js\";\nimport { centroid } from \"./centroid.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * \n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport const rotate = (\n  triangle: Triangle,\n  amountRadian?: number,\n  origin?: Point\n): Triangle => {\n  if (amountRadian === undefined || amountRadian === 0) return triangle;\n  if (origin === undefined) origin = centroid(triangle);\n  return Object.freeze({\n    ...triangle,\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};\n\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n * \n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport const rotateByVertex = (\n  triangle: Triangle,\n  amountRadian: number,\n  vertex: `a` | `b` | `c` = `b`\n): Triangle => {\n  const origin =\n    vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n  return Object.freeze({\n    a: PointsRotate(triangle.a, amountRadian, origin),\n    b: PointsRotate(triangle.b, amountRadian, origin),\n    c: PointsRotate(triangle.c, amountRadian, origin),\n  });\n};","import { guard } from \"./guard.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport const toFlatArray = (t: Triangle): readonly number[] => {\n  guard(t);\n  return [ t.a.x, t.a.y, t.b.x, t.b.y, t.c.x, t.c.y ];\n};","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n\nconst pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\n\nexport type TriangleEquilateral =\n  | {\n    readonly length: number;\n  }\n  | number;\n\nconst resolveLength = (t: TriangleEquilateral): number => {\n  if (typeof t === `number`) return t;\n  return t.length;\n};\n\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * * ▶️ 0: a and c on vertical, b at the tip\n * * ◀️ Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * * 🔽 Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * * 🔼 Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (\n  t: TriangleEquilateral,\n  origin?: Point,\n  rotationRad?: number\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t) / Math.sqrt(3);\n  const rot = rotationRad ?? Math.PI * 1.5;\n  const b = {\n    x: r * Math.cos(rot) + origin.x,\n    y: r * Math.sin(rot) + origin.y,\n  };\n  const a = {\n    x: r * Math.cos(rot + pi4over3) + origin.x,\n    y: r * Math.sin(rot + pi4over3) + origin.y,\n  };\n  const c = {\n    x: r * Math.cos(rot + pi2over3) + origin.x,\n    y: r * Math.sin(rot + pi2over3) + origin.y,\n  };\n\n  return Object.freeze({ a, b, c });\n};\n\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (\n  t: TriangleEquilateral,\n  ptA?: Point\n): Point => {\n  if (!ptA) ptA = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n  return {\n    x: ptA.x + r / 2,\n    y: ptA.y - radius,\n  };\n};\n\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (\n  t: TriangleEquilateral,\n  ptB?: Point\n): Point => {\n  if (!ptB) ptB = Object.freeze({ x: 0, y: 0 })\n\n  const { radius } = incircle(t);\n  return {\n    x: ptB.x,\n    y: ptB.y + radius * 2,\n  };\n};\n\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (\n  t: TriangleEquilateral,\n  ptC?: Point\n): Point => {\n  if (!ptC) ptC = Object.freeze({ x: 0, y: 0 })\n\n  const r = resolveLength(t);\n  const { radius } = incircle(t);\n\n  return {\n    x: ptC.x - r / 2,\n    y: ptC.y - radius,\n  };\n};\n\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t: TriangleEquilateral): number =>\n  (Math.sqrt(3) / 2) * resolveLength(t);\n\nexport const perimeter = (t: TriangleEquilateral): number =>\n  resolveLength(t) * 3;\n\nexport const area = (t: TriangleEquilateral): number =>\n  (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: TriangleEquilateral): Circle => ({\n  radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Right = {\n  readonly adjacent?: number;\n  readonly hypotenuse?: number;\n  readonly opposite?: number;\n};\n\nexport type DefinedRight = {\n  readonly adjacent: number;\n  readonly hypotenuse: number;\n  readonly opposite: number;\n};\n\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x + seg[ 1 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const tt = resolveLengths(t);\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n  const c = { x: origin.x - seg[ 0 ], y: origin.y - h };\n  return { a, b, c };\n};\n\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (\n  t: Right,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const seg = hypotenuseSegments(t);\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - seg[ 1 ], y: origin.y + h };\n  const b = { x: origin.x + seg[ 0 ], y: origin.y + h };\n  return { a, b, c };\n};\n\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t: Right): DefinedRight => {\n  const a = t.adjacent;\n  const o = t.opposite;\n  const h = t.hypotenuse;\n\n  if (a !== undefined && o !== undefined) {\n    return {\n      ...t,\n      adjacent: a,\n      opposite: o,\n      hypotenuse: Math.hypot(a, o),\n    };\n  } else if (a && h) {\n    return {\n      ...t,\n      adjacent: a,\n      hypotenuse: h,\n      opposite: h * h - a * a,\n    };\n  } else if (o && h) {\n    return {\n      ...t,\n      hypotenuse: h,\n      opposite: o,\n      adjacent: h * h - o * o,\n    };\n  } else if (t.opposite && t.hypotenuse && t.adjacent) {\n    return t as DefinedRight;\n  }\n  throw new Error(`Missing at least two edges`);\n};\n\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t: Right): number => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return Math.sqrt(p * q);\n};\n\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (\n  t: Right\n): readonly [ p: number, q: number ] => {\n  const tt = resolveLengths(t);\n  const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n  const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n  return [ p, q ];\n};\n\nexport const perimeter = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\n\nexport const area = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return (tt.opposite * tt.adjacent) / 2;\n};\n\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.adjacent * tt.adjacent +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.opposite * tt.opposite) /\n    (2 * tt.adjacent * tt.hypotenuse)\n  );\n};\n\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t: Right): number => {\n  const tt = resolveLengths(t);\n  return Math.acos(\n    (tt.opposite * tt.opposite +\n      tt.hypotenuse * tt.hypotenuse -\n      tt.adjacent * tt.adjacent) /\n    (2 * tt.opposite * tt.hypotenuse)\n  );\n};\n\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (\n  t: Right\n): readonly [ a: number, b: number, c: number ] => {\n  const tt = resolveLengths(t);\n  const b = tt.adjacent * tt.adjacent;\n  const c = tt.hypotenuse * tt.hypotenuse;\n  const a = tt.opposite * tt.opposite;\n\n  return [\n    Math.sqrt(2 * (b + c) - a) / 2,\n    Math.sqrt(2 * (c + a) - b) / 2,\n    Math.sqrt(2 * (a + b) - c) / 2,\n  ];\n};\n\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return { radius: tt.hypotenuse / 2 };\n};\n\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t: Right): Circle => {\n  const tt = resolveLengths(t);\n  return {\n    radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n  };\n};\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (\n  angleRad: number,\n  adjacent: number\n): number => Math.tan(angleRad) * adjacent;\n\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (\n  angleRad: number,\n  hypotenuse: number\n): number => Math.sin(angleRad) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport const adjacentFromHypotenuse = (\n  angleRadian: number,\n  hypotenuse: number\n): number => Math.cos(angleRadian) * hypotenuse;\n\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.tan(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const hypotenuseFromOpposite = (\n  angleRadian: number,\n  opposite: number\n): number => opposite / Math.sin(angleRadian);\n\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (\n  angleRadian: number,\n  adjacent: number\n): number => adjacent / Math.cos(angleRadian);\n","\nimport type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Isosceles = {\n  readonly legs: number;\n  readonly base: number;\n};\n\nexport const baseAngle = (t: Isosceles): number =>\n  Math.acos(t.base / (2 * t.legs));\n\nexport const apexAngle = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.acos((2 * aa - cc) / (2 * aa));\n};\n\nexport const height = (t: Isosceles): number => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  return Math.sqrt((4 * aa - cc) / 4);\n};\n\nexport const legHeights = (t: Isosceles): number => {\n  const b = baseAngle(t);\n  return t.base * Math.sin(b);\n};\n\nexport const perimeter = (t: Isosceles): number => 2 * t.legs + t.base;\n\nexport const area = (t: Isosceles): number => {\n  const h = height(t);\n  return (h * t.base) / 2;\n};\n\nexport const circumcircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  const hh = h * h;\n  const cc = t.base * t.base;\n  return { radius: (4 * hh + cc) / (8 * h) };\n};\n\nexport const incircle = (t: Isosceles): Circle => {\n  const h = height(t);\n  return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\n\nexport const medians = (\n  t: Isosceles\n): readonly [ a: number, b: number, c: number ] => {\n  const aa = t.legs * t.legs;\n  const cc = t.base * t.base;\n  const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n  const medianC = Math.sqrt(4 * aa - cc) / 2;\n  return [ medianAB, medianAB, medianC ];\n};\n\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const incircleR = incircle(t).radius;\n  const verticalToApex = h - incircleR;\n\n  const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n  const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n  const c = { x: origin.x, y: origin.y - verticalToApex };\n  return { a, b, c };\n};\n\nexport const fromA = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const a = { x: origin.x, y: origin.y };\n  const b = { x: origin.x + t.base, y: origin.y };\n  const c = { x: origin.x + t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromB = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n\n  const h = height(t);\n  const b = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base, y: origin.y };\n  const c = { x: origin.x - t.base / 2, y: origin.y - h };\n  return { a, b, c };\n};\n\nexport const fromC = (\n  t: Isosceles,\n  origin?: Point\n): Triangle => {\n  if (!origin) origin = Object.freeze({ x: 0, y: 0 })\n  const h = height(t);\n  const c = { x: origin.x, y: origin.y };\n  const a = { x: origin.x - t.base / 2, y: origin.y + h };\n  const b = { x: origin.x + t.base / 2, y: origin.y + h };\n  return { a, b, c };\n};\n","export type * from './triangle-type.js';\nexport * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './inner-circle.js';\nexport * from './intersects.js';\nexport * from './kinds.js';\nexport * from './lengths.js';\nexport * from './math.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\nexport * from './to.js';\nexport * from './guard.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\n\nexport * as Isosceles from './isosceles.js';\n\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n\n\n"],"mappings":"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"}