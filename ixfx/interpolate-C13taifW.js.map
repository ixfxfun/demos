{"version":3,"file":"interpolate-C13taifW.js","names":["pos1: number","pos2?: number | Partial<BasicInterpolateOptions>","pos3?: number | Partial<BasicInterpolateOptions>","pos4?: Partial<BasicInterpolateOptions>","amountProcess: undefined | ((v: number) => number)","limits: BasicInterpolateOptions[ 'limits' ]","amount: number","_amt: number","_a: number","_b: number","o: Partial<BasicInterpolateOptions>","a: number","b: number","aValue: number","bValue: number","aRadians: number","bRadians: number","options?: Partial<BasicInterpolateOptions>"],"sources":["../../packages/numbers/src/pi-pi.ts","../../packages/numbers/src/interpolate.ts"],"sourcesContent":["export const piPi= Math.PI*2;","import { wrap } from './wrap.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type BasicInterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  transform: (v: number) => number\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<BasicInterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<BasicInterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<BasicInterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n * \n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<BasicInterpolateOptions>, pos3?: number | Partial<BasicInterpolateOptions>, pos4?: Partial<BasicInterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: BasicInterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    resultThrow(\n      numberTest(_a, ``, `a`),\n      numberTest(_b, ``, `b`),\n      numberTest(_amt, ``, `amount`)\n    );\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<BasicInterpolateOptions> = {}) => {\n    if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    resultThrow(numberTest(amount, ``, `amount`));\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<BasicInterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<BasicInterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n"],"mappings":";;;;;AAAA,MAAa,OAAM,KAAK,KAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACsH3B,SAAgB,YAAYA,MAAcC,MAAkDC,MAAkDC,MAAyC;CACrL,IAAIC;CACJ,IAAIC,UAA+C;CAEnD,MAAM,eAAe,CAACC,WAAmB;AACvC,MAAI,cAAe,UAAS,cAAc,OAAO;AACjD,MAAI,qBAAwB,YAAY,OACtC,UAAS,MAAM,OAAO;WACb,YAAY,OACrB;OAAI,SAAS,EAAG,UAAS,SAAS;YACzB,SAAS,EAChB,UAAS,IAAK,SAAS;EACxB;AAEH,SAAO;CACR;CAED,MAAM,YAAY,CAACC,MAAcC,IAAYC,OAAe;AAC1D,cACE,WAAW,KAAK,IAAI,GAAG,EACvB,WAAW,KAAK,IAAI,GAAG,EACvB,WAAW,OAAO,IAAI,QAAQ,CAC/B;AACD,SAAO,aAAa,KAAK;AACzB,UAAQ,IAAI,QAAQ,KAAK,OAAO;CACjC;CAGD,MAAM,WAAW,CAACC,IAAsC,CAAE,MAAK;AAC7D,MAAI,EAAE,WAAW;AACf,cAAW,EAAE,eAAe,UAAW,OAAM,IAAI,OAAO,8DAA+D,EAAE,UAAW;AACpI,mBAAgB,EAAE;EACnB;AACD,WAAS,EAAE,WAAW;CACvB;CAED,MAAM,UAAU,CAACH,MAAcC,IAAYC,QAAgB,IAAI,QAAQ,KAAK,OAAO;AAEnF,YAAW,UAAU,QAAS,OAAM,IAAI,WAAW,sDAAuD,KAAM;AAChH,YAAW,UAAU,SAAS;EAC5B,IAAIE;EACJ,IAAIC;AACJ,MAAI,0BAA6B,UAAU,SAAS;AAElD,OAAI;AACJ,OAAI;AACJ,YAAS,KAAK;AACd,UAAO,CAACN,WAAmB,UAAU,QAAQ,GAAG,EAAE;EACnD,kBAAiB,UAAU,SAAS;AAEnC,OAAI;AACJ,OAAI;AACJ,YAAS,KAAK;AACd,UAAO,UAAU,MAAM,GAAG,EAAE;EAC7B,MACC,OAAM,IAAI,OAAO;CAEpB,WAAU,0BAA6B,UAAU,SAAS;EAEzD,MAAM,SAAS,aAAa,KAAK;AACjC,WAAS,KAAK;AACd,cAAY,WAAW,SAAS,IAAI,QAAQ,CAAC;AAC7C,SAAO,CAACO,QAAgBC,WAAmB,QAAQ,QAAQ,QAAQ,OAAO;CAC3E;AACF;;;;;;;;;;;;;AAgED,MAAa,mBAAmB,CAC9BR,QACAS,UACAC,UACAC,YACW;CACX,MAAM,IAAI,KAAK,WAAW,UAAU,GAAG,KAAK;AAC5C,QAAO,YAAY,QAAQ,UAAU,YAAY,IAAI,KAAK,KAAK,IAAI,OAAO,IAAI,QAAQ;AACvF"}