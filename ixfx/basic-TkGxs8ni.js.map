{"version":3,"file":"basic-TkGxs8ni.js","names":["interval","max","min","tally"],"sources":["../../core/dist/src/comparers.js","../../core/dist/src/maps.js","../../core/dist/src/continuously.js","../../core/dist/src/elapsed.js","../../core/dist/src/promise-from-event.js","../../core/dist/src/sleep.js","../../process/dist/src/basic.js"],"sourcesContent":["import { defaultToString } from \"./to-string.js\";\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n *\n * Returns:\n * * 0: values are equal\n * * negative: `a` should be before `b`\n * * positive: `a` should come after `b`\n * @param a\n * @param b\n * @returns\n */\nexport const numericComparer = (a, b) => {\n    // ✔️ Unit tested\n    if (a === b)\n        return 0;\n    if (a > b)\n        return 1;\n    return -1;\n};\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\nexport const jsComparer = (x, y) => {\n    // ✔️ Unit tested\n    // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n    if (x === undefined && y === undefined)\n        return 0;\n    if (x === undefined)\n        return 1;\n    if (y === undefined)\n        return -1;\n    const xString = defaultToString(x);\n    const yString = defaultToString(y);\n    if (xString < yString)\n        return -1;\n    if (xString > yString)\n        return 1;\n    return 0;\n};\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = (comparer) => {\n    return (x, y) => {\n        const v = comparer(x, y);\n        return v * -1;\n    };\n};\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x, y) => {\n    if (typeof x === `number` && typeof y === `number`) {\n        return numericComparer(x, y);\n    }\n    return jsComparer(x, y);\n};\n","import { defaultComparer } from './comparers.js';\nimport { isEqualDefault } from './is-equal.js';\nimport { toStringDefault, } from './to-string.js';\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (data, target) => {\n    target = Math.round(target);\n    if (data.has(target)) {\n        return target;\n    }\n    else {\n        let offset = 1;\n        while (offset < 1000) {\n            if (data.has(target - offset))\n                return target - offset;\n            else if (data.has(target + offset))\n                return target + offset;\n            offset++;\n        }\n        throw new Error(`Could not find target ${target.toString()}`);\n    }\n};\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = findBySomeKey(data, keys);\n * ```\n * @param data\n * @param keys\n * @returns\n */\nexport const findBySomeKey = (data, keys) => {\n    for (const key of keys) {\n        if (data.has(key))\n            return data.get(key);\n    }\n};\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match. By default uses === comparison.\n * @returns True if key is found\n */\nexport const hasKeyValue = (map, key, value, comparer = isEqualDefault) => {\n    if (!map.has(key))\n        return false;\n    const values = [...map.values()];\n    return values.some((v) => comparer(v, value));\n};\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueCompareMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer Uses === equality by default. Use isEqualValueDefault to compare by value\n */\nexport const deleteByValueCompareMutate = (map, value, comparer = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (comparer(entry[1], value)) {\n            map.delete(entry[0]);\n        }\n    }\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link findEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const findEntryByPredicate = (map, predicate) => {\n    for (const entry of map.entries()) {\n        if (predicate(entry[1], entry[0]))\n            return entry;\n    }\n};\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * Uses JS's === comparison by default. Consider using `isEqualValueDefault` to match by value.\n * An alternative is {@link findEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const findEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (isEqual(entry[1], value))\n            return entry;\n    }\n};\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n * Returns a copy of the input map.\n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\n// export const addKeepingExisting = <V>(\n//   set: ReadonlyMap<string, V> | undefined,\n//   hasher: ToString<V>,\n//   ...values: readonly V[]\n// ) => {\n//   const s = set === undefined ? new Map() : new Map(set);\n//   for (const v of values) {\n//     const hashResult = hasher(v);\n//     if (s.has(hashResult)) continue;\n//     s.set(hashResult, v);\n//   }\n//   return s;\n// };\n/**\n * Mutates `map`, adding each value to it using a\n * function to produce a key. Use {@link addValue} for an immutable version.\n * ```\n * const map = new Map();\n * addValueMutate(map, v=>v.name, { name:`Jane`, size:10 }, { name:`Bob`, size: 9 });\n * // Map consists of entries:\n * // [ `Jane`, { name:`Jane`, size:10 } ],\n * // [ `Bob` { name:`Bob`, size: 9 } ]\n * ```\n *\n * Uses {@link addValueMutator} under the hood.\n * @param map Map to modify. If _undefined_, a new map is created\n * @param hasher Function to generate a string key for a given object value\n * @param values Values to add\n * @param collisionPolicy What to do if the key already exists\n * @returns Map instance\n */\nexport const addValueMutate = (map, hasher, collisionPolicy, ...values) => {\n    const m = map ?? new Map();\n    const f = addValueMutator(m, hasher, collisionPolicy);\n    f(...values);\n    return m;\n};\n/**\n * Adds values to a map, returning a new, modified copy and leaving the original\n * intact.\n *\n * Use {@link addValueMutate} for a mutable\n * @param map Map to start with, or _undefined_ to automatically create a map\n * @param hasher Function to create keys for values\n * @param collisionPolicy What to do if a key already exists\n * @param values Values to add\n * @returns A new map containing values\n */\nexport const addValue = (map, hasher, collisionPolicy, ...values) => {\n    const m = map === undefined ? new Map() : new Map(map);\n    for (const v of values) {\n        const hashResult = hasher(v);\n        if (collisionPolicy !== `overwrite`) {\n            if (m.has(hashResult)) {\n                if (collisionPolicy === `throw`)\n                    throw new Error(`Key '${hashResult}' already in map`);\n                if (collisionPolicy === `skip`)\n                    continue;\n            }\n        }\n        m.set(hashResult, v);\n    }\n    return m;\n};\n/**\n * Returns a function that adds values to a map, using a hashing function to produce a key.\n * Use {@link addValueMutate} if you don't need a reusable function.\n *\n * ```js\n * const map = new Map(); // Create map\n * const mutate = addValueMutator(map, v=>v.name); // Create a mutator using default 'overwrite' policy\n * mutate( { name:`Bob`, size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( {name: `Bob`, size: 11 }); // Change the value stored under key `Bob`.\n * map.get(`Bob`); // { name: `Bob`, size: 11 }\n * ```\n *\n * The 'collision policy' determines what to do if the key already exists. The default behaviour\n * is to overwrite the key, just as Map.set would.\n * ```js\n * const map = new Map();\n * const mutate = addValueMutator(map, v=>v.name, `skip`);\n * mutate( { name:`Bob`,size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( { name:`Bob`, size: 20 }); // This value would be skipped because map already contains 'Bob'\n * map.get(`Bob`); // { name: `Bob`, size: 10 }\n * ```\n *\n * @param map Map to modify\n * @param hasher Hashing function to make a key for a value\n * @param collisionPolicy What to do if a value is already stored under a key\n * @returns Function\n */\nexport const addValueMutator = (map, hasher, collisionPolicy = `overwrite`) => {\n    return (...values) => {\n        for (const v of values) {\n            const hashResult = hasher(v);\n            if (collisionPolicy !== `overwrite`) {\n                if (map.has(hashResult)) {\n                    if (collisionPolicy === `throw`)\n                        throw new Error(`Key '${hashResult}' already in map`);\n                    if (collisionPolicy === `skip`)\n                        continue;\n                }\n            }\n            map.set(hashResult, v);\n        }\n        return map;\n    };\n};\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = (map, comparer) => {\n    const f = comparer ?? defaultComparer;\n    return [...map.entries()].sort((a, b) => f(a[1], b[1]));\n};\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = sortByValueProperty(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = (map, property, compareFunction) => {\n    const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n    return [...map.entries()].sort((aE, bE) => {\n        const a = aE[1];\n        const b = bE[1];\n        return cfn(a[property], b[property]);\n    });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = (map, value, comparer) => {\n    const entries = [...map.entries()];\n    return entries.some((kv) => comparer(kv[1], value));\n};\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filterValues(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filterValues(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\nexport function* filterValues(map, predicate) {\n    for (const v of map.values()) {\n        if (predicate(v))\n            yield v;\n    }\n}\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = (map) => [...map.values()];\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` },\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = fromIterable(data, v => v.fruit);\n * map.get(`granny-smith`); // { fruit: `granny-smith`, family: `apple`, colour: `green` }\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param collisionPolicy By default, values with same key overwrite previous (`overwrite`)\n * @returns\n */\nexport const fromIterable = (data, keyFunction = (toStringDefault), collisionPolicy = `overwrite`) => {\n    const m = new Map();\n    for (const d of data) {\n        const key = keyFunction(d);\n        if (m.has(key)) {\n            if (collisionPolicy === `throw`)\n                throw new Error(`Key '${key}' is already used and new data will overwrite it. `);\n            if (collisionPolicy === `skip`)\n                continue;\n        }\n        m.set(key, d);\n    }\n    return m;\n};\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectEntriesMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = (data) => {\n    const map = new Map();\n    if (Array.isArray(data)) {\n        for (const d of data)\n            addObjectEntriesMutate(map, d);\n    }\n    else {\n        addObjectEntriesMutate(map, data);\n    }\n    return map;\n};\n/**\n * Adds an object to an existing map, mutating it.\n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObjectEntriesMutate(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectEntriesMutate = (map, data) => {\n    const entries = Object.entries(data);\n    for (const [key, value] of entries) {\n        map.set(key, value);\n    }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n * To get an entry see {@link findEntryByPredicate}\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filterValue} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = findValue(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const findValue = (map, predicate) => [...map.values()].find(v => predicate(v));\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link findValue} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map\n * @param predicate\n * @returns\n */\nexport const some = (map, predicate) => [...map.values()].some(v => predicate(v));\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = (m, valueTransform) => [...m].reduce((object, [key, value]) => {\n    const t = valueTransform(value);\n    object[key] = t;\n    return object;\n}, {});\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = (keys, values) => {\n    if (keys.length !== values.length) {\n        throw new Error(`Keys and values arrays should be same length`);\n    }\n    return Object.fromEntries(keys.map((k, index) => [k, values[index]]));\n};\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = (source, transformer) => new Map(Array.from(source, (v) => [v[0], transformer(v[1], v[0])]));\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = (m) => [...m].reduce((object, [key, value]) => {\n    object[key] = value;\n    return object;\n}, {});\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * const person = { age: 29, name: `John`};\n * map.set(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = (m, transformer) => [...m.entries()].map((x) => transformer(x[0], x[1]));\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also @ixfx/arrays/mergeByKey if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 1 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = (reconcile, ...maps) => {\n    const result = new Map();\n    for (const m of maps) {\n        for (const [mk, mv] of m) {\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return result;\n};\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate = (map, fn) => async (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value; //Promise.resolve(value);\n    value = await fn(key, args);\n    if (value === undefined)\n        throw new Error(`fn returned undefined`);\n    map.set(key, value);\n    return value;\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport const continuously = (callback, interval = 0, options = {}) => {\n    let intervalMs = intervalToMs(interval, 0);\n    resultThrow(integerTest(intervalMs, `positive`, `interval`));\n    const fireBeforeWait = options.fireBeforeWait ?? false;\n    const onStartCalled = options.onStartCalled;\n    const signal = options.signal;\n    let disposed = false;\n    let runState = `idle`;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let startedAt = performance.now();\n    let intervalUsed = interval ?? 0;\n    let cancelled = false;\n    let currentTimer;\n    const deschedule = () => {\n        if (currentTimer === undefined)\n            return;\n        globalThis.clearTimeout(currentTimer);\n        currentTimer = undefined;\n        startCount = 0;\n        startedAt = Number.NaN;\n    };\n    const schedule = (scheduledCallback) => {\n        if (intervalMs === 0) {\n            if (typeof requestAnimationFrame === `undefined`) {\n                currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n            }\n            else {\n                currentTimer = undefined;\n                requestAnimationFrame(scheduledCallback);\n            }\n        }\n        else {\n            currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n        }\n    };\n    const cancel = () => {\n        if (cancelled)\n            return;\n        cancelled = true;\n        if (runState === `idle`)\n            return; // No need to cancel\n        runState = `idle`;\n        deschedule();\n    };\n    const loop = async () => {\n        if (signal?.aborted) {\n            runState = `idle`;\n        }\n        if (runState === `idle`)\n            return;\n        runState = `running`;\n        startCount++;\n        startCountTotal++;\n        const valueOrPromise = callback(startCount, performance.now() - startedAt);\n        const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n        if (cancelled) {\n            return;\n        }\n        runState = `scheduled`;\n        // Didn't get a value, exit out\n        if (value !== undefined && !value) {\n            cancel();\n            return;\n        }\n        if (cancelled)\n            return; // has been cancelled\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop);\n    };\n    const start = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        if (onStartCalled !== undefined) {\n            // A function governs whether to allow .start() to go ahead\n            const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n            switch (doWhat) {\n                case `cancel`: {\n                    cancel();\n                    return;\n                }\n                case `reset`: {\n                    reset();\n                    return;\n                }\n                case `dispose`: {\n                    disposed = true;\n                    cancel();\n                    return;\n                }\n                // No default\n            }\n        }\n        if (runState === `idle`) {\n            // Start running\n            startCount = 0;\n            startedAt = performance.now();\n            runState = `scheduled`;\n            if (fireBeforeWait) {\n                void loop(); // Exec first, then wait\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                schedule(loop); // Wait first, then exec\n            }\n        } // else: already running, ignore\n    };\n    const reset = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        startCount = 0;\n        startedAt = Number.NaN;\n        // Cancel scheduled iteration\n        if (runState !== `idle`) {\n            cancel();\n        }\n        start();\n    };\n    return {\n        start,\n        reset,\n        cancel,\n        get interval() {\n            return intervalUsed;\n        },\n        get runState() {\n            return runState;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        },\n        get startCount() {\n            return startCount;\n        },\n        set interval(interval) {\n            const ms = intervalToMs(interval, 0);\n            resultThrow(integerTest(ms, `positive`, `interval`));\n            intervalMs = ms;\n            intervalUsed = interval;\n        },\n        get isDisposed() {\n            return disposed;\n        },\n        get elapsedMs() {\n            return performance.now() - startedAt;\n        },\n    };\n};\n","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n/**\n * Returns elapsed time since the initial call.\n *\n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = () => {\n    const start = performance.now();\n    return () => {\n        return performance.now() - start;\n    };\n};\n/**\n * Returns the interval between the start and each subsequent call.\n *\n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n *\n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns\n */\nexport const elapsedInterval = () => {\n    let start = performance.now();\n    return () => {\n        const now = performance.now();\n        const x = now - start;\n        start = now;\n        return x;\n    };\n};\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n *\n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = () => {\n    const start = Date.now();\n    let stoppedAt = 0;\n    return () => {\n        if (stoppedAt === 0) {\n            stoppedAt = Date.now() - start;\n        }\n        return stoppedAt;\n    };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = () => {\n    return () => {\n        return Number.POSITIVE_INFINITY;\n    };\n};\n","export const promiseFromEvent = (target, name) => {\n    return new Promise(resolve => {\n        const handler = (...args) => {\n            target.removeEventListener(name, handler);\n            if (Array.isArray(args) && args.length === 1)\n                resolve(args[0]);\n            else\n                resolve(args);\n        };\n        target.addEventListener(name, handler);\n    });\n};\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n    if (typeof window === `undefined`) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        globalThis.requestAnimationFrame = (callback) => {\n            setTimeout(callback, 1);\n        };\n    }\n}\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * `Flow.delay()` and {@link sleep} are similar. `Flow.delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = (optsOrMillis) => {\n    const timeoutMs = intervalToMs(optsOrMillis, 1);\n    const signal = optsOrMillis.signal;\n    const value = optsOrMillis.value;\n    resultThrow(numberTest(timeoutMs, `positive`, `timeoutMs`));\n    if (timeoutMs === 0) {\n        return new Promise((resolve) => requestAnimationFrame((_) => {\n            resolve(value);\n        }));\n    }\n    else {\n        return new Promise((resolve, reject) => {\n            const onAbortSignal = () => {\n                clearTimeout(t);\n                if (signal) {\n                    signal.removeEventListener(`abort`, onAbortSignal);\n                    reject(new Error(signal.reason));\n                }\n                else {\n                    reject(new Error(`Cancelled`));\n                }\n            };\n            if (signal) {\n                signal.addEventListener(`abort`, onAbortSignal);\n            }\n            const t = setTimeout(() => {\n                signal?.removeEventListener(`abort`, onAbortSignal);\n                if (signal?.aborted) {\n                    reject(new Error(signal.reason));\n                    return;\n                }\n                resolve(value);\n            }, timeoutMs);\n        });\n    }\n};\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate\n * @param checkInterval\n */\nexport const sleepWhile = async (predicate, checkInterval = 100) => {\n    while (predicate()) {\n        await sleep(checkInterval);\n    }\n};\n","/**\n * Outputs the current largest-seen value\n * @returns\n */\nexport const max = () => {\n    let max = Number.MIN_SAFE_INTEGER;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                break;\n            max = Math.max(subValue, max);\n        }\n        return max;\n    };\n    return compute;\n};\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = () => {\n    let min = Number.MAX_SAFE_INTEGER;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                break;\n            min = Math.min(subValue, min);\n        }\n        return min;\n    };\n    return compute;\n};\n/**\n * Returns a sum of values\n * @returns\n */\nexport const sum = () => {\n    let t = 0;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                continue;\n            t += subValue;\n        }\n        return t;\n    };\n    return compute;\n};\n/**\n * Returns the current average of input values\n * @returns\n */\nexport const average = () => {\n    let total = 0;\n    let tally = 0;\n    const compute = (value) => {\n        const valueArray = Array.isArray(value) ? value : [value];\n        for (const subValue of valueArray) {\n            if (typeof subValue !== `number`)\n                continue;\n            tally++;\n            total += subValue;\n        }\n        return total / tally;\n    };\n    return compute;\n};\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems\n * @returns\n */\nexport const tally = (countArrayItems) => {\n    let t = 0;\n    const compute = (value) => {\n        if (countArrayItems) {\n            if (Array.isArray(value))\n                t += value.length;\n            else\n                t++;\n        }\n        else {\n            t++;\n        }\n        return t;\n    };\n    return compute;\n};\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r\n * @param options\n * @returns\n */\nexport function rank(r, options = {}) {\n    const includeType = options.includeType;\n    const emitEqualRanked = options.emitEqualRanked ?? false;\n    const emitRepeatHighest = options.emitRepeatHighest ?? false;\n    let best;\n    return (value) => {\n        if (includeType && typeof value !== includeType)\n            return;\n        if (best === undefined) {\n            best = value;\n            return best;\n        }\n        else {\n            const result = r(value, best);\n            //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n            if (result == `a`) {\n                // New value is the current best\n                best = value;\n                return best;\n            }\n            else if (result === `eq` && emitEqualRanked) {\n                // New value is same rank as previous, but we have flag on\n                return best;\n            }\n            else if (emitRepeatHighest) {\n                // Emit current highest due to flag\n                return best;\n            }\n        }\n    };\n}\n"],"mappings":"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"}