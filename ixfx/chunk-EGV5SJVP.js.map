{"version":3,"sources":["../src/visual/index.ts","../src/visual/Drawing.ts","../src/visual/Palette.ts","../src/visual/SceneGraph.ts","../src/geometry/rect/Clamp.ts","../src/visual/CanvasRegion.ts","../src/visual/BipolarView.ts","../src/visual/plot/index.ts","../src/visual/plot/Cartesian.ts","../src/visual/plot/DataSet.ts","../src/dom/DomRx.ts","../src/dom/ElementSizing.ts","../src/visual/plot/CartesianCanvasPlot.ts"],"sourcesContent":["import * as Drawing from './Drawing.js';\nimport * as Svg from './Svg.js';\n//import * as Plot from './Plot.js';\n\n//import * as Plot2 from './Plot2.js';\n\nimport * as Palette from './Palette.js';\nimport * as Colour from './Colour.js';\n\nimport * as SceneGraph from './SceneGraph.js';\nimport * as Video from './Video.js';\n\nexport * from './CanvasRegion.js';\nexport * as ImageDataGrid from './ImageDataGrid.js';\nexport * as BipolarView from './BipolarView.js';\nexport * as Palette from './Palette.js';\nexport * as Drawing from './Drawing.js';\nexport * as Svg from './Svg.js';\n//export * as Plot2 from './Plot2.js';\n\nexport * as Plot from './plot/index.js';\nexport * as SceneGraph from './SceneGraph.js';\n//export * from './ScaleCanvas.js';\nexport * from './plot/CartesianCanvasPlot.js';\n\n/**\n * Colour interpolation, scale generation and parsing\n *\n * Overview\n * * {@link interpolator}: Blend colours\n * * {@link scale}: Produce colour scale\n * * {@link multiplyOpacity}: Modify opacity with a scalar\n * * {@link randomHue}: Generate a random hue\n * * {@link goldenAngleColour}: Pick perceptually different shades\n *\n * CSS\n * * {@link getCssVariable}: Parse a CSS-defined colour\n *\n * Conversions: convert from 'blue', 'rgb(255,0,0)',  'hsl(0, 100%, 50%)' etc:\n * * {@link toHex}: to a hex format string\n * * {@link toHsl}: to a `{h, s, l}` object\n * * {@link toRgb}: to a `{r, g, b}` object\n */\nexport * as Colour from './Colour.js';\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n * ```\n */\nexport * as Video from './Video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        SceneGraph,\n        Drawing,\n        Svg,\n        Palette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n","import * as Points from '../geometry/point/index.js';\nimport * as Triangles from '../geometry/triangle/index.js';\nimport { throwArrayTest } from '../util/GuardArrays.js';\nimport * as Arcs from '../geometry/arc/index.js';\nimport * as Beziers from '../geometry/bezier/index.js';\nimport * as Ellipses from '../geometry/Ellipse.js';\nimport * as Colours from '../visual/Colour.js';\nimport { resolveEl } from '../dom/ResolveEl.js';\nimport type { IStackImmutable } from '../collections/stack/IStackImmutable.js';\nimport { StackImmutable } from '../collections/stack/StackImmutable.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { Line } from '../geometry/line/LineType.js';\nimport type { CirclePositioned } from '../geometry/circle/CircleType.js';\nimport type { Rect, RectPositioned } from '../geometry/rect/index.js';\nimport type { Path } from '../geometry/path/PathType.js';\nimport type { Triangle } from '../geometry/triangle/TriangleType.js';\n\nimport { Empty as RectsEmpty } from '../geometry/rect/Empty.js';\nimport { corners as RectsCorners } from '../geometry/rect/Corners.js';\nimport { isLine } from '../geometry/line/Guard.js';\nimport { quantiseEvery } from '../numbers/Quantise.js';\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElementContextOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\nexport type DrawingHelper = ReturnType<typeof makeHelper>\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rect\n) => {\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    ctx,\n    paths(pathsToDraw: Array<Path>, opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Line | Array<Line>, opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: Rect | Array<Rect> | RectPositioned | Array<RectPositioned>,\n      opts?: RectOpts\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Array<Point>,\n      opts?: DrawingOpts & Partial<ConnectedPointsOptions>\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Array<Point>, opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Point | Array<Point>,\n      opts?: DotOpts\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: CirclePositioned | Array<\n        CirclePositioned>,\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Array<Arcs.ArcPositioned>,\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: Array<string>,\n      opts: DrawingOpts & {\n        anchor: Point;\n        anchorPadding?: number;\n        bounds?: RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: ReadonlyArray<StackOp>\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  //eslint-disable-next-line functional/immutable-data\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | ReadonlyArray<Arcs.ArcPositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: ReadonlyArray<StackOp>): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    // eslint-disable-next-line functional/immutable-data\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    // eslint-disable-next-line functional/immutable-data\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    // eslint-disable-next-line functional/immutable-data\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  if (stk === undefined) stk = new StackImmutable<StackOp>();\n\n  const push = (...ops: Array<StackOp>): DrawingStack => {\n    if (stk === undefined) stk = new StackImmutable<StackOp>();\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    //eslint-disable-next-line functional/immutable-data\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: ReadonlyArray<Point>,\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: CirclePositioned | ReadonlyArray<CirclePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c);\n  } else {\n    draw(circlesToDraw as CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | ReadonlyArray<Ellipses.EllipsePositioned>,\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    //eslint-disable-next-line functional/immutable-data\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: ReadonlyArray<Path> | Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Path);\n  }\n};\n\nexport type ConnectedPointsOptions = {\n  readonly lineWidth: number\n  readonly loop: boolean\n  readonly fillStyle: string\n  readonly strokeStyle: string\n}\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: Partial<ConnectedPointsOptions> = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n\n  throwArrayTest(pts);\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    //eslint-disable-next-line functional/immutable-data\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: ReadonlyArray<Point>,\n  opts: { readonly fillStyle?: string } = {},\n  labels?: ReadonlyArray<string>\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Point\n): Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  //eslint-disable-next-line functional/immutable-data\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\nexport type DotOpts = DrawingOpts & {\n  readonly radius?: number;\n  readonly stroke?: boolean;\n  readonly filled?: boolean;\n  readonly strokeWidth?: number;\n}\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Point | Array<Point | CirclePositioned> | CirclePositioned,\n  opts?: DotOpts\n) => {\n  if (opts === undefined) opts = {};\n  const radius = opts.radius ?? 10;\n  const positions = Array.isArray(pos) ? pos : [ pos ];\n  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== undefined;\n  let filled = opts.filled ? opts.filled : opts.fillStyle !== undefined;\n  if (!stroke && !filled) filled = true;\n\n  applyOpts(ctx, opts);\n\n  for (const pos of positions) {\n    ctx.beginPath();\n    if (`radius` in pos) {\n      ctx.arc(pos.x, pos.y, pos.radius, 0, 2 * Math.PI);\n    } else {\n      ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\n    }\n    if (filled) {\n      ctx.fill();\n    }\n    if (stroke) {\n      ctx.stroke();\n    }\n  }\n\n  // const makePath = () => {\n  //   ctx.beginPath();\n\n  //   // x&y for arc is the center of circle\n  //   if (Array.isArray(pos)) {\n  //     for (const p of pos) {\n  //       ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //     }\n  //   } else {\n  //     const p = pos as Point;\n  //     ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //   }\n  // }\n  // makePath();\n  // if (opts.filled || !opts.stroke) {\n  //   ctx.fill();\n  // }\n  // if (opts.stroke) {\n  //   if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n  //   //makePath();\n  //   ctx.stroke();\n  // }\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  // eslint-disable-next-line functional/no-let\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colours.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colours.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    //eslint-disable-next-line functional/immutable-data\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Line | ReadonlyArray<Line>,\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t);\n  } else {\n    draw(toDraw as Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangle | ReadonlyArray<Triangle>,\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n\nexport type RectOpts = DrawingOpts & Readonly<Partial<{\n  stroke: boolean\n  filled: boolean\n  strokeWidth: number\n  /**\n   * If true, diagonals are drawn\n   */\n  crossed: boolean\n}>>\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rect | Array<Rect> | RectPositioned | Array<RectPositioned>,\n  opts: RectOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroke = opts.stroke ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: RectPositioned | Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroke) {\n      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n      //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n      ctx.strokeRect(x, y, d.width, d.height);\n    }\n    if (opts.crossed) {\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(d.width, d.height);\n      ctx.stroke();\n      ctx.moveTo(0, d.height);\n      ctx.lineTo(d.width, 0);\n      ctx.stroke();\n    }\n    if (opts.debug) {\n      pointLabels(ctx, RectsCorners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rect => {\n  if (text === undefined || text === null || text.length === 0) return RectsEmpty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? quantiseEvery(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: ReadonlyArray<string>,\n  opts: DrawingOpts & {\n    readonly anchor: Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n  const align = opts.align ?? `top`;\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  //eslint-disable-next-line functional/prefer-tacit\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  // eslint-disable-next-line functional/no-let\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (align === `top`) {\n    ctx.textBaseline = `top`;\n  } else {\n    ctx.textBaseline = `middle`;\n  }\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: ReadonlyArray<string> | string,\n  opts: DrawingOpts & {\n    readonly bounds: RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","/**\n * Manage a set of colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type Palette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: readonly string[]): Palette =>\n  new PaletteImpl(fallbacks);\n\nclass PaletteImpl {\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #store: Map<string, string> = new Map();\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: readonly string[];\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: readonly string[]) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const varName = `--` + key;\n    // eslint-disable-next-line functional/no-let\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(varName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","// #region imports\nimport { intersectsPoint as RectsIntersectsPoint } from '../geometry/rect/Intersects.js';\nimport { isPlaceholder as RectsIsPlaceholder } from '../geometry/rect/Guard.js';\nimport { EmptyPositioned as RectsEmptyPositioned } from '../geometry/rect/Empty.js';\nimport { PlaceholderPositioned as RectsPlaceholderPositioned, Placeholder as RectsPlaceholder } from '../geometry/rect/Placeholder.js';\nimport { hue as randomHue } from '../random/index.js';\nimport type { Point } from '../geometry/point/PointType.js';\nimport type { Rect, RectPositioned } from '../geometry/rect/index.js';\nimport { isEqualSize as RectIsEqualSize } from '../geometry/rect/IsEqual.js';\nimport { isEqual as PointsIsEqual } from '../geometry/point/IsEqual.js';\nimport { Empty as PointsEmpty } from '../geometry/point/Empty.js';\nimport { withoutUndefined } from '../data/arrays/Filter.js';\nimport { clamp as RectsClamp } from '../geometry/rect/Clamp.js';\nimport { subtract as PointsSubtract } from '../geometry/point/Subtract.js';\n// #endregion\nexport type Measurement = {\n  actual: Rect;\n  ref: Box;\n  children: Array<Measurement | undefined>;\n};\n\nexport type Layout = {\n  actual: Point;\n  ref: Box;\n  children: Array<Layout | undefined>;\n};\n\nexport type PxUnit = {\n  value: number;\n  type: `px`;\n};\n\nexport type PcUnit = {\n  value: number;\n  type: `pc`;\n};\n\nexport type BoxUnit = PxUnit | PcUnit;\n\nexport type BoxRect = {\n  x?: BoxUnit;\n  y?: BoxUnit;\n  width?: BoxUnit;\n  height?: BoxUnit;\n};\n\nexport const boxUnitFromPx = (v: number): PxUnit => {\n  return { type: `px`, value: v };\n}\nexport const boxRectFromPx = (x: number, y: number, width: number, height: number): BoxRect => {\n  return {\n    x: boxUnitFromPx(x),\n    y: boxUnitFromPx(y),\n    width: boxUnitFromPx(width),\n    height: boxUnitFromPx(height)\n  }\n}\nexport const boxRectFromRectPx = (r: RectPositioned): BoxRect => {\n  return {\n    x: boxUnitFromPx(r.x),\n    y: boxUnitFromPx(r.y),\n    width: boxUnitFromPx(r.width),\n    height: boxUnitFromPx(r.height)\n  }\n}\n\nconst unitIsEqual = (a: BoxUnit, b: BoxUnit): boolean => {\n  if (a.type === `px` && b.type === `px`) {\n    return a.value === b.value;\n  }\n  return false;\n};\n\nconst boxRectIsEqual = (\n  a: BoxRect | undefined,\n  b: BoxRect | undefined\n): boolean => {\n  if (a === undefined && b === undefined) return true;\n  if (a === undefined) return false;\n  if (b === undefined) return false;\n  if (a.x && b.x && !unitIsEqual(a.x, b.x)) return false;\n  if (a.y && b.y && !unitIsEqual(a.y, b.y)) return false;\n  if (a.width && b.width && !unitIsEqual(a.width, b.width)) return false;\n  if (a.height && b.height && !unitIsEqual(a.height, b.height)) return false;\n  return true;\n};\n\nclass BaseState {\n  bounds: RectPositioned;\n  pass: number;\n  constructor(bounds: RectPositioned) {\n    this.bounds = bounds;\n    this.pass = 0;\n  }\n\n  resolveToPx(u: BoxUnit | undefined, maxValue: number, defaultValue?: number): number | undefined {\n    if (u === undefined && defaultValue !== undefined) return defaultValue;\n    if (u === undefined) return; //throw new Error(`unit undefined`);\n    if (u.type === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Type is missing`);\n    if (u.value === undefined) throw new TypeError(`Expected 'type' and 'value' fields. Value is missing`);\n\n\n    if (u.type === `px`) return u.value;\n    if (u.type === `pc`) return u.value * maxValue;\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    // @ts-expect-error\n    throw new Error(`Unknown unit type: ${ u.type }`);\n  }\n\n  resolveBox(box: BoxRect | undefined): Rect | RectPositioned | undefined {\n    if (box === undefined) return undefined;\n    const x = this.resolveToPx(box.x, this.bounds.width);\n    const y = this.resolveToPx(box.y, this.bounds.height);\n    const width = this.resolveToPx(box.width, this.bounds.width);\n    const height = this.resolveToPx(box.height, this.bounds.height);\n    if (!width || !height) throw new TypeError(`Expected width and height`);\n    if (x === undefined && y === undefined) {\n      return Object.freeze({ width, height });\n    } else {\n      if (!x || !y) throw new TypeError(`Expected x and y`);\n      return Object.freeze({\n        x, y, width, height\n      });\n    }\n  }\n}\n\nexport class MeasureState extends BaseState {\n  measurements: Map<string, Measurement>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.measurements = new Map<string, Measurement>();\n  }\n\n  getActualSize(id: string): Rect | undefined {\n    const s = this.measurements.get(id);\n    if (s === undefined) return;\n    if (RectsIsPlaceholder(s.actual)) return;\n    return s.actual;\n  }\n\n  whatIsMeasured(): Array<string> {\n    return [ ...this.measurements.keys() ]\n  }\n}\n\nexport class LayoutState extends BaseState {\n  layouts: Map<string, Layout>;\n\n  constructor(bounds: RectPositioned) {\n    super(bounds);\n    this.layouts = new Map<string, Layout>();\n  }\n}\n/**\n * Box\n */\nexport abstract class Box {\n\n  /** Rectangle Box occupies in canvas/etc */\n  canvasRegion: RectPositioned = RectsPlaceholderPositioned;\n\n  private _desiredRect: BoxRect | undefined;\n\n  protected _measuredSize: Rect | undefined;\n  protected _layoutPosition: Point | undefined;\n\n  protected children: Array<Box> = [];\n  protected readonly _parent: Box | undefined;\n  private _idMap = new Map<string, Box>();\n\n  debugLayout = false;\n\n  private _visible = true;\n  protected _ready = true;\n\n  takesSpaceWhenInvisible = false;\n\n  protected _needsMeasuring = true;\n  protected _needsLayoutX = true;\n  protected _needsDrawing = true;\n\n  debugHue = randomHue();\n  readonly id: string;\n\n  /**\n   * Constructor.\n   * \n   * If `parent` is provided, `parent.onChildAdded(this)` is called.\n   * @param parent parent box \n   * @param id id of this box\n   */\n  constructor(parent: Box | undefined, id: string) {\n    this.id = id;\n    this._parent = parent;\n\n    parent?.onChildAdded(this);\n  }\n\n  /**\n   * Returns _true_ if `box` is a child\n   * @param box \n   * @returns \n   */\n  hasChild(box: Box): boolean {\n    const byReference = this.children.find((c) => c === box);\n    const byId = this.children.find((c) => c.id === box.id);\n    return byReference !== undefined || byId !== undefined;\n  }\n\n  /**\n   * Sends a message to all child boxes.\n   * \n   * This first calls `onNotify` on this instance,\n   * before calling `notify()` on each child.\n   * @param message \n   * @param source \n   */\n  notify(message: string, source: Box) {\n    this.onNotify(message, source);\n    for (const c of this.children) c.notify(message, source);\n  }\n\n  *getChildren() {\n    return this.children.entries();\n  }\n\n  /**\n   * Handles a received message\n   * @param _message \n   * @param _source \n   */\n  protected onNotify(_message: string, _source: Box) {\n    /** no-op */\n  }\n\n  /**\n   * Notification a child box has been added\n   * \n   * Throws if\n   * - child has parent as its own child\n   * - child is same as this\n   * - child is already child of this\n   * @param child \n   */\n  protected onChildAdded(child: Box) {\n    if (child.hasChild(this)) throw new Error(`Recursive`);\n    if (child === this) throw new Error(`Cannot add self as child`);\n    if (this.hasChild(child)) throw new Error(`Child already present`);\n\n    this.children.push(child);\n    this._idMap.set(child.id, child);\n\n    this.layoutInvalidated(`Box.onChildAdded`);\n  }\n\n  /**\n   * Sets `_ready` to `ready`. If `includeChildren` is _true_,\n   * `setReady` is called on each child\n   * @param ready \n   * @param includeChildren \n   */\n  setReady(ready: boolean, includeChildren = false) {\n    this._ready = ready;\n    if (includeChildren) {\n      for (const c of this.children) c.setReady(ready, includeChildren);\n    }\n  }\n\n  /**\n   * Gets visible state\n   */\n  get visible(): boolean {\n    return this._visible;\n  }\n\n  /**\n   * Sets visible state\n   */\n  set visible(v: boolean) {\n    if (this._visible === v) return;\n    this._visible = v;\n\n    // Invalidated because we skip measuring when it is invisible\n    this.layoutInvalidated(`Box.set visible`);\n  }\n\n  /**\n   * Gets the box's desired region, or _undefined_\n   */\n  get desiredRegion(): BoxRect | undefined {\n    return this._desiredRect;\n  }\n\n  /**\n   * Sets the box's desired region.\n   * Calls `onLayoutNeeded()`\n   */\n  set desiredRegion(v: BoxRect | undefined) {\n    if (boxRectIsEqual(v, this._desiredRect)) return;\n    this._desiredRect = v;\n    this.layoutInvalidated(`set desiredRegion`);\n  }\n\n  /**\n   * Calls `notifyChildLayoutNeeded`\n   */\n  layoutInvalidated(reason: string) {\n    if (reason === undefined) debugger;\n    this.debugLog(`layoutInvalidated ${ reason }`);\n    this._needsMeasuring = true;\n    this._needsLayoutX = true;\n    // TODO: Only set to true during measuring if it actually changes\n    this._needsDrawing = true;\n    this.notifyChildLayoutNeeded();\n  }\n\n  drawingInvalidated(_reason: string): void {\n    this._needsDrawing = true;\n    //this.debugLog(`drawingInvalidated ${ reason }`);\n  }\n\n  /**\n   * Called from a child, notifying us that\n   * its layout has changed\n   * @returns \n   */\n  private notifyChildLayoutNeeded() {\n    // TODO: Not all layout changes require re-layout higher up\n    this._needsDrawing = true;\n    this._needsLayoutX = true;\n    this._needsMeasuring = true;\n    if (this._parent === undefined) return;\n    this._parent.notifyChildLayoutNeeded();\n  }\n\n  /**\n   * Returns the root box\n   */\n  get root(): Box {\n    if (this._parent === undefined) return this;\n    return this._parent.root;\n  }\n\n  /**\n   * Prepare for measuring\n   */\n  protected measurePreflight() {\n    /** no-up */\n  }\n\n  /**\n   * Applies actual size, returning _true_ if size is different than before\n   * \n   * 1. Sets `_needsLayout` to _false_.\n   * 2. Sets `visual` to `m`\n   * 3. Calls `measureApply` on each child\n   * 4. If there's a change or `force`, sets `needsDrawing` to _true_, and notifies root of `measureApplied`\n   * @param m Measurement for box\n   * @returns \n   */\n  protected measureApply(m: Measurement) {\n    this._needsMeasuring = false;\n\n    const different = this._measuredSize === undefined ? true : !RectIsEqualSize(m.actual, this._measuredSize);\n    if (different) {\n      //this.debugLog(`measureApply: Size is different than previous. Actual: ${ JSON.stringify(m.actual) } current: ${ JSON.stringify(this._measuredSize) }`);\n      this._needsLayoutX = true;\n    }\n\n    this._measuredSize = { width: m.actual.width, height: m.actual.height };\n\n    for (const c of m.children) {\n      if (c !== undefined) c.ref.measureApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`measureApplied`, this);\n    }\n    return different;\n  }\n\n  protected layoutApply(l: Layout) {\n    this._needsLayoutX = false;\n\n    const different = this._layoutPosition === undefined ? true : !PointsIsEqual(l.actual, this._layoutPosition);\n    // if (different) {\n    //   this.debugLog(`layoutApply. Position different than previous. ${ JSON.stringify(l.actual) }`);\n    // }\n    this._layoutPosition = { x: l.actual.x, y: l.actual.y };\n\n    for (const c of l.children) {\n      if (c !== undefined) c.ref.layoutApply(c);\n    }\n\n    if (different) {\n      this.root.notify(`layoutApplied`, this);\n    }\n    return different;\n  }\n\n  /**\n   * Debug log from this box context\n   * @param m \n   */\n  debugLog(m: any) {\n    if (!this.debugLayout) return;\n    console.log(`SceneGraph[${ this.id }]`, m);\n  }\n\n  layoutStart(measureState: MeasureState, layoutState: LayoutState, force: boolean, parent?: Layout): Layout | undefined {\n    const m: Layout = {\n      ref: this,\n      actual: PointsEmpty,\n      children: [],\n    };\n    // Stash away measurement by id\n    layoutState.layouts.set(this.id, m);\n\n    const currentPosition = this.layoutSelf(measureState, layoutState, parent);\n    this.root.notify(`laidout`, this);\n\n    // For some reason we can't measure\n    if (currentPosition === undefined) return;\n\n    // Assign\n    m.actual = currentPosition;\n\n    m.children = this.children.map((c) => c.layoutStart(measureState, layoutState, force, m));\n    if (withoutUndefined(m.children).length < this.children.length) {\n      return undefined; // One of the children did not resolve\n    }\n    return m;\n  }\n\n  protected layoutSelf(\n    measureState: MeasureState,\n    layoutState: LayoutState,\n    _parent?: Layout\n  ): Point | undefined {\n    // TODO: Proper layout\n    const box = layoutState.resolveBox(this._desiredRect);\n    const x = box === undefined ? 0 : (`x` in box ? box.x : 0);\n    const y = box === undefined ? 0 : (`y` in box ? box.y : 0);\n    if (x === undefined) debugger;\n    if (y === undefined) debugger;\n    return { x, y }\n  }\n\n  /**\n   * Start of measuring\n   * 1. Keeps track of measurements in `opts.measurements`\n   * 2. If this box takes space\n   * 2.1. Measure itself if needed\n   * 2.2. Use size\n   * 2. Calls `measureStart` on each child\n   * @param opts Options\n   * @param force Force measurement\n   * @param parent Parent's measurement \n   * @returns Measurement\n   */\n  measureStart(\n    opts: MeasureState,\n    force: boolean,\n    parent?: Measurement\n  ): Measurement | undefined {\n    this.measurePreflight();\n\n    const m: Measurement = {\n      ref: this,\n      // So far no known measurement\n      actual: RectsPlaceholder,\n      children: [],\n    };\n    // Stash away measurement by id\n    opts.measurements.set(this.id, m);\n\n    if (!this._visible && !this.takesSpaceWhenInvisible) {\n      // If we're not visible, there's no actual size\n      m.actual = RectsEmptyPositioned;\n    } else {\n      let currentMeasurement: Rect | string | undefined = this._measuredSize;\n\n      // If we need to, measure how big it actually is\n      if (this._needsMeasuring || this._measuredSize === undefined) {\n        currentMeasurement = this.measureSelf(opts, parent);\n        this.root.notify(`measured`, this);\n      }\n\n      // For some reason we can't measure\n      if (typeof currentMeasurement === `string`) {\n        //this.debugLog(`measureStart: measureSelf failed: ${ currentMeasurement }`);\n        return;\n      } else if (currentMeasurement === undefined) {\n        //this.debugLog(`measureStart: measureSelf failed for some other reason`);\n        return;\n      }\n\n      // Assign\n      m.actual = currentMeasurement;\n    }\n\n    m.children = this.children.map((c) => c.measureStart(opts, force, m));\n    if (withoutUndefined(m.children).length < this.children.length) {\n      //this.debugLog(`measureStart: Child failed measureStart`);\n      return undefined; // One of the children did not resolve\n    }\n\n    return m;\n  }\n\n  /**\n   * Measure the box\n   * 1. Uses desired rectangle, if possible\n   * 2. Otherwise uses parent's size\n   * @param opts Measure state\n   * @param parent Parent size\n   * @returns \n   */\n  protected measureSelf(\n    opts: MeasureState,\n    parent?: Measurement\n  ): Rect | string {\n    let size = RectsPlaceholder;\n\n    const context = parent ? parent.actual : opts.bounds;\n    const desired = opts.resolveBox(this._desiredRect);\n\n    size = desired ? RectsClamp(desired, context) : context;\n\n    if (RectsIsPlaceholder(size)) {\n      return `Box.measureSelf - No size for box?`;\n    }\n    return size;\n  }\n\n\n  /**\n   * Gets initial state for a run of measurements & layout.\n   * \n   * Called when update() is called\n   * @param context\n   */\n  protected abstract updateBegin(context: any): [ MeasureState, LayoutState ];\n\n  protected abstract updateComplete(measureChanged: boolean, layoutChanged: boolean): void;\n\n  // protected updateDone(state: MeasureState, force: boolean): void {\n  //   this.onUpdateDone(state, force);\n  //   for (const c of this.children) c.updateDone(state, force);\n  // }\n\n  /**\n   * Update has completed\n   * @param state \n   * @param force \n   */\n  //abstract onUpdateDone(state: MeasureState, force: boolean): void;\n\n  /**\n   * Update\n   * 1. Calls `this.updateBegin()` to initialise measurement state\n   * 2. In a loop, run `measureStart()` and then `measureApply` if possible\n   * 3. Call `updateDone` when finished\n   * @param force Force update\n   * @returns \n   */\n  update(context: object, force = false) {\n    if (context === undefined) throw new Error(`context is undefined`);\n\n    if (!this._needsMeasuring && !this._needsLayoutX && !force) return;\n    const [ measureState, layoutState ] = this.updateBegin(context);\n    let attempts = 5;\n    let measureApplied = false;\n    let layoutApplied = false;\n\n    // Measure everything\n    if (this._needsMeasuring || force) {\n      //this.debugLog(`update: needs measuring (force: ${ force }) bounds: ${ JSON.stringify(measureState.bounds) }`);\n      while (attempts--) {\n        const m = this.measureStart(measureState, force);\n        if (m !== undefined) {\n          // Apply measurements\n          this.measureApply(m);\n          if (!this._ready) return;\n          measureApplied = true;\n        }\n      }\n      //this.updateDone(state, force);\n      if (!measureApplied) this.debugLog(`Ran out of measurement attempts`);\n    }\n\n    // Lay it out\n    if (this._needsLayoutX || force) {\n      const p = this.layoutStart(measureState, layoutState, force);\n      if (p === undefined) {\n        this.debugLog(`Warning: could not layout`);\n      } else {\n        this.layoutApply(p);\n        layoutApplied = true;\n      }\n    }\n    this.updateComplete(measureApplied, layoutApplied);\n  }\n}\n\n/**\n * Canvas measure state\n */\nexport class CanvasMeasureState extends MeasureState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n  }\n}\n\nexport class CanvasLayoutState extends LayoutState {\n  readonly ctx: CanvasRenderingContext2D;\n  constructor(bounds: RectPositioned, ctx: CanvasRenderingContext2D) {\n    super(bounds);\n    this.ctx = ctx;\n    if (ctx === undefined) throw new Error(`ctx is undefined`);\n\n  }\n}\n\n/**\n * A Box that exists on a HTMLCanvasElement\n */\nexport class CanvasBox extends Box {\n  bounds: RectPositioned | undefined;\n  constructor(\n    parent: CanvasBox | undefined,\n    //canvasElement: HTMLCanvasElement,\n    id: string,\n    bounds?: RectPositioned\n  ) {\n    super(parent, id);\n    this.bounds = bounds;\n    this.debugLog(`CanvasBox ctor bounds: ${ JSON.stringify(bounds) }`);\n  }\n\n  static fromCanvas(canvasElement: HTMLCanvasElement): CanvasBox {\n    const box = new CanvasBox(undefined, `canvas-box`, canvasElement.getBoundingClientRect());\n    return box;\n  }\n\n  /**\n   * Called if this is the parent Box\n   */\n  public addEventHandlers(element: HTMLElement) {\n    element.addEventListener(`pointermove`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyPointerMove(p);\n    });\n\n    element.addEventListener(`pointerleave`, (_event) => {\n      this.notifyPointerLeave();\n    });\n\n    element.addEventListener(`click`, (event) => {\n      const p = { x: event.offsetX, y: event.offsetY };\n      this.notifyClick(p);\n    });\n  }\n\n  protected onClick(_p: Point) {\n    /** no-up */\n  }\n\n  /**\n   * Click event has happened on canvas\n   * 1. If it's within our range, call `onClick` and pass to all children via `notifyClick`\n   * @param p \n   * @returns \n   */\n  private notifyClick(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = PointsSubtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onClick(pp);\n      // TODO: Only call `notifyClick` if child is within range?\n      for (const c of this.children) (c as CanvasBox).notifyClick(pp);\n    }\n  }\n\n  /**\n   * Pointer has left\n   * 1. Pass notification to all children via `notifyPointerLeave`\n   */\n  private notifyPointerLeave() {\n    this.onPointerLeave();\n    for (const c of this.children) (c as CanvasBox).notifyPointerLeave();\n  }\n\n  /**\n   * Pointer has moved\n   * 1. If it's within range `onPointerMove` is called, and pass on to all children via `notifyPointerMove`\n   * @param p \n   * @returns \n   */\n  private notifyPointerMove(p: Point) {\n    if (RectsIsPlaceholder(this.canvasRegion)) return;\n    if (RectsIntersectsPoint(this.canvasRegion, p)) {\n      const pp = PointsSubtract(p, this.canvasRegion.x, this.canvasRegion.y);\n      this.onPointerMove(pp);\n      for (const c of this.children) (c as CanvasBox).notifyPointerMove(pp);\n    }\n  }\n\n  /**\n   * Handler when pointer has left\n   */\n  protected onPointerLeave() {\n    /** no-up */\n  }\n\n  /**\n   * Handler when pointer moves within our region\n   * @param _p \n   */\n  protected onPointerMove(_p: Point) {\n    /** no-up */\n\n  }\n\n  /**\n   * Performs recalculations and drawing as necessary\n   * If nothing needs to happen, function returns.\n   * @param context \n   * @param force Force update\n   */\n  update(context: CanvasRenderingContext2D, force = false) {\n    super.update(context, force);\n    this.draw(context, force);\n  }\n\n  getBounds(): RectPositioned | undefined {\n    return this.bounds === undefined && this._parent ? (this._parent as CanvasBox).bounds : this.bounds;\n  }\n\n  unsetBounds() {\n    this.bounds = undefined;\n  }\n\n  /**\n   * Update begins.\n   * @returns MeasureState\n   */\n  protected updateBegin(context: CanvasRenderingContext2D): [ MeasureState, LayoutState ] {\n    if (context === undefined) throw new Error(`Context is undefined`);\n    let bounds = this.getBounds();\n    //this.debugLog(`updateBegin bounds: ${ JSON.stringify(bounds) } measured: ${ JSON.stringify(this._measuredSize) }`);\n\n    if (bounds === undefined) {\n      this.debugLog(`No bounds for element or parent, using canvas bounds`);\n      bounds = { x: 0, y: 0, width: context.canvas.width, height: context.canvas.height }\n    }\n    return [\n      new CanvasMeasureState(bounds, context),\n      new CanvasLayoutState(bounds, context)\n    ]\n    // if (this.region) {\n    //   return new CanvasMeasureState(this.region);\n    // } else {\n    //   const s = this.canvasEl.getBoundingClientRect();\n\n    //   return new CanvasMeasureState(\n    //     {\n    //       x: 0,\n    //       y: 0,\n    //       width: s.width,\n    //       height: s.height,\n    //     },\n    //     ctx\n    //   );\n    // }\n  }\n\n  protected updateComplete(_measureChanged: boolean, _layoutChanged: boolean): void {\n    //this.debugLog(`updateComplete. measureChanged: ${ _measureChanged } layoutChanged: ${ _layoutChanged } pos: ${ JSON.stringify(this._layoutPosition) }`);\n    this.canvasRegion = RectsPlaceholderPositioned;\n  }\n\n  protected measureApply(m: Measurement): boolean {\n    const different = super.measureApply(m);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  protected layoutApply(l: Layout): boolean {\n    const different = super.layoutApply(l);\n    if (different) this.canvasRegion = RectsPlaceholderPositioned;\n    return different;\n  }\n\n  public draw(ctx: CanvasRenderingContext2D, force = false) {\n    //this.debugLog(`draw. needs drawing: ${ this._needsDrawing } force: ${ force } pos: ${ JSON.stringify(this._layoutPosition) } size: ${ JSON.stringify(this._measuredSize) }`);\n\n    // if (!this._needsDrawing && !force) return;\n\n    if (this._needsDrawing || force) {\n      if (RectsIsPlaceholder(this.canvasRegion)) {\n        if (this._layoutPosition === undefined) return;\n        if (this._measuredSize === undefined) return;\n        this.canvasRegion = {\n          x: this._layoutPosition.x,\n          y: this._layoutPosition.y,\n          width: this._measuredSize.width,\n          height: this._measuredSize.height\n        }\n      }\n\n      //this.debugLog(`draw: canvasRegion: ${ JSON.stringify(this.canvasRegion) }`);\n      if (this._needsLayoutX || this._needsMeasuring) {\n        //this.debugLog(`draw: warning: drawing with outdated layout / measurements`);\n      }\n      ctx.save();\n      const v = this.canvasRegion;\n      ctx.translate(v.x, v.y);\n      ctx.beginPath();\n      ctx.rect(0, 0, v.width, v.height);\n      ctx.clip();\n\n      if (this.debugLayout) {\n        //ctx.clearRect(0,0,v.width,v.height);\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = `hsl(${ this.debugHue }, 100%, 50%)`;\n\n        //ctx.fillStyle = ctx.strokeStyle;\n        //ctx.fillRect(0,0,v.width,v.height);\n\n        ctx.strokeRect(0, 0, v.width, v.height);\n\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fillText(this.id, 10, 10, v.width);\n\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(v.width, v.height);\n        ctx.stroke();\n      }\n\n      this.drawSelf(ctx);\n\n      this._needsDrawing = false;\n      ctx.restore();\n    }\n    for (const c of this.children) {\n      (c as CanvasBox).draw(ctx, force)\n    }\n  }\n\n  /**\n   * Draw this object\n   * @param _ctx \n   */\n  protected drawSelf(_ctx: CanvasRenderingContext2D): void {\n    /** no-up */\n  }\n}\n","import type { Rect } from \"./RectTypes.js\";\n\n/**\n * Clamps `value` so it does not exceed `maximum`\n * on either dimension. x,y are ignored.\n * \n * ```js\n * clamp({ width:100, height:5 }, { width:10, height:10 }); // { width:10, height:5 }\n * \n * clamp({ width:10, height:10 }, { width:10, height:10 }); // { width:10, height:10 }\n * ```\n * \n * Any existing data on `value` is copied to output.\n * @param value Input rectangle\n * @param maximum Maximum allowed size\n */\nexport const clamp = (value: Rect, maximum: Rect): Rect => {\n  return Object.freeze({\n    ...value,\n    width: Math.min(value.width, maximum.width),\n    height: Math.min(value.height, maximum.height)\n  });\n}","import { piPi } from \"src/data/index.js\";\nimport { Points, Rects } from \"src/geometry/index.js\";\nimport type { CirclePositioned, Point, Rect, RectPositioned } from \"src/geometry/Types.js\";\nimport { scalerTwoWay } from \"src/numbers/Scale.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport { clamp } from \"src/numbers/Clamp.js\";\n\nexport class CanvasSource {\n  #canvasEl: HTMLCanvasElement;\n  #ctx: undefined | CanvasRenderingContext2D;\n  #sizeBasis: `min` | `max`;\n  #sizeScaler;\n  #logicalSize: Rect;\n  #pixelScaling;\n\n  #regions: Array<CanvasRegion> = [];\n\n  constructor(canvasElementOrQuery: HTMLCanvasElement | string, sizeBasis: `min` | `max` = `min`) {\n    this.#canvasEl = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    this.#sizeBasis = sizeBasis;\n    this.#pixelScaling = window.devicePixelRatio || 1;\n    this.#sizeScaler = this.#createSizeScaler();\n    this.#logicalSize = this.setLogicalSize({ width: this.#canvasEl.width, height: this.#canvasEl.height });\n  }\n\n\n  setLogicalSize(size: Rect) {\n    this.#logicalSize = size;\n    const el = this.#canvasEl;\n    el.width = (size.width * this.#pixelScaling);\n    el.height = (size.height * this.#pixelScaling);\n\n    el.style.width = `${ (size.width).toString() }px`;\n    el.style.height = `${ (size.height).toString() }px`;\n    this.#sizeScaler = this.#createSizeScaler();\n    this.invalidateContext();\n    return size;\n  }\n\n  #createSizeScaler() {\n    let inMax = 1;\n    switch (this.#sizeBasis) {\n      case `min`:\n        inMax = Math.min(this.#canvasEl.width, this.#canvasEl.height);\n        break;\n      case `max`:\n        inMax = Math.max(this.#canvasEl.width, this.#canvasEl.height);\n        break;\n    }\n    const s = scalerTwoWay(0, inMax, 0, 1);\n    return {\n      abs: s.in,\n      rel: s.out\n    }\n  }\n\n  invalidateContext() {\n    this.#ctx = undefined;\n  }\n\n  #add(region: CanvasRegion) {\n    this.#regions.push(region);\n    return region;\n  }\n\n  createFixedAbsolute(canvasCoordsRect: RectPositioned) {\n    return this.#add(new CanvasRegion(this, () => canvasCoordsRect))\n  }\n\n  toAbsPoint(pt: Point, kind: `independent` = `independent`) {\n    let { x, y } = pt;\n    switch (kind) {\n      case `independent`:\n        x *= this.width;\n        y *= this.height;\n\n    }\n    return { x, y };\n  }\n\n  get offset() {\n    const b = this.#canvasEl.getBoundingClientRect();\n    return { x: b.left, y: b.top };\n  }\n\n  toRelPoint(pt: Point, source: `screen` | `source`, kind: `independent` | `skip` = `independent`, clamped = true) {\n    let { x, y } = pt;\n    if (source === `screen`) {\n      const b = this.#canvasEl.getBoundingClientRect();\n      x -= b.x;\n      y -= b.y;\n    }\n    switch (kind) {\n      case `independent`:\n        x /= this.width;\n        y /= this.height;\n        break;\n      case `skip`:\n        break;\n    }\n    if (clamped) {\n      x = clamp(x);\n      y = clamp(y);\n    }\n    return { x, y };\n  }\n\n\n\n  toAbsRect(rect: Rect | RectPositioned, kind: `independent` = `independent`) {\n    let { width, height } = rect;\n    switch (kind) {\n      case `independent`:\n        width *= this.width;\n        height *= this.height;\n        if (Rects.isRectPositioned(rect)) {\n          return {\n            ...this.toAbsPoint(rect),\n            width,\n            height\n          }\n        }\n    }\n    return { width, height }\n  }\n\n  createRelative(rect: RectPositioned, kind: `independent` = `independent`) {\n    let compute: undefined | ((source: CanvasSource) => RectPositioned);\n    switch (kind) {\n      case `independent`:\n        compute = (source: CanvasSource): RectPositioned => ({\n          x: rect.x * source.width,\n          y: rect.y * source.height,\n          width: rect.width * source.width,\n          height: rect.height * source.height\n        })\n        break;\n    }\n    // const compute = (source: CanvasSource) => {\n    //   return {\n    //     x: source.sizeScaler.abs(rect.x),\n    //     y: source.sizeScaler.abs(rect.y),\n    //     width: source.sizeScaler.abs(rect.width),\n    //     height: source.sizeScaler.abs(rect.height),\n    //   }\n    // };\n    return this.#add(new CanvasRegion(this, compute));\n  }\n\n  clear() {\n    const c = this.context;\n    c.clearRect(0, 0, this.width, this.height);\n  }\n\n  get context() {\n    if (this.#ctx) return this.#ctx;\n    const c = this.#canvasEl.getContext(`2d`);\n    if (!c) throw new Error(`Could not create 2d context`);\n    c.setTransform(1, 0, 0, 1, 0, 0);\n    c.scale(this.#pixelScaling, this.#pixelScaling);\n\n    this.#ctx = c;\n\n    for (const r of this.#regions) {\n      r.recomputeRegion();\n    }\n    return this.#ctx;\n  }\n\n  get sizeScaler() {\n    return this.#sizeScaler;\n  }\n\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  get height() {\n    return this.#logicalSize.height;\n  }\n}\n\n/**\n * Draws on a canvas, constrained to a specific region\n */\nexport class CanvasRegion {\n  source;\n  #regionCompute;\n  #r;\n\n  /**\n   * Creates, using coordinate in canvas coordinates\n   */\n  constructor(source: CanvasSource, regionCompute: (parent: CanvasSource) => RectPositioned) {\n    this.source = source;\n    this.#regionCompute = regionCompute;\n    this.#r = regionCompute(source);\n  }\n\n  recomputeRegion() {\n    this.#r = this.#regionCompute(this.source);\n  }\n\n  /**\n   * Converts a region-relative point (0..1) to an absolute\n   * point, which uses region-relative coordinates.\n   * \n   * Eg if the region had an x,y of 100,100, `toAbsRegion({x:0,y:0})`\n   * will return 0,0.\n   *\n   * @param rel \n   * @param scaleBy \n   * @returns \n   */\n  toAbsRegion(regionRel: Point, scaleBy: `both` = `both`) {\n    switch (scaleBy) {\n      case `both`:\n        return {\n          x: regionRel.x * this.#r.width,\n          y: regionRel.y * this.#r.height\n        }\n        break;\n    }\n  }\n\n  applyRegionOffset(p: Point) {\n    return {\n      x: p.x + this.#r.x,\n      y: p.y + this.#r.y\n    }\n  }\n\n  drawConnectedPointsRelative(relativePoints: Array<Point>, strokeStyle: string, lineWidth = 1) {\n    const points = relativePoints.map(p => this.toAbsRegion(p));\n    this.drawConnectedPoints(points, strokeStyle, lineWidth);\n  }\n\n  drawConnectedPoints(points: Array<Point>, strokeStyle: string, lineWidth = 1) {\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    c.beginPath();\n    c.strokeStyle = strokeStyle;\n    c.lineWidth = lineWidth;\n    for (let index = 0; index < points.length; index++) {\n      if (index === 0) {\n        c.moveTo(points[ index ].x, points[ index ].y);\n      } else {\n        c.lineTo(points[ index ].x, points[ index ].y);\n      }\n    }\n    c.stroke();\n    c.restore();\n  }\n\n  /**\n   * Fills text at a relative position\n   * @param text \n   * @param relPos Relative, meaning 0.5,0.5 is the middle of the region\n   * @param fillStyle \n   * @param baseline \n   * @param align \n   */\n  fillTextRelative(text: string, relPos: Point, fillStyle: string = `black`, font: string, baseline: CanvasTextBaseline = `alphabetic`, align: CanvasTextAlign = `start`) {\n    const point = this.toAbsRegion(relPos);\n    this.fillTextRelative(text, point, fillStyle, font, baseline, align);\n  }\n\n  /**\n   * Fills text at a region-relative position\n   * @param text \n   * @param point Region relative, meaning 0,0 is top-left of region\n   * @param fillStyle \n   * @param baseline \n   * @param align \n   */\n  fillText(text: string, point: Point, fillStyle: string = `black`, font: string, baseline: CanvasTextBaseline = `alphabetic`, align: CanvasTextAlign = `start`) {\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    if (font.length > 0) {\n      c.font = font;\n    }\n    c.textBaseline = baseline;\n    c.textAlign = align;\n    c.fillStyle = fillStyle;\n    c.fillText(text, point.x, point.y);\n    c.restore();\n  }\n\n  drawCircles(relativeCircles: Array<CirclePositioned>, fillStyle: string, strokeStyle: string = ``, lineWidth = 1) {\n    const circles = relativeCircles.map(c => {\n      return {\n        ...this.toAbsRegion(c),\n        radius: this.source.sizeScaler.abs(c.radius)\n      }\n    });\n\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    c.fillStyle = fillStyle;\n    c.strokeStyle = strokeStyle;\n    c.lineWidth = lineWidth;\n\n    for (const circle of circles) {\n      c.beginPath();\n      c.arc(circle.x, circle.y, circle.radius, 0, piPi);\n      c.closePath();\n      if (fillStyle.length > 0) {\n        c.fill();\n      }\n      if (strokeStyle.length > 0) {\n        c.stroke();\n      }\n    }\n    c.restore();\n  }\n\n  clear() {\n    const c = this.context;\n    c.clearRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);\n  }\n\n  fill(fillStyle: string = `white`) {\n    const c = this.context;\n    c.fillStyle = fillStyle;\n    c.fillRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);\n  }\n\n  drawBounds(strokeStyle: string, lineWidth = 1) {\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 0 },\n      { x: 1, y: 0 },\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: 0, y: 0 }\n    ], strokeStyle, lineWidth);\n\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 1 },\n      { x: 1, y: 0 }\n    ], strokeStyle, lineWidth);\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 0 },\n      { x: 1, y: 1 }\n    ], strokeStyle, lineWidth);\n  }\n\n  /**\n   * Converts a  point to a region-relative one.\n   * @param pt \n   * @param kind \n   * @returns \n   */\n  toRelPoint(pt: Point, source: `screen` | `source` = `screen`, kind: `independent` = `independent`, clamped = true) {\n    pt = this.source.toRelPoint(pt, source, `skip`, false);\n    let { x, y } = pt;\n    x -= this.x;\n    y -= this.y;\n\n    switch (kind) {\n      case `independent`:\n        x /= this.width;\n        y /= this.height;\n    }\n    if (clamped) {\n      x = clamp(x);\n      y = clamp(y);\n    }\n    return { x, y };\n  }\n\n  absToRegionPoint(pt: Point, source: `screen`, clamped: boolean) {\n    if (source === `screen`) {\n      pt = Points.subtract(pt, this.source.offset);\n    }\n\n    let { x, y } = pt;\n    x -= this.x;\n    y -= this.y;\n\n    if (clamped) {\n      if (x < 0) x = 0;\n      if (y < 0) y = 0;\n      if (x > this.width + this.x) x = this.x + this.width;\n      if (y > this.height + this.y) y = this.y + this.height;\n    }\n    return { x, y };\n  }\n\n  get center() {\n    return Rects.center(this.#r);\n  }\n\n  get context() {\n    return this.source.context;\n  }\n\n  set region(value: RectPositioned) {\n    this.#r = value;\n  }\n\n  get region() {\n    return this.#r;\n  }\n\n  get width() {\n    return this.#r.width;\n  }\n\n  get height() {\n    return this.#r.height;\n  }\n\n  get x() {\n    return this.#r.x;\n  }\n\n  get y() {\n    return this.#r.y;\n  }\n\n  get dimensionMin() {\n    return Math.min(this.#r.width, this.#r.height);\n  }\n}\n","import * as Drawing from \"./Drawing.js\";\nimport * as Bipolar from \"../numbers/Bipolar.js\";\nimport * as Queues from \"../collections/queue/index.js\";\nimport * as Colour from \"./Colour.js\";\nimport { type CirclePositioned } from \"../geometry/index.js\";\nimport type { IQueueImmutable } from \"../collections/queue/IQueueImmutable.js\";\n\n/**\n * Options\n */\nexport type BipolarViewOptions = Readonly<{\n  width?: number,\n  height?: number,\n  labelPrecision?: number\n  labels?: [ string, string ],\n  axisColour?: string,\n  bgColour?: string,\n  whiskerColour?: string,\n  whiskerSize?: number,\n  dotColour?: string,\n  dotRadius?: number,\n  showWhiskers?: boolean,\n  showDot?: boolean,\n  showLabels?: boolean,\n  padding?: number,\n  labelColour?: string,\n  axisWidth?: number,\n  asPercentages?: boolean,\n  /**\n   * If non-zero, will render the last X number of values with increasing opacity.\n   * Default: 0\n   */\n  displayLastValues?: number\n  /**\n   * If _true_, (default) negative y values are at the bottom.\n   * If _false_  negative y values are at the top.\n   */\n  yAxisBottomNegative?: boolean,\n  /**\n   * Custom rendering for background\n   */\n  renderBackground?: Render\n}>\n\nfunction getNumericAttribute(el: HTMLElement, name: string, defaultValue: number) {\n  const a = el.getAttribute(name);\n  if (a === null) return defaultValue;\n  return Number.parseInt(a);\n}\n\nexport type Render = (ctx: CanvasRenderingContext2D, width: number, height: number) => void;\n/**\n * A function that plots a point on the graph\n */\nexport type BipolarView = (x: number, y: number) => void;\n\n/**\n * Initialises a plotter for bipolar values (-1...1)\n * \n * ```js\n * const p = BipolarView.init(`#my-canvas`);\n * // Shows the dot at 1, 0.5\n * p(1, 0.5);\n * ```\n * @param elementQuery \n * @param options \n * @returns \n */\nexport const init = (elementQuery: string, options: BipolarViewOptions = {}): BipolarView => {\n  const element = document.querySelector<HTMLCanvasElement>(elementQuery);\n  if (!element) throw new Error(`Element query could not be found (${ elementQuery })`);\n  const labels = options.labels ?? [ `x`, `y` ];\n  const labelPrecision = options.labelPrecision ?? 2;\n  const asPercentages = options.asPercentages ?? false;\n  const displayLastValues = options.displayLastValues ?? 0;\n  // Flags\n  const showWhiskers = options.showWhiskers ?? true;\n  const showDot = options.showDot ?? true;\n  const showLabels = options.showLabels ?? true;\n  const yAxisBottomNegative = options.yAxisBottomNegative ?? true;\n  // Colours\n  const axisColour = Colour.resolveToString(options.axisColour, `silver`);\n  const bgColour = Colour.resolveToString(options.bgColour, `white`);\n  const whiskerColour = Colour.resolveToString(options.whiskerColour, `black`);\n  const dotColour = Colour.resolveToString(options.dotColour, options.whiskerColour, `black`);\n  const labelColour = Colour.resolveToString(options.labelColour, options.axisColour, `silver`);\n\n  // Sizes\n  const axisWidth = (options.axisWidth ?? 1 * window.devicePixelRatio);\n  const dotRadius = (options.dotRadius ?? 5 * window.devicePixelRatio);\n  const pad = (options.padding ?? 10 * window.devicePixelRatio);\n  const whiskerSize = (options.whiskerSize ?? 5 * window.devicePixelRatio);\n  const width = (options.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio);\n  const height = (options.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio);\n\n  let lastValues: IQueueImmutable<CirclePositioned> | undefined;\n  if (displayLastValues > 0) {\n    lastValues = Queues.immutable<CirclePositioned>({\n      capacity: displayLastValues,\n      discardPolicy: `older`\n    });\n  }\n\n  element.width = width;// * window.devicePixelRatio;\n  element.height = height;// * window.devicePixelRatio;\n  element.style.width = `${ (width / window.devicePixelRatio) }px`;\n  element.style.height = `${ (height / window.devicePixelRatio) }px`;\n\n  const midY = height / 2;\n  const midX = width / 2;\n  const ctx = element.getContext(`2d`);\n  if (!ctx) throw new Error(`Could not create drawing context`);\n\n  if (window.devicePixelRatio >= 2) {\n    ctx.font = `20px sans-serif`;\n  }\n  const percentageFormat = (v: number) => `${ Math.round(v * 100) }%`;\n  const fixedFormat = (v: number) => v.toFixed(labelPrecision);\n\n  const valueFormat = asPercentages ? percentageFormat : fixedFormat;\n  if (showLabels) {\n    labels[ 0 ] = labels[ 0 ] + `:`;\n    labels[ 1 ] = labels[ 1 ] + `:`;\n  } else {\n    labels[ 0 ] = ``;\n    labels[ 1 ] = ``;\n  }\n\n  const renderBackground: Render = options.renderBackground ?? ((ctx, width, height): void => {\n    if (options.bgColour === `transparent`) {\n      ctx.clearRect(0, 0, width, height);\n    } else {\n      ctx.fillStyle = bgColour;\n      ctx.fillRect(0, 0, width, height);\n    }\n  });\n\n  return (x: number, y: number) => {\n    x = Bipolar.clamp(x);\n    y = Bipolar.clamp(y);\n\n    renderBackground(ctx, width, height);\n\n    // Labels\n    ctx.fillStyle = labelColour;\n    ctx.textBaseline = `top`;\n    ctx.save();\n    ctx.translate(midX, midY);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText((labels[ 1 ] + ` ` + valueFormat(y)).trim(), -midX + pad, 1);\n    ctx.restore();\n    ctx.fillText((labels[ 0 ] + ` ` + valueFormat(x)).trim(), pad, midX + 2);\n\n    if (!yAxisBottomNegative) y *= -1;\n\n    // Axes\n    ctx.strokeStyle = axisColour;\n    ctx.lineWidth = axisWidth;\n    ctx.beginPath();\n    ctx.moveTo(pad, midY);\n    ctx.lineTo(width - pad, midY);\n    ctx.moveTo(midX, pad);\n    ctx.lineTo(midX, height - pad);\n    ctx.stroke();\n    ctx.closePath();\n\n    const yy = (height - pad - pad) / 2 * -y;\n    const xx = (width - pad - pad) / 2 * x;\n    const dotPos = { x: xx, y: yy, radius: dotRadius };\n\n    if (lastValues) {\n      lastValues = lastValues.enqueue(dotPos);\n    }\n    ctx.save();\n    ctx.translate(midX, midY);\n\n    // Dot\n    if (showDot) {\n      if (lastValues) {\n        const opacityStep = 1 / lastValues.length;\n        let opacity = 1;\n        lastValues.forEach(d => {\n          const colour = Colour.multiplyOpacity(dotColour, opacity);\n          Drawing.circle(ctx, d, { fillStyle: colour });\n          opacity -= opacityStep;\n        });\n      } else {\n        Drawing.circle(ctx, dotPos, { fillStyle: dotColour });\n      }\n    }\n\n    // Whiskers\n    if (showWhiskers) {\n      ctx.strokeStyle = whiskerColour;\n\n      // y line\n      ctx.beginPath();\n      ctx.moveTo(0, yy - whiskerSize);\n      ctx.lineTo(0, yy + whiskerSize);\n\n      // x line\n      ctx.moveTo(xx - whiskerSize, 0);\n      ctx.lineTo(xx + whiskerSize, 0);\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    // Restore transform\n    ctx.restore();\n  }\n}\n","export * from './Cartesian.js';\nexport * from './CartesianCanvasPlot.js';\nexport * from './DataSet.js';\nexport type * from './Types.js';","\nimport { scaler } from \"../../numbers/Scale.js\";\nimport type { Point } from \"../../geometry/point/PointType.js\";\nimport type { GridStyle, LineStyle, ShowOptions, TextStyle } from \"./Types.js\";\n\nexport type PointMinMax = { min: Point, max: Point, width: number, height: number, minDim: number, maxDim: number };\n\nexport type PlotPoint = Point & {\n  fillStyle?: string\n  radius?: number\n}\n\nexport type CartesianScaler = (pt: Point) => Point;\n\nexport type CartesianDataRange = {\n  /**\n   * Converts a data value to relative value (0..1)\n   */\n  absDataToRelative: CartesianScaler\n  /**\n   * Converts a relative value to element-based coordinates\n   * (ie 0,0 is top-left of CANVAS)\n   */\n  relDataToCanvas: CartesianScaler\n  canvasToRelData: CartesianScaler\n  /**\n   * Converts canvas coordinate to relative\n   */\n  regionSpaceToRelative: CartesianScaler,\n  /**\n   * Converts relative coordinate to value\n   */\n  relDataToAbs: CartesianScaler\n  range: PointMinMax\n}\n\n\nexport type CartesianPlotOptions = {\n  clear: `region` | `canvas`\n  onInvalidated: () => void\n  /**\n * Margin around whole plot area. Use\n * to avoid dots being cut off by edge of canvas\n */\n  visualPadding: number\n  // canvasWidth: number\n  // canvasHeight: number\n  // canvasResize: ElementResizeLogic\n  // coordinateScale: ScaleBy\n  show: Partial<ShowOptions>\n  /**\n   * If 'auto' (default), range of plot is based on data.\n   * Otherwise specify the range, eg:\n   * `{ min: {x:-1,y:-1}, {x:1,y:1}}`\n   * \n   */\n  range: `auto` | { min: Point, max: Point }\n\n  /**\n   * Gridline setting\n   */\n  grid: Partial<GridStyle>\n  /**\n   * Drawing settings for axis (if 'showAxes' is enabled)\n   */\n  axisStyle: LineStyle\n  /**\n   * How values are drawn. Default: 'dot'\n   */\n  valueStyle: `dot` | ``,\n  /**\n   * How values are connected. Default: '' (no connecting)\n   * Values are connected in order of dataset.\n   */\n  connectStyle: `` | `line`,\n  textStyle: TextStyle\n  whiskerLength: number\n}\n\nexport const computeMinMax = (mm: Array<Point>): PointMinMax => {\n  const x = mm.map(m => m.x);\n  const y = mm.map(m => m.y);\n  const minX = Math.min(...x);\n  const maxX = Math.max(...x);\n  const minY = Math.min(...y);\n  const maxY = Math.max(...y);\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  return {\n    min: { x: minX, y: minY },\n    max: { x: maxX, y: maxY },\n    width, height,\n    minDim: Math.min(width, height),\n    maxDim: Math.max(width, height)\n  }\n}\n\nexport const relativeCompute = (minMax: PointMinMax) => {\n  if (!Number.isFinite(minMax.height)) {\n    return (point: Point) => point;\n  }\n  const xScale = scaler(minMax.min.x, minMax.max.x);\n  const yScale = scaler(minMax.min.y, minMax.max.y);\n  return (point: Point) => ({\n    x: xScale(point.x),\n    y: yScale(point.y)\n  });\n}\n\nexport const absoluteCompute = (minMax: PointMinMax) => {\n  const xScale = scaler(0, 1, minMax.min.x, minMax.max.x);\n  const yScale = scaler(0, 1, minMax.min.y, minMax.max.y);\n  return (point: Point) => ({\n    x: xScale(point.x),\n    y: yScale(point.y)\n  });\n}\n\nexport type AxisMark = Point & {\n  major: boolean\n}\nexport const computeAxisMark = (mm: PointMinMax, increments: number, major: number): { x: Array<AxisMark>, y: Array<AxisMark> } => {\n  // Vertical\n  const xValues: Array<AxisMark> = [];\n  let count = 0;\n\n  for (let x = mm.min.x; x < mm.max.x; x += increments) {\n    const isMajor = count % major === 0;\n    xValues.push({ x, y: 0, major: isMajor });\n    count++;\n  }\n\n  // Horizontal\n  count = 0;\n  const yValues: Array<AxisMark> = [];\n  for (let y = mm.min.y; y < mm.max.y; y += increments) {\n    const isMajor = count % major === 0;\n    yValues.push({ x: 0, y, major: isMajor })\n    count++;\n  }\n  return { x: xValues, y: yValues }\n}","import { MapOfSimpleMutable } from \"../../collections/index.js\";\n\nexport class DataSet<TValue, TSeriesMeta> {\n  #data;\n  #meta;\n  lastChange;\n\n  constructor() {\n    this.lastChange = performance.now();\n    this.#data = new MapOfSimpleMutable<TValue>();\n\n    this.#meta = new Map<string, TSeriesMeta>();\n  }\n\n  get metaCount() {\n    return this.#meta.size;\n  }\n\n  clear() {\n    this.#data.clear();\n    this.lastChange = performance.now();\n  }\n\n  set(series: string, data: Array<TValue>) {\n    this.#data.setValues(series, data);\n  }\n\n  deleteBySeries(series: string) {\n    const changed = this.#data.delete(series);\n    if (changed) {\n      this.lastChange = performance.now();\n    }\n    return changed;\n  }\n\n  setMeta(series: string, meta: TSeriesMeta) {\n    this.#meta.set(series, meta);\n  }\n\n  hasMeta(series: string) {\n    return this.#meta.has(series);\n  }\n\n  getMeta(series: string) {\n    return this.#meta.get(series);\n  }\n\n  *getValues() {\n    yield* this.#data.valuesFlat();\n  }\n\n  *getEntries() {\n    yield* this.#data.entries();\n  }\n\n  *getSeries() {\n    yield* this.#data.values();\n  }\n\n  add(value: TValue, series = `default`) {\n    this.#data.addKeyedValues(series, value);\n    this.lastChange = performance.now();\n  }\n}","import type { Interval } from '../flow/IntervalType.js';\nimport * as Rx from '../rx/index.js';\n\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param elapsed\n * @returns\n */\nexport const windowResize = (elapsed?: Interval) => Rx.Ops.debounce<{ innerWidth: number, innerHeight: number }>({ elapsed: elapsed ?? 100 })(Rx.From.event(window, `resize`, { innerWidth: 0, innerHeight: 0 }));\n\n/**\n * Observe when document's class changes\n *\n * ```js\n * const c = themeChangeObservable();\n * c.on(msg => {\n *  // do something...\n * });\n * ```\n * @returns\n */\nexport const themeChange = () => {\n  const m = Rx.From.observable<Array<MutationRecord>>(stream => {\n    const ro = new MutationObserver((entries) => {\n      stream.set(entries);\n    });\n    const opts: MutationObserverInit = {\n      attributeFilter: [ `class` ],\n      attributes: true,\n    };\n    ro.observe(document.documentElement, opts);\n\n    return () => {\n      ro.disconnect();\n    }\n  });\n  return m;\n}\n\n/**\n * Observe when element resizes. Specify `interval` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param interval Tiemout before event gets triggered\n * @returns\n */\nexport const resizeObservable = (\n  elem: Readonly<Element>,\n  interval?: Interval\n) => {\n  if (elem === null) {\n    throw new Error(`elem parameter is null. Expected element to observe`);\n  }\n  if (elem === undefined) {\n    throw new Error(`elem parameter is undefined. Expected element to observe`);\n  }\n\n  const m = Rx.From.observable<Array<ResizeObserverEntry>>(stream => {\n    const ro = new ResizeObserver((entries) => {\n      stream.set(entries);\n    });\n    ro.observe(elem);\n\n    return () => {\n      ro.unobserve(elem);\n    };\n  });\n  return Rx.Ops.debounce<Array<ResizeObserverEntry>>({ elapsed: interval ?? 100 })(m);\n}\n","import type { Reactive } from \"src/rx/Types.js\";\nimport type { Rect } from \"../geometry/rect/RectTypes.js\";\nimport * as Rects from '../geometry/rect/index.js';\nimport { resizeObservable, windowResize } from \"./DomRx.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\n\n/**\n * * width: use width of parent, set height based on original aspect ratio of element. Assumes parent has a determined width.\n * * height: use height of parent, set width based on original aspect ratio of element. Assumes parent has a determined height.\n * * both: use height & width of parent, so the element adopts the ratio of the parent. Be sure that parent has a width and height set.\n * * min: use the smallest dimension of parent\n * * max: use the largest dimension of parent\n */\nexport type ElementResizeLogic = `width` | `height` | `both` | `none` | `min` | `max`;\n\nexport type ElementSizerOptions<T extends HTMLElement | SVGElement> = {\n  stretch?: ElementResizeLogic\n  naturalSize?: Rect\n  // el: HTMLElement | string\n  containerEl?: HTMLElement | string\n  onSetSize: (size: Rect, el: T) => void\n}\n\nexport class ElementSizer<T extends HTMLElement | SVGElement> {\n  #stretch: ElementResizeLogic;\n  #size: Rect;\n  #naturalSize: Rect;\n  #naturalRatio: number;\n  #viewport: Rects.RectPositioned;\n  #onSetSize;\n  #el: T;\n  #containerEl: HTMLElement;\n  #disposed = false;\n  #resizeObservable: Reactive<any> | undefined;\n\n  constructor(elOrQuery: T | string, options: ElementSizerOptions<T>) {\n    this.#el = resolveEl(elOrQuery);\n    this.#containerEl = options.containerEl ? resolveEl(options.containerEl) : this.#el.parentElement!;\n\n    this.#stretch = options.stretch ?? `none`;\n    this.#onSetSize = options.onSetSize;\n    this.#size = Rects.Empty;\n\n    let naturalSize = options.naturalSize;\n    if (naturalSize === undefined) {\n      naturalSize = this.#el.getBoundingClientRect();\n    }\n    this.#naturalRatio = 1;\n    this.#naturalSize = naturalSize;\n    this.setNaturalSize(naturalSize);\n    this.#viewport = Rects.EmptyPositioned;\n\n    if (this.#containerEl === document.body) {\n      this.#byViewport();\n    } else {\n      this.#byContainer();\n    }\n  }\n\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizeObservable) {\n      this.#resizeObservable.dispose(`ElementSizing (${ reason })`);\n      this.#resizeObservable = undefined;\n    }\n  }\n\n  static canvasParent(canvasElementOrQuery: HTMLCanvasElement | string, options: ElementSizerOptions<HTMLCanvasElement>): ElementSizer<HTMLCanvasElement> {\n    const el = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    const er = new ElementSizer<HTMLCanvasElement>(el, {\n      ...options,\n      onSetSize(size, el) {\n        el.width = size.width;\n        el.height = size.height;\n        if (options.onSetSize) options.onSetSize(size, el);\n        //el.setAttribute(`width`, size.width.toString());\n        //el.setAttribute(`height`, size.height.toString());\n      },\n    });\n    return er;\n  }\n\n  static canvasViewport(canvasElementOrQuery: HTMLCanvasElement | string, options: { zIndex?: number } & ElementSizerOptions<HTMLCanvasElement>): ElementSizer<HTMLCanvasElement> {\n    const el = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    el.style.position = `absolute`;\n    el.style.zIndex = (options.zIndex ?? 0).toString();\n    el.style.left = `0px`;\n    el.style.top = `0px`;\n    const opts: ElementSizerOptions<HTMLCanvasElement> = { ...options, containerEl: document.body }\n    return this.canvasParent(canvasElementOrQuery, opts);\n  }\n\n  static svgViewport(svg: SVGElement): ElementSizer<SVGElement> {\n    const er = new ElementSizer<SVGElement>(svg, {\n      containerEl: document.body,\n      stretch: `both`,\n      onSetSize(size) {\n        svg.setAttribute(`width`, size.width.toString());\n        svg.setAttribute(`height`, size.height.toString());\n      },\n    });\n    return er;\n  }\n\n\n  #byContainer() {\n    const c = this.#containerEl;\n    if (!c) throw new Error(`No container element`);\n\n    // Listen for resize\n    const r = resizeObservable(c);\n    r.onValue((v) => { this.#onParentResize(v); });\n\n    // Get current value\n    const current = this.#getStretchSize(c.getBoundingClientRect());\n    this.size = current;\n\n    this.#resizeObservable = r;\n  }\n\n  #byViewport() {\n    const r = windowResize();\n    r.onValue(v => {\n      this.#onViewportResize();\n    });\n\n    this.#resizeObservable = r;\n    this.#onViewportResize();\n  }\n\n  #onViewportResize() {\n    this.size = { width: window.innerWidth, height: window.innerHeight };\n    this.#viewport = {\n      x: 0, y: 0,\n      ...this.size\n    };\n  }\n  /**\n   * Sets the 'natural' size of an element.\n   * This can also be specified when creating ElementSizer.\n   * @param size \n   */\n  setNaturalSize(size: Rect) {\n    this.#naturalSize = size;\n    this.#naturalRatio = size.width / size.height;\n  }\n\n  get naturalSize() {\n    return this.#naturalSize;\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  #getStretchSize(parentSize: Rect) {\n    let { width, height } = parentSize;\n\n    let stretch = this.#stretch;\n    if (stretch === `min`) {\n      stretch = width < height ? `width` : `height`;\n    } else if (stretch === `max`) {\n      stretch = width > height ? `width` : `height`;\n    }\n\n    if (stretch === `width`) {\n      height = width / this.#naturalRatio;\n    } else if (stretch === `height`) {\n      width = height * this.#naturalRatio;\n    }\n\n    return { width, height };\n  }\n\n\n  #onParentResize(args: Array<ResizeObserverEntry>) {\n    const box = args[ 0 ].contentBoxSize[ 0 ];\n    const parentSize = { width: box.inlineSize, height: box.blockSize };\n    this.size = this.#getStretchSize(parentSize);\n    this.#viewport = {\n      x: 0, y: 0,\n      width: parentSize.width,\n      height: parentSize.height\n    }\n  }\n\n  set size(size: Rect) {\n    Rects.guard(size, `size`);\n    this.#size = size;\n    this.#onSetSize(size, this.#el);\n  }\n\n  get size() {\n    return this.#size;\n  }\n}","import type { Point } from \"../../geometry/point/PointType.js\";\nimport { DataSet } from \"./DataSet.js\";\nimport type { Line, RectPositioned } from \"../../geometry/Types.js\";\nimport * as Rects from '../../geometry/rect/index.js';\nimport * as Cart from './Cartesian.js';\nimport { Colour } from \"../index.js\";\nimport { round } from \"../../numbers/Round.js\";\nimport type { GridStyle, LineStyle, SeriesMeta, ShowOptions, TextStyle } from \"./Types.js\";\nimport type { RecursivePartial } from \"../../TsUtil.js\";\nimport type { CanvasRegion } from \"../../visual/CanvasRegion.js\";\nimport { CanvasSource } from \"../../visual/CanvasRegion.js\";\nimport { resolveEl } from \"../../dom/ResolveEl.js\";\nimport { ElementSizer } from \"../../dom/ElementSizing.js\";\nimport { Points } from \"src/geometry/index.js\";\n\nexport type InsertOptions = (InsertOptionsViewport | InsertOptionsParent) & {\n  region?: RectPositioned\n};\n\nexport type InsertOptionsViewport = {\n  fill: `viewport`\n\n}\nexport type InsertOptionsParent = {\n  fill?: `parent`\n  parent: HTMLElement | string\n}\n\nexport const insert = (insertOptions: InsertOptions, options: RecursivePartial<Cart.CartesianPlotOptions> = {}) => {\n\n  const parentEl = (insertOptions.fill === `viewport`) ? document.body : resolveEl(insertOptions.parent);\n  const canvasEl = document.createElement(`canvas`);\n  parentEl.prepend(canvasEl);\n\n  const ds = new DataSet<Cart.PlotPoint, SeriesMeta>();\n\n  const source = new CanvasSource(canvasEl, `min`);\n  const rect = insertOptions.region ?? { x: 0, y: 0, width: 1, height: 1 };\n  const region = source.createRelative(rect, `independent`);\n  const p = new CartesianCanvasPlot(region, ds, options);\n\n  if (insertOptions.fill === `viewport`) {\n    ElementSizer.canvasViewport(canvasEl, {\n      onSetSize: (size, _el) => {\n        source.setLogicalSize(size);\n        p.invalidateRange();\n        p.draw();\n      }\n    });\n  } else {\n    ElementSizer.canvasParent(canvasEl, {\n      onSetSize: (size, _el) => {\n        source.setLogicalSize(size);\n        p.invalidateRange();\n        p.draw();\n      }\n    });\n  }\n  return p;\n}\n\n\n/**\n * Simple plotting of cartesian values.\n * \n * Create a plot that fills screen\n * ```js\n * const p = Plot.insert({fill`viewport});\n * const dataSet = p.dataSet;\n * \n * // Add data\n * ds.add({ x: 1, y: 2 });\n * \n * // Draw\n * p.draw();\n * ```\n *\n * Create a plot that fills a container\n * ```js\n * const p = Plot.insert({parent:`#someel`});\n * ```\n * \n * Add data using the created data set\n * ```js\n * \n * // Add a value to the `alpha` series\n * p.dataSet.add({x:1,y:1}, `alpha`);\n * ```\n * \n * Set default series formatting\n * ```js\n * p.setMeta(`default`, {\n *  colour: `hsl(50,100%,50%)`,\n *  lineWidth: 10\n * });\n * ```\n * \n * Series can have metadata associated with it in the DataSet\n * ```js\n * // Use 'pink' by default for the series 'alpha'\n * p.setMeta(`alpha`, { colour: `pink` });\n * ``\n * \n */\nexport class CartesianCanvasPlot {\n  #data;\n  #lastDataChange;\n  #canvasRegion;\n\n  actualDataRange: RectPositioned = Rects.EmptyPositioned;\n  visibleRange: RectPositioned = Rects.PlaceholderPositioned;\n  show: ShowOptions;\n  whiskerLength: number;\n  axisRounder = round(1, true);\n  onInvalidated: undefined | (() => void);\n\n  /**\n   * List of lines to draw after drawing everything else.\n   * Lines are given in value-coordinate space\n   */\n  overlayLines: Array<Line & LineStyle> = [];\n  #grid: GridStyle\n  #rangeMode;\n\n  #currentRange?: Cart.CartesianDataRange;\n\n  #axisStyle: LineStyle;\n  #valueStyle;\n  #connectStyle;\n  #rangeManual: Cart.PointMinMax | undefined;\n  #textStyle: TextStyle;\n  #visualPadding: number;\n  #visualClear: `region` | `canvas`;\n\n  constructor(cr: CanvasRegion, data: DataSet<Cart.PlotPoint, SeriesMeta>, options: RecursivePartial<Cart.CartesianPlotOptions> = {}) {\n    if (!data) throw new TypeError(`Param 'data' is undefined`);\n    if (typeof data !== `object`) throw new TypeError(`Param 'data' is not an object. Got: ${ typeof data }`);\n    this.onInvalidated = options.onInvalidated as undefined | (() => void);\n    this.#data = data;\n    this.#canvasRegion = cr;\n    this.#lastDataChange = 0;\n    this.#visualClear = options.clear ?? `region`;\n    this.#rangeMode = options.range ?? `auto`;\n    this.#valueStyle = options.valueStyle ?? `dot`;\n    this.#connectStyle = options.connectStyle ?? ``;\n    this.whiskerLength = options.whiskerLength ?? 5;\n    this.#visualPadding = options.visualPadding ?? 20;\n    this.show = {\n      axes: true,\n      axisValues: true,\n      grid: true,\n      whiskers: true,\n      ...options.show\n    };\n\n    this.#axisStyle = {\n      colour: `black`,\n      width: 2,\n      ...options.axisStyle\n    };\n    this.#textStyle = {\n      colour: `black`,\n      size: `1em`,\n      font: `system-ui`,\n      ...options.textStyle\n    };\n\n    this.#grid = {\n      increments: 0.1,\n      major: 5,\n      colour: `whitesmoke`,\n      width: 1,\n      ...options.grid\n    }\n  }\n\n  getCurrentRange() {\n    if (this.#data.lastChange === this.#lastDataChange && this.#currentRange) return this.#currentRange;\n    this.#lastDataChange = this.#data.lastChange;\n    const r = this.#createRange();\n    this.#currentRange = r;\n    if (this.onInvalidated) this.onInvalidated();\n    return r;\n  }\n\n  invalidateRange() {\n    this.#currentRange = undefined;\n  }\n\n  #createRange(): Cart.CartesianDataRange {\n    // Compute scale of data\n    const range = this.getDataRange(); // actual data range, or user-provided\n\n    const absDataToRelative = Cart.relativeCompute(range);\n    const relDataToAbs = Cart.absoluteCompute(range);\n    const cr = this.#canvasRegion;\n    const padding = this.#visualPadding;\n\n    // Offsets are in canvas coordinates, not region\n    // eg 0,0 is top-left corner of canvas\n    let xOffset = cr.x + padding;\n    let yOffset = cr.y + padding;\n\n    const allowedHeight = cr.height - (padding * 2);\n    const allowedWidth = cr.width - (padding * 2);\n    const dimensionMin = Math.min(allowedHeight, allowedWidth);;\n\n    if (allowedWidth >= allowedHeight) {\n      // Landscape\n      xOffset += (allowedWidth / 2) - (dimensionMin / 2);\n    } else {\n      // Portrait\n      yOffset += (allowedHeight / 2) - (dimensionMin / 2);\n    }\n\n    const relDataToCanvas = (pt: Point) => {\n      let { x, y } = pt;\n      if (x === Number.NEGATIVE_INFINITY) x = 0;\n      else if (x === Number.POSITIVE_INFINITY) x = 1;\n      if (y === Number.NEGATIVE_INFINITY) y = 0;\n      else if (y === Number.POSITIVE_INFINITY) y = 1;\n      x = x * dimensionMin;\n      y = (1 - y) * dimensionMin;\n\n      x += xOffset;\n      y += yOffset;\n\n      return { x, y }\n    };\n\n    const canvasToRelData = (pt: Point) => {\n      let { x, y } = pt;\n      x -= xOffset;\n      y -= yOffset;\n      x = x / dimensionMin;\n      y = 1 - (y / dimensionMin);\n      return { x, y }\n    };\n\n    // Convert region-space to plot area relative\n    const regionSpaceToRelative = (pt: Point) => {\n      let { x, y } = pt;\n      x = x - cr.x + this.#visualPadding;\n      y = (dimensionMin + this.#visualPadding) - y;\n      x /= dimensionMin;\n      y = (y / dimensionMin);\n      return { x, y }\n    }\n\n    return {\n      absDataToRelative, relDataToCanvas, canvasToRelData, regionSpaceToRelative, relDataToAbs, range\n    }\n  }\n\n\n  /**\n   * Positions an element at the viewport location of `data` point.\n   * Ensure the element has `position:absolute` set.\n   * @param data \n   * @param elementToPosition \n   * @param by \n   */\n  positionElementAt(data: Point, elementToPosition: HTMLElement | string, by: `middle` | `top-left` = `middle`, relativeToQuery?: HTMLElement | string) {\n    const el = resolveEl(elementToPosition);\n    let { x, y } = this.valueToScreenSpace(data);\n    // x -= this.canvasSource.offset.x;\n    // y -= this.canvasSource.offset.y;\n    if (by === `middle`) {\n      const bounds = el.getBoundingClientRect();\n      x -= bounds.width / 2;\n      y -= bounds.height / 2;\n    } else if (by === `top-left`) {\n      // no-op\n    } else throw new Error(`Param 'by' expected to be 'middle' or 'top-left'.`);\n    if (relativeToQuery) {\n      const relativeTo = resolveEl(relativeToQuery);\n      const bounds = relativeTo.getBoundingClientRect();\n\n      //console.log(`Plot relativeTo: ${ relativeTo.scrollTop } y:  ${ bounds.y }`);\n      x -= bounds.x;\n      y -= bounds.y;\n    }\n    el.style.left = `${ x }px`;\n    el.style.top = `${ y }px`;\n  }\n\n  /**\n   * When range is auto, returns the range of the data\n   * Otherwise returns the user-provided range.\n   * @returns \n   */\n  getDataRange(): Cart.PointMinMax {\n    if (this.#rangeMode === `auto`) {\n      return Cart.computeMinMax([ ...this.#data.getValues() ]);\n    } else {\n      if (!this.#rangeManual) {\n        this.#rangeManual = Cart.computeMinMax([ this.#rangeMode.max, this.#rangeMode.min ]);\n      }\n      return this.#rangeManual;\n    }\n  }\n\n  valueToScreenSpace(dataPoint: Point) {\n    const region = this.valueToRegionSpace(dataPoint);\n    const offset = this.canvasSource.offset;\n    const scr = {\n      x: region.x + offset.x,\n      y: region.y + offset.y\n    }\n    return scr;\n  }\n\n  valueToRegionSpace(dataValue: Point, debug = false) {\n    const ds = this.getCurrentRange();\n\n    // Scale absolute value relative to total dimensions of data\n    const rel = ds.absDataToRelative(dataValue);\n\n    // Scale relative data value to canvas space\n    const region = ds.relDataToCanvas(rel);\n\n    if (debug) console.log(`orig: ${ dataValue.x }x${ dataValue.y } rel: ${ rel.x }x${ rel.y } region: ${ region.x }x${ region.y }`);\n    return {\n      ...dataValue,\n      x: region.x,\n      y: region.y\n    }\n  }\n\n  // #regionSpaceToValue(scr: Point, clamped: boolean) {\n  //   const ds = this.getCurrentRange();\n\n  //   const rel = ds.regionSpaceToRelative(scr);\n  //   //console.log(`regionSpaceToRelative ${ rel.x.toFixed(2) },${ rel.y.toFixed(2) }`);\n\n  //   const value = ds.relDataToAbs(rel);\n  //   //if (debug) console.log(`orig: ${ a.x }x${ a.y } rel: ${ rel.x }x${ rel.y } scr: ${ scr.x }x${ scr.y }`);\n\n  //   const pt = {\n  //     ...scr,\n  //     x: value.x,\n  //     y: value.y\n  //   }\n  //   if (clamped) return clamp(pt);\n  //   return pt;\n  // }\n\n  /**\n   * Converts a point in pixel coordinates to a value.\n   * Useful for converting from user input coordinates.\n   * @param point \n   * @returns \n   */\n  pointToValue(point: Point, _source: `screen`) {\n    const ds = this.getCurrentRange();\n\n    // Apply offset\n    const canvasPoint = Points.subtract(point, this.canvasSource.offset);\n\n    const v = ds.canvasToRelData(canvasPoint);\n    return ds.relDataToAbs(v);\n  }\n\n  // valueToScreen(a: Point) {\n  //   const ds = this.getCurrentRange();\n  //   const rel = ds.valueToRelative(a);\n  //   const scr = ds.relativeToElementSpace(rel);\n  //   const bounds = this.helper.el.getBoundingClientRect();\n  //   return {\n  //     x: scr.x + bounds.x,\n  //     y: scr.y + bounds.y\n  //   }\n  // }\n\n  // valueRectToScreen(a: Point, b: Point): RectPositioned {\n  //   a = this.valueToScreen(a);\n  //   b = this.valueToScreen(b);\n  //   return {\n  //     x: a.x,\n  //     y: b.y,\n  //     width: b.x - a.x,\n  //     height: a.y - b.y\n  //   }\n  // }\n\n  /**\n   * Compute canvas-relative coordinates based on two points in value space\n   * @param valueA \n   * @param valueB \n   */\n  #valueLineToCanvasSpace(valueA: Point, valueB: Point, debug = false): Line {\n    valueA = this.valueToRegionSpace(valueA, debug) as Point;\n    valueB = this.valueToRegionSpace(valueB, debug) as Point;\n    return { a: valueA, b: valueB };\n  }\n\n  getDefaultMeta(): SeriesMeta {\n    return {\n      colour: Colour.goldenAngleColour(this.#data.metaCount),\n      lineWidth: 2,\n      dotRadius: 5\n    }\n  }\n\n  draw() {\n    if (this.#visualClear === `region`) {\n      this.#canvasRegion.clear();\n    } else {\n      this.canvasSource.clear();\n    }\n\n    //const ctx = this.helper.ctx;\n    //this.helper.drawBounds(`whitesmoke`);\n    //Drawing.rect(ctx, this.renderArea, { strokeStyle: `whitesmoke` });\n\n    this.#useGrid();\n    if (this.show.axes) this.#drawAxes();\n\n    //let seriesCount = 0;\n    for (const [ k, v ] of this.#data.getEntries()) {\n      let meta = this.#data.getMeta(k);\n      if (!meta) {\n        meta = this.getDefaultMeta();\n        this.#data.setMeta(k, meta);\n      }\n      this.#drawSeries(k, v, meta);\n      //seriesCount++;\n    }\n    //console.log(`series count: ${ seriesCount }`);\n    for (const line of this.overlayLines) {\n      this.drawLine(line, line.colour, line.width);\n    }\n  }\n\n  /**\n   * Draws a line in value-coordinate space\n   * @param line \n   * @param colour \n   * @param width \n   */\n  drawLine(line: Line, colour: string, width: number) {\n    const l = this.#valueLineToCanvasSpace(line.a, line.b);\n    this.#drawLineCanvasSpace(l, colour, width);\n  }\n\n  setMeta(series: string, meta: Partial<SeriesMeta>) {\n    this.#data.setMeta(series, {\n      ...this.getDefaultMeta(),\n      ...meta\n    })\n  }\n\n  #drawAxes() {\n    const { colour, width } = this.#axisStyle;\n    // Axis coordinates in canvas-space\n    const yAxis = this.#valueLineToCanvasSpace({ x: 0, y: Number.NEGATIVE_INFINITY }, { x: 0, y: Number.POSITIVE_INFINITY }, false);\n    const xAxis = this.#valueLineToCanvasSpace({ x: Number.NEGATIVE_INFINITY, y: 0 }, { x: Number.POSITIVE_INFINITY, y: 0 }, false);\n\n    //console.log(`x axis: ${ xAxis.a.x }-${ xAxis.b.x }`);\n    this.#drawLineCanvasSpace(xAxis, colour, width, false);\n    this.#drawLineCanvasSpace(yAxis, colour, width, false);\n  }\n\n\n  #drawYAxisValues(yPoints: Array<Point>) {\n    //const { ctx } = this.helper;\n    const ctx = this.#canvasRegion.context;\n\n    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;\n    ctx.fillStyle = this.#textStyle.colour;\n    ctx.textBaseline = `middle`;\n\n\n    for (const p of yPoints) {\n      if (p.x === 0 && p.y === 0) continue;\n      const reg = this.valueToRegionSpace(p, false);\n      const value = this.axisRounder(p.y);\n      const label = value.toString();\n      const measure = ctx.measureText(label);\n      const x = reg.x - measure.width - (this.whiskerLength / 2) - 5;\n      const y = reg.y;\n      ctx.fillText(label, x, y);\n    }\n  }\n\n  #drawXAxisValues(xPoints: Array<Point>) {\n    //const { ctx } = this.helper;\n    const ctx = this.#canvasRegion.context;\n    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;\n    ctx.fillStyle = this.#textStyle.colour;\n    ctx.textBaseline = `top`;\n    for (const p of xPoints) {\n      const reg = this.valueToRegionSpace(p, false);\n      const value = this.axisRounder(p.x);\n      const label = value.toString();\n      const measure = ctx.measureText(label);\n      const x = reg.x - measure.width / 2;\n      const y = reg.y + measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent + (this.whiskerLength / 2);\n      ctx.fillText(label, x, y);\n    }\n  }\n\n  #drawWhisker(p: Cart.AxisMark, vertical: boolean) {\n    const whiskerHalfLength = this.whiskerLength / 2;\n    const v = vertical ? { x: p.x, y: 0 } : { y: p.y, x: 0 }\n    const reg = this.valueToRegionSpace(v, false);\n\n    const line = vertical ? {\n      a: { x: reg.x, y: reg.y - whiskerHalfLength },\n      b: { x: reg.x, y: reg.y + whiskerHalfLength },\n    } :\n      {\n        a: { y: reg.y, x: reg.x - whiskerHalfLength },\n        b: { y: reg.y, x: reg.x + whiskerHalfLength },\n      }\n    this.#drawLineCanvasSpace(line, this.#axisStyle.colour, this.#axisStyle.width, false);\n  }\n\n  #drawGridline(p: Cart.AxisMark, vertical: boolean) {\n    const line = vertical ?\n      this.#valueLineToCanvasSpace({ x: p.x, y: Number.NEGATIVE_INFINITY }, { x: p.x, y: Number.POSITIVE_INFINITY }) :\n      this.#valueLineToCanvasSpace({ y: p.y, x: Number.NEGATIVE_INFINITY }, { y: p.y, x: Number.POSITIVE_INFINITY }, false);\n    this.#drawLineCanvasSpace(line, this.#grid.colour, p.major ? this.#grid.width * 2 : this.#grid.width);\n  }\n\n  #useGrid() {\n    const g = this.#grid;\n    const showGrid = this.show.grid;\n    const showWhiskers = this.show.whiskers;\n    const showValues = this.show.axisValues;\n    const mm = this.getCurrentRange().range; // actual data range, or user-provided\n    const { increments, major } = g;\n\n    // Vertical lines\n    const axisMarks = Cart.computeAxisMark(mm, increments, major);\n    for (const p of axisMarks.x) {\n      if (showGrid) this.#drawGridline(p, true);\n      if (showWhiskers && p.major) this.#drawWhisker(p, true);\n    }\n\n    // Horizontal lines\n    for (const p of axisMarks.y) {\n      if (showGrid) this.#drawGridline(p, false);\n      if (showWhiskers && p.major) this.#drawWhisker(p, false);\n    }\n\n    if (showValues) {\n      this.#drawXAxisValues(axisMarks.x.filter(p => p.major));\n      this.#drawYAxisValues(axisMarks.y.filter(p => p.major));\n    }\n  }\n\n  #drawSeries(name: string, series: Array<Cart.PlotPoint>, meta: SeriesMeta) {\n    if (this.#connectStyle === `line`) {\n      this.#drawConnected(series, meta.colour, meta.lineWidth);\n    }\n\n    //let valueCount = 0;\n    if (this.#valueStyle === `dot`) {\n      for (const v of series) {\n        this.#drawDot(v, meta.colour, meta.dotRadius);\n        //valueCount++;\n      }\n    }\n    //console.log(`valueCount: ${ valueCount }`);\n  }\n\n  #drawConnected(dots: Array<Cart.PlotPoint>, colour: string, width: number) {\n    const ctx = this.#canvasRegion.context;\n    ctx.beginPath();\n    for (const [ index, dot_ ] of dots.entries()) {\n      const dot = this.valueToRegionSpace(dot_, false);\n      if (index === 0) ctx.moveTo(dot.x, dot.y);\n      ctx.lineTo(dot.x, dot.y);\n    }\n    ctx.strokeStyle = Colour.resolveToString(colour);\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  #drawDot(originalDot: Cart.PlotPoint, fallbackColour: string, fallbackRadius: number) {\n    const colour = Colour.resolveToString(originalDot.fillStyle ?? fallbackColour);\n    const pos = this.valueToRegionSpace(originalDot);\n    const radius = originalDot.radius ?? fallbackRadius;\n    this.#canvasRegion.drawCircles([\n      { ...pos, radius }\n    ], colour);\n\n    // const ctx = this.helper.ctx;\n    // const dot = this.#valueToElementSpace(originalDot, false);\n    // const radius = originalDot.radius ?? fallbackRadius;\n    // //console.log(`dot ${ dot.x }x${ dot.y } (from ${ originalDot.x }x${ originalDot.y })`);\n    // ctx.fillStyle = Colour.resolveToString(originalDot.fillStyle ?? fallbackColour);\n    // ctx.beginPath();\n    // ctx.arc(dot.x, dot.y, radius, 0, Math.PI * 2);\n    // ctx.fill();\n    // ctx.closePath();\n  }\n\n\n  #drawLineCanvasSpace(line: Line, colour: string, width: number, debug = false) {\n    if (debug) console.log(line);\n    const ctx = this.#canvasRegion.context;\n\n    colour = Colour.resolveToString(colour);\n    //this.#canvasRegion.drawConnectedPoints([ line.a, line.b ], colour, width);\n    ctx.beginPath();\n    ctx.moveTo(line.a.x, line.a.y);\n    ctx.lineTo(line.b.x, line.b.y);\n    ctx.strokeStyle = Colour.resolveToString(colour);\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  get dataSet() {\n    return this.#data;\n  }\n\n  get canvasRegion() {\n    return this.#canvasRegion;\n  }\n\n  get canvasSource() {\n    return this.#canvasRegion.source;\n  }\n}"],"mappings":"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","names":["arc","ellipse","pos","corners","rect","Empty","line","clamp","clamp","rect","c","circle","ctx","width","height","clamp","Empty","el","guard","rect","line","dot"]}