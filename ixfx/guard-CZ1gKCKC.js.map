{"version":3,"file":"guard-CZ1gKCKC.js","names":["a: Point","b: Point","lines:Line[]","p: any","guard","line: Line","getPointParameter","aOrLine: Point | Line","b?: Point","length","aOrLine: Point | Line | PolyLine","pointB?: Point","sum","amount: number","aOrLine: Point | Line","pointBOrAllowOverflow?: Point | boolean","allowOverflow?: boolean","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","b","a","a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>","b?: number | boolean","c?: number","a: Point | Point3d","xOrB?: Point | Point3d | number","y?: number","z?: number","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a: Point","b?: Point","c?: Point","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","pt: Point | Point3d","v: number","pt: Point","length","ptOrX: Point | number","y?: number","rect: RectPositioned | Rect","origin?: Point","path: Path | QuadraticBezier | CubicBezier","path: Path | CubicBezier | QuadraticBezier"],"sources":["../../packages/geometry/src/line/from-points.ts","../../packages/geometry/src/line/join-points-to-lines.ts","../../packages/geometry/src/line/guard.ts","../../packages/geometry/src/line/get-points-parameter.ts","../../packages/geometry/src/line/length.ts","../../packages/geometry/src/line/interpolate.ts","../../packages/geometry/src/point/get-point-parameter.ts","../../packages/geometry/src/point/distance.ts","../../packages/geometry/src/point/divider.ts","../../packages/geometry/src/point/subtract.ts","../../packages/geometry/src/point/empty.ts","../../packages/geometry/src/point/point-type.ts","../../packages/geometry/src/point/angle.ts","../../packages/geometry/src/point/sum.ts","../../packages/geometry/src/point/multiply.ts","../../packages/geometry/src/point/magnitude.ts","../../packages/geometry/src/point/normalise.ts","../../packages/geometry/src/rect/corners.ts","../../packages/geometry/src/bezier/guard.ts"],"sourcesContent":["import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines:Line[] = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { isPoint } from \"../point/guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/point-type.js\";\nimport { isLine } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/point-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { numberTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n\n  if (!allowOverflow) resultThrow(percentTest(amount, `amount`));\n  else resultThrow(numberTest(amount, ``, `amount`));\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns \n */\nexport function pointAtDistance(line: Line, distance: number, fromA = true): Point {\n  if (!fromA) line = reverse(line);\n\n  const dx = line.b.x - line.a.x;\n  const dy = line.b.y - line.a.y;\n  const theta = Math.atan2(dy, dx);\n  const xp = distance * Math.cos(theta);\n  const yp = distance * Math.sin(theta);\n  return { x: xp + line.a.x, y: yp + line.a.y };\n}","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function getTwoPointParameters(a: Point, b: Point): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, b: Point3d): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a: Point, x: number, y: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number) {\n  if (isPoint3d(a1) && isPoint3d(ab2)) return [ a1, ab2 ];\n  if (isPoint(a1) && isPoint(ab2)) return [ a1, ab2 ];\n  if (isPoint3d(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3,\n      z: ab4\n    }\n    if (!isPoint3d(b)) throw new Error(`Expected x, y & z parameters`);\n    return [ a1, b ];\n  }\n  if (isPoint(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3\n    }\n    if (!isPoint(b)) throw new Error(`Expected x & y parameters`);\n    return [ a1, b ];\n  }\n\n  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n    const a = {\n      x: a1,\n      y: ab2,\n      z: ab3\n    };\n    const b = {\n      x: ab4,\n      y: ab5,\n      z: ab6\n    }\n    if (!isPoint3d(a)) throw new Error(`Expected x,y,z for first point`);\n    if (!isPoint3d(b)) throw new Error(`Expected x,y,z for second point`);\n    return [ a, b ];\n  }\n\n  const a = {\n    x: a1,\n    y: ab2\n  };\n  const b = {\n    x: ab3,\n    y: ab4\n  }\n  if (!isPoint(a)) throw new Error(`Expected x,y for first point`);\n  if (!isPoint(b)) throw new Error(`Expected x,y for second point`);\n  return [ a, b ];\n\n}\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from './point-type.js';\nimport { getPointParameter } from \"./get-point-parameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","\nimport { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  const pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | number[], b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | number[],\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function subtract(a: Point, b: Point): Point;\nexport function subtract(a: Point3d, b: Point3d): Point3d;\nexport function subtract(a: Point, x: number, y: number): Point;\nexport function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n * \n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x - ptB.x,\n    y: ptA.y - ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 } as const;\n\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 } as const;\n\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 } as const;\n\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 } as const;","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function multiply(a: Point, b: Point): Point;\nexport function multiply(a: Point3d, b: Point3d): Point3d;\nexport function multiply(a: Point, x: number, y: number): Point;\nexport function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x * ptB.x,\n    y: ptA.y * ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import { type Point } from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n"],"mappings":"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"}