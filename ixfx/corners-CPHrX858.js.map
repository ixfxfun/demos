{"version":3,"file":"corners-CPHrX858.js","names":["a: Point","b: Point","lines:Line[]","a: Point | Point3d","xOrB?: Point | Point3d | number","y?: number","z?: number","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","p: unknown","angleInDegrees: number | readonly number[]","angleInDegrees: number","angleInGradians: number","angleInRadians: number","angleInGradian: number","angleInRadians: number | readonly number[]","value: string | number | Angle","v: any","angleOrDegrees: Angle | number | string","destination: Angle[ `unit` ]","turns: number","degrees: number","radians: number","toCartesian: ToCartesian","a: Coord | number","b?: Point | number","c?: Point","EmptyPoint","distance: number","angleRadians: number","origin: Point","distance","a: Point","b?: Point","c?: Point","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","pt: Point","length","ptOrX: Point | number","y?: number","rect: RectPositioned | Rect","origin?: Point"],"sources":["../../../ixfx/packages/geometry/src/line/from-points.ts","../../../ixfx/packages/geometry/src/line/join-points-to-lines.ts","../../../ixfx/packages/geometry/src/point/distance.ts","../../../ixfx/packages/geometry/src/point/divider.ts","../../../ixfx/packages/geometry/src/polar/guard.ts","../../../ixfx/packages/geometry/src/pi.ts","../../../ixfx/packages/geometry/src/angles.ts","../../../ixfx/packages/geometry/src/polar/conversions.ts","../../../ixfx/packages/geometry/src/point/angle.ts","../../../ixfx/packages/geometry/src/point/sum.ts","../../../ixfx/packages/geometry/src/point/magnitude.ts","../../../ixfx/packages/geometry/src/point/normalise.ts","../../../ixfx/packages/geometry/src/rect/corners.ts"],"sourcesContent":["import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines:Line[] = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from './point-type.js';\nimport { getPointParameter } from \"./get-point-parameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","\nimport { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  const pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | number[], b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | number[],\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Coord } from \"./types.js\";\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};","export const piPi = Math.PI * 2;","import { piPi } from './pi.js';\nimport type { Point } from './point/point-type.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: readonly number[]): readonly number[];\n\n\nexport function degreeToRadian(angleInDegrees: number | readonly number[]): number | readonly number[] {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians \n * @returns \n */\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\nexport function degreeToGradian(angleInDegrees: number) {\n  return angleInDegrees * 1.111111\n}\n\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians \n * @param wrap \n * @returns \n */\nexport function gradianToDegree(angleInGradians: number, wrap = true) {\n  if (wrap) return (angleInGradians * 0.9) % 360;\n  return angleInGradians * 0.9;\n}\n\n\nexport function radianToGradian(angleInRadians: number) {\n  return angleInRadians * 63.6619772368; // 200/pi\n}\n\nexport function gradianToRadian(angleInGradian: number) {\n  return angleInGradian * 0.0157079633; // pi/200\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: readonly number[]): readonly number[];\n\n\nexport function radianToDegree(angleInRadians: number | readonly number[]): number | readonly number[] {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start: number, amount: number, clockwise = true) => {\n  if (clockwise) {\n    let x = start + amount;\n    if (x >= piPi) x = x % piPi;\n    return x;\n  } else {\n    const x = start - amount;\n    if (x < 0) {\n      return piPi + x;\n    }\n    return x;\n  }\n}\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n * \n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start: number, amount: number, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n * \n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n * \n * See {@link degreeArc} to operate in degrees.\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start: number, end: number, clockwise = true) => {\n  let s = start;\n  if (end < s) {\n    s = 0;\n    end = piPi - start + end;\n  }\n  let d = end - s;\n  if (clockwise) d = piPi - d;\n  if (d >= piPi) return d % piPi;\n  return d;\n}\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n * \n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n * \n * See {@link radianArc} to operate in radians.\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start: number, end: number, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));\n\n\nexport type Angle = {\n  value: number\n  unit: `deg` | `rad` | `turn` | `grad`\n}\n\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n * \n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n * \n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n * \n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value \n * @returns \n */\nexport const angleParse = (value: string | number | Angle): Angle => {\n  if (isAngle(value)) return value;\n\n  if (typeof value === `number`) {\n    return {\n      value, unit: `deg`\n    }\n  }\n  value = value.toLowerCase();\n  let unit = `deg`;\n  let numberValue = Number.NaN;\n  if (value.endsWith(`grad`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n    unit = `grad`;\n  } else if (value.endsWith(`rad`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n    unit = `rad`;\n  } else if (value.endsWith(`turn`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n    unit = `turn`;\n  } else if (value.endsWith(`deg`)) {\n    numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n    unit = `deg`;\n  } else {\n    numberValue = Number.parseFloat(value);\n  }\n\n  if (Number.isNaN(numberValue)) throw new Error(`Invalid angle (bad value?)`);\n  if (unit.length === 0) throw new Error(`Invalid angle (no unit)`);\n  return {\n    value: numberValue,\n    unit: unit as `deg` | `grad` | `turn` | `rad`\n  }\n}\n\nconst isAngle = (v: any): v is Angle => {\n  if (typeof v !== `object`) return false;\n  if (`unit` in v && `value` in v) {\n    if (typeof v.unit !== `string`) return false;\n    if (typeof v.value !== `number`) return false;\n    return true;\n  }\n  return false;\n}\n\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n * \n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n * \n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n * \n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees \n * @param destination \n * @returns \n */\nexport const angleConvert = (angleOrDegrees: Angle | number | string, destination: Angle[ `unit` ]): Angle => {\n  const angle = typeof angleOrDegrees === `object` ? angleOrDegrees : angleParse(angleOrDegrees);\n  switch (destination) {\n    case `deg`:\n      if (angle.unit === `deg`) return angle;\n      if (angle.unit === `rad`) return { value: radianToDegree(angle.value), unit: `deg` };\n      if (angle.unit === `grad`) return { value: gradianToDegree(angle.value), unit: `deg` };\n      if (angle.unit === `turn`) return { value: turnToDegree(angle.value), unit: `deg` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `grad`:\n      if (angle.unit === `deg`) return { value: degreeToGradian(angle.value), unit: `grad` };\n      if (angle.unit === `rad`) return { value: radianToGradian(angle.value), unit: `grad` };\n      if (angle.unit === `grad`) return angle;\n      if (angle.unit === `turn`) return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `rad`:\n      if (angle.unit === `deg`) return { value: degreeToRadian(angle.value), unit: `rad` };\n      if (angle.unit === `rad`) return angle;\n      if (angle.unit === `grad`) return { value: gradianToRadian(angle.value), unit: `rad` };\n      if (angle.unit === `turn`) return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    case `turn`:\n      if (angle.unit === `deg`) return { value: degreeToTurn(angle.value), unit: `turn` };\n      if (angle.unit === `rad`) return { value: radianToTurn(angle.value), unit: `turn` };\n      if (angle.unit === `grad`) return { value: radianToTurn(gradianToRadian(angle.value)), unit: `turn` };\n      if (angle.unit === `turn`) return angle;\n      throw new Error(`Unknown unit: ${ angle.unit }`);\n    default:\n      throw new Error(`Destination unit unknown ('${ destination }). Expects: deg, grad, rad or turn`);\n  }\n}\n\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so \n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns \n * @param wrap \n * @returns \n */\nexport const turnToDegree = (turns: number, wrap = true) => {\n  if (wrap) return (turns * 360) % 360;\n  return turns * 360;\n}\n\nexport const turnToRadian = (turns: number) => turns * piPi;\nexport const degreeToTurn = (degrees: number) => degrees / 360;\nexport const radianToTurn = (radians: number) => radians / piPi","import type { Point } from \"../point/point-type.js\";\nimport { guard, isPolarCoord } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = EmptyPoint;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = EmptyPoint;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtractPoint(point, origin);\n\n  const angle = Math.atan2(point.y, point.x);\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = EmptyPoint\n): Point => {\n  guardPoint(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyPoint): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import { type Point } from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};"],"mappings":"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"}