{"version":3,"file":"state-machine-BUeoIwqN.js","names":[],"sources":["../../flow/dist/src/state-machine/state-machine.js"],"sourcesContent":["import { unique } from '@ixfx/arrays';\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = (toClone) => {\n    return Object.freeze({\n        value: toClone.value,\n        visited: [...toClone.visited],\n        machine: toClone.machine,\n    });\n};\n/**\n * Initialises a state machine. [Read more in the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n *\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n *\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n *\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n *\n * StateMachine.isDone(sm); // false\n * StateMachine.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = (stateMachine, initialState) => {\n    const [machine, machineValidationError] = validateMachine(stateMachine);\n    if (!machine)\n        throw new Error(machineValidationError);\n    const state = \n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState) ?? Object.keys(machine.states)[0];\n    if (typeof machine.states[state] === `undefined`) {\n        throw new TypeError(`Initial state ('${state}') not found`);\n    }\n    // Normalise states\n    const transitions = validateAndNormaliseTransitions(machine.states);\n    if (transitions === undefined) {\n        throw new Error(`Could not normalise transitions`);\n    }\n    return Object.freeze({\n        value: state,\n        visited: [],\n        machine: Object.freeze(Object.fromEntries(transitions)),\n    });\n};\nexport const reset = (sm) => {\n    return init(sm.machine);\n};\nexport const validateMachine = (smOrTransitions) => {\n    if (typeof smOrTransitions === `undefined`) {\n        return [undefined, `Parameter undefined`];\n    }\n    if (smOrTransitions === null) {\n        return [undefined, `Parameter null`];\n    }\n    if (`states` in smOrTransitions) {\n        // Assume Machine type\n        return [smOrTransitions, ``];\n    }\n    if (typeof smOrTransitions === `object`) {\n        return [\n            {\n                states: smOrTransitions,\n            },\n            ``,\n        ];\n    }\n    return [\n        undefined,\n        `Unexpected type: ${typeof smOrTransitions}. Expected object`,\n    ];\n};\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = (sm) => {\n    return possible(sm).length === 0;\n};\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = (sm) => {\n    // Validate current state\n    validateMachineState(sm);\n    // get list of possible targets\n    const fromS = sm.machine[sm.value];\n    if (fromS.length === 1 && fromS[0].state === null)\n        return [];\n    return fromS;\n};\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = (sm) => {\n    const targets = possibleTargets(sm);\n    return targets.map((v) => v.state);\n};\nexport const normaliseTargets = (targets) => {\n    const normaliseSingleTarget = (target) => {\n        // Terminal target\n        if (target === null)\n            return { state: null };\n        // String is the target state\n        if (typeof target === `string`) {\n            return {\n                state: target,\n            };\n        }\n        else if (typeof target === `object` && `state` in target) {\n            const targetState = target.state;\n            if (typeof targetState !== `string`) {\n                throw new TypeError(`Target 'state' field is not a string. Got: ${typeof targetState}`);\n            }\n            if (`preconditions` in target) {\n                return {\n                    state: targetState,\n                    preconditions: target.preconditions,\n                };\n            }\n            return { state: targetState };\n        }\n        else {\n            throw new Error(`Unexpected type: ${typeof target}. Expected string or object with 'state' field.`);\n        }\n    };\n    // Array of targets (either strings or objects)\n    if (Array.isArray(targets)) {\n        let containsNull = false;\n        const mapResults = targets.map((t) => {\n            const r = normaliseSingleTarget(t);\n            if (!r)\n                throw new Error(`Invalid target`);\n            containsNull = containsNull || r.state === null;\n            return r;\n        });\n        if (containsNull && mapResults.length > 1) {\n            throw new Error(`Cannot have null as an possible state`);\n        }\n        return mapResults;\n    }\n    else {\n        const target = normaliseSingleTarget(targets);\n        if (!target)\n            return;\n        return [target];\n    }\n};\nconst validateAndNormaliseTransitions = (d) => {\n    const returnMap = new Map();\n    // 1. Index top-level states\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        if (typeof topLevelState === `undefined`) {\n            throw new TypeError(`Top-level undefined state`);\n        }\n        if (typeof topLevelTargets === `undefined`) {\n            throw new TypeError(`Undefined target state for ${topLevelState}`);\n        }\n        if (returnMap.has(topLevelState)) {\n            throw new Error(`State defined twice: ${topLevelState}`);\n        }\n        if (topLevelState.includes(` `)) {\n            throw new Error(`State names cannot contain spaces`);\n        }\n        returnMap.set(topLevelState, []);\n    }\n    // 2. Normalise target\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        const targets = normaliseTargets(topLevelTargets);\n        if (targets === undefined)\n            throw new Error(`Could not normalise target`);\n        if (targets !== null) {\n            // Check that they all exist as top-level states\n            const seenStates = new Set();\n            for (const target of targets) {\n                if (seenStates.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' already exists for '${topLevelState}'`);\n                }\n                seenStates.add(target.state);\n                if (target.state === null)\n                    continue;\n                if (!returnMap.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' is not defined as a top-level state. Defined under: '${topLevelState}'`);\n                }\n            }\n            returnMap.set(topLevelState, targets);\n        }\n    }\n    return returnMap;\n};\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = (state) => {\n    if (typeof state === `undefined`) {\n        throw new TypeError(`Param 'state' is undefined`);\n    }\n    if (typeof state.value !== `string`) {\n        throw new TypeError(`Existing state is not a string`);\n    }\n};\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n *\n * @example Attempts to transition to 'name-of-state'\n * ```js\n * const newState = StateMachine.to(currentState, `name-of-state`);\n * ```\n *\n * Note that 'currentState' is not changed.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = (sm, toState) => {\n    validateMachineState(sm); // throws if not OK\n    validateTransition(sm, toState); // throws if not OK\n    return Object.freeze({\n        value: toState,\n        machine: sm.machine,\n        visited: unique([sm.visited, [sm.value]]),\n    });\n};\nexport const next = (sm) => {\n    //validateMachineState(sm);\n    const first = possibleTargets(sm).at(0);\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (!first || first.state === null) {\n        throw new Error(`Not possible to move to a next state from '${sm.value}`);\n    }\n    return to(sm, first.state);\n};\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = (sm, toState) => {\n    try {\n        validateTransition(sm, toState);\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nexport const validateTransition = (sm, toState) => {\n    if (toState === null)\n        throw new Error(`Cannot transition to null state`);\n    if (typeof toState === `undefined`) {\n        throw new Error(`Cannot transition to undefined state`);\n    }\n    if (typeof toState !== `string`) {\n        throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof toState}`);\n    }\n    //const toS = sm.machine[toState];\n    //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n    const p = possible(sm);\n    if (p.length === 0)\n        throw new Error(`Machine is in terminal state`);\n    if (!p.includes(toState)) {\n        throw new Error(`Target state '${toState}' not available at current state '${sm.value}'. Possible states: ${p.join(`, `)}`);\n    }\n};\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n *\n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length <= 2)\n        throw new Error(`Expects at least two states`);\n    for (let index = 0; index < states.length; index++) {\n        const s = states[index];\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = (index === states.length - 1) ? null : states[index + 1];\n    }\n    return t;\n};\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n *\n * See also {@link fromList}.\n *\n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length < 2)\n        throw new Error(`Expects at least two states`);\n    for (const [index, s] of states.entries()) {\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = [];\n    }\n    for (let index = 0; index < states.length; index++) {\n        const v = t[states[index]];\n        if (index === states.length - 1) {\n            if (states.length > 1) {\n                v.push(states[index - 1]);\n            }\n            else {\n                t[states[index]] = null;\n            }\n        }\n        else {\n            v.push(states[index + 1]);\n            if (index > 0)\n                v.push(states[index - 1]);\n        }\n    }\n    return t;\n};\n"],"mappings":"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"}