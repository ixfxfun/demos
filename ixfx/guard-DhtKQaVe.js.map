{"version":3,"file":"guard-DhtKQaVe.js","names":["p: any","guard","line: Line","aOrLine: Point | Line","b?: Point","aOrLine: Point | Line | PolyLine","pointB?: Point","amount: number","aOrLine: Point | Line","pointBOrAllowOverflow?: Point | boolean","allowOverflow?: boolean","path: Path | QuadraticBezier | CubicBezier","path: Path | CubicBezier | QuadraticBezier"],"sources":["../../../ixfx/packages/geometry/src/line/guard.ts","../../../ixfx/packages/geometry/src/line/get-points-parameter.ts","../../../ixfx/packages/geometry/src/line/length.ts","../../../ixfx/packages/geometry/src/line/interpolate.ts","../../../ixfx/packages/geometry/src/bezier/guard.ts"],"sourcesContent":["import { isPoint } from \"../point/guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/point-type.js\";\nimport { isLine } from \"./guard.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/point-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { numberTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n\n  if (!allowOverflow) resultThrow(percentTest(amount, `amount`));\n  else resultThrow(numberTest(amount, ``, `amount`));\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns \n */\nexport function pointAtDistance(line: Line, distance: number, fromA = true): Point {\n  if (!fromA) line = reverse(line);\n\n  const dx = line.b.x - line.a.x;\n  const dy = line.b.y - line.a.y;\n  const theta = Math.atan2(dy, dx);\n  const xp = distance * Math.cos(theta);\n  const yp = distance * Math.sin(theta);\n  return { x: xp + line.a.x, y: yp + line.a.y };\n}","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n"],"mappings":";;;;;;;;;;;;;AAYA,MAAa,SAAS,CAACA,MAAsB;AAC3C,KAAI,aAAiB,QAAO;AAC5B,KAAK,EAAW,aAAiB,QAAO;AACxC,KAAK,EAAW,aAAiB,QAAO;AACxC,MAAK,QAAS,EAAW,EAAE,CAAE,QAAO;AACpC,MAAK,QAAS,EAAW,EAAE,CAAE,QAAO;AACpC,QAAO;AACR;;;;;;;AASD,MAAa,aAAa,CAACA,MAA0B;AACnD,MAAK,MAAM,QAAQ,EAAE,CAAE,QAAO;CAE9B,MAAM,SAAS,EAAE,KAAK,QAAM,OAAO,EAAE,CAAC;AACtC,QAAO;AACR;;;;;;;;;;AAWD,MAAaC,UAAQ,CAACC,MAAY,QAAQ,UAAU;AAClD,KAAI,gBAAoB,OAAM,IAAI,OAAO,EAAG,KAAM;AAClD,KAAI,KAAK,aAAiB,OAAM,IAAI,OAAO,EAAG,KAAM,kDAAmD,KAAK,UAAU,KAAK,CAAE;AAC7H,KAAI,KAAK,aAAiB,OAAM,IAAI,OAAO,EAAG,KAAM,iDAAkD,KAAK,UAAU,KAAK,CAAE;AAC7H;;;;;;;;;;;;;AClCD,MAAa,oBAAoB,CAACC,SAAuBC,MAAyC;CAEhG,IAAI;AACJ,KAAI,OAAO,QAAQ,EAAE;AACnB,MAAI,QAAQ;AACZ,MAAI,QAAQ;CACb,OAAM;AACL,MAAI;AACJ,MAAI,aAAiB,OAAM,IAAI,OAAO,uEAAwE,KAAK,UAAU,EAAE,CAAE,MAAO,KAAK,UAAU,EAAE,CAAE;CAC5J;AACD,OAAW,IAAI,GAAG;AAClB,OAAW,IAAI,GAAG;AAElB,QAAO,CAAE,GAAG,CAAG;AAChB;;;;;;;;;;;ACUD,SAAgB,OAAOC,SAAkCC,QAAwB;AAC/E,KAAI,WAAW,QAAQ,EAAE;EACvB,MAAM,MAAM,QAAQ,OAAO,CAAC,aAAa,MAAM,OAAO,EAAE,GAAG,aAAa,EAAE;AAC1E,SAAO;CACR;AACD,KAAI,mBAAuB,OAAM,IAAI,WAAW;CAChD,MAAM,CAAE,GAAG,EAAG,GAAG,kBAAkB,SAAS,OAAO;CACnD,MAAM,IAAI,EAAE,IAAI,EAAE;CAClB,MAAM,IAAI,EAAE,IAAI,EAAE;AAClB,KAAI,EAAE,gBAAmB,EAAE,cAAiB;EAC1C,MAAM,IAAI,EAAE,IAAI,EAAE;AAClB,SAAO,KAAK,MAAM,GAAG,GAAG,EAAE;CAC3B,MACC,QAAO,KAAK,MAAM,GAAG,EAAE;AAE1B;;;;;;;;;;;;;ACGD,SAAgB,YAAYC,QAAgBC,SAAuBC,uBAAyCC,eAAgC;AAE1I,YAAW,2BAA2B,UAAU;AAC9C,kBAAgB;AAChB;CACD;AAGD,MAAK,cAAe,aAAY,YAAY,SAAS,QAAQ,CAAC;KACzD,aAAY,WAAW,SAAS,IAAI,QAAQ,CAAC;CAElD,MAAM,CAAE,GAAG,EAAG,GAAG,kBAAkB,SAAS,sBAAsB;CAElE,MAAM,IAAI,OAAO,GAAG,EAAE;CACtB,MAAM,KAAK,KAAK,IAAI;AAGpB,KAAI,MAAM,KAAK,OAAO,EAAG,QAAO,OAAO,OAAO,EAAE,GAAG,EAAG,EAAC;CAEvD,MAAM,IAAI,EAAE,IAAK,MAAM,EAAE,IAAI,EAAE,KAAK;CACpC,MAAM,IAAI,EAAE,IAAK,MAAM,EAAE,IAAI,EAAE,KAAK;AAEpC,QAAO,OAAO,OAAO;EACnB,GAAG;EACA;EACA;CACJ,EAAC;AACH;;;;AChFD,MAAa,oBAAoB,CAACC,SAAyE,KAAyB;AAEpI,MAAa,gBAAgB,CAACC,SAAqE,KAAqB,qBAAyB,KAAqB"}