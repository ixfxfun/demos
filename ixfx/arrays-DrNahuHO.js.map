{"version":3,"file":"arrays-DrNahuHO.js","names":["groupBy","contains"],"sources":["../../packages/arrays/dist/src/array-cycle.js","../../packages/arrays/dist/src/at-wrap.js","../../packages/arrays/dist/src/chunks.js","../../packages/arrays/dist/src/util/to-string.js","../../packages/arrays/dist/src/util/is-equal.js","../../packages/arrays/dist/src/contains.js","../../packages/arrays/dist/src/ensure-length.js","../../packages/arrays/dist/src/equality.js","../../packages/arrays/dist/src/filter.js","../../packages/arrays/dist/src/flatten.js","../../packages/arrays/dist/src/frequency.js","../../packages/arrays/dist/src/group-by.js","../../packages/arrays/dist/src/unique.js","../../packages/arrays/dist/src/insert-at.js","../../packages/arrays/dist/src/interleave.js","../../packages/arrays/dist/src/intersection.js","../../packages/arrays/dist/src/merge-by-key.js","../../packages/arrays/dist/src/pairwise.js","../../packages/arrays/dist/src/random.js","../../packages/arrays/dist/src/remove.js","../../packages/arrays/dist/src/sample.js","../../packages/arrays/dist/src/sort.js","../../packages/arrays/dist/src/until.js","../../packages/arrays/dist/src/zip.js","../src/arrays.ts"],"sourcesContent":["/**\n * Cycle through the contents of an array. By default starts at index 0.\n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n *\n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n *\n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n *\n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over\n * @returns\n */\nexport const cycle = (options) => {\n    const opts = [...options];\n    let index = 0;\n    const next = () => {\n        index++;\n        if (index === opts.length)\n            index = 0;\n        return value();\n    };\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const prev = () => {\n        index--;\n        if (index === -1)\n            index = opts.length - 1;\n        return value();\n    };\n    const value = () => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return opts.at(index);\n    };\n    const select = (indexOrValue) => {\n        if (typeof indexOrValue === `number`) {\n            index = indexOrValue;\n        }\n        else {\n            const found = opts.indexOf(indexOrValue);\n            if (found === -1)\n                throw new Error(`Could not find value`);\n            index = found;\n        }\n    };\n    const toArray = () => [...opts];\n    return { toArray, next, prev, get current() { return value(); }, select };\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\nexport const atWrap = (array, index) => {\n    throwNumberTest(index, ``, `index`);\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array`);\n    index = index % array.length;\n    return array.at(index);\n};\n","/**\n * Return `arr` broken up into chunks of `size`\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param array\n * @param size\n * @returns\n */\nexport function chunks(array, size) {\n    // https://surma.github.io/underdash/\n    const output = [];\n    for (let index = 0; index < array.length; index += size) {\n        output.push(array.slice(index, index + size));\n    }\n    return output;\n}\n","/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\n// export const toStringOrdered = (itemToMakeStringFor: unknown) => {\n//   if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n//   const allKeys = new Set<string>();\n//   JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n//   return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n// }\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\n// export const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n//   // ✔ UNIT TESTED\n//   if (a === b) return true; // Object references are the same, or string values are the same\n//   return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n// };\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n/**\n * Returns _true_ if contents of `needles` is contained by `haystack`.\n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * @param haystack\n * @param needles\n * @param eq\n */\nexport const contains = (haystack, needles, eq = (isEqualDefault)) => {\n    if (!Array.isArray(haystack)) {\n        throw new TypeError(`Expects haystack parameter to be an array`);\n    }\n    if (!Array.isArray(needles)) {\n        throw new TypeError(`Expects needles parameter to be an array`);\n    }\n    for (const needle of needles) {\n        let found = false;\n        for (const element of haystack) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            if (eq(needle, element)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n *\n * Uses JSON.toString() by default to compare values.\n *\n * See also:\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link unique} Get unique set of values in an array\n * @param array Array to examine\n * @param keyFunction Function to generate key string for object, uses JSON.stringify by default.\n * @returns\n */\nexport const containsDuplicateValues = (data, keyFunction = (toStringDefault)) => {\n    if (typeof data !== `object`)\n        throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${typeof data}`);\n    const set = new Set();\n    for (const v of data) {\n        const string_ = keyFunction(v);\n        if (set.has(string_))\n            return true;\n        set.add(string_);\n    }\n    return false;\n};\n/**\n * Returns _true_ if array contains duplicate instances based on `===` equality checking\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array\n * @returns\n */\nexport const containsDuplicateInstances = (array) => {\n    if (!Array.isArray(array))\n        throw new Error(`Parameter needs to be an array`);\n    for (let index = 0; index < array.length; index++) {\n        for (let x = 0; x < array.length; x++) {\n            if (index === x)\n                continue;\n            if (array[index] === array[x])\n                return true;\n        }\n    }\n    return false;\n};\n","/**\n * Returns a copy of `data` with specified length.\n * If the input array is too long, it is truncated.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with `undefined`\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * Arrays.ensureLength([1,2,3], 2); // [1,2]\n * Arrays.ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * Arrays.ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * Arrays.ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * Arrays.ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expand Expand strategy\n * @typeParam V Type of array\n */\nexport const ensureLength = (data, length, expand = `undefined`) => {\n    // Unit tested\n    if (data === undefined)\n        throw new Error(`Data undefined`);\n    if (!Array.isArray(data))\n        throw new Error(`data is not an array`);\n    if (data.length === length)\n        return [...data];\n    if (data.length > length) {\n        return data.slice(0, length);\n    }\n    const d = [...data];\n    const add = length - d.length;\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < add; index++) {\n        //eslint-disable-next-line functional/immutable-data\n        switch (expand) {\n            case `undefined`: {\n                // @ts-expect-error\n                d.push(undefined);\n                break;\n            }\n            case `repeat`: {\n                d.push(data[index % data.length]);\n                break;\n            }\n            case `first`: {\n                d.push(data[0]);\n                break;\n            }\n            case `last`: {\n                // @ts-expect-error\n                d.push(data.at(-1));\n                break;\n            }\n            // No default\n        }\n    }\n    return d;\n};\n","import { isEqualDefault, isEqualValueDefault } from \"./util/is-equal.js\";\nimport { guardArray } from \"@ixfx/guards\";\n/**\n * Returns _true_ if the two arrays have the same items at same indexes.\n *\n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n *\n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n *\n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n *\n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA\n * @param arrayB\n * @param equality Function to compare values\n */\nexport const isEqual = (arrayA, arrayB, equality = (isEqualDefault)) => {\n    // TODO: 'eq' function could be a key-generating function too\n    guardArray(arrayA, `arrayA`);\n    guardArray(arrayB, `arrayB`);\n    if (arrayA.length !== arrayB.length)\n        return false;\n    for (let indexA = 0; indexA < arrayA.length; indexA++) {\n        if (!(equality(arrayA[indexA], arrayB[indexA])))\n            return false;\n    }\n    return true;\n};\n/**\n * Returns _true_ if all values in the array are the same\n *\n * Uses value-based equality checking by default.\n *\n * @example Uses default equality function:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a1 = [ 10, 10, 10 ];\n * Arrays.isContentsTheSame(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * Arrays.isContentsTheSame(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * Arrays.isContentsTheSame(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const isContentsTheSame = (array, equality) => {\n    // TODO: 'equality' function could be a key-generating function too\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array.`);\n    if (array.length === 0)\n        return true;\n    const eq = equality ?? isEqualValueDefault;\n    const a = array[0];\n    const r = array.some((v) => !eq(a, v));\n    if (r)\n        return false;\n    return true;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { guardArray, guardIndex } from \"@ixfx/guards\";\nexport const withoutUndefined = (data) => {\n    return data.filter(v => v !== undefined);\n};\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = (data, filter) => {\n    const a = [];\n    const b = [];\n    for (const datum of data) {\n        //eslint-disable-next-line functional/immutable-data\n        if (filter(datum))\n            a.push(datum);\n        //eslint-disable-next-line functional/immutable-data\n        else\n            b.push(datum);\n    }\n    return [a, b];\n};\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween(array, predicate, startIndex, endIndex) {\n    guardArray(array);\n    if (typeof startIndex === `undefined`)\n        startIndex = 0;\n    if (typeof endIndex === `undefined`)\n        endIndex = array.length; //- 1;\n    guardIndex(array, startIndex, `startIndex`);\n    guardIndex(array, endIndex - 1, `endIndex`);\n    //const t: Array<V> = [];\n    //eslint-disable-next-line functional/no-let\n    for (let index = startIndex; index < endIndex; index++) {\n        //eslint-disable-next-line functional/immutable-data\n        if (predicate(array[index], index, array))\n            yield array[index]; //t.push(array[ index ]);\n    }\n    //return t;\n}\n;\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const filtered = Arrays.without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * Arrays.without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * Arrays.without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * Arrays.without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = (\n//eslint-disable-next-line functional/prefer-readonly-type\nsourceArray, toRemove, comparer = isEqualDefault) => {\n    if (Array.isArray(toRemove)) {\n        const returnArray = [];\n        for (const source of sourceArray) {\n            if (!toRemove.some(v => comparer(source, v))) {\n                returnArray.push(source);\n            }\n        }\n        return returnArray;\n    }\n    else {\n        return sourceArray.filter((v) => !comparer(v, toRemove));\n    }\n};\n","/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array) => [...array].flat();\n","/**\n * Computes the frequency of values by a grouping function.\n * ```js\n * const data = [1,2,3,4,5,6,7,8,9,10];\n * // Returns 'odd' or 'even' for an input value\n *\n * const groupBy = v => v % 2 === 0 ? `even`:`odd`;\n *\n * const data = frequencyByGroup(groupBy, data);\n * // Yields map with:\n * //  key: 'even', value: 5\n * //  key: 'odd', value: 5\n * @param groupBy\n * @param data\n * @returns\n */\nexport const frequencyByGroup = (groupBy, data) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'array' is expected to be an array. Got type: '${typeof data}'`);\n    const store = new Map();\n    for (const value of data) {\n        const group = groupBy(value);\n        if (typeof group !== `string` && typeof group !== `number`) {\n            throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${typeof group}' for value: '${value}'`);\n        }\n        let groupValue = store.get(group);\n        groupValue ??= 0;\n        groupValue++;\n        store.set(group, groupValue);\n    }\n    return store;\n};\n","/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [\n *  { age: 39, city: `London` },\n *  { age: 14, city: `Copenhagen` },\n *  { age: 23, city: `Stockholm` },\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = Arrays.groupBy(data, item => item.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = (array, grouper) => {\n    const map = new Map();\n    for (const a of array) {\n        const key = grouper(a);\n        let existing = map.get(key);\n        if (!existing) {\n            existing = [];\n            map.set(key, existing);\n        }\n        existing.push(a);\n    }\n    return map;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n *\n * By default uses Javascript's default equality checking\n *\n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = (arrays, comparer = (isEqualDefault)) => {\n    const t = [];\n    const contains = (v) => {\n        for (const tValue of t) {\n            if (comparer(tValue, v))\n                return true;\n        }\n        return false;\n    };\n    const flattened = arrays.flat(10);\n    for (const v of flattened) {\n        if (!contains(v))\n            t.push(v);\n    }\n    return t;\n};\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n *\n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n *\n * By default uses JSON.toString() to compare values.\n *\n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = (arrays, toString = toStringDefault) => {\n    const matching = new Set();\n    const t = [];\n    const flattened = arrays.flat(10);\n    for (const a of flattened) {\n        const stringRepresentation = toString(a);\n        if (matching.has(stringRepresentation))\n            continue;\n        matching.add(stringRepresentation);\n        t.push(a);\n    }\n    return t;\n};\n","/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down.\n * @param data\n * @param index\n * @param values\n * @returns\n */\nexport const insertAt = (data, index, ...values) => {\n    if (!Array.isArray(data)) {\n        throw new TypeError(`Param 'data' is not an arry`);\n    }\n    return [...data.slice(0, index), ...values, ...data.slice(index + 1)];\n};\n","import { isContentsTheSame } from \"./equality.js\";\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = Arrays.interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map(a => a.length);\n    if (!isContentsTheSame(lengths)) {\n        throw new Error(`Arrays must be of same length`);\n    }\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        for (const array of arrays) {\n            returnValue.push(array[index]);\n        }\n    }\n    return returnValue;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n *\n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also:\n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA\n * @param arrayB\n * @param equality\n * @returns\n */\nexport const intersection = (arrayA, arrayB, equality = isEqualDefault) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n","/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Maps.mergeByKey} if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFunction Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = (keyFunction, reconcile, ...arrays) => {\n    const result = new Map();\n    for (const m of arrays) {\n        for (const mv of m) {\n            if (mv === undefined)\n                continue;\n            const mk = keyFunction(mv);\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return [...result.values()];\n};\n","import { guardArray } from \"@ixfx/guards\";\n/**\n * Combines values in pairwise fashion.\n * Throws an error if there are less than two entries.\n *\n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [[1,2],[2,3],[3,4],[4,5] ]\n *\n * pairwise([ 1, 2, 3, 4 ]);\n * Yields:\n * [1,2],[2,3],[3,4]\n * ```\n * @param values\n */\nexport function* pairwise(values) {\n    guardArray(values, `values`);\n    if (values.length < 2)\n        throw new Error(`Array needs to have at least two entries. Length: ${values.length}`);\n    for (let index = 1; index < values.length; index++) {\n        yield [values[index - 1], values[index]];\n    }\n}\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = (array, reducer, initial) => {\n    guardArray(array, `arr`);\n    if (array.length < 2)\n        return initial;\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < array.length - 1; index++) {\n        initial = reducer(initial, array[index], array[index + 1]);\n    }\n    return initial;\n};\n","import { guardArray } from \"@ixfx/guards\";\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = (dataToShuffle, rand = Math.random) => {\n    guardArray(dataToShuffle, `dataToShuffle`);\n    const array = [...dataToShuffle];\n    for (let index = array.length - 1; index > 0; index--) {\n        const index_ = Math.floor(rand() * (index + 1));\n        [array[index], array[index_]] = [array[index_], array[index]];\n    }\n    return array;\n};\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = (array, rand = Math.random) => {\n    guardArray(array, `array`);\n    return array[Math.floor(rand() * array.length)];\n};\n","import { guardIndex } from \"@ixfx/guards\";\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = (\n//eslint-disable-next-line functional/prefer-readonly-type\ndata, index) => {\n    // ✔️ Unit tested\n    if (!Array.isArray(data)) {\n        throw new TypeError(`'data' parameter should be an array`);\n    }\n    guardIndex(data, index, `index`);\n    return [...data.slice(0, index), ...data.slice(index + 1)];\n};\n","import { throwIntegerTest } from '@ixfx/guards';\n/**\n * Samples values from an array. If `amount` is less or equal to 1, it's treated as a percentage to sample.\n * Otherwise it's treated as every _n_th value to sample.\n *\n * @example\n * By percentage - get half of the items\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example\n * By steps - every third value\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = (array, amount) => {\n    if (!Array.isArray(array))\n        throw new TypeError(`Param 'array' is not actually an array. Got type: ${typeof array}`);\n    let subsampleSteps = 1;\n    if (amount <= 1) {\n        // Subsample based on a percentage\n        const numberOfItems = array.length * amount;\n        subsampleSteps = Math.round(array.length / numberOfItems);\n    }\n    else {\n        subsampleSteps = amount;\n    }\n    throwIntegerTest(subsampleSteps, `positive`, `amount`);\n    if (subsampleSteps > array.length - 1) {\n        throw new Error(`Subsample steps exceeds array length`);\n    }\n    const r = [];\n    for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n        r.push(array[index]);\n    }\n    return r;\n};\n","import { guardArray } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = (data, propertyName) => [...data].sort((a, b) => {\n    guardArray(data, `data`);\n    const av = a[propertyName];\n    const bv = b[propertyName];\n    if (av < bv)\n        return -1;\n    if (av > bv)\n        return 1;\n    return 0;\n});\nexport const sortByProperty = (data, propertyName) => [...data].sort((a, b) => {\n    guardArray(data, `data`);\n    const av = a[propertyName];\n    const bv = b[propertyName];\n    if (av < bv)\n        return -1;\n    if (av > bv)\n        return 1;\n    return 0;\n});\n","/**\n * Yields all items in `data` for as long as `predicate` returns true.\n *\n * `predicate` yields arrays of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = [...until([1,2,3,4,5], v => [v === 3, 0])];\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport function* until(data, predicate, initial) {\n    let total = initial;\n    for (const datum of data) {\n        const [stop, accumulator] = predicate(datum, total);\n        if (stop)\n            break;\n        total = accumulator;\n        yield datum;\n    }\n}\n;\n","import { isContentsTheSame } from \"./equality.js\";\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map((a) => a.length);\n    if (!isContentsTheSame(lengths)) {\n        throw new Error(`Arrays must be of same length`);\n    }\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        returnValue.push(arrays.map((a) => a[index]));\n    }\n    return returnValue;\n};\n","\nexport * from '@ixfx/arrays';"],"mappings":"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"}