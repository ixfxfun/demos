{"version":3,"file":"guard-DPX_PMKU.js","names":["guardPoint","guard","getPointParameter","guardPoint","length","sum","getPointParameter","getPointParameter","length","length","EmptyPoint","distance","guardPoint"],"sources":["../../geometry/dist/src/rect/corners.js","../../geometry/dist/src/point/sum.js","../../geometry/dist/src/point/distance.js","../../geometry/dist/src/line/from-points.js","../../geometry/dist/src/line/join-points-to-lines.js","../../geometry/dist/src/line/guard.js","../../geometry/dist/src/line/get-points-parameter.js","../../geometry/dist/src/line/length.js","../../geometry/dist/src/pi.js","../../geometry/dist/src/point/angle.js","../../geometry/dist/src/point/divider.js","../../geometry/dist/src/line/interpolate.js","../../geometry/dist/src/point/magnitude.js","../../geometry/dist/src/point/normalise.js","../../geometry/dist/src/polar/guard.js","../../geometry/dist/src/angles.js","../../geometry/dist/src/polar/conversions.js","../../geometry/dist/src/bezier/guard.js"],"sourcesContent":["import {} from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (rect, origin) => {\n    const r = getRectPositioned(rect, origin);\n    return [\n        { x: r.x, y: r.y },\n        { x: r.x + r.width, y: r.y },\n        { x: r.x + r.width, y: r.y + r.height },\n        { x: r.x, y: r.y + r.height },\n    ];\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points added.\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x + ptB.x,\n        y: ptA.y + ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n","import { guard, isPoint3d } from \"./guard.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(a, xOrB, y, z) {\n    const pt = getPointParameter(xOrB, y, z);\n    guard(pt, `b`);\n    guard(a, `a`);\n    return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import { guard as guardPoint } from '../point/guard.js';\n/**\n * Returns a line from two points\n *\n * ```js\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns\n */\nexport const fromPoints = (a, b) => {\n    guardPoint(a, `a`);\n    guardPoint(b, `b`);\n    a = Object.freeze({ ...a });\n    b = Object.freeze({ ...b });\n    return Object.freeze({\n        a: a,\n        b: b\n    });\n};\n","import { fromPoints } from \"./from-points.js\";\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n *\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n *\n * ```js\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points\n * @returns\n */\nexport const joinPointsToLines = (...points) => {\n    const lines = [];\n    let start = points[0];\n    for (let index = 1; index < points.length; index++) {\n        lines.push(fromPoints(start, points[index]));\n        start = points[index];\n    }\n    return lines;\n};\n","import { isPoint } from \"../point/guard.js\";\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p) => {\n    if (p === undefined)\n        return false;\n    if (p.a === undefined)\n        return false;\n    if (p.b === undefined)\n        return false;\n    if (!isPoint(p.a))\n        return false;\n    if (!isPoint(p.b))\n        return false;\n    return true;\n};\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p\n * @returns\n */\nexport const isPolyLine = (p) => {\n    if (!Array.isArray(p))\n        return false;\n    const valid = !p.some(v => !isLine(v));\n    return valid;\n};\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n *\n * Does not validate points\n * @param line\n * @param name\n */\nexport const guard = (line, name = `line`) => {\n    if (line === undefined)\n        throw new Error(`${name} undefined`);\n    if (line.a === undefined)\n        throw new Error(`${name}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(line)}`);\n    if (line.b === undefined)\n        throw new Error(`${name}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(line)}`);\n};\n","import { isLine } from \"./guard.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine\n * @param b\n * @returns\n */\nexport const getPointParameter = (aOrLine, b) => {\n    let a;\n    if (isLine(aOrLine)) {\n        b = aOrLine.b;\n        a = aOrLine.a;\n    }\n    else {\n        a = aOrLine;\n        if (b === undefined)\n            throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n    }\n    guardPoint(a, `a`);\n    guardPoint(a, `b`);\n    return [a, b];\n};\n","import { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\n/**\n * Returns length of line, polyline or between two points\n *\n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\nexport function length(aOrLine, pointB) {\n    if (isPolyLine(aOrLine)) {\n        const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n        return sum;\n    }\n    if (aOrLine === undefined)\n        throw new TypeError(`Parameter 'aOrLine' is undefined`);\n    const [a, b] = getPointParameter(aOrLine, pointB);\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    if (a.z !== undefined && b.z !== undefined) {\n        const z = b.z - a.z;\n        return Math.hypot(x, y, z);\n    }\n    else {\n        return Math.hypot(x, y);\n    }\n}\n","export const piPi = Math.PI * 2;\n","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n *\n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a, b, c) => {\n    guard(a, `a`);\n    if (b === undefined) {\n        return Math.atan2(a.y, a.x);\n    }\n    guard(b, `b`);\n    if (c === undefined) {\n        return Math.atan2(b.y - a.y, b.x - a.x);\n    }\n    guard(c, `c`);\n    return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadianCircle = (a, b, c) => {\n    const angle = angleRadian(a, b, c);\n    if (angle < 0)\n        return angle + piPi;\n    return angle;\n};\n","import { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    if (ptB.x === 0)\n        throw new TypeError('Cannot divide by zero (b.x is 0)');\n    if (ptB.y === 0)\n        throw new TypeError('Cannot divide by zero (b.y is 0)');\n    const pt = {\n        x: ptA.x / ptB.x,\n        y: ptA.y / ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        if (ptB.z === 0)\n            throw new TypeError('Cannot divide by zero (b.z is 0)');\n        pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a, b, c) {\n    const divisor = getPointParameter(a, b, c);\n    guardNonZeroPoint(divisor, `divisor`);\n    return (aa, bb, cc) => {\n        const dividend = getPointParameter(aa, bb, cc);\n        return typeof dividend.z === `undefined` ? Object.freeze({\n            x: dividend.x / divisor.x,\n            y: dividend.y / divisor.y,\n        }) : Object.freeze({\n            x: dividend.x / divisor.x,\n            y: dividend.y / divisor.y,\n            z: dividend.z / (divisor.z ?? 1),\n        });\n    };\n}\n","import { numberTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between a line's start and end points.\n *\n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns\n */\nexport function interpolate(amount, aOrLine, pointBOrAllowOverflow, allowOverflow) {\n    if (typeof pointBOrAllowOverflow === `boolean`) {\n        allowOverflow = pointBOrAllowOverflow;\n        pointBOrAllowOverflow = undefined;\n    }\n    if (!allowOverflow)\n        resultThrow(percentTest(amount, `amount`));\n    else\n        resultThrow(numberTest(amount, ``, `amount`));\n    const [a, b] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n    const d = length(a, b);\n    const d2 = d * (1 - amount);\n    // Points are identical, return a copy of b\n    if (d === 0 && d2 === 0)\n        return Object.freeze({ ...b });\n    const x = b.x - (d2 * (b.x - a.x) / d);\n    const y = b.y - (d2 * (b.y - a.y) / d);\n    return Object.freeze({\n        ...b,\n        x: x,\n        y: y\n    });\n}\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns\n */\nexport function pointAtDistance(line, distance, fromA = true) {\n    if (!fromA)\n        line = reverse(line);\n    const dx = line.b.x - line.a.x;\n    const dy = line.b.y - line.a.y;\n    const theta = Math.atan2(dy, dx);\n    const xp = distance * Math.cos(theta);\n    const yp = distance * Math.sin(theta);\n    return { x: xp + line.a.x, y: yp + line.a.y };\n}\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt, max = 1, min = 0) => {\n    const length = distance(pt);\n    let ratio = 1;\n    if (length > max) {\n        ratio = max / length;\n    }\n    else if (length < min) {\n        ratio = min / length;\n    }\n    return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};\n","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nconst length = (ptOrX, y) => {\n    if (isPoint(ptOrX)) {\n        y = ptOrX.y;\n        ptOrX = ptOrX.x;\n    }\n    if (y === undefined)\n        throw new Error(`Expected y`);\n    return Math.hypot(ptOrX, y);\n};\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX, y) => {\n    const pt = getPointParameter(ptOrX, y);\n    const l = length(pt);\n    if (l === 0)\n        return Empty;\n    return Object.freeze({\n        ...pt,\n        x: pt.x / l,\n        y: pt.y / l,\n    });\n};\n","/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p) => {\n    if (p.distance === undefined)\n        return false;\n    if (p.angleRadian === undefined)\n        return false;\n    return true;\n};\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p, name = `Point`) => {\n    if (p === undefined) {\n        throw new Error(`'${name}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p === null) {\n        throw new Error(`'${name}' is null. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p.angleRadian === undefined) {\n        throw new Error(`'${name}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p.distance === undefined) {\n        throw new Error(`'${name}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (typeof p.angleRadian !== `number`) {\n        throw new TypeError(`'${name}.angleRadian' must be a number. Got ${p.angleRadian}`);\n    }\n    if (typeof p.distance !== `number`) {\n        throw new TypeError(`'${name}.distance' must be a number. Got ${p.distance}`);\n    }\n    if (p.angleRadian === null)\n        throw new Error(`'${name}.angleRadian' is null`);\n    if (p.distance === null)\n        throw new Error(`'${name}.distance' is null`);\n    if (Number.isNaN(p.angleRadian)) {\n        throw new TypeError(`'${name}.angleRadian' is NaN`);\n    }\n    if (Number.isNaN(p.distance))\n        throw new Error(`'${name}.distance' is NaN`);\n};\n","import { piPi } from './pi.js';\nexport function degreeToRadian(angleInDegrees) {\n    return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : angleInDegrees * (Math.PI / 180);\n}\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians\n * @returns\n */\nexport function radianInvert(angleInRadians) {\n    return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\nexport function degreeToGradian(angleInDegrees) {\n    return angleInDegrees * 1.111111;\n}\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians\n * @param wrap\n * @returns\n */\nexport function gradianToDegree(angleInGradians, wrap = true) {\n    if (wrap)\n        return (angleInGradians * 0.9) % 360;\n    return angleInGradians * 0.9;\n}\nexport function radianToGradian(angleInRadians) {\n    return angleInRadians * 63.6619772368; // 200/pi\n}\nexport function gradianToRadian(angleInGradian) {\n    return angleInGradian * 0.0157079633; // pi/200\n}\nexport function radianToDegree(angleInRadians) {\n    return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : angleInRadians * 180 / Math.PI;\n}\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point\n * @returns\n */\nexport const radiansFromAxisX = (point) => Math.atan2(point.x, point.y);\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start, amount, clockwise = true) => {\n    if (clockwise) {\n        let x = start + amount;\n        if (x >= piPi)\n            x = x % piPi;\n        return x;\n    }\n    else {\n        const x = start - amount;\n        if (x < 0) {\n            return piPi + x;\n        }\n        return x;\n    }\n};\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n *\n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start, amount, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n *\n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n *\n * See {@link degreeArc} to operate in degrees.\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start, end, clockwise = true) => {\n    let s = start;\n    if (end < s) {\n        s = 0;\n        end = piPi - start + end;\n    }\n    let d = end - s;\n    if (clockwise)\n        d = piPi - d;\n    if (d >= piPi)\n        return d % piPi;\n    return d;\n};\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n *\n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n *\n * See {@link radianArc} to operate in radians.\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start, end, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n *\n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n *\n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n *\n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value\n * @returns\n */\nexport const angleParse = (value) => {\n    if (isAngle(value))\n        return value;\n    if (typeof value === `number`) {\n        return {\n            value, unit: `deg`\n        };\n    }\n    value = value.toLowerCase();\n    let unit = `deg`;\n    let numberValue = Number.NaN;\n    if (value.endsWith(`grad`)) {\n        numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n        unit = `grad`;\n    }\n    else if (value.endsWith(`rad`)) {\n        numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n        unit = `rad`;\n    }\n    else if (value.endsWith(`turn`)) {\n        numberValue = Number.parseFloat(value.substring(0, value.length - 4));\n        unit = `turn`;\n    }\n    else if (value.endsWith(`deg`)) {\n        numberValue = Number.parseFloat(value.substring(0, value.length - 3));\n        unit = `deg`;\n    }\n    else {\n        numberValue = Number.parseFloat(value);\n    }\n    if (Number.isNaN(numberValue))\n        throw new Error(`Invalid angle (bad value?)`);\n    if (unit.length === 0)\n        throw new Error(`Invalid angle (no unit)`);\n    return {\n        value: numberValue,\n        unit: unit\n    };\n};\nconst isAngle = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (`unit` in v && `value` in v) {\n        if (typeof v.unit !== `string`)\n            return false;\n        if (typeof v.value !== `number`)\n            return false;\n        return true;\n    }\n    return false;\n};\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n *\n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n *\n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n *\n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees\n * @param destination\n * @returns\n */\nexport const angleConvert = (angleOrDegrees, destination) => {\n    const angle = typeof angleOrDegrees === `object` ? angleOrDegrees : angleParse(angleOrDegrees);\n    switch (destination) {\n        case `deg`:\n            if (angle.unit === `deg`)\n                return angle;\n            if (angle.unit === `rad`)\n                return { value: radianToDegree(angle.value), unit: `deg` };\n            if (angle.unit === `grad`)\n                return { value: gradianToDegree(angle.value), unit: `deg` };\n            if (angle.unit === `turn`)\n                return { value: turnToDegree(angle.value), unit: `deg` };\n            throw new Error(`Unknown unit: ${angle.unit}`);\n        case `grad`:\n            if (angle.unit === `deg`)\n                return { value: degreeToGradian(angle.value), unit: `grad` };\n            if (angle.unit === `rad`)\n                return { value: radianToGradian(angle.value), unit: `grad` };\n            if (angle.unit === `grad`)\n                return angle;\n            if (angle.unit === `turn`)\n                return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n            throw new Error(`Unknown unit: ${angle.unit}`);\n        case `rad`:\n            if (angle.unit === `deg`)\n                return { value: degreeToRadian(angle.value), unit: `rad` };\n            if (angle.unit === `rad`)\n                return angle;\n            if (angle.unit === `grad`)\n                return { value: gradianToRadian(angle.value), unit: `rad` };\n            if (angle.unit === `turn`)\n                return { value: radianToGradian(turnToRadian(angle.value)), unit: `grad` };\n            throw new Error(`Unknown unit: ${angle.unit}`);\n        case `turn`:\n            if (angle.unit === `deg`)\n                return { value: degreeToTurn(angle.value), unit: `turn` };\n            if (angle.unit === `rad`)\n                return { value: radianToTurn(angle.value), unit: `turn` };\n            if (angle.unit === `grad`)\n                return { value: radianToTurn(gradianToRadian(angle.value)), unit: `turn` };\n            if (angle.unit === `turn`)\n                return angle;\n            throw new Error(`Unknown unit: ${angle.unit}`);\n        default:\n            throw new Error(`Destination unit unknown ('${destination}). Expects: deg, grad, rad or turn`);\n    }\n};\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so\n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns\n * @param wrap\n * @returns\n */\nexport const turnToDegree = (turns, wrap = true) => {\n    if (wrap)\n        return (turns * 360) % 360;\n    return turns * 360;\n};\nexport const turnToRadian = (turns) => turns * piPi;\nexport const degreeToTurn = (degrees) => degrees / 360;\nexport const radianToTurn = (radians) => radians / piPi;\n","import { guard, isPolarCoord } from \"./guard.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian = (a, b, c) => {\n    if (isPolarCoord(a)) {\n        if (typeof b === `undefined`)\n            b = EmptyPoint;\n        if (isPoint(b)) {\n            return polarToCartesian(a.distance, a.angleRadian, b);\n        }\n        throw new Error(`Expecting (Coord, Point). Second parameter is not a point`);\n    }\n    else if (typeof a === `object`) {\n        throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(a)}`);\n    }\n    else {\n        if (typeof a === `number` && typeof b === `number`) {\n            if (c === undefined)\n                c = EmptyPoint;\n            if (!isPoint(c)) {\n                throw new Error(`Expecting (number, number, Point). Point param wrong type`);\n            }\n            return polarToCartesian(a, b, c);\n        }\n        else {\n            throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof a}, ${typeof b}, ${typeof c}). a: ${JSON.stringify(a)}`);\n        }\n    }\n};\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (point, origin) => {\n    point = subtractPoint(point, origin);\n    const angle = Math.atan2(point.y, point.x);\n    return Object.freeze({\n        ...point,\n        angleRadian: angle,\n        distance: Math.hypot(point.x, point.y),\n    });\n};\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (distance, angleRadians, origin = EmptyPoint) => {\n    guardPoint(origin);\n    return Object.freeze({\n        x: origin.x + distance * Math.cos(angleRadians),\n        y: origin.y + distance * Math.sin(angleRadians),\n    });\n};\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p, digits) => {\n    if (p === undefined)\n        return `(undefined)`;\n    if (p === null)\n        return `(null)`;\n    const angleDeg = radianToDegree(p.angleRadian);\n    const d = digits ? p.distance.toFixed(digits) : p.distance;\n    const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n    return `(${d},${a})`;\n};\nexport const toPoint = (v, origin = EmptyPoint) => {\n    guard(v, `v`);\n    return Object.freeze({\n        x: origin.x + v.distance * Math.cos(v.angleRadian),\n        y: origin.y + v.distance * Math.sin(v.angleRadian),\n    });\n};\n","export const isQuadraticBezier = (path) => path.quadratic !== undefined;\nexport const isCubicBezier = (path) => path.cubic1 !== undefined && path.cubic2 !== undefined;\n"],"mappings":"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"}