{"version":3,"file":"index-1oZyS9hM.d.ts","names":["LogOption","DriverOptions","Transitions","V","DriverStatesHandler","DriverExpressionOrResult","T","DriverResult","MachineState","StateNames","DriverRunner","Promise","TransitionResult","TransitionCondition","StateTargetStrict","StateTarget","TransitionsStrict","Record","Readonly","Machine","StateEvent","StateHandler","State","DriverOptions","DriverRunner","DriverStatesHandler","Machine","Transitions","driver","V","Promise","Machine","MachineState","StateNames","StateTarget","StateTargetStrict","Transitions","TransitionsStrict","cloneState","V","init","reset","validateMachine","isDone","possibleTargets","possible","normaliseTargets","to","next","isValidTransition","validateTransition","fromList","fromListBidirectional","SimpleEventEmitter","StateNames","Transitions","StateChangeEvent","V","StopEvent","StateMachineEventMap","StateMachineWithEventsOptions","StateMachineWithEvents"],"sources":["../../flow/dist/src/state-machine/types.d.ts","../../flow/dist/src/state-machine/driver.d.ts","../../flow/dist/src/state-machine/state-machine.d.ts","../../flow/dist/src/state-machine/with-events.d.ts","../../flow/dist/src/state-machine/index.d.ts"],"sourcesContent":["import type { LogOption } from \"@ixfx/debug\";\nexport type DriverOptions<V extends Transitions> = {\n    readonly handlers: readonly DriverStatesHandler<V>[];\n    readonly debug?: LogOption;\n    /**\n     * If _true_ execution of handlers is shuffled each time\n     */\n    readonly shuffleHandlers?: boolean;\n};\nexport type DriverExpressionOrResult<T extends Transitions> = DriverResult<T> | ((machine?: MachineState<T>) => DriverResult<T> | undefined | void);\nexport type DriverStatesHandler<V extends Transitions> = {\n    readonly if: readonly StateNames<V>[] | StateNames<V>[] | StateNames<V>;\n    readonly then: readonly DriverExpressionOrResult<V>[] | DriverExpressionOrResult<V>;\n    /**\n     * Logic for choosing which result, if there are multiple expressions.\n     * By default 'highest' (for highest ranked result)\n     */\n    readonly resultChoice?: `first` | `highest` | `lowest` | `random`;\n};\nexport type DriverRunner<V extends Transitions> = {\n    readonly run: () => Promise<MachineState<V> | undefined>;\n    readonly getValue: () => StateNames<V>;\n    readonly reset: () => void;\n    readonly to: (state: StateNames<V>) => MachineState<V>;\n};\nexport type DriverResult<V extends Transitions> = {\n    /**\n     * Score of this result. This is used when a state\n     * has multiple handlers returning results separately.\n     * If not defined, 0 is used.\n     */\n    readonly score?: number;\n    /**\n     * If specified,the state to transition to. Use\n     * _true_ to attempt to automatically advance machine.\n     * This field is 2nd priority.\n     */\n    readonly next?: StateNames<V> | boolean;\n    /**\n     * If true, resets the machine.\n     * This flag is 1st priority, taking precedence over the `next` field.\n     */\n    readonly reset?: boolean;\n};\n/**\n * Transition result\n * * 'Ok': transition valid\n * * 'FromNotFound': the from state is missing from machine definition\n * * 'ToNotFound': the 'to' state is missing from machine definition\n * * 'Invalid': not allowed to transition to target state from the current state\n * * 'Terminal':  not allowed to transition because from state is the final state\n */\nexport type TransitionResult = `Ok` | `FromNotFound` | `ToNotFound` | `Invalid` | `Terminal`;\nexport type TransitionCondition<V extends Transitions> = {\n    readonly hasPriorState: readonly StateNames<V>[];\n    readonly isInState: StateNames<V>;\n};\nexport type StateTargetStrict<V extends Transitions> = {\n    readonly state: StateNames<V> | null;\n    readonly preconditions?: readonly TransitionCondition<V>[];\n};\n/**\n * Possible state transitions, or _null_ if final state.\n */\nexport type StateTarget<V extends Transitions> = string | string[] | readonly string[] | null | StateTargetStrict<V>;\n/**\n * Maps state to allowable next states\n */\nexport type Transitions = {\n    readonly [key: string]: StateTarget<Transitions>;\n};\nexport type TransitionsStrict = Readonly<Record<string, readonly StateTargetStrict<Transitions>[]>>;\n/**\n * List of possible states\n */\nexport type StateNames<V extends Transitions> = keyof V & string;\nexport type Machine<V extends Transitions> = {\n    /**\n     * Allowable state transitions\n     */\n    readonly states: V;\n};\n/**\n * Encapsulation of a 'running' machine description and state.\n *\n * See:\n * - {@link cloneState}\n */\nexport type MachineState<V extends Transitions> = {\n    /**\n     * Current state\n     */\n    readonly value: StateNames<V>;\n    /**\n     * List of unique states visited. Won't contain the current\n     * state unless it has already been visited.\n     */\n    readonly visited: readonly StateNames<V>[];\n    /**\n     * Definition of state machine\n     */\n    readonly machine: Readonly<Record<StateNames<V>, readonly StateTargetStrict<V>[]>>;\n};\nexport type StateEvent = (args: unknown, sender: any) => void;\nexport type StateHandler = string | StateEvent | null;\nexport type State = Readonly<Record<string, StateHandler>>;\n//# sourceMappingURL=types.d.ts.map","import { type DriverOptions, type DriverRunner, type DriverStatesHandler, type Machine, type Transitions } from './types.js';\n/**\n * Drives a state machine.\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/driver/)\n *\n * Uses a 'handlers' structure to determine when to change\n * state and actions to take.\n *\n * The structure is a set of logical conditions: if we're in\n * this state, then move to this other state etc.\n *\n * ```js\n * const handlers = [\n *  {\n *    // If we're in the 'sleeping' state, move to next state\n *    if: 'sleeping',\n *    then: { next: true }\n *  },\n *  {\n *    // If we're in the 'waking' state, randomly either go to 'resting' or 'sleeping' state\n *    if: 'waking',\n *    then: [\n *      () => {\n *        if (Math.random() > 0.5) {\n *          return { next: 'resting' }\n *        } else {\n *          return { next: 'sleeping' }\n *        }\n *      }\n *    ]\n *   }\n * ];\n * ```\n *\n * Set up the driver, and call `run()` when you want to get\n * the machine to change state or take action:\n *\n * ```js\n * const driver = await StateMachine.driver(states, handlers);\n * setInterval(async () => {\n *  await driver.run(); // Note use of 'await' again\n * }, 1000);\n * ```\n *\n * Essentially, the 'handlers' structure gets run through each time `run()`\n * is called.\n *\n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\nexport declare function driver<V extends Transitions>(machine: Machine<V> | Transitions, handlersOrOpts: readonly DriverStatesHandler<V>[] | DriverOptions<V>): Promise<DriverRunner<V>>;\n//# sourceMappingURL=driver.d.ts.map","import type { Machine, MachineState, StateNames, StateTarget, StateTargetStrict, Transitions, TransitionsStrict } from './types.js';\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport declare const cloneState: <V extends Transitions>(toClone: MachineState<V>) => MachineState<V>;\n/**\n * Initialises a state machine. [Read more in the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n *\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n *\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n *\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n *\n * StateMachine.isDone(sm); // false\n * StateMachine.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport declare const init: <V extends Transitions>(stateMachine: Machine<V> | Transitions | TransitionsStrict, initialState?: StateNames<V>) => MachineState<V>;\nexport declare const reset: <V extends Transitions>(sm: MachineState<V>) => MachineState<V>;\nexport declare const validateMachine: <V extends Transitions>(smOrTransitions: Machine<V> | Transitions | TransitionsStrict) => [machine: Machine<V> | undefined, msg: string];\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport declare const isDone: <V extends Transitions>(sm: MachineState<V>) => boolean;\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport declare const possibleTargets: <V extends Transitions>(sm: MachineState<V>) => readonly StateTargetStrict<V>[];\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport declare const possible: <V extends Transitions>(sm: MachineState<V>) => (StateNames<V> | null)[];\nexport declare const normaliseTargets: <V extends Transitions>(targets: StateTarget<V> | readonly StateTargetStrict<V>[] | StateTargetStrict<V>) => StateTargetStrict<V>[] | null | undefined;\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n *\n * @example Attempts to transition to 'name-of-state'\n * ```js\n * const newState = StateMachine.to(currentState, `name-of-state`);\n * ```\n *\n * Note that 'currentState' is not changed.\n * @param sm\n * @param toState\n * @returns\n */\nexport declare const to: <V extends Transitions>(sm: MachineState<V>, toState: StateNames<V>) => MachineState<V>;\nexport declare const next: <V extends Transitions>(sm: MachineState<V>) => MachineState<V>;\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport declare const isValidTransition: <V extends Transitions>(sm: MachineState<V>, toState: StateNames<V>) => boolean;\nexport declare const validateTransition: <V extends Transitions>(sm: MachineState<V>, toState: StateNames<V>) => void;\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n *\n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport declare const fromList: (...states: readonly string[]) => Transitions;\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n *\n * See also {@link fromList}.\n *\n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport declare const fromListBidirectional: (...states: readonly string[]) => Transitions;\n//# sourceMappingURL=state-machine.d.ts.map","import { SimpleEventEmitter } from '@ixfx/events';\nimport type { StateNames, Transitions } from './types.js';\nexport type StateChangeEvent<V extends Transitions> = {\n    readonly newState: StateNames<V>;\n    readonly priorState: StateNames<V>;\n};\nexport type StopEvent<V extends Transitions> = {\n    readonly state: StateNames<V>;\n};\nexport type StateMachineEventMap<V extends Transitions> = {\n    readonly change: StateChangeEvent<V>;\n    readonly stop: StopEvent<V>;\n};\nexport type StateMachineWithEventsOptions<V extends Transitions> = {\n    readonly debug?: boolean;\n    readonly initial?: StateNames<V>;\n};\n/**\n * A state machine that fires events when state changes.\n *\n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport declare class StateMachineWithEvents<V extends Transitions> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n    #private;\n    /**\n     * Create a state machine with initial state, description and options\n     * @param m Machine description\n     * @param opts Options for machine (defaults to `{debug:false}`)\n     */\n    constructor(m: V, opts?: StateMachineWithEventsOptions<V>);\n    /**\n     * Return a list of possible states from current state.\n     *\n     * If list is empty, no states are possible. Otherwise lists\n     * possible states, including 'null' for terminal\n     */\n    get statesPossible(): readonly (StateNames<V> | null)[];\n    /**\n     * Return a list of all defined states\n     */\n    get statesDefined(): readonly StateNames<V>[];\n    /**\n     * Moves to the next state if possible. If multiple states are possible, it will use the first.\n     * If machine is finalised, no error is thrown and null is returned.\n     *\n     * @returns {(string|null)} Returns new state, or null if machine is finalised\n     */\n    next(): string | null;\n    /**\n     * Returns _true_ if state machine is in its final state\n     *\n     * @returns\n     */\n    get isDone(): boolean;\n    /**\n     * Resets machine to initial state\n     */\n    reset(): void;\n    /**\n     * Throws if it's not valid to transition to `newState`\n     * @param newState\n     * @returns\n     */\n    validateTransition(newState: StateNames<V>): void;\n    /**\n     * Returns _true_ if `newState` is valid transition from current state.\n     * Use {@link validateTransition} if you want an explanation for the _false_ results.\n     * @param newState\n     * @returns\n     */\n    isValid(newState: StateNames<V>): boolean;\n    /**\n     * Gets or sets state. Throws an error if an invalid transition is attempted.\n     * Use `isValid()` to check validity without changing.\n     *\n     * If `newState` is the same as current state, the request is ignored silently.\n     */\n    set state(newState: StateNames<V>);\n    get state(): string;\n    /**\n     * Returns timestamp when state was last changed.\n     * See also `elapsed`\n     */\n    get changedAt(): number;\n    /**\n     * Returns milliseconds elapsed since last state change.\n     * See also `changedAt`\n     */\n    get elapsed(): number;\n}\n//# sourceMappingURL=with-events.d.ts.map","export * from './driver.js';\nexport * from './state-machine.js';\nexport * from './with-events.js';\nexport type * from './types.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}