{"version":3,"file":"iterables-DUvYbSAZ.js","names":["fromArray","fromIterable","chunks","concat","dropWhile","until","repeat","equals","every","fill","filter","find","flatten","forEach","last","map","max","min","reduce","asCallback","slice","some","toArray","unique","uniqueByValue","zip","slice","reduce","uniqueByValue","asCallback","last","chunks","concat","dropWhile","until","equals","every","fill","forEach","filter","find","flatten","map","max","min","some","unique","zip","fromIterable","toArray","fromArray","min","max"],"sources":["../../packages/iterables/dist/src/guard.js","../../packages/iterables/dist/src/async.js","../../packages/iterables/dist/src/sync/slice.js","../../packages/iterables/dist/src/sync/reduce.js","../../packages/iterables/dist/src/sync.js","../../packages/iterables/dist/src/compare-values.js","../../packages/iterables/dist/src/from-event.js","../../packages/iterables/dist/src/numbers-compute.js","../../packages/iterables/dist/src/index.js","../src/iterables.ts"],"sourcesContent":["export const isAsyncIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.asyncIterator in v;\n};\nexport const isIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.iterator in v;\n};\n","import { intervalToMs, toStringDefault } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\nimport { isAsyncIterable, isIterable } from './guard.js';\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray(array, interval = 1) {\n    for (const v of array) {\n        yield v;\n        await sleep(interval);\n    }\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable(iterable, interval = 1) {\n    for await (const v of iterable) {\n        yield v;\n        await sleep(interval);\n    }\n}\nexport async function* chunks(it, size) {\n    // Source: https://surma.github.io/underdash/\n    let buffer = [];\n    for await (const v of it) {\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport async function* concat(...its) {\n    // Source: https://surma.github.io/underdash/\n    for await (const it of its)\n        yield* it;\n}\nexport async function* dropWhile(it, f) {\n    for await (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n *\n * In this version, we do a `for await of` over `gen`, and also `await callback()`.\n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n *\n * If you want the value from the generator, use a `for of` loop as usual.\n *\n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it, callback) => {\n    for await (const _ of it) {\n        const value = await callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n *\n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n *\n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n *\n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n *\n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator\n * @param repeatsOrSignal\n */\nexport const repeat = async function* (genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for await (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals(it1, it2, equality) {\n    // https://surma.github.io/underdash/\n    const iit1 = it1[Symbol.asyncIterator](); // it1[ Symbol.iterator ]();\n    const iit2 = it2[Symbol.asyncIterator]();\n    while (true) {\n        const index1 = await iit1.next();\n        const index2 = await iit2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport async function every(it, f) {\n    for await (const v of it) {\n        const result = await f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport async function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for await (const _ of it)\n        yield v;\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (!await f(v))\n            continue;\n        yield v;\n    }\n}\nexport async function find(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return v;\n    }\n}\nexport async function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isAsyncIterable(v)) {\n                for await (const vv of v) {\n                    yield vv;\n                }\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function (iterator, fn, options = {}) {\n    const interval = options.interval;\n    if (Array.isArray(iterator)) {\n        // Handle array\n        for (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n    else {\n        // Handle an async iterator\n        for await (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n};\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last(it, opts = {}) {\n    const abort = opts.abort;\n    let returnValue;\n    for await (const value of it) {\n        if (abort?.aborted)\n            return undefined;\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport async function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        yield f(v);\n    }\n}\nexport async function* max(it, gt = ((a, b) => a > b)) {\n    let max;\n    for await (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield (max);\n            continue;\n        }\n        // If V is bigger than max, we have a new max\n        if (gt(v, max)) {\n            max = v;\n            yield v;\n        }\n    }\n}\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n *\n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for await (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n            continue;\n        }\n        // If min is bigger than V, V is the new min\n        if (gt(min, v)) {\n            min = v;\n            yield v;\n        }\n    }\n    return min;\n}\nexport async function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for await (const v of it)\n        start = f(start, v);\n    return start;\n}\n/**\n * Calls `callback` whenever the async generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport async function asCallback(input, callback, onDone) {\n    for await (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\nexport async function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    console.log(`Async slice start: ${start}`);\n    // https://surma.github.io/underdash/\n    const iit = it[Symbol.asyncIterator]();\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    for (; start > 0; start--, end--)\n        await iit.next();\n    for await (const v of it) {\n        if (end-- > 0) {\n            yield v;\n        }\n        else {\n            break;\n        }\n    }\n}\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it\n * @param delay\n */\nexport async function* withDelay(it, delay) {\n    for (const v of it) {\n        await sleep(delay);\n        yield v;\n    }\n}\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout(it, options) {\n    const ms = intervalToMs(options, 1000);\n    const value = await Promise.race([\n        (async () => {\n            await sleep({ millis: ms, signal: options.signal });\n            return undefined;\n        })(),\n        (async () => {\n            return await it.next();\n        })()\n    ]);\n    if (value === undefined)\n        throw new Error(`Timeout`);\n    return value;\n}\nexport async function some(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return true;\n    }\n    return false;\n}\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray(it, options = {}) {\n    // https://2ality.com/2016/10/asynchronous-iteration.html\n    const result = [];\n    const iterator = it[Symbol.asyncIterator]();\n    const started = Date.now();\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const whileFunction = options.while;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        const r = await iterator.next();\n        if (r.done)\n            break;\n        //eslint-disable-next-line functional/immutable-data\n        result.push(r.value);\n    }\n    return result;\n}\nexport async function* unique(iterable) {\n    const buffer = [];\n    const itera = Array.isArray(iterable) ? iterable : [iterable];\n    for await (const it of itera) {\n        for await (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\nexport async function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for await (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.asyncIterator]());\n    while (true) {\n        const vs = await Promise.all(iits.map((it) => it.next()));\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\n","export function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    if (start < 0)\n        throw new Error(`Param 'start' should be at least 0`);\n    let index = 0;\n    for (const v of it) {\n        if (index < start) {\n            index++;\n            continue;\n        }\n        if (index > end) {\n            break;\n        }\n        yield v;\n        index++;\n    }\n}\n","export function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for (const v of it)\n        start = f(start, v);\n    return start;\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { isIterable } from './guard.js';\nexport { slice } from './sync/slice.js';\nexport { reduce } from './sync/reduce.js';\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    for (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(generator, defaultValue) {\n    return () => {\n        const v = generator.next().value;\n        if (v === undefined)\n            return defaultValue;\n        return v;\n    };\n}\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first(it) {\n    for (const value of it) {\n        return value;\n    }\n}\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last(it) {\n    let returnValue;\n    for (const value of it) {\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping(it, size) {\n    if (size <= 1)\n        throw new Error(`Size should be at least 2`);\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer = [buffer.at(-1)];\n        }\n    }\n    if (buffer.length <= 1)\n        return;\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* chunks(it, size) {\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* concat(...its) {\n    for (const it of its)\n        yield* it;\n}\nexport function* dropWhile(it, f) {\n    for (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it, callback) => {\n    for (const _ of it) {\n        const value = callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\nexport const next = (it) => {\n    return () => {\n        const r = it.next();\n        if (r.done)\n            return;\n        return r.value;\n    };\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    //it1 = it1[Symbol.iterator]();\n    //it2 = it2[Symbol.iterator]();\n    while (true) {\n        const index1 = it1.next(), index2 = it2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport function every(it, f) {\n    for (const v of it) {\n        const result = f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for (const _ of it)\n        yield v;\n}\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * import { Sync } from \"https://unpkg.com/ixfx/dist/iterables.js\"\n * Sync.forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * Sync.forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * Sync.forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEach} if you want to use an async `iterator` and async `fn`.\n *\n * Alternatives:\n * * {@link Flow.repeat}/{@link Flow.repeatSync}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam T Type of iterable's values\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport function forEach(iterator, fn) {\n    for (const v of iterator) {\n        const result = fn(v);\n        if (typeof result === `boolean` && !result)\n            break;\n    }\n}\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (!f(v))\n            continue;\n        yield v;\n    }\n}\nexport function find(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return v;\n    }\n}\nexport function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\nexport function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        yield f(v);\n    }\n}\nexport function* max(it, gt = (a, b) => a > b) {\n    let max;\n    for (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield max;\n            continue;\n        }\n        if (gt(v, max)) {\n            max = v;\n            yield max;\n        }\n    }\n    return max;\n}\nexport function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n        }\n        if (gt(min, v)) {\n            min = v;\n            yield min;\n        }\n    }\n}\nexport function some(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return true;\n    }\n    return false;\n}\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\nexport function* repeat(genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n}\nexport function* unique(iterable) {\n    // Adapted from https://surma.github.io/underdash/\n    const buffer = [];\n    let itera = [];\n    itera = Array.isArray(iterable) ? iterable : [iterable];\n    for (const it of itera) {\n        for (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.iterator]());\n    while (true) {\n        const vs = iits.map((it) => it.next());\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\nexport function* fromIterable(iterable) {\n    for (const v of iterable) {\n        yield v;\n    }\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    const result = [];\n    const started = Date.now();\n    const whileFunction = options.while;\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    for (const v of it) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        if (result.length >= maxItems)\n            break;\n        if (Date.now() - started > maxElapsed)\n            break;\n        result.push(v);\n    }\n    return result;\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray(array) {\n    for (const v of array) {\n        yield v;\n    }\n}\n","import { compareIterableValuesShallow, isEqualDefault } from \"@ixfx/core\";\n/**\n * Returns the 'max' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const maxScore = (iterable, scorer) => {\n    let highestValue;\n    let highestScore = Number.MIN_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score >= highestScore) {\n            highestScore = score;\n            highestValue = value;\n        }\n    }\n    return highestValue;\n};\n/**\n * Returns the 'min' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const minScore = (iterable, scorer) => {\n    let lowestValue;\n    let lowestScore = Number.MAX_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score <= lowestScore) {\n            lowestScore = score;\n            lowestValue = value;\n        }\n    }\n    return lowestValue;\n};\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n *\n * Is NOT recursive.\n *\n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * hasEqualValues(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * hasEqualValues(a, b);\n * // True, since now we're comparing by value\n * hasEqualValues(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param arrays\n * @param eq\n */\nexport const hasEqualValuesShallow = (iterableA, iterableB, eq) => {\n    const returnValue = compareIterableValuesShallow(iterableA, iterableB, eq);\n    return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n","export const fromEvent = (eventSource, eventType) => {\n    const pullQueue = [];\n    const pushQueue = [];\n    let done = false;\n    const pushValue = (args) => {\n        if (pullQueue.length > 0) {\n            //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const resolver = pullQueue.shift();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            resolver(...args);\n        }\n        else {\n            pushQueue.push(args);\n        }\n    };\n    const pullValue = () => new Promise((resolve) => {\n        if (pushQueue.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arguments_ = pushQueue.shift();\n            // @ts-expect-error\n            resolve(...arguments_);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const handler = (...arguments_) => {\n        pushValue(arguments_);\n    };\n    eventSource.addEventListener(eventType, handler);\n    const r = {\n        next: async () => {\n            if (done)\n                return { done: true, value: undefined };\n            return {\n                done: false,\n                value: await pullValue(),\n            };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        return: async () => {\n            done = true;\n            eventSource.removeEventListener(eventType, handler);\n            return { done: true, value: undefined };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        throw: async (error) => {\n            done = true;\n            return {\n                done: true,\n                value: Promise.reject(new Error(error)),\n            };\n        },\n    };\n    return r;\n};\n","import { numberArrayCompute } from \"@ixfx/numbers\";\nimport { isIterable } from \"./guard.js\";\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * const v = [ 10, 2, 4.2, 99 ];\n * const mma = numbersCompute(v);\n * // Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link Numbers.average}, {@link Numbers.max}, {@link Numbers.min} or {@link Numbers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * numbersCompute(count(5,1)); // Averages 1,2,3,4,5\n * ```\n *\n * Returns `NaN` if the input data is empty.\n * @param data\n * @param options Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const numbersCompute = (data, options = {}) => {\n    if (typeof data === `undefined`)\n        throw new Error(`Param 'data' is undefined`);\n    if (Array.isArray(data)) {\n        return numberArrayCompute(data, options);\n    }\n    if (isIterable(data)) {\n        return numbersComputeIterable(data, options);\n    }\n    throw new Error(`Param 'data' is neither an array nor iterable`);\n};\nfunction numbersComputeIterable(data, options = {}) {\n    // if (typeof options.startIndex !== `undefined` || typeof options.endIndex !== `undefined`) {\n    //   data = slice(data, options.startIndex, options.endIndex);\n    // }\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let v of data) {\n        if (typeof v !== `number` || Number.isNaN(v)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof v}'`);\n            if (nonNumbers === `nan`)\n                v = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += v;\n        count++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n    }\n    return {\n        avg: total / count,\n        total, max, min, count\n    };\n}\nexport function computeAverage(data, options = {}) {\n    let count = 0;\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    for (let d of data) {\n        if (typeof d !== `number` || Number.isNaN(d)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof d}'`);\n            if (nonNumbers === `nan`)\n                d = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += d;\n        count++;\n    }\n    return total / count;\n}\n","import * as Async from './async.js';\nimport * as Sync from './sync.js';\nexport * as Async from './async.js';\nexport * as Sync from './sync.js';\nexport * from './compare-values.js';\nexport * from './from-event.js';\nexport * from './guard.js';\nexport * from './types.js';\nimport { isAsyncIterable } from './guard.js';\n//import * as Chains from './chain/index.js';\n// import type { Interval } from '../flow/IntervalType.js';\nimport { toStringDefault } from '@ixfx/core';\nexport * from './numbers-compute.js';\n/**\n * Returns a stream of minimum values.\n *\n * Streaming result: works with endless iterables.\n *\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n *\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile(it, f) {\n    return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n*\n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it, callback) {\n    if (isAsyncIterable(it)) {\n        return Async.until(it, callback);\n    }\n    else {\n        // @ts-expect-error\n        Sync.until(it, callback);\n    }\n}\n/**\n * Breaks an iterable into array chunks\n *\n * Streaming: works with infinite iterables.\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks(it, size) {\n    return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter(it, f) {\n    return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f);\n}\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n *\n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill(it, v) {\n    return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n/**\n * Return concatenation of iterators.\n *\n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat(...its) {\n    return isAsyncIterable(its[0]) ? Async.concat(...its) : Sync.concat(...its);\n}\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find(it, f) {\n    return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f);\n}\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n *\n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach(it, fn, options = {}) {\n    if (isAsyncIterable(it)) {\n        return Async.forEach(it, fn, options);\n    }\n    else {\n        Sync.forEach(it, fn);\n    }\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map(it, f) {\n    return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray(array, interval) {\n    return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten(it) {\n    return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some(it, f) {\n    return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f);\n}\n/**\n * Returns the last item of an iterable, or _undefined_ if it yields no results.\n * @param it\n * @returns\n */\nexport function last(it) {\n    return isAsyncIterable(it) ? Async.last(it) : Sync.last(it);\n}\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce(it, f, start) {\n    return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n/**\n * Returns a section from an iterable.\n *\n * 'end' is the end index, not the number of items.\n *\n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, start, end);\n}\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique(iterable) {\n    if (Array.isArray(iterable)) {\n        if (iterable.length === 0)\n            return Sync.fromArray([]);\n        return isAsyncIterable(iterable[0]) ? Async.unique(iterable) : Sync.unique(iterable);\n    }\n    else if (isAsyncIterable(iterable)) {\n        return Async.unique(iterable);\n    }\n    else {\n        return Sync.unique(iterable);\n    }\n}\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n *\n * Streaming: Works with unbounded iterables.\n *\n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n *\n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n *\n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n *\n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n *\n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n *\n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input\n * @param seen\n * @param toString\n */\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    return isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n *\n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every(it, f) {\n    return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f);\n}\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n    return as ? Async.equals(it1, it2, equality) : Sync.equals(it1, it2, equality);\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip(...its) {\n    if (its.length === 0)\n        return Sync.fromArray([]);\n    return isAsyncIterable(its[0]) ? Async.zip(...its) : Sync.zip(...its);\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport function fromIterable(iterable, interval) {\n    if (isAsyncIterable(iterable) || interval !== undefined)\n        return Async.fromIterable(iterable, interval);\n    return Sync.fromIterable(iterable);\n}\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction(callback) {\n    while (true) {\n        const v = callback();\n        yield v;\n    }\n}\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback\n */\nexport async function* fromFunctionAwaited(callback) {\n    while (true) {\n        const v = await callback();\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    if (isAsyncIterable(input)) {\n        return Async.asCallback(input, callback);\n    }\n    else {\n        Sync.asCallback(input, callback);\n        return;\n    }\n}\n","export * from '@ixfx/iterables';"],"mappings":"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"}