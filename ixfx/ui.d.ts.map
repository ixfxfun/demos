{"version":3,"file":"ui.d.ts","names":["HslBase","ColourSpaces","HslScalar","HslAbsolute","Hsl","RgbBase","RgbScalar","Rgb8Bit","Rgb","LchBase","ColourInterpolator","Colour","T","OkLchBase","OkLchScalar","OkLchAbsolute","OkLch","Colourish","ColourInterpolationOpts","ColourStepOpts","ParsingOptions","Partial","IsEqual","Interval","IsEqualContext","CombineLatestOptions","InitLazyStreamOptions","Lazy","UpstreamOptions","TriggerValue","TTriggerValue","CountOptions","AbortSignal","FunctionFunction","T","Promise","ArrayOptions","PingedFunctionFunction","TSource","TriggerFunction","TriggerGenerator","IterableIterator","Trigger","TimeoutPingOptions","TimeoutValueOptions","ObjectOptions","Record","V","ValueToPingOptions","TUpstream","PingedFunctionOptions","ArrayObjectOptions","FunctionOptions","Partial","GeneratorOptions","EventSourceOptions","EventSourceTriggerOptions","EventPluckedFieldOptions","EventPluckedFieldOptions2","TValueDestination","TDomSource","DerivedFunction","TOutput","DerivedOptions","TResult","Interval","Primitive","ChunkOptions","DebounceOptions","FieldOptions","FilterPredicate","SplitOptions","SyncOptions","SwitcherOptions","TransformOpts","ThrottleOptions","OpMathOptions","TimeoutPingOptions","TimeoutValueOptions","SetHtmlOptions","Processors","TallyOptions","ChangeRecord","RecursivePartial","Pathed","CombineLatestOptions","Optional","T","Partial","K","Pick","Omit","symbol","SignalKinds","Passed","V","PassedSignal","PassedValue","UpstreamOptions","Lazy","In","UpstreamInitialOptions","Wrapped","TIn","Reactive","TAnnotation","TOut","ReactiveOp","TSource","TFieldType","InitStreamOptions","ReactiveOrSource","RxValueTypes","Record","RxValueTypeObject","TRec","TLabel","T2","T3","T4","T5","T6","ReactiveWritable","TTriggerValue","ToArrayOptions","Promise","InitLazyStreamOptions","InitLazyStreamInitedOptions","IterableIterator","AsyncIterableIterator","Generator","AsyncGenerator","Unsubscriber","ReactivePingable","ReactiveNonInitial","ReactiveInitial","ReactiveFinite","ReactiveArray","ObjectFieldHandler","ReactiveDiff","PathDataChange","ReactiveStream","ReactiveInitialStream","PipeSet","WithValueOptions","ResolveOptions","ReactiveOpInit","TOpts","ReactiveOpLinks","Out","RxValueTypeObjectOrUndefined","RxValueTypeRx","PrimitiveValueTypeObject"],"sources":["../../visual/dist/src/colour/types.d.ts","../../rx/dist/src/from/types.d.ts","../../rx/dist/src/types.d.ts","../../ui/src/rx/browser-resize.ts","../../ui/src/rx/browser-theme-change.ts","../../ui/src/rx/colour.ts","../../ui/src/rx/dom-types.ts","../../ui/src/rx/dom-source.ts","../../ui/src/rx/dom.ts","../../ui/src/rx/index.ts"],"sourcesContent":["export type HslBase = {\n    /**\n     * Hue\n     */\n    h: number;\n    /**\n     * Saturation\n     */\n    s: number;\n    /**\n     * Lightness\n     */\n    l: number;\n    /**\n     * Opacity\n     */\n    opacity?: number;\n    space?: `hsl`;\n};\nexport type ColourSpaces = `srgb` | `hsl` | `oklch`;\n/**\n * Scalar values use 0..1 for each field\n */\nexport type HslScalar = HslBase & {\n    unit: `scalar`;\n};\n/**\n * Absolute values use hue:0..360, all other fields 0..100\n */\nexport type HslAbsolute = HslBase & {\n    unit: `absolute`;\n};\n/**\n * HSL value.\n * By default assumes scalar coordinates (0..1) for each field.\n * Use 'absolute' unit for hue:0...360, all other fields on 0..100 scale.\n */\nexport type Hsl = HslScalar | HslAbsolute;\n/**\n * Rgb.\n * Units determine how to interperet rgb values.\n * * 'scalar': 0..1 range for RGB & opacity\n * * '8bit': 0..255 range for RGB & opacity\n */\nexport type RgbBase = {\n    r: number;\n    g: number;\n    b: number;\n    opacity?: number;\n    space?: `srgb`;\n};\nexport type RgbScalar = RgbBase & {\n    unit: `scalar`;\n};\n/**\n * RGB in 0...255 range, including opacity.\n */\nexport type Rgb8Bit = RgbBase & {\n    unit: `8bit`;\n};\n/**\n * Rgb.\n * Units determine how to interperet rgb values.\n * * 'scalar': 0..1 range for RGB & opacity\n * * '8bit': 0..255 range for RGB & opacity\n */\nexport type Rgb = RgbScalar | Rgb8Bit;\nexport type LchBase = {\n    /**\n     * Lightness/perceived brightnes\n     */\n    l: number;\n    /**\n     * Chroma ('amount of colour')\n     */\n    c: number;\n    /**\n     * Hue\n     */\n    h: number;\n    /**\n     * Opacity on 0..1 scale\n     */\n    opacity?: number;\n    space: `lch` | `oklch`;\n};\nexport type ColourInterpolator<T extends Colour> = (amount: number) => T;\nexport type OkLchBase = LchBase & {\n    space: `oklch`;\n};\n/**\n * Oklch colour expressed in 0..1 scalar values for LCH & opacity\n */\nexport type OkLchScalar = OkLchBase & {\n    unit: `scalar`;\n};\n/**\n * Oklch colour expressed with:\n * l: 0..1\n * c: 0..4\n * h: 0..360 degrees\n * opacity: 0..1\n */\nexport type OkLchAbsolute = OkLchBase & {\n    unit: `absolute`;\n};\nexport type OkLch = OkLchAbsolute | OkLchScalar;\nexport type Colour = {\n    opacity?: number;\n} & (Hsl | OkLch | Rgb);\n/**\n * A representation of colour. Eg: `blue`, `rgb(255,0,0)`, `hsl(20,100%,50%)`\n */\nexport type Colourish = Colour | string;\n/**\n * Options for interpolation\n */\nexport type ColourInterpolationOpts = {\n    direction: `longer` | `shorter`;\n    space: ColourSpaces;\n};\nexport type ColourStepOpts = ColourInterpolationOpts & {\n    /**\n     * If set, determines total number of steps, including colour stops.\n     * Use this _or_ `stepsBetween`.\n     */\n    stepsTotal?: number;\n    /**\n     * If set, determines number of steps between colour stops.\n     * Use this _or_ `stepsTotal`.\n     */\n    stepsBetween?: number;\n};\nexport type ParsingOptions<T> = Partial<{\n    scalar: boolean;\n    ensureSafe: boolean;\n    /**\n     * Value to use if input is invalid\n     */\n    fallbackString: string;\n    /**\n     * Fallback colour to use if value cannot be parsed\n     */\n    fallbackColour: T;\n}>;\n//# sourceMappingURL=types.d.ts.map","import type { IsEqual, Interval, IsEqualContext } from \"@ixfx/core\";\nimport type { CombineLatestOptions, InitLazyStreamOptions, Lazy, UpstreamOptions } from '../types.js';\nexport type TriggerValue<TTriggerValue> = {\n    value: TTriggerValue;\n};\n/**\n * Options for the 'count' source.\n */\nexport type CountOptions = {\n    /**\n     * Determines when counting starts\n     * @defaultValue 'initial'\n     */\n    lazy: Lazy;\n    /**\n     * Amount to increment by\n     * @defaultValue 1\n     */\n    amount: number;\n    /**\n     * Where to begin counting\n     * @defaultValue 0\n     */\n    offset: number;\n    /**\n     * How long to wait before incrementing.\n     * @defaultValue 1 second\n     */\n    interval: Interval;\n    /**\n     * Abort signal to trigger the source to close.\n     */\n    signal: AbortSignal;\n};\n/**\n * Function which returns a result. Or promised result.\n *\n * `abort` value is a callback to exit out of looped execution.\n */\nexport type FunctionFunction<T> = ((abort: (reason: string) => void) => T) | ((abort: (reason: string) => void) => Promise<T>);\nexport type ArrayOptions = {\n    /**\n     * Interval between each item being read. Default: 5ms.\n     */\n    interval: Interval;\n    lazy: Lazy;\n    /**\n     * Behaviour when reactive stops, for example due to having no subscribers\n     * * continue: iteration continues through array where it left off\n     * * reset: iteration begins from start of array\n     */\n    whenStopped: `continue` | `reset`;\n    debugLifecycle: boolean;\n    signal: AbortSignal;\n};\n/**\n * Function which returns a result. Or promised result.\n * Takes a `value` as first parameter, and callback to signal an abort as the second.\n */\nexport type PingedFunctionFunction<T, TSource> = ((value: TSource, abort: (reason: string) => void) => T) | ((value: TSource, abort: (reason: string) => void) => Promise<T>);\n/**\n * Trigger that calls a `fn`.\n * If `fn` returns _undefined_, it means the trigger is complete\n */\nexport type TriggerFunction<TTriggerValue> = {\n    fn: () => TTriggerValue;\n};\nexport type TriggerGenerator<TTriggerValue> = {\n    gen: IterableIterator<TTriggerValue>;\n};\n/**\n * A trigger can be a value, a function or generator. Value triggers never complete.\n *\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n */\nexport type Trigger<TTriggerValue> = TriggerValue<TTriggerValue> | TriggerFunction<TTriggerValue> | TriggerGenerator<TTriggerValue>;\nexport type TimeoutPingOptions = Interval & {\n    /**\n     * If abort signals, it will disable\n     */\n    abort?: AbortSignal;\n};\nexport type TimeoutValueOptions<TTriggerValue> = Trigger<TTriggerValue> & {\n    /**\n     * Whether to repeatedly trigger even if upstream source doesn't emit values.\n     * When _false_ (default) it will emit a max of one value after a source value if `interval` is reached.\n     * When _true_, it will continue emitting values at `interval`.\n     * Default: false\n     */\n    repeat?: boolean;\n    /**\n     * Interval before emitting trigger value\n     * Default: 1s\n     */\n    interval: Interval;\n    /**\n     * If _true_ (default) start the timeout\n     * immediately, even before the first value.\n     * If _false_, it won't timeout until the first\n     * upstream value happens.\n     */\n    immediate?: boolean;\n};\n/**\n * Options when creating a reactive object.\n */\nexport type ObjectOptions<V extends Record<string, unknown>> = {\n    /**\n     * _false_ by default.\n     * If _true_, inherited fields are included. This is necessary for event args, for example.\n     */\n    deepEntries: boolean;\n    /**\n     * Uses JSON.stringify() by default.\n     * Fn that returns _true_ if two values are equal, given a certain path.\n     */\n    eq: IsEqualContext<V>;\n};\nexport type ValueToPingOptions<TUpstream> = {\n    /**\n     * If set, this function acts as a threshold gate.\n     * If the function returns _true_ the upstream value will trigger a ping\n     * Otherwise the value won't trigger a ping.\n     *\n     * By default all values trigger a ping.\n     * @param value\n     * @returns\n     */\n    gate: (value: TUpstream) => boolean;\n    /**\n     * Laziness\n     * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n     * * very: only begins on first subscriber. Stops looping if there are no subscribers\n     * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n     */\n    lazy: Lazy;\n    /**\n      * If specified, signal is checked to prevent function execution.\n      * Also used for aborting a looped fromFunction.\n    */\n    signal: AbortSignal;\n};\nexport type PingedFunctionOptions = {\n    /**\n     * If _true_, stream closes if function throws an error.\n     * If _false_, errors are emitted as signals, but stream is not closed.\n     * Default: _true_\n     */\n    closeOnError: boolean;\n    /**\n     * Laziness\n     * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n     * * very: only begins on first subscriber. Stops looping if there are no subscribers\n     * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n     */\n    lazy: Lazy;\n    /**\n      * If specified, a time before invoking function.\n      * If `repeat` is used, this is in addition to `interval` time.\n      */\n    predelay: Interval;\n    /***\n  * If specified, signal is checked to prevent function execution.\n  * Also used for aborting a looped fromFunction.\n  */\n    signal: AbortSignal;\n};\n/**\n * Options when creating a reactive object.\n */\nexport type ArrayObjectOptions<V> = {\n    /**\n     * Uses JSON.stringify() by default.\n     * Fn that returns _true_ if two values are equal, given a certain path.\n     */\n    eq: IsEqual<V>;\n};\nexport type FunctionOptions = Partial<InitLazyStreamOptions> & {\n    /**\n     * If _true_, stream closes if function throws an error.\n     * If _false_, errors are emitted as signals, but stream is not closed.\n     * Default: _true_\n     */\n    closeOnError: boolean;\n    /**\n     * Laziness\n     * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n     * * very: only begins on first subscriber. Stops looping if there are no subscribers\n     * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n     */\n    lazy: Lazy;\n    /**\n     * If _true_, no automatic calling of function will happen, it will only\n     * be executed if the reactive gets a ping\n     * When this is set, 'interval' is ignored. 'maximumRepeats' and 'predelay' still apply.\n     * Default: _false_\n    */\n    manual: boolean;\n    /**\n     * If specified, sets an upper limit of how many times we loop\n     * (if this is also enabled)\n     */\n    maximumRepeats: number;\n    /**\n     * If specified, function is called repeatedly with this delay\n     */\n    interval: Interval;\n    /**\n     * If specified, a time before invoking function.\n     * If `repeat` is used, this is in addition to `interval` time.\n     */\n    predelay: Interval;\n    /***\n     * If specified, signal is checked to prevent function execution.\n     * Also used for aborting a looped fromFunction.\n     */\n    signal: AbortSignal;\n};\nexport type GeneratorOptions = {\n    traceLifecycle: boolean;\n    /**\n     * Wait between reading from generator\n     * Default: 5ms\n     */\n    readInterval: Interval;\n    /**\n     * Timeout when waiting for a value\n     * Default: `{ mins: 5 }`\n     */\n    readTimeout: Interval;\n    /**\n     * If _true_, only accesses the generator if there is a subscriber.\n     * Default: true\n     */\n    lazy: Lazy;\n    signal: AbortSignal;\n    /**\n     * Behaviour when reactive stops, for example due to having no subscribers\n     * * continue: iteration continues through array where it left off\n     * * reset: iteration begins from start of array\n     */\n    whenStopped: `continue` | `reset`;\n};\nexport type EventSourceOptions = {\n    /**\n     * If true, behaves like Source.object where event\n     * properties are compared and source only\n     * emits where there is a change.\n     *\n     * Default: _false_\n     */\n    diff?: boolean;\n    lazy?: Lazy;\n    /**\n     * If true, log messages are emitted\n     * when event handlers are added/removed\n     */\n    debugLifecycle?: boolean;\n    /**\n     * If true, log messages are emitted\n     * when the source event fires\n     */\n    debugFiring?: boolean;\n};\nexport type EventSourceTriggerOptions = EventSourceOptions & {\n    /**\n     * If _true_ sends an initial trigger when starting\n     * Default: false\n     */\n    fireInitial: boolean;\n};\nexport type EventPluckedFieldOptions<T> = {\n    lazy?: Lazy;\n    initialValue: T;\n};\nexport type EventPluckedFieldOptions2<TDomSource, TValueDestination> = {\n    lazy?: Lazy;\n    initialValue: TValueDestination;\n    domToValue: (value: TDomSource | undefined) => TValueDestination | undefined;\n    valueToDom: (value: TValueDestination) => TDomSource;\n};\nexport type DerivedFunction<TOutput> = (...args: unknown[]) => TOutput;\nexport type DerivedOptions<TResult, T> = {\n    ignoreIdentical: boolean;\n    eq: (a: TResult, b: TResult) => boolean;\n} & CombineLatestOptions & UpstreamOptions<T>;\n//# sourceMappingURL=types.d.ts.map","import type { Interval, Primitive } from '@ixfx/core';\nimport type { ChunkOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/types.js';\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './from/types.js';\nimport type { SetHtmlOptions } from './sinks/dom.js';\nimport type { Processors } from '@ixfx/process';\nimport type { TallyOptions } from './ops/math.js';\nimport type { ChangeRecord } from '@ixfx/core/records';\nimport type { RecursivePartial } from '@ixfx/core';\nimport { Pathed } from '@ixfx/core';\nexport type CombineLatestOptions = {\n    /**\n     * If _true_, disposes all the merged sources when the merged reactive closes.\n     * Default: _true_.\n     */\n    disposeSources: boolean;\n    /**\n     * How to handle when a source ends.\n     * * 'allow': continue combined stream, last value for done stream will kept\n     * * 'break': stop combined stream\n     *\n     * Default: 'break'\n     */\n    onSourceDone: `allow` | `break`;\n    /**\n     * If _true_ (default), emits a value when initialised.\n     */\n    emitInitial: boolean;\n};\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\nexport declare const symbol: unique symbol;\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n    value: V | undefined;\n    signal?: SignalKinds;\n    context?: string;\n};\nexport type PassedSignal = Passed<any> & {\n    value: undefined;\n    signal: SignalKinds;\n    context: string;\n};\nexport type PassedValue<V> = Passed<V> & {\n    value: V;\n};\nexport type UpstreamOptions<In> = {\n    lazy: Lazy;\n    /**\n     * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n     */\n    disposeIfSourceDone: boolean;\n    onValue: (v: In) => void;\n    /**\n     * Called just before we subscribe to source\n     * @returns\n     */\n    onStart: () => void;\n    /**\n     * Called after we unsubscribe from source\n     * @returns\n     */\n    onStop: () => void;\n    debugLabel: string;\n    onDispose: (reason: string) => void;\n};\nexport type UpstreamInitialOptions<In> = UpstreamOptions<In> & {\n    initialValue: In;\n};\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n    enacts: {\n        setHtmlText: (options: SetHtmlOptions) => () => void;\n    };\n    source: Reactive<TIn>;\n    /**\n     * Annotate values with output from the `annotation` function.\n     * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n     * @param transformer\n     * @returns\n     */\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{\n        value: TIn;\n        annotation: TAnnotation;\n    }>;\n    annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>) => Wrapped<{\n        value: TIn;\n        annotation: TOut;\n    }>;\n    /**\n    * Accumulate a chunk of values, emitted as an array\n    * @param options\n    * @returns\n    */\n    chunk: (options: Partial<ChunkOptions>) => Wrapped<TIn[]>;\n    debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>;\n    /**\n     * Pluck and emit a single field from values\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>;\n    /**\n     * Throws away values that don't match `predicate`\n     * @param predicate\n     * @param options\n     * @returns\n     */\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>;\n    combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>;\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: {\n        name: string;\n    } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>;\n    min: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    max: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    average: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    sum: (options?: Partial<OpMathOptions>) => Wrapped<number>;\n    tally: (options?: Partial<TallyOptions>) => Wrapped<number>;\n    /**\n     * Converts one source stream into two, with values being emitted by both\n     * @param options\n     * @returns\n     */\n    split: (options?: Partial<SplitOptions>) => Wrapped<TIn>[];\n    /**\n   * Emits values when this stream and any additional streams produce a value. The resulting stream is\n   * thus an array of values, each source at a given index.\n   * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n   * the slowest stream.\n   * @returns\n   */\n    syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[TIn, ...RxValueTypes<T>]>;\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: {\n        name?: string;\n    } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>;\n    /**\n     * Creates new streams for each case, sending values to the stream if they match the filter predicate\n     * @param cases\n     * @param options\n     * @returns\n     */\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>;\n    /**\n     * Creates new streams for each case\n     * @param labels\n     * @returns\n     */\n    splitLabelled: <K extends keyof TIn>(...labels: K[]) => Record<K, Wrapped<TIn>>;\n    /**\n     * Taps the stream, passing values to one or more 'processor' functions.\n     * This processing essentially happens in parallel, not affecting the main stream.\n     *\n     * ```js\n     * // Stream of pointermove events with {x:0,y:0} as default\n     * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n     * // Wrap it for fluent access\n     * const ptr = Rx.wrap(move)\n     *  .tapProcess(\n     *    // Create a string representation\n     *    v => `${v.x},${v.y}`\n     *    // Set to DOM\n     *    v => {\n     *      document.getElementById(`coords`).innerText = v;\n     *    }\n     *   )\n     *  .onValue(value => {\n     *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n     *    // not affecting stream\n     *  });\n     * ```\n     * @param processors One-five processing functions\n     * @returns\n     */\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>;\n    tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>;\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<TIn, TOut>[]) => Wrapped<TIn>;\n    /**\n     * Transforms all values\n     * @param transformer\n     * @param options\n     * @returns\n     */\n    transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>;\n    /**\n     * Only allow values through if a minimum of time has elapsed. Throws away values.\n     * Ie. converts a fast stream into a slower one.\n     * @param options\n     * @returns\n     */\n    throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>;\n    /**\n     * Emits a value if `source` does not emit a value after `interval`\n     * has elapsed. This can be useful to reset a reactive to some\n     * 'zero' state if nothing is going on.\n     *\n     * If `source` emits faster than the `interval`, it won't get triggered.\n     *\n     * Default for 'timeout': 1000s.\n     *\n     * ```js\n     * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n     * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n     * ```\n     *\n     * Can also emit results from a function or generator\n     * ```js\n     * // Emits a random number if 'source' doesn't emit a value after 500ms\n     * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n     * ```\n     *\n     * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n     * Otherwise it won't start until it observes the first value from `source`.\n     * @param options\n     */\n    timeoutValue: <TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>;\n    /**\n     * 'Pings' reactive (if it supports it) if a value is not received within a given interval.\n     * Behaviour can be stopped using an abort signal.\n     * @param options\n     * @returns\n     */\n    timeoutPing: (options: TimeoutPingOptions) => Wrapped<TIn>;\n    /**\n     * Copies values from source into an array, throwing\n     * an error if expected number of items is not reached\n     * @param options\n     * @returns\n     */\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<TIn[]>;\n    /**\n     * Copies values from source into an array.\n     * @param options\n     * @returns\n     */\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<(TIn | undefined)[]>;\n    /**\n     * Listen for values\n     * @param callback\n     * @returns\n     */\n    onValue: (callback: (value: TIn) => void) => void;\n};\nexport type ToArrayOptions<V> = {\n    /**\n     * Maximim time to wait for `limit` to be reached. 10s by default.\n     */\n    maximumWait: Interval;\n    /**\n     * Number of items to read\n     */\n    limit: number;\n    /**\n     * Behaviour if threshold is not reached.\n     * partial: return partial results\n     * throw: throw an error\n     * fill: fill remaining array slots with `fillValue`\n     */\n    underThreshold: `partial` | `throw` | `fill`;\n    /**\n     * Value to fill empty slots with if `underThreshold = 'fill'`.\n     */\n    fillValue: V;\n};\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`;\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n    lazy?: Lazy;\n    debugLabel?: string;\n    onStart: () => void;\n    onStop: () => void;\n};\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n    initialValue: T;\n};\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | V[] | (() => V);\n/**\n * A Reactive\n */\nexport type Reactive<V> = {\n    /**\n     * Subscribes to a reactive. Receives\n     * data as well as signals. Use `onValue` if you\n     * just care about values.\n     *\n     * Return result unsubscribes.\n     *\n     * ```js\n     * const unsub = someReactive.on(msg => {\n     *    // Do something with msg.value\n     * });\n     *\n     * unsub(); // Unsubscribe\n     * ```\n     * @param handler\n     */\n    on(handler: (value: Passed<V>) => void): Unsubscriber;\n    /**\n     * Subscribes to a reactive's values.\n     * Returns a function that unsubscribes.\n     * @param handler\n     */\n    onValue(handler: (value: V) => void): Unsubscriber;\n    /**\n     * Disposes the reactive, providing a reason for debug tracing\n     * @param reason\n     */\n    dispose(reason: string): void;\n    /**\n     * Returns _true_ if Reactive is disposed\n     */\n    isDisposed(): boolean;\n    /**\n     * Optional 'set' to write a value. Use {@link ReactiveWritable} if you want this non-optional\n     * @param value\n     */\n    set?(value: V): void;\n};\n/**\n * A reactive that can be 'pinged' to produce a value.\n *\n * Use {@link isPingable} to check if a reactive is pingable.\n *\n * Pingable reactives are returned from\n * * interpolate\n * * computeWithPrevious\n * * valueToPing\n */\nexport type ReactivePingable<V> = Reactive<V> & {\n    ping(): void;\n};\nexport type Unsubscriber = () => void;\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n    last(): V | undefined;\n};\n/**\n * A stream that can be written to\n */\nexport type ReactiveWritable<TIn, TOut = TIn> = Reactive<TOut> & {\n    /**\n     * Sets a value\n     * @param value Value to write\n     */\n    set(value: TIn): void;\n};\nexport type ReactiveInitial<V> = Reactive<V> & {\n    last(): V;\n};\nexport type ReactiveFinite = {\n    isDone(): boolean;\n};\nexport type ReactiveArray<V> = ReactiveWritable<V[]> & {\n    push(value: V): void;\n    deleteAt(index: number): void;\n    deleteWhere(filter: (value: V) => boolean): number;\n    setAt(index: number, value: V): void;\n    insertAt(index: number, value: V): void;\n    onArray(handler: (changes: Passed<ChangeRecord<number>[]>) => void): () => void;\n};\nexport type ObjectFieldHandler = {\n    value: any;\n    fieldName: string;\n    pattern: string;\n};\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n    /**\n     * Notifies when the value of `fieldName` is changed.\n     *\n     * Use the returned function to unsubscribe.\n     * @param fieldName\n     * @param handler\n     */\n    onField(fieldName: string, handler: (result: ObjectFieldHandler) => void): () => void;\n    /**\n     * Notifies of which field(s) were changed.\n     * If you just care about the whole, changed data use the `value` event.\n     *\n     * Use the returned function to unsubscribe.\n     * @param changes\n     */\n    onDiff(changes: (changes: Pathed.PathDataChange<any>[]) => void): () => void;\n    /**\n     * Updates the reactive with some partial key-value pairs.\n     * Keys omitted are left the same as the current value.\n     * @param changedPart\n     * @returns Returns new value\n     */\n    update(changedPart: RecursivePartial<V>): V;\n    /**\n     * Updates a particular field by its path\n     * @param field\n     * @param value\n     */\n    updateField(field: string, value: any): void;\n};\n/**\n * A reactive stream which can be read and written to\n */\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n    /**\n     * Removes all the subscribers from this stream.\n     */\n    removeAllSubscribers(): void;\n    /**\n     * Dispatches a signal\n     * @param signal\n     * @param context\n     */\n    signal(signal: SignalKinds, context?: string): void;\n};\nexport type ReactiveInitialStream<V> = ReactiveStream<V> & ReactiveInitial<V>;\nexport type PipeSet<In, Out> = [\n    Reactive<In>,\n    ...(Reactive<any> & ReactiveWritable<any>)[]\n];\nexport type InitStreamOptions = {\n    /**\n     * Optional label to associate with this stream. Useful for debugging.\n     */\n    debugLabel: string;\n    /**\n     * Called when there is a subscriber after there were no subscribers.\n     * Useful for 'startup' types of things that we want to run only when someone is actually listening.\n     *\n     * During the lifeycle of a stream, this could be called multiple times. Eg if all subscribers are removed\n     * next time someone subscribes it will get called again.\n     * @returns\n     */\n    onFirstSubscribe: () => void;\n    /**\n     * Called when there are no longer any subscribers. Useful for shutting down\n     * activities now that no-one is listening.\n     *\n     * During the lifecycle of a stream, this could be called multiple times.\n     * @returns\n     */\n    onNoSubscribers: () => void;\n    /**\n     * Called whenever the stream disposes. Useful for cleaning up.\n     * @param reason\n     * @returns\n     */\n    onDispose: (reason: string) => void;\n};\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n    /**\n     * Initial value\n     */\n    initial: V;\n    /**\n     * Laziness\n     */\n    lazy?: Lazy;\n};\nexport type ResolveOptions = {\n    /**\n     * How many times to return value or call function.\n     * If _infinite_ is set to true, this value is ignored\n     */\n    loops: number;\n    /**\n     * If _true_ loops forever\n     */\n    infinite: boolean;\n    /**\n     * Delay before value\n     */\n    interval: Interval;\n    lazy: Lazy;\n};\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>;\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>;\nexport type ReactiveOpLinks<In, Out> = [\n    ReactiveOrSource<In>,\n    ...ReactiveOp<any, any>[],\n    ReactiveOp<any, Out>\n];\nexport type RxValueTypes<T extends readonly ReactiveOrSource<any>[]> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? V | undefined : T[K] extends Wrapped<infer V> ? V | undefined : T[K] extends Generator<infer V> ? V | undefined : T[K] extends AsyncGenerator<infer V> ? V | undefined : T[K] extends IterableIterator<infer V> ? V | undefined : T[K] extends AsyncIterableIterator<infer V> ? V | undefined : T[K] extends (infer V)[] ? V | undefined : never;\n};\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? V : T[K] extends Wrapped<infer V> ? V : T[K] extends Generator<infer V> ? V : T[K] extends AsyncGenerator<infer V> ? V : T[K] extends IterableIterator<infer V> ? V : T[K] extends AsyncIterableIterator<infer V> ? V : T[K] extends (infer V)[] ? V : never;\n};\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? V | undefined : T[K] extends Wrapped<infer V> ? V | undefined : T[K] extends Generator<infer V> ? V | undefined : T[K] extends AsyncGenerator<infer V> ? V | undefined : T[K] extends IterableIterator<infer V> ? V | undefined : T[K] extends AsyncIterableIterator<infer V> ? V | undefined : T[K] extends (infer V)[] ? V | undefined : never;\n};\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> = {\n    [K in keyof T]: T[K] extends Reactive<infer V> ? Reactive<V> : T[K] extends Wrapped<infer V> ? Reactive<V> : T[K] extends Generator<infer V> ? Reactive<V> : T[K] extends AsyncGenerator<infer V> ? Reactive<V> : T[K] extends IterableIterator<infer V> ? Reactive<V> : T[K] extends AsyncIterableIterator<infer V> ? Reactive<V> : T[K] extends (infer V)[] ? Reactive<V> : never;\n};\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> = {\n    [K in keyof T]: T[K] extends number ? number | undefined : T[K] extends string ? string | undefined : T[K] extends boolean ? boolean | undefined : T[K] extends bigint ? bigint | undefined : never;\n};\n//# sourceMappingURL=types.d.ts.map"],"mappings":"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"}