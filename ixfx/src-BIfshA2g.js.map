{"version":3,"file":"src-BIfshA2g.js","names":["#capacity","#pointer","value","mutable","peek","isEmpty","isFull","peek","isEmpty","isFull","mutable","toString","compare","treeCompare","asDynamicTraversable","value","n","hasParent","hasAnyParent","hasChild","hasAnyChild","addValue","add","depthFirst","breadthFirst","root","children","parents","findChildByValue","findAnyChildByValue","entries","childrenLength","toStringDeep","followValue","entries","toStringDeep","value","isPrimitive","depthFirst","create","create","root","add","value","prettyPrint","remove","childrenLength","getRoot","value","root","entries","children","TreeNodeToTraversable","ObjectToTraversable","isEmpty","isFull","peek","immutable","mutable","value","map","immutable","#depth","#maxDepth","set","value","#getChild","#dumpToArray","create","priority","item","IterablesLast","IterablesMax","IterablesMin","#data","immutable","create","#maintain","value","entries","key","existing","map","value","value","entries","value","without","del","entries","map","value","value","data","value","#map","set","value","map","mapAddValue","mapFindValue","mapFilterValues","mapToArray","value","mapHasAnyValue","value","value","value","entries","value","value","#getRowRaw","#getOrCreateRawRow","#getColumnRaw","createVertex","graph","toAdjacencyMatrix","dumpGraph","debugGraphToArray","vertices","adjacentVertices","resolveVertex","getOrCreate","updateGraphVertex","to","connectTo","connect","connectWithEdges","edges","stringForEdge","immutableMap","graph","edges","immutableMap","resolve","timeout","resolve","#handlers","#counter","wrap","#id","value","timeout","resolve","distance","#data","#lastUsersChange","#resourcesWithoutUserExpireAfterMs","#capacityPerResource","#users","#state","r","#allocateResource","resolve","#maintainLoop","#maintain","#outgoing","#requestCallback","#requestAwait","resolve","value","run","#resolve","#promise","#reject","resolve","#initPromise","value","resolve","#promise","#resolve","resolve","value","#written","debug","machineInit","run","machineReset","machineNext","machineTo","#debug","#sm","#smInitial","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt"],"sources":["../../collections/dist/src/circular-array.js","../../collections/dist/src/queue/queue-fns.js","../../collections/dist/src/queue/queue-mutable.js","../../collections/dist/src/stack/StackFns.js","../../collections/dist/src/stack/StackMutable.js","../../collections/dist/src/tree/compare.js","../../collections/dist/src/tree/tree-mutable.js","../../collections/dist/src/tree/traverse-object.js","../../collections/dist/src/tree/pathed.js","../../collections/dist/src/tree/traversable-tree.js","../../collections/dist/src/tree/index.js","../../collections/dist/src/stack/StackImmutable.js","../../collections/dist/src/stack/index.js","../../collections/dist/src/set/set-mutable.js","../../collections/dist/src/set/SetImmutable.js","../../collections/dist/src/set/massive-set.js","../../collections/dist/src/set/index.js","../../collections/dist/src/queue/priority-mutable.js","../../collections/dist/src/queue/queue-immutable.js","../../collections/dist/src/queue/index.js","../../collections/dist/src/map/expiring-map.js","../../collections/dist/src/map/map-multi-fns.js","../../collections/dist/src/map/map-of-simple-base.js","../../collections/dist/src/map/map-of-simple-mutable.js","../../collections/dist/src/map/map-immutable-fns.js","../../collections/dist/src/map/map.js","../../collections/dist/src/map/map-mutable.js","../../collections/dist/src/map/map-of-multi-impl.js","../../collections/dist/src/map/map-of-set-mutable.js","../../collections/dist/src/map/map-of-circular-mutable.js","../../collections/dist/src/map/number-map.js","../../collections/dist/src/map/map-of-array-mutable.js","../../collections/dist/src/map/map-of-simple.js","../../collections/dist/src/map/index.js","../../collections/dist/src/table.js","../../collections/dist/src/graph/directed-graph.js","../../collections/dist/src/graph/undirected-graph.js","../../collections/dist/src/graph/index.js","../../collections/dist/src/index.js","../../flow/dist/src/behaviour-tree.js","../../flow/dist/src/delay.js","../../flow/dist/src/timeout.js","../../flow/dist/src/debounce.js","../../flow/dist/src/dispatch-list.js","../../flow/dist/src/every.js","../../flow/dist/src/execute.js","../../flow/dist/src/event-race.js","../../flow/dist/src/moving-average.js","../../flow/dist/src/pool.js","../../flow/dist/src/promise-with-resolvers.js","../../flow/dist/src/rate-minimum.js","../../flow/dist/src/repeat.js","../../flow/dist/src/req-resp-match.js","../../flow/dist/src/retry.js","../../flow/dist/src/run-once.js","../../flow/dist/src/sync-wait.js","../../flow/dist/src/task-queue-mutable.js","../../flow/dist/src/throttle.js","../../flow/dist/src/timer.js","../../flow/dist/src/update-outdated.js","../../flow/dist/src/wait-for-value.js","../../flow/dist/src/wait-for.js","../../flow/dist/src/state-machine/state-machine.js","../../flow/dist/src/state-machine/driver.js","../../flow/dist/src/state-machine/with-events.js","../../flow/dist/src/state-machine/index.js","../../flow/dist/src/index.js"],"sourcesContent":["import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * A circular array keeps a maximum number of values, overwriting older values as needed. Immutable.\n *\n * `CircularArray` extends the regular JS array. Only use `add` to change the array if you want\n * to keep the `CircularArray` behaviour.\n *\n * @example Basic functions\n * ```js\n * let a = new CircularArray(10);\n * a = a.add(`hello`);  // Because it's immutable, capture the return result of `add`\n * a.isFull;            // True if circular array is full\n * a.pointer;           // The current position in array it will write to\n * ```\n *\n * Since it extends the regular JS array, you can access items as usual:\n * @example Accessing\n * ```js\n * let a = new CircularArray(10);\n * ... add some stuff ..\n * a.forEach(item => // do something with item);\n * ```\n * @param capacity Maximum capacity before recycling array entries\n * @return Circular array\n */\nexport class CircularArray extends Array {\n    #capacity;\n    #pointer;\n    constructor(capacity = 0) {\n        super();\n        // Allowed to create with capacity zero\n        resultThrow(integerTest(capacity, `positive`, `capacity`));\n        // Can't throw because .filter won't use ctor proprly\n        this.#capacity = capacity;\n        this.#pointer = 0;\n    }\n    /**\n     * Add to array\n     * @param value Thing to add\n     * @returns\n     */\n    add(value) {\n        const ca = CircularArray.from(this);\n        ca[this.#pointer] = value;\n        ca.#capacity = this.#capacity;\n        if (this.#capacity > 0) {\n            ca.#pointer =\n                this.#pointer + 1 === this.#capacity ? 0 : this.#pointer + 1;\n        }\n        else {\n            ca.#pointer = this.#pointer + 1;\n        }\n        return ca;\n    }\n    get pointer() {\n        return this.#pointer;\n    }\n    get isFull() {\n        if (this.#capacity === 0)\n            return false;\n        return this.length === this.#capacity;\n    }\n}\n","export const debug = (opts, message) => {\n    opts.debug ? console.log(`queue:${message}`) : undefined;\n};\nexport const trimQueue = (opts, queue, toAdd) => {\n    const potentialLength = queue.length + toAdd.length;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    const policy = opts.discardPolicy ?? `additions`;\n    // debug(\n    //   opts,\n    //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n    // );\n    // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n    switch (policy) {\n        // Only add what we can from toAdd\n        case `additions`: {\n            // debug(\n            //   opts,\n            //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n            //     potentialLength - capacity\n            //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n            // );\n            if (queue.length === 0)\n                return toAdd.slice(0, toAdd.length - toRemove);\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (queue.length === opts.capacity) {\n                return queue; // Completely full\n            }\n            else {\n                // Only add some from the new array (from the front)\n                return [...queue, ...toAdd.slice(0, toRemove - 1)];\n            }\n        }\n        // Remove from rear of queue (last index) before adding new things\n        case `newer`: {\n            if (toRemove >= queue.length) {\n                // New items will completely flush out old\n                //debug(opts, `slice start: ${toAdd.length - capacity}`);\n                if (queue.length === 0) {\n                    // Special case when queue starts off empty\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];\n                }\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n                //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n                //return tmp;\n            }\n            else {\n                // Keep some of the old\n                // const toAddFinal = toAdd.slice(\n                //   0,\n                //   Math.min(toAdd.length, capacity - toRemove + 1)\n                // );\n                // Cap 5, queue 5, toAdd: 10.\n                const countToAdd = Math.max(1, toAdd.length - queue.length);\n                const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n                const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n                // debug(\n                //   opts,\n                //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n                //     queue.length\n                //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n                //     toKeep\n                //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n                //     toAddFinal\n                //   )}`\n                // );\n                const t = [...toKeep, ...toAddFinal];\n                //debug(opts, `final: ${JSON.stringify(t)}`);\n                return t;\n            }\n        }\n        // Remove from the front of the queue (0 index). ie. older items are discarded\n        case `older`: {\n            // If queue is A, B and toAdd is C, D this yields A, B, C, D\n            return [...queue, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown overflow policy ${policy}`);\n        }\n    }\n};\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = (opts, queue, ...toAdd) => {\n    if (opts === undefined)\n        throw new Error(`opts parameter undefined`);\n    const potentialLength = queue.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimQueue(opts, queue, toAdd)\n        : [...queue, ...toAdd];\n    if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n        throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\n    }\n    if (!opts.capacity && toReturn.length !== potentialLength) {\n        throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\n    }\n    return toReturn;\n};\n// Remove from front of queue (0 index)\nexport const dequeue = (opts, queue) => {\n    if (queue.length === 0)\n        throw new Error(`Queue is empty`);\n    return queue.slice(1);\n};\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, queue) => queue[0];\nexport const isEmpty = (opts, queue) => queue.length === 0;\nexport const isFull = (opts, queue) => {\n    if (opts.capacity) {\n        return queue.length >= opts.capacity;\n    }\n    return false;\n};\n","import {} from './iqueue-mutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './queue-fns.js';\nimport {} from './queue-types.js';\nimport { isEqualDefault } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\n/**\n * Mutable queue that fires events when manipulated.\n *\n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n *\n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n *\n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @typeParam V - Data type of items\n */\nexport class QueueMutable extends SimpleEventEmitter {\n    options;\n    data;\n    eq;\n    constructor(opts = {}, data = []) {\n        super();\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.options = opts;\n        this.data = data;\n        this.eq = opts.eq ?? isEqualDefault;\n    }\n    clear() {\n        const copy = [...this.data];\n        this.data = [];\n        this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n        this.onClear();\n    }\n    /**\n     * Called when all data is cleared\n     */\n    onClear() {\n    }\n    at(index) {\n        if (index >= this.data.length)\n            throw new Error(`Index outside bounds of queue`);\n        const v = this.data.at(index);\n        if (v === undefined)\n            throw new Error(`Index appears to be outside range of queue`);\n        return v;\n    }\n    enqueue(...toAdd) {\n        this.data = enqueue(this.options, this.data, ...toAdd);\n        const length = this.data.length;\n        this.onEnqueue(this.data, toAdd);\n        return length;\n    }\n    onEnqueue(result, attemptedToAdd) {\n        this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n    }\n    dequeue() {\n        const v = peek(this.options, this.data);\n        if (v === undefined)\n            return;\n        /* eslint-disable-next-line functional/immutable-data */\n        this.data = dequeue(this.options, this.data);\n        this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n        this.onRemoved([v], this.data);\n        return v;\n    }\n    onRemoved(removed, finalData) {\n        this.fireEvent(`removed`, { removed, finalData });\n    }\n    /**\n     * Removes values that match `predicate`.\n     * @param predicate\n     * @returns Returns number of items removed.\n     */\n    removeWhere(predicate) {\n        const countPre = this.data.length;\n        const toRemove = this.data.filter(v => predicate(v));\n        if (toRemove.length === 0)\n            return 0;\n        this.data = this.data.filter((element) => !predicate(element));\n        this.onRemoved(toRemove, this.data);\n        return countPre - this.data.length;\n    }\n    /**\n   * Return a copy of the array\n   * @returns\n   */\n    toArray() {\n        return [...this.data];\n    }\n    get isEmpty() {\n        return isEmpty(this.options, this.data);\n    }\n    get isFull() {\n        return isFull(this.options, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n    get peek() {\n        return peek(this.options, this.data);\n    }\n}\n/**\n * Creates a new QueueMutable\n * @param options\n * @param startingItems\n * @returns\n */\nexport function mutable(options = {}, ...startingItems) {\n    return new QueueMutable({ ...options }, [...startingItems]);\n}\n","export const trimStack = (opts, stack, toAdd) => {\n    const potentialLength = stack.length + toAdd.length;\n    const policy = opts.discardPolicy ?? `additions`;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    if (opts.debug) {\n        console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);\n    }\n    switch (policy) {\n        case `additions`: {\n            if (opts.debug) {\n                console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`);\n            }\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (stack.length === opts.capacity) {\n                return stack; // Completely full\n            }\n            else {\n                // Only add some from the new array\n                return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];\n            }\n        }\n        case `newer`: {\n            if (toRemove >= stack.length) {\n                // New items will completely flush out old\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n            }\n            else {\n                // Keep some of the old (from 0)\n                //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n                if (opts.debug) {\n                    console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);\n                }\n                return [\n                    ...stack.slice(0, stack.length - toRemove),\n                    ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n                ];\n            }\n        }\n        case `older`: {\n            // Oldest item in stack is position 0\n            return [...stack, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown discard policy ${policy}`);\n        }\n    }\n};\n// Add to top (last index)\nexport const push = (opts, stack, ...toAdd) => {\n    // If stack is A, B and toAdd is C, D this yields A, B, C, D\n    //const mutated = [...stack, ...toAdd];\n    const potentialLength = stack.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimStack(opts, stack, toAdd)\n        : [...stack, ...toAdd];\n    return toReturn;\n};\n// Remove from top (last index)\nexport const pop = (opts, stack) => {\n    if (stack.length === 0)\n        throw new Error(`Stack is empty`);\n    return stack.slice(0, -1);\n};\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, stack) => stack.at(-1);\nexport const isEmpty = (opts, stack) => stack.length === 0;\nexport const isFull = (opts, stack) => {\n    if (opts.capacity) {\n        return stack.length >= opts.capacity;\n    }\n    return false;\n};\n","// -------------------------\n// Mutable\n// -------------------------\nimport { push, peek, pop, isEmpty, isFull } from './StackFns.js';\n/**\n * Creates a stack. Mutable. Use {@link StackImmutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = new StackMutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport class StackMutable {\n    opts;\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    /**\n     * Push data onto the stack.\n     * If `toAdd` is empty, nothing happens\n     * @param toAdd Data to add\n     * @returns Length of stack\n     */\n    push(...toAdd) {\n        if (toAdd.length === 0)\n            return this.data.length;\n        this.data = push(this.opts, this.data, ...toAdd);\n        return this.data.length;\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    pop() {\n        const v = peek(this.opts, this.data);\n        this.data = pop(this.opts, this.data);\n        return v;\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Creates a stack. Mutable. Use {@link Stacks.immutable} for an immutable alternative.\n *\n * @example Basic usage\n * ```js\n * // Create\n * const s = Stacks.mutable();\n * // Add one or more items\n * s.push(1, 2, 3, 4);\n *\n * // See what's on top\n * s.peek;  // 4\n *\n * // Remove the top-most, and return it\n * s.pop();   // 4\n *\n * // Now there's a new top-most element\n * s.peek;  // 3\n * ```\n */\nexport const mutable = (opts = {}, ...startingItems) => new StackMutable({ ...opts }, [...startingItems]);\n","import { isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport * as TreeMutable from './tree-mutable.js';\nexport const compare = (a, b, eq = isEqualValueIgnoreOrder, parent) => {\n    const valueEqual = valueOrIdentityEqual(a, b, eq);\n    // if (!valueEqual) {\n    //   nsole.log(`changed compare a: ${ toStringSingle(a) } b: ${ toStringSingle(b) }`);\n    // }\n    const childrenCompare = compareChildren(a, b, eq);\n    const diff = {\n        valueChanged: !valueEqual, a, b,\n        added: childrenCompare.added,\n        removed: childrenCompare.removed,\n        childChanged: false\n    };\n    const diffNode = {\n        value: diff,\n        childrenStore: [],\n        parent\n    };\n    const childrenDiff = childrenCompare.identical.map(c => compare(c[0], c[1], eq, diffNode));\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const someChildChange = hasChange(diff) || childrenDiff.some(v => hasChange(v.value));\n    TreeMutable.setChildren(diffNode, childrenDiff);\n    //diffNode.childrenStore = childrenDiff;\n    diffNode.toString = () => toString(diffNode, 0);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    diffNode.value.childChanged = someChildChange;\n    TreeMutable.throwTreeTest(diffNode);\n    return diffNode;\n};\nconst hasChange = (vv) => {\n    if (vv === undefined)\n        return false;\n    if (vv.valueChanged)\n        return true;\n    if (vv.childChanged)\n        return true;\n    if (vv.added.length > 0)\n        return true;\n    if (vv.removed.length > 0)\n        return true;\n    return false;\n};\nconst compareChildren = (a, b, eq = isEqualValueIgnoreOrder) => {\n    const childrenOfA = [...a.children()];\n    const childrenOfB = [...b.children()];\n    const identical = [];\n    const removed = [];\n    for (const childA of childrenOfA) {\n        let foundIndex = -1;\n        for (const [index, childOfB] of childrenOfB.entries()) {\n            const d = valueOrIdentityEqual(childA, childOfB, eq);\n            if (d) {\n                identical.push([childA, childOfB]);\n                foundIndex = index;\n                break;\n            }\n        }\n        if (foundIndex === -1) {\n            // A's child not found in B's children\n            removed.push(childA);\n        }\n        else {\n            // Found, remove it from list of B's children\n            childrenOfB.splice(foundIndex, 1);\n        }\n    }\n    const added = [...childrenOfB];\n    return { added, identical, removed };\n};\nconst valueOrIdentityEqual = (a, b, eq) => {\n    if (a.getIdentity() === b.getIdentity())\n        return true;\n    if (eq(a.getValue(), b.getValue()))\n        return true;\n    return false;\n};\nconst toStringSingle = (n) => {\n    return JSON.stringify(n.getValue());\n};\nconst toString = (n, indent = 0) => {\n    if (n === undefined)\n        return `(undefined)`;\n    let t = toStringDiff(n.value, indent);\n    for (const c of n.childrenStore) {\n        t += toString(c, indent + 2);\n    }\n    return t;\n};\nconst toStringDiff = (n, indent) => {\n    const spaces = ` `.repeat(indent);\n    if (n === undefined)\n        return `${spaces}(undefined)`;\n    const t = [];\n    t.push(`a: ${toStringSingle(n.a)} b: ${toStringSingle(n.b)}`);\n    if (n.valueChanged)\n        t.push(`Value changed. Child changed: ${n.childChanged}`);\n    else\n        t.push(`Value unchanged. Child changed: ${n.childChanged}`);\n    if (n.added.length > 0) {\n        t.push(`Added:`);\n        for (const c of n.added) {\n            t.push(` - ` + toStringSingle(c));\n        }\n    }\n    if (n.removed.length > 0) {\n        t.push(`Removed: ${n.removed.length}`);\n        for (const c of n.removed) {\n            t.push(` - ` + toStringSingle(c));\n        }\n    }\n    t.push(`----\\n`);\n    return t.map(line => spaces + line).join(`\\n`);\n};\n","import { isEqualDefault } from \"@ixfx/core\";\nimport { without } from '@ixfx/arrays';\nimport { containsDuplicateInstances } from \"@ixfx/arrays\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { compare as treeCompare } from './compare.js';\nimport { toStringAbbreviate } from \"@ixfx/core/text\";\n/**\n * Compares two nodes.\n *\n * By default uses `isEqualValueIgnoreOrder` to compare nodes. This means\n * values of nodes will be compared, ignoring the order of fields.\n * @param a\n * @param b\n * @param eq Comparison function. Uses `isEqualValueIgnoreOrder` by default.\n * @returns Compare results\n */\nexport const compare = (a, b, eq) => {\n    return treeCompare(asDynamicTraversable(a), asDynamicTraversable(b), eq);\n};\n/**\n * Converts `TreeNode` to `SimplifiedNode`, removing the 'parent' fields.\n * This can be useful because if you have the whole tree, the parent field\n * is redundant and because it makes circular references can make dumping to console etc more troublesome.\n *\n * Recursive: strips parentage of all children and so on too.\n * @param node\n * @returns\n */\nexport const stripParentage = (node) => {\n    const n = {\n        value: node.value,\n        childrenStore: node.childrenStore.map(c => stripParentage(c))\n    };\n    return n;\n};\nconst unwrapped = (node) => (`wraps` in node) ? node.wraps : node;\nconst wrapped = (node) => (`wraps` in node) ? node : wrap(node);\n/**\n * Wraps node `n` for a more object-oriented means of access.\n * It will wrap child nodes on demand. For this reason, WrappedNode object\n * identity is not stable\n * @param n Node to wrap\n * @returns\n */\nexport const wrap = (n) => {\n    return {\n        *children() {\n            for (const c of n.childrenStore) {\n                yield wrap(c);\n            }\n        },\n        getValue: () => n.value,\n        getIdentity: () => n,\n        *queryValue(value) {\n            for (const v of queryByValue(value, unwrapped(n))) {\n                yield wrap(v);\n            }\n        },\n        *queryParentsValue(child, value, eq) {\n            for (const v of queryParentsValue(unwrapped(child), value, eq)) {\n                yield wrap(v);\n            }\n        },\n        *parentsValues(child) {\n            yield* parentsValues(unwrapped(child));\n        },\n        findParentsValue(child, value, eq) {\n            const n = findParentsValue(child, value, eq);\n            if (n !== undefined)\n                return wrap(n);\n        },\n        getParent: () => n.parent === undefined ? undefined : wrap(n.parent),\n        hasParent: (parent) => {\n            return hasParent(n, unwrapped(parent));\n        },\n        hasAnyParent: (parent) => {\n            return hasAnyParent(n, unwrapped(parent));\n        },\n        hasChild: (child) => {\n            return hasChild(unwrapped(child), n);\n        },\n        hasAnyChild: (child) => {\n            return hasAnyChild(unwrapped(child), n);\n        },\n        remove: () => {\n            remove(n);\n        },\n        addValue: (value) => {\n            const nodeValue = addValue(value, n);\n            return wrap(nodeValue);\n        },\n        add: (child) => {\n            add(unwrapped(child), n);\n            return wrapped(child);\n        },\n        wraps: n\n    };\n};\n/**\n * Removes `child` from the tree structure it is in.\n * It removes `child` from its parent. Any sub-children of `child` still remain connected.\n * @param child\n * @returns\n */\nexport const remove = (child) => {\n    const p = child.parent;\n    if (p === undefined)\n        return;\n    child.parent = undefined;\n    p.childrenStore = without(p.childrenStore, child);\n};\n/**\n * Depth-first iteration of the children of `node`\n * @param node\n * @returns\n */\nexport function* depthFirst(node) {\n    if (!root)\n        return;\n    const stack = new StackMutable();\n    stack.push(...node.childrenStore);\n    let entry = stack.pop();\n    while (entry) {\n        yield entry;\n        if (entry) {\n            stack.push(...entry.childrenStore);\n        }\n        if (stack.isEmpty)\n            break;\n        entry = stack.pop();\n    }\n}\n/**\n * Breadth-first iteration of the children of `node`\n * @param node\n * @returns\n */\nexport function* breadthFirst(node) {\n    if (!node)\n        return;\n    const queue = new QueueMutable();\n    queue.enqueue(...node.childrenStore);\n    let entry = queue.dequeue();\n    while (entry) {\n        yield entry;\n        if (entry) {\n            queue.enqueue(...entry.childrenStore);\n        }\n        if (queue.isEmpty)\n            break;\n        entry = queue.dequeue();\n    }\n}\n/**\n * Validates the tree from `root` downwards.\n * @param root\n * @param seen\n * @returns\n */\nexport function treeTest(root, seen = []) {\n    if (root.parent === root)\n        return [false, `Root has itself as parent`, root];\n    if (seen.includes(root))\n        return [false, `Same node instance is appearing further in tree`, root];\n    seen.push(root);\n    if (containsDuplicateInstances(root.childrenStore))\n        return [false, `Children list contains duplicates`, root];\n    for (const c of root.childrenStore) {\n        if (c.parent !== root)\n            return [false, `Member of childrenStore does not have .parent set`, c];\n        if (hasAnyChild(root, c))\n            return [false, `Child has parent as its own child`, c];\n        const v = treeTest(c, seen);\n        if (!v[0])\n            return v;\n    }\n    return [true, ``, root];\n}\n/**\n * Throws an exception if `root` fails tree validation\n * @param root\n * @returns\n */\nexport function throwTreeTest(root) {\n    const v = treeTest(root);\n    if (v[0])\n        return;\n    throw new Error(`${v[1]} Node: ${toStringAbbreviate(v[2].value, 30)}`, { cause: v[2] });\n}\n/**\n * Iterate over direct children of `root`, yielding {@link TreeNode} instances.\n * Use {@link childrenValues} to iterate over child values\n * @param root\n */\nexport function* children(root) {\n    for (const c of root.childrenStore) {\n        yield c;\n    }\n}\n/**\n * Iterate over the value ofdirect children of `root`.\n * Use {@link children} if you want to iterate over {@link TreeNode} instances instead.\n * @param root\n */\nexport function* childrenValues(root) {\n    for (const c of root.childrenStore) {\n        if (typeof c.value !== `undefined`)\n            yield c.value;\n    }\n}\n/**\n * Iterate over all parents of `root`. First result is the immediate parent.\n * @param root\n */\nexport function* parents(root) {\n    let p = root.parent;\n    while (p) {\n        yield p;\n        p = p.parent;\n    }\n}\n/**\n * Returns the depth of `node`. A root node (ie. with no parents) has a depth of 0.\n * @param node\n * @returns\n */\nexport function nodeDepth(node) {\n    const p = [...parents(node)];\n    return p.length;\n}\nexport const hasChild = (child, parent) => {\n    for (const c of parent.childrenStore) {\n        if (c === child)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns the first immediate child of `parent` that matches `value`.\n *\n * Use {@link queryByValue} if you want all matching children.\n * @param value\n * @param parent\n * @param eq\n * @returns\n */\nexport const findChildByValue = (value, parent, eq = isEqualDefault) => {\n    for (const c of parent.childrenStore) {\n        if (eq(value, c.value))\n            return c;\n    }\n};\n/**\n * Yield all immediate children of `parent` that match `value`.\n *\n * Use {@link findChildByValue} if you only want the first matching child.\n * @param value\n * @param parent\n * @param eq\n */\nexport function* queryByValue(value, parent, eq = isEqualDefault) {\n    for (const c of parent.childrenStore) {\n        if (eq(value, c.value))\n            yield c;\n    }\n}\n/**\n * Returns _true_ if `prospectiveChild` is some child node of `parent`,\n * anywhere in the tree structure.\n *\n * Use {@link hasChild} to only check immediate children.\n * @param prospectiveChild\n * @param parent\n * @returns\n */\nexport const hasAnyChild = (prospectiveChild, parent) => {\n    for (const c of breadthFirst(parent)) {\n        if (c === prospectiveChild)\n            return true;\n    }\n    return false;\n};\nexport const findAnyChildByValue = (value, parent, eq = isEqualDefault) => {\n    for (const c of breadthFirst(parent)) {\n        if (eq(c.value, value))\n            return c;\n    }\n};\nexport const getRoot = (node) => {\n    if (node.parent)\n        return getRoot(node.parent);\n    return node;\n};\n/**\n * Returns _true_ if `prospectiveParent` is any ancestor\n * parent of `child`.\n *\n * Use {@link hasParent} to only check immediate parent.\n * @param child\n * @param prospectiveParent\n * @returns\n */\nexport const hasAnyParent = (child, prospectiveParent) => {\n    for (const p of parents(child)) {\n        if (p === prospectiveParent)\n            return true;\n    }\n    return false;\n};\n/**\n * Yields the node value of each parent of `child`.\n * _undefined_ values are not returned.\n *\n * Use {@link queryParentsValue} to search for a particular value\n * @param child\n * @returns\n */\nexport function* parentsValues(child) {\n    for (const p of parents(child)) {\n        if (typeof p.value !== `undefined`) {\n            yield p.value;\n        }\n    }\n    return false;\n}\n/**\n * Yields all parents of `child` that have a given value.\n * Use {@link findParentsValue} to find the first match only.\n * @param child\n * @param value\n * @param eq\n * @returns\n */\nexport function* queryParentsValue(child, value, eq = isEqualDefault) {\n    for (const p of parents(child)) {\n        if (typeof p.value !== `undefined`) {\n            if (eq(p.value, value))\n                yield p;\n        }\n    }\n    return false;\n}\n/**\n * Returns the first parent that has a given value.\n * @param child\n * @param value\n * @param eq\n * @returns\n */\nexport function findParentsValue(child, value, eq = isEqualDefault) {\n    for (const p of queryParentsValue(child, value, eq)) {\n        return p;\n    }\n}\n/**\n * Returns _true_ if `prospectiveParent` is the immediate\n * parent of `child`.\n *\n * Use {@link hasAnyParent} to check for any ancestor parent.\n * @param child\n * @param prospectiveParent\n * @returns\n */\nexport const hasParent = (child, prospectiveParent) => {\n    return child.parent === prospectiveParent;\n};\n/**\n * Computes the maximum depth of the tree.\n * That is, how many steps down from `node` it can go.\n * If a tree is: root -> childA -> subChildB\n * ```js\n * // Yields 2, since there are at max two steps down from root\n * computeMaxDepth(root);\n * ```\n * @param node\n * @returns\n */\nexport const computeMaxDepth = (node) => {\n    return computeMaxDepthImpl(node, 0);\n};\nconst computeMaxDepthImpl = (node, startingDepth = 0) => {\n    let depth = startingDepth;\n    for (const c of node.childrenStore) {\n        depth = Math.max(depth, computeMaxDepthImpl(c, startingDepth + 1));\n    }\n    return depth;\n};\nexport const add = (child, parent) => {\n    throwAttemptedChild(child, parent);\n    //if (hasAnyChild(parent, child)) throw new Error(`Parent already contains child`);\n    //if (hasAnyParent(child, parent)) throw new Error(`Child already has parent`);\n    const p = child.parent;\n    parent.childrenStore = [...parent.childrenStore, child];\n    child.parent = parent;\n    if (p) {\n        p.childrenStore = without(p.childrenStore, child);\n    }\n};\nexport const addValue = (value, parent) => {\n    return createNode(value, parent);\n};\n/**\n * Creates the root for a tree, with an optional `value`.\n * Use {@link rootWrapped} if you want a more object-oriented mode of access.\n * @param value\n * @returns\n */\nexport const root = (value) => {\n    return createNode(value);\n};\nexport const fromPlainObject = (value, label = ``, parent, seen = []) => {\n    const entries = Object.entries(value);\n    parent = parent === undefined ? root() : addValue({ label, value }, parent);\n    for (const entry of entries) {\n        const value = entry[1];\n        // Avoid circular references\n        if (seen.includes(value))\n            continue;\n        seen.push(value);\n        if (typeof entry[1] === `object`) {\n            fromPlainObject(value, entry[0], parent, seen);\n        }\n        else {\n            addValue({ label: entry[0], value: value }, parent);\n        }\n    }\n    return parent;\n};\n/**\n * Creates a tree, returning it as a {@link WrappedNode} for object-oriented access.\n * Use {@link Trees.Mutable.root} alternatively.\n * @param value\n * @returns\n */\nexport const rootWrapped = (value) => {\n    return wrap(createNode(value));\n};\n/**\n * Creates a `TreeNode` instance with a given value and parent.\n * Parent node, if specified, has its `childrenStore` property changed to include new child.\n * @param value\n * @param parent\n * @returns\n */\nexport const createNode = (value, parent) => {\n    const n = {\n        childrenStore: [],\n        parent: parent,\n        value: value\n    };\n    if (parent !== undefined) {\n        parent.childrenStore = [...parent.childrenStore, n];\n    }\n    return n;\n};\nexport const childrenLength = (node) => {\n    return node.childrenStore.length;\n};\nexport const value = (node) => {\n    return node.value;\n};\n/**\n * Projects `node` as a dynamic traversable.\n * Dynamic in the sense that it creates the traversable project for nodes on demand.\n * A consequence is that node identities are not stable.\n * @param node\n * @returns\n */\nexport const asDynamicTraversable = (node) => {\n    const t = {\n        *children() {\n            for (const c of node.childrenStore) {\n                yield asDynamicTraversable(c);\n            }\n        },\n        getParent() {\n            if (node.parent === undefined)\n                return;\n            return asDynamicTraversable(node.parent);\n        },\n        getValue() {\n            return node.value;\n        },\n        getIdentity() {\n            return node;\n        },\n    };\n    return t;\n};\nconst throwAttemptedChild = (c, parent) => {\n    if (parent === c)\n        throw new Error(`Cannot add self as child`);\n    if (c.parent === parent)\n        return; // skip if it's already a child\n    if (hasAnyParent(parent, c))\n        throw new Error(`Child contains parent (1)`, { cause: c });\n    if (hasAnyParent(c, parent))\n        throw new Error(`Parent already contains child`, { cause: c });\n    if (hasAnyChild(parent, c))\n        throw new Error(`Child contains parent (2)`, { cause: c });\n};\nexport const setChildren = (parent, children) => {\n    // Verify children are legit\n    for (const c of children) {\n        throwAttemptedChild(c, parent);\n    }\n    parent.childrenStore = [...children];\n    for (const c of children) {\n        c.parent = parent;\n    }\n};\nexport const toStringDeep = (node, indent = 0) => {\n    const t = `${`  `.repeat(indent)} + ${node.value ? JSON.stringify(node.value) : `-`}`;\n    return node.childrenStore.length > 0 ? (t +\n        `\\n` +\n        node.childrenStore.map((d) => toStringDeep(d, indent + 1)).join(`\\n`)) : t;\n};\nexport function* followValue(root, continuePredicate, depth = 1) {\n    for (const c of root.childrenStore) {\n        const value = c.value;\n        if (value === undefined)\n            continue;\n        if (continuePredicate(value, depth)) {\n            yield c.value;\n            yield* followValue(c, continuePredicate, depth + 1);\n        }\n    }\n}\n// export function* followNode<T>(root: Node<T>, continuePredicate: (nodeValue: T | undefined, depth: number) => boolean, depth = 1): IterableIterator<Node<T>> {\n//   for (const c of root.childrenStore) {\n//     if (continuePredicate(c.value, depth)) {\n//       yield c;\n//       yield* followNode(c, continuePredicate, depth + 1);\n//     }\n//   }\n// }\n","import { toStringAbbreviate } from '@ixfx/core/text';\nimport { nullUndefTest, resultThrow } from '@ixfx/guards'; //'../../util/GuardEmpty.js';\nimport { last } from '@ixfx/iterables/sync';\nimport * as TreeArrayBacked from './tree-mutable.js';\nimport { isPrimitive } from '@ixfx/core'; //'../../util/IsPrimitive.js';\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link TraverseObjectEntry}.\n * @param entries\n * @returns\n */\nexport function prettyPrintEntries(entries) {\n    if (entries.length === 0)\n        return `(empty)`;\n    let t = ``;\n    for (const [index, entry] of entries.entries()) {\n        t += `  `.repeat(index);\n        t += entry.name + ` = ` + JSON.stringify(entry.leafValue) + `\\n`;\n    }\n    return t;\n}\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const prettyPrint = (node, indent = 0, options = {}) => {\n    resultThrow(nullUndefTest(node, `node`));\n    const defaultName = options.name ?? `node`;\n    const entry = getNamedEntry(node, defaultName);\n    const t = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.leafValue)}`;\n    const childrenAsArray = [...children(node, options)];\n    return childrenAsArray.length > 0 ? (t +\n        `\\n` +\n        childrenAsArray.map((d) => prettyPrint(d.leafValue, indent + 1, { ...options, name: d.name })).join(`\\n`)) : t;\n};\n/**\n * Returns a debug string representation of the node (recursive)\n * @param node\n * @param indent\n * @returns\n */\nexport const toStringDeep = (node, indent = 0) => {\n    let t = ` `.repeat(indent) + ` ${node.value?.name}`;\n    if (node.value !== undefined) {\n        if (`sourceValue` in node.value && `leafValue` in node.value) {\n            let sourceValue = toStringAbbreviate(node.value.sourceValue, 20);\n            const leafValue = toStringAbbreviate(node.value.leafValue, 20);\n            sourceValue = sourceValue === leafValue ? `` : `source: ` + sourceValue;\n            t += ` = ${leafValue} ${sourceValue}`;\n        }\n        else if (`sourceValue` in node.value && node.value.sourceValue !== undefined)\n            t += ` = ${node.value.sourceValue}`;\n        if (`ancestors` in node.value) {\n            t += ` (ancestors: ${(node.value.ancestors).join(`, `)})`;\n        }\n    }\n    t += `\\n`;\n    for (const c of node.childrenStore) {\n        t += toStringDeep(c, indent + 1);\n    }\n    return t;\n};\n/**\n * Yields the direct (ie. non-recursive) children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * To iterate recursively, consider {@link depthFirst}\n *\n * Each child is returned in an {@link TraverseObjectEntry} structure:\n * ```typescript\n * type Entry = Readonly<{\n *  // Property name\n *  name: string,\n *  // Value of property, as if you called `object[propertyName]`\n *  sourceValue: any,\n *  // Branch nodes will have _undefined_, leaf nodes will contain the value\n *  leafValue: any\n * }>;\n * ```\n *\n * For example, iterating over a flat object:\n * ```js\n * const verySimpleObject = { field: `hello`, flag: true }\n * const kids = [ ...children(verySimpleObject) ];\n * // Yields:\n * // [ { name: \"field\", sourceValue: `hello`, leafValue: `hello` },\n * //  { name: \"flag\", sourceValue: true, leafValue: true } ]\n * ```\n *\n * For objects containing objects:\n * ```js\n * const lessSimpleObject = { field: `hello`, flag: true, colour: { `red`, opacity: 0.5 } }\n * const kids = [ ...children(verySimpleObject) ];\n * // Yields as before, plus:\n * //  { name: \"colour\", sourceValue: { name: 'red', opacity: 0.5 }, leafValue: undefined }\n * ```\n *\n * Note that 'sourceValue' always contains the property value, as if you\n * access it via `object[propName]`. 'leafValue' only contains the value if it's a leaf\n * node.\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport function* children(node, options = {}) {\n    resultThrow(nullUndefTest(node, `node`));\n    const filteringOption = options.filter ?? `none`;\n    const filterByValue = (v) => {\n        if (filteringOption === `none`)\n            return [true, isPrimitive(v)];\n        else if (filteringOption === `leaves` && isPrimitive(v))\n            return [true, true];\n        else if (filteringOption === `branches` && !isPrimitive(v))\n            return [true, false];\n        return [false, isPrimitive(v)];\n    };\n    if (Array.isArray(node)) {\n        //if (options.name === undefined) defaultName = `array`;\n        for (const [index, element] of node.entries()) {\n            const f = filterByValue(element);\n            if (f[0]) {\n                yield { name: index.toString(), _kind: `entry`, sourceValue: element, leafValue: f[1] ? element : undefined };\n                //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, leafValue: f[ 1 ] ? element : undefined };\n            }\n        }\n    }\n    else if (typeof node === `object`) {\n        const entriesIter = (`entries` in node) ? node.entries() : Object.entries(node);\n        for (const [name, value] of entriesIter) {\n            //console.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n            const [filter, isPrimitive] = filterByValue(value);\n            if (filter) {\n                yield { name: name, _kind: `entry`, sourceValue: value, leafValue: isPrimitive ? value : undefined };\n            }\n        }\n    }\n}\nexport function* depthFirst(node, options = {}, ancestors = []) {\n    for (const c of children(node, options)) {\n        //onsole.log(`depthFirst name: ${ c.name } leafValue: ${ toStringAbbreviate(c.leafValue) }`)\n        yield { ...c, ancestors: [...ancestors], _kind: `entry-ancestors` };\n        yield* depthFirst(c.sourceValue, options, [...ancestors, c.name]);\n    }\n}\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction childByName(name, node) {\n    for (const d of children(node)) {\n        if (d.name === name)\n            return d;\n    }\n}\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getByPath(path, node, options = {}) {\n    // ✔️ Unit tested\n    const v = last(traceByPath(path, node, options));\n    if (!v)\n        throw new Error(`Could not trace path: ${path} `);\n    return v;\n}\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getByPath} if you don't care about interim steps.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceByPath(path, node, options = {}) {\n    resultThrow(nullUndefTest(path, `path`), nullUndefTest(node, `node`));\n    const separator = options.separator ?? `.`;\n    // const allowArrayIndexes = opts.allowArrayIndexes ?? true;\n    const pathSplit = path.split(separator);\n    const ancestors = [];\n    for (const p of pathSplit) {\n        const entry = childByName(p, node);\n        //onsole.log(`traceByPath: entry: ${ entry?.name } path: '${ path }' p: '${ p }' source: ${ JSON.stringify(entry?.sourceValue) }`);\n        // if (allowArrayIndexes) {\n        //   const [ withoutBrackets, arrayIndexString ] = betweenChomp(p, `[`, `]`);\n        //   //onsole.log(`  withoutBrackets: ${ withoutBrackets } str: ${ arrayIndexString } without: ${ withoutBrackets }`);\n        //   const arrayIndex = integerParse(arrayIndexString, `positive`, -1);\n        //   if (arrayIndex >= 0) {\n        //     // Get array by name without the []\n        //     entry = childByName(withoutBrackets, node);\n        //     //onsole.log(`  entry: ${ entry?.name }`);\n        //     if (entry && Array.isArray(entry.sourceValue)) {\n        //       // Result was array as expected\n        //       entry = { name: p, sourceValue: entry.sourceValue[ arrayIndex ], leafValue: entry.sourceValue[ arrayIndex ] };\n        //     }\n        //   }\n        // }\n        if (!entry) {\n            yield { name: p, sourceValue: undefined, leafValue: undefined, ancestors, _kind: `entry-ancestors` };\n            return;\n        }\n        node = entry.sourceValue;\n        yield { ...entry, ancestors: [...ancestors], _kind: `entry-ancestors` };\n        ancestors.push(p);\n    }\n}\n/**\n * Returns a projection of `node` as a dynamic traversable.\n * This means that the tree structure is dynamically created as last-minute as possible.\n *\n * The type when calling `getValue()` is {@link TraverseObjectEntryStatic}:\n * ```typescript\n * type EntryStatic = Readonly<{\n *  name: string,\n *  value: any\n *  ancestors: string[]\n * }>\n * ```\n *\n * Note that the object identity of TraversableTree return results is not stable.\n * This is because they are created on-the-fly by reading fields of `node`.\n *\n * ```js\n * const c1 = [ ...asDynamicTraversable(someObject).children() ];\n * const c2 = [ ...asDynamicTraversable(someObject).children() ];\n *\n * // Object identity is not the same\n * c1[ 0 ] === c1[ 0 ]; // false\n *\n * // ...even though its referring to the same value\n * c1[ 0 ].getValue() === c1[ 0 ].getValue(); // true\n * ```\n *\n * Instead .getIdentity() to get a stable identity:\n * ```js\n * c1[ 0 ].getIdentity() === c2[ 0 ].getIdentity(); // true\n * ```\n *\n * @example\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const myObj = { name: `Pedro`, size: 45, colour: `orange` };\n * const root = Trees.FromObject.asDynamicTraversable(myObj);\n * for (const v of Trees.Traverse.breadthFirst(root)) {\n * // v.getValue() yields:\n * // { name: 'name', sourceValue: 'Pedro' ...},\n * // { name: 'size', sourceValue: 45 ... }\n * // ...\n * }\n * ```\n * @param node Object to read\n * @param options Options when creating traversable\n * @param ancestors Do not use\n * @param parent Do not use\n * @returns\n */\nexport const asDynamicTraversable = (node, options = {}, ancestors = [], parent) => {\n    const name = options.name ?? `object`;\n    const t = {\n        *children() {\n            for (const { name: childName, sourceValue, leafValue } of children(node, options)) {\n                yield asDynamicTraversable(sourceValue, { ...options, name: childName }, [...ancestors, name], t);\n            }\n        },\n        getParent() {\n            return parent;\n        },\n        getValue() {\n            return { name, sourceValue: node, ancestors, _kind: `entry-static` };\n        },\n        getIdentity() {\n            return node;\n        }\n    };\n    return t;\n};\n/**\n * Reads all fields and sub-fields of `node`, returning as a 'wrapped' tree structure.\n * @param node\n * @param options\n * @returns\n */\nexport const createWrapped = (node, options) => {\n    return TreeArrayBacked.wrap(create(node, options));\n};\n/**\n * Reads all fields and sub-fields of `node`, returning as a basic tree structure.\n * The structure is a snapshot of the object. If the object changes afterwards, the tree will\n * remain the same.\n *\n * Alternatively, consider {@link asDynamicTraversable} which reads the object dynamically.\n * @example\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const myObj = { name: `Pedro`, size: 45, colour: `orange` };\n * const root = Trees.FromObject.create(myObj);\n * for (const v of Trees.Traverse.breadthFirst(root)) {\n * // v.getValue() yields:\n * // { name: 'name', sourceValue: 'Pedro' ...},\n * // { name: 'size', sourceValue: 45 ... }\n * // ...\n * }\n * ```\n * @param node\n * @param options\n * @returns\n */\nexport const create = (node, options = {}) => {\n    const valuesAtLeaves = options.valuesAtLeaves ?? false;\n    const valueFor = valuesAtLeaves ? (v) => { if (isPrimitive(v))\n        return v; } : (v) => v;\n    return createImpl(node, valueFor(node), options, []);\n};\nconst createImpl = (sourceValue, leafValue, options = {}, ancestors) => {\n    const defaultName = options.name ?? `object_ci`;\n    //onsole.log(`createImpl name: ${ defaultName } leafValue: ${ JSON.stringify(leafValue) }`);\n    const r = TreeArrayBacked.root({ name: defaultName, sourceValue: leafValue, ancestors: [...ancestors], _kind: `entry-static` });\n    ancestors = [...ancestors, defaultName];\n    for (const c of children(sourceValue, options)) {\n        const v = options.valuesAtLeaves ? c.leafValue : c.sourceValue;\n        TreeArrayBacked.add(createImpl(c.sourceValue, v, { ...options, name: c.name }, ancestors), r);\n    }\n    return r;\n};\n/**\n * Returns a copy of `node` with its (and all its children's) parent information removed.\n * @param node\n * @param options\n * @returns\n */\nexport const createSimplified = (node, options = {}) => {\n    return TreeArrayBacked.stripParentage(create(node, options));\n};\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedEntry(node, defaultName = ``) {\n    if (`name` in node && `leafValue` in node && `sourceValue` in node)\n        return {\n            name: node.name,\n            _kind: `entry`,\n            leafValue: node.leafValue,\n            sourceValue: node.sourceValue\n        };\n    if (`name` in node) {\n        return { name: node.name, leafValue: node, sourceValue: node, _kind: `entry` };\n    }\n    return { name: defaultName, leafValue: node, sourceValue: node, _kind: `entry` };\n}\n// /**\n//  * Depth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* depthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const stack = new StackMutable<Entry>();\n//   //eslint-disable-next-line functional/immutable-data\n//   stack.push(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let,functional/immutable-data\n//   let entry = stack.pop();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       //eslint-disable-next-line functional/immutable-data\n//       stack.push(...directChildren(entry.value, entry.name));\n//     }\n//     if (stack.isEmpty) break;\n//     //eslint-disable-next-line functional/immutable-data\n//     entry = stack.pop();\n//   }\n// }\n// /**\n//  * Breadth-first traversal over object, array, Map or TreeNode\n//  * @param root\n//  * @returns\n//  */\n// export function* breadthFirst(root: object): IterableIterator<Entry> {\n//   if (!root) return;\n//   const queue = new QueueMutable<Entry>();\n//   queue.enqueue(getEntry(root, `root`));\n//   //eslint-disable-next-line functional/no-let\n//   let entry = queue.dequeue();\n//   while (entry) {\n//     yield entry;\n//     if (entry) {\n//       queue.enqueue(...directChildren(entry.value, entry.name));\n//     }\n//     if (queue.isEmpty) break;\n//     entry = queue.dequeue();\n//   }\n// }\n// export const fromUnknown = (node: object, name: string, parents: Array<TreeNode<any>> = []): TreeNode<any> => {\n//   const parentsWithUs = [ ...parents ];\n//   const enumerator = Array.isArray(node) ? enumerateArrayChildren : enumerateObjectChildren;\n//   const thisNode: TreeNode<any> = {\n//     getLengthChildren() {\n//       return [ ...enumerator(node, parentsWithUs, name) ].length\n//     },\n//     *children() {\n//       for (const c of enumerator(node, parentsWithUs, name)) {\n//         yield c;\n//       }\n//     },\n//     parents() {\n//       return parents.values()\n//     },\n//     name: name,\n//     value: node\n//   }\n//   parentsWithUs.push(thisNode);\n//   return thisNode;\n// }\n// function* enumerateObjectChildren(node: object, name: string): IterableIterator<Entry> {\n//   if (`entries` in node) {\n//     for (const entry of (node as any as Map<any, any>)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   } else {\n//     for (const entry of Object.entries(node)) {\n//       yield fromUnknown(entry[ 1 ], entry[ 0 ], parents);\n//     }\n//   }\n// }\n// function* enumerateArrayChildren(node: object, parents: Array<TreeNode<any>>, name: string): IterableIterator<TreeNode<any>> {\n//   const nodeArray = node as Array<any>;\n//   // eslint-disable-next-line unicorn/no-for-loop\n//   for (let index = 0; index < nodeArray.length; index++) {\n//     yield fromUnknown(nodeArray[ index ], name + `[ ` + index.toString() + ` ]`, parents);\n//   }\n// }\n","import * as TreeArrayBacked from \"./tree-mutable.js\";\n/**\n * Creates a wrapper for working with 'pathed' trees.\n * An example is a filesystem.\n *\n * ```js\n * const t = create();\n * // Store a value. Path implies a structure of\n * //   c -> users -> admin\n * // ...which is autoatically created\n * t.add({x:10}, `c.users.admin`);\n *\n * t.add({x:20}, `c.users.guest`);\n * // Tree will now be:\n * // c-> users -> admin\n * //            -> guest\n *\n * t.getValue(`c.users.guest`); // { x:20 }\n * ```\n *\n * By default only a single value can be stored at a path.\n * Set options to allow this:\n * ```js\n * const t = create({ duplicates: `allow` });\n * t.add({x:10}, `c.users.admin`);\n * t.add({x:20}, `c.users.admin`);\n * t.getValue(`c.users.admin`);   // Throws an error because there are multiple values\n * t.getValues(`c.users.admin`);  // [ {x:10}, {x:20 } ]\n * ```\n * @param pathOpts\n * @returns\n */\nexport const create = (pathOpts = {}) => {\n    let root;\n    const add = (value, path) => {\n        const n = addValueByPath(value, path, root, pathOpts);\n        if (root === undefined) {\n            root = TreeArrayBacked.getRoot(n);\n        }\n    };\n    const prettyPrint = () => {\n        if (root === undefined)\n            return `(empty)`;\n        return TreeArrayBacked.toStringDeep(root);\n    };\n    const getValue = (path) => {\n        if (root === undefined)\n            return;\n        return valueByPath(path, root, pathOpts);\n    };\n    const remove = (path) => {\n        if (root === undefined)\n            return false;\n        return removeByPath(path, root, pathOpts);\n    };\n    const hasPath = (path) => {\n        if (root === undefined)\n            return false;\n        const c = findChildByPath(path, root, pathOpts);\n        return c !== undefined;\n    };\n    const getNode = (path) => {\n        if (root === undefined)\n            return;\n        const c = findChildByPath(path, root, pathOpts);\n        return c;\n    };\n    const childrenLength = (path) => {\n        if (root === undefined)\n            return 0;\n        const c = findChildByPath(path, root, pathOpts);\n        if (c === undefined)\n            return 0;\n        return c.childrenStore.length;\n    };\n    const getValues = (path) => {\n        if (root === undefined)\n            return [];\n        return valuesByPath(path, root, pathOpts);\n    };\n    const getRoot = () => {\n        return root;\n    };\n    const clearValues = (path) => {\n        if (root === undefined)\n            return false;\n        return clearValuesByPath(path, root, pathOpts);\n    };\n    return { getRoot, add, prettyPrint, remove, getValue, getValues, hasPath, childrenLength, getNode, clearValues };\n};\n/**\n * Adds a value by a string path, with '.' as a the default delimiter\n * Automatically generates intermediate nodes.\n *\n * ```js\n * const root = addValueByPath({}, 'c');\n * addValueByPath({x:'blah'}, 'c.users.admin', root);\n * ```\n *\n * Creates the structure:\n * ```\n * c          value: { }            label: c\n * + users    value: undefined      label: users\n *  + admin   value: { x: 'blah' }  label: admin\n * ```\n *\n * By default, multiple values under same key are overwritten, with the most recent winning.\n * @param value\n * @param path\n * @param pathOpts\n */\nexport const addValueByPath = (value, path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const duplicatePath = pathOpts.duplicates ?? `overwrite`;\n    const split = path.split(separator);\n    let count = 0;\n    for (const p of split) {\n        const lastEntry = count === split.length - 1;\n        //onsole.log(`p: ${ p }`);\n        const found = findChildByLabel(p, node);\n        if (found === undefined) {\n            //onsole.log(`  - not found`);\n            const labelled = {\n                value: (lastEntry ? value : undefined),\n                label: p\n            };\n            node = TreeArrayBacked.createNode(labelled, node);\n        }\n        else {\n            node = found;\n            if (lastEntry) {\n                switch (duplicatePath) {\n                    case `ignore`: {\n                        break;\n                    }\n                    case `allow`: {\n                        const existing = getValuesFromNode(node);\n                        node.value = {\n                            values: [...existing, value],\n                            label: p\n                        };\n                        break;\n                    }\n                    case `overwrite`: {\n                        node.value = {\n                            value,\n                            label: p\n                        };\n                        break;\n                    }\n                }\n            }\n            else {\n                //onsole.log(`  - found!`, found.value);\n                node = found;\n            }\n        }\n        count++;\n    }\n    if (node === undefined)\n        throw new Error(`Could not create tree`);\n    return node;\n};\nexport const removeByPath = (path, root, pathOpts = {}) => {\n    if (root === undefined)\n        return false;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined)\n        return false;\n    TreeArrayBacked.remove(c);\n    return true;\n};\nexport const clearValuesByPath = (path, root, pathOpts = {}) => {\n    if (root === undefined)\n        return false;\n    const c = findChildByPath(path, root, pathOpts);\n    if (c === undefined)\n        return false;\n    c.value = {\n        label: c.value?.label ?? ``,\n        value: undefined\n    };\n    return true;\n};\nexport const childrenLengthByPath = (path, node, pathOpts = {}) => {\n    if (node === undefined)\n        return 0;\n    const c = findChildByPath(path, node, pathOpts);\n    if (c === undefined)\n        return 0;\n    return c.childrenStore.length;\n};\n/**\n * Searches direct children, returning the node that has the given `label`\n * @param label\n * @returns\n */\nconst findChildByLabel = (label, node) => {\n    if (node === undefined)\n        return undefined;\n    if (label === undefined)\n        throw new Error(`Parameter 'label' cannot be undefined`);\n    if (node.value?.label === label)\n        return node;\n    for (const c of node.childrenStore) {\n        if (c.value?.label === label)\n            return c;\n    }\n};\nexport const valueByPath = (path, node, pathOpts = {}) => {\n    const values = valuesByPath(path, node, pathOpts);\n    if (values.length === 0)\n        return undefined;\n    if (values.length > 1)\n        throw new Error(`Multiple values at path. Use getValues instead`);\n    return values[0];\n};\nconst getValuesFromNode = (c) => {\n    if (c.value === undefined)\n        return [];\n    if (`values` in c.value)\n        return c.value.values;\n    if (`value` in c.value) {\n        if (c.value.value === undefined)\n            return [];\n        return [c.value.value];\n    }\n    return [];\n};\nconst findChildByPath = (path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const split = path.split(separator);\n    let c = node;\n    for (const p of split) {\n        c = findChildByLabel(p, c);\n        if (c === undefined) {\n            return;\n        }\n    }\n    return c;\n};\nexport const valuesByPath = (path, node, pathOpts = {}) => {\n    const separator = pathOpts.separator ?? `.`;\n    const split = path.split(separator);\n    let c = node;\n    for (const p of split) {\n        //onsole.log(`getValue p: ${ p }`);\n        c = findChildByLabel(p, c);\n        if (c === undefined) {\n            //onsole.log(`getValue  - could not find. node: ${ JSON.stringify(node.value) }`);\n            return [];\n        }\n    }\n    return getValuesFromNode(c);\n};\n","import { toStringAbbreviate } from \"@ixfx/core/text\";\nimport { isEqualDefault } from \"@ixfx/core\"; //\"../../util/IsEqual.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { isTraversable } from \"./index.js\";\nexport const childrenLength = (tree) => {\n    return [...tree.children()].length;\n};\n/**\n * Returns _true_ if `child` is parented at any level (grand-parented etc) by `possibleParent`\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param eq Equality comparison function {@link isEqualDefault} used by default\n * @returns\n */\nexport const hasAnyParent = (child, possibleParent, eq) => {\n    return hasParent(child, possibleParent, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const hasAnyParentValue = (child, possibleParentValue, eq) => {\n    if (typeof child === `undefined`)\n        throw new TypeError(`Param 'child' is undefined`);\n    return hasParentValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const findAnyParentByValue = (child, possibleParentValue, eq) => {\n    return findParentByValue(child, possibleParentValue, eq, Number.MAX_SAFE_INTEGER);\n};\n/**\n * Returns _true_ if `child` exists within `possibleParent`. By default it only looks at the immediate\n * parent (maxDepth: 0). Use Number.MAX_SAFE_INTEGER for searching recursively upwards (or {@link hasAnyParent})\n * @param child Child being sought\n * @param possibleParent Possible parent of child\n * @param maxDepth Max depth of traversal. Default of 0 only looks for immediate parent.\n * @param eq Equality comparison function. {@link isEqualDefault} used by default.\n * @returns\n */\nexport const hasParent = (child, possibleParent, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    const isChildTrav = isTraversable(child);\n    const isParentTrav = isTraversable(possibleParent);\n    const p = (isChildTrav ? child.getParent() : child.parent);\n    if (typeof p === `undefined`)\n        return false;\n    if (eq(p, possibleParent))\n        return true;\n    const pId = isChildTrav ? p.getIdentity() : p.value;\n    const ppId = isParentTrav ? (possibleParent).getIdentity() : possibleParent.value;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    if (eq(pId, ppId))\n        return true;\n    //if (eq(p.getIdentity(), possibleParent.getIdentity())) return true;\n    return hasParent(p, possibleParent, eq, maxDepth - 1);\n};\n/**\n * Checks if a child node has a parent with a certain value\n * Note: by default only checks immediate parent. Set maxDepth to a large value to recurse\n *\n * Uses `getValue()` on the parent if that function exists.\n * @param child Node to start looking from\n * @param possibleParentValue Value to seek\n * @param eq Equality checker\n * @param maxDepth Defaults to 0, so it only checks immediate parent\n * @returns\n */\nexport const hasParentValue = (child, possibleParentValue, eq = (isEqualDefault), maxDepth = 0) => {\n    if (child === undefined)\n        throw new Error(`Param 'child' is undefined`);\n    if (maxDepth < 0) {\n        return false;\n    }\n    const p = `getParent` in child ? child.getParent() : child.parent;\n    if (p === undefined) {\n        return false;\n    }\n    const value = `getValue` in p ? p.getValue() : p.value;\n    if (eq(value, possibleParentValue))\n        return true;\n    return hasParentValue(p, possibleParentValue, eq, maxDepth - 1);\n};\nexport const findParentByValue = (child, possibleParentValue, eq = (isEqualDefault), maxDepth = 0) => {\n    if (maxDepth < 0)\n        return;\n    const p = (`getParent` in child ? child.getParent() : child.parent);\n    if (p === undefined)\n        return;\n    const value = `getValue` in p ? p.getValue() : p.value;\n    if (eq(value, possibleParentValue))\n        return p;\n    return findParentByValue(p, possibleParentValue, eq, maxDepth - 1);\n};\n/**\n * Returns _true_ if `prospectiveChild` can be legally added to `parent`.\n * _False_ is returned if:\n *  * `parent` and `prospectiveChild` are equal\n *  * `parent` already contains `prospectiveChild`\n *  * `prospectiveChild` has `parent` as its own child\n *\n * Throws an error if `parent` or `prospectiveChild` is null/undefined.\n * @param parent Parent to add to\n * @param prospectiveChild Prospective child\n * @param eq Equality function\n */\nexport const couldAddChild = (parent, prospectiveChild, eq = isEqualDefault) => {\n    if (eq(parent, prospectiveChild))\n        throw new Error(`Child equals parent`);\n    if (hasAnyChild(parent, prospectiveChild, eq)) {\n        throw new Error(`Circular. Parent already has child`);\n    }\n    if (hasAnyChild(prospectiveChild, parent, eq)) {\n        throw new Error(`Prospective child has parent as child relation`);\n    }\n};\n/**\n * Returns _true_ if _possibleChild_ is contained within _parent_ tree.\n * That is, it is any sub-child.\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasAnyChild = (parent, possibleChild, eq = isEqualDefault) => {\n    return hasChild(parent, possibleChild, eq, Number.MAX_SAFE_INTEGER);\n};\nexport const hasAnyChildValue = (parent, possibleChildValue, eq = isEqualDefault) => {\n    return hasChildValue(parent, possibleChildValue, eq, Number.MAX_SAFE_INTEGER);\n};\n/**\n * Returns _true_ if _possibleChild_ is contained within _maxDepth_ children\n * of _parent_ node. By default only looks at immediate children (maxDepth = 0).\n *\n * ```js\n * // Just check parentNode for childNode\n * Trees.hasChild(parentNode, childNode);\n * // See if parentNode or parentNode's parents have childNode\n * Trees.hasChild(parentNode, childNode, 1);\n * // Use custom equality function, in this case comparing on name field\n * Trees.hasChild(parentNode, childNode, 0, (a, b) => a.name === b.name);\n * ```\n * @param parent Parent tree\n * @param possibleChild Sought child\n * @param maxDepth Maximum depth. 0 for immediate children, Number.MAX_SAFE_INTEGER for boundless\n * @param eq Equality function, or {@link isEqualDefault} if undefined.\n * @returns\n */\nexport const hasChild = (parent, possibleChild, eq = isEqualDefault, maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    if (eq(parent, possibleChild))\n        return true;\n    const pId = `getIdentity` in parent ? parent.getIdentity() : parent.value;\n    const pcId = `getIdentity` in possibleChild ? possibleChild.getIdentity() : possibleChild.value;\n    if (eq(pId, pcId))\n        return true;\n    for (const c of breadthFirst(parent, maxDepth)) {\n        const cId = `getIdentity` in c ? c.getIdentity() : c.value;\n        if (eq(c, possibleChild))\n            return true;\n        if (eq(cId, pcId))\n            return true;\n    }\n    return false;\n};\nexport const hasChildValue = (parent, possibleValue, eq = isEqualDefault, maxDepth = 0) => {\n    if (maxDepth < 0)\n        return false;\n    if (eq(parent.getValue(), possibleValue))\n        return true;\n    for (const c of breadthFirst(parent, maxDepth)) {\n        const v = c.getValue();\n        if (eq(v, possibleValue))\n            return true;\n    }\n    return false;\n};\n/**\n * Iterates over siblings of `node`.\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns\n */\nexport function* siblings(node) {\n    const p = node.getParent();\n    if (p === undefined)\n        return;\n    for (const s of p.children()) {\n        if (s === node)\n            continue;\n        yield s;\n    }\n}\n// export function parents<T>(node: TreeNode<T>): IterableIterator<TreeNode<T>>;\n// export function parents<T>(node: TraversableTree<T>): IterableIterator<TraversableTree<T>>;\n/**\n * Iterates over parents of `node`, starting with immediate parent\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param node Node to begin from\n * @returns\n */\nexport function* parents(node) {\n    if (isTraversable(node)) {\n        let p = node.getParent();\n        while (p !== undefined) {\n            yield p;\n            p = p.getParent();\n        }\n    }\n    else {\n        let p = node.parent;\n        while (p !== undefined) {\n            yield p;\n            p = p.parent;\n        }\n    }\n}\n// export function findAnyChildByValue<TValue>(parent: TraversableTree<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TraversableTree<TValue> | undefined;\n// export function findAnyChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>\n// ): TreeNode<TValue> | undefined;\n/**\n * Descends `parent`, breadth-first, looking for a particular value.\n * Returns _undefined_ if not found.\n * @param parent\n * @param possibleValue\n * @param eq\n * @returns\n */\nexport function findAnyChildByValue(parent, possibleValue, eq = isEqualDefault) {\n    return findChildByValue(parent, possibleValue, eq, Number.MAX_SAFE_INTEGER);\n}\n;\n// export function findChildByValue<T extends TraversableTree<TV> | TreeNode<TV>, TV>(parent: T,\n//   possibleValue: TV,\n//   eq?: IsEqual<TV>,\n//   maxDepth?: number\n// ): TraversableTree<TV> | undefined;\n// export function findChildByValue<TValue>(parent: TreeNode<TValue>,\n//   possibleValue: TValue,\n//   eq?: IsEqual<TValue>,\n//   maxDepth?: number\n// ): TreeNode<TValue> | undefined;\n/**\n * Searches breadth-first for `possibleValue` under and including `parent`.\n * `maxDepth` sets he maximum level to which the tree is searched.\n * @param parent\n * @param possibleValue\n * @param eq\n * @param maxDepth\n * @returns\n */\nexport function findChildByValue(parent, possibleValue, eq = isEqualDefault, maxDepth = 0) {\n    if (maxDepth < 0)\n        return;\n    const isTraver = isTraversable(parent);\n    if (isTraver) {\n        if (eq(parent.getValue(), possibleValue))\n            return parent;\n    }\n    else {\n        if (eq(parent.value, possibleValue))\n            return parent;\n    }\n    for (const d of breadthFirst(parent, maxDepth)) {\n        // This child matches\n        if (isTraver) {\n            if (eq(d.getValue(), possibleValue))\n                return d;\n        }\n        else {\n            if (eq(d.value, possibleValue))\n                return d;\n        }\n    }\n    return;\n}\n;\n/**\n * Iterates over children of `root`, depth-first.\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n * @param root Root node\n * @returns\n */\nexport function* depthFirst(root) {\n    if (!root)\n        return;\n    const stack = new StackMutable();\n    let entry = root;\n    while (entry) {\n        const entries = isTraversable(entry) ?\n            [...entry.children()] :\n            [...entry.childrenStore];\n        stack.push(...entries);\n        if (stack.isEmpty)\n            break;\n        entry = stack.pop();\n        if (entry)\n            yield entry;\n    }\n}\n//export function breadthFirst<T>(root: TraversableTree<T>, depth?: number): IterableIterator<TraversableTree<T>>;\n//export function breadthFirst<T>(root: TreeNode<T>, depth?: number): IterableIterator<TreeNode<T>>;\n/**\n * Iterates over the children of `root`, breadth-first\n *\n * Other iteration options:\n * * {@link breadthFirst}: Children, breadth-first\n * * {@link depthFirst}: Children, depth-first\n * * {@link parents}: Chain of parents, starting with immediate parent\n * * {@link siblings}: Nodes with same parent\n *\n * @example Traversing over a simple object\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const myObj = { name: `Pedro`, size: 45, colour: `orange` };\n * const root = Trees.FromObject.asDynamicTraversable(myObj);\n * for (const v of Trees.Traverse.breadthFirst(root)) {\n * // v.getValue() yields:\n * // { name: 'name', sourceValue: 'Pedro' ...},\n * // { name: 'size', sourceValue: 45 ... }\n * // ...\n * }\n * ```\n * @param root Root node\n * @param depth How many levels to traverse\n * @returns\n */\nexport function* breadthFirst(root, depth = Number.MAX_SAFE_INTEGER) {\n    if (!root)\n        return;\n    const isTrav = isTraversable(root);\n    const queue = isTrav ? new QueueMutable() : new QueueMutable();\n    let entry = root;\n    while (entry) {\n        if (depth < 0)\n            return;\n        if (entry !== undefined) {\n            const kids = `childrenStore` in entry ? entry.childrenStore : entry.children();\n            for (const c of kids) {\n                yield c;\n                queue.enqueue(c);\n            }\n        }\n        entry = queue.dequeue();\n        depth--;\n    }\n}\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node where\n * `predicate` yields _true_.\n * Use {@link findByValue} to find a node by its value\n * @param root\n * @param predicate\n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns\n */\nexport function find(root, predicate, order = `breadth`) {\n    if (predicate(root))\n        return root;\n    const iter = order === `breadth` ? breadthFirst : depthFirst;\n    for (const c of iter(root)) {\n        if (predicate(c))\n            return c;\n    }\n}\n/**\n * Applies `predicate` to `root` and all its child nodes, returning the node value for\n * `predicate` yields _true_.\n * Use {@link find} to filter by nodes rather than values\n *\n * ```js\n * const n = findByValue(root, (v) => v.name === 'Bob');\n * ```\n * @param root\n * @param predicate\n * @param order Iterate children by breadth or depth. Default 'breadth'\n * @returns\n */\nexport function findByValue(root, predicate, order = `breadth`) {\n    if (predicate(root.getValue()))\n        return root;\n    const iter = order === `breadth` ? breadthFirst : depthFirst;\n    for (const c of iter(root)) {\n        if (predicate(c.getValue()))\n            return c;\n    }\n}\n/**\n * Search through children in a path-like manner.\n *\n * It finds the first child of `root` that matches `continuePredicate`.\n * The function gets passed a depth of 1 to begin with. It recurses, looking for the next sub-child, etc.\n *\n * If it can't find a child, it stops.\n *\n * This is different to 'find' functions, which exhaustively search all possible child nodes, regardless of position in tree.\n *\n * ```js\n * const path = 'a.aa.aaa'.split('.');\n * const pred = (nodeValue, depth) => {\n *  if (nodeValue === path[0]) {\n *    path.shift(); // Remove first element\n *    return true;\n *  }\n *  return false;\n * }\n *\n * // Assuming we have a tree of string values:\n * // a\n * //   - aa\n * //       - aaa\n * //   - ab\n * // b\n * //   - ba\n * for (const c of follow(tree, pred)) {\n *  // Returns nodes: a, aa and then aaa\n * }\n * ```\n * @param root\n * @param continuePredicate\n * @param depth\n */\nexport function* followValue(root, continuePredicate, depth = 1) {\n    for (const c of root.children()) {\n        if (continuePredicate(c.getValue(), depth)) {\n            yield c.getValue();\n            yield* followValue(c, continuePredicate, depth + 1);\n        }\n    }\n}\nexport function toStringDeep(node, depth = 0) {\n    if (node === undefined)\n        return `(undefined)`;\n    if (node === null)\n        return `(null)`;\n    const v = node.getValue();\n    let type = typeof v;\n    if (Array.isArray(v))\n        type = `array`;\n    let t = `  `.repeat(depth) + `value: ${JSON.stringify(v)} (${type})\\n`;\n    for (const n of node.children()) {\n        t += toStringDeep(n, depth + 1);\n    }\n    return t;\n}\nexport function toString(...nodes) {\n    let t = ``;\n    for (const node of nodes) {\n        const v = node.getValue();\n        const vString = toStringAbbreviate(v);\n        const children = [...node.children()];\n        const parent = node.getParent();\n        let type = typeof v;\n        if (Array.isArray(v))\n            type = `array`;\n        t += `value: ${vString} (${type}) kids: ${children.length} parented: ${parent ? `y` : `n`}\\n`;\n    }\n    return t;\n}\n","import { asDynamicTraversable as ObjectToTraversable } from './traverse-object.js';\nimport { asDynamicTraversable as TreeNodeToTraversable } from './tree-mutable.js';\nexport * as Mutable from './tree-mutable.js';\nexport * as Pathed from './pathed.js';\nexport * as FromObject from './traverse-object.js';\nexport * as Traverse from './traversable-tree.js';\nexport * from './compare.js';\n/**\n * Makes a 'traversable' to move around a {@link TreeNode}, an existing {@link TraversableTree} or a plain object.\n *\n * @param node\n * @returns\n */\nexport const toTraversable = (node) => {\n    if (isTraversable(node))\n        return node;\n    if (isTreeNode(node))\n        return TreeNodeToTraversable(node);\n    if (typeof node === `object`)\n        return ObjectToTraversable(node);\n    throw new Error(`Parameter 'node' not convertible`);\n};\n/**\n * Checks whether `node` is of type {@link TreeNode}.\n *\n * Checks for: parent, childrenStore and value defined on `node`.\n * @param node\n * @returns\n */\nexport const isTreeNode = (node) => {\n    if (`parent` in node && `childrenStore` in node && `value` in node) {\n        if (Array.isArray(node.childrenStore))\n            return true;\n    }\n    return false;\n};\n/**\n * Checks if `node` is of type {@link TraversableTree}.\n *\n * Checks by looking for: children, getParent, getValue and getIdentity defined on `node`.\n * @param node\n * @returns\n */\nexport const isTraversable = (node) => {\n    return (`children` in node && `getParent` in node && `getValue` in node && `getIdentity` in node);\n};\n","import { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nexport class StackImmutable {\n    opts;\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    push(...toAdd) {\n        return new StackImmutable(this.opts, push(this.opts, this.data, ...toAdd));\n    }\n    pop() {\n        return new StackImmutable(this.opts, pop(this.opts, this.data));\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = (options = {}, ...startingItems) => new StackImmutable({ ...options }, [...startingItems]);\n","export * from './IStack.js';\nexport * from './IStackMutable.js';\nexport * from './IStackImmutable.js';\nexport * from './StackImmutable.js';\nexport * from './StackMutable.js';\nexport * from './StackFns.js';\n","// ✔ UNIT TESTED\nimport { defaultKeyer } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\nimport {} from './ISetMutable.js';\nimport {} from './Types.js';\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = (keyString) => new SetStringMutable(keyString);\n/**\n * Mutable string set\n */\nexport class SetStringMutable extends SimpleEventEmitter {\n    // ✔ UNIT TESTED\n    /* eslint-disable functional/prefer-readonly-type */\n    store = new Map();\n    keyString;\n    /**\n     * Constructor\n     * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n     */\n    constructor(keyString) {\n        super();\n        this.keyString = keyString ?? (defaultKeyer);\n    }\n    /**\n     * Number of items stored in set\n     */\n    get size() {\n        return this.store.size;\n    }\n    /**\n     * Adds one or more items to set. `add` event is fired for each item\n     * @param values items to add\n     */\n    add(...values) {\n        //eslint-disable-next-line functional/no-let\n        let somethingAdded = false;\n        for (const value of values) {\n            const isUpdated = this.has(value);\n            this.store.set(this.keyString(value), value);\n            super.fireEvent(`add`, { value: value, updated: isUpdated });\n            if (!isUpdated)\n                somethingAdded = true;\n        }\n        return somethingAdded;\n    }\n    /**\n     * Returns values from set as an iterable\n     * @returns\n     */\n    //eslint-disable-next-line functional/prefer-tacit\n    values() {\n        return this.store.values();\n    }\n    /**\n     * Clear items from set\n     */\n    clear() {\n        this.store.clear();\n        super.fireEvent(`clear`, true);\n    }\n    /**\n     * Delete value from set.\n     * @param v Value to delete\n    * @returns _True_ if item was found and removed\n     */\n    delete(v) {\n        const isDeleted = this.store.delete(this.keyString(v));\n        if (isDeleted)\n            super.fireEvent(`delete`, v);\n        return isDeleted;\n    }\n    /**\n     * Returns _true_ if item exists in set\n     * @param v\n     * @returns\n     */\n    has(v) {\n        return this.store.has(this.keyString(v));\n    }\n    /**\n     * Returns array copy of set\n     * @returns Array copy of set\n     */\n    toArray() {\n        return [...this.store.values()];\n    }\n}\n","import { defaultKeyer, toStringDefault } from '@ixfx/core';\nimport {} from './ISetImmutable.js';\nexport class SetStringImmutable {\n    store;\n    keyString;\n    //eslint-disable-next-line functional/prefer-immutable-types\n    constructor(keyString, map) {\n        this.store = map ?? new Map();\n        this.keyString = keyString ?? (defaultKeyer);\n    }\n    get size() {\n        return this.store.size;\n    }\n    add(...values) {\n        const s = new Map(this.store);\n        for (const v of values) {\n            const key = this.keyString(v);\n            s.set(key, v);\n        }\n        return new SetStringImmutable(this.keyString, s);\n    }\n    delete(v) {\n        const s = new Map(this.store);\n        const key = this.keyString(v);\n        if (s.delete(key))\n            return new SetStringImmutable(this.keyString, s);\n        return this;\n    }\n    has(v) {\n        const key = this.keyString(v);\n        return this.store.has(key);\n    }\n    toArray() {\n        return [...this.store.values()];\n    }\n    *values() {\n        yield* this.store.values();\n    }\n}\n/**\n * Immutable set that uses a `keyString` function to determine uniqueness\n *\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`.\n * @returns\n */\nexport const immutable = (keyString = toStringDefault) => new SetStringImmutable(keyString);\n","/**\n * MassiveSet supports semantics similar to Set, but without the\n * limitation on how much data is stored.\n *\n * It only supports strings, and stores data in a hierarchy.\n *\n * ```js\n * const set = new MassiveSet(); // maxDepth=1 default\n * set.add(`test`);\n * set.add(`bloorp`);\n * ```\n *\n * In the above example, it will create a subtree for the first letter\n * of each key, putting the value underneath it. So we'd get a sub\n * MassiveSet for every key starting with 't' and every one starting with 'b'.\n *\n * If `maxDepth` was 2, we'd get the same two top-level nodes, but then\n * another sub-node based on the _second_ character of the value.\n *\n * It's not a very smart data-structure since it does no self-balancing\n * or tuning.\n */\nexport class MassiveSet {\n    #depth;\n    #maxDepth;\n    children = new Map();\n    values = [];\n    constructor(maxDepth = 1, depth = 0) {\n        this.#depth = depth;\n        this.#maxDepth = maxDepth;\n    }\n    /**\n     * Returns the number of values stored in just this level of the set\n     * @returns\n     */\n    sizeLocal() {\n        return this.values.length;\n    }\n    /**\n     * Returns the number of branches at this node\n     * Use {@link sizeChildrenDeep} to count all branches recursively\n     * @returns\n     */\n    sizeChildren() {\n        return [...this.children.values()].length;\n    }\n    sizeChildrenDeep() {\n        let t = this.sizeChildren();\n        for (const c of this.children.values()) {\n            t += c.sizeChildrenDeep();\n        }\n        return t;\n    }\n    /**\n     * Returns the total number of values stored in the set\n     */\n    size() {\n        let x = this.values.length;\n        for (const set of this.children.values()) {\n            x += set.size();\n        }\n        return x;\n    }\n    add(value) {\n        if (typeof value !== `string`)\n            throw new Error(`Param 'value' must be a string. Got: ${typeof value}`);\n        if (value.length === 0)\n            throw new Error(`Param 'value' is empty`);\n        const destination = this.#getChild(value, true);\n        if (destination === this) {\n            if (!this.hasLocal(value)) {\n                this.values.push(value);\n            }\n            return;\n        }\n        if (!destination)\n            throw new Error(`Could not create child set for: ${value}`);\n        destination.add(value);\n    }\n    remove(value) {\n        if (typeof value !== `string`)\n            throw new Error(`Param 'value' must be a string. Got: ${typeof value}`);\n        if (value.length === 0)\n            throw new Error(`Param 'value' is empty`);\n        const destination = this.#getChild(value, false);\n        if (destination === undefined)\n            return false;\n        if (destination === this) {\n            if (this.hasLocal(value)) {\n                this.values = this.values.filter(v => v !== value);\n                return true;\n            }\n            return false; // Not found\n        }\n        return destination.remove(value);\n    }\n    debugDump() {\n        const r = this.#dumpToArray();\n        for (const rr of r) {\n            console.log(rr);\n        }\n    }\n    #dumpToArray(depth = 0) {\n        const r = [];\n        r.push(`Depth: ${this.#depth} Max: ${this.#maxDepth}`);\n        for (const [key, value] of this.children.entries()) {\n            const dumped = value.#dumpToArray(depth + 1);\n            r.push(` key: ${key}`);\n            for (const d of dumped) {\n                r.push(` `.repeat(depth + 1) + d);\n            }\n        }\n        r.push(`Values: (${this.values.length})`);\n        for (const v of this.values) {\n            r.push(` ${v}`);\n        }\n        return r.map(line => ` `.repeat(depth) + line);\n    }\n    #getChild(value, create) {\n        if (value === undefined)\n            throw new Error(`Param 'value' undefined`);\n        if (this.#depth === this.#maxDepth)\n            return this;\n        if (value.length <= this.#depth)\n            return this;\n        const k = value[this.#depth];\n        if (k === undefined)\n            throw new Error(`Logic error. Depth: ${this.#depth} Len: ${value.length}`);\n        let child = this.children.get(k);\n        if (child === undefined && create) {\n            child = new MassiveSet(this.#maxDepth, this.#depth + 1);\n            this.children.set(k, child);\n        }\n        return child;\n    }\n    /**\n     * Returns _true_ if `value` stored on this node\n     * @param value\n     * @returns\n     */\n    hasLocal(value) {\n        for (const v of this.values) {\n            if (v === value)\n                return true;\n        }\n        return false;\n    }\n    has(value) {\n        if (typeof value !== `string`)\n            return false;\n        const destination = this.#getChild(value, false);\n        if (destination === undefined)\n            return false;\n        if (destination === this)\n            return this.hasLocal(value);\n        return destination.has(value);\n    }\n}\n","export * from './set-mutable.js';\nexport * from './SetImmutable.js';\nexport {} from './ISetMutable.js';\nexport {} from './ISetImmutable.js';\nexport * from './massive-set.js';\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { isEqualDefault } from \"@ixfx/core\";\nimport { max as IterablesMax, min as IterablesMin, last as IterablesLast } from \"@ixfx/iterables\";\nimport { QueueMutable } from \"./queue-mutable.js\";\n/**\n * Simple priority queue implementation.\n * Higher numbers mean higher priority.\n *\n * ```js\n * const pm = new PriorityMutable();\n *\n * // Add items with a priority (higher numeric value = higher value)\n * pm.enqueueWithPriority(`hello`, 4);\n * pm.enqueueWithPriotity(`there`, 1);\n *\n * ```\n */\nexport class PriorityMutable extends QueueMutable {\n    constructor(opts = {}) {\n        if (opts.eq === undefined) {\n            opts = {\n                ...opts,\n                eq: (a, b) => {\n                    return isEqualDefault(a.item, b.item);\n                }\n            };\n        }\n        super(opts);\n    }\n    /**\n     * Adds an item with a given priority\n     * @param item Item\n     * @param priority Priority (higher numeric value means higher priority)\n     */\n    enqueueWithPriority(item, priority) {\n        resultThrow(numberTest(priority, `positive`));\n        super.enqueue({ item, priority });\n    }\n    changePriority(item, priority, addIfMissing = false, eq) {\n        if (item === undefined)\n            throw new Error(`Item cannot be undefined`);\n        let toDelete;\n        for (const d of this.data) {\n            if (eq) {\n                if (eq(d.item, item)) {\n                    toDelete = d;\n                    break;\n                }\n            }\n            else {\n                if (this.eq(d, { item, priority: 0 })) {\n                    toDelete = d;\n                    break;\n                }\n            }\n        }\n        if (toDelete === undefined && !addIfMissing)\n            throw new Error(`Item not found in priority queue. Item: ${JSON.stringify(item)}`);\n        if (toDelete !== undefined) {\n            this.removeWhere(item => toDelete === item);\n        }\n        this.enqueueWithPriority(item, priority);\n    }\n    dequeueMax() {\n        //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        this.removeWhere(item => item === m);\n        return m.item;\n    }\n    dequeueMin() {\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        //const m = IterablesLast(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        this.removeWhere(item => item.item === m);\n        return m.item;\n    }\n    peekMax() {\n        const m = IterablesLast(IterablesMax(this.data, (a, b) => a.priority >= b.priority));\n        //const m = IterablesLast(IterablesMax(this.data, v => v.priority));\n        if (m === undefined)\n            return;\n        return m.item;\n    }\n    peekMin() {\n        //const m = IterablesLast<V>(IterablesMin(this.data, (a,b) => a.priority >= b.priority));\n        const m = IterablesLast(IterablesMin(this.data, (a, b) => a.priority >= b.priority));\n        if (m === undefined)\n            return;\n        return m.item;\n    }\n}\n/**\n * Creates a {@link PriorityMutable} queue.\n *\n * Options:\n * * eq: Equality function\n * * capacity: limit on number of items\n * * discardPolicy: what to do if capacity is reached\n * @param opts\n * @returns\n */\nexport function priority(opts = {}) {\n    return new PriorityMutable(opts);\n}\n","import { peek, isFull, isEmpty, enqueue, dequeue } from './queue-fns.js';\nimport {} from './queue-types.js';\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable {\n    opts;\n    #data;\n    /**\n     * Creates an instance of Queue.\n     * @param {QueueOpts} opts Options foor queue\n     * @param {V[]} data Initial data. Index 0 is front of queue\n     */\n    constructor(opts = {}, data = []) {\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.opts = opts;\n        this.#data = data;\n    }\n    forEach(fn) {\n        //eslint-disable-next-line functional/no-let\n        for (let index = this.#data.length - 1; index >= 0; index--) {\n            fn(this.#data[index]);\n        }\n    }\n    forEachFromFront(fn) {\n        // From front of queue\n        this.#data.forEach(item => { fn(item); }); //(vv) => fn(vv));\n    }\n    enqueue(...toAdd) {\n        return new QueueImmutable(this.opts, enqueue(this.opts, this.#data, ...toAdd));\n    }\n    dequeue() {\n        return new QueueImmutable(this.opts, dequeue(this.opts, this.#data));\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.#data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.#data);\n    }\n    get length() {\n        return this.#data.length;\n    }\n    get peek() {\n        return peek(this.opts, this.#data);\n    }\n    toArray() {\n        return [...this.#data];\n    }\n}\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @typeParam V - Type of values stored\n * @param options\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = (options = {}, ...startingItems) => {\n    options = { ...options }; // Make a copy of options\n    return new QueueImmutable(options, [...startingItems]); // Make a copy of array so it can't be modified\n};\n","export * from './priority-mutable.js';\nexport { immutable, QueueImmutable } from './queue-immutable.js';\nexport { mutable, QueueMutable } from './queue-mutable.js';\n//export * from './Responsive.js';\nexport * from './queue-fns.js';\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { sortByValueProperty } from '@ixfx/core/maps';\nimport { intervalToMs } from '@ixfx/core';\nimport { integerTest, resultThrow } from '@ixfx/guards';\n/**\n * Create a ExpiringMap instance\n * @param options Options when creating map\n * @returns\n */\nexport const create = (options = {}) => new ExpiringMap(options);\n/***\n * A map that can have a capacity limit. The elapsed time for each get/set\n * operation is maintained allowing for items to be automatically removed.\n * `has()` does not affect the last access time.\n *\n * By default, it uses the `none` eviction policy, meaning that when full\n * an error will be thrown if attempting to add new keys.\n *\n * Eviction policies:\n * `oldestGet` removes the item that hasn't been accessed the longest,\n * `oldestSet` removes the item that hasn't been updated the longest.\n *\n * ```js\n * const map = new ExpiringMap();\n * map.set(`fruit`, `apple`);\n *\n * // Remove all entries that were set more than 100ms ago\n * map.deleteWithElapsed(100, `set`);\n * // Remove all entries that were last accessed more than 100ms ago\n * map.deleteWithElapsed(100, `get`);\n * // Returns the elapsed time since `fruit` was last accessed\n * map.elapsedGet(`fruit`);\n * // Returns the elapsed time since `fruit` was last set\n * map.elapsedSet(`fruit`);\n * ```\n *\n * Last set/get time for a key can be manually reset using {@link touch}.\n *\n *\n * Events:\n * * 'expired': when an item is automatically removed.\n * * 'removed': when an item is manually or automatically removed.\n * * 'newKey': when a new key is added\n *\n * ```js\n * map.addEventListener(`expired`, evt => {\n *  const { key, value } = evt;\n * });\n * ```\n * The map can automatically remove items based on elapsed intervals.\n *\n * @example\n * Automatically delete items that haven't been accessed for one second\n * ```js\n * const map = new ExpiringMap({\n *  autoDeleteElapsed: 1000,\n *  autoDeletePolicy: `get`\n * });\n * ```\n *\n * @example\n * Automatically delete the oldest item if we reach a capacity limit\n * ```js\n * const map = new ExpiringMap({\n *  capacity: 5,\n *  evictPolicy: `oldestSet`\n * });\n * ```\n * @typeParam K - Type of keys\n * @typeParam V - Type of values\n */\nexport class ExpiringMap extends SimpleEventEmitter {\n    capacity;\n    store;\n    //private keyCount: number;\n    evictPolicy;\n    autoDeleteElapsedMs;\n    autoDeletePolicy;\n    autoDeleteTimer;\n    disposed = false;\n    constructor(opts = {}) {\n        super();\n        this.capacity = opts.capacity ?? -1;\n        resultThrow(integerTest(this.capacity, `nonZero`, `capacity`));\n        this.store = new Map();\n        //this.keyCount = 0;\n        if (opts.evictPolicy && this.capacity <= 0) {\n            throw new Error(`evictPolicy is set, but no capacity limit is set`);\n        }\n        this.evictPolicy = opts.evictPolicy ?? `none`;\n        this.autoDeleteElapsedMs = opts.autoDeleteElapsedMs ?? -1;\n        this.autoDeletePolicy = opts.autoDeletePolicy ?? `none`;\n        if (this.autoDeleteElapsedMs > 0) {\n            this.autoDeleteTimer = setInterval(() => { this.#maintain(); }, Math.max(1000, this.autoDeleteElapsedMs * 2));\n        }\n    }\n    dispose() {\n        if (this.disposed)\n            return;\n        this.disposed = true;\n        if (this.autoDeleteTimer) {\n            clearInterval(this.autoDeleteTimer);\n            this.autoDeleteTimer = undefined;\n        }\n    }\n    /**\n     * Returns the number of keys being stored.\n     */\n    get keyLength() {\n        return this.store.size; // keyCount;\n    }\n    *entries() {\n        for (const entry of this.store.entries()) {\n            yield [entry[0], entry[1].value];\n        }\n    }\n    *values() {\n        for (const v of this.store.values()) {\n            yield v.value;\n        }\n    }\n    *keys() {\n        yield* this.store.keys();\n    }\n    /**\n     * Returns the elapsed time since `key`\n     * was set. Returns _undefined_ if `key`\n     * does not exist\n     */\n    elapsedSet(key) {\n        const v = this.store.get(key);\n        if (typeof v === `undefined`)\n            return;\n        return Date.now() - v.lastSet;\n    }\n    /**\n     * Returns the elapsed time since `key`\n     * was accessed. Returns _undefined_ if `key`\n     * does not exist\n     */\n    elapsedGet(key) {\n        const v = this.store.get(key);\n        if (typeof v === `undefined`)\n            return;\n        return Date.now() - v.lastGet;\n    }\n    /**\n     * Returns true if `key` is stored.\n     * Does not affect the key's last access time.\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.store.has(key);\n    }\n    /**\n     * Gets an item from the map by key, returning\n     * undefined if not present\n     * @param key Key\n     * @returns Value, or undefined\n     */\n    get(key) {\n        const v = this.store.get(key);\n        if (v) {\n            if (this.autoDeletePolicy === `either` || this.autoDeletePolicy === `get`) {\n                this.store.set(key, {\n                    ...v,\n                    lastGet: performance.now(),\n                });\n            }\n            return v.value;\n        }\n    }\n    /**\n     * Deletes the value under `key`, if present.\n     *\n     * Returns _true_ if something was removed.\n     * @param key\n     * @returns\n     */\n    delete(key) {\n        const value = this.store.get(key);\n        if (!value)\n            return false;\n        const d = this.store.delete(key);\n        //this.keyCount = this.keyCount - 1;\n        this.fireEvent(`removed`, {\n            key,\n            value: value.value,\n        });\n        return d;\n    }\n    /**\n     * Clears the contents of the map.\n     * Note: does not fire `removed` event\n     */\n    clear() {\n        this.store.clear();\n    }\n    /**\n     * Updates the lastSet/lastGet time for a value\n     * under `k`.\n     *\n     * Returns false if key was not found\n     * @param key\n     * @returns\n     */\n    touch(key) {\n        const v = this.store.get(key);\n        if (!v)\n            return false;\n        this.store.set(key, {\n            ...v,\n            lastSet: Date.now(),\n            lastGet: Date.now(),\n        });\n        return true;\n    }\n    findEvicteeKey() {\n        if (this.evictPolicy === `none`)\n            return;\n        let sortBy = ``;\n        if (this.evictPolicy === `oldestGet`)\n            sortBy = `lastGet`;\n        else if (this.evictPolicy === `oldestSet`)\n            sortBy = `lastSet`;\n        else\n            throw new Error(`Unknown eviction policy ${this.evictPolicy}`);\n        const sorted = sortByValueProperty(this.store, sortBy);\n        return sorted[0][0];\n    }\n    #maintain() {\n        if (this.autoDeletePolicy === `none`)\n            return;\n        this.deleteWithElapsed(this.autoDeleteElapsedMs, this.autoDeletePolicy);\n    }\n    /**\n     * Deletes all values where elapsed time has past\n     * for get/set or either.\n     * ```js\n     * // Delete all keys (and associated values) not accessed for a minute\n     * em.deleteWithElapsed({mins:1}, `get`);\n     * // Delete things that were set 1s ago\n     * em.deleteWithElapsed(1000, `set`);\n     * ```\n     *\n     * @param interval Interval\n     * @param property Basis for deletion 'get','set' or 'either'\n     * @returns Items removed\n     */\n    deleteWithElapsed(interval, property) {\n        const entries = [...this.store.entries()];\n        const prune = [];\n        const intervalMs = intervalToMs(interval, 1000);\n        const now = performance.now();\n        for (const entry of entries) {\n            const elapsedGet = now - entry[1].lastGet;\n            const elapsedSet = now - entry[1].lastSet;\n            const elapsed = property === `get`\n                ? elapsedGet\n                : (property === `set`\n                    ? elapsedSet\n                    : Math.max(elapsedGet, elapsedSet));\n            if (elapsed >= intervalMs) {\n                prune.push([entry[0], entry[1].value]);\n            }\n        }\n        for (const entry of prune) {\n            this.store.delete(entry[0]);\n            //this.keyCount = this.keyCount - 1;\n            const eventArguments = {\n                key: entry[0],\n                value: entry[1],\n            };\n            this.fireEvent(`expired`, eventArguments);\n            this.fireEvent(`removed`, eventArguments);\n        }\n        return prune;\n    }\n    /**\n     * Sets the `key` to be `value`.\n     *\n     * If the key already exists, it is updated.\n     *\n     * If the map is full, according to its capacity,\n     * another value is selected for removal.\n     * @param key\n     * @param value\n     * @returns\n     */\n    set(key, value) {\n        const existing = this.store.get(key);\n        if (existing) {\n            // Update set time\n            this.store.set(key, {\n                ...existing,\n                lastSet: performance.now(),\n            });\n            return;\n        }\n        // New key\n        if (this.keyLength === this.capacity && this.capacity > 0) {\n            // Evict first\n            const key = this.findEvicteeKey();\n            if (!key) {\n                throw new Error(`ExpiringMap full (capacity: ${this.capacity})`);\n            }\n            const existing = this.store.get(key);\n            this.store.delete(key);\n            //this.keyCount = this.keyCount - 1;\n            if (existing) {\n                const eventArguments = { key, value: existing.value };\n                this.fireEvent(`expired`, eventArguments);\n                this.fireEvent(`removed`, eventArguments);\n            }\n        }\n        //this.keyCount++;\n        this.store.set(key, {\n            lastGet: 0,\n            lastSet: performance.now(),\n            value: value,\n        });\n        this.fireEvent(`newKey`, { key, value });\n    }\n}\n","// ✔ UNIT TESTED\nimport { isEqualDefault } from '@ixfx/core';\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = (map, predicate) => {\n    for (const e of map.entries()) {\n        const value = e[1];\n        for (const subValue of value) {\n            if (predicate(subValue, e[0]))\n                return e;\n        }\n    }\n};\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = (map) => {\n    //eslint-disable-next-line functional/no-let\n    let largest = ['', 0];\n    for (const e of map.keysAndCounts()) {\n        if (e[1] > largest[1]) {\n            largest = e;\n        }\n    }\n    return largest[1];\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const e of map.entries()) {\n        const value_ = e[1];\n        for (const subValue of value_) {\n            if (isEqual(subValue, value))\n                return e;\n        }\n    }\n};\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { firstEntryByValue } from './map-multi-fns.js';\nexport class MapOfSimpleBase {\n    map;\n    groupBy;\n    valueEq;\n    /**\n     * Constructor\n     * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n     * @param valueEq Compare values. By default uses JS logic for equality\n     */\n    constructor(groupBy = defaultKeyer, valueEq = (isEqualDefault), initial = []) {\n        this.groupBy = groupBy;\n        this.valueEq = valueEq;\n        this.map = new Map(initial);\n    }\n    /**\n     * Returns _true_ if `key` exists\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.map.has(key);\n    }\n    /**\n     * Returns _true_ if `value` exists under `key`.\n     * @param key Key\n     * @param value Value to seek under `key`\n     * @returns _True_ if `value` exists under `key`.\n     */\n    hasKeyValue(key, value) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        for (const v of values) {\n            if (this.valueEq(v, value))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Debug dump of contents\n     * @returns\n     */\n    debugString() {\n        let r = ``;\n        const keys = [...this.map.keys()];\n        keys.every((k) => {\n            const v = this.map.get(k);\n            if (v === undefined)\n                return;\n            r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\n        });\n        return r;\n    }\n    /**\n     * Return number of values stored under `key`.\n     * Returns 0 if `key` is not found.\n     * @param key\n     * @returns\n     */\n    count(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return 0;\n        return values.length;\n    }\n    /**\n   * Returns first key that contains `value`\n   * @param value\n   * @param eq\n   * @returns\n   */\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const entry = firstEntryByValue(this, value, eq);\n        if (entry)\n            return entry[0];\n    }\n    /**\n     * Iterate over all entries\n     */\n    *entriesFlat() {\n        for (const key of this.map.keys()) {\n            for (const value of this.map.get(key)) {\n                yield [key, value];\n            }\n        }\n    }\n    /**\n     * Iterate over keys and array of values for that key\n     */\n    *entries() {\n        for (const [k, v] of this.map.entries()) {\n            yield [k, [...v]];\n        }\n    }\n    /**\n     * Get all values under `key`\n     * @param key\n     * @returns\n     */\n    *get(key) {\n        const m = this.map.get(key);\n        if (!m)\n            return;\n        yield* m.values();\n    }\n    /**\n     * Iterate over all keys\n     */\n    *keys() {\n        yield* this.map.keys();\n    }\n    /**\n     * Iterate over all values (regardless of key).\n     * Use {@link values} to iterate over a set of values per key\n     */\n    *valuesFlat() {\n        for (const entries of this.map) {\n            yield* entries[1];\n        }\n    }\n    /**\n     * Yields the values for each key in sequence, returning an array.\n     * Use {@link valuesFlat} to iterate over all keys regardless of key.\n     */\n    *values() {\n        for (const entries of this.map) {\n            yield entries[1];\n        }\n    }\n    /**\n     * Iterate over keys and length of values stored under keys\n     */\n    *keysAndCounts() {\n        for (const entries of this.map) {\n            yield [entries[0], entries[1].length];\n        }\n    }\n    /**\n     * Returns the count of keys.\n     */\n    get lengthKeys() {\n        return this.map.size;\n    }\n    /**\n    * _True_ if empty\n    */\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        const existing = this.map.get(key);\n        if (existing === undefined) {\n            this.map.set(key, values);\n        }\n        else {\n            this.map.set(key, [...existing, ...values]);\n        }\n    }\n    /**\n     * Set `values` to `key`.\n     * Previous data stored under `key` is thrown away.\n     * @param key\n     * @param values\n     */\n    setValues(key, values) {\n        this.map.set(key, values);\n    }\n    /**\n     * Adds a value, automatically extracting a key via the\n     * `groupBy` function assigned in the constructor options.\n     * @param values Adds several values\n     */\n    addValue(...values) {\n        for (const v of values) {\n            const key = this.groupBy(v);\n            this.addKeyedValues(key, v);\n        }\n    }\n    /**\n     * Delete `value` under a particular `key`\n     * @param key\n     * @param value\n     * @returns _True_ if `value` was found under `key`\n     */\n    deleteKeyValue(key, value) {\n        const existing = this.map.get(key);\n        if (existing === undefined)\n            return false;\n        const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n        this.map.set(key, without);\n        return without.length < existing.length;\n    }\n    /**\n     * Deletes `value` regardless of key.\n     *\n     * Uses the constructor-defined equality function.\n     * @param value Value to delete\n     * @returns\n     */\n    deleteByValue(value) {\n        let del = false;\n        const entries = [...this.map.entries()];\n        for (const keyEntries of entries) {\n            for (const values of keyEntries[1]) {\n                if (this.valueEq(values, value)) {\n                    del = true;\n                    this.deleteKeyValue(keyEntries[0], value);\n                }\n            }\n        }\n        return del;\n    }\n    /**\n     * Deletes all values under `key`,\n     * @param key\n     * @returns _True_ if `key` was found and values stored\n     */\n    delete(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        if (values.length === 0)\n            return false;\n        this.map.delete(key);\n        return true;\n    }\n    /**\n     * Clear contents\n     */\n    clear() {\n        this.map.clear();\n    }\n}\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimpleMutable(groupBy, valueEq);\n","/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = (map, data) => {\n    const x = new Map(map.entries());\n    for (const d of data) {\n        if (d[0] === undefined)\n            throw new Error(`key cannot be undefined`);\n        if (d[1] === undefined)\n            throw new Error(`value cannot be undefined`);\n        x.set(d[0], d[1]);\n    }\n    return x;\n};\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = (map, data) => {\n    const x = new Map(map.entries());\n    for (const d of data) {\n        if (d.key === undefined)\n            throw new Error(`key cannot be undefined`);\n        if (d.value === undefined)\n            throw new Error(`value cannot be undefined`);\n        x.set(d.key, d.value);\n    }\n    return x;\n};\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = (map, key) => map.has(key);\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = (map, ...data) => {\n    if (map === undefined)\n        throw new Error(`map parameter is undefined`);\n    if (data === undefined)\n        throw new Error(`data parameter i.s undefined`);\n    if (data.length === 0)\n        return map;\n    const firstRecord = data[0];\n    const isObject = typeof firstRecord.key !==\n        `undefined` &&\n        typeof firstRecord.value !==\n            `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n    return isObject\n        ? addObjects(map, data)\n        : addArray(map, data);\n};\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = (map, key, value) => {\n    const x = new Map(map.entries());\n    x.set(key, value);\n    return x;\n};\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = (map, key) => {\n    const x = new Map(map.entries());\n    x.delete(key);\n    return x;\n};\n","import {} from '../types.js';\nimport { add, del, set } from './map-immutable-fns.js';\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = (dataOrMap) => {\n    if (dataOrMap === undefined)\n        return immutable([]);\n    if (Array.isArray(dataOrMap))\n        return immutable(add(new Map(), ...dataOrMap));\n    const data = dataOrMap;\n    return {\n        add: (...itemsToAdd) => {\n            const s = add(data, ...itemsToAdd);\n            return immutable(s);\n        },\n        set: (key, value) => {\n            const s = set(data, key, value);\n            return immutable(s);\n        },\n        get: (key) => data.get(key),\n        delete: (key) => immutable(del(data, key)),\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        clear: () => immutable(),\n        has: (key) => data.has(key),\n        entries: () => data.entries(),\n        values: () => data.values(),\n        isEmpty: () => data.size === 0,\n    };\n};\n","import {} from '../types.js';\nimport { add, del, set, has } from './map-immutable-fns.js';\n/**\n * Returns a {@link IMapMutable} (which just wraps the in-built Map)\n * Use {@link Maps.immutable} for the immutable alternative.\n *\n * @example Basic usage\n * ```js\n * const m = mapMutable();\n * // Add one or more entries\n * m.add([\"name\", \"sally\"]);\n * // Alternatively:\n * m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");           // \"sally\"\n * m.delete(\"name\");\n * m.isEmpty; // True\n * m.clear();\n * ```\n * @param data Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const mutable = (...data) => {\n    // eslint-disable-next-line functional/no-let\n    let m = add(new Map(), ...data);\n    return {\n        add: (...data) => {\n            m = add(m, ...data);\n        },\n        delete: (key) => {\n            m = del(m, key);\n        },\n        clear: () => {\n            m = add(new Map());\n        },\n        set: (key, value) => {\n            m = set(m, key, value);\n        },\n        get: (key) => m.get(key),\n        entries: () => m.entries(),\n        values: () => m.values(),\n        isEmpty: () => m.size === 0,\n        has: (key) => has(m, key),\n    };\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { toStringDefault } from '@ixfx/core';\n/**\n * @internal\n */\nexport class MapOfMutableImpl extends SimpleEventEmitter {\n    #map = new Map();\n    groupBy;\n    type;\n    constructor(type, opts = {}) {\n        super();\n        this.type = type;\n        this.groupBy = opts.groupBy ?? toStringDefault;\n    }\n    /**\n     * Returns the type name. For in-built implementations, it will be one of: array, set or circular\n     */\n    get typeName() {\n        return this.type.name;\n    }\n    /**\n     * Returns the number of keys\n     */\n    get lengthKeys() {\n        return this.#map.size;\n    }\n    /**\n     * Returns the length of the longest child list\n     */\n    get lengthMax() {\n        let m = 0;\n        for (const v of this.#map.values()) {\n            m = Math.max(m, this.type.count(v));\n        }\n        return m;\n    }\n    debugString() {\n        const keys = [...this.#map.keys()];\n        let r = `Keys: ${keys.join(`, `)}\\r\\n`;\n        for (const k of keys) {\n            const v = this.#map.get(k);\n            if (v === undefined) {\n                r += ` - ${k} (undefined)\\r\\n`;\n            }\n            else {\n                const asArray = this.type.toArray(v);\n                if (asArray !== undefined) {\n                    r += ` - ${k} (${this.type.count(v)}) = ${JSON.stringify(asArray)}\\r\\n`;\n                }\n            }\n        }\n        ;\n        return r;\n    }\n    get isEmpty() {\n        return this.#map.size === 0;\n    }\n    clear() {\n        this.#map.clear();\n        super.fireEvent(`clear`, true);\n    }\n    addKeyedValues(key, ...values) {\n        const set = this.#map.get(key);\n        if (set === undefined) {\n            this.#map.set(key, this.type.addKeyedValues(undefined, values));\n            super.fireEvent(`addedKey`, { key: key });\n            super.fireEvent(`addedValues`, { values: values });\n        }\n        else {\n            this.#map.set(key, this.type.addKeyedValues(set, values));\n            super.fireEvent(`addedValues`, { values: values });\n        }\n    }\n    set(key, values) {\n        this.addKeyedValues(key, ...values);\n        return this;\n    }\n    addValue(...values) {\n        for (const v of values)\n            this.addKeyedValues(this.groupBy(v), v);\n    }\n    hasKeyValue(key, value, eq) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return false;\n        return this.type.has(m, value, eq);\n    }\n    has(key) {\n        return this.#map.has(key);\n    }\n    deleteKeyValue(key, value) {\n        const a = this.#map.get(key);\n        if (a === undefined)\n            return false;\n        return this.deleteKeyValueFromMap(a, key, value);\n    }\n    deleteKeyValueFromMap(map, key, value) {\n        const preCount = this.type.count(map);\n        const filtered = this.type.without(map, value);\n        const postCount = filtered.length;\n        this.#map.set(key, this.type.addKeyedValues(undefined, filtered));\n        return preCount > postCount;\n    }\n    deleteByValue(value) {\n        let something = false;\n        [...this.#map.keys()].filter((key) => {\n            const a = this.#map.get(key);\n            if (!a)\n                throw new Error(`Bug: map could not be accessed`);\n            if (this.deleteKeyValueFromMap(a, key, value)) {\n                something = true; // note that something was deleted\n                // If key is empty, delete it\n                if (this.count(key) === 0)\n                    this.delete(key);\n            }\n        });\n        return something;\n    }\n    delete(key) {\n        const a = this.#map.get(key);\n        if (a === undefined)\n            return false;\n        this.#map.delete(key);\n        this.fireEvent(`deleteKey`, { key: key });\n        return true;\n    }\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const keys = [...this.#map.keys()];\n        const found = keys.find((key) => {\n            const a = this.#map.get(key);\n            if (a === undefined)\n                throw new Error(`Bug: map could not be accessed`);\n            const r = this.type.has(a, value, eq);\n            return r;\n        });\n        return found;\n    }\n    count(key) {\n        const entry = this.#map.get(key);\n        if (entry === undefined)\n            return 0;\n        return this.type.count(entry);\n    }\n    /**\n     * Iterates over values stored under `key`\n     * An empty array is returned if there are no values\n     */\n    *get(key) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return;\n        yield* this.type.iterable(m);\n    }\n    /**\n     * Iterate over the values stored under `key`.\n     * If key does not exist, iteration is essentially a no-op\n     * @param key\n     * @returns\n     */\n    *valuesFor(key) {\n        const m = this.#map.get(key);\n        if (m === undefined)\n            return;\n        yield* this.type.iterable(m);\n    }\n    getSource(key) {\n        return this.#map.get(key);\n    }\n    *keys() {\n        yield* this.#map.keys();\n        //return Array.from(this.#map.keys());\n    }\n    *entriesFlat() {\n        for (const entry of this.#map.entries()) {\n            for (const v of this.type.iterable(entry[1])) {\n                yield [entry[0], v];\n            }\n        }\n    }\n    *valuesFlat() {\n        for (const entry of this.#map.entries()) {\n            yield* this.type.iterable(entry[1]);\n        }\n    }\n    *entries() {\n        for (const [k, v] of this.#map.entries()) {\n            const temporary = [...this.type.iterable(v)];\n            yield [k, temporary];\n        }\n    }\n    *keysAndCounts() {\n        for (const key of this.keys()) {\n            yield [key, this.count(key)];\n        }\n    }\n    merge(other) {\n        for (const key of other.keys()) {\n            const data = other.get(key);\n            this.addKeyedValues(key, ...data);\n        }\n    }\n    get size() {\n        return this.#map.size;\n    }\n    get [Symbol.toStringTag]() {\n        return this.#map[Symbol.toStringTag];\n    }\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { without } from '@ixfx/arrays';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\nimport { hasAnyValue as mapHasAnyValue, toArray as mapToArray, findValue as mapFindValue, filterValues as mapFilterValues, addValue as mapAddValue } from '@ixfx/core/maps';\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a set to hold values.\n * This means that only unique values are stored under each key. By default it\n * uses the JSON representation to compare items.\n *\n * Options: `{ hash: toStringFn } }`\n *\n * `hash` is Util.ToString function: `(object) => string`. By default it uses\n * `JSON.stringify`.\n *\n * @example Only storing the newest three items per key\n * ```js\n * const map = ofSetMutable();\n * map.addKeyedValues(`hello`, [1, 2, 3, 1, 2, 3]);\n * const hello = map.get(`hello`); // [1, 2, 3]\n * ```\n *\n * @example\n * ```js\n * const hash = (v) => v.name; // Use name as the key\n * const map = ofSetMutable({hash});\n * map.addValue({age:40, name: `Mary`});\n * map.addValue({age:29, name: `Mary`}); // Value ignored as same name exists\n * ```\n * @param options\n * @returns\n */\nexport const ofSetMutable = (options) => {\n    const hash = options?.hash ?? toStringDefault;\n    const comparer = (a, b) => hash(a) === hash(b);\n    const t = {\n        get name() {\n            return `set`;\n        },\n        iterable: (source) => source.values(),\n        addKeyedValues: (dest, values) => mapAddValue(dest, hash, `skip`, ...values),\n        count: (source) => source.size,\n        find: (source, predicate) => mapFindValue(source, predicate),\n        filter: (source, predicate) => mapFilterValues(source, predicate),\n        toArray: (source) => mapToArray(source),\n        has: (source, value) => mapHasAnyValue(source, value, comparer),\n        without: (source, value) => without(mapToArray(source), value, comparer),\n    };\n    const m = new MapOfMutableImpl(t, options);\n    return m;\n};\n","import { isEqualDefault } from '@ixfx/core';\nimport { CircularArray } from '../circular-array.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n/**\n * Returns a {@link IMapOfMutableExtended} that uses a {@link ICircularArray} to hold values. Mutable.\n * This means that the number of values stored under each key will be limited to the defined\n * capacity.\n *\n * Required option:\n * * `capacity`: how many items to hold\n *\n * @example Only store the most recent three items per key\n * ```js\n * const map = ofCircularMutable({capacity: 3});\n * map.add(`hello`, [1, 2, 3, 4, 5]);\n * const hello = map.get(`hello`); // [3, 4, 5]\n * ```\n *\n *\n * @param options\n * @returns\n */\nexport const ofCircularMutable = (options) => {\n    const comparer = isEqualDefault;\n    const t = {\n        get name() {\n            return `circular`;\n        },\n        addKeyedValues: (destination, values) => {\n            let ca = destination ?? new CircularArray(options.capacity);\n            for (const v of values) {\n                ca = ca.add(v);\n            }\n            return ca;\n        },\n        count: (source) => source.length,\n        find: (source, predicate) => source.find(predicate),\n        filter: (source, predicate) => source.filter(predicate),\n        toArray: (source) => source,\n        iterable: (source) => source.values(),\n        has: (source, value) => source.find((v) => comparer(v, value)) !== undefined,\n        without: (source, value) => source.filter((v) => !comparer(v, value)),\n    };\n    return new MapOfMutableImpl(t, options);\n};\n","/**\n * Simple map for numbers.\n *\n * Keys not present in map return the `defaultValue` given in the constructor\n * ```js\n * // All keys default to zero.\n * const map = new NumberMap();\n * map.get(`hello`); // 0\n * ```\n *\n * To check if a key is present, use `has`:\n * ```js\n * map.has(`hello`); // false\n * ```\n *\n * Math:\n * ```js\n * // Adds 1 by default to value of `hello`\n * map.add(`hello`);         // 1\n * map.multiply(`hello`, 2); // 2\n *\n * // Reset key to default value\n * map.reset(`hello`); // 0\n * ```\n *\n * Different default value:\n * ```js\n * const map = new NumberMap(10);\n * map.get(`hello`); // 10\n * ```\n *\n * Regular `set` works as well:\n * ```js\n * map.set(`hello`, 5);\n * map.add(`hello`, 2); // 7\n * ```\n */\nexport class NumberMap extends Map {\n    defaultValue;\n    constructor(defaultValue = 0) {\n        super();\n        this.defaultValue = defaultValue;\n    }\n    get(key) {\n        const v = super.get(key);\n        if (v === undefined)\n            return this.defaultValue;\n        return v;\n    }\n    reset(key) {\n        super.set(key, this.defaultValue);\n        return this.defaultValue;\n    }\n    multiply(key, amount) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value *= amount;\n        super.set(key, value);\n        return value;\n    }\n    add(key, amount = 1) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value += amount;\n        super.set(key, value);\n        return value;\n    }\n    subtract(key, amount = 1) {\n        const v = super.get(key);\n        let value = v ?? this.defaultValue;\n        value -= amount;\n        super.set(key, value);\n        return value;\n    }\n}\n","import { isEqualDefault } from '@ixfx/core';\nimport {} from './imap-of-mutable-extended.js';\nimport {} from './map-multi.js';\nimport { MapOfMutableImpl } from './map-of-multi-impl.js';\n/**\n * Returns a {@link IMapOfMutableExtended} to allow storing multiple values under a key, unlike a regular Map.\n * @example\n * ```js\n * const map = ofArrayMutable();\n * map.addKeyedValues(`hello`, [1,2,3,4]); // Adds series of numbers under key `hello`\n *\n * const hello = map.get(`hello`); // Get back values\n * ```\n *\n * Takes options:\n * * `comparer`: {@link IsEqual}\n * * `toString`: Util.ToString\n *\n * A custom Util.ToString function can be provided as the `convertToString` opion. This is then used when checking value equality (`has`, `without`)\n * ```js\n * const map = ofArrayMutable({ convertToString:(v) => v.name}); // Compare values based on their `name` field;\n * ```\n *\n * Alternatively, a {@link IsEqual} function can be used:\n * ```js\n * const map = ofArrayMutable({comparer: (a, b) => a.name === b.name });\n * ```\n * @param options Optiosn for mutable array\n * @typeParam V - Data type of items\n * @returns {@link IMapOfMutableExtended}\n */\nexport const ofArrayMutable = (options = {}) => {\n    // const toStringFunction = opts.toString === undefined ?  \n    // const comparer =\n    //   opts.comparer === undefined\n    //     ? (opts.toString === undefined\n    //       ? (a: V, b: V) => opts.toString(a) === opts.toString(b)\n    //       : isEqualDefault)\n    //     : opts.comparer;\n    // const convertToStringComparer = opts.convertToString === undefined ? undefined : (a: V, b: V) => {\n    //   const r = opts.convertToString(a) === opts.convertToString(b)\n    //   console.log(`ofArrayMutable toString comparer: r: ${ r } a: ${ a } b: ${ b }`);\n    //   console.log(`ofArrayMutable toString comparer: a: ${ opts.toString(a) } b: ${ opts.toString(b) }`);\n    //   return r;\n    // };\n    const convertToString = options.convertToString;\n    const toStringFunction = typeof convertToString === `undefined` ? isEqualDefault : (a, b) => convertToString(a) === convertToString(b);\n    const comparer = options.comparer ?? toStringFunction;\n    const t = {\n        get name() {\n            return `array`;\n        },\n        addKeyedValues: (destination, values) => {\n            if (destination === undefined)\n                return [...values];\n            return [...destination, ...values];\n        },\n        iterable: (source) => source.values(),\n        count: (source) => source.length,\n        find: (source, predicate) => source.find(f => predicate(f)),\n        filter: (source, predicate) => source.filter(f => predicate(f)),\n        toArray: (source) => source,\n        has: (source, value) => source.some((v) => comparer(v, value)),\n        without: (source, value) => source.filter((v) => !comparer(v, value)),\n        //[Symbol.iterator]: (source) => source[Symbol.iterator]()\n    };\n    const m = new MapOfMutableImpl(t, options);\n    return m;\n};\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * Simple immutable MapOf\n */\nexport class MapOfSimple extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        //const asEntries = values.map(v => [key, v]) as [string, V[]][];\n        //return this.addBatch(asEntries);\n        return this.addBatch([[key, values]]);\n    }\n    addValue(...values) {\n        const asEntries = values.map((v) => [this.groupBy(v), v]);\n        return this.addBatch(asEntries);\n    }\n    //eslint-disable-next-line functional/prefer-immutable-types\n    addBatch(entries) {\n        // Deep copy Map\n        const temporary = new Map([...this.map.entries()].map((e) => [e[0], [...e[1]]]));\n        for (const [key, list] of entries) {\n            // Does key exist already\n            const existingList = temporary.get(key);\n            if (typeof existingList === `undefined`) {\n                // No, use the batch input as the data for this key\n                // @ts-expect-error\n                temporary.set(key, list);\n            }\n            else {\n                // Yes\n                existingList.push(...list);\n            }\n        }\n        return new MapOfSimple(this.groupBy, this.valueEq, [...temporary.entries()]);\n    }\n    clear() {\n        return new MapOfSimple(this.groupBy, this.valueEq);\n    }\n    deleteKeyValue(_key, _value) {\n        throw new Error(`Method not implemented.`);\n    }\n    deleteByValue(value, eq) {\n        const entries = [...this.map.entries()];\n        const eqFunction = eq ?? this.valueEq;\n        const x = entries.map((entry) => {\n            const key = entry[0];\n            const values = entry[1].filter((vv) => !eqFunction(vv, value));\n            return [key, values];\n        });\n        return new MapOfSimple(this.groupBy, this.valueEq, x);\n    }\n    delete(key) {\n        const entries = [...this.map.entries()].filter((e) => e[0] !== key);\n        return new MapOfSimple(this.groupBy, this.valueEq, entries);\n    }\n}\n/**\n * A simple immutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * let m = mapSimple();\n * m = m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m = m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimple = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimple(groupBy, valueEq);\n","export { create as expiringMap, ExpiringMap } from './expiring-map.js';\nexport * from './map-of-simple-mutable.js';\nexport { immutable } from './map.js';\nexport { mutable } from './map-mutable.js';\nexport { ofSetMutable } from './map-of-set-mutable.js';\nexport { ofCircularMutable } from './map-of-circular-mutable.js';\nexport { NumberMap } from './number-map.js';\nexport * from './map-multi.js';\n// Re-export from core\nexport * from '@ixfx/core/maps';\n//export type { IDictionary as IMappish, IWithEntries } from '../../data/maps/IMappish.js';\n","import { resultIsError } from \"@ixfx/guards\";\n/**\n * Stores values in a table of rows (vertical) and columns (horizontal)\n */\nexport class Table {\n    rows = [];\n    rowLabels = [];\n    colLabels = [];\n    /**\n     * Keep track of widest row\n     */\n    columnMaxLength = 0;\n    /**\n     * Gets the label for a given column index,\n     * returning _undefined_ if not found.\n     *\n     * Case-sensitive\n     * @param label Label to seek\n     * @returns Index of column, or _undefined_ if not found\n     */\n    getColumnLabelIndex(label) {\n        for (const [index, l] of this.colLabels.entries()) {\n            if (l === label)\n                return index;\n        }\n    }\n    /**\n     * Gets the label for a given row index,\n     * returning _undefined_ if not found.\n     *\n     * Case-sensitive\n     * @param label Label to seek\n     * @returns Index of row, or _undefined_ if not found\n     */\n    getRowLabelIndex(label) {\n        for (const [index, l] of this.rowLabels.entries()) {\n            if (l === label)\n                return index;\n        }\n    }\n    /**\n     * Dumps the values of the table to the console\n     */\n    print() {\n        console.table([...this.rowsWithLabelsObject()]);\n    }\n    /**\n     * Return a copy of table as nested array\n     *\n     * ```js\n     * const t = new Table();\n     * // add stuff\n     * // ...\n     * const m = t.asArray();\n     * for (const row of m) {\n     *  for (const colValue of row) {\n     *    // iterate over all column values for this row\n     *  }\n     * }\n     * ```\n     *\n     * Alternative: get value at row Y and column X\n     * ```js\n     * const value = m[y][x];\n     * ```\n     * @returns\n     */\n    asArray() {\n        const r = [];\n        for (const row of this.rows) {\n            if (row === undefined)\n                r.push([]);\n            else\n                r.push([...row]);\n        }\n        return r;\n    }\n    /**\n     * Return the number of rows\n     */\n    get rowCount() {\n        return this.rows.length;\n    }\n    /**\n     * Return the maximum number of columns in any row\n     */\n    get columnCount() {\n        return this.columnMaxLength;\n        // const lengths = this.rows.map(row => row.length);\n        // return Math.max(...lengths);\n    }\n    /**\n     * Iterates over the table row-wise, in object format.\n     * @see {@link rowsWithLabelsArray} to get rows in array format\n     */\n    *rowsWithLabelsObject() {\n        for (let index = 0; index < this.rows.length; index++) {\n            const labelledRow = this.getRowWithLabelsObject(index);\n            yield labelledRow;\n        }\n    }\n    /**\n     * Iterates over each row, including the labels if available\n     * @see {@link rowsWithLabelsObject} to get rows in object format\n     */\n    *rowsWithLabelsArray() {\n        for (let index = 0; index < this.rows.length; index++) {\n            const labelledRow = this.getRowWithLabelsArray(index);\n            yield labelledRow;\n        }\n    }\n    /**\n     * Assign labels to columns\n     * @param labels\n     */\n    labelColumns(...labels) {\n        this.colLabels = labels;\n    }\n    /**\n     * Assign label to a specific column\n     * First column has an index of 0\n     * @param columnIndex\n     * @param label\n     */\n    labelColumn(columnIndex, label) {\n        this.colLabels[columnIndex] = label;\n    }\n    /**\n     * Label rows\n     * @param labels Labels\n     */\n    labelRows(...labels) {\n        this.rowLabels = labels;\n    }\n    /**\n     * Assign label to a specific row\n     * First row has an index of 0\n     * @param rowIndex\n     * @param label\n     */\n    labelRow(rowIndex, label) {\n        this.rowLabels[rowIndex] = label;\n    }\n    /**\n     * Adds a new row\n     * @param data Columns\n     */\n    appendRow(...data) {\n        this.columnMaxLength = Math.max(this.columnMaxLength, data.length);\n        this.rows.push(data);\n        return data;\n    }\n    /**\n     * Gets a row along with labels, as an array\n     * @param rowIndex\n     * @returns\n     */\n    getRowWithLabelsArray(rowIndex) {\n        const row = this.rows.at(rowIndex);\n        if (row === undefined)\n            return undefined;\n        return row.map((value, index) => [this.colLabels.at(index), value]);\n    }\n    /**\n     * Return a row of objects. Keys use the column labels.\n     *\n     * ```js\n     * const row = table.getRowWithLabelsObject(10);\n     * // eg:\n     * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n     * ```\n     * @param rowIndex\n     * @returns\n     */\n    getRowWithLabelsObject(rowIndex) {\n        const row = this.rows.at(rowIndex);\n        if (row === undefined)\n            return undefined;\n        const object = {};\n        for (let index = 0; index < this.colLabels.length; index++) {\n            const label = this.colLabels.at(index) ?? index.toString();\n            object[label] = row[index];\n        }\n        return object;\n    }\n    /**\n     * Gets or creates a row at given position\n     * @param row Index or label of row\n     * @returns\n     */\n    #getOrCreateRawRow(row) {\n        const index = typeof row === `number` ? row : this.getRowLabelIndex(row);\n        // Couldn't lookup label\n        if (index === undefined)\n            return { success: false, error: `row-label-notfound` };\n        // Bad index\n        if (index < 0)\n            return { success: false, error: `row-index-invalid` };\n        // Within existing set of rows\n        if (index < this.rows.length) {\n            return { success: true, value: this.rows[index] };\n        }\n        const newRow = [];\n        this.rows[index] = newRow;\n        return { success: true, value: newRow };\n    }\n    /**\n     * Gets a copy of values at given row, specified by index or label\n     * @param row\n     * @returns Returns row or throws an error if label or index not found\n     */\n    row(row) {\n        const r = this.#getRowRaw(row);\n        if (resultIsError(r)) {\n            throw new Error(r.error);\n        }\n        return [...r.value];\n    }\n    /**\n     * Set the value of row,columm.\n     * Row is created if it doesn't exist, with the other column values being _undefined_\n     * @param row Index or label\n     * @param column Column\n     * @param value Value to set at row,column\n     */\n    set(row, column, value) {\n        const result = this.#getOrCreateRawRow(row);\n        if (resultIsError(result))\n            throw new Error(result.error);\n        // Have an array that corresponds to row\n        const r = result.value;\n        const columnIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n        if (typeof columnIndex === `undefined`)\n            throw new Error(`Column label '${column}' not found or is invalid`);\n        if (columnIndex < 0)\n            throw new Error(`Column index invalid (less than zero)`);\n        // Already have needed columns\n        r[columnIndex] = value;\n    }\n    /**\n     * Gets the value at a specified row and column.\n     * Throws an error if coordinates are out of range or missing.\n     * @param row Row index or label\n     * @param column Column index or label\n     * @returns\n     */\n    get(row, column) {\n        const rowR = this.#getRowRaw(row);\n        if (resultIsError(rowR))\n            throw new Error(rowR.error);\n        const colR = this.#getColumnRaw(rowR.value, column);\n        if (resultIsError(colR))\n            throw new Error(colR.error);\n        return colR.value.value;\n    }\n    #getRowRaw(row) {\n        let index = 0;\n        if (typeof row === `number`) {\n            index = row;\n        }\n        else {\n            index = this.getRowLabelIndex(row);\n            if (typeof index !== `number`)\n                return { error: `row-label-notfound`, success: false };\n        }\n        if (typeof index !== `number`)\n            return { error: `row-invalid`, success: false };\n        if (index < 0 || index >= this.rows.length)\n            return { error: `row-index-out-of-range`, success: false };\n        return { success: true, value: this.rows[index] };\n    }\n    #getColumnRaw(row, column) {\n        const colIndex = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n        if (typeof colIndex !== `number`)\n            return { success: false, error: `col-label-notfound` };\n        if (colIndex < 0 || colIndex >= row.length)\n            return { success: false, error: `col-index-out-of-range` };\n        return {\n            success: true, value: { index: colIndex, value: row[colIndex] }\n        };\n    }\n    /**\n     * Set all the columns of a row to a specified value.\n     *\n     * By default, sets the number of columns corresponding to\n     * the table's maximum column length. To set an arbitrary\n     * length of the row, use `length`\n     * @param row Index or label of row\n     * @param length How wide the row is. If unset, uses the current maximum width of rows.\n     * @param value Value to set\n     */\n    setRow(row, value, length) {\n        // Get or create a row\n        const rowResult = this.#getOrCreateRawRow(row);\n        if (resultIsError(rowResult))\n            throw new Error(rowResult.error);\n        // Set value within row\n        const r = rowResult.value;\n        const width = typeof length === `number` ? length : this.columnMaxLength;\n        for (let columnNumber = 0; columnNumber < width; columnNumber++) {\n            r[columnNumber] = value;\n        }\n        return r;\n    }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\";\nimport { QueueMutable } from \"../queue/queue-mutable.js\";\nimport { PriorityMutable } from \"../queue/priority-mutable.js\";\nimport { immutable as immutableMap } from \"../map/map.js\";\nimport { NumberMap } from \"../map/number-map.js\";\nimport * as Sync from \"@ixfx/iterables/sync\";\nimport { Table } from \"../table.js\";\nimport { resultThrow, stringTest } from \"@ixfx/guards\";\n/**\n * Create a vertex with given id\n * @param id\n * @returns\n */\nexport const createVertex = (id) => {\n    return {\n        id,\n        out: []\n    };\n};\n/**\n * Returns _true_ if graph contains `key`.\n *\n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key\n * @returns\n */\nexport function hasKey(graph, key) {\n    resultThrow(graphTest(graph));\n    return graph.vertices.has(key);\n}\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n *\n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph\n * @param key\n * @returns\n */\nexport function get(graph, key) {\n    resultThrow(graphTest(graph));\n    resultThrow(stringTest(key, `non-empty`, `key`));\n    return graph.vertices.get(key);\n}\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph\n * @returns\n */\nexport function toAdjacencyMatrix(graph) {\n    resultThrow(graphTest(graph));\n    const v = [...graph.vertices.values()];\n    //const m: Array<Array<boolean>> = [];\n    const table = new Table();\n    table.labelColumns(...v.map(vv => vv.id));\n    table.labelRows(...v.map(vv => vv.id));\n    // const row: Array<boolean> = [];\n    // for (let index = 0; index < v.length; index++) {\n    //   row[ index ] = false;\n    // }\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (let i = 0; i < v.length; i++) {\n        //m[ i ] = [ ...row ];\n        table.setRow(i, false, v.length);\n        const ii = v[i];\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        for (const [j, jj] of v.entries()) {\n            if (ii.out.some(o => o.id === jj.id)) {\n                //m[ i ][ j ] = true;\n                table.set(i, j, true);\n            }\n        }\n    }\n    return table;\n}\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph\n * @returns\n */\nexport const dumpGraph = (graph) => {\n    const lines = debugGraphToArray(graph);\n    return lines.join(`\\n`);\n};\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph\n * @returns\n */\nconst debugGraphToArray = (graph) => {\n    const r = [];\n    const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n    for (const v of vertices) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const str = debugDumpVertex(v);\n        r.push(...str.map(line => ` ${line}`));\n    }\n    return r;\n};\n/**\n * Returns the weight of an edge, or 1 if undefined.\n * @param graph\n * @param edge\n * @returns\n */\nexport const distance = (graph, edge) => {\n    if (edge.weight !== undefined)\n        return edge.weight;\n    return 1;\n};\n/**\n * Iterate over all the edges in the graph\n * @param graph\n */\nexport function* edges(graph) {\n    resultThrow(graphTest(graph));\n    const vertices = [...graph.vertices.values()];\n    for (const vertex of vertices) {\n        for (const edge of vertex.out) {\n            yield edge;\n        }\n    }\n}\n/**\n * Iterate over all the vertices of the graph\n * @param graph\n */\nexport function* vertices(graph) {\n    resultThrow(graphTest(graph));\n    const vertices = [...graph.vertices.values()];\n    for (const vertex of vertices) {\n        yield vertex;\n    }\n}\nfunction graphTest(g, parameterName = `graph`) {\n    if (g === undefined)\n        return { success: false, error: `Param '${parameterName}' is undefined. Expected Graph` };\n    if (g === null)\n        return { success: false, error: `Param '${parameterName}' is null. Expected Graph` };\n    if (typeof g === `object`) {\n        if (!(`vertices` in g))\n            return {\n                success: false, error: `Param '${parameterName}.vertices' does not exist. Is it a Graph type?`\n            };\n    }\n    else {\n        return { success: false, error: `Param '${parameterName} is type '${typeof g}'. Expected an object Graph` };\n    }\n    return { success: true, value: g };\n}\n// function throwGraphTest(g: DirectedGraph, parameterName = `graph`) {\n//   const r = testGraph(g, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ] as string)\n// }\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns\n */\nexport function* adjacentVertices(graph, context) {\n    resultThrow(graphTest(graph));\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of vertex.out) {\n        const edgeV = graph.vertices.get(edge.id);\n        if (edgeV === undefined)\n            throw new Error(`Could not find vertex: ${edge.id}`);\n        yield edgeV;\n    }\n}\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n *\n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns\n */\nexport const vertexHasOut = (vertex, outIdOrVertex) => {\n    if (vertex === undefined)\n        return false;\n    const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n    return vertex.out.some(edge => edge.id === outId);\n};\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph\n * @param vertex\n * @returns\n */\nexport const hasNoOuts = (graph, vertex) => {\n    resultThrow(graphTest(graph));\n    const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n    if (context === undefined)\n        return false;\n    return context.out.length === 0;\n};\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph\n * @param vertex\n * @param outIdOrVertex\n * @returns\n */\nexport const hasOnlyOuts = (graph, vertex, ...outIdOrVertex) => {\n    resultThrow(graphTest(graph));\n    const context = resolveVertex(graph, vertex);\n    const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n    if (outs.length !== context.out.length) {\n        //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n        return false;\n    }\n    for (const out of outs) {\n        //console.log(`Testing ${ context.id } -> ${ out.id }`);\n        if (!hasOut(graph, context, out)) {\n            //console.log(`  no`);\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph\n * @param vertex\n * @param outIdOrVertex\n * @returns\n */\nexport const hasOut = (graph, vertex, outIdOrVertex) => {\n    resultThrow(graphTest(graph));\n    const context = resolveVertex(graph, vertex);\n    const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n    return context.out.some(edge => edge.id === outId);\n};\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph\n * @param id\n * @returns\n */\nexport const getOrCreate = (graph, id) => {\n    resultThrow(graphTest(graph));\n    const v = graph.vertices.get(id);\n    if (v !== undefined)\n        return { graph, vertex: v };\n    const vv = createVertex(id);\n    const gg = updateGraphVertex(graph, vv);\n    return { graph: gg, vertex: vv };\n};\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph\n * @param id\n * @returns\n */\nexport const getOrFail = (graph, id) => {\n    resultThrow(graphTest(graph));\n    const v = graph.vertices.get(id);\n    if (v === undefined)\n        throw new Error(`Vertex '${id}' not found in graph`);\n    return v;\n};\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns\n */\nexport const updateGraphVertex = (graph, vertex) => {\n    resultThrow(graphTest(graph));\n    const gr = {\n        ...graph,\n        vertices: graph.vertices.set(vertex.id, vertex)\n    };\n    return gr;\n};\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph\n * @param edge\n * @returns\n */\nexport const distanceDefault = (graph, edge) => {\n    if (edge.weight !== undefined)\n        return edge.weight;\n    return 1;\n};\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n *\n * If edge was not there, original graph is returned.\n * @param graph\n * @param from\n * @param to\n * @returns\n */\nexport function disconnect(graph, from, to) {\n    resultThrow(graphTest(graph));\n    const fromV = resolveVertex(graph, from);\n    const toV = resolveVertex(graph, to);\n    return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n        ...fromV,\n        out: fromV.out.filter(t => t.id !== toV.id)\n    }) : graph;\n}\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph\n * @param from\n * @param to\n * @param weight\n * @returns\n */\nexport function connectTo(graph, from, to, weight) {\n    resultThrow(graphTest(graph));\n    const fromResult = getOrCreate(graph, from);\n    graph = fromResult.graph;\n    const toResult = getOrCreate(graph, to);\n    graph = toResult.graph;\n    const edge = {\n        id: to,\n        weight\n    };\n    if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n        graph = updateGraphVertex(graph, {\n            ...fromResult.vertex,\n            // Add new edge to list of edges for this node\n            out: [...fromResult.vertex.out, edge]\n        });\n    }\n    return { graph, edge };\n}\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n *\n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n *\n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph\n * @param options\n * @returns\n */\nexport function connect(graph, options) {\n    if (typeof graph !== `object`)\n        throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof graph}`);\n    if (typeof options !== `object`)\n        throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof options}`);\n    const result = connectWithEdges(graph, options);\n    return result.graph;\n}\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well.\n *\n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n *\n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph\n * @param options\n * @returns\n */\nexport function connectWithEdges(graph, options) {\n    resultThrow(graphTest(graph));\n    const { to, weight, from } = options;\n    const bidi = options.bidi ?? false;\n    const toList = Array.isArray(to) ? to : [to];\n    const edges = [];\n    // Connect from -> to\n    for (const toSingle of toList) {\n        const result = connectTo(graph, from, toSingle, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    if (!bidi)\n        return { graph, edges };\n    // Bidirectional connection\n    // Connect to -> from\n    for (const toSingle of toList) {\n        const result = connectTo(graph, toSingle, from, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    return { graph, edges };\n}\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v\n * @returns\n */\nconst debugDumpVertex = (v) => {\n    const r = [\n        v.id\n    ];\n    const stringForEdge = (edge) => edge.weight === undefined ? edge.id : `${edge.id} (${edge.weight})`;\n    // for (const edge of v.in) {\n    //   r.push(` <- ${ stringForEdge(edge) }`);\n    // }\n    for (const edge of v.out) {\n        r.push(` -> ${stringForEdge(edge)}`);\n    }\n    if (v.out.length === 0)\n        r[0] += ` (terminal)`;\n    return r;\n};\n/**\n * Returns _true_ if a->b or b->a\n * @param graph\n * @param a\n * @param b\n * @returns\n */\nexport function areAdjacent(graph, a, b) {\n    resultThrow(graphTest(graph));\n    if (hasOut(graph, a, b.id))\n        return true;\n    if (hasOut(graph, b, a.id))\n        return true;\n}\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph\n * @param idOrVertex\n * @returns\n */\nfunction resolveVertex(graph, idOrVertex) {\n    resultThrow(graphTest(graph));\n    if (idOrVertex === undefined)\n        throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n    const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n    if (v === undefined)\n        throw new Error(`Id not found ${idOrVertex}`);\n    return v;\n}\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph\n * @param startIdOrVertex\n * @param targetIdOrVertex\n * @returns\n */\nexport function* bfs(graph, startIdOrVertex, targetIdOrVertex) {\n    resultThrow(graphTest(graph));\n    const start = resolveVertex(graph, startIdOrVertex);\n    const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n    const queue = new QueueMutable();\n    const seen = new Set();\n    queue.enqueue(start);\n    while (!queue.isEmpty) {\n        const v = queue.dequeue();\n        yield v;\n        if (target !== undefined && target === v)\n            return;\n        for (const edge of adjacentVertices(graph, v)) {\n            if (!seen.has(edge.id)) {\n                seen.add(edge.id);\n                queue.enqueue(resolveVertex(graph, edge.id));\n            }\n        }\n    }\n}\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph\n * @param startIdOrVertex\n */\nexport function* dfs(graph, startIdOrVertex) {\n    resultThrow(graphTest(graph));\n    const source = resolveVertex(graph, startIdOrVertex);\n    const s = new StackMutable();\n    const seen = new Set();\n    s.push(source);\n    while (!s.isEmpty) {\n        const v = s.pop();\n        if (v === undefined)\n            continue;\n        if (!seen.has(v.id)) {\n            seen.add(v.id);\n            yield v;\n            for (const edge of v.out) {\n                const destination = graph.vertices.get(edge.id);\n                if (destination) {\n                    s.push(destination);\n                }\n            }\n        }\n    }\n}\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph\n * @param sourceOrId\n * @returns\n */\nexport const pathDijkstra = (graph, sourceOrId) => {\n    resultThrow(graphTest(graph));\n    const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n    if (source === undefined)\n        throw new Error(`source vertex not found`);\n    const distances = new Map();\n    const previous = new Map();\n    distances.set(source.id, 0);\n    const pq = new PriorityMutable();\n    const vertices = [...graph.vertices.values()];\n    for (const v of vertices) {\n        if (v.id !== source.id) {\n            distances.set(v.id, Number.MAX_SAFE_INTEGER);\n            previous.set(v.id, null);\n        }\n        pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n    }\n    while (!pq.isEmpty) {\n        const u = pq.dequeueMin();\n        if (u === undefined)\n            throw new Error(`Bug. Queue unexpectedly empty`);\n        const vertexU = graph.vertices.get(u);\n        for (const neighbour of vertexU.out) {\n            //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n            const alt = distances.get(u) + distance(graph, neighbour);\n            if (alt < distances.get(neighbour.id)) {\n                distances.set(neighbour.id, alt);\n                previous.set(neighbour.id, vertexU);\n                pq.changePriority(neighbour.id, alt, true);\n            }\n        }\n    }\n    const pathTo = (id) => {\n        const path = [];\n        while (true) {\n            if (id === source.id)\n                break;\n            const v = previous.get(id);\n            if (v === undefined || v === null)\n                throw new Error(`Id not present: ${id}`);\n            path.push({ id, weight: distances.get(id) });\n            id = v.id;\n        }\n        return path;\n    };\n    return {\n        distances, previous, pathTo\n    };\n};\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph\n * @returns\n */\nexport const clone = (graph) => {\n    resultThrow(graphTest(graph));\n    const g = {\n        vertices: immutableMap([...graph.vertices.entries()])\n    };\n    return g;\n};\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n *\n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections\n * @returns\n */\nexport const graph = (...initialConnections) => {\n    let g = {\n        vertices: immutableMap()\n    };\n    for (const ic of initialConnections) {\n        g = connect(g, ic);\n    }\n    return g;\n};\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph\n */\nexport function isAcyclic(graph) {\n    resultThrow(graphTest(graph));\n    const cycles = getCycles(graph);\n    return cycles.length === 0;\n}\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph\n */\nexport function topologicalSort(graph) {\n    resultThrow(graphTest(graph));\n    const indegrees = new NumberMap(0);\n    // Increment indegrees for each edge leading to a vertex\n    for (const edge of edges(graph)) {\n        indegrees.add(edge.id, 1);\n    }\n    // Enqueue all vertices with an indegree of 0\n    const queue = new QueueMutable();\n    let vertexCount = 0;\n    for (const vertex of vertices(graph)) {\n        if (indegrees.get(vertex.id) === 0) {\n            queue.enqueue(vertex);\n        }\n        vertexCount++;\n    }\n    const topOrder = [];\n    while (!queue.isEmpty) {\n        // Add to topological order\n        const u = queue.dequeue();\n        topOrder.push(u);\n        // Iterate through neighbours\n        for (const neighbour of u.out) {\n            const result = indegrees.subtract(neighbour.id, 1);\n            if (result === 0) {\n                queue.enqueue(graph.vertices.get(neighbour.id));\n            }\n        }\n    }\n    if (topOrder.length !== vertexCount) {\n        throw new Error(`Graph contains cycles`);\n    }\n    return graphFromVertices(topOrder);\n}\n/**\n * Create a graph from an iterable of vertices\n * @param vertices\n * @returns\n */\nexport function graphFromVertices(vertices) {\n    const keyValues = Sync.map(vertices, f => {\n        return [f.id, f];\n    });\n    const m = immutableMap([...keyValues]);\n    return {\n        vertices: m\n    };\n}\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph\n * @returns\n */\nexport function getCycles(graph) {\n    resultThrow(graphTest(graph));\n    let index = 0;\n    const stack = new StackMutable();\n    const vertices = new Map();\n    const scc = [];\n    for (const v of graph.vertices.values()) {\n        vertices.set(v.id, {\n            ...v,\n            lowlink: Number.NaN,\n            index: Number.NaN,\n            onStack: false\n        });\n    }\n    const strongConnect = (vertex) => {\n        vertex.index = index;\n        vertex.lowlink = index;\n        index++;\n        stack.push(vertex);\n        vertex.onStack = true;\n        for (const edge of vertex.out) {\n            const edgeV = vertices.get(edge.id);\n            if (Number.isNaN(edgeV.index)) {\n                strongConnect(edgeV);\n                vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n            }\n            else if (edgeV.onStack) {\n                vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n            }\n        }\n        if (vertex.lowlink === vertex.index) {\n            const stronglyConnected = [];\n            let w;\n            while (vertex !== w) {\n                w = stack.pop();\n                w.onStack = false;\n                stronglyConnected.push({ id: w.id, out: w.out });\n            }\n            if (stronglyConnected.length > 1)\n                scc.push(stronglyConnected);\n        }\n    };\n    for (const v of vertices.values()) {\n        if (Number.isNaN(v.index)) {\n            strongConnect(v);\n        }\n    }\n    return scc;\n}\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph\n * @returns\n */\nexport function transitiveReduction(graph) {\n    resultThrow(graphTest(graph));\n    for (const u of vertices(graph)) {\n        for (const v of adjacentVertices(graph, u)) {\n            for (const v1 of dfs(graph, v)) {\n                if (v.id === v1.id)\n                    continue;\n                if (hasOut(graph, u, v1)) {\n                    const g = disconnect(graph, u, v1);\n                    return transitiveReduction(g);\n                }\n            }\n        }\n    }\n    return graph;\n}\n","import { immutable as immutableMap } from \"../map/map.js\";\nimport { Table } from \"../table.js\";\nexport const createVertex = (id) => {\n    return {\n        id\n    };\n};\nexport const updateGraphVertex = (graph, vertex) => {\n    const gr = {\n        ...graph,\n        vertices: graph.vertices.set(vertex.id, vertex)\n    };\n    return gr;\n};\nexport const getOrCreate = (graph, id) => {\n    const v = graph.vertices.get(id);\n    if (v !== undefined)\n        return { graph, vertex: v };\n    const vv = createVertex(id);\n    const gg = updateGraphVertex(graph, vv);\n    return { graph: gg, vertex: vv };\n};\nfunction resolveVertex(graph, idOrVertex) {\n    if (idOrVertex === undefined)\n        throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n    if (graph === undefined)\n        throw new Error(`Param 'graph' is undefined. Expected Graph`);\n    const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n    if (v === undefined)\n        throw new Error(`Id not found ${idOrVertex}`);\n    return v;\n}\n/**\n * Returns _true/false_ if there is a connection between `a` and `b` in `graph`.\n * Use {@link getConnection} if you want to the edge.\n * @param graph Graph to search\n * @param a\n * @param b\n * @returns _true_ if edge exists\n */\nexport const hasConnection = (graph, a, b) => {\n    const edge = getConnection(graph, a, b);\n    return edge !== undefined;\n};\n/**\n * Gets the connection, if it exists between `a` and `b` in `graph`.\n * If it doesn't exist, _undefined_ is returned.\n * Use {@link hasConnection} for a simple true/false if edge exists.\n * @param graph Graph\n * @param a\n * @param b\n * @returns\n */\nexport const getConnection = (graph, a, b) => {\n    if (a === undefined)\n        throw new Error(`Param 'a' is undefined. Expected string or Vertex`);\n    if (b === undefined)\n        throw new Error(`Param 'b' is undefined. Expected string or Vertex`);\n    if (graph === undefined)\n        throw new Error(`Param 'graph' is undefined. Expected Graph`);\n    const aa = resolveVertex(graph, a);\n    const bb = resolveVertex(graph, b);\n    for (const edge of graph.edges) {\n        if (edge.a == aa.id && edge.b === bb.id)\n            return edge;\n        if (edge.a == bb.id && edge.b === aa.id)\n            return edge;\n    }\n    return;\n};\n/**\n * Connects A with B, returning the changed graph and created edge.\n * If the connection already exists, the original graph & edge is returned.\n * @param graph\n * @param a\n * @param b\n * @param weight\n * @returns\n */\nexport function connectTo(graph, a, b, weight) {\n    const aResult = getOrCreate(graph, a);\n    graph = aResult.graph;\n    const bResult = getOrCreate(graph, b);\n    graph = bResult.graph;\n    let edge = getConnection(graph, a, b);\n    if (edge !== undefined)\n        return { graph, edge };\n    edge = {\n        a,\n        b,\n        weight\n    };\n    const graphChanged = {\n        ...graph,\n        edges: [...graph.edges, edge]\n    };\n    return { graph: graphChanged, edge };\n}\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connectWithEdges} but only the {@link Graph} is returned.\n *\n * ```js\n * let g = graph(); // Create an empty graph\n * // Make a connection between `red` and `orange`\n * g = connect(g, { a: `red`, b: `orange` });\n *\n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * g = connect(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connect(graph, options) {\n    const result = connectWithEdges(graph, options);\n    return result.graph;\n}\n/**\n * Makes a connection between `options.a` and one or more nodes in `options.b`.\n * Same as {@link connect} but graph and edges are returned.\n *\n * ```js\n * let g = graph(); // Create an empty graph\n *\n * // Make a connection between `red` and `orange`\n * result = connectWithEdges(g, { a: `red`, b: `orange` });\n *\n * // Make a connection between `red` and `orange as well as `red` and `yellow`.\n * result = connectWithEdges(g, { a: `red`, b: [`orange`, `yellow`] })\n * ```\n * @param graph Initial graph\n * @param options Options\n */\nexport function connectWithEdges(graph, options) {\n    const { a, weight, b } = options;\n    const destinations = Array.isArray(b) ? b : [b];\n    const edges = [];\n    for (const destination of destinations) {\n        const result = connectTo(graph, a, destination, weight);\n        graph = result.graph;\n        edges.push(result.edge);\n    }\n    return { graph, edges };\n}\nexport const graph = (...initialConnections) => {\n    let g = {\n        vertices: immutableMap(),\n        edges: []\n    };\n    for (const ic of initialConnections) {\n        g = connect(g, ic);\n    }\n    return g;\n};\nexport function toAdjacencyMatrix(graph) {\n    const v = [...graph.vertices.values()];\n    const table = new Table();\n    table.labelColumns(...v.map(vv => vv.id));\n    table.labelRows(...v.map(vv => vv.id));\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (let i = 0; i < v.length; i++) {\n        table.setRow(i, false, v.length);\n        const ii = v[i];\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        for (const [j, jj] of v.entries()) {\n            const connected = hasConnection(graph, ii, jj);\n            if (connected) {\n                table.set(i, j, true);\n            }\n        }\n    }\n    return table;\n}\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph\n * @returns\n */\nexport const dumpGraph = (graph) => {\n    const lines = debugGraphToArray(graph);\n    return lines.join(`\\n`);\n};\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph\n * @returns\n */\nconst debugGraphToArray = (graph) => {\n    const r = [];\n    r.push(`Vertices: ${[...graph.vertices.values()].map(v => v.id).join(`, `)}`);\n    r.push(`Edges:`);\n    for (const edge of graph.edges) {\n        r.push(stringForEdge(edge));\n    }\n    return r;\n};\nconst stringForEdge = (edge) => {\n    const weight = edge.weight ? ` (${edge.weight})` : ``;\n    return `${edge.a} <-> ${edge.b}${weight}`;\n};\n/**\n * Iterate over all the vertices connectd to `context` vertex\n * @param graph Graph\n * @param context id or Vertex\n * @returns\n */\nexport function* adjacentVertices(graph, context) {\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of graph.edges) {\n        if (edge.a === context)\n            yield resolveVertex(graph, edge.b);\n        else if (edge.b === context)\n            yield resolveVertex(graph, edge.a);\n    }\n}\nexport function* edgesForVertex(graph, context) {\n    if (context === undefined)\n        return;\n    const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n    if (vertex === undefined)\n        throw new Error(`Vertex not found ${JSON.stringify(context)}`);\n    for (const edge of graph.edges) {\n        if (edge.a === context)\n            yield edge;\n        else if (edge.b === context)\n            yield edge;\n    }\n}\n","/**\n * Directed graphs\n *\n * Graph _vertices_ (ie. nodes) connect to each other along _edges_.\n * This is 'directed' in that connections are not necessarily mutual.\n * A can connect to B without B connecting to A.\n *\n * Connections can have an optional weight, defaulting to 1.\n *\n * @example Creating a directed graph A connects to B and C; B connects to C. C has edges.\n * ```js\n * let g = Directed.graph(\n *  { from: `a`, to: [`b`, `c`] },\n *  { from: `b`, to: `c` }\n*  );\n* ```\n*\n* Graphs do not store data directly, only the relation between vertices. Each vertex has an id,\n* so to associate data, use a map along with the graph.\n*\n*/\nexport * as Directed from './directed-graph.js';\n/**\n * Undirected graphs\n *\n * Graph _vertices_ (ie. nodes) connect to each other along _edges_.\n * Unlike a directed graph, nodes are always mutually connected.\n *\n * @example Creating an undirected graph where vertex 0 connects to 1, 2 & 3; 2 connects to 1\n * ```js\n * let g = Undirected.graph(\n *    { a: `0`, b: [ `1`, `2`, `3` ] },\n *    { a: `2`, b: `1` }\n *  );\n* ```\n*\n* Graphs do not store data directly, only the relation between vertices. Each vertex has an id,\n* so to associate data, use a map along with the graph.\n*\n*/\nexport * as Undirected from './undirected-graph.js';\n","export * from './circular-array.js';\n/**\n * A tree-like structure of branches and leaves.\n *\n * ```js\n * import { Trees } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const root = Trees.Mutable.rootWrapped(`root`);\n * // Add 'a' as the child of the root node\n * let a = root.addValue(`a`);\n * // Add `aa` as the child of `a`\n * let b = a.addValue(`aa`);\n * b.hasParent(a); // True\n * ```\n */\nexport * as Trees from './tree/index.js';\nexport * from './tree/types.js';\n/**\n * Stacks store items in order, like a stack of plates.\n *\n * ```js\n * import { Stacks } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * let s = Stacks.immutable();\n * s = s.push(`a`, `b`);   // Add two strings\n * // Peek looks at the top of the stack\n * // (ie most recently added)\n * s.peek; // `b`\n * // Remove item from top of stack\n * s = s.pop();\n * s.peek // `a`\n * ```\n */\nexport * as Stacks from './stack/index.js';\nexport { StackMutable } from './stack/StackMutable.js';\nexport { StackImmutable } from './stack/StackImmutable.js';\n/**\n * Sets store unique items.\n */\nexport * as Sets from './set/index.js';\nexport * from './set/Types.js';\nexport { SetStringMutable } from './set/set-mutable.js';\nexport { SetStringImmutable } from './set/SetImmutable.js';\nexport * from './set/ISetMutable.js';\n/**\n * Queues store items in the order in which they are added.\n */\nexport * as Queues from './queue/index.js';\nexport { QueueMutable } from './queue/queue-mutable.js';\nexport { QueueImmutable } from './queue/queue-immutable.js';\n/**\n * Maps associate keys with values.\n */\nexport * as Maps from './map/index.js';\nexport { ExpiringMap } from './map/expiring-map.js';\nexport { MapOfSimpleMutable } from './map/map-of-simple-mutable.js';\n/**\n * Undirected and directed graphs and associated algorithms.\n *\n * @example\n * ```js\n * import { Graphs } from \"https://unpkg.com/@ixfx/collections/bundle\"\n * const Dg = Graphs.Directed;\n * let g = Dg.graph();\n * g = Dg.connect(g, { from: `a`, to: `b` });\n * g = Dg.connect(g, { from: `b`, to: `c` });\n * g = Dg.connect(g, { from: `c`, to: `a` });\n * Dg.dumpGraph(g);\n * // A -> B, B -> C, C -> A\n * ```\n */\nexport * as Graphs from './graph/index.js';\nexport { Table } from './table.js';\n","const t = {\n    name: `root`,\n    seq: [\n        `walk_to_door`,\n        {\n            name: `door_locked`,\n            sel: [\n                `open_door`,\n                {\n                    name: `open_locked_door`,\n                    seq: [`unlock_door`, `open_door`]\n                },\n                `smash_door`\n            ]\n        },\n        `walk_through_door`,\n        `close_door`\n    ]\n};\nconst getName = (t, defaultValue = ``) => {\n    if (typeof t === `object` && `name` in t && t.name !== undefined)\n        return t.name;\n    return defaultValue;\n};\n//eslint-disable-next-line func-style\nexport function* iterateBreadth(t, pathPrefix) {\n    if (typeof pathPrefix === `undefined`) {\n        pathPrefix = getName(t);\n    }\n    for (const [index, n] of entries(t)) {\n        yield [n, pathPrefix];\n    }\n    for (const [index, n] of entries(t)) {\n        const name = getName(n, `?`);\n        const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n        yield* iterateBreadth(n, prefix);\n    }\n}\n//eslint-disable-next-line func-style\nexport function* iterateDepth(t, pathPrefix) {\n    if (typeof pathPrefix === `undefined`) {\n        pathPrefix = getName(t);\n    }\n    for (const [index, n] of entries(t)) {\n        yield [n, pathPrefix];\n        const name = getName(n, `?`);\n        const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n        yield* iterateBreadth(n, prefix);\n    }\n}\n//eslint-disable-next-line func-style\nfunction isSeqNode(n) {\n    return n.seq !== undefined;\n}\n//eslint-disable-next-line func-style\nfunction isSelNode(n) {\n    return n.sel !== undefined;\n}\n//eslint-disable-next-line func-style\nfunction* entries(n) {\n    if (isSeqNode(n)) {\n        yield* n.seq.entries();\n    }\n    else if (isSelNode(n)) {\n        yield* n.sel.entries();\n    }\n    else if (typeof n === `string`) {\n        // no-op\n    }\n    else {\n        throw new TypeError(`Unexpected shape of node. seq/sel missing`);\n    }\n}\n// for (const tn of iterateBreadth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n// console.log(`---`);\n// for (const tn of iterateDepth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n","import { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async (callback, \n//eslint-disable-next-line functional/prefer-immutable-types\noptsOrMillis) => {\n    const opts = typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n    const delayWhen = opts.delay ?? `before`;\n    if (delayWhen === `before` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    const r = Promise.resolve(await callback());\n    if (delayWhen === `after` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    return r;\n};\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//     // Yield value\n//     yield v;\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n *\n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n *\n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n *\n * The below example shows how to do this.\n *\n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n *\n * // Execution continues while loop also runs\n * ```\n *\n */\nasync function* delayAnimationLoop() {\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer = 0;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.requestAnimationFrame(callback);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        globalThis.cancelAnimationFrame(timer);\n    }\n}\n/**\n * Async generator that loops at a given interval.\n *\n * @example\n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n *\n * @example\n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport async function* delayLoop(timeout) {\n    const timeoutMs = intervalToMs(timeout);\n    if (typeof timeoutMs === `undefined`)\n        throw new Error(`timeout is undefined`);\n    if (timeoutMs < 0)\n        throw new Error(`Timeout is less than zero`);\n    if (timeoutMs === 0)\n        return yield* delayAnimationLoop();\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.setTimeout(callback, timeoutMs);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        if (timer !== undefined)\n            globalThis.clearTimeout(timer);\n        timer = undefined;\n    }\n}\n","import { integerTest, resultToError, resultIsError, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n *\n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (callback, interval) => {\n    if (callback === undefined) {\n        throw new Error(`callback parameter is undefined`);\n    }\n    const intervalMs = intervalToMs(interval);\n    resultThrow(integerTest(intervalMs, `aboveZero`, `interval`));\n    let timer;\n    let startedAt = 0;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let state = `idle`;\n    const clear = () => {\n        startedAt = 0;\n        globalThis.clearTimeout(timer);\n        state = `idle`;\n    };\n    const start = async (altInterval = interval, args) => {\n        const p = new Promise((resolve, reject) => {\n            startedAt = performance.now();\n            const altTimeoutMs = intervalToMs(altInterval);\n            const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n            if (resultIsError(it)) {\n                reject(resultToError(it));\n                return;\n            }\n            switch (state) {\n                case `scheduled`: {\n                    // Cancel other scheduled execution\n                    cancel();\n                    break;\n                }\n                case `running`: {\n                    //console.warn(`Timeout being rescheduled while task is already running`);\n                    break;\n                }\n            }\n            state = `scheduled`;\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            timer = globalThis.setTimeout(async () => {\n                if (state !== `scheduled`) {\n                    console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n                    clear();\n                    return;\n                }\n                const args_ = args ?? [];\n                startCount++;\n                startCountTotal++;\n                state = `running`;\n                await callback(performance.now() - startedAt, ...args_);\n                state = `idle`;\n                clear();\n                resolve();\n            }, altTimeoutMs);\n        });\n        return p;\n    };\n    const cancel = () => {\n        if (state === `idle`)\n            return;\n        clear();\n    };\n    return {\n        start,\n        cancel,\n        get runState() {\n            return state;\n        },\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        }\n    };\n};\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });\n","import { timeout, } from './timeout.js';\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param interval Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (callback, interval) => {\n    const t = timeout(callback, interval);\n    return (...args) => { t.start(undefined, args); };\n};\n","/**\n * Maintains a list of listeners to receive data\n *\n * ```js\n * const d = new DispatchList();\n *\n * // Eg: add a listener\n * d.add(v => {\n *  // Handle a value\n * });\n *\n * // Eg. send a value to all listeners\n * d.notify(`some value`);\n * ```\n */\nexport class DispatchList {\n    #handlers;\n    #counter = 0;\n    #id = Math.floor(Math.random() * 100);\n    constructor() {\n        this.#handlers = [];\n    }\n    /**\n     * Returns _true_ if list is empty\n     * @returns\n     */\n    isEmpty() {\n        return this.#handlers.length === 0;\n    }\n    /**\n     * Adds a handler. You get back an id which can be used\n     * to remove the handler later.\n     *\n     * Handlers can be added with 'once' flag set to _true_. This will\n     * automatically remove them after the first value is sent to them.\n     * @param handler\n     * @param options\n     * @returns\n     */\n    add(handler, options = {}) {\n        this.#counter++;\n        const once = options.once ?? false;\n        const wrap = {\n            id: `${this.#id} - ${this.#counter}`,\n            handler,\n            once\n        };\n        this.#handlers.push(wrap);\n        return wrap.id;\n    }\n    /**\n     * Remove a handler by its id.\n     * @param id\n     * @returns _True_ if handler was removed, _false_ if not found.\n     */\n    remove(id) {\n        const length = this.#handlers.length;\n        this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n        return this.#handlers.length !== length;\n    }\n    /**\n     * Emit a value to all handlers\n     * @param value\n     */\n    notify(value) {\n        for (const handler of this.#handlers) {\n            handler.handler(value);\n            if (handler.once) {\n                this.remove(handler.id);\n            }\n        }\n    }\n    /**\n     * Remove all handlers\n     */\n    clear() {\n        this.#handlers = [];\n    }\n}\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = (nth, callback) => {\n    resultThrow(integerTest(nth, `positive`, `nth`));\n    let counter = 0;\n    return (data) => {\n        counter++;\n        if (counter === nth) {\n            counter = 0;\n            if (callback)\n                callback(data);\n            return true;\n        }\n        return false;\n    };\n};\n","import { defaultComparer } from '@ixfx/core';\nimport { shuffle } from '@ixfx/arrays';\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = runSingle([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async (expressions, opts = {}, args) => {\n    const results = [];\n    const compareFunction = opts.rank ?? defaultComparer;\n    let expressionsArray = Array.isArray(expressions)\n        ? (expressions)\n        : [expressions];\n    if (opts.shuffle)\n        expressionsArray = shuffle(expressionsArray);\n    for (let index = 0; index < expressionsArray.length; index++) {\n        const exp = expressionsArray[index];\n        let r;\n        if (typeof exp === 'function') {\n            // @ts-ignore\n            r = await exp(args);\n        }\n        else {\n            r = exp;\n        }\n        if (r !== undefined) {\n            results.push(r);\n            results.sort(compareFunction);\n        }\n        if (typeof opts.stop !== 'undefined') {\n            if (opts.stop(r, results)) {\n                break;\n            }\n        }\n    }\n    if (opts.filter) {\n        return results.filter(opts.filter);\n    }\n    return results;\n};\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async (expressions, opts = {}, args) => {\n    const results = await run(expressions, opts, args);\n    if (!results)\n        return;\n    if (results.length === 0)\n        return;\n    const at = opts.at ?? -1;\n    return results.at(at);\n};\n","/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n *\n * By default waits a maximum of 1 minute.\n *\n * Automatically unsubscribes on success or failure (ie. timeout)\n *\n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns\n */\nexport const eventRace = (target, eventNames, options = {}) => {\n    const intervalMs = options.timeoutMs ?? 60_1000; //intervalToMs(options.timeout, 60 * 1000);\n    const signal = options.signal;\n    let triggered = false;\n    let disposed = false;\n    let timeout;\n    const promise = new Promise((resolve, reject) => {\n        const onEvent = (event) => {\n            if (`type` in event) {\n                if (eventNames.includes(event.type)) {\n                    triggered = true;\n                    resolve(event);\n                    dispose();\n                }\n                else {\n                    console.warn(`eventRace: Got event '${event.type}' that is not in race list`);\n                }\n            }\n            else {\n                console.warn(`eventRace: Event data does not have expected 'type' field`);\n                console.log(event);\n            }\n        };\n        for (const name of eventNames) {\n            target.addEventListener(name, onEvent);\n        }\n        const dispose = () => {\n            if (disposed)\n                return;\n            if (timeout !== undefined)\n                clearTimeout(timeout);\n            timeout = undefined;\n            disposed = true;\n            for (const name of eventNames) {\n                target.removeEventListener(name, onEvent);\n            }\n        };\n        timeout = setTimeout(() => {\n            if (triggered || disposed)\n                return;\n            dispose();\n            reject(new Error(`eventRace: Events not fired within interval. Events: ${JSON.stringify(eventNames)} Interval: ${intervalMs}`));\n        }, intervalMs);\n        signal?.addEventListener(`abort`, () => {\n            if (triggered || disposed)\n                return;\n            dispose();\n            reject(new Error(`Abort signal received ${signal.reason}`));\n        });\n    });\n    return promise;\n};\n","import { movingAverageLight } from \"@ixfx/numbers\";\nimport { rateMinimum } from \"@ixfx/flow\";\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n *\n * mat(); // Get current average\n * ```\n *\n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n *\n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options) => {\n    const average = movingAverageLight();\n    const rm = rateMinimum({\n        ...options,\n        whatToCall: (distance) => {\n            average(distance);\n        },\n        fallback() {\n            return options.default ?? 0;\n        }\n    });\n    return (v) => {\n        rm(v);\n        return average();\n    };\n};\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as Debug from '@ixfx/debug';\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser extends SimpleEventEmitter {\n    key;\n    resource;\n    _lastUpdate;\n    _pool;\n    _state;\n    _userExpireAfterMs;\n    /**\n     * Constructor\n     * @param key User key\n     * @param resource Resource being used\n     */\n    constructor(key, resource) {\n        super();\n        this.key = key;\n        this.resource = resource;\n        this._lastUpdate = performance.now();\n        this._pool = resource.pool;\n        this._userExpireAfterMs = this._pool.userExpireAfterMs;\n        this._state = `idle`;\n        this._pool.log.log(`PoolUser ctor key: ${this.key}`);\n    }\n    /**\n     * Returns a human readable debug string\n     * @returns\n     */\n    toString() {\n        if (this.isDisposed)\n            return `PoolUser. State: disposed`;\n        return `PoolUser. State: ${this._state} Elapsed: ${performance.now() - this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`;\n    }\n    /**\n     * Resets countdown for instance expiry.\n     * Throws an error if instance is disposed.\n     */\n    keepAlive() {\n        if (this._state === `disposed`)\n            throw new Error(`PoolItem disposed`);\n        this._lastUpdate = performance.now();\n    }\n    /**\n     * @internal\n     * @param reason\n     * @returns\n     */\n    _dispose(reason, data) {\n        if (this._state === `disposed`)\n            return;\n        const resource = this.resource;\n        //const data = resource.data;\n        this._state = `disposed`;\n        resource._release(this);\n        this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${reason}`);\n        this.fireEvent(`disposed`, { data, reason });\n        super.clearEventListeners();\n    }\n    /**\n     * Release this instance\n     * @param reason\n     */\n    release(reason) {\n        if (this.isDisposed)\n            throw new Error(`User disposed`);\n        const resource = this.resource;\n        const data = resource.data;\n        this._pool.log.log(`PoolUser release key: ${this.key} reason: ${reason}`);\n        this.fireEvent(`released`, { data, reason });\n        this._dispose(`release-${reason}`, data);\n    }\n    // #region Properties\n    get data() {\n        if (this.isDisposed)\n            throw new Error(`User disposed`);\n        return this.resource.data;\n    }\n    /**\n     * Returns true if this instance has expired.\n     * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n     */\n    get isExpired() {\n        if (this._userExpireAfterMs > 0) {\n            return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n        }\n        return false;\n    }\n    /**\n     * Returns elapsed time since last 'update'\n     */\n    get elapsed() {\n        return performance.now() - this._lastUpdate;\n    }\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed() {\n        return this._state === `disposed`;\n    }\n    /**\n     * Returns true if instance is neither disposed nor expired\n     */\n    get isValid() {\n        if (this.isDisposed || this.isExpired)\n            return false;\n        if (this.resource.isDisposed)\n            return false;\n        return true;\n    }\n}\n/**\n * A resource allocated in the Pool\n */\nexport class Resource {\n    pool;\n    #state;\n    #data;\n    #users;\n    #capacityPerResource;\n    #resourcesWithoutUserExpireAfterMs;\n    #lastUsersChange;\n    /**\n     * Constructor.\n     * @param pool Pool\n     * @param data Data\n     */\n    constructor(pool, data) {\n        this.pool = pool;\n        if (data === undefined)\n            throw new Error(`Parameter 'data' is undefined`);\n        if (pool === undefined)\n            throw new Error(`Parameter 'pool' is undefined`);\n        this.#data = data;\n        this.#lastUsersChange = 0;\n        this.#resourcesWithoutUserExpireAfterMs =\n            pool.resourcesWithoutUserExpireAfterMs;\n        this.#capacityPerResource = pool.capacityPerResource;\n        this.#users = [];\n        this.#state = `idle`;\n    }\n    /**\n     * Gets data associated with resource.\n     * Throws an error if disposed\n     */\n    get data() {\n        if (this.#state === `disposed`)\n            throw new Error(`Resource disposed`);\n        return this.#data;\n    }\n    /**\n     * Changes the data associated with this resource.\n     * Throws an error if disposed or `data` is undefined.\n     * @param data\n     */\n    updateData(data) {\n        if (this.#state === `disposed`)\n            throw new Error(`Resource disposed`);\n        if (data === undefined)\n            throw new Error(`Parameter 'data' is undefined`);\n        this.#data = data;\n    }\n    /**\n     * Returns a human-readable debug string for resource\n     * @returns\n     */\n    toString() {\n        return `Resource (expired: ${this.isExpiredFromUsers} users: ${this.#users.length}, state: ${this.#state}) data: ${JSON.stringify(this.data)}`;\n    }\n    /**\n     * Assigns a user to this resource.\n     * @internal\n     * @param user\n     */\n    _assign(user) {\n        const existing = this.#users.find((u) => u === user || u.key === user.key);\n        if (existing)\n            throw new Error(`User instance already assigned to resource`);\n        this.#users.push(user);\n        this.#lastUsersChange = performance.now();\n    }\n    /**\n     * Releases a user from this resource\n     * @internal\n     * @param user\n     */\n    _release(user) {\n        this.#users = this.#users.filter((u) => u !== user);\n        this.pool._release(user);\n        this.#lastUsersChange = performance.now();\n    }\n    /**\n     * Returns true if resource can have additional users allocated\n     */\n    get hasUserCapacity() {\n        return this.usersCount < this.#capacityPerResource;\n    }\n    /**\n     * Returns number of uses of the resource\n     */\n    get usersCount() {\n        return this.#users.length;\n    }\n    /**\n     * Returns true if automatic expiry is enabled, and that interval\n     * has elapsed since the users list has changed for this resource\n     */\n    get isExpiredFromUsers() {\n        if (this.#resourcesWithoutUserExpireAfterMs <= 0)\n            return false;\n        if (this.#users.length > 0)\n            return false;\n        return (performance.now() >\n            this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange);\n    }\n    /**\n     * Returns true if instance is disposed\n     */\n    get isDisposed() {\n        return this.#state === `disposed`;\n    }\n    /**\n     * Disposes the resource.\n     * If it is already disposed, it does nothing.\n     * @param reason\n     * @returns\n     */\n    dispose(reason) {\n        if (this.#state === `disposed`)\n            return;\n        const data = this.#data;\n        this.#state = `disposed`;\n        this.pool.log.log(`Resource disposed (${reason})`);\n        for (const u of this.#users) {\n            u._dispose(`resource-${reason}`, data);\n        }\n        this.#users = [];\n        this.#lastUsersChange = performance.now();\n        this.pool._releaseResource(this, reason);\n        if (this.pool.freeResource)\n            this.pool.freeResource(data);\n    }\n}\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'.\n * All resources in the Pool are meant to be the same kind of object.\n *\n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n *\n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n *\n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport class Pool {\n    _resources;\n    _users;\n    capacity;\n    userExpireAfterMs;\n    resourcesWithoutUserExpireAfterMs;\n    capacityPerResource;\n    fullPolicy;\n    generateResource;\n    freeResource;\n    log = Debug.logSet(`Pool`);\n    /**\n     * Constructor.\n     *\n     * By default, no capacity limit, one user per resource\n     * @param options Pool options\n     */\n    constructor(options = {}) {\n        this.capacity = options.capacity ?? -1;\n        this.fullPolicy = options.fullPolicy ?? `error`;\n        this.capacityPerResource = options.capacityPerResource ?? 1;\n        this.userExpireAfterMs = options.userExpireAfterMs ?? -1;\n        this.resourcesWithoutUserExpireAfterMs =\n            options.resourcesWithoutUserExpireAfterMs ?? -1;\n        this.generateResource = options.generate;\n        this.freeResource = options.free;\n        this._users = new Map();\n        this._resources = [];\n        this.log = Debug.logSet(`Pool`, options.debug ?? false);\n        // If we have a time-based expiry, set an interval to\n        // automatically do the housekeeping\n        const timer = Math.max(this.userExpireAfterMs, this.resourcesWithoutUserExpireAfterMs);\n        if (timer > 0) {\n            setInterval(() => {\n                this.maintain();\n            }, timer * 1.1);\n        }\n    }\n    /**\n     * Returns a debug string of Pool state\n     * @returns\n     */\n    dumpToString() {\n        let r = `Pool\n    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}\n    resources count: ${this._resources.length}`;\n        const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n        r += `\\r\\nResources:\\r\\n\\t` + resource;\n        r += `\\r\\nUsers: \\r\\n`;\n        for (const [k, v] of this._users.entries()) {\n            r += `\\tk: ${k} v: ${v.toString()}\\r\\n`;\n        }\n        return r;\n    }\n    /**\n     * Sorts users by longest elapsed time since update\n     * @returns\n     */\n    getUsersByLongestElapsed() {\n        return [...this._users.values()].sort((a, b) => {\n            const aa = a.elapsed;\n            const bb = b.elapsed;\n            if (aa === bb)\n                return 0;\n            if (aa < bb)\n                return 1;\n            return -1;\n        });\n    }\n    /**\n     * Returns resources sorted with least used first\n     * @returns\n     */\n    getResourcesSortedByUse() {\n        return [...this._resources].sort((a, b) => {\n            if (a.usersCount === b.usersCount)\n                return 0;\n            if (a.usersCount < b.usersCount)\n                return -1;\n            return 1;\n        });\n    }\n    /**\n     * Adds a shared resource to the pool\n     * @throws Error if the capacity limit is reached or resource is null\n     * @param resource\n     * @returns\n     */\n    addResource(resource) {\n        if (resource === undefined) {\n            throw new Error(`Cannot add undefined resource`);\n        }\n        if (resource === null)\n            throw new TypeError(`Cannot add null resource`);\n        if (this.capacity > 0 && this._resources.length === this.capacity) {\n            throw new Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);\n        }\n        this.log.log(`Adding resource: ${JSON.stringify(resource)}`);\n        const pi = new Resource(this, resource);\n        this._resources.push(pi);\n        return pi;\n    }\n    /**\n     * Performs maintenance, removing disposed/expired resources & users.\n     * This is called automatically when using a resource.\n     */\n    maintain() {\n        let changed = false;\n        // Find all disposed resources\n        const nuke = [];\n        for (const p of this._resources) {\n            if (p.isDisposed) {\n                this.log.log(`Maintain, disposed resource: ${JSON.stringify(p.data)}`);\n                nuke.push(p);\n            }\n            else if (p.isExpiredFromUsers) {\n                this.log.log(`Maintain, expired resource: ${JSON.stringify(p.data)}`);\n                nuke.push(p);\n            }\n        }\n        // Remove them\n        if (nuke.length > 0) {\n            for (const resource of nuke) {\n                resource.dispose(`diposed/expired`);\n            }\n            changed = true;\n        }\n        // Find 'users' to clean up\n        const userKeysToRemove = [];\n        for (const [key, user] of this._users.entries()) {\n            if (!user.isValid) {\n                this.log.log(`Maintain. Invalid user: ${user.key} (Disposed: ${user.isDisposed} Expired: ${user.isExpired} Resource disposed: ${user.resource.isDisposed})`);\n                userKeysToRemove.push(key);\n                user._dispose(`invalid`, user.data);\n            }\n        }\n        for (const userKey of userKeysToRemove) {\n            this._users.delete(userKey);\n            changed = true;\n        }\n        if (changed) {\n            this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`);\n        }\n    }\n    /**\n     * Iterate over resources in the pool.\n     * To iterate over the data associated with each resource, use\n     * `values`.\n     */\n    *resources() {\n        const resource = [...this._resources];\n        for (const r of resource) {\n            yield r;\n        }\n    }\n    /**\n     * Iterate over resource values in the pool.\n     * to iterate over the resources, use `resources`.\n     *\n     * Note that values may be returned even though there is no\n     * active user.\n     */\n    *values() {\n        const resource = [...this._resources];\n        for (const r of resource) {\n            yield r.data;\n        }\n    }\n    /**\n     * Unassociate a key with a pool item\n     * @param userKey\n     */\n    release(userKey, reason) {\n        const pi = this._users.get(userKey);\n        if (!pi)\n            return;\n        pi.release(reason ?? `Pool.release`);\n    }\n    /**\n     * @internal\n     * @param user\n     */\n    _release(user) {\n        this._users.delete(user.key);\n    }\n    /**\n     * @internal\n     * @param resource\n     * @param _\n     */\n    _releaseResource(resource, _) {\n        this._resources = this._resources.filter((v) => v !== resource);\n    }\n    /**\n     * Returns true if `v` has an associted resource in the pool\n     * @param resource\n     * @returns\n     */\n    hasResource(resource) {\n        const found = this._resources.find((v) => v.data === resource);\n        return found !== undefined;\n    }\n    /**\n     * Returns true if a given `userKey` is in use.\n     * @param userKey\n     * @returns\n     */\n    hasUser(userKey) {\n        return this._users.has(userKey);\n    }\n    /**\n     * @internal\n     * @param key\n     * @param resource\n     * @returns\n     */\n    _assign(key, resource) {\n        const u = new PoolUser(key, resource);\n        this._users.set(key, u);\n        resource._assign(u);\n        return u;\n    }\n    /**\n     * Allocates a resource for `userKey`\n     * @internal\n     * @param userKey\n     * @returns\n     */\n    #allocateResource(userKey) {\n        // Sort items by number of users per pool item\n        const sorted = this.getResourcesSortedByUse();\n        // for (let i=0;i<sorted.length;i++) {\n        //   console.log(i +`. users: ` + sorted[i].usersCount);\n        // }\n        if (sorted.length > 0 && sorted[0].hasUserCapacity) {\n            // No problem, resource has capacity\n            //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n            const u = this._assign(userKey, sorted[0]);\n            return u;\n        }\n        // If resource count is below capacity, can we generate more?\n        if (this.generateResource &&\n            (this.capacity < 0 || this._resources.length < this.capacity)) {\n            this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);\n            const resourceGenerated = this.addResource(this.generateResource());\n            const u = this._assign(userKey, resourceGenerated);\n            return u;\n        }\n    }\n    /**\n     * Return the number of users\n     */\n    get usersLength() {\n        return [...this._users.values()].length;\n    }\n    /**\n     * 'Uses' a resource, returning the value\n     * @param userKey\n     * @returns\n     */\n    useValue(userKey) {\n        const resource = this.use(userKey);\n        return resource.resource.data;\n    }\n    /**\n     * Gets a pool item based on a 'user' key.\n     *\n     * The same key should return the same pool item,\n     * for as long as it still exists.\n     *\n     * If a 'user' already has a resource, it will 'keep alive' their use.\n     * If a 'user' does not already have resource\n     *  - if there is capacity, a resource is allocated to user\n     *  - if pool is full\n     *    - fullPolicy = 'error': an error is thrown\n     *    - fullPolicy = 'evictOldestUser': evicts an older user\n     *    - Throw error\n     * @param userKey\n     * @throws Error If all resources are used and fullPolicy = 'error'\n     * @returns\n     */\n    use(userKey) {\n        const pi = this._users.get(userKey);\n        if (pi) {\n            pi.keepAlive();\n            return pi;\n        }\n        this.maintain();\n        const match = this.#allocateResource(userKey);\n        if (match)\n            return match;\n        // Throw an error if all items are being used\n        if (this.fullPolicy === `error`) {\n            //console.log(this.dumpToString());\n            throw new Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);\n        }\n        // Evict oldest user\n        if (this.fullPolicy === `evictOldestUser`) {\n            const users = this.getUsersByLongestElapsed();\n            if (users.length > 0) {\n                this.release(users[0].key, `evictedOldestUser`);\n                const match2 = this.#allocateResource(userKey);\n                if (match2)\n                    return match2;\n            }\n        }\n        // Evict newest user\n        // Evict from random pool item\n        throw new Error(`Pool is fully used (${this.fullPolicy})`);\n    }\n}\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport const create = (options = {}) => new Pool(options);\n","/**\n * Creates a new Promise, returning the promise\n * along with its resolve and reject functions.\n *\n * ```js\n * const { promise, resolve, reject } = promiseWithResolvers();\n *\n * setTimeout(() => {\n *  resolve();\n * }, 1000);\n *\n * await promise;\n * ```\n *\n * Promise would be passed somewhere that expects a promise,\n * and you're free to call `resolve` or `reject` when needed.\n * @returns\n */\nexport function promiseWithResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = _resolve;\n        reject = _reject;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: resolve, reject: reject };\n}\n","import { timeout } from \"./timeout.js\";\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n *\n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n *\n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n *\n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ```\n *\n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n *\n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n *\n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n *\n * @param options\n * @returns\n */\nexport const rateMinimum = (options) => {\n    let disposed = false;\n    const t = timeout(() => {\n        if (disposed)\n            return;\n        t.start();\n        options.whatToCall(options.fallback());\n    }, options.interval);\n    if (options.abort) {\n        options.abort.addEventListener(`abort`, _ => {\n            disposed = true;\n            t.cancel();\n        });\n    }\n    t.start();\n    return (args) => {\n        if (disposed)\n            throw new Error(`AbortSignal has been fired`);\n        t.start();\n        options.whatToCall(args);\n    };\n};\n","import { resolve, resolveSync } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat(produce, opts) {\n    const signal = opts.signal ?? undefined;\n    const delayWhen = opts.delayWhen ?? `before`;\n    const count = opts.count ?? undefined;\n    const allowUndefined = opts.allowUndefined ?? false;\n    const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n    const whileFunction = opts.while;\n    let cancelled = false;\n    let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n    let started = performance.now();\n    const doDelay = async () => {\n        const elapsed = performance.now() - started;\n        if (typeof minIntervalMs !== `undefined`) {\n            sleepMs = Math.max(0, minIntervalMs - elapsed);\n        }\n        if (sleepMs) {\n            await sleep({ millis: sleepMs, signal });\n        }\n        started = performance.now();\n        if (signal?.aborted)\n            throw new Error(`Signal aborted ${signal.reason}`);\n    };\n    if (Array.isArray(produce))\n        produce = produce.values();\n    if (opts.onStart)\n        opts.onStart();\n    let errored = true;\n    let loopedTimes = 0;\n    try {\n        while (!cancelled) {\n            loopedTimes++;\n            if (delayWhen === `before` || delayWhen === `both`)\n                await doDelay();\n            const result = await resolve(produce);\n            if (typeof result === `undefined` && !allowUndefined) {\n                cancelled = true;\n            }\n            else {\n                yield result;\n                if (delayWhen === `after` || delayWhen === `both`)\n                    await doDelay();\n                if (count !== undefined && loopedTimes >= count)\n                    cancelled = true;\n            }\n            if (whileFunction) {\n                if (!whileFunction(loopedTimes)) {\n                    cancelled = true;\n                }\n            }\n        }\n        errored = false;\n    }\n    finally {\n        cancelled = true;\n        if (opts.onComplete)\n            opts.onComplete(errored);\n    }\n}\n;\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n *\n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n *\n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync(produce, opts) {\n    const signal = opts.signal ?? undefined;\n    const count = opts.count ?? undefined;\n    const allowUndefined = opts.allowUndefined ?? false;\n    let cancelled = false;\n    if (Array.isArray(produce))\n        produce = produce.values();\n    if (opts.onStart)\n        opts.onStart();\n    let errored = true;\n    let loopedTimes = 0;\n    try {\n        while (!cancelled) {\n            loopedTimes++;\n            const result = resolveSync(produce);\n            if (typeof result === `undefined` && !allowUndefined) {\n                cancelled = true;\n            }\n            else {\n                yield result;\n                if (count !== undefined && loopedTimes >= count)\n                    cancelled = true;\n                if (signal?.aborted)\n                    cancelled = true;\n            }\n        }\n        errored = false;\n    }\n    finally {\n        cancelled = true;\n        if (opts.onComplete)\n            opts.onComplete(errored);\n    }\n}\n;\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { continuously } from \"@ixfx/core\";\nimport { SimpleEventEmitter } from \"@ixfx/events\";\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n *\n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n *\n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n *\n *\n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id;\n *  }\n * });\n * ```\n *\n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id;\n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n *\n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport class RequestResponseMatch extends SimpleEventEmitter {\n    timeoutMs;\n    whenUnmatchedResponse;\n    keyRequest;\n    keyResponse;\n    #outgoing = new Map();\n    #maintainLoop;\n    constructor(options = {}) {\n        super();\n        if (typeof window === `undefined`) {\n            globalThis.window = {\n                setTimeout: setTimeout,\n                clearTimeout: clearTimeout\n            };\n        }\n        this.timeoutMs = options.timeoutMs ?? 1000;\n        this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;\n        this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);\n        if (options.key) {\n            if (options.keyRequest)\n                throw new Error(`Cannot set 'keyRequest' when 'key' is set `);\n            if (options.keyResponse)\n                throw new Error(`Cannot set 'keyResponse' when 'key' is set `);\n            this.keyRequest = options.key;\n            this.keyResponse = options.key;\n        }\n        else {\n            if (!options.keyRequest || !options.keyResponse) {\n                throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);\n            }\n            this.keyRequest = options.keyRequest;\n            this.keyResponse = options.keyResponse;\n        }\n    }\n    #maintain() {\n        const values = [...this.#outgoing.values()];\n        const now = Date.now();\n        for (const v of values) {\n            if (v.expiresAt <= now) {\n                if (v.promiseReject) {\n                    v.promiseReject(`Request timeout`);\n                }\n                const callback = v.callback;\n                if (callback) {\n                    setTimeout(() => {\n                        callback(true, `Request timeout`);\n                    }, 1);\n                }\n                this.fireEvent(`completed`, { request: v.req, response: `Request timeout`, success: false });\n                this.#outgoing.delete(v.id);\n            }\n        }\n        this.debugDump();\n        return this.#outgoing.size > 0;\n    }\n    debugDump() {\n        const values = [...this.#outgoing.values()];\n        const now = Date.now();\n        for (const v of values) {\n            const expire = now - v.expiresAt;\n            console.log(`${v.id} Expires in: ${Math.floor(expire / 1000).toString()}s`);\n        }\n    }\n    /**\n     * Makes a request.\n     * If `callback` is set, it's equivalent to calling `requestCallback`.\n     * If `callback` is not set, a promise is returned\n     * @param request\n     * @param callback\n     * @returns\n     */\n    request(request, callback) {\n        if (callback !== undefined) {\n            this.#requestCallback(request, callback);\n            return;\n        }\n        return this.#requestAwait(request);\n    }\n    /**\n     * Make a request and don't wait for the outcome.\n     * @param request\n     */\n    requestAndForget(request) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const r = {\n            expiresAt: Date.now() + this.timeoutMs,\n            id,\n            req: request\n        };\n        this.#outgoing.set(id, r);\n        this.#maintainLoop.start();\n    }\n    /**\n     * Make a request, returning a Promise for the outcome.\n     * Errors will throw an exception.\n     * @param request\n     * @returns\n     */\n    #requestAwait(request) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const p = new Promise((resolve, reject) => {\n            const r = {\n                expiresAt: Date.now() + this.timeoutMs,\n                id,\n                req: request,\n                promiseResolve: resolve,\n                promiseReject: reject\n            };\n            this.#outgoing.set(id, r);\n            this.#maintainLoop.start();\n        });\n        return p;\n    }\n    /**\n     * Make a request, and get notified of outcome with a callback\n     * @param request\n     * @param callback\n     */\n    #requestCallback(request, callback) {\n        const id = this.keyRequest(request);\n        if (this.#outgoing.has(id))\n            throw new Error(`Already a request pending with id '${id}'`);\n        const r = {\n            expiresAt: Date.now() + this.timeoutMs,\n            id,\n            req: request,\n            callback\n        };\n        this.#outgoing.set(id, r);\n        this.#maintainLoop.start();\n    }\n    /**\n     * Response has been received\n     * @param response Response\n     * @returns _True_ if response matched a request\n     */\n    response(response, keepAlive) {\n        const id = this.keyResponse(response);\n        const request = this.#outgoing.get(id);\n        if (!request) {\n            if (this.whenUnmatchedResponse === `throw`)\n                throw new Error(`Unmatched response with id: '${id}'`, { cause: response });\n            // otherwise ignore\n            return false;\n        }\n        if (keepAlive) {\n            // Continue life of request\n            request.expiresAt = Date.now() + this.timeoutMs;\n        }\n        else {\n            this.#outgoing.delete(id);\n        }\n        if (request.promiseResolve) {\n            request.promiseResolve(response);\n        }\n        if (request.callback) {\n            request.callback(false, response);\n        }\n        this.fireEvent(`match`, { request: request.req, response: response });\n        if (!keepAlive) {\n            this.fireEvent(`completed`, { request: request.req, response: response, success: true });\n        }\n        return true;\n    }\n}\n","import { elapsedSince, sleep } from '@ixfx/core';\nimport { resolveLogOption } from '@ixfx/debug';\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { getErrorMessage } from '@ixfx/debug';\nimport { elapsedToHumanString } from '@ixfx/core';\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n *\n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n *\n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n *\n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n *\n * @param options\n * @returns\n */\nexport function* backoffGenerator(options = {}) {\n    const startAt = options.startAt ?? 1;\n    let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n    const limitValue = options.limitValue;\n    const power = options.power ?? 1.1;\n    let value = startAt;\n    resultThrow(integerTest(limitAttempts, `aboveZero`, `limitAttempts`), numberTest(startAt, ``, `startAt`), numberTest(limitAttempts, ``, `limitAttempts`), () => (limitValue !== undefined) ? numberTest(limitValue, ``, `limitValue`) : undefined, numberTest(power, ``, `power`));\n    while (limitAttempts > 0) {\n        // Value has climbed to the limit\n        if (limitValue && value >= limitValue)\n            return;\n        limitAttempts--;\n        yield value;\n        // Increase value for next iteration\n        value += Math.pow(value, power);\n    }\n}\n/**\n * Keeps calling `callback` until it returns something other than _undefined_.\n * There is an exponentially-increasing delay between each retry attempt.\n *\n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport const retryFunction = (callback, options = {}) => {\n    const task = {\n        async probe() {\n            try {\n                const v = await callback();\n                if (v === undefined)\n                    return { value: options.taskValueFallback, error: `Fallback`, success: false };\n                return { value: v, success: true };\n            }\n            catch (error) {\n                return { success: false, error: error };\n            }\n        },\n    };\n    return retryTask(task, options);\n};\n/**\n * Keeps trying to run `task`.\n *\n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *\n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n *\n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task\n * @param opts\n * @returns\n */\nexport const retryTask = async (task, opts = {}) => {\n    const signal = opts.abort;\n    const log = resolveLogOption(opts.log);\n    const predelayMs = opts.predelayMs ?? 0;\n    const startedAt = elapsedSince();\n    let attempts = 0;\n    const initialValue = opts.startAt ?? 1000;\n    const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n    const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n    if (initialValue <= 0)\n        throw new Error(`Param 'initialValue' must be above zero`);\n    if (predelayMs > 0) {\n        try {\n            await sleep({ millis: predelayMs, signal: signal });\n        }\n        catch (error) {\n            // Could happen due to abort signal\n            return {\n                success: false,\n                attempts,\n                value: opts.taskValueFallback,\n                elapsed: startedAt(),\n                message: getErrorMessage(error),\n            };\n        }\n    }\n    for (const t of backoffGen) {\n        attempts++;\n        // Run task\n        const result = await task.probe(attempts);\n        if (result.success) {\n            return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n        }\n        log({\n            msg: `retry attempts: ${attempts.toString()} t: ${elapsedToHumanString(t)}`,\n        });\n        // Did not succeed.\n        if (attempts >= limitAttempts) {\n            break; // Out of attempts, no point sleeping again\n        }\n        // Sleep\n        try {\n            await sleep({ millis: t, signal });\n        }\n        catch (error) {\n            // Eg if abort signal fires\n            return {\n                success: false,\n                attempts,\n                value: opts.taskValueFallback,\n                message: getErrorMessage(error),\n                elapsed: startedAt(),\n            };\n        }\n    }\n    return {\n        message: `Giving up after ${attempts.toString()} attempts.`,\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n    };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun) => {\n    let run = false;\n    let success = false;\n    return () => {\n        if (run)\n            return success;\n        run = true;\n        success = onRun();\n        return success;\n    };\n};\n","/**\n * Simple synchronisation. Supports only a single signal/waiter.\n * Expects one or more calls to .signal() for .forSignal() to resolve\n *\n * ```js\n * const sw = new SyncWait();\n * obj.addEventListener(`click`, () => {\n *  sw.signal();\n * });\n *\n * // Wait until click event\n * await sw.forSignal();\n * ```\n *\n * `forSignal` can also take a maximum time to wait. If the\n * time elapses, an exception is thrown.\n *\n * {@link didSignal} returns _true_/_false_ if signal happened rather\n * than throwing an exception.\n *\n */\nexport class SyncWait {\n    #resolve;\n    #reject;\n    #promise;\n    signal() {\n        if (this.#resolve) {\n            this.#resolve();\n            this.#resolve = undefined;\n        }\n        this.#promise = Promise.resolve();\n    }\n    /**\n     * Throw away any previous signalled state.\n     * This will cause any currently waiters to throw\n     */\n    flush() {\n        if (this.#reject) {\n            this.#reject(`Flushed`);\n            this.#reject = undefined;\n        }\n        this.#resolve = undefined;\n        this.#promise = undefined;\n    }\n    #initPromise() {\n        const p = new Promise((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n        });\n        this.#promise = p;\n        return p;\n    }\n    /**\n     * Call with `await` to wait until .signal() happens.\n     * If a wait period is specified, an exception is thrown if signal does not happen within this time.\n     * @param maximumWaitMs\n     */\n    async forSignal(maximumWaitMs) {\n        let p = this.#promise;\n        p ??= this.#initPromise();\n        if (maximumWaitMs) {\n            const reject = this.#reject;\n            setTimeout(() => {\n                if (reject) {\n                    reject(`Timeout elapsed ${maximumWaitMs.toString()}`);\n                }\n            }, maximumWaitMs);\n        }\n        await p;\n        this.#promise = undefined;\n        this.#resolve = undefined;\n        this.#reject = undefined;\n    }\n    /**\n     * An alternative to {@link forSignal}, returning _true_\n     * if signalled, or _false_ if wait period was exceeded\n     *\n     * ```js\n     * const s = await sw.didSignal(5000);\n     * ```\n     * @param maximumWaitMs\n     * @returns\n     */\n    async didSignal(maximumWaitMs) {\n        try {\n            await this.forSignal(maximumWaitMs);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { Queues } from '@ixfx/collections';\nimport { continuously } from '@ixfx/core';\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n *\n * The TaskQueueMutable is shared across your code,\n * so you don't create it directly. Rather, use:\n *\n * ```js\n * const queue = TaskQueueMutable.shared;\n * ```\n *\n * @example Usage\n * ```js\n * const queue = TaskQueueMutable.shared;\n * q.enqueue(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n *\n * You can listen to events from the TaskQueue:\n * ```js\n * TaskQueueMutable.shared.addEventListener(`started`, () => {\n *  // Queue was empty, now started processing\n * });\n *\n * TaskQueueMutable.shared.addEventListener(`empty`, () => {\n *  // Queue has finished processing all items\n * });\n * ```\n */\nexport class TaskQueueMutable extends SimpleEventEmitter {\n    static shared = new TaskQueueMutable();\n    _loop;\n    _queue;\n    constructor() {\n        super();\n        this._queue = Queues.mutable();\n        this._loop = continuously(() => {\n            return this.processQueue();\n        }, 100);\n    }\n    /**\n     * Adds a task. This triggers processing loop if not already started.\n     *\n     * ```js\n     * queue.add(async () => {\n     *  await sleep(1000);\n     * });\n     * ```\n     * @param task Task to run\n     */\n    enqueue(task) {\n        const length = this._queue.enqueue(task);\n        if (this._loop.runState === `idle`) {\n            this.fireEvent(`started`, {});\n            this._loop.start();\n        }\n        return length;\n    }\n    dequeue() {\n        return this._queue.dequeue();\n    }\n    async processQueue() {\n        const task = this._queue.dequeue();\n        if (task === undefined) {\n            this.fireEvent(`empty`, {});\n            return false;\n        }\n        try {\n            await task();\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }\n    /**\n     * Clears all tasks, and stops any scheduled processing.\n     * Currently running tasks will continue.\n     * @returns\n     */\n    clear() {\n        if (this._queue.length === 0)\n            return;\n        this._queue.clear();\n        this._loop.cancel();\n        this.fireEvent(`empty`, {});\n    }\n    /**\n    * Returns true if queue is empty\n    */\n    get isEmpty() {\n        return this._queue.isEmpty;\n    }\n    /**\n     * Number of items in queue\n     */\n    get length() {\n        return this._queue.length;\n    }\n}\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (callback, intervalMinMs) => {\n    let trigger = 0;\n    return async (...args) => {\n        const elapsed = performance.now() - trigger;\n        if (elapsed >= intervalMinMs) {\n            const r = callback(elapsed, ...args);\n            if (typeof r === `object`)\n                await r;\n            trigger = performance.now();\n        }\n    };\n};\n","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n *\n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n *\n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed) {\n    const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n    return () => t.isDone;\n}\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * const timer = Flow.ofTotal(1000);\n *\n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n *\n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(duration, opts = {}) {\n    const totalMs = intervalToMs(duration);\n    if (!totalMs)\n        throw new Error(`Param 'duration' not valid`);\n    const timerOpts = {\n        ...opts,\n        timer: elapsedMillisecondsAbsolute(),\n    };\n    let t;\n    return () => {\n        t ??= relative(totalMs, timerOpts);\n        return t.elapsed;\n    };\n}\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks, opts = {}) {\n    const timerOpts = {\n        ...opts,\n        timer: elapsedTicksAbsolute(),\n    };\n    let t;\n    return () => {\n        t ??= relative(totalTicks, timerOpts);\n        return t.elapsed;\n    };\n}\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns\n */\nexport const timerAlwaysDone = () => ({\n    elapsed: 1,\n    isDone: true,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reset() {\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    mod(amt) {\n    },\n});\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns\n */\nexport const timerNeverDone = () => ({\n    elapsed: 0,\n    isDone: false,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    reset() {\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    mod() {\n    }\n});\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n *\n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n *\n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n *\n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (total, options = {}) => {\n    if (!Number.isFinite(total)) {\n        return timerAlwaysDone();\n    }\n    else if (Number.isNaN(total)) {\n        return timerNeverDone();\n    }\n    const clampValue = options.clampValue ?? false;\n    const wrapValue = options.wrapValue ?? false;\n    if (clampValue && wrapValue)\n        throw new Error(`clampValue and wrapValue cannot both be enabled`);\n    let modulationAmount = 1;\n    // Create and starts timer\n    const timer = options.timer ?? elapsedMillisecondsAbsolute();\n    // Keep track of value to avoid over-advancing the tick counter\n    let lastValue = 0;\n    const computeElapsed = (value) => {\n        lastValue = value;\n        let v = value / (total * modulationAmount);\n        if (clampValue)\n            v = clamp(v);\n        else if (wrapValue && v >= 1)\n            v = v % 1;\n        return v;\n    };\n    return {\n        mod(amt) {\n            modulationAmount = amt;\n        },\n        get isDone() {\n            //const tmp = computeElapsed();\n            //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n            return computeElapsed(lastValue) >= 1;\n        },\n        get elapsed() {\n            return computeElapsed(timer.elapsed);\n        },\n        reset: () => {\n            timer.reset();\n        }\n    };\n};\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (frequency, options = {}) => {\n    const timer = options.timer ?? elapsedMillisecondsAbsolute();\n    const cyclesPerSecond = frequency / 1000;\n    let modulationAmount = 1;\n    const computeElapsed = () => {\n        // Get position in a cycle\n        const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n        // Get fractional part\n        const f = v - Math.floor(v);\n        if (f < 0) {\n            throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${v} f: ${f}`);\n        }\n        if (f > 1) {\n            throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${v} f: ${f}`);\n        }\n        return f;\n    };\n    return {\n        mod: (amt) => {\n            modulationAmount = amt;\n        },\n        reset: () => {\n            timer.reset();\n        },\n        get isDone() {\n            return computeElapsed() >= 1;\n        },\n        get elapsed() {\n            return computeElapsed();\n        },\n    };\n};\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = () => {\n    let start = performance.now();\n    return {\n        /**\n         * Reset timer\n         */\n        reset: () => {\n            start = performance.now();\n        },\n        /**\n         * Returns elapsed time since start\n         */\n        get elapsed() {\n            return performance.now() - start;\n        }\n    };\n};\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n *\n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = () => {\n    let start = 0;\n    return {\n        /**\n         * Reset ticks to 0. The next call to `elapsed` will return 1.\n         */\n        reset: () => {\n            start = 0;\n        },\n        /**\n         * Get current ticks without incrementing.\n         */\n        get peek() {\n            return start;\n        },\n        /**\n         * Returns the number of elapsed ticks as well as\n         * incrementing the tick count.\n         *\n         * Minimum is 1\n         *\n         * Use {@link peek} to get the current ticks without incrementing.\n         */\n        get elapsed() {\n            return ++start;\n        }\n    };\n};\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n *\n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n *\n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n *\n * @param fn\n * @param timer\n * @returns\n */\nexport const timerWithFunction = (fn, timer) => {\n    if (typeof fn !== `function`)\n        throw new Error(`Param 'fn' should be a function. Got: ${typeof fn}`);\n    let startCount = 1;\n    return {\n        get elapsed() {\n            return timer.elapsed;\n        },\n        get isDone() {\n            return timer.isDone;\n        },\n        get runState() {\n            if (timer.isDone)\n                return `idle`;\n            return `scheduled`;\n        },\n        /**\n         * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n         */\n        get startCount() {\n            return startCount;\n        },\n        get startCountTotal() {\n            return startCount;\n        },\n        compute: () => {\n            const elapsed = timer.elapsed;\n            return fn(elapsed);\n        },\n        reset: () => {\n            timer.reset();\n            startCount++;\n        },\n    };\n};\n","import { intervalToMs } from \"@ixfx/core\";\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `interval` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. Its minimum value will be `interval`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `interval` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param interval Maximum age of cached result\n * @param updateFail `slow` by default\n * @typeParam V - Return type of `fn`\n * @returns Value\n */\nexport const updateOutdated = (fn, interval, updateFail = `slow`) => {\n    let lastRun = 0;\n    let lastValue;\n    let intervalMsCurrent = intervalToMs(interval, 1000);\n    return () => \n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    new Promise(async (resolve, reject) => {\n        const elapsed = performance.now() - lastRun;\n        if (lastValue === undefined || elapsed > intervalMsCurrent) {\n            try {\n                lastRun = performance.now();\n                lastValue = await fn(elapsed);\n                intervalMsCurrent = intervalToMs(interval, 1000);\n            }\n            catch (error) {\n                if (updateFail === `fast`) {\n                    lastValue = undefined;\n                    lastRun = 0;\n                }\n                else if (updateFail === `backoff`) {\n                    intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n                }\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(error);\n                return;\n            }\n        }\n        resolve(lastValue);\n    });\n};\n","import { promiseWithResolvers } from \"./promise-with-resolvers.js\";\n/**\n * Queue of a single item, only once, allows for simple synchronisation.\n *\n * It has a 'first write wins' behaviour\n *\n * ```js\n * const q = new WaitForValue(); // or singleItem();\n *\n * // In some part of the code add a value\n * const value = q.add(`some-val`);\n *\n * // Somewhere else, wait for value\n * await q.get(value);\n * ```\n *\n * It is not possible to `add` a second item (an exception will throw), however\n * it is possible to call `get` as many times as you need.\n *\n * The `.isUsed` property allows you to to check if a value\n * has been already added to the queue.\n *\n * Based on: https://2ality.com/2024/05/proposal-promise-with-resolvers.html\n */\nexport class WaitForValue {\n    #promise;\n    #resolve;\n    #written = false;\n    constructor() {\n        const { promise, resolve } = promiseWithResolvers();\n        this.#promise = promise;\n        this.#resolve = resolve;\n    }\n    /**\n     * Gets the promise\n     * ```js\n     * const wv = new WaitForValue();\n     *\n     * await wv.get();\n     * ```\n     * @returns\n     */\n    get() {\n        return this.#promise;\n    }\n    /**\n     * Adds a value, triggering promise resolution.\n     *\n     * Throws an exception if queue has already been used. Use {@link isUsed} to check.\n     * @param value\n     */\n    add(value) {\n        if (this.#written)\n            throw new Error(`QueueSingleUse has already been used`);\n        this.#written = true;\n        this.#resolve(value);\n    }\n    /**\n     * Returns _true_ if a value has been added\n     * and therefore no more values can be written\n     */\n    get isUsed() {\n        return this.#written;\n    }\n}\n/**\n * {@inheritDoc WaitForValue}\n */\nexport const singleItem = () => new WaitForValue();\n","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n *\n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n *\n * ```js\n * waitFor(1000,\n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n *\n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n *\n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n *\n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (timeoutMs, onAborted, onComplete) => {\n    let t;\n    let success = false;\n    const done = (error) => {\n        if (t !== undefined) {\n            window.clearTimeout(t);\n            t = undefined;\n        }\n        if (error) {\n            onAborted(error);\n        }\n        else {\n            success = true;\n        }\n        if (onComplete !== undefined)\n            onComplete(success);\n    };\n    t = globalThis.setTimeout(() => {\n        t = undefined;\n        try {\n            onAborted(`Timeout after ${timeoutMs}ms`);\n        }\n        finally {\n            if (onComplete !== undefined)\n                onComplete(success);\n        }\n    }, timeoutMs);\n    return done;\n};\n","import { unique } from '@ixfx/arrays';\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = (toClone) => {\n    return Object.freeze({\n        value: toClone.value,\n        visited: [...toClone.visited],\n        machine: toClone.machine,\n    });\n};\n/**\n * Initialises a state machine. [Read more in the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n *\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n *\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n *\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n *\n * StateMachine.isDone(sm); // false\n * StateMachine.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = (stateMachine, initialState) => {\n    const [machine, machineValidationError] = validateMachine(stateMachine);\n    if (!machine)\n        throw new Error(machineValidationError);\n    const state = \n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState) ?? Object.keys(machine.states)[0];\n    if (typeof machine.states[state] === `undefined`) {\n        throw new TypeError(`Initial state ('${state}') not found`);\n    }\n    // Normalise states\n    const transitions = validateAndNormaliseTransitions(machine.states);\n    if (transitions === undefined) {\n        throw new Error(`Could not normalise transitions`);\n    }\n    return Object.freeze({\n        value: state,\n        visited: [],\n        machine: Object.freeze(Object.fromEntries(transitions)),\n    });\n};\nexport const reset = (sm) => {\n    return init(sm.machine);\n};\nexport const validateMachine = (smOrTransitions) => {\n    if (typeof smOrTransitions === `undefined`) {\n        return [undefined, `Parameter undefined`];\n    }\n    if (smOrTransitions === null) {\n        return [undefined, `Parameter null`];\n    }\n    if (`states` in smOrTransitions) {\n        // Assume Machine type\n        return [smOrTransitions, ``];\n    }\n    if (typeof smOrTransitions === `object`) {\n        return [\n            {\n                states: smOrTransitions,\n            },\n            ``,\n        ];\n    }\n    return [\n        undefined,\n        `Unexpected type: ${typeof smOrTransitions}. Expected object`,\n    ];\n};\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = (sm) => {\n    return possible(sm).length === 0;\n};\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = (sm) => {\n    // Validate current state\n    validateMachineState(sm);\n    // get list of possible targets\n    const fromS = sm.machine[sm.value];\n    if (fromS.length === 1 && fromS[0].state === null)\n        return [];\n    return fromS;\n};\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = (sm) => {\n    const targets = possibleTargets(sm);\n    return targets.map((v) => v.state);\n};\nexport const normaliseTargets = (targets) => {\n    const normaliseSingleTarget = (target) => {\n        // Terminal target\n        if (target === null)\n            return { state: null };\n        // String is the target state\n        if (typeof target === `string`) {\n            return {\n                state: target,\n            };\n        }\n        else if (typeof target === `object` && `state` in target) {\n            const targetState = target.state;\n            if (typeof targetState !== `string`) {\n                throw new TypeError(`Target 'state' field is not a string. Got: ${typeof targetState}`);\n            }\n            if (`preconditions` in target) {\n                return {\n                    state: targetState,\n                    preconditions: target.preconditions,\n                };\n            }\n            return { state: targetState };\n        }\n        else {\n            throw new Error(`Unexpected type: ${typeof target}. Expected string or object with 'state' field.`);\n        }\n    };\n    // Array of targets (either strings or objects)\n    if (Array.isArray(targets)) {\n        let containsNull = false;\n        const mapResults = targets.map((t) => {\n            const r = normaliseSingleTarget(t);\n            if (!r)\n                throw new Error(`Invalid target`);\n            containsNull = containsNull || r.state === null;\n            return r;\n        });\n        if (containsNull && mapResults.length > 1) {\n            throw new Error(`Cannot have null as an possible state`);\n        }\n        return mapResults;\n    }\n    else {\n        const target = normaliseSingleTarget(targets);\n        if (!target)\n            return;\n        return [target];\n    }\n};\nconst validateAndNormaliseTransitions = (d) => {\n    const returnMap = new Map();\n    // 1. Index top-level states\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        if (typeof topLevelState === `undefined`) {\n            throw new TypeError(`Top-level undefined state`);\n        }\n        if (typeof topLevelTargets === `undefined`) {\n            throw new TypeError(`Undefined target state for ${topLevelState}`);\n        }\n        if (returnMap.has(topLevelState)) {\n            throw new Error(`State defined twice: ${topLevelState}`);\n        }\n        if (topLevelState.includes(` `)) {\n            throw new Error(`State names cannot contain spaces`);\n        }\n        returnMap.set(topLevelState, []);\n    }\n    // 2. Normalise target\n    for (const [topLevelState, topLevelTargets] of Object.entries(d)) {\n        const targets = normaliseTargets(topLevelTargets);\n        if (targets === undefined)\n            throw new Error(`Could not normalise target`);\n        if (targets !== null) {\n            // Check that they all exist as top-level states\n            const seenStates = new Set();\n            for (const target of targets) {\n                if (seenStates.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' already exists for '${topLevelState}'`);\n                }\n                seenStates.add(target.state);\n                if (target.state === null)\n                    continue;\n                if (!returnMap.has(target.state)) {\n                    throw new Error(`Target state '${target.state}' is not defined as a top-level state. Defined under: '${topLevelState}'`);\n                }\n            }\n            returnMap.set(topLevelState, targets);\n        }\n    }\n    return returnMap;\n};\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = (state) => {\n    if (typeof state === `undefined`) {\n        throw new TypeError(`Param 'state' is undefined`);\n    }\n    if (typeof state.value !== `string`) {\n        throw new TypeError(`Existing state is not a string`);\n    }\n};\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n *\n * @example Attempts to transition to 'name-of-state'\n * ```js\n * const newState = StateMachine.to(currentState, `name-of-state`);\n * ```\n *\n * Note that 'currentState' is not changed.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = (sm, toState) => {\n    validateMachineState(sm); // throws if not OK\n    validateTransition(sm, toState); // throws if not OK\n    return Object.freeze({\n        value: toState,\n        machine: sm.machine,\n        visited: unique([sm.visited, [sm.value]]),\n    });\n};\nexport const next = (sm) => {\n    //validateMachineState(sm);\n    const first = possibleTargets(sm).at(0);\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (!first || first.state === null) {\n        throw new Error(`Not possible to move to a next state from '${sm.value}`);\n    }\n    return to(sm, first.state);\n};\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = (sm, toState) => {\n    try {\n        validateTransition(sm, toState);\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nexport const validateTransition = (sm, toState) => {\n    if (toState === null)\n        throw new Error(`Cannot transition to null state`);\n    if (typeof toState === `undefined`) {\n        throw new Error(`Cannot transition to undefined state`);\n    }\n    if (typeof toState !== `string`) {\n        throw new TypeError(`Parameter 'toState' should be a string. Got: ${typeof toState}`);\n    }\n    //const toS = sm.machine[toState];\n    //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n    const p = possible(sm);\n    if (p.length === 0)\n        throw new Error(`Machine is in terminal state`);\n    if (!p.includes(toState)) {\n        throw new Error(`Target state '${toState}' not available at current state '${sm.value}'. Possible states: ${p.join(`, `)}`);\n    }\n};\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n *\n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length <= 2)\n        throw new Error(`Expects at least two states`);\n    for (let index = 0; index < states.length; index++) {\n        const s = states[index];\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = (index === states.length - 1) ? null : states[index + 1];\n    }\n    return t;\n};\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n *\n * See also {@link fromList}.\n *\n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (...states) => {\n    const t = {};\n    if (!Array.isArray(states))\n        throw new Error(`Expected array of strings`);\n    if (states.length < 2)\n        throw new Error(`Expects at least two states`);\n    for (const [index, s] of states.entries()) {\n        if (typeof s !== `string`) {\n            throw new TypeError(`Expected array of strings. Got type '${typeof s}' at index ${index.toString()}`);\n        }\n        t[s] = [];\n    }\n    for (let index = 0; index < states.length; index++) {\n        const v = t[states[index]];\n        if (index === states.length - 1) {\n            if (states.length > 1) {\n                v.push(states[index - 1]);\n            }\n            else {\n                t[states[index]] = null;\n            }\n        }\n        else {\n            v.push(states[index + 1]);\n            if (index > 0)\n                v.push(states[index - 1]);\n        }\n    }\n    return t;\n};\n","import * as Execute from '../execute.js';\nimport {} from './types.js';\nimport { defaultComparer } from '@ixfx/core';\nimport { randomElement } from '@ixfx/arrays';\nimport * as Debug from '@ixfx/debug';\nimport { init as machineInit, reset as machineReset, next as machineNext, to as machineTo } from './state-machine.js';\n// export type Prerequisite<V extends StateMachine.Transitions> =\n//   | readonly StateMachine.StateNames<V>[]\n//   | ((\n//       potentialState: StateMachine.StateNames<V>,\n//       state: StateMachine.MachineState<V>\n//     ) => boolean);\n// export type StatePrerequisites<V extends StateMachine.Transitions> = {\n//   readonly states:\n//     | readonly StateMachine.StateNames<V>[]\n//     | StateMachine.StateNames<V>;\n//   readonly condition?: Prerequisite<V>;\n// };\n// async function run<V extends StateMachine.Transitions>(\n//   machine: StateMachine.Machine<V>,\n//   handlers: readonly StatesHandler<V>[]\n// );\n/**\n * Drives a state machine.\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/driver/)\n *\n * Uses a 'handlers' structure to determine when to change\n * state and actions to take.\n *\n * The structure is a set of logical conditions: if we're in\n * this state, then move to this other state etc.\n *\n * ```js\n * const handlers = [\n *  {\n *    // If we're in the 'sleeping' state, move to next state\n *    if: 'sleeping',\n *    then: { next: true }\n *  },\n *  {\n *    // If we're in the 'waking' state, randomly either go to 'resting' or 'sleeping' state\n *    if: 'waking',\n *    then: [\n *      () => {\n *        if (Math.random() > 0.5) {\n *          return { next: 'resting' }\n *        } else {\n *          return { next: 'sleeping' }\n *        }\n *      }\n *    ]\n *   }\n * ];\n * ```\n *\n * Set up the driver, and call `run()` when you want to get\n * the machine to change state or take action:\n *\n * ```js\n * const driver = await StateMachine.driver(states, handlers);\n * setInterval(async () => {\n *  await driver.run(); // Note use of 'await' again\n * }, 1000);\n * ```\n *\n * Essentially, the 'handlers' structure gets run through each time `run()`\n * is called.\n *\n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\nexport async function driver(machine, handlersOrOpts) {\n    const opts = Array.isArray(handlersOrOpts)\n        ? {\n            handlers: handlersOrOpts,\n        }\n        : handlersOrOpts;\n    const debug = Debug.resolveLogOption(opts.debug, {\n        category: `StateMachineDriver`,\n    });\n    // Index handlers by state, making sure there are not multiple\n    // handlers for a given state.\n    const byState = new Map();\n    for (const h of opts.handlers) {\n        const ifBlock = Array.isArray(h.if) ? h.if : [h.if];\n        for (const state of ifBlock) {\n            if (typeof state !== `string`) {\n                throw new TypeError(`Expected single or array of strings for the 'if' field. Got: '${typeof state}'.`);\n            }\n            if (byState.has(state)) {\n                throw new Error(`Multiple handlers defined for state '${state}'. There should be at most one.`);\n            }\n            byState.set(state, h);\n        }\n    }\n    const runOpts = {\n        // Rank results by score\n        rank: (a, b) => {\n            return defaultComparer(a.score ?? 0, b.score ?? 0);\n        },\n        shuffle: opts.shuffleHandlers ?? false,\n    };\n    let sm = machineInit(machine);\n    // Check that all 'if' states are actually defined on machine\n    for (const [ifState] of byState) {\n        // Check if state is defined\n        if (typeof sm.machine[ifState] === `undefined` &&\n            ifState !== `__fallback`) {\n            throw new Error(`StateMachineDriver handler references a state ('${ifState}') which is not defined on the machine. Therefore this handler will never run.'`);\n        }\n    }\n    const run = async () => {\n        debug(`Run. State: ${sm.value}`);\n        const state = sm.value;\n        let handler = byState.get(state);\n        if (handler === undefined) {\n            debug(`  No handler for state '${state}', trying __fallback`);\n            // Is there a fallback?\n            handler = byState.get(`__fallback`);\n        }\n        if (handler === undefined) {\n            debug(`  No __fallback handler`);\n            return;\n        }\n        // If the `first` option is given, stop executing fns as soon as we get\n        // a valid result.\n        const runOptionsForHandler = handler.resultChoice === `first`\n            ? {\n                ...runOpts,\n                stop: (latest) => {\n                    if (!latest)\n                        return false;\n                    if (`reset` in latest)\n                        return true;\n                    if (`next` in latest && latest.next !== undefined)\n                        return true;\n                    return false;\n                },\n            }\n            : runOpts;\n        const results = await Execute.run(handler.then, runOptionsForHandler, sm);\n        debug(`  In state '${sm.value}' results: ${results.length}. Choice: ${handler.resultChoice}`);\n        // Apply selection logic\n        //eslint-disable-next-line functional/no-let\n        let r;\n        switch (handler.resultChoice ?? `highest`) {\n            case `highest`: {\n                r = results.at(-1);\n                break;\n            }\n            case `first`: {\n                r = results[0]; // Since we break on the first result\n                break;\n            }\n            case `lowest`: {\n                r = results.at(0);\n                break;\n            }\n            case `random`: {\n                r = randomElement(results);\n                break;\n            }\n            default: {\n                throw new Error(`Unknown 'resultChoice' option: ${handler.resultChoice}. Expected highest, first, lowest or random`);\n            }\n        }\n        debug(`  Chosen result: ${JSON.stringify(r)}`);\n        // Apply result\n        if (r?.reset) {\n            sm = machineReset(sm);\n        }\n        else if (r && r.next) {\n            if (typeof r.next === `boolean`) {\n                sm = machineNext(sm);\n            }\n            else {\n                debug(JSON.stringify(results));\n                sm = machineTo(sm, r.next);\n            }\n        }\n        return sm;\n    };\n    return {\n        reset: () => {\n            sm = machineReset(sm);\n        },\n        getValue: () => sm.value,\n        run,\n        to: (state) => {\n            sm = machineTo(sm, state);\n            return sm;\n        },\n    };\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n/**\n * A state machine that fires events when state changes.\n *\n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents extends SimpleEventEmitter {\n    #sm;\n    #smInitial;\n    #debug;\n    #isDoneNeedsFiring = false;\n    #isDone = false;\n    #changedAt = elapsedInfinity();\n    /**\n     * Create a state machine with initial state, description and options\n     * @param m Machine description\n     * @param opts Options for machine (defaults to `{debug:false}`)\n     */\n    constructor(m, opts = {}) {\n        super();\n        this.#debug = opts.debug ?? false;\n        this.#sm = StateMachine.init(m, opts.initial);\n        this.#smInitial = StateMachine.cloneState(this.#sm);\n    }\n    #setIsDone(v) {\n        if (this.#isDone === v)\n            return;\n        this.#isDone = v;\n        if (v) {\n            this.#isDoneNeedsFiring = true;\n            setTimeout(() => {\n                if (!this.#isDoneNeedsFiring)\n                    return;\n                this.#isDoneNeedsFiring = false;\n                //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n                this.fireEvent(`stop`, { state: this.#sm.value });\n            }, 2);\n        }\n        else {\n            this.#isDoneNeedsFiring = false;\n        }\n    }\n    /**\n     * Return a list of possible states from current state.\n     *\n     * If list is empty, no states are possible. Otherwise lists\n     * possible states, including 'null' for terminal\n     */\n    get statesPossible() {\n        return StateMachine.possible(this.#sm);\n    }\n    /**\n     * Return a list of all defined states\n     */\n    get statesDefined() {\n        return Object.keys(this.#sm.machine);\n    }\n    /**\n     * Moves to the next state if possible. If multiple states are possible, it will use the first.\n     * If machine is finalised, no error is thrown and null is returned.\n     *\n     * @returns {(string|null)} Returns new state, or null if machine is finalised\n     */\n    next() {\n        const p = StateMachine.possible(this.#sm);\n        if (p.length === 0)\n            return null;\n        this.state = p[0];\n        return p[0];\n    }\n    /**\n     * Returns _true_ if state machine is in its final state\n     *\n     * @returns\n     */\n    get isDone() {\n        return StateMachine.isDone(this.#sm);\n    }\n    /**\n     * Resets machine to initial state\n     */\n    reset() {\n        this.#setIsDone(false);\n        this.#sm = StateMachine.cloneState(this.#smInitial);\n        this.#changedAt = elapsedSince();\n    }\n    /**\n     * Throws if it's not valid to transition to `newState`\n     * @param newState\n     * @returns\n     */\n    validateTransition(newState) {\n        StateMachine.validateTransition(this.#sm, newState);\n    }\n    /**\n     * Returns _true_ if `newState` is valid transition from current state.\n     * Use {@link validateTransition} if you want an explanation for the _false_ results.\n     * @param newState\n     * @returns\n     */\n    isValid(newState) {\n        return StateMachine.isValidTransition(this.#sm, newState);\n    }\n    /**\n     * Gets or sets state. Throws an error if an invalid transition is attempted.\n     * Use `isValid()` to check validity without changing.\n     *\n     * If `newState` is the same as current state, the request is ignored silently.\n     */\n    set state(newState) {\n        const priorState = this.#sm.value;\n        if (newState === this.#sm.value)\n            return;\n        // Try to change state\n        this.#sm = StateMachine.to(this.#sm, newState);\n        if (this.#debug) {\n            console.log(`StateMachine: ${priorState} -> ${newState}`);\n        }\n        this.#changedAt = elapsedSince();\n        setTimeout(() => {\n            this.fireEvent(`change`, { newState: newState, priorState: priorState });\n        }, 1);\n        if (StateMachine.isDone(this.#sm))\n            this.#setIsDone(true);\n    }\n    get state() {\n        return this.#sm.value;\n    }\n    /**\n     * Returns timestamp when state was last changed.\n     * See also `elapsed`\n     */\n    get changedAt() {\n        return this.#changedAt();\n    }\n    /**\n     * Returns milliseconds elapsed since last state change.\n     * See also `changedAt`\n     */\n    get elapsed() {\n        return this.#changedAt();\n    }\n}\n","export * from './driver.js';\nexport * from './state-machine.js';\nexport * from './with-events.js';\n","export * from '@ixfx/core/continuously';\nexport * from './behaviour-tree.js';\nexport * from './delay.js';\nexport * from './debounce.js';\nexport * from './dispatch-list.js';\nexport * from './every.js';\nexport * from './execute.js';\nexport * from './event-race.js';\nexport * from './moving-average.js';\nexport * from './pool.js';\nexport * from './promise-with-resolvers.js';\nexport * from './rate-minimum.js';\nexport * from './repeat.js';\nexport * from './req-resp-match.js';\nexport * from './retry.js';\nexport * from './run-once.js';\nexport * from './sync-wait.js';\nexport * from './task-queue-mutable.js';\nexport * from './throttle.js';\nexport * from './timeout.js';\nexport * from './timer.js';\nexport * from './types.js';\nexport * from './update-outdated.js';\nexport * from './wait-for-value.js';\nexport * from './wait-for.js';\nexport { sleep } from '@ixfx/core';\n/**\n * Functions for creating and driving a state machine\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n */\nexport * as StateMachine from './state-machine/index.js';\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,IAAa,gBAAb,MAAa,sBAAsB,MAAM;CACrC;CACA;CACA,YAAY,WAAW,GAAG;EACtB,OAAO;EAEP,YAAY,YAAY,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;EAE1D,KAAKA,YAAY;EACjB,KAAKC,WAAW;CACnB;;;;;;CAMD,IAAIC,SAAO;EACP,MAAM,KAAK,cAAc,KAAK,KAAK;EACnC,GAAG,KAAKD,YAAYC;EACpB,GAAGF,YAAY,KAAKA;AACpB,MAAI,KAAKA,YAAY,GACjB,GAAGC,WACC,KAAKA,WAAW,MAAM,KAAKD,YAAY,IAAI,KAAKC,WAAW;OAG/D,GAAGA,WAAW,KAAKA,WAAW;AAElC,SAAO;CACV;CACD,IAAI,UAAU;AACV,SAAO,KAAKA;CACf;CACD,IAAI,SAAS;AACT,MAAI,KAAKD,cAAc,EACnB,QAAO;AACX,SAAO,KAAK,WAAW,KAAKA;CAC/B;AACJ;;;;AC9DD,MAAa,QAAQ,CAAC,MAAM,YAAY;CACpC,KAAK,SAAQ,QAAQ,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC;AAC/C;AACD,MAAa,YAAY,CAAC,MAAM,OAAO,UAAU;CAC7C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,WAAW,KAAK,YAAY;CAClC,MAAM,WAAW,kBAAkB;CACnC,MAAM,SAAS,KAAK,iBAAiB,CAAC,SAAS,CAAC;AAMhD,SAAQ,QAAR;EAEI,KAAK,CAAC,SAAS,CAAC,EAAE;AAOd,OAAI,MAAM,WAAW,EACjB,QAAO,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS;AAElD,OAAI,MAAM,WAAW,KAAK,SACtB,QAAO;OAIP,QAAO,CAAC,GAAG,OAAO,GAAG,MAAM,MAAM,GAAG,WAAW,EAAE,AAAC;EAEzD;EAED,KAAK,CAAC,KAAK,CAAC,CACR,KAAI,YAAY,MAAM,QAAQ;AAG1B,OAAI,MAAM,WAAW,EAGjB,QAAO,CAAC,GAAG,MAAM,MAAM,GAAG,WAAW,EAAE,EAAE,MAAM,GAAG,GAAG,AAAC;AAE1D,UAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAS,SAAS,EAAE,KAAK,IAAI,MAAM,QAAQ,SAAS,GAAG,EAAE;EAGjG,OACI;GAOD,MAAM,aAAa,KAAK,IAAI,GAAG,MAAM,SAAS,MAAM,OAAO;GAC3D,MAAM,aAAa,MAAM,MAAM,MAAM,SAAS,YAAY,MAAM,OAAO;GACvE,MAAM,SAAS,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAW,EAAE,CAAC;GAWnE,MAAM,IAAI,CAAC,GAAG,QAAQ,GAAG,UAAW;AAEpC,UAAO;EACV;EAGL,KAAK,CAAC,KAAK,CAAC,CAER,QAAO,CAAC,GAAG,OAAO,GAAG,KAAM,EAAC,MAAM,SAAS;EAE/C,QAEI,OAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,QAAQ;CAE1D;AACJ;;;;;;;;;;AAUD,MAAa,UAAU,CAAC,MAAM,OAAO,GAAG,UAAU;AAC9C,KAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;CAC9C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,WAAW,KAAK,YAAY,kBAAkB,KAAK;CACzD,MAAM,WAAW,WACX,UAAU,MAAM,OAAO,MAAM,GAC7B,CAAC,GAAG,OAAO,GAAG,KAAM;AAC1B,KAAI,KAAK,YAAY,SAAS,WAAW,KAAK,YAAY,SACtD,OAAM,IAAI,MAAM,CAAC,oDAAoD,EAAE,SAAS,OAAO,WAAW,EAAE,KAAK,SAAS,OAAO,EAAE,KAAK,UAAU,KAAK,EAAE;AAErJ,KAAI,CAAC,KAAK,YAAY,SAAS,WAAW,gBACtC,OAAM,IAAI,MAAM,CAAC,6CAA6C,EAAE,SAAS,OAAO,WAAW,EAAE,gBAAgB,OAAO,EAAE,KAAK,UAAU,KAAK,EAAE;AAEhJ,QAAO;AACV;AAED,MAAa,UAAU,CAAC,MAAM,UAAU;AACpC,KAAI,MAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,cAAc,CAAC;AACpC,QAAO,MAAM,MAAM,EAAE;AACxB;;;;;;;;;AASD,MAAa,OAAO,CAAC,MAAM,UAAU,MAAM;AAC3C,MAAa,UAAU,CAAC,MAAM,UAAU,MAAM,WAAW;AACzD,MAAa,SAAS,CAAC,MAAM,UAAU;AACnC,KAAI,KAAK,SACL,QAAO,MAAM,UAAU,KAAK;AAEhC,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrFD,IAAa,eAAb,cAAkC,mBAAmB;CACjD;CACA;CACA;CACA,YAAY,OAAO,CAAE,GAAE,OAAO,CAAE,GAAE;EAC9B,OAAO;AACP,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;EAC9C,KAAK,UAAU;EACf,KAAK,OAAO;EACZ,KAAK,KAAK,KAAK,MAAM;CACxB;CACD,QAAQ;EACJ,MAAM,OAAO,CAAC,GAAG,KAAK,IAAK;EAC3B,KAAK,OAAO,CAAE;EACd,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE;GAAE,WAAW,KAAK;GAAM,SAAS;EAAM,EAAC;EAClE,KAAK,SAAS;CACjB;;;;CAID,UAAU,CACT;CACD,GAAG,OAAO;AACN,MAAI,SAAS,KAAK,KAAK,OACnB,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;EACnD,MAAM,IAAI,KAAK,KAAK,GAAG,MAAM;AAC7B,MAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;AAChE,SAAO;CACV;CACD,QAAQ,GAAG,OAAO;EACd,KAAK,OAAO,QAAQ,KAAK,SAAS,KAAK,MAAM,GAAG,MAAM;EACtD,MAAM,SAAS,KAAK,KAAK;EACzB,KAAK,UAAU,KAAK,MAAM,MAAM;AAChC,SAAO;CACV;CACD,UAAU,QAAQ,gBAAgB;EAC9B,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE;GAAE,OAAO;GAAgB,WAAW;EAAQ,EAAC;CAC1E;CACD,UAAU;EACN,MAAM,IAAI,KAAK,KAAK,SAAS,KAAK,KAAK;AACvC,MAAI,MAAM,OACN;EAEJ,KAAK,OAAO,QAAQ,KAAK,SAAS,KAAK,KAAK;EAC5C,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE;GAAE,SAAS;GAAG,WAAW,KAAK;EAAM,EAAC;EAC/D,KAAK,UAAU,CAAC,CAAE,GAAE,KAAK,KAAK;AAC9B,SAAO;CACV;CACD,UAAU,SAAS,WAAW;EAC1B,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE;GAAE;GAAS;EAAW,EAAC;CACpD;;;;;;CAMD,YAAY,WAAW;EACnB,MAAM,WAAW,KAAK,KAAK;EAC3B,MAAM,WAAW,KAAK,KAAK,OAAO,OAAK,UAAU,EAAE,CAAC;AACpD,MAAI,SAAS,WAAW,EACpB,QAAO;EACX,KAAK,OAAO,KAAK,KAAK,OAAO,CAAC,YAAY,CAAC,UAAU,QAAQ,CAAC;EAC9D,KAAK,UAAU,UAAU,KAAK,KAAK;AACnC,SAAO,WAAW,KAAK,KAAK;CAC/B;;;;;CAKD,UAAU;AACN,SAAO,CAAC,GAAG,KAAK,IAAK;CACxB;CACD,IAAI,UAAU;AACV,SAAO,QAAQ,KAAK,SAAS,KAAK,KAAK;CAC1C;CACD,IAAI,SAAS;AACT,SAAO,OAAO,KAAK,SAAS,KAAK,KAAK;CACzC;CACD,IAAI,SAAS;AACT,SAAO,KAAK,KAAK;CACpB;CACD,IAAI,OAAO;AACP,SAAO,KAAK,KAAK,SAAS,KAAK,KAAK;CACvC;AACJ;;;;;;;AAOD,SAAgBG,UAAQ,UAAU,CAAE,GAAE,GAAG,eAAe;AACpD,QAAO,IAAI,aAAa,EAAE,GAAG,QAAS,GAAE,CAAC,GAAG,aAAc;AAC7D;;;;AC3ID,MAAa,YAAY,CAAC,MAAM,OAAO,UAAU;CAC7C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,SAAS,KAAK,iBAAiB,CAAC,SAAS,CAAC;CAChD,MAAM,WAAW,KAAK,YAAY;CAClC,MAAM,WAAW,kBAAkB;AACnC,KAAI,KAAK,OACL,QAAQ,IAAI,CAAC,sBAAsB,EAAE,MAAM,OAAO,eAAe,EAAE,gBAAgB,WAAW,EAAE,SAAS,SAAS,EAAE,QAAQ,CAAC;AAEjI,SAAQ,QAAR;EACI,KAAK,CAAC,SAAS,CAAC,EAAE;AACd,OAAI,KAAK,OACL,QAAQ,IAAI,CAAC,uCAAuC,EAAE,MAAM,OAAO,QAAQ,EAAE,kBAAkB,SAAS,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGxI,OAAI,MAAM,WAAW,KAAK,SACtB,QAAO;OAIP,QAAO,CAAC,GAAG,OAAO,GAAG,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS,AAAC;EAEpE;EACD,KAAK,CAAC,KAAK,CAAC,CACR,KAAI,YAAY,MAAM,OAElB,QAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAS,SAAS,EAAE,KAAK,IAAI,MAAM,QAAQ,SAAS,GAAG,EAAE;OAE7F;AAGD,OAAI,KAAK,OACL,QAAQ,IAAI,CAAC,YAAY,EAAE,KAAK,UAAU,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS,CAAC,EAAE,CAAC;AAEzF,UAAO,CACH,GAAG,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS,EAC1C,GAAG,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAW,WAAW,EAAE,CAAC,AACrE;EACJ;EAEL,KAAK,CAAC,KAAK,CAAC,CAER,QAAO,CAAC,GAAG,OAAO,GAAG,KAAM,EAAC,MAAM,SAAS;EAE/C,QAEI,OAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,QAAQ;CAEzD;AACJ;AAED,MAAa,OAAO,CAAC,MAAM,OAAO,GAAG,UAAU;CAG3C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,WAAW,KAAK,YAAY,kBAAkB,KAAK;CACzD,MAAM,WAAW,WACX,UAAU,MAAM,OAAO,MAAM,GAC7B,CAAC,GAAG,OAAO,GAAG,KAAM;AAC1B,QAAO;AACV;AAED,MAAa,MAAM,CAAC,MAAM,UAAU;AAChC,KAAI,MAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,cAAc,CAAC;AACpC,QAAO,MAAM,MAAM,GAAG,GAAG;AAC5B;;;;;;;;;AASD,MAAaC,SAAO,CAAC,MAAM,UAAU,MAAM,GAAG,GAAG;AACjD,MAAaC,YAAU,CAAC,MAAM,UAAU,MAAM,WAAW;AACzD,MAAaC,WAAS,CAAC,MAAM,UAAU;AACnC,KAAI,KAAK,SACL,QAAO,MAAM,UAAU,KAAK;AAEhC,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;ACzDD,IAAa,eAAb,MAA0B;CACtB;CACA;CACA,YAAY,OAAO,CAAE,GAAE,OAAO,CAAE,GAAE;EAC9B,KAAK,OAAO;EACZ,KAAK,OAAO;CACf;;;;;;;CAOD,KAAK,GAAG,OAAO;AACX,MAAI,MAAM,WAAW,EACjB,QAAO,KAAK,KAAK;EACrB,KAAK,OAAO,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG,MAAM;AAChD,SAAO,KAAK,KAAK;CACpB;CACD,QAAQ,IAAI;EACR,KAAK,KAAK,QAAQ,GAAG;CACxB;CACD,eAAe,IAAI;EACf,CAAC,GAAG,KAAK,IAAK,EAAC,SAAS,CAAC,QAAQ,GAAG;CACvC;CACD,MAAM;EACF,MAAM,IAAIC,OAAK,KAAK,MAAM,KAAK,KAAK;EACpC,KAAK,OAAO,IAAI,KAAK,MAAM,KAAK,KAAK;AACrC,SAAO;CACV;CACD,IAAI,UAAU;AACV,SAAOC,UAAQ,KAAK,MAAM,KAAK,KAAK;CACvC;CACD,IAAI,SAAS;AACT,SAAOC,SAAO,KAAK,MAAM,KAAK,KAAK;CACtC;CACD,IAAI,OAAO;AACP,SAAOF,OAAK,KAAK,MAAM,KAAK,KAAK;CACpC;CACD,IAAI,SAAS;AACT,SAAO,KAAK,KAAK;CACpB;AACJ;;;;;;;;;;;;;;;;;;;;;AAqBD,MAAaG,YAAU,CAAC,OAAO,CAAE,GAAE,GAAG,kBAAkB,IAAI,aAAa,EAAE,GAAG,KAAM,GAAE,CAAC,GAAG,aAAc;;;;ACrFxG,MAAa,UAAU,CAAC,GAAG,GAAG,KAAK,yBAAyB,WAAW;CACnE,MAAM,aAAa,qBAAqB,GAAG,GAAG,GAAG;CAIjD,MAAM,kBAAkB,gBAAgB,GAAG,GAAG,GAAG;CACjD,MAAM,OAAO;EACT,cAAc,CAAC;EAAY;EAAG;EAC9B,OAAO,gBAAgB;EACvB,SAAS,gBAAgB;EACzB,cAAc;CACjB;CACD,MAAM,WAAW;EACb,OAAO;EACP,eAAe,CAAE;EACjB;CACH;CACD,MAAM,eAAe,gBAAgB,UAAU,IAAI,OAAK,QAAQ,EAAE,IAAI,EAAE,IAAI,IAAI,SAAS,CAAC;CAE1F,MAAM,kBAAkB,UAAU,KAAK,IAAI,aAAa,KAAK,OAAK,UAAU,EAAE,MAAM,CAAC;aAC7D,UAAU,aAAa;CAE/C,SAAS,WAAW,MAAMC,WAAS,UAAU,EAAE;CAE/C,SAAS,MAAM,eAAe;eACJ,SAAS;AACnC,QAAO;AACV;AACD,MAAM,YAAY,CAAC,OAAO;AACtB,KAAI,OAAO,OACP,QAAO;AACX,KAAI,GAAG,aACH,QAAO;AACX,KAAI,GAAG,aACH,QAAO;AACX,KAAI,GAAG,MAAM,SAAS,EAClB,QAAO;AACX,KAAI,GAAG,QAAQ,SAAS,EACpB,QAAO;AACX,QAAO;AACV;AACD,MAAM,kBAAkB,CAAC,GAAG,GAAG,KAAK,4BAA4B;CAC5D,MAAM,cAAc,CAAC,GAAG,EAAE,UAAU,AAAC;CACrC,MAAM,cAAc,CAAC,GAAG,EAAE,UAAU,AAAC;CACrC,MAAM,YAAY,CAAE;CACpB,MAAM,UAAU,CAAE;AAClB,MAAK,MAAM,UAAU,aAAa;EAC9B,IAAI,aAAa;AACjB,OAAK,MAAM,CAAC,OAAO,SAAS,IAAI,YAAY,SAAS,EAAE;GACnD,MAAM,IAAI,qBAAqB,QAAQ,UAAU,GAAG;AACpD,OAAI,GAAG;IACH,UAAU,KAAK,CAAC,QAAQ,QAAS,EAAC;IAClC,aAAa;AACb;GACH;EACJ;AACD,MAAI,eAAe,IAEf,QAAQ,KAAK,OAAO;OAIpB,YAAY,OAAO,YAAY,EAAE;CAExC;CACD,MAAM,QAAQ,CAAC,GAAG,WAAY;AAC9B,QAAO;EAAE;EAAO;EAAW;CAAS;AACvC;AACD,MAAM,uBAAuB,CAAC,GAAG,GAAG,OAAO;AACvC,KAAI,EAAE,aAAa,KAAK,EAAE,aAAa,CACnC,QAAO;AACX,KAAI,GAAG,EAAE,UAAU,EAAE,EAAE,UAAU,CAAC,CAC9B,QAAO;AACX,QAAO;AACV;AACD,MAAM,iBAAiB,CAAC,MAAM;AAC1B,QAAO,KAAK,UAAU,EAAE,UAAU,CAAC;AACtC;AACD,MAAMA,aAAW,CAAC,GAAG,SAAS,MAAM;AAChC,KAAI,MAAM,OACN,QAAO,CAAC,WAAW,CAAC;CACxB,IAAI,IAAI,aAAa,EAAE,OAAO,OAAO;AACrC,MAAK,MAAM,KAAK,EAAE,eACd,KAAKA,WAAS,GAAG,SAAS,EAAE;AAEhC,QAAO;AACV;AACD,MAAM,eAAe,CAAC,GAAG,WAAW;CAChC,MAAM,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,OAAO;AACjC,KAAI,MAAM,OACN,QAAO,GAAG,OAAO,WAAW,CAAC;CACjC,MAAM,IAAI,CAAE;CACZ,EAAE,KAAK,CAAC,GAAG,EAAE,eAAe,EAAE,EAAE,CAAC,IAAI,EAAE,eAAe,EAAE,EAAE,EAAE,CAAC;AAC7D,KAAI,EAAE,cACF,EAAE,KAAK,CAAC,8BAA8B,EAAE,EAAE,cAAc,CAAC;MAEzD,EAAE,KAAK,CAAC,gCAAgC,EAAE,EAAE,cAAc,CAAC;AAC/D,KAAI,EAAE,MAAM,SAAS,GAAG;EACpB,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;AAChB,OAAK,MAAM,KAAK,EAAE,OACd,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,eAAe,EAAE,CAAC;CAExC;AACD,KAAI,EAAE,QAAQ,SAAS,GAAG;EACtB,EAAE,KAAK,CAAC,SAAS,EAAE,EAAE,QAAQ,QAAQ,CAAC;AACtC,OAAK,MAAM,KAAK,EAAE,SACd,EAAE,KAAK,CAAC,GAAG,CAAC,GAAG,eAAe,EAAE,CAAC;CAExC;CACD,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;AAChB,QAAO,EAAE,IAAI,UAAQ,SAAS,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;AACjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChGD,MAAaC,YAAU,CAAC,GAAG,GAAG,OAAO;AACjC,QAAOC,QAAYC,uBAAqB,EAAE,EAAEA,uBAAqB,EAAE,EAAE,GAAG;AAC3E;;;;;;;;;;AAUD,MAAa,iBAAiB,CAAC,SAAS;CACpC,MAAM,IAAI;EACN,OAAO,KAAK;EACZ,eAAe,KAAK,cAAc,IAAI,OAAK,eAAe,EAAE,CAAC;CAChE;AACD,QAAO;AACV;AACD,MAAM,YAAY,CAAC,SAAU,CAAC,KAAK,CAAC,IAAI,OAAQ,KAAK,QAAQ;AAC7D,MAAM,UAAU,CAAC,SAAU,CAAC,KAAK,CAAC,IAAI,OAAQ,OAAO,KAAK,KAAK;;;;;;;;AAQ/D,MAAa,OAAO,CAAC,MAAM;AACvB,QAAO;EACH,CAAC,WAAW;AACR,QAAK,MAAM,KAAK,EAAE,eACd,MAAM,KAAK,EAAE;EAEpB;EACD,UAAU,MAAM,EAAE;EAClB,aAAa,MAAM;EACnB,CAAC,WAAWC,SAAO;AACf,QAAK,MAAM,KAAK,aAAaA,SAAO,UAAU,EAAE,CAAC,EAC7C,MAAM,KAAK,EAAE;EAEpB;EACD,CAAC,kBAAkB,OAAOA,SAAO,IAAI;AACjC,QAAK,MAAM,KAAK,kBAAkB,UAAU,MAAM,EAAEA,SAAO,GAAG,EAC1D,MAAM,KAAK,EAAE;EAEpB;EACD,CAAC,cAAc,OAAO;GAClB,OAAO,cAAc,UAAU,MAAM,CAAC;EACzC;EACD,iBAAiB,OAAOA,SAAO,IAAI;GAC/B,MAAMC,MAAI,iBAAiB,OAAOD,SAAO,GAAG;AAC5C,OAAIC,QAAM,OACN,QAAO,KAAKA,IAAE;EACrB;EACD,WAAW,MAAM,EAAE,WAAW,SAAY,SAAY,KAAK,EAAE,OAAO;EACpE,WAAW,CAAC,WAAW;AACnB,UAAOC,YAAU,GAAG,UAAU,OAAO,CAAC;EACzC;EACD,cAAc,CAAC,WAAW;AACtB,UAAOC,eAAa,GAAG,UAAU,OAAO,CAAC;EAC5C;EACD,UAAU,CAAC,UAAU;AACjB,UAAOC,WAAS,UAAU,MAAM,EAAE,EAAE;EACvC;EACD,aAAa,CAAC,UAAU;AACpB,UAAOC,cAAY,UAAU,MAAM,EAAE,EAAE;EAC1C;EACD,QAAQ,MAAM;GACV,OAAO,EAAE;EACZ;EACD,UAAU,CAACL,YAAU;GACjB,MAAM,YAAYM,WAASN,SAAO,EAAE;AACpC,UAAO,KAAK,UAAU;EACzB;EACD,KAAK,CAAC,UAAU;GACZO,MAAI,UAAU,MAAM,EAAE,EAAE;AACxB,UAAO,QAAQ,MAAM;EACxB;EACD,OAAO;CACV;AACJ;;;;;;;AAOD,MAAa,SAAS,CAAC,UAAU;CAC7B,MAAM,IAAI,MAAM;AAChB,KAAI,MAAM,OACN;CACJ,MAAM,SAAS;CACf,EAAE,gBAAgB,QAAQ,EAAE,eAAe,MAAM;AACpD;;;;;;AAMD,UAAiBC,aAAW,MAAM;AAC9B,KAAI,CAAC,KACD;CACJ,MAAM,QAAQ,IAAI;CAClB,MAAM,KAAK,GAAG,KAAK,cAAc;CACjC,IAAI,QAAQ,MAAM,KAAK;AACvB,QAAO,OAAO;EACV,MAAM;AACN,MAAI,OACA,MAAM,KAAK,GAAG,MAAM,cAAc;AAEtC,MAAI,MAAM,QACN;EACJ,QAAQ,MAAM,KAAK;CACtB;AACJ;;;;;;AAMD,UAAiBC,eAAa,MAAM;AAChC,KAAI,CAAC,KACD;CACJ,MAAM,QAAQ,IAAI;CAClB,MAAM,QAAQ,GAAG,KAAK,cAAc;CACpC,IAAI,QAAQ,MAAM,SAAS;AAC3B,QAAO,OAAO;EACV,MAAM;AACN,MAAI,OACA,MAAM,QAAQ,GAAG,MAAM,cAAc;AAEzC,MAAI,MAAM,QACN;EACJ,QAAQ,MAAM,SAAS;CAC1B;AACJ;;;;;;;AAOD,SAAgB,SAASC,QAAM,OAAO,CAAE,GAAE;AACtC,KAAIA,OAAK,WAAWA,OAChB,QAAO;EAAC;EAAO,CAAC,yBAAyB,CAAC;EAAEA;CAAK;AACrD,KAAI,KAAK,SAASA,OAAK,CACnB,QAAO;EAAC;EAAO,CAAC,+CAA+C,CAAC;EAAEA;CAAK;CAC3E,KAAK,KAAKA,OAAK;AACf,KAAI,2BAA2BA,OAAK,cAAc,CAC9C,QAAO;EAAC;EAAO,CAAC,iCAAiC,CAAC;EAAEA;CAAK;AAC7D,MAAK,MAAM,KAAKA,OAAK,eAAe;AAChC,MAAI,EAAE,WAAWA,OACb,QAAO;GAAC;GAAO,CAAC,iDAAiD,CAAC;GAAE;EAAE;AAC1E,MAAIL,cAAYK,QAAM,EAAE,CACpB,QAAO;GAAC;GAAO,CAAC,iCAAiC,CAAC;GAAE;EAAE;EAC1D,MAAM,IAAI,SAAS,GAAG,KAAK;AAC3B,MAAI,CAAC,EAAE,GACH,QAAO;CACd;AACD,QAAO;EAAC;EAAM,EAAE;EAAEA;CAAK;AAC1B;;;;;;AAMD,SAAgB,cAAcA,QAAM;CAChC,MAAM,IAAI,SAASA,OAAK;AACxB,KAAI,EAAE,GACF;AACJ,OAAM,IAAI,MAAM,GAAG,EAAE,GAAG,OAAO,EAAE,mBAAmB,EAAE,GAAG,OAAO,GAAG,EAAE,EAAE,EAAE,OAAO,EAAE,GAAI;AACzF;;;;;;AAMD,UAAiBC,WAASD,QAAM;AAC5B,MAAK,MAAM,KAAKA,OAAK,eACjB,MAAM;AAEb;;;;;;AAMD,UAAiB,eAAeA,QAAM;AAClC,MAAK,MAAM,KAAKA,OAAK,cACjB,KAAI,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC,EAC9B,MAAM,EAAE;AAEnB;;;;;AAKD,UAAiBE,UAAQF,QAAM;CAC3B,IAAI,IAAIA,OAAK;AACb,QAAO,GAAG;EACN,MAAM;EACN,IAAI,EAAE;CACT;AACJ;;;;;;AAMD,SAAgB,UAAU,MAAM;CAC5B,MAAM,IAAI,CAAC,GAAGE,UAAQ,KAAK,AAAC;AAC5B,QAAO,EAAE;AACZ;AACD,MAAaR,aAAW,CAAC,OAAO,WAAW;AACvC,MAAK,MAAM,KAAK,OAAO,cACnB,KAAI,MAAM,MACN,QAAO;AAEf,QAAO;AACV;;;;;;;;;;AAUD,MAAaS,qBAAmB,CAACb,SAAO,QAAQ,KAAK,mBAAmB;AACpE,MAAK,MAAM,KAAK,OAAO,cACnB,KAAI,GAAGA,SAAO,EAAE,MAAM,CAClB,QAAO;AAElB;;;;;;;;;AASD,UAAiB,aAAaA,SAAO,QAAQ,KAAK,gBAAgB;AAC9D,MAAK,MAAM,KAAK,OAAO,cACnB,KAAI,GAAGA,SAAO,EAAE,MAAM,EAClB,MAAM;AAEjB;;;;;;;;;;AAUD,MAAaK,gBAAc,CAAC,kBAAkB,WAAW;AACrD,MAAK,MAAM,KAAKI,eAAa,OAAO,CAChC,KAAI,MAAM,iBACN,QAAO;AAEf,QAAO;AACV;AACD,MAAaK,wBAAsB,CAACd,SAAO,QAAQ,KAAK,mBAAmB;AACvE,MAAK,MAAM,KAAKS,eAAa,OAAO,CAChC,KAAI,GAAG,EAAE,OAAOT,QAAM,CAClB,QAAO;AAElB;AACD,MAAa,UAAU,CAAC,SAAS;AAC7B,KAAI,KAAK,OACL,QAAO,QAAQ,KAAK,OAAO;AAC/B,QAAO;AACV;;;;;;;;;;AAUD,MAAaG,iBAAe,CAAC,OAAO,sBAAsB;AACtD,MAAK,MAAM,KAAKS,UAAQ,MAAM,CAC1B,KAAI,MAAM,kBACN,QAAO;AAEf,QAAO;AACV;;;;;;;;;AASD,UAAiB,cAAc,OAAO;AAClC,MAAK,MAAM,KAAKA,UAAQ,MAAM,CAC1B,KAAI,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC,EAC9B,MAAM,EAAE;AAGhB,QAAO;AACV;;;;;;;;;AASD,UAAiB,kBAAkB,OAAOZ,SAAO,KAAK,gBAAgB;AAClE,MAAK,MAAM,KAAKY,UAAQ,MAAM,CAC1B,KAAI,OAAO,EAAE,UAAU,CAAC,SAAS,CAAC,EAC9B;MAAI,GAAG,EAAE,OAAOZ,QAAM,EAClB,MAAM;CAAE;AAGpB,QAAO;AACV;;;;;;;;AAQD,SAAgB,iBAAiB,OAAOA,SAAO,KAAK,gBAAgB;AAChE,MAAK,MAAM,KAAK,kBAAkB,OAAOA,SAAO,GAAG,CAC/C,QAAO;AAEd;;;;;;;;;;AAUD,MAAaE,cAAY,CAAC,OAAO,sBAAsB;AACnD,QAAO,MAAM,WAAW;AAC3B;;;;;;;;;;;;AAYD,MAAa,kBAAkB,CAAC,SAAS;AACrC,QAAO,oBAAoB,MAAM,EAAE;AACtC;AACD,MAAM,sBAAsB,CAAC,MAAM,gBAAgB,MAAM;CACrD,IAAI,QAAQ;AACZ,MAAK,MAAM,KAAK,KAAK,eACjB,QAAQ,KAAK,IAAI,OAAO,oBAAoB,GAAG,gBAAgB,EAAE,CAAC;AAEtE,QAAO;AACV;AACD,MAAaK,QAAM,CAAC,OAAO,WAAW;CAClC,oBAAoB,OAAO,OAAO;CAGlC,MAAM,IAAI,MAAM;CAChB,OAAO,gBAAgB,CAAC,GAAG,OAAO,eAAe,KAAM;CACvD,MAAM,SAAS;AACf,KAAI,GACA,EAAE,gBAAgB,QAAQ,EAAE,eAAe,MAAM;AAExD;AACD,MAAaD,aAAW,CAACN,SAAO,WAAW;AACvC,QAAO,WAAWA,SAAO,OAAO;AACnC;;;;;;;AAOD,MAAa,OAAO,CAACA,YAAU;AAC3B,QAAO,WAAWA,QAAM;AAC3B;AACD,MAAa,kBAAkB,CAACA,SAAO,QAAQ,EAAE,EAAE,QAAQ,OAAO,CAAE,MAAK;CACrE,MAAMe,YAAU,OAAO,QAAQf,QAAM;CACrC,SAAS,WAAW,SAAY,MAAM,GAAGM,WAAS;EAAE;EAAO;CAAO,GAAE,OAAO;AAC3E,MAAK,MAAM,SAASS,WAAS;EACzB,MAAMf,UAAQ,MAAM;AAEpB,MAAI,KAAK,SAASA,QAAM,CACpB;EACJ,KAAK,KAAKA,QAAM;AAChB,MAAI,OAAO,MAAM,OAAO,CAAC,MAAM,CAAC,EAC5B,gBAAgBA,SAAO,MAAM,IAAI,QAAQ,KAAK;OAG9CM,WAAS;GAAE,OAAO,MAAM;GAAI,OAAON;EAAO,GAAE,OAAO;CAE1D;AACD,QAAO;AACV;;;;;;;AAOD,MAAa,cAAc,CAACA,YAAU;AAClC,QAAO,KAAK,WAAWA,QAAM,CAAC;AACjC;;;;;;;;AAQD,MAAa,aAAa,CAACA,SAAO,WAAW;CACzC,MAAM,IAAI;EACN,eAAe,CAAE;EACT;EACR,OAAOA;CACV;AACD,KAAI,WAAW,QACX,OAAO,gBAAgB,CAAC,GAAG,OAAO,eAAe,CAAE;AAEvD,QAAO;AACV;AACD,MAAagB,mBAAiB,CAAC,SAAS;AACpC,QAAO,KAAK,cAAc;AAC7B;AACD,MAAa,QAAQ,CAAC,SAAS;AAC3B,QAAO,KAAK;AACf;;;;;;;;AAQD,MAAajB,yBAAuB,CAAC,SAAS;CAC1C,MAAM,IAAI;EACN,CAAC,WAAW;AACR,QAAK,MAAM,KAAK,KAAK,eACjB,MAAMA,uBAAqB,EAAE;EAEpC;EACD,YAAY;AACR,OAAI,KAAK,WAAW,OAChB;AACJ,UAAOA,uBAAqB,KAAK,OAAO;EAC3C;EACD,WAAW;AACP,UAAO,KAAK;EACf;EACD,cAAc;AACV,UAAO;EACV;CACJ;AACD,QAAO;AACV;AACD,MAAM,sBAAsB,CAAC,GAAG,WAAW;AACvC,KAAI,WAAW,EACX,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;AAC9C,KAAI,EAAE,WAAW,OACb;AACJ,KAAII,eAAa,QAAQ,EAAE,CACvB,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC,EAAE,EAAE,OAAO,EAAG;AAC7D,KAAIA,eAAa,GAAG,OAAO,CACvB,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC,EAAE,EAAE,OAAO,EAAG;AACjE,KAAIE,cAAY,QAAQ,EAAE,CACtB,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC,EAAE,EAAE,OAAO,EAAG;AAChE;AACD,MAAa,cAAc,CAAC,QAAQM,eAAa;AAE7C,MAAK,MAAM,KAAKA,YACZ,oBAAoB,GAAG,OAAO;CAElC,OAAO,gBAAgB,CAAC,GAAGA,UAAS;AACpC,MAAK,MAAM,KAAKA,YACZ,EAAE,SAAS;AAElB;AACD,MAAaM,iBAAe,CAAC,MAAM,SAAS,MAAM;CAC9C,MAAM,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,OAAO,OAAO,CAAC,GAAG,EAAE,KAAK,QAAQ,KAAK,UAAU,KAAK,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;AACrF,QAAO,KAAK,cAAc,SAAS,IAAK,IACpC,CAAC,EAAE,CAAC,GACJ,KAAK,cAAc,IAAI,CAAC,MAAMA,eAAa,GAAG,SAAS,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAI;AAChF;AACD,UAAiBC,cAAYR,QAAM,mBAAmB,QAAQ,GAAG;AAC7D,MAAK,MAAM,KAAKA,OAAK,eAAe;EAChC,MAAMV,UAAQ,EAAE;AAChB,MAAIA,YAAU,OACV;AACJ,MAAI,kBAAkBA,SAAO,MAAM,EAAE;GACjC,MAAM,EAAE;GACR,OAAOkB,cAAY,GAAG,mBAAmB,QAAQ,EAAE;EACtD;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;ACtgBD,SAAgB,mBAAmBC,WAAS;AACxC,KAAIA,UAAQ,WAAW,EACnB,QAAO,CAAC,OAAO,CAAC;CACpB,IAAI,IAAI,EAAE;AACV,MAAK,MAAM,CAAC,OAAO,MAAM,IAAIA,UAAQ,SAAS,EAAE;EAC5C,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,MAAM;EACvB,KAAK,MAAM,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,UAAU,MAAM,UAAU,GAAG,CAAC,EAAE,CAAC;CACnE;AACD,QAAO;AACV;;;;;;;;;;;AAWD,MAAa,cAAc,CAAC,MAAM,SAAS,GAAG,UAAU,CAAE,MAAK;CAC3D,YAAY,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;CACxC,MAAM,cAAc,QAAQ,QAAQ,CAAC,IAAI,CAAC;CAC1C,MAAM,QAAQ,cAAc,MAAM,YAAY;CAC9C,MAAM,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,OAAO,OAAO,CAAC,SAAS,EAAE,MAAM,KAAK,QAAQ,EAAE,KAAK,UAAU,MAAM,UAAU,EAAE;CAClG,MAAM,kBAAkB,CAAC,GAAG,SAAS,MAAM,QAAQ,AAAC;AACpD,QAAO,gBAAgB,SAAS,IAAK,IACjC,CAAC,EAAE,CAAC,GACJ,gBAAgB,IAAI,CAAC,MAAM,YAAY,EAAE,WAAW,SAAS,GAAG;EAAE,GAAG;EAAS,MAAM,EAAE;CAAM,EAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAAI;AACpH;;;;;;;AAOD,MAAaC,iBAAe,CAAC,MAAM,SAAS,MAAM;CAC9C,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,OAAO,OAAO,GAAG,CAAC,CAAC,EAAE,KAAK,OAAO,MAAM;AACnD,KAAI,KAAK,UAAU,QAAW;AAC1B,MAAI,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,CAAC,SAAS,CAAC,IAAI,KAAK,OAAO;GAC1D,IAAI,cAAc,mBAAmB,KAAK,MAAM,aAAa,GAAG;GAChE,MAAM,YAAY,mBAAmB,KAAK,MAAM,WAAW,GAAG;GAC9D,cAAc,gBAAgB,YAAY,EAAE,GAAG,CAAC,QAAQ,CAAC,GAAG;GAC5D,KAAK,CAAC,GAAG,EAAE,UAAU,CAAC,EAAE,aAAa;EACxC,WACQ,CAAC,WAAW,CAAC,IAAI,KAAK,SAAS,KAAK,MAAM,gBAAgB,QAC/D,KAAK,CAAC,GAAG,EAAE,KAAK,MAAM,aAAa;AACvC,MAAI,CAAC,SAAS,CAAC,IAAI,KAAK,OACpB,KAAK,CAAC,aAAa,EAAG,KAAK,MAAM,UAAW,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;CAEhE;CACD,KAAK,CAAC,EAAE,CAAC;AACT,MAAK,MAAM,KAAK,KAAK,eACjB,KAAKA,eAAa,GAAG,SAAS,EAAE;AAEpC,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDD,UAAiB,SAAS,MAAM,UAAU,CAAE,GAAE;CAC1C,YAAY,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;CACxC,MAAM,kBAAkB,QAAQ,UAAU,CAAC,IAAI,CAAC;CAChD,MAAM,gBAAgB,CAAC,MAAM;AACzB,MAAI,oBAAoB,CAAC,IAAI,CAAC,CAC1B,QAAO,CAAC,MAAM,YAAY,EAAE,AAAC;WACxB,oBAAoB,CAAC,MAAM,CAAC,IAAI,YAAY,EAAE,CACnD,QAAO,CAAC,MAAM,IAAK;WACd,oBAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,EAAE,CACtD,QAAO,CAAC,MAAM,KAAM;AACxB,SAAO,CAAC,OAAO,YAAY,EAAE,AAAC;CACjC;AACD,KAAI,MAAM,QAAQ,KAAK,CAEnB,MAAK,MAAM,CAAC,OAAO,QAAQ,IAAI,KAAK,SAAS,EAAE;EAC3C,MAAM,IAAI,cAAc,QAAQ;AAChC,MAAI,EAAE,IACF,MAAM;GAAE,MAAM,MAAM,UAAU;GAAE,OAAO,CAAC,KAAK,CAAC;GAAE,aAAa;GAAS,WAAW,EAAE,KAAK,UAAU;EAAW;CAGpH;UAEI,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;EAC/B,MAAM,cAAe,CAAC,OAAO,CAAC,IAAI,OAAQ,KAAK,SAAS,GAAG,OAAO,QAAQ,KAAK;AAC/E,OAAK,MAAM,CAAC,MAAMC,QAAM,IAAI,aAAa;GAErC,MAAM,CAAC,QAAQC,cAAY,GAAG,cAAcD,QAAM;AAClD,OAAI,QACA,MAAM;IAAQ;IAAM,OAAO,CAAC,KAAK,CAAC;IAAE,aAAaA;IAAO,WAAWC,gBAAcD,UAAQ;GAAW;EAE3G;CACJ;AACJ;AACD,UAAiBE,aAAW,MAAM,UAAU,CAAE,GAAE,YAAY,CAAE,GAAE;AAC5D,MAAK,MAAM,KAAK,SAAS,MAAM,QAAQ,EAAE;EAErC,MAAM;GAAE,GAAG;GAAG,WAAW,CAAC,GAAG,SAAU;GAAE,OAAO,CAAC,eAAe,CAAC;EAAE;EACnE,OAAOA,aAAW,EAAE,aAAa,SAAS,CAAC,GAAG,WAAW,EAAE,IAAK,EAAC;CACpE;AACJ;;;;;;;AAOD,SAAS,YAAY,MAAM,MAAM;AAC7B,MAAK,MAAM,KAAK,SAAS,KAAK,CAC1B,KAAI,EAAE,SAAS,KACX,QAAO;AAElB;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BD,SAAgB,UAAU,MAAM,MAAM,UAAU,CAAE,GAAE;CAEhD,MAAM,IAAI,KAAK,YAAY,MAAM,MAAM,QAAQ,CAAC;AAChD,KAAI,CAAC,EACD,OAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;AACpD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCD,UAAiB,YAAY,MAAM,MAAM,UAAU,CAAE,GAAE;CACnD,YAAY,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;CACrE,MAAM,YAAY,QAAQ,aAAa,CAAC,CAAC,CAAC;CAE1C,MAAM,YAAY,KAAK,MAAM,UAAU;CACvC,MAAM,YAAY,CAAE;AACpB,MAAK,MAAM,KAAK,WAAW;EACvB,MAAM,QAAQ,YAAY,GAAG,KAAK;AAgBlC,MAAI,CAAC,OAAO;GACR,MAAM;IAAE,MAAM;IAAG,aAAa;IAAW,WAAW;IAAW;IAAW,OAAO,CAAC,eAAe,CAAC;GAAE;AACpG;EACH;EACD,OAAO,MAAM;EACb,MAAM;GAAE,GAAG;GAAO,WAAW,CAAC,GAAG,SAAU;GAAE,OAAO,CAAC,eAAe,CAAC;EAAE;EACvE,UAAU,KAAK,EAAE;CACpB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDD,MAAa,uBAAuB,CAAC,MAAM,UAAU,CAAE,GAAE,YAAY,CAAE,GAAE,WAAW;CAChF,MAAM,OAAO,QAAQ,QAAQ,CAAC,MAAM,CAAC;CACrC,MAAM,IAAI;EACN,CAAC,WAAW;AACR,QAAK,MAAM,EAAE,MAAM,WAAW,aAAa,WAAW,IAAI,SAAS,MAAM,QAAQ,EAC7E,MAAM,qBAAqB,aAAa;IAAE,GAAG;IAAS,MAAM;GAAW,GAAE,CAAC,GAAG,WAAW,IAAK,GAAE,EAAE;EAExG;EACD,YAAY;AACR,UAAO;EACV;EACD,WAAW;AACP,UAAO;IAAE;IAAM,aAAa;IAAM;IAAW,OAAO,CAAC,YAAY,CAAC;GAAE;EACvE;EACD,cAAc;AACV,UAAO;EACV;CACJ;AACD,QAAO;AACV;;;;;;;AAOD,MAAa,gBAAgB,CAAC,MAAM,YAAY;AAC5C,aAA4BC,SAAO,MAAM,QAAQ,CAAC;AACrD;;;;;;;;;;;;;;;;;;;;;;;AAuBD,MAAaA,WAAS,CAAC,MAAM,UAAU,CAAE,MAAK;CAC1C,MAAM,iBAAiB,QAAQ,kBAAkB;CACjD,MAAM,WAAW,iBAAiB,CAAC,MAAM;AAAE,MAAI,YAAY,EAAE,CACzD,QAAO;CAAI,IAAG,CAAC,MAAM;AACzB,QAAO,WAAW,MAAM,SAAS,KAAK,EAAE,SAAS,CAAE,EAAC;AACvD;AACD,MAAM,aAAa,CAAC,aAAa,WAAW,UAAU,CAAE,GAAE,cAAc;CACpE,MAAM,cAAc,QAAQ,QAAQ,CAAC,SAAS,CAAC;CAE/C,MAAM,SAAyB;EAAE,MAAM;EAAa,aAAa;EAAW,WAAW,CAAC,GAAG,SAAU;EAAE,OAAO,CAAC,YAAY,CAAC;CAAE,EAAC;CAC/H,YAAY,CAAC,GAAG,WAAW,WAAY;AACvC,MAAK,MAAM,KAAK,SAAS,aAAa,QAAQ,EAAE;EAC5C,MAAM,IAAI,QAAQ,iBAAiB,EAAE,YAAY,EAAE;QAC/B,WAAW,EAAE,aAAa,GAAG;GAAE,GAAG;GAAS,MAAM,EAAE;EAAM,GAAE,UAAU,EAAE,EAAE;CAChG;AACD,QAAO;AACV;;;;;;;AAOD,MAAa,mBAAmB,CAAC,MAAM,UAAU,CAAE,MAAK;AACpD,uBAAsCA,SAAO,MAAM,QAAQ,CAAC;AAC/D;;;;;;;;AAQD,SAAS,cAAc,MAAM,cAAc,EAAE,EAAE;AAC3C,KAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,CAAC,WAAW,CAAC,IAAI,KAC1D,QAAO;EACH,MAAM,KAAK;EACX,OAAO,CAAC,KAAK,CAAC;EACd,WAAW,KAAK;EAChB,aAAa,KAAK;CACrB;AACL,KAAI,CAAC,IAAI,CAAC,IAAI,KACV,QAAO;EAAE,MAAM,KAAK;EAAM,WAAW;EAAM,aAAa;EAAM,OAAO,CAAC,KAAK,CAAC;CAAE;AAElF,QAAO;EAAE,MAAM;EAAa,WAAW;EAAM,aAAa;EAAM,OAAO,CAAC,KAAK,CAAC;CAAE;AACnF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClYD,MAAaC,WAAS,CAAC,WAAW,CAAE,MAAK;CACrC,IAAIC;CACJ,MAAMC,QAAM,CAACC,SAAO,SAAS;EACzB,MAAM,IAAI,eAAeA,SAAO,MAAMF,QAAM,SAAS;AACrD,MAAIA,WAAS,QACTA,iBAA+B,EAAE;CAExC;CACD,MAAMG,gBAAc,MAAM;AACtB,MAAIH,WAAS,OACT,QAAO,CAAC,OAAO,CAAC;AACpB,wBAAoCA,OAAK;CAC5C;CACD,MAAM,WAAW,CAAC,SAAS;AACvB,MAAIA,WAAS,OACT;AACJ,SAAO,YAAY,MAAMA,QAAM,SAAS;CAC3C;CACD,MAAMI,WAAS,CAAC,SAAS;AACrB,MAAIJ,WAAS,OACT,QAAO;AACX,SAAO,aAAa,MAAMA,QAAM,SAAS;CAC5C;CACD,MAAM,UAAU,CAAC,SAAS;AACtB,MAAIA,WAAS,OACT,QAAO;EACX,MAAM,IAAI,gBAAgB,MAAMA,QAAM,SAAS;AAC/C,SAAO,MAAM;CAChB;CACD,MAAM,UAAU,CAAC,SAAS;AACtB,MAAIA,WAAS,OACT;EACJ,MAAM,IAAI,gBAAgB,MAAMA,QAAM,SAAS;AAC/C,SAAO;CACV;CACD,MAAMK,mBAAiB,CAAC,SAAS;AAC7B,MAAIL,WAAS,OACT,QAAO;EACX,MAAM,IAAI,gBAAgB,MAAMA,QAAM,SAAS;AAC/C,MAAI,MAAM,OACN,QAAO;AACX,SAAO,EAAE,cAAc;CAC1B;CACD,MAAM,YAAY,CAAC,SAAS;AACxB,MAAIA,WAAS,OACT,QAAO,CAAE;AACb,SAAO,aAAa,MAAMA,QAAM,SAAS;CAC5C;CACD,MAAMM,YAAU,MAAM;AAClB,SAAON;CACV;CACD,MAAM,cAAc,CAAC,SAAS;AAC1B,MAAIA,WAAS,OACT,QAAO;AACX,SAAO,kBAAkB,MAAMA,QAAM,SAAS;CACjD;AACD,QAAO;EAAE;EAAS;EAAK;EAAa;EAAQ;EAAU;EAAW;EAAS;EAAgB;EAAS;CAAa;AACnH;;;;;;;;;;;;;;;;;;;;;;AAsBD,MAAa,iBAAiB,CAACE,SAAO,MAAM,MAAM,WAAW,CAAE,MAAK;CAChE,MAAM,YAAY,SAAS,aAAa,CAAC,CAAC,CAAC;CAC3C,MAAM,gBAAgB,SAAS,cAAc,CAAC,SAAS,CAAC;CACxD,MAAM,QAAQ,KAAK,MAAM,UAAU;CACnC,IAAI,QAAQ;AACZ,MAAK,MAAM,KAAK,OAAO;EACnB,MAAM,YAAY,UAAU,MAAM,SAAS;EAE3C,MAAM,QAAQ,iBAAiB,GAAG,KAAK;AACvC,MAAI,UAAU,QAAW;GAErB,MAAM,WAAW;IACb,OAAQ,YAAYA,UAAQ;IAC5B,OAAO;GACV;GACD,kBAAkC,UAAU,KAAK;EACpD,OACI;GACD,OAAO;AACP,OAAI,UACA,SAAQ,eAAR;IACI,KAAK,CAAC,MAAM,CAAC,CACT;IAEJ,KAAK,CAAC,KAAK,CAAC,EAAE;KACV,MAAM,WAAW,kBAAkB,KAAK;KACxC,KAAK,QAAQ;MACT,QAAQ,CAAC,GAAG,UAAUA,OAAM;MAC5B,OAAO;KACV;AACD;IACH;IACD,KAAK,CAAC,SAAS,CAAC,EAAE;KACd,KAAK,QAAQ;MACT;MACA,OAAO;KACV;AACD;IACH;GACJ;QAID,OAAO;EAEd;EACD;CACH;AACD,KAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,qBAAqB,CAAC;AAC3C,QAAO;AACV;AACD,MAAa,eAAe,CAAC,MAAMF,QAAM,WAAW,CAAE,MAAK;AACvD,KAAIA,WAAS,OACT,QAAO;CACX,MAAM,IAAI,gBAAgB,MAAMA,QAAM,SAAS;AAC/C,KAAI,MAAM,OACN,QAAO;QACY,EAAE;AACzB,QAAO;AACV;AACD,MAAa,oBAAoB,CAAC,MAAMA,QAAM,WAAW,CAAE,MAAK;AAC5D,KAAIA,WAAS,OACT,QAAO;CACX,MAAM,IAAI,gBAAgB,MAAMA,QAAM,SAAS;AAC/C,KAAI,MAAM,OACN,QAAO;CACX,EAAE,QAAQ;EACN,OAAO,EAAE,OAAO,SAAS,EAAE;EAC3B,OAAO;CACV;AACD,QAAO;AACV;AACD,MAAa,uBAAuB,CAAC,MAAM,MAAM,WAAW,CAAE,MAAK;AAC/D,KAAI,SAAS,OACT,QAAO;CACX,MAAM,IAAI,gBAAgB,MAAM,MAAM,SAAS;AAC/C,KAAI,MAAM,OACN,QAAO;AACX,QAAO,EAAE,cAAc;AAC1B;;;;;;AAMD,MAAM,mBAAmB,CAAC,OAAO,SAAS;AACtC,KAAI,SAAS,OACT,QAAO;AACX,KAAI,UAAU,OACV,OAAM,IAAI,MAAM,CAAC,qCAAqC,CAAC;AAC3D,KAAI,KAAK,OAAO,UAAU,MACtB,QAAO;AACX,MAAK,MAAM,KAAK,KAAK,cACjB,KAAI,EAAE,OAAO,UAAU,MACnB,QAAO;AAElB;AACD,MAAa,cAAc,CAAC,MAAM,MAAM,WAAW,CAAE,MAAK;CACtD,MAAM,SAAS,aAAa,MAAM,MAAM,SAAS;AACjD,KAAI,OAAO,WAAW,EAClB,QAAO;AACX,KAAI,OAAO,SAAS,EAChB,OAAM,IAAI,MAAM,CAAC,8CAA8C,CAAC;AACpE,QAAO,OAAO;AACjB;AACD,MAAM,oBAAoB,CAAC,MAAM;AAC7B,KAAI,EAAE,UAAU,OACZ,QAAO,CAAE;AACb,KAAI,CAAC,MAAM,CAAC,IAAI,EAAE,MACd,QAAO,EAAE,MAAM;AACnB,KAAI,CAAC,KAAK,CAAC,IAAI,EAAE,OAAO;AACpB,MAAI,EAAE,MAAM,UAAU,OAClB,QAAO,CAAE;AACb,SAAO,CAAC,EAAE,MAAM,KAAM;CACzB;AACD,QAAO,CAAE;AACZ;AACD,MAAM,kBAAkB,CAAC,MAAM,MAAM,WAAW,CAAE,MAAK;CACnD,MAAM,YAAY,SAAS,aAAa,CAAC,CAAC,CAAC;CAC3C,MAAM,QAAQ,KAAK,MAAM,UAAU;CACnC,IAAI,IAAI;AACR,MAAK,MAAM,KAAK,OAAO;EACnB,IAAI,iBAAiB,GAAG,EAAE;AAC1B,MAAI,MAAM,OACN;CAEP;AACD,QAAO;AACV;AACD,MAAa,eAAe,CAAC,MAAM,MAAM,WAAW,CAAE,MAAK;CACvD,MAAM,YAAY,SAAS,aAAa,CAAC,CAAC,CAAC;CAC3C,MAAM,QAAQ,KAAK,MAAM,UAAU;CACnC,IAAI,IAAI;AACR,MAAK,MAAM,KAAK,OAAO;EAEnB,IAAI,iBAAiB,GAAG,EAAE;AAC1B,MAAI,MAAM,OAEN,QAAO,CAAE;CAEhB;AACD,QAAO,kBAAkB,EAAE;AAC9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzPD,MAAa,iBAAiB,CAAC,SAAS;AACpC,QAAO,CAAC,GAAG,KAAK,UAAU,AAAC,EAAC;AAC/B;;;;;;;;AAQD,MAAa,eAAe,CAAC,OAAO,gBAAgB,OAAO;AACvD,QAAO,UAAU,OAAO,gBAAgB,IAAI,OAAO,iBAAiB;AACvE;AACD,MAAa,oBAAoB,CAAC,OAAO,qBAAqB,OAAO;AACjE,KAAI,OAAO,UAAU,CAAC,SAAS,CAAC,CAC5B,OAAM,IAAI,UAAU,CAAC,0BAA0B,CAAC;AACpD,QAAO,eAAe,OAAO,qBAAqB,IAAI,OAAO,iBAAiB;AACjF;AACD,MAAa,uBAAuB,CAAC,OAAO,qBAAqB,OAAO;AACpE,QAAO,kBAAkB,OAAO,qBAAqB,IAAI,OAAO,iBAAiB;AACpF;;;;;;;;;;AAUD,MAAa,YAAY,CAAC,OAAO,gBAAgB,KAAM,gBAAiB,WAAW,MAAM;AACrF,KAAI,WAAW,EACX,QAAO;CACX,MAAM,cAAc,cAAc,MAAM;CACxC,MAAM,eAAe,cAAc,eAAe;CAClD,MAAM,IAAK,cAAc,MAAM,WAAW,GAAG,MAAM;AACnD,KAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CACxB,QAAO;AACX,KAAI,GAAG,GAAG,eAAe,CACrB,QAAO;CACX,MAAM,MAAM,cAAc,EAAE,aAAa,GAAG,EAAE;CAC9C,MAAM,OAAO,eAAgB,eAAgB,aAAa,GAAG,eAAe;AAE5E,KAAI,GAAG,KAAK,KAAK,CACb,QAAO;AAEX,QAAO,UAAU,GAAG,gBAAgB,IAAI,WAAW,EAAE;AACxD;;;;;;;;;;;;AAYD,MAAa,iBAAiB,CAAC,OAAO,qBAAqB,KAAM,gBAAiB,WAAW,MAAM;AAC/F,KAAI,UAAU,OACV,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAChD,KAAI,WAAW,EACX,QAAO;CAEX,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,QAAQ,MAAM,WAAW,GAAG,MAAM;AAC3D,KAAI,MAAM,OACN,QAAO;CAEX,MAAMO,UAAQ,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAE,UAAU,GAAG,EAAE;AACjD,KAAI,GAAGA,SAAO,oBAAoB,CAC9B,QAAO;AACX,QAAO,eAAe,GAAG,qBAAqB,IAAI,WAAW,EAAE;AAClE;AACD,MAAa,oBAAoB,CAAC,OAAO,qBAAqB,KAAM,gBAAiB,WAAW,MAAM;AAClG,KAAI,WAAW,EACX;CACJ,MAAM,IAAK,CAAC,SAAS,CAAC,IAAI,QAAQ,MAAM,WAAW,GAAG,MAAM;AAC5D,KAAI,MAAM,OACN;CACJ,MAAMA,UAAQ,CAAC,QAAQ,CAAC,IAAI,IAAI,EAAE,UAAU,GAAG,EAAE;AACjD,KAAI,GAAGA,SAAO,oBAAoB,CAC9B,QAAO;AACX,QAAO,kBAAkB,GAAG,qBAAqB,IAAI,WAAW,EAAE;AACrE;;;;;;;;;;;;;AAaD,MAAa,gBAAgB,CAAC,QAAQ,kBAAkB,KAAK,mBAAmB;AAC5E,KAAI,GAAG,QAAQ,iBAAiB,CAC5B,OAAM,IAAI,MAAM,CAAC,mBAAmB,CAAC;AACzC,KAAI,YAAY,QAAQ,kBAAkB,GAAG,CACzC,OAAM,IAAI,MAAM,CAAC,kCAAkC,CAAC;AAExD,KAAI,YAAY,kBAAkB,QAAQ,GAAG,CACzC,OAAM,IAAI,MAAM,CAAC,8CAA8C,CAAC;AAEvE;;;;;;;;;AASD,MAAa,cAAc,CAAC,QAAQ,eAAe,KAAK,mBAAmB;AACvE,QAAO,SAAS,QAAQ,eAAe,IAAI,OAAO,iBAAiB;AACtE;AACD,MAAa,mBAAmB,CAAC,QAAQ,oBAAoB,KAAK,mBAAmB;AACjF,QAAO,cAAc,QAAQ,oBAAoB,IAAI,OAAO,iBAAiB;AAChF;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,WAAW,CAAC,QAAQ,eAAe,KAAK,gBAAgB,WAAW,MAAM;AAClF,KAAI,WAAW,EACX,QAAO;AACX,KAAI,GAAG,QAAQ,cAAc,CACzB,QAAO;CACX,MAAM,MAAM,CAAC,WAAW,CAAC,IAAI,SAAS,OAAO,aAAa,GAAG,OAAO;CACpE,MAAM,OAAO,CAAC,WAAW,CAAC,IAAI,gBAAgB,cAAc,aAAa,GAAG,cAAc;AAC1F,KAAI,GAAG,KAAK,KAAK,CACb,QAAO;AACX,MAAK,MAAM,KAAK,aAAa,QAAQ,SAAS,EAAE;EAC5C,MAAM,MAAM,CAAC,WAAW,CAAC,IAAI,IAAI,EAAE,aAAa,GAAG,EAAE;AACrD,MAAI,GAAG,GAAG,cAAc,CACpB,QAAO;AACX,MAAI,GAAG,KAAK,KAAK,CACb,QAAO;CACd;AACD,QAAO;AACV;AACD,MAAa,gBAAgB,CAAC,QAAQ,eAAe,KAAK,gBAAgB,WAAW,MAAM;AACvF,KAAI,WAAW,EACX,QAAO;AACX,KAAI,GAAG,OAAO,UAAU,EAAE,cAAc,CACpC,QAAO;AACX,MAAK,MAAM,KAAK,aAAa,QAAQ,SAAS,EAAE;EAC5C,MAAM,IAAI,EAAE,UAAU;AACtB,MAAI,GAAG,GAAG,cAAc,CACpB,QAAO;CACd;AACD,QAAO;AACV;;;;;;;;;;;;AAYD,UAAiB,SAAS,MAAM;CAC5B,MAAM,IAAI,KAAK,WAAW;AAC1B,KAAI,MAAM,OACN;AACJ,MAAK,MAAM,KAAK,EAAE,UAAU,EAAE;AAC1B,MAAI,MAAM,KACN;EACJ,MAAM;CACT;AACJ;;;;;;;;;;;;AAcD,UAAiB,QAAQ,MAAM;AAC3B,KAAI,cAAc,KAAK,EAAE;EACrB,IAAI,IAAI,KAAK,WAAW;AACxB,SAAO,MAAM,QAAW;GACpB,MAAM;GACN,IAAI,EAAE,WAAW;EACpB;CACJ,OACI;EACD,IAAI,IAAI,KAAK;AACb,SAAO,MAAM,QAAW;GACpB,MAAM;GACN,IAAI,EAAE;EACT;CACJ;AACJ;;;;;;;;;AAiBD,SAAgB,oBAAoB,QAAQ,eAAe,KAAK,gBAAgB;AAC5E,QAAO,iBAAiB,QAAQ,eAAe,IAAI,OAAO,iBAAiB;AAC9E;;;;;;;;;;AAqBD,SAAgB,iBAAiB,QAAQ,eAAe,KAAK,gBAAgB,WAAW,GAAG;AACvF,KAAI,WAAW,EACX;CACJ,MAAM,WAAW,cAAc,OAAO;AACtC,KAAI,UACA;MAAI,GAAG,OAAO,UAAU,EAAE,cAAc,CACpC,QAAO;CAAO,WAGd,GAAG,OAAO,OAAO,cAAc,CAC/B,QAAO;AAEf,MAAK,MAAM,KAAK,aAAa,QAAQ,SAAS,CAE1C,KAAI,UACA;MAAI,GAAG,EAAE,UAAU,EAAE,cAAc,CAC/B,QAAO;CAAE,WAGT,GAAG,EAAE,OAAO,cAAc,CAC1B,QAAO;AAGnB;AACH;;;;;;;;;;;;AAaD,UAAiB,WAAWC,QAAM;AAC9B,KAAI,CAACA,OACD;CACJ,MAAM,QAAQ,IAAI;CAClB,IAAI,QAAQA;AACZ,QAAO,OAAO;EACV,MAAMC,YAAU,cAAc,MAAM,GAChC,CAAC,GAAG,MAAM,UAAU,AAAC,IACrB,CAAC,GAAG,MAAM,aAAc;EAC5B,MAAM,KAAK,GAAGA,UAAQ;AACtB,MAAI,MAAM,QACN;EACJ,QAAQ,MAAM,KAAK;AACnB,MAAI,OACA,MAAM;CACb;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BD,UAAiB,aAAaD,QAAM,QAAQ,OAAO,kBAAkB;AACjE,KAAI,CAACA,OACD;CACJ,MAAM,SAAS,cAAcA,OAAK;CAClC,MAAM,QAAQ,SAAS,IAAI,iBAAiB,IAAI;CAChD,IAAI,QAAQA;AACZ,QAAO,OAAO;AACV,MAAI,QAAQ,EACR;AACJ,MAAI,UAAU,QAAW;GACrB,MAAM,OAAO,CAAC,aAAa,CAAC,IAAI,QAAQ,MAAM,gBAAgB,MAAM,UAAU;AAC9E,QAAK,MAAM,KAAK,MAAM;IAClB,MAAM;IACN,MAAM,QAAQ,EAAE;GACnB;EACJ;EACD,QAAQ,MAAM,SAAS;EACvB;CACH;AACJ;;;;;;;;;;AAUD,SAAgB,KAAKA,QAAM,WAAW,QAAQ,CAAC,OAAO,CAAC,EAAE;AACrD,KAAI,UAAUA,OAAK,CACf,QAAOA;CACX,MAAM,OAAO,UAAU,CAAC,OAAO,CAAC,GAAG,eAAe;AAClD,MAAK,MAAM,KAAK,KAAKA,OAAK,CACtB,KAAI,UAAU,EAAE,CACZ,QAAO;AAElB;;;;;;;;;;;;;;AAcD,SAAgB,YAAYA,QAAM,WAAW,QAAQ,CAAC,OAAO,CAAC,EAAE;AAC5D,KAAI,UAAUA,OAAK,UAAU,CAAC,CAC1B,QAAOA;CACX,MAAM,OAAO,UAAU,CAAC,OAAO,CAAC,GAAG,eAAe;AAClD,MAAK,MAAM,KAAK,KAAKA,OAAK,CACtB,KAAI,UAAU,EAAE,UAAU,CAAC,CACvB,QAAO;AAElB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCD,UAAiB,YAAYA,QAAM,mBAAmB,QAAQ,GAAG;AAC7D,MAAK,MAAM,KAAKA,OAAK,UAAU,CAC3B,KAAI,kBAAkB,EAAE,UAAU,EAAE,MAAM,EAAE;EACxC,MAAM,EAAE,UAAU;EAClB,OAAO,YAAY,GAAG,mBAAmB,QAAQ,EAAE;CACtD;AAER;AACD,SAAgB,aAAa,MAAM,QAAQ,GAAG;AAC1C,KAAI,SAAS,OACT,QAAO,CAAC,WAAW,CAAC;AACxB,KAAI,SAAS,KACT,QAAO,CAAC,MAAM,CAAC;CACnB,MAAM,IAAI,KAAK,UAAU;CACzB,IAAI,OAAO,OAAO;AAClB,KAAI,MAAM,QAAQ,EAAE,EAChB,OAAO,CAAC,KAAK,CAAC;CAClB,IAAI,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,MAAM,GAAG,CAAC,OAAO,EAAE,KAAK,UAAU,EAAE,CAAC,EAAE,EAAE,KAAK,GAAG,CAAC;AACtE,MAAK,MAAM,KAAK,KAAK,UAAU,EAC3B,KAAK,aAAa,GAAG,QAAQ,EAAE;AAEnC,QAAO;AACV;AACD,SAAgB,SAAS,GAAG,OAAO;CAC/B,IAAI,IAAI,EAAE;AACV,MAAK,MAAM,QAAQ,OAAO;EACtB,MAAM,IAAI,KAAK,UAAU;EACzB,MAAM,UAAU,mBAAmB,EAAE;EACrC,MAAME,aAAW,CAAC,GAAG,KAAK,UAAU,AAAC;EACrC,MAAM,SAAS,KAAK,WAAW;EAC/B,IAAI,OAAO,OAAO;AAClB,MAAI,MAAM,QAAQ,EAAE,EAChB,OAAO,CAAC,KAAK,CAAC;EAClB,KAAK,CAAC,OAAO,EAAE,QAAQ,EAAE,EAAE,KAAK,QAAQ,EAAEA,WAAS,OAAO,WAAW,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;CAChG;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;AC9cD,MAAa,gBAAgB,CAAC,SAAS;AACnC,KAAI,cAAc,KAAK,CACnB,QAAO;AACX,KAAI,WAAW,KAAK,CAChB,QAAOC,uBAAsB,KAAK;AACtC,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CACxB,QAAOC,qBAAoB,KAAK;AACpC,OAAM,IAAI,MAAM,CAAC,gCAAgC,CAAC;AACrD;;;;;;;;AAQD,MAAa,aAAa,CAAC,SAAS;AAChC,KAAI,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,MAC1D;MAAI,MAAM,QAAQ,KAAK,cAAc,CACjC,QAAO;CAAK;AAEpB,QAAO;AACV;;;;;;;;AAQD,MAAa,gBAAgB,CAAC,SAAS;AACnC,QAAQ,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,IAAI,QAAQ,CAAC,WAAW,CAAC,IAAI;AAC/F;;;;AC5CD,IAAa,iBAAb,MAAa,eAAe;CACxB;CAEA;CACA,YAAY,OAAO,CAAE,GAAE,OAAO,CAAE,GAAE;EAC9B,KAAK,OAAO;EACZ,KAAK,OAAO;CACf;CACD,KAAK,GAAG,OAAO;AACX,SAAO,IAAI,eAAe,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG,MAAM;CAC5E;CACD,MAAM;AACF,SAAO,IAAI,eAAe,KAAK,MAAM,IAAI,KAAK,MAAM,KAAK,KAAK;CACjE;CACD,QAAQ,IAAI;EACR,KAAK,KAAK,QAAQ,GAAG;CACxB;CACD,eAAe,IAAI;EACf,CAAC,GAAG,KAAK,IAAK,EAAC,SAAS,CAAC,QAAQ,GAAG;CACvC;CACD,IAAI,UAAU;AACV,SAAOC,UAAQ,KAAK,MAAM,KAAK,KAAK;CACvC;CACD,IAAI,SAAS;AACT,SAAOC,SAAO,KAAK,MAAM,KAAK,KAAK;CACtC;CACD,IAAI,OAAO;AACP,SAAOC,OAAK,KAAK,MAAM,KAAK,KAAK;CACpC;CACD,IAAI,SAAS;AACT,SAAO,KAAK,KAAK;CACpB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;AAwBD,MAAaC,cAAY,CAAC,UAAU,CAAE,GAAE,GAAG,kBAAkB,IAAI,eAAe,EAAE,GAAG,QAAS,GAAE,CAAC,GAAG,aAAc;;;;;;;;;;;;;;;;;;;;;;;;;AE/ClH,MAAaC,YAAU,CAAC,cAAc,IAAI,iBAAiB;;;;AAI3D,IAAa,mBAAb,cAAsC,mBAAmB;CAGrD,wBAAQ,IAAI;CACZ;;;;;CAKA,YAAY,WAAW;EACnB,OAAO;EACP,KAAK,YAAY,aAAc;CAClC;;;;CAID,IAAI,OAAO;AACP,SAAO,KAAK,MAAM;CACrB;;;;;CAKD,IAAI,GAAG,QAAQ;EAEX,IAAI,iBAAiB;AACrB,OAAK,MAAMC,WAAS,QAAQ;GACxB,MAAM,YAAY,KAAK,IAAIA,QAAM;GACjC,KAAK,MAAM,IAAI,KAAK,UAAUA,QAAM,EAAEA,QAAM;GAC5C,MAAM,UAAU,CAAC,GAAG,CAAC,EAAE;IAAE,OAAOA;IAAO,SAAS;GAAW,EAAC;AAC5D,OAAI,CAAC,WACD,iBAAiB;EACxB;AACD,SAAO;CACV;;;;;CAMD,SAAS;AACL,SAAO,KAAK,MAAM,QAAQ;CAC7B;;;;CAID,QAAQ;EACJ,KAAK,MAAM,OAAO;EAClB,MAAM,UAAU,CAAC,KAAK,CAAC,EAAE,KAAK;CACjC;;;;;;CAMD,OAAO,GAAG;EACN,MAAM,YAAY,KAAK,MAAM,OAAO,KAAK,UAAU,EAAE,CAAC;AACtD,MAAI,WACA,MAAM,UAAU,CAAC,MAAM,CAAC,EAAE,EAAE;AAChC,SAAO;CACV;;;;;;CAMD,IAAI,GAAG;AACH,SAAO,KAAK,MAAM,IAAI,KAAK,UAAU,EAAE,CAAC;CAC3C;;;;;CAKD,UAAU;AACN,SAAO,CAAC,GAAG,KAAK,MAAM,QAAQ,AAAC;CAClC;AACJ;;;;ACxFD,IAAa,qBAAb,MAAa,mBAAmB;CAC5B;CACA;CAEA,YAAY,WAAWC,OAAK;EACxB,KAAK,QAAQA,yBAAO,IAAI;EACxB,KAAK,YAAY,aAAc;CAClC;CACD,IAAI,OAAO;AACP,SAAO,KAAK,MAAM;CACrB;CACD,IAAI,GAAG,QAAQ;EACX,MAAM,IAAI,IAAI,IAAI,KAAK;AACvB,OAAK,MAAM,KAAK,QAAQ;GACpB,MAAM,MAAM,KAAK,UAAU,EAAE;GAC7B,EAAE,IAAI,KAAK,EAAE;EAChB;AACD,SAAO,IAAI,mBAAmB,KAAK,WAAW;CACjD;CACD,OAAO,GAAG;EACN,MAAM,IAAI,IAAI,IAAI,KAAK;EACvB,MAAM,MAAM,KAAK,UAAU,EAAE;AAC7B,MAAI,EAAE,OAAO,IAAI,CACb,QAAO,IAAI,mBAAmB,KAAK,WAAW;AAClD,SAAO;CACV;CACD,IAAI,GAAG;EACH,MAAM,MAAM,KAAK,UAAU,EAAE;AAC7B,SAAO,KAAK,MAAM,IAAI,IAAI;CAC7B;CACD,UAAU;AACN,SAAO,CAAC,GAAG,KAAK,MAAM,QAAQ,AAAC;CAClC;CACD,CAAC,SAAS;EACN,OAAO,KAAK,MAAM,QAAQ;CAC7B;AACJ;;;;;;;AAOD,MAAaC,cAAY,CAAC,YAAY,oBAAoB,IAAI,mBAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBjF,IAAa,aAAb,MAAa,WAAW;CACpB;CACA;CACA,2BAAW,IAAI;CACf,SAAS,CAAE;CACX,YAAY,WAAW,GAAG,QAAQ,GAAG;EACjC,KAAKC,SAAS;EACd,KAAKC,YAAY;CACpB;;;;;CAKD,YAAY;AACR,SAAO,KAAK,OAAO;CACtB;;;;;;CAMD,eAAe;AACX,SAAO,CAAC,GAAG,KAAK,SAAS,QAAQ,AAAC,EAAC;CACtC;CACD,mBAAmB;EACf,IAAI,IAAI,KAAK,cAAc;AAC3B,OAAK,MAAM,KAAK,KAAK,SAAS,QAAQ,EAClC,KAAK,EAAE,kBAAkB;AAE7B,SAAO;CACV;;;;CAID,OAAO;EACH,IAAI,IAAI,KAAK,OAAO;AACpB,OAAK,MAAMC,SAAO,KAAK,SAAS,QAAQ,EACpC,KAAKA,MAAI,MAAM;AAEnB,SAAO;CACV;CACD,IAAIC,SAAO;AACP,MAAI,OAAOA,YAAU,CAAC,MAAM,CAAC,CACzB,OAAM,IAAI,MAAM,CAAC,qCAAqC,EAAE,OAAOA,SAAO;AAC1E,MAAIA,QAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;EAC5C,MAAM,cAAc,KAAKC,UAAUD,SAAO,KAAK;AAC/C,MAAI,gBAAgB,MAAM;AACtB,OAAI,CAAC,KAAK,SAASA,QAAM,EACrB,KAAK,OAAO,KAAKA,QAAM;AAE3B;EACH;AACD,MAAI,CAAC,YACD,OAAM,IAAI,MAAM,CAAC,gCAAgC,EAAEA,SAAO;EAC9D,YAAY,IAAIA,QAAM;CACzB;CACD,OAAOA,SAAO;AACV,MAAI,OAAOA,YAAU,CAAC,MAAM,CAAC,CACzB,OAAM,IAAI,MAAM,CAAC,qCAAqC,EAAE,OAAOA,SAAO;AAC1E,MAAIA,QAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;EAC5C,MAAM,cAAc,KAAKC,UAAUD,SAAO,MAAM;AAChD,MAAI,gBAAgB,OAChB,QAAO;AACX,MAAI,gBAAgB,MAAM;AACtB,OAAI,KAAK,SAASA,QAAM,EAAE;IACtB,KAAK,SAAS,KAAK,OAAO,OAAO,OAAK,MAAMA,QAAM;AAClD,WAAO;GACV;AACD,UAAO;EACV;AACD,SAAO,YAAY,OAAOA,QAAM;CACnC;CACD,YAAY;EACR,MAAM,IAAI,KAAKE,cAAc;AAC7B,OAAK,MAAM,MAAM,GACb,QAAQ,IAAI,GAAG;CAEtB;CACD,aAAa,QAAQ,GAAG;EACpB,MAAM,IAAI,CAAE;EACZ,EAAE,KAAK,CAAC,OAAO,EAAE,KAAKL,OAAO,MAAM,EAAE,KAAKC,WAAW,CAAC;AACtD,OAAK,MAAM,CAAC,KAAKE,QAAM,IAAI,KAAK,SAAS,SAAS,EAAE;GAChD,MAAM,SAASA,QAAME,aAAa,QAAQ,EAAE;GAC5C,EAAE,KAAK,CAAC,MAAM,EAAE,KAAK,CAAC;AACtB,QAAK,MAAM,KAAK,QACZ,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,QAAQ,EAAE,GAAG,EAAE;EAExC;EACD,EAAE,KAAK,CAAC,SAAS,EAAE,KAAK,OAAO,OAAO,CAAC,CAAC,CAAC;AACzC,OAAK,MAAM,KAAK,KAAK,QACjB,EAAE,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC;AAEnB,SAAO,EAAE,IAAI,UAAQ,CAAC,CAAC,CAAC,CAAC,OAAO,MAAM,GAAG,KAAK;CACjD;CACD,UAAUF,SAAOG,UAAQ;AACrB,MAAIH,YAAU,OACV,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;AAC7C,MAAI,KAAKH,WAAW,KAAKC,UACrB,QAAO;AACX,MAAIE,QAAM,UAAU,KAAKH,OACrB,QAAO;EACX,MAAM,IAAIG,QAAM,KAAKH;AACrB,MAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,KAAKA,OAAO,MAAM,EAAEG,QAAM,QAAQ;EAC7E,IAAI,QAAQ,KAAK,SAAS,IAAI,EAAE;AAChC,MAAI,UAAU,UAAaG,UAAQ;GAC/B,QAAQ,IAAI,WAAW,KAAKL,WAAW,KAAKD,SAAS;GACrD,KAAK,SAAS,IAAI,GAAG,MAAM;EAC9B;AACD,SAAO;CACV;;;;;;CAMD,SAASG,SAAO;AACZ,OAAK,MAAM,KAAK,KAAK,OACjB,KAAI,MAAMA,QACN,QAAO;AAEf,SAAO;CACV;CACD,IAAIA,SAAO;AACP,MAAI,OAAOA,YAAU,CAAC,MAAM,CAAC,CACzB,QAAO;EACX,MAAM,cAAc,KAAKC,UAAUD,SAAO,MAAM;AAChD,MAAI,gBAAgB,OAChB,QAAO;AACX,MAAI,gBAAgB,KAChB,QAAO,KAAK,SAASA,QAAM;AAC/B,SAAO,YAAY,IAAIA,QAAM;CAChC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE5ID,IAAa,kBAAb,cAAqC,aAAa;CAC9C,YAAY,OAAO,CAAE,GAAE;AACnB,MAAI,KAAK,OAAO,QACZ,OAAO;GACH,GAAG;GACH,IAAI,CAAC,GAAG,MAAM;AACV,WAAO,eAAe,EAAE,MAAM,EAAE,KAAK;GACxC;EACJ;EAEL,MAAM,KAAK;CACd;;;;;;CAMD,oBAAoB,MAAMI,YAAU;EAChC,YAAY,WAAWA,YAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;EAC7C,MAAM,QAAQ;GAAE;GAAM;EAAU,EAAC;CACpC;CACD,eAAe,MAAMA,YAAU,eAAe,OAAO,IAAI;AACrD,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;EAC9C,IAAI;AACJ,OAAK,MAAM,KAAK,KAAK,KACjB,KAAI,IACA;OAAI,GAAG,EAAE,MAAM,KAAK,EAAE;IAClB,WAAW;AACX;GACH;aAGG,KAAK,GAAG,GAAG;GAAE;GAAM,UAAU;EAAG,EAAC,EAAE;GACnC,WAAW;AACX;EACH;AAGT,MAAI,aAAa,UAAa,CAAC,aAC3B,OAAM,IAAI,MAAM,CAAC,wCAAwC,EAAE,KAAK,UAAU,KAAK,EAAE;AACrF,MAAI,aAAa,QACb,KAAK,YAAY,YAAQ,aAAaC,OAAK;EAE/C,KAAK,oBAAoB,MAAMD,WAAS;CAC3C;CACD,aAAa;EAET,MAAM,IAAIE,OAAcC,IAAa,KAAK,MAAM,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC;AACpF,MAAI,MAAM,OACN;EACJ,KAAK,YAAY,UAAQ,SAAS,EAAE;AACpC,SAAO,EAAE;CACZ;CACD,aAAa;EACT,MAAM,IAAID,OAAcC,IAAa,KAAK,MAAM,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC;AAEpF,MAAI,MAAM,OACN;EACJ,KAAK,YAAY,UAAQ,KAAK,SAAS,EAAE;AACzC,SAAO,EAAE;CACZ;CACD,UAAU;EACN,MAAM,IAAID,OAAcC,IAAa,KAAK,MAAM,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC;AAEpF,MAAI,MAAM,OACN;AACJ,SAAO,EAAE;CACZ;CACD,UAAU;EAEN,MAAM,IAAID,OAAcE,IAAa,KAAK,MAAM,CAAC,GAAG,MAAM,EAAE,YAAY,EAAE,SAAS,CAAC;AACpF,MAAI,MAAM,OACN;AACJ,SAAO,EAAE;CACZ;AACJ;;;;;;;;;;;AAWD,SAAgB,SAAS,OAAO,CAAE,GAAE;AAChC,QAAO,IAAI,gBAAgB;AAC9B;;;;ACrGD,IAAa,iBAAb,MAAa,eAAe;CACxB;CACA;;;;;;CAMA,YAAY,OAAO,CAAE,GAAE,OAAO,CAAE,GAAE;AAC9B,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;EAC9C,KAAK,OAAO;EACZ,KAAKC,QAAQ;CAChB;CACD,QAAQ,IAAI;AAER,OAAK,IAAI,QAAQ,KAAKA,MAAM,SAAS,GAAG,SAAS,GAAG,SAChD,GAAG,KAAKA,MAAM,OAAO;CAE5B;CACD,iBAAiB,IAAI;EAEjB,KAAKA,MAAM,QAAQ,UAAQ;GAAE,GAAG,KAAK;EAAG,EAAC;CAC5C;CACD,QAAQ,GAAG,OAAO;AACd,SAAO,IAAI,eAAe,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAKA,OAAO,GAAG,MAAM;CAChF;CACD,UAAU;AACN,SAAO,IAAI,eAAe,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAKA,MAAM;CACtE;CACD,IAAI,UAAU;AACV,SAAO,QAAQ,KAAK,MAAM,KAAKA,MAAM;CACxC;CACD,IAAI,SAAS;AACT,SAAO,OAAO,KAAK,MAAM,KAAKA,MAAM;CACvC;CACD,IAAI,SAAS;AACT,SAAO,KAAKA,MAAM;CACrB;CACD,IAAI,OAAO;AACP,SAAO,KAAK,KAAK,MAAM,KAAKA,MAAM;CACrC;CACD,UAAU;AACN,SAAO,CAAC,GAAG,KAAKA,KAAM;CACzB;AACJ;;;;;;;;;;;;;;;;;;;;;;AAsBD,MAAaC,cAAY,CAAC,UAAU,CAAE,GAAE,GAAG,kBAAkB;CACzD,UAAU,EAAE,GAAG,QAAS;AACxB,QAAO,IAAI,eAAe,SAAS,CAAC,GAAG,aAAc;AACxD;;;;;;;;;;;;;;;;;;;;;;;;;;;;AElED,MAAaC,WAAS,CAAC,UAAU,CAAE,MAAK,IAAI,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8DxD,IAAa,cAAb,cAAiC,mBAAmB;CAChD;CACA;CAEA;CACA;CACA;CACA;CACA,WAAW;CACX,YAAY,OAAO,CAAE,GAAE;EACnB,OAAO;EACP,KAAK,WAAW,KAAK,YAAY;EACjC,YAAY,YAAY,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;EAC9D,KAAK,wBAAQ,IAAI;AAEjB,MAAI,KAAK,eAAe,KAAK,YAAY,EACrC,OAAM,IAAI,MAAM,CAAC,gDAAgD,CAAC;EAEtE,KAAK,cAAc,KAAK,eAAe,CAAC,IAAI,CAAC;EAC7C,KAAK,sBAAsB,KAAK,uBAAuB;EACvD,KAAK,mBAAmB,KAAK,oBAAoB,CAAC,IAAI,CAAC;AACvD,MAAI,KAAK,sBAAsB,GAC3B,KAAK,kBAAkB,YAAY,MAAM;GAAE,KAAKC,WAAW;EAAG,GAAE,KAAK,IAAI,KAAM,KAAK,sBAAsB,EAAE,CAAC;CAEpH;CACD,UAAU;AACN,MAAI,KAAK,SACL;EACJ,KAAK,WAAW;AAChB,MAAI,KAAK,iBAAiB;GACtB,cAAc,KAAK,gBAAgB;GACnC,KAAK,kBAAkB;EAC1B;CACJ;;;;CAID,IAAI,YAAY;AACZ,SAAO,KAAK,MAAM;CACrB;CACD,CAAC,UAAU;AACP,OAAK,MAAM,SAAS,KAAK,MAAM,SAAS,EACpC,MAAM,CAAC,MAAM,IAAI,MAAM,GAAG,KAAM;CAEvC;CACD,CAAC,SAAS;AACN,OAAK,MAAM,KAAK,KAAK,MAAM,QAAQ,EAC/B,MAAM,EAAE;CAEf;CACD,CAAC,OAAO;EACJ,OAAO,KAAK,MAAM,MAAM;CAC3B;;;;;;CAMD,WAAW,KAAK;EACZ,MAAM,IAAI,KAAK,MAAM,IAAI,IAAI;AAC7B,MAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CACxB;AACJ,SAAO,KAAK,KAAK,GAAG,EAAE;CACzB;;;;;;CAMD,WAAW,KAAK;EACZ,MAAM,IAAI,KAAK,MAAM,IAAI,IAAI;AAC7B,MAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CACxB;AACJ,SAAO,KAAK,KAAK,GAAG,EAAE;CACzB;;;;;;;CAOD,IAAI,KAAK;AACL,SAAO,KAAK,MAAM,IAAI,IAAI;CAC7B;;;;;;;CAOD,IAAI,KAAK;EACL,MAAM,IAAI,KAAK,MAAM,IAAI,IAAI;AAC7B,MAAI,GAAG;AACH,OAAI,KAAK,qBAAqB,CAAC,MAAM,CAAC,IAAI,KAAK,qBAAqB,CAAC,GAAG,CAAC,EACrE,KAAK,MAAM,IAAI,KAAK;IAChB,GAAG;IACH,SAAS,YAAY,KAAK;GAC7B,EAAC;AAEN,UAAO,EAAE;EACZ;CACJ;;;;;;;;CAQD,OAAO,KAAK;EACR,MAAMC,UAAQ,KAAK,MAAM,IAAI,IAAI;AACjC,MAAI,CAACA,QACD,QAAO;EACX,MAAM,IAAI,KAAK,MAAM,OAAO,IAAI;EAEhC,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE;GACtB;GACA,OAAOA,QAAM;EAChB,EAAC;AACF,SAAO;CACV;;;;;CAKD,QAAQ;EACJ,KAAK,MAAM,OAAO;CACrB;;;;;;;;;CASD,MAAM,KAAK;EACP,MAAM,IAAI,KAAK,MAAM,IAAI,IAAI;AAC7B,MAAI,CAAC,EACD,QAAO;EACX,KAAK,MAAM,IAAI,KAAK;GAChB,GAAG;GACH,SAAS,KAAK,KAAK;GACnB,SAAS,KAAK,KAAK;EACtB,EAAC;AACF,SAAO;CACV;CACD,iBAAiB;AACb,MAAI,KAAK,gBAAgB,CAAC,IAAI,CAAC,CAC3B;EACJ,IAAI,SAAS,EAAE;AACf,MAAI,KAAK,gBAAgB,CAAC,SAAS,CAAC,EAChC,SAAS,CAAC,OAAO,CAAC;WACb,KAAK,gBAAgB,CAAC,SAAS,CAAC,EACrC,SAAS,CAAC,OAAO,CAAC;MAElB,OAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,KAAK,aAAa;EACjE,MAAM,SAAS,oBAAoB,KAAK,OAAO,OAAO;AACtD,SAAO,OAAO,GAAG;CACpB;CACD,YAAY;AACR,MAAI,KAAK,qBAAqB,CAAC,IAAI,CAAC,CAChC;EACJ,KAAK,kBAAkB,KAAK,qBAAqB,KAAK,iBAAiB;CAC1E;;;;;;;;;;;;;;;CAeD,kBAAkB,UAAU,UAAU;EAClC,MAAMC,YAAU,CAAC,GAAG,KAAK,MAAM,SAAS,AAAC;EACzC,MAAM,QAAQ,CAAE;EAChB,MAAM,aAAa,aAAa,UAAU,IAAK;EAC/C,MAAM,MAAM,YAAY,KAAK;AAC7B,OAAK,MAAM,SAASA,WAAS;GACzB,MAAM,aAAa,MAAM,MAAM,GAAG;GAClC,MAAM,aAAa,MAAM,MAAM,GAAG;GAClC,MAAM,UAAU,aAAa,CAAC,GAAG,CAAC,GAC5B,aACC,aAAa,CAAC,GAAG,CAAC,GACf,aACA,KAAK,IAAI,YAAY,WAAW;AAC1C,OAAI,WAAW,YACX,MAAM,KAAK,CAAC,MAAM,IAAI,MAAM,GAAG,KAAM,EAAC;EAE7C;AACD,OAAK,MAAM,SAAS,OAAO;GACvB,KAAK,MAAM,OAAO,MAAM,GAAG;GAE3B,MAAM,iBAAiB;IACnB,KAAK,MAAM;IACX,OAAO,MAAM;GAChB;GACD,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,eAAe;GACzC,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,eAAe;EAC5C;AACD,SAAO;CACV;;;;;;;;;;;;CAYD,IAAI,KAAKD,SAAO;EACZ,MAAM,WAAW,KAAK,MAAM,IAAI,IAAI;AACpC,MAAI,UAAU;GAEV,KAAK,MAAM,IAAI,KAAK;IAChB,GAAG;IACH,SAAS,YAAY,KAAK;GAC7B,EAAC;AACF;EACH;AAED,MAAI,KAAK,cAAc,KAAK,YAAY,KAAK,WAAW,GAAG;GAEvD,MAAME,QAAM,KAAK,gBAAgB;AACjC,OAAI,CAACA,MACD,OAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,SAAS,CAAC,CAAC;GAEnE,MAAMC,aAAW,KAAK,MAAM,IAAID,MAAI;GACpC,KAAK,MAAM,OAAOA,MAAI;AAEtB,OAAIC,YAAU;IACV,MAAM,iBAAiB;KAAE;KAAK,OAAOA,WAAS;IAAO;IACrD,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,eAAe;IACzC,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,eAAe;GAC5C;EACJ;EAED,KAAK,MAAM,IAAI,KAAK;GAChB,SAAS;GACT,SAAS,YAAY,KAAK;GAC1B,OAAOH;EACV,EAAC;EACF,KAAK,UAAU,CAAC,MAAM,CAAC,EAAE;GAAE;GAAK;EAAO,EAAC;CAC3C;AACJ;;;;;;;;;;;;;;;;;;;;;;;AC/SD,MAAa,aAAa,CAACI,OAAK,cAAc;AAC1C,MAAK,MAAM,KAAKA,MAAI,SAAS,EAAE;EAC3B,MAAMC,UAAQ,EAAE;AAChB,OAAK,MAAM,YAAYA,QACnB,KAAI,UAAU,UAAU,EAAE,GAAG,CACzB,QAAO;CAElB;AACJ;;;;AAID,MAAa,YAAY,CAACD,UAAQ;CAE9B,IAAI,UAAU,CAAC,IAAI,CAAE;AACrB,MAAK,MAAM,KAAKA,MAAI,eAAe,CAC/B,KAAI,EAAE,KAAK,QAAQ,IACf,UAAU;AAGlB,QAAO,QAAQ;AAClB;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,oBAAoB,CAACA,OAAKC,SAAO,UAAU,mBAAmB;AACvE,MAAK,MAAM,KAAKD,MAAI,SAAS,EAAE;EAC3B,MAAM,SAAS,EAAE;AACjB,OAAK,MAAM,YAAY,OACnB,KAAI,QAAQ,UAAUC,QAAM,CACxB,QAAO;CAElB;AACJ;;;;ACnED,IAAa,kBAAb,MAA6B;CACzB;CACA;CACA;;;;;;CAMA,YAAY,UAAU,cAAc,UAAW,gBAAiB,UAAU,CAAE,GAAE;EAC1E,KAAK,UAAU;EACf,KAAK,UAAU;EACf,KAAK,MAAM,IAAI,IAAI;CACtB;;;;;;CAMD,IAAI,KAAK;AACL,SAAO,KAAK,IAAI,IAAI,IAAI;CAC3B;;;;;;;CAOD,YAAY,KAAKC,SAAO;EACpB,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI;AAChC,MAAI,CAAC,OACD,QAAO;AACX,OAAK,MAAM,KAAK,OACZ,KAAI,KAAK,QAAQ,GAAGA,QAAM,CACtB,QAAO;AAEf,SAAO;CACV;;;;;CAKD,cAAc;EACV,IAAI,IAAI,EAAE;EACV,MAAM,OAAO,CAAC,GAAG,KAAK,IAAI,MAAM,AAAC;EACjC,KAAK,MAAM,CAAC,MAAM;GACd,MAAM,IAAI,KAAK,IAAI,IAAI,EAAE;AACzB,OAAI,MAAM,OACN;GACJ,KAAK,IAAI,CAAC,EAAE,EAAE,EAAE,OAAO,IAAI,EAAE,KAAK,UAAU,EAAE,CAAC,IAAI,CAAC;EACvD,EAAC;AACF,SAAO;CACV;;;;;;;CAOD,MAAM,KAAK;EACP,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI;AAChC,MAAI,CAAC,OACD,QAAO;AACX,SAAO,OAAO;CACjB;;;;;;;CAOD,gBAAgBA,SAAO,KAAK,gBAAgB;EACxC,MAAM,QAAQ,kBAAkB,MAAMA,SAAO,GAAG;AAChD,MAAI,MACA,QAAO,MAAM;CACpB;;;;CAID,CAAC,cAAc;AACX,OAAK,MAAM,OAAO,KAAK,IAAI,MAAM,CAC7B,MAAK,MAAMA,WAAS,KAAK,IAAI,IAAI,IAAI,EACjC,MAAM,CAAC,KAAKA,OAAM;CAG7B;;;;CAID,CAAC,UAAU;AACP,OAAK,MAAM,CAAC,GAAG,EAAE,IAAI,KAAK,IAAI,SAAS,EACnC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;CAExB;;;;;;CAMD,CAAC,IAAI,KAAK;EACN,MAAM,IAAI,KAAK,IAAI,IAAI,IAAI;AAC3B,MAAI,CAAC,EACD;EACJ,OAAO,EAAE,QAAQ;CACpB;;;;CAID,CAAC,OAAO;EACJ,OAAO,KAAK,IAAI,MAAM;CACzB;;;;;CAKD,CAAC,aAAa;AACV,OAAK,MAAMC,aAAW,KAAK,KACvB,OAAOA,UAAQ;CAEtB;;;;;CAKD,CAAC,SAAS;AACN,OAAK,MAAMA,aAAW,KAAK,KACvB,MAAMA,UAAQ;CAErB;;;;CAID,CAAC,gBAAgB;AACb,OAAK,MAAMA,aAAW,KAAK,KACvB,MAAM,CAACA,UAAQ,IAAIA,UAAQ,GAAG,MAAO;CAE5C;;;;CAID,IAAI,aAAa;AACb,SAAO,KAAK,IAAI;CACnB;;;;CAID,IAAI,UAAU;AACV,SAAO,KAAK,IAAI,SAAS;CAC5B;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HD,IAAa,qBAAb,cAAwC,gBAAgB;CACpD,eAAe,KAAK,GAAG,QAAQ;EAC3B,MAAM,WAAW,KAAK,IAAI,IAAI,IAAI;AAClC,MAAI,aAAa,QACb,KAAK,IAAI,IAAI,KAAK,OAAO;OAGzB,KAAK,IAAI,IAAI,KAAK,CAAC,GAAG,UAAU,GAAG,MAAO,EAAC;CAElD;;;;;;;CAOD,UAAU,KAAK,QAAQ;EACnB,KAAK,IAAI,IAAI,KAAK,OAAO;CAC5B;;;;;;CAMD,SAAS,GAAG,QAAQ;AAChB,OAAK,MAAM,KAAK,QAAQ;GACpB,MAAM,MAAM,KAAK,QAAQ,EAAE;GAC3B,KAAK,eAAe,KAAK,EAAE;EAC9B;CACJ;;;;;;;CAOD,eAAe,KAAKC,SAAO;EACvB,MAAM,WAAW,KAAK,IAAI,IAAI,IAAI;AAClC,MAAI,aAAa,OACb,QAAO;EACX,MAAMC,YAAU,SAAS,OAAO,CAAC,kBAAkB,CAAC,KAAK,QAAQ,eAAeD,QAAM,CAAC;EACvF,KAAK,IAAI,IAAI,KAAKC,UAAQ;AAC1B,SAAOA,UAAQ,SAAS,SAAS;CACpC;;;;;;;;CAQD,cAAcD,SAAO;EACjB,IAAIE,QAAM;EACV,MAAMC,YAAU,CAAC,GAAG,KAAK,IAAI,SAAS,AAAC;AACvC,OAAK,MAAM,cAAcA,UACrB,MAAK,MAAM,UAAU,WAAW,GAC5B,KAAI,KAAK,QAAQ,QAAQH,QAAM,EAAE;GAC7BE,QAAM;GACN,KAAK,eAAe,WAAW,IAAIF,QAAM;EAC5C;AAGT,SAAOE;CACV;;;;;;CAMD,OAAO,KAAK;EACR,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI;AAChC,MAAI,CAAC,OACD,QAAO;AACX,MAAI,OAAO,WAAW,EAClB,QAAO;EACX,KAAK,IAAI,OAAO,IAAI;AACpB,SAAO;CACV;;;;CAID,QAAQ;EACJ,KAAK,IAAI,OAAO;CACnB;AACJ;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,kBAAkB,CAAC,UAAU,cAAc,UAAW,mBAAoB,IAAI,mBAAmB,SAAS;;;;;;;;;;ACzHvH,MAAM,WAAW,CAACE,OAAK,SAAS;CAC5B,MAAM,IAAI,IAAI,IAAIA,MAAI,SAAS;AAC/B,MAAK,MAAM,KAAK,MAAM;AAClB,MAAI,EAAE,OAAO,OACT,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;AAC7C,MAAI,EAAE,OAAO,OACT,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;EAC/C,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG;CACpB;AACD,QAAO;AACV;;;;;;;AAOD,MAAM,aAAa,CAACA,OAAK,SAAS;CAC9B,MAAM,IAAI,IAAI,IAAIA,MAAI,SAAS;AAC/B,MAAK,MAAM,KAAK,MAAM;AAClB,MAAI,EAAE,QAAQ,OACV,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;AAC7C,MAAI,EAAE,UAAU,OACZ,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;EAC/C,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM;CACxB;AACD,QAAO;AACV;;;;;;;;;;;;AAYD,MAAa,MAAM,CAACA,OAAK,QAAQA,MAAI,IAAI,IAAI;;;;;;;;;;;;;;;AAe7C,MAAa,MAAM,CAACA,OAAK,GAAG,SAAS;AACjC,KAAIA,UAAQ,OACR,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAChD,KAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,4BAA4B,CAAC;AAClD,KAAI,KAAK,WAAW,EAChB,QAAOA;CACX,MAAM,cAAc,KAAK;CACzB,MAAM,WAAW,OAAO,YAAY,QAChC,CAAC,SAAS,CAAC,IACX,OAAO,YAAY,UACf,CAAC,SAAS,CAAC;AACnB,QAAO,WACD,WAAWA,OAAK,KAAK,GACrB,SAASA,OAAK,KAAK;AAC5B;;;;;;;;AAQD,MAAa,MAAM,CAACA,OAAK,KAAKC,YAAU;CACpC,MAAM,IAAI,IAAI,IAAID,MAAI,SAAS;CAC/B,EAAE,IAAI,KAAKC,QAAM;AACjB,QAAO;AACV;;;;;;;AAOD,MAAa,MAAM,CAACD,OAAK,QAAQ;CAC7B,MAAM,IAAI,IAAI,IAAIA,MAAI,SAAS;CAC/B,EAAE,OAAO,IAAI;AACb,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtDD,MAAa,YAAY,CAAC,cAAc;AACpC,KAAI,cAAc,OACd,QAAO,UAAU,CAAE,EAAC;AACxB,KAAI,MAAM,QAAQ,UAAU,CACxB,QAAO,UAAU,oBAAI,IAAI,OAAO,GAAG,UAAU,CAAC;CAClD,MAAM,OAAO;AACb,QAAO;EACH,KAAK,CAAC,GAAG,eAAe;GACpB,MAAM,IAAI,IAAI,MAAM,GAAG,WAAW;AAClC,UAAO,UAAU,EAAE;EACtB;EACD,KAAK,CAAC,KAAKE,YAAU;GACjB,MAAM,IAAI,IAAI,MAAM,KAAKA,QAAM;AAC/B,UAAO,UAAU,EAAE;EACtB;EACD,KAAK,CAAC,QAAQ,KAAK,IAAI,IAAI;EAC3B,QAAQ,CAAC,QAAQ,UAAU,IAAI,MAAM,IAAI,CAAC;EAE1C,OAAO,MAAM,WAAW;EACxB,KAAK,CAAC,QAAQ,KAAK,IAAI,IAAI;EAC3B,SAAS,MAAM,KAAK,SAAS;EAC7B,QAAQ,MAAM,KAAK,QAAQ;EAC3B,SAAS,MAAM,KAAK,SAAS;CAChC;AACJ;;;;;;;;;;;;;;;;;;;;;;;AC/CD,MAAa,UAAU,CAAC,GAAG,SAAS;CAEhC,IAAI,IAAI,oBAAI,IAAI,OAAO,GAAG,KAAK;AAC/B,QAAO;EACH,KAAK,CAAC,GAAGC,WAAS;GACd,IAAI,IAAI,GAAG,GAAGA,OAAK;EACtB;EACD,QAAQ,CAAC,QAAQ;GACb,IAAI,IAAI,GAAG,IAAI;EAClB;EACD,OAAO,MAAM;GACT,IAAI,oBAAI,IAAI,MAAM;EACrB;EACD,KAAK,CAAC,KAAKC,YAAU;GACjB,IAAI,IAAI,GAAG,KAAKA,QAAM;EACzB;EACD,KAAK,CAAC,QAAQ,EAAE,IAAI,IAAI;EACxB,SAAS,MAAM,EAAE,SAAS;EAC1B,QAAQ,MAAM,EAAE,QAAQ;EACxB,SAAS,MAAM,EAAE,SAAS;EAC1B,KAAK,CAAC,QAAQ,IAAI,GAAG,IAAI;CAC5B;AACJ;;;;;;;ACrCD,IAAa,mBAAb,cAAsC,mBAAmB;CACrD,uBAAO,IAAI;CACX;CACA;CACA,YAAY,MAAM,OAAO,CAAE,GAAE;EACzB,OAAO;EACP,KAAK,OAAO;EACZ,KAAK,UAAU,KAAK,WAAW;CAClC;;;;CAID,IAAI,WAAW;AACX,SAAO,KAAK,KAAK;CACpB;;;;CAID,IAAI,aAAa;AACb,SAAO,KAAKC,KAAK;CACpB;;;;CAID,IAAI,YAAY;EACZ,IAAI,IAAI;AACR,OAAK,MAAM,KAAK,KAAKA,KAAK,QAAQ,EAC9B,IAAI,KAAK,IAAI,GAAG,KAAK,KAAK,MAAM,EAAE,CAAC;AAEvC,SAAO;CACV;CACD,cAAc;EACV,MAAM,OAAO,CAAC,GAAG,KAAKA,KAAK,MAAM,AAAC;EAClC,IAAI,IAAI,CAAC,MAAM,EAAE,KAAK,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;AACtC,OAAK,MAAM,KAAK,MAAM;GAClB,MAAM,IAAI,KAAKA,KAAK,IAAI,EAAE;AAC1B,OAAI,MAAM,QACN,KAAK,CAAC,GAAG,EAAE,EAAE,gBAAgB,CAAC;QAE7B;IACD,MAAM,UAAU,KAAK,KAAK,QAAQ,EAAE;AACpC,QAAI,YAAY,QACZ,KAAK,CAAC,GAAG,EAAE,EAAE,EAAE,EAAE,KAAK,KAAK,MAAM,EAAE,CAAC,IAAI,EAAE,KAAK,UAAU,QAAQ,CAAC,IAAI,CAAC;GAE9E;EACJ;AAED,SAAO;CACV;CACD,IAAI,UAAU;AACV,SAAO,KAAKA,KAAK,SAAS;CAC7B;CACD,QAAQ;EACJ,KAAKA,KAAK,OAAO;EACjB,MAAM,UAAU,CAAC,KAAK,CAAC,EAAE,KAAK;CACjC;CACD,eAAe,KAAK,GAAG,QAAQ;EAC3B,MAAMC,QAAM,KAAKD,KAAK,IAAI,IAAI;AAC9B,MAAIC,UAAQ,QAAW;GACnB,KAAKD,KAAK,IAAI,KAAK,KAAK,KAAK,eAAe,QAAW,OAAO,CAAC;GAC/D,MAAM,UAAU,CAAC,QAAQ,CAAC,EAAE,EAAO,IAAK,EAAC;GACzC,MAAM,UAAU,CAAC,WAAW,CAAC,EAAE,EAAU,OAAQ,EAAC;EACrD,OACI;GACD,KAAKA,KAAK,IAAI,KAAK,KAAK,KAAK,eAAeC,OAAK,OAAO,CAAC;GACzD,MAAM,UAAU,CAAC,WAAW,CAAC,EAAE,EAAU,OAAQ,EAAC;EACrD;CACJ;CACD,IAAI,KAAK,QAAQ;EACb,KAAK,eAAe,KAAK,GAAG,OAAO;AACnC,SAAO;CACV;CACD,SAAS,GAAG,QAAQ;AAChB,OAAK,MAAM,KAAK,QACZ,KAAK,eAAe,KAAK,QAAQ,EAAE,EAAE,EAAE;CAC9C;CACD,YAAY,KAAKC,SAAO,IAAI;EACxB,MAAM,IAAI,KAAKF,KAAK,IAAI,IAAI;AAC5B,MAAI,MAAM,OACN,QAAO;AACX,SAAO,KAAK,KAAK,IAAI,GAAGE,SAAO,GAAG;CACrC;CACD,IAAI,KAAK;AACL,SAAO,KAAKF,KAAK,IAAI,IAAI;CAC5B;CACD,eAAe,KAAKE,SAAO;EACvB,MAAM,IAAI,KAAKF,KAAK,IAAI,IAAI;AAC5B,MAAI,MAAM,OACN,QAAO;AACX,SAAO,KAAK,sBAAsB,GAAG,KAAKE,QAAM;CACnD;CACD,sBAAsBC,OAAK,KAAKD,SAAO;EACnC,MAAM,WAAW,KAAK,KAAK,MAAMC,MAAI;EACrC,MAAM,WAAW,KAAK,KAAK,QAAQA,OAAKD,QAAM;EAC9C,MAAM,YAAY,SAAS;EAC3B,KAAKF,KAAK,IAAI,KAAK,KAAK,KAAK,eAAe,QAAW,SAAS,CAAC;AACjE,SAAO,WAAW;CACrB;CACD,cAAcE,SAAO;EACjB,IAAI,YAAY;EAChB,CAAC,GAAG,KAAKF,KAAK,MAAM,AAAC,EAAC,OAAO,CAAC,QAAQ;GAClC,MAAM,IAAI,KAAKA,KAAK,IAAI,IAAI;AAC5B,OAAI,CAAC,EACD,OAAM,IAAI,MAAM,CAAC,8BAA8B,CAAC;AACpD,OAAI,KAAK,sBAAsB,GAAG,KAAKE,QAAM,EAAE;IAC3C,YAAY;AAEZ,QAAI,KAAK,MAAM,IAAI,KAAK,GACpB,KAAK,OAAO,IAAI;GACvB;EACJ,EAAC;AACF,SAAO;CACV;CACD,OAAO,KAAK;EACR,MAAM,IAAI,KAAKF,KAAK,IAAI,IAAI;AAC5B,MAAI,MAAM,OACN,QAAO;EACX,KAAKA,KAAK,OAAO,IAAI;EACrB,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE,EAAO,IAAK,EAAC;AACzC,SAAO;CACV;CACD,gBAAgBE,SAAO,KAAK,gBAAgB;EACxC,MAAM,OAAO,CAAC,GAAG,KAAKF,KAAK,MAAM,AAAC;EAClC,MAAM,QAAQ,KAAK,KAAK,CAAC,QAAQ;GAC7B,MAAM,IAAI,KAAKA,KAAK,IAAI,IAAI;AAC5B,OAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,8BAA8B,CAAC;GACpD,MAAM,IAAI,KAAK,KAAK,IAAI,GAAGE,SAAO,GAAG;AACrC,UAAO;EACV,EAAC;AACF,SAAO;CACV;CACD,MAAM,KAAK;EACP,MAAM,QAAQ,KAAKF,KAAK,IAAI,IAAI;AAChC,MAAI,UAAU,OACV,QAAO;AACX,SAAO,KAAK,KAAK,MAAM,MAAM;CAChC;;;;;CAKD,CAAC,IAAI,KAAK;EACN,MAAM,IAAI,KAAKA,KAAK,IAAI,IAAI;AAC5B,MAAI,MAAM,OACN;EACJ,OAAO,KAAK,KAAK,SAAS,EAAE;CAC/B;;;;;;;CAOD,CAAC,UAAU,KAAK;EACZ,MAAM,IAAI,KAAKA,KAAK,IAAI,IAAI;AAC5B,MAAI,MAAM,OACN;EACJ,OAAO,KAAK,KAAK,SAAS,EAAE;CAC/B;CACD,UAAU,KAAK;AACX,SAAO,KAAKA,KAAK,IAAI,IAAI;CAC5B;CACD,CAAC,OAAO;EACJ,OAAO,KAAKA,KAAK,MAAM;CAE1B;CACD,CAAC,cAAc;AACX,OAAK,MAAM,SAAS,KAAKA,KAAK,SAAS,CACnC,MAAK,MAAM,KAAK,KAAK,KAAK,SAAS,MAAM,GAAG,EACxC,MAAM,CAAC,MAAM,IAAI,CAAE;CAG9B;CACD,CAAC,aAAa;AACV,OAAK,MAAM,SAAS,KAAKA,KAAK,SAAS,EACnC,OAAO,KAAK,KAAK,SAAS,MAAM,GAAG;CAE1C;CACD,CAAC,UAAU;AACP,OAAK,MAAM,CAAC,GAAG,EAAE,IAAI,KAAKA,KAAK,SAAS,EAAE;GACtC,MAAM,YAAY,CAAC,GAAG,KAAK,KAAK,SAAS,EAAE,AAAC;GAC5C,MAAM,CAAC,GAAG,SAAU;EACvB;CACJ;CACD,CAAC,gBAAgB;AACb,OAAK,MAAM,OAAO,KAAK,MAAM,EACzB,MAAM,CAAC,KAAK,KAAK,MAAM,IAAI,AAAC;CAEnC;CACD,MAAM,OAAO;AACT,OAAK,MAAM,OAAO,MAAM,MAAM,EAAE;GAC5B,MAAM,OAAO,MAAM,IAAI,IAAI;GAC3B,KAAK,eAAe,KAAK,GAAG,KAAK;EACpC;CACJ;CACD,IAAI,OAAO;AACP,SAAO,KAAKA,KAAK;CACpB;CACD,KAAK,OAAO,eAAe;AACvB,SAAO,KAAKA,KAAK,OAAO;CAC3B;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjLD,MAAa,eAAe,CAAC,YAAY;CACrC,MAAM,OAAO,SAAS,QAAQ;CAC9B,MAAM,WAAW,CAAC,GAAG,MAAM,KAAK,EAAE,KAAK,KAAK,EAAE;CAC9C,MAAM,IAAI;EACN,IAAI,OAAO;AACP,UAAO,CAAC,GAAG,CAAC;EACf;EACD,UAAU,CAAC,WAAW,OAAO,QAAQ;EACrC,gBAAgB,CAAC,MAAM,WAAWI,SAAY,MAAM,MAAM,CAAC,IAAI,CAAC,EAAE,GAAG,OAAO;EAC5E,OAAO,CAAC,WAAW,OAAO;EAC1B,MAAM,CAAC,QAAQ,cAAcC,UAAa,QAAQ,UAAU;EAC5D,QAAQ,CAAC,QAAQ,cAAcC,aAAgB,QAAQ,UAAU;EACjE,SAAS,CAAC,WAAWC,QAAW,OAAO;EACvC,KAAK,CAAC,QAAQC,YAAUC,YAAe,QAAQD,SAAO,SAAS;EAC/D,SAAS,CAAC,QAAQA,YAAU,QAAQD,QAAW,OAAO,EAAEC,SAAO,SAAS;CAC3E;CACD,MAAM,IAAI,IAAI,iBAAiB,GAAG;AAClC,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;AC3BD,MAAa,oBAAoB,CAAC,YAAY;CAC1C,MAAM,WAAW;CACjB,MAAM,IAAI;EACN,IAAI,OAAO;AACP,UAAO,CAAC,QAAQ,CAAC;EACpB;EACD,gBAAgB,CAAC,aAAa,WAAW;GACrC,IAAI,KAAK,eAAe,IAAI,cAAc,QAAQ;AAClD,QAAK,MAAM,KAAK,QACZ,KAAK,GAAG,IAAI,EAAE;AAElB,UAAO;EACV;EACD,OAAO,CAAC,WAAW,OAAO;EAC1B,MAAM,CAAC,QAAQ,cAAc,OAAO,KAAK,UAAU;EACnD,QAAQ,CAAC,QAAQ,cAAc,OAAO,OAAO,UAAU;EACvD,SAAS,CAAC,WAAW;EACrB,UAAU,CAAC,WAAW,OAAO,QAAQ;EACrC,KAAK,CAAC,QAAQE,YAAU,OAAO,KAAK,CAAC,MAAM,SAAS,GAAGA,QAAM,CAAC,KAAK;EACnE,SAAS,CAAC,QAAQA,YAAU,OAAO,OAAO,CAAC,MAAM,CAAC,SAAS,GAAGA,QAAM,CAAC;CACxE;AACD,QAAO,IAAI,iBAAiB,GAAG;AAClC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPD,IAAa,YAAb,cAA+B,IAAI;CAC/B;CACA,YAAY,eAAe,GAAG;EAC1B,OAAO;EACP,KAAK,eAAe;CACvB;CACD,IAAI,KAAK;EACL,MAAM,IAAI,MAAM,IAAI,IAAI;AACxB,MAAI,MAAM,OACN,QAAO,KAAK;AAChB,SAAO;CACV;CACD,MAAM,KAAK;EACP,MAAM,IAAI,KAAK,KAAK,aAAa;AACjC,SAAO,KAAK;CACf;CACD,SAAS,KAAK,QAAQ;EAClB,MAAM,IAAI,MAAM,IAAI,IAAI;EACxB,IAAIC,UAAQ,KAAK,KAAK;EACtBA,WAAS;EACT,MAAM,IAAI,KAAKA,QAAM;AACrB,SAAOA;CACV;CACD,IAAI,KAAK,SAAS,GAAG;EACjB,MAAM,IAAI,MAAM,IAAI,IAAI;EACxB,IAAIA,UAAQ,KAAK,KAAK;EACtBA,WAAS;EACT,MAAM,IAAI,KAAKA,QAAM;AACrB,SAAOA;CACV;CACD,SAAS,KAAK,SAAS,GAAG;EACtB,MAAM,IAAI,MAAM,IAAI,IAAI;EACxB,IAAIA,UAAQ,KAAK,KAAK;EACtBA,WAAS;EACT,MAAM,IAAI,KAAKA,QAAM;AACrB,SAAOA;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CD,MAAa,iBAAiB,CAAC,UAAU,CAAE,MAAK;CAc5C,MAAM,kBAAkB,QAAQ;CAChC,MAAM,mBAAmB,OAAO,oBAAoB,CAAC,SAAS,CAAC,GAAG,iBAAiB,CAAC,GAAG,MAAM,gBAAgB,EAAE,KAAK,gBAAgB,EAAE;CACtI,MAAM,WAAW,QAAQ,YAAY;CACrC,MAAM,IAAI;EACN,IAAI,OAAO;AACP,UAAO,CAAC,KAAK,CAAC;EACjB;EACD,gBAAgB,CAAC,aAAa,WAAW;AACrC,OAAI,gBAAgB,OAChB,QAAO,CAAC,GAAG,MAAO;AACtB,UAAO,CAAC,GAAG,aAAa,GAAG,MAAO;EACrC;EACD,UAAU,CAAC,WAAW,OAAO,QAAQ;EACrC,OAAO,CAAC,WAAW,OAAO;EAC1B,MAAM,CAAC,QAAQ,cAAc,OAAO,KAAK,OAAK,UAAU,EAAE,CAAC;EAC3D,QAAQ,CAAC,QAAQ,cAAc,OAAO,OAAO,OAAK,UAAU,EAAE,CAAC;EAC/D,SAAS,CAAC,WAAW;EACrB,KAAK,CAAC,QAAQC,YAAU,OAAO,KAAK,CAAC,MAAM,SAAS,GAAGA,QAAM,CAAC;EAC9D,SAAS,CAAC,QAAQA,YAAU,OAAO,OAAO,CAAC,MAAM,CAAC,SAAS,GAAGA,QAAM,CAAC;CAExE;CACD,MAAM,IAAI,IAAI,iBAAiB,GAAG;AAClC,QAAO;AACV;;;;;;;AC/DD,IAAa,cAAb,MAAa,oBAAoB,gBAAgB;CAC7C,eAAe,KAAK,GAAG,QAAQ;AAG3B,SAAO,KAAK,SAAS,CAAC,CAAC,KAAK,MAAO,CAAC,EAAC;CACxC;CACD,SAAS,GAAG,QAAQ;EAChB,MAAM,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,QAAQ,EAAE,EAAE,CAAE,EAAC;AACzD,SAAO,KAAK,SAAS,UAAU;CAClC;CAED,SAASC,WAAS;EAEd,MAAM,YAAY,IAAI,IAAI,CAAC,GAAG,KAAK,IAAI,SAAS,AAAC,EAAC,IAAI,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,GAAG,EAAE,EAAG,CAAC,EAAC;AAC/E,OAAK,MAAM,CAAC,KAAK,KAAK,IAAIA,WAAS;GAE/B,MAAM,eAAe,UAAU,IAAI,IAAI;AACvC,OAAI,OAAO,iBAAiB,CAAC,SAAS,CAAC,EAGnC,UAAU,IAAI,KAAK,KAAK;QAIxB,aAAa,KAAK,GAAG,KAAK;EAEjC;AACD,SAAO,IAAI,YAAY,KAAK,SAAS,KAAK,SAAS,CAAC,GAAG,UAAU,SAAS,AAAC;CAC9E;CACD,QAAQ;AACJ,SAAO,IAAI,YAAY,KAAK,SAAS,KAAK;CAC7C;CACD,eAAe,MAAM,QAAQ;AACzB,QAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;CAC5C;CACD,cAAcC,SAAO,IAAI;EACrB,MAAMD,YAAU,CAAC,GAAG,KAAK,IAAI,SAAS,AAAC;EACvC,MAAM,aAAa,MAAM,KAAK;EAC9B,MAAM,IAAIA,UAAQ,IAAI,CAAC,UAAU;GAC7B,MAAM,MAAM,MAAM;GAClB,MAAM,SAAS,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,WAAW,IAAIC,QAAM,CAAC;AAC9D,UAAO,CAAC,KAAK,MAAO;EACvB,EAAC;AACF,SAAO,IAAI,YAAY,KAAK,SAAS,KAAK,SAAS;CACtD;CACD,OAAO,KAAK;EACR,MAAMD,YAAU,CAAC,GAAG,KAAK,IAAI,SAAS,AAAC,EAAC,OAAO,CAAC,MAAM,EAAE,OAAO,IAAI;AACnE,SAAO,IAAI,YAAY,KAAK,SAAS,KAAK,SAASA;CACtD;AACJ;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,WAAW,CAAC,UAAU,cAAc,UAAW,mBAAoB,IAAI,YAAY,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AErEzG,IAAa,QAAb,MAAmB;CACf,OAAO,CAAE;CACT,YAAY,CAAE;CACd,YAAY,CAAE;;;;CAId,kBAAkB;;;;;;;;;CASlB,oBAAoB,OAAO;AACvB,OAAK,MAAM,CAAC,OAAO,EAAE,IAAI,KAAK,UAAU,SAAS,CAC7C,KAAI,MAAM,MACN,QAAO;CAElB;;;;;;;;;CASD,iBAAiB,OAAO;AACpB,OAAK,MAAM,CAAC,OAAO,EAAE,IAAI,KAAK,UAAU,SAAS,CAC7C,KAAI,MAAM,MACN,QAAO;CAElB;;;;CAID,QAAQ;EACJ,QAAQ,MAAM,CAAC,GAAG,KAAK,sBAAsB,AAAC,EAAC;CAClD;;;;;;;;;;;;;;;;;;;;;;CAsBD,UAAU;EACN,MAAM,IAAI,CAAE;AACZ,OAAK,MAAM,OAAO,KAAK,KACnB,KAAI,QAAQ,QACR,EAAE,KAAK,CAAE,EAAC;OAEV,EAAE,KAAK,CAAC,GAAG,GAAI,EAAC;AAExB,SAAO;CACV;;;;CAID,IAAI,WAAW;AACX,SAAO,KAAK,KAAK;CACpB;;;;CAID,IAAI,cAAc;AACd,SAAO,KAAK;CAGf;;;;;CAKD,CAAC,uBAAuB;AACpB,OAAK,IAAI,QAAQ,GAAG,QAAQ,KAAK,KAAK,QAAQ,SAAS;GACnD,MAAM,cAAc,KAAK,uBAAuB,MAAM;GACtD,MAAM;EACT;CACJ;;;;;CAKD,CAAC,sBAAsB;AACnB,OAAK,IAAI,QAAQ,GAAG,QAAQ,KAAK,KAAK,QAAQ,SAAS;GACnD,MAAM,cAAc,KAAK,sBAAsB,MAAM;GACrD,MAAM;EACT;CACJ;;;;;CAKD,aAAa,GAAG,QAAQ;EACpB,KAAK,YAAY;CACpB;;;;;;;CAOD,YAAY,aAAa,OAAO;EAC5B,KAAK,UAAU,eAAe;CACjC;;;;;CAKD,UAAU,GAAG,QAAQ;EACjB,KAAK,YAAY;CACpB;;;;;;;CAOD,SAAS,UAAU,OAAO;EACtB,KAAK,UAAU,YAAY;CAC9B;;;;;CAKD,UAAU,GAAG,MAAM;EACf,KAAK,kBAAkB,KAAK,IAAI,KAAK,iBAAiB,KAAK,OAAO;EAClE,KAAK,KAAK,KAAK,KAAK;AACpB,SAAO;CACV;;;;;;CAMD,sBAAsB,UAAU;EAC5B,MAAM,MAAM,KAAK,KAAK,GAAG,SAAS;AAClC,MAAI,QAAQ,OACR,QAAO;AACX,SAAO,IAAI,IAAI,CAACE,SAAO,UAAU,CAAC,KAAK,UAAU,GAAG,MAAM,EAAEA,OAAM,EAAC;CACtE;;;;;;;;;;;;CAYD,uBAAuB,UAAU;EAC7B,MAAM,MAAM,KAAK,KAAK,GAAG,SAAS;AAClC,MAAI,QAAQ,OACR,QAAO;EACX,MAAM,SAAS,CAAE;AACjB,OAAK,IAAI,QAAQ,GAAG,QAAQ,KAAK,UAAU,QAAQ,SAAS;GACxD,MAAM,QAAQ,KAAK,UAAU,GAAG,MAAM,IAAI,MAAM,UAAU;GAC1D,OAAO,SAAS,IAAI;EACvB;AACD,SAAO;CACV;;;;;;CAMD,mBAAmB,KAAK;EACpB,MAAM,QAAQ,OAAO,QAAQ,CAAC,MAAM,CAAC,GAAG,MAAM,KAAK,iBAAiB,IAAI;AAExE,MAAI,UAAU,OACV,QAAO;GAAE,SAAS;GAAO,OAAO,CAAC,kBAAkB,CAAC;EAAE;AAE1D,MAAI,QAAQ,EACR,QAAO;GAAE,SAAS;GAAO,OAAO,CAAC,iBAAiB,CAAC;EAAE;AAEzD,MAAI,QAAQ,KAAK,KAAK,OAClB,QAAO;GAAE,SAAS;GAAM,OAAO,KAAK,KAAK;EAAQ;EAErD,MAAM,SAAS,CAAE;EACjB,KAAK,KAAK,SAAS;AACnB,SAAO;GAAE,SAAS;GAAM,OAAO;EAAQ;CAC1C;;;;;;CAMD,IAAI,KAAK;EACL,MAAM,IAAI,KAAKC,WAAW,IAAI;AAC9B,MAAI,cAAc,EAAE,CAChB,OAAM,IAAI,MAAM,EAAE;AAEtB,SAAO,CAAC,GAAG,EAAE,KAAM;CACtB;;;;;;;;CAQD,IAAI,KAAK,QAAQD,SAAO;EACpB,MAAM,SAAS,KAAKE,mBAAmB,IAAI;AAC3C,MAAI,cAAc,OAAO,CACrB,OAAM,IAAI,MAAM,OAAO;EAE3B,MAAM,IAAI,OAAO;EACjB,MAAM,cAAc,OAAO,WAAW,CAAC,MAAM,CAAC,GAAG,SAAS,KAAK,oBAAoB,OAAO;AAC1F,MAAI,OAAO,gBAAgB,CAAC,SAAS,CAAC,CAClC,OAAM,IAAI,MAAM,CAAC,cAAc,EAAE,OAAO,yBAAyB,CAAC;AACtE,MAAI,cAAc,EACd,OAAM,IAAI,MAAM,CAAC,qCAAqC,CAAC;EAE3D,EAAE,eAAeF;CACpB;;;;;;;;CAQD,IAAI,KAAK,QAAQ;EACb,MAAM,OAAO,KAAKC,WAAW,IAAI;AACjC,MAAI,cAAc,KAAK,CACnB,OAAM,IAAI,MAAM,KAAK;EACzB,MAAM,OAAO,KAAKE,cAAc,KAAK,OAAO,OAAO;AACnD,MAAI,cAAc,KAAK,CACnB,OAAM,IAAI,MAAM,KAAK;AACzB,SAAO,KAAK,MAAM;CACrB;CACD,WAAW,KAAK;EACZ,IAAI,QAAQ;AACZ,MAAI,OAAO,QAAQ,CAAC,MAAM,CAAC,EACvB,QAAQ;OAEP;GACD,QAAQ,KAAK,iBAAiB,IAAI;AAClC,OAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzB,QAAO;IAAE,OAAO,CAAC,kBAAkB,CAAC;IAAE,SAAS;GAAO;EAC7D;AACD,MAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzB,QAAO;GAAE,OAAO,CAAC,WAAW,CAAC;GAAE,SAAS;EAAO;AACnD,MAAI,QAAQ,KAAK,SAAS,KAAK,KAAK,OAChC,QAAO;GAAE,OAAO,CAAC,sBAAsB,CAAC;GAAE,SAAS;EAAO;AAC9D,SAAO;GAAE,SAAS;GAAM,OAAO,KAAK,KAAK;EAAQ;CACpD;CACD,cAAc,KAAK,QAAQ;EACvB,MAAM,WAAW,OAAO,WAAW,CAAC,MAAM,CAAC,GAAG,SAAS,KAAK,oBAAoB,OAAO;AACvF,MAAI,OAAO,aAAa,CAAC,MAAM,CAAC,CAC5B,QAAO;GAAE,SAAS;GAAO,OAAO,CAAC,kBAAkB,CAAC;EAAE;AAC1D,MAAI,WAAW,KAAK,YAAY,IAAI,OAChC,QAAO;GAAE,SAAS;GAAO,OAAO,CAAC,sBAAsB,CAAC;EAAE;AAC9D,SAAO;GACH,SAAS;GAAM,OAAO;IAAE,OAAO;IAAU,OAAO,IAAI;GAAW;EAClE;CACJ;;;;;;;;;;;CAWD,OAAO,KAAKH,SAAO,QAAQ;EAEvB,MAAM,YAAY,KAAKE,mBAAmB,IAAI;AAC9C,MAAI,cAAc,UAAU,CACxB,OAAM,IAAI,MAAM,UAAU;EAE9B,MAAM,IAAI,UAAU;EACpB,MAAM,QAAQ,OAAO,WAAW,CAAC,MAAM,CAAC,GAAG,SAAS,KAAK;AACzD,OAAK,IAAI,eAAe,GAAG,eAAe,OAAO,gBAC7C,EAAE,gBAAgBF;AAEtB,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClSD,MAAaI,iBAAe,CAAC,OAAO;AAChC,QAAO;EACH;EACA,KAAK,CAAE;CACV;AACJ;;;;;;;;;;;;AAYD,SAAgB,OAAOC,SAAO,KAAK;CAC/B,YAAY,UAAUA,QAAM,CAAC;AAC7B,QAAOA,QAAM,SAAS,IAAI,IAAI;AACjC;;;;;;;;;;;;;AAaD,SAAgB,IAAIA,SAAO,KAAK;CAC5B,YAAY,UAAUA,QAAM,CAAC;CAC7B,YAAY,WAAW,KAAK,CAAC,SAAS,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;AAChD,QAAOA,QAAM,SAAS,IAAI,IAAI;AACjC;;;;;;AAaD,SAAgBC,oBAAkBD,SAAO;CACrC,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,IAAI,CAAC,GAAGA,QAAM,SAAS,QAAQ,AAAC;CAEtC,MAAM,QAAQ,IAAI;CAClB,MAAM,aAAa,GAAG,EAAE,IAAI,QAAM,GAAG,GAAG,CAAC;CACzC,MAAM,UAAU,GAAG,EAAE,IAAI,QAAM,GAAG,GAAG,CAAC;AAMtC,MAAK,IAAI,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;EAE/B,MAAM,OAAO,GAAG,OAAO,EAAE,OAAO;EAChC,MAAM,KAAK,EAAE;AAEb,OAAK,MAAM,CAAC,GAAG,GAAG,IAAI,EAAE,SAAS,CAC7B,KAAI,GAAG,IAAI,KAAK,OAAK,EAAE,OAAO,GAAG,GAAG,EAEhC,MAAM,IAAI,GAAG,GAAG,KAAK;CAGhC;AACD,QAAO;AACV;;;;;;AAMD,MAAaE,cAAY,CAACF,YAAU;CAChC,MAAM,QAAQG,oBAAkBH,QAAM;AACtC,QAAO,MAAM,KAAK,CAAC,EAAE,CAAC,CAAC;AAC1B;;;;;;AAMD,MAAMG,sBAAoB,CAACH,YAAU;CACjC,MAAM,IAAI,CAAE;CACZ,MAAMI,aAAY,CAAC,QAAQ,CAAC,IAAIJ,UAASA,QAAM,SAAS,QAAQ,GAAGA;AACnE,MAAK,MAAM,KAAKI,YAAU;EAEtB,MAAM,MAAM,gBAAgB,EAAE;EAC9B,EAAE,KAAK,GAAG,IAAI,IAAI,UAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;CACzC;AACD,QAAO;AACV;;;;;;;AAOD,MAAa,WAAW,CAACJ,SAAO,SAAS;AACrC,KAAI,KAAK,WAAW,OAChB,QAAO,KAAK;AAChB,QAAO;AACV;;;;;AAKD,UAAiB,MAAMA,SAAO;CAC1B,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAMI,aAAW,CAAC,GAAGJ,QAAM,SAAS,QAAQ,AAAC;AAC7C,MAAK,MAAM,UAAUI,WACjB,MAAK,MAAM,QAAQ,OAAO,KACtB,MAAM;AAGjB;;;;;AAKD,UAAiB,SAASJ,SAAO;CAC7B,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAMI,aAAW,CAAC,GAAGJ,QAAM,SAAS,QAAQ,AAAC;AAC7C,MAAK,MAAM,UAAUI,YACjB,MAAM;AAEb;AACD,SAAS,UAAU,GAAG,gBAAgB,CAAC,KAAK,CAAC,EAAE;AAC3C,KAAI,MAAM,OACN,QAAO;EAAE,SAAS;EAAO,OAAO,CAAC,OAAO,EAAE,cAAc,8BAA8B,CAAC;CAAE;AAC7F,KAAI,MAAM,KACN,QAAO;EAAE,SAAS;EAAO,OAAO,CAAC,OAAO,EAAE,cAAc,yBAAyB,CAAC;CAAE;AACxF,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EACrB;MAAI,EAAE,CAAC,QAAQ,CAAC,IAAI,GAChB,QAAO;GACH,SAAS;GAAO,OAAO,CAAC,OAAO,EAAE,cAAc,8CAA8C,CAAC;EACjG;CAAC,MAGN,QAAO;EAAE,SAAS;EAAO,OAAO,CAAC,OAAO,EAAE,cAAc,UAAU,EAAE,OAAO,EAAE,2BAA2B,CAAC;CAAE;AAE/G,QAAO;EAAE,SAAS;EAAM,OAAO;CAAG;AACrC;;;;;;;AAYD,UAAiBC,mBAAiBL,SAAO,SAAS;CAC9C,YAAY,UAAUA,QAAM,CAAC;AAC7B,KAAI,YAAY,OACZ;CACJ,MAAM,SAAS,OAAO,YAAY,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,QAAQ,GAAG;AAC3E,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK,UAAU,QAAQ,EAAE;AACjE,MAAK,MAAM,QAAQ,OAAO,KAAK;EAC3B,MAAM,QAAQA,QAAM,SAAS,IAAI,KAAK,GAAG;AACzC,MAAI,UAAU,OACV,OAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,KAAK,IAAI;EACvD,MAAM;CACT;AACJ;;;;;;;;;;AAUD,MAAa,eAAe,CAAC,QAAQ,kBAAkB;AACnD,KAAI,WAAW,OACX,QAAO;CACX,MAAM,QAAQ,OAAO,kBAAkB,CAAC,MAAM,CAAC,GAAG,gBAAgB,cAAc;AAChF,QAAO,OAAO,IAAI,KAAK,UAAQ,KAAK,OAAO,MAAM;AACpD;;;;;;;AAOD,MAAa,YAAY,CAACA,SAAO,WAAW;CACxC,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,UAAU,OAAO,WAAW,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,OAAO,GAAG;AAC1E,KAAI,YAAY,OACZ,QAAO;AACX,QAAO,QAAQ,IAAI,WAAW;AACjC;;;;;;;;;AASD,MAAa,cAAc,CAACA,SAAO,QAAQ,GAAG,kBAAkB;CAC5D,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,UAAUM,gBAAcN,SAAO,OAAO;CAC5C,MAAM,OAAO,cAAc,IAAI,OAAKM,gBAAcN,SAAO,EAAE,CAAC;AAC5D,KAAI,KAAK,WAAW,QAAQ,IAAI,OAE5B,QAAO;AAEX,MAAK,MAAM,OAAO,KAEd,KAAI,CAAC,OAAOA,SAAO,SAAS,IAAI,CAE5B,QAAO;AAGf,QAAO;AACV;;;;;;;;AAQD,MAAa,SAAS,CAACA,SAAO,QAAQ,kBAAkB;CACpD,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,UAAUM,gBAAcN,SAAO,OAAO;CAC5C,MAAM,QAAQ,OAAO,kBAAkB,CAAC,MAAM,CAAC,GAAG,gBAAgB,cAAc;AAChF,QAAO,QAAQ,IAAI,KAAK,UAAQ,KAAK,OAAO,MAAM;AACrD;;;;;;;AAaD,MAAaO,gBAAc,CAACP,SAAO,OAAO;CACtC,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,IAAIA,QAAM,SAAS,IAAI,GAAG;AAChC,KAAI,MAAM,OACN,QAAO;EAAE;EAAO,QAAQ;CAAG;CAC/B,MAAM,KAAKD,eAAa,GAAG;CAC3B,MAAM,KAAKS,oBAAkBR,SAAO,GAAG;AACvC,QAAO;EAAE,OAAO;EAAI,QAAQ;CAAI;AACnC;;;;;;;AAOD,MAAa,YAAY,CAACA,SAAO,OAAO;CACpC,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,IAAIA,QAAM,SAAS,IAAI,GAAG;AAChC,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,GAAG,oBAAoB,CAAC;AACvD,QAAO;AACV;;;;;;;AAOD,MAAaQ,sBAAoB,CAACR,SAAO,WAAW;CAChD,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,KAAK;EACP,GAAGA;EACH,UAAUA,QAAM,SAAS,IAAI,OAAO,IAAI,OAAO;CAClD;AACD,QAAO;AACV;;;;;;;AAOD,MAAa,kBAAkB,CAACA,SAAO,SAAS;AAC5C,KAAI,KAAK,WAAW,OAChB,QAAO,KAAK;AAChB,QAAO;AACV;;;;;;;;;;AAUD,SAAgB,WAAWA,SAAO,MAAMS,MAAI;CACxC,YAAY,UAAUT,QAAM,CAAC;CAC7B,MAAM,QAAQM,gBAAcN,SAAO,KAAK;CACxC,MAAM,MAAMM,gBAAcN,SAAOS,KAAG;AACpC,QAAO,OAAOT,SAAO,OAAO,IAAI,GAAGQ,oBAAkBR,SAAO;EACxD,GAAG;EACH,KAAK,MAAM,IAAI,OAAO,OAAK,EAAE,OAAO,IAAI,GAAG;CAC9C,EAAC,GAAGA;AACR;;;;;;;;;;AAUD,SAAgBU,YAAUV,SAAO,MAAMS,MAAI,QAAQ;CAC/C,YAAY,UAAUT,QAAM,CAAC;CAC7B,MAAM,aAAaO,cAAYP,SAAO,KAAK;CAC3CA,UAAQ,WAAW;CACnB,MAAM,WAAWO,cAAYP,SAAOS,KAAG;CACvCT,UAAQ,SAAS;CACjB,MAAM,OAAO;EACT,IAAIS;EACJ;CACH;AACD,KAAI,CAAC,OAAOT,SAAO,WAAW,QAAQ,SAAS,OAAO,EAClDA,UAAQQ,oBAAkBR,SAAO;EAC7B,GAAG,WAAW;EAEd,KAAK,CAAC,GAAG,WAAW,OAAO,KAAK,IAAK;CACxC,EAAC;AAEN,QAAO;EAAE;EAAO;CAAM;AACzB;;;;;;;;;;;;AAYD,SAAgBW,UAAQX,SAAO,SAAS;AACpC,KAAI,OAAOA,YAAU,CAAC,MAAM,CAAC,CACzB,OAAM,IAAI,UAAU,CAAC,6DAA6D,EAAE,OAAOA,SAAO;AACtG,KAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC3B,OAAM,IAAI,UAAU,CAAC,8DAA8D,EAAE,OAAO,SAAS;CACzG,MAAM,SAASY,mBAAiBZ,SAAO,QAAQ;AAC/C,QAAO,OAAO;AACjB;;;;;;;;;;;;AAYD,SAAgBY,mBAAiBZ,SAAO,SAAS;CAC7C,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,EAAE,UAAI,QAAQ,MAAM,GAAG;CAC7B,MAAM,OAAO,QAAQ,QAAQ;CAC7B,MAAM,SAAS,MAAM,QAAQS,KAAG,GAAGA,OAAK,CAACA,IAAG;CAC5C,MAAMI,UAAQ,CAAE;AAEhB,MAAK,MAAM,YAAY,QAAQ;EAC3B,MAAM,SAASH,YAAUV,SAAO,MAAM,UAAU,OAAO;EACvDA,UAAQ,OAAO;EACfa,QAAM,KAAK,OAAO,KAAK;CAC1B;AACD,KAAI,CAAC,KACD,QAAO;EAAE;EAAO;CAAO;AAG3B,MAAK,MAAM,YAAY,QAAQ;EAC3B,MAAM,SAASH,YAAUV,SAAO,UAAU,MAAM,OAAO;EACvDA,UAAQ,OAAO;EACfa,QAAM,KAAK,OAAO,KAAK;CAC1B;AACD,QAAO;EAAE;EAAO;CAAO;AAC1B;;;;;;AAMD,MAAM,kBAAkB,CAAC,MAAM;CAC3B,MAAM,IAAI,CACN,EAAE,EACL;CACD,MAAMC,kBAAgB,CAAC,SAAS,KAAK,WAAW,SAAY,KAAK,KAAK,GAAG,KAAK,GAAG,EAAE,EAAE,KAAK,OAAO,CAAC,CAAC;AAInG,MAAK,MAAM,QAAQ,EAAE,KACjB,EAAE,KAAK,CAAC,IAAI,EAAEA,gBAAc,KAAK,EAAE,CAAC;AAExC,KAAI,EAAE,IAAI,WAAW,GACjB,EAAE,MAAM,CAAC,WAAW,CAAC;AACzB,QAAO;AACV;;;;;;;;AAQD,SAAgB,YAAYd,SAAO,GAAG,GAAG;CACrC,YAAY,UAAUA,QAAM,CAAC;AAC7B,KAAI,OAAOA,SAAO,GAAG,EAAE,GAAG,CACtB,QAAO;AACX,KAAI,OAAOA,SAAO,GAAG,EAAE,GAAG,CACtB,QAAO;AACd;;;;;;;;AAQD,SAASM,gBAAcN,SAAO,YAAY;CACtC,YAAY,UAAUA,QAAM,CAAC;AAC7B,KAAI,eAAe,OACf,OAAM,IAAI,MAAM,CAAC,0DAA0D,CAAC;CAChF,MAAM,IAAI,OAAO,eAAe,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,WAAW,GAAG;AAC5E,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,aAAa,EAAE,YAAY;AAChD,QAAO;AACV;;;;;;;;AAQD,UAAiB,IAAIA,SAAO,iBAAiB,kBAAkB;CAC3D,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,QAAQM,gBAAcN,SAAO,gBAAgB;CACnD,MAAM,SAAS,qBAAqB,SAAY,SAAYM,gBAAcN,SAAO,iBAAiB;CAClG,MAAM,QAAQ,IAAI;CAClB,MAAM,uBAAO,IAAI;CACjB,MAAM,QAAQ,MAAM;AACpB,QAAO,CAAC,MAAM,SAAS;EACnB,MAAM,IAAI,MAAM,SAAS;EACzB,MAAM;AACN,MAAI,WAAW,UAAa,WAAW,EACnC;AACJ,OAAK,MAAM,QAAQK,mBAAiBL,SAAO,EAAE,CACzC,KAAI,CAAC,KAAK,IAAI,KAAK,GAAG,EAAE;GACpB,KAAK,IAAI,KAAK,GAAG;GACjB,MAAM,QAAQM,gBAAcN,SAAO,KAAK,GAAG,CAAC;EAC/C;CAER;AACJ;;;;;;AAMD,UAAiB,IAAIA,SAAO,iBAAiB;CACzC,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,SAASM,gBAAcN,SAAO,gBAAgB;CACpD,MAAM,IAAI,IAAI;CACd,MAAM,uBAAO,IAAI;CACjB,EAAE,KAAK,OAAO;AACd,QAAO,CAAC,EAAE,SAAS;EACf,MAAM,IAAI,EAAE,KAAK;AACjB,MAAI,MAAM,OACN;AACJ,MAAI,CAAC,KAAK,IAAI,EAAE,GAAG,EAAE;GACjB,KAAK,IAAI,EAAE,GAAG;GACd,MAAM;AACN,QAAK,MAAM,QAAQ,EAAE,KAAK;IACtB,MAAM,cAAcA,QAAM,SAAS,IAAI,KAAK,GAAG;AAC/C,QAAI,aACA,EAAE,KAAK,YAAY;GAE1B;EACJ;CACJ;AACJ;;;;;;;AAOD,MAAa,eAAe,CAACA,SAAO,eAAe;CAC/C,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,SAAS,OAAO,eAAe,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,WAAW,GAAG;AACjF,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;CAC7C,MAAM,4BAAY,IAAI;CACtB,MAAM,2BAAW,IAAI;CACrB,UAAU,IAAI,OAAO,IAAI,EAAE;CAC3B,MAAM,KAAK,IAAI;CACf,MAAMI,aAAW,CAAC,GAAGJ,QAAM,SAAS,QAAQ,AAAC;AAC7C,MAAK,MAAM,KAAKI,YAAU;AACtB,MAAI,EAAE,OAAO,OAAO,IAAI;GACpB,UAAU,IAAI,EAAE,IAAI,OAAO,iBAAiB;GAC5C,SAAS,IAAI,EAAE,IAAI,KAAK;EAC3B;EACD,GAAG,oBAAoB,EAAE,IAAI,OAAO,iBAAiB;CACxD;AACD,QAAO,CAAC,GAAG,SAAS;EAChB,MAAM,IAAI,GAAG,YAAY;AACzB,MAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;EACnD,MAAM,UAAUJ,QAAM,SAAS,IAAI,EAAE;AACrC,OAAK,MAAM,aAAa,QAAQ,KAAK;GAEjC,MAAM,MAAM,UAAU,IAAI,EAAE,GAAG,SAASA,SAAO,UAAU;AACzD,OAAI,MAAM,UAAU,IAAI,UAAU,GAAG,EAAE;IACnC,UAAU,IAAI,UAAU,IAAI,IAAI;IAChC,SAAS,IAAI,UAAU,IAAI,QAAQ;IACnC,GAAG,eAAe,UAAU,IAAI,KAAK,KAAK;GAC7C;EACJ;CACJ;CACD,MAAM,SAAS,CAAC,OAAO;EACnB,MAAM,OAAO,CAAE;AACf,SAAO,MAAM;AACT,OAAI,OAAO,OAAO,GACd;GACJ,MAAM,IAAI,SAAS,IAAI,GAAG;AAC1B,OAAI,MAAM,UAAa,MAAM,KACzB,OAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI;GAC3C,KAAK,KAAK;IAAE;IAAI,QAAQ,UAAU,IAAI,GAAG;GAAE,EAAC;GAC5C,KAAK,EAAE;EACV;AACD,SAAO;CACV;AACD,QAAO;EACH;EAAW;EAAU;CACxB;AACJ;;;;;;AAMD,MAAa,QAAQ,CAACA,YAAU;CAC5B,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,IAAI,EACN,UAAUe,UAAa,CAAC,GAAGf,QAAM,SAAS,SAAS,AAAC,EAAC,CACxD;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;AAiBD,MAAaA,UAAQ,CAAC,GAAG,uBAAuB;CAC5C,IAAI,IAAI,EACJ,UAAUe,WAAc,CAC3B;AACD,MAAK,MAAM,MAAM,oBACb,IAAIJ,UAAQ,GAAG,GAAG;AAEtB,QAAO;AACV;;;;;AAKD,SAAgB,UAAUX,SAAO;CAC7B,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,SAAS,UAAUA,QAAM;AAC/B,QAAO,OAAO,WAAW;AAC5B;;;;;;AAMD,SAAgB,gBAAgBA,SAAO;CACnC,YAAY,UAAUA,QAAM,CAAC;CAC7B,MAAM,YAAY,IAAI,UAAU;AAEhC,MAAK,MAAM,QAAQ,MAAMA,QAAM,EAC3B,UAAU,IAAI,KAAK,IAAI,EAAE;CAG7B,MAAM,QAAQ,IAAI;CAClB,IAAI,cAAc;AAClB,MAAK,MAAM,UAAU,SAASA,QAAM,EAAE;AAClC,MAAI,UAAU,IAAI,OAAO,GAAG,KAAK,GAC7B,MAAM,QAAQ,OAAO;EAEzB;CACH;CACD,MAAM,WAAW,CAAE;AACnB,QAAO,CAAC,MAAM,SAAS;EAEnB,MAAM,IAAI,MAAM,SAAS;EACzB,SAAS,KAAK,EAAE;AAEhB,OAAK,MAAM,aAAa,EAAE,KAAK;GAC3B,MAAM,SAAS,UAAU,SAAS,UAAU,IAAI,EAAE;AAClD,OAAI,WAAW,GACX,MAAM,QAAQA,QAAM,SAAS,IAAI,UAAU,GAAG,CAAC;EAEtD;CACJ;AACD,KAAI,SAAS,WAAW,YACpB,OAAM,IAAI,MAAM,CAAC,qBAAqB,CAAC;AAE3C,QAAO,kBAAkB,SAAS;AACrC;;;;;;AAMD,SAAgB,kBAAkBI,YAAU;CACxC,MAAM,gBAAqBA,YAAU,OAAK;AACtC,SAAO,CAAC,EAAE,IAAI,CAAE;CACnB,EAAC;CACF,MAAM,IAAIW,UAAa,CAAC,GAAG,SAAU,EAAC;AACtC,QAAO,EACH,UAAU,EACb;AACJ;;;;;;;AAOD,SAAgB,UAAUf,SAAO;CAC7B,YAAY,UAAUA,QAAM,CAAC;CAC7B,IAAI,QAAQ;CACZ,MAAM,QAAQ,IAAI;CAClB,MAAMI,6BAAW,IAAI;CACrB,MAAM,MAAM,CAAE;AACd,MAAK,MAAM,KAAKJ,QAAM,SAAS,QAAQ,EACnCI,WAAS,IAAI,EAAE,IAAI;EACf,GAAG;EACH,SAAS;EACT,OAAO;EACP,SAAS;CACZ,EAAC;CAEN,MAAM,gBAAgB,CAAC,WAAW;EAC9B,OAAO,QAAQ;EACf,OAAO,UAAU;EACjB;EACA,MAAM,KAAK,OAAO;EAClB,OAAO,UAAU;AACjB,OAAK,MAAM,QAAQ,OAAO,KAAK;GAC3B,MAAM,QAAQA,WAAS,IAAI,KAAK,GAAG;AACnC,OAAI,OAAO,MAAM,MAAM,MAAM,EAAE;IAC3B,cAAc,MAAM;IACpB,OAAO,UAAU,KAAK,IAAI,OAAO,SAAS,MAAM,QAAQ;GAC3D,WACQ,MAAM,SACX,OAAO,UAAU,KAAK,IAAI,OAAO,SAAS,MAAM,QAAQ;EAE/D;AACD,MAAI,OAAO,YAAY,OAAO,OAAO;GACjC,MAAM,oBAAoB,CAAE;GAC5B,IAAI;AACJ,UAAO,WAAW,GAAG;IACjB,IAAI,MAAM,KAAK;IACf,EAAE,UAAU;IACZ,kBAAkB,KAAK;KAAE,IAAI,EAAE;KAAI,KAAK,EAAE;IAAK,EAAC;GACnD;AACD,OAAI,kBAAkB,SAAS,GAC3B,IAAI,KAAK,kBAAkB;EAClC;CACJ;AACD,MAAK,MAAM,KAAKA,WAAS,QAAQ,CAC7B,KAAI,OAAO,MAAM,EAAE,MAAM,EACrB,cAAc,EAAE;AAGxB,QAAO;AACV;;;;;;;AAOD,SAAgB,oBAAoBJ,SAAO;CACvC,YAAY,UAAUA,QAAM,CAAC;AAC7B,MAAK,MAAM,KAAK,SAASA,QAAM,CAC3B,MAAK,MAAM,KAAKK,mBAAiBL,SAAO,EAAE,CACtC,MAAK,MAAM,MAAM,IAAIA,SAAO,EAAE,EAAE;AAC5B,MAAI,EAAE,OAAO,GAAG,GACZ;AACJ,MAAI,OAAOA,SAAO,GAAG,GAAG,EAAE;GACtB,MAAM,IAAI,WAAWA,SAAO,GAAG,GAAG;AAClC,UAAO,oBAAoB,EAAE;EAChC;CACJ;AAGT,QAAOA;AACV;;;;;;;;;;;;;;;;;;;;AC1uBD,MAAa,eAAe,CAAC,OAAO;AAChC,QAAO,EACH,GACH;AACJ;AACD,MAAa,oBAAoB,CAACgB,SAAO,WAAW;CAChD,MAAM,KAAK;EACP,GAAGA;EACH,UAAUA,QAAM,SAAS,IAAI,OAAO,IAAI,OAAO;CAClD;AACD,QAAO;AACV;AACD,MAAa,cAAc,CAACA,SAAO,OAAO;CACtC,MAAM,IAAIA,QAAM,SAAS,IAAI,GAAG;AAChC,KAAI,MAAM,OACN,QAAO;EAAE;EAAO,QAAQ;CAAG;CAC/B,MAAM,KAAK,aAAa,GAAG;CAC3B,MAAM,KAAK,kBAAkBA,SAAO,GAAG;AACvC,QAAO;EAAE,OAAO;EAAI,QAAQ;CAAI;AACnC;AACD,SAAS,cAAcA,SAAO,YAAY;AACtC,KAAI,eAAe,OACf,OAAM,IAAI,MAAM,CAAC,0DAA0D,CAAC;AAChF,KAAIA,YAAU,OACV,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;CAChE,MAAM,IAAI,OAAO,eAAe,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,WAAW,GAAG;AAC5E,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,aAAa,EAAE,YAAY;AAChD,QAAO;AACV;;;;;;;;;AASD,MAAa,gBAAgB,CAACA,SAAO,GAAG,MAAM;CAC1C,MAAM,OAAO,cAAcA,SAAO,GAAG,EAAE;AACvC,QAAO,SAAS;AACnB;;;;;;;;;;AAUD,MAAa,gBAAgB,CAACA,SAAO,GAAG,MAAM;AAC1C,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,iDAAiD,CAAC;AACvE,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,iDAAiD,CAAC;AACvE,KAAIA,YAAU,OACV,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;CAChE,MAAM,KAAK,cAAcA,SAAO,EAAE;CAClC,MAAM,KAAK,cAAcA,SAAO,EAAE;AAClC,MAAK,MAAM,QAAQA,QAAM,OAAO;AAC5B,MAAI,KAAK,KAAK,GAAG,MAAM,KAAK,MAAM,GAAG,GACjC,QAAO;AACX,MAAI,KAAK,KAAK,GAAG,MAAM,KAAK,MAAM,GAAG,GACjC,QAAO;CACd;AACD;AACH;;;;;;;;;;AAUD,SAAgB,UAAUA,SAAO,GAAG,GAAG,QAAQ;CAC3C,MAAM,UAAU,YAAYA,SAAO,EAAE;CACrCA,UAAQ,QAAQ;CAChB,MAAM,UAAU,YAAYA,SAAO,EAAE;CACrCA,UAAQ,QAAQ;CAChB,IAAI,OAAO,cAAcA,SAAO,GAAG,EAAE;AACrC,KAAI,SAAS,OACT,QAAO;EAAE;EAAO;CAAM;CAC1B,OAAO;EACH;EACA;EACA;CACH;CACD,MAAM,eAAe;EACjB,GAAGA;EACH,OAAO,CAAC,GAAGA,QAAM,OAAO,IAAK;CAChC;AACD,QAAO;EAAE,OAAO;EAAc;CAAM;AACvC;;;;;;;;;;;;;;;;AAgBD,SAAgB,QAAQA,SAAO,SAAS;CACpC,MAAM,SAAS,iBAAiBA,SAAO,QAAQ;AAC/C,QAAO,OAAO;AACjB;;;;;;;;;;;;;;;;;AAiBD,SAAgB,iBAAiBA,SAAO,SAAS;CAC7C,MAAM,EAAE,GAAG,QAAQ,GAAG,GAAG;CACzB,MAAM,eAAe,MAAM,QAAQ,EAAE,GAAG,IAAI,CAAC,CAAE;CAC/C,MAAMC,UAAQ,CAAE;AAChB,MAAK,MAAM,eAAe,cAAc;EACpC,MAAM,SAAS,UAAUD,SAAO,GAAG,aAAa,OAAO;EACvDA,UAAQ,OAAO;EACfC,QAAM,KAAK,OAAO,KAAK;CAC1B;AACD,QAAO;EAAE;EAAO;CAAO;AAC1B;AACD,MAAa,QAAQ,CAAC,GAAG,uBAAuB;CAC5C,IAAI,IAAI;EACJ,UAAUC,WAAc;EACxB,OAAO,CAAE;CACZ;AACD,MAAK,MAAM,MAAM,oBACb,IAAI,QAAQ,GAAG,GAAG;AAEtB,QAAO;AACV;AACD,SAAgB,kBAAkBF,SAAO;CACrC,MAAM,IAAI,CAAC,GAAGA,QAAM,SAAS,QAAQ,AAAC;CACtC,MAAM,QAAQ,IAAI;CAClB,MAAM,aAAa,GAAG,EAAE,IAAI,QAAM,GAAG,GAAG,CAAC;CACzC,MAAM,UAAU,GAAG,EAAE,IAAI,QAAM,GAAG,GAAG,CAAC;AAEtC,MAAK,IAAI,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;EAC/B,MAAM,OAAO,GAAG,OAAO,EAAE,OAAO;EAChC,MAAM,KAAK,EAAE;AAEb,OAAK,MAAM,CAAC,GAAG,GAAG,IAAI,EAAE,SAAS,EAAE;GAC/B,MAAM,YAAY,cAAcA,SAAO,IAAI,GAAG;AAC9C,OAAI,WACA,MAAM,IAAI,GAAG,GAAG,KAAK;EAE5B;CACJ;AACD,QAAO;AACV;;;;;;AAMD,MAAa,YAAY,CAACA,YAAU;CAChC,MAAM,QAAQ,kBAAkBA,QAAM;AACtC,QAAO,MAAM,KAAK,CAAC,EAAE,CAAC,CAAC;AAC1B;;;;;;AAMD,MAAM,oBAAoB,CAACA,YAAU;CACjC,MAAM,IAAI,CAAE;CACZ,EAAE,KAAK,CAAC,UAAU,EAAE,CAAC,GAAGA,QAAM,SAAS,QAAQ,AAAC,EAAC,IAAI,OAAK,EAAE,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC;CAC7E,EAAE,KAAK,CAAC,MAAM,CAAC,CAAC;AAChB,MAAK,MAAM,QAAQA,QAAM,OACrB,EAAE,KAAK,cAAc,KAAK,CAAC;AAE/B,QAAO;AACV;AACD,MAAM,gBAAgB,CAAC,SAAS;CAC5B,MAAM,SAAS,KAAK,SAAS,CAAC,EAAE,EAAE,KAAK,OAAO,CAAC,CAAC,GAAG,EAAE;AACrD,QAAO,GAAG,KAAK,EAAE,KAAK,EAAE,KAAK,IAAI,QAAQ;AAC5C;;;;;;;AAOD,UAAiB,iBAAiBA,SAAO,SAAS;AAC9C,KAAI,YAAY,OACZ;CACJ,MAAM,SAAS,OAAO,YAAY,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,QAAQ,GAAG;AAC3E,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK,UAAU,QAAQ,EAAE;AACjE,MAAK,MAAM,QAAQA,QAAM,MACrB,KAAI,KAAK,MAAM,SACX,MAAM,cAAcA,SAAO,KAAK,EAAE;UAC7B,KAAK,MAAM,SAChB,MAAM,cAAcA,SAAO,KAAK,EAAE;AAE7C;AACD,UAAiB,eAAeA,SAAO,SAAS;AAC5C,KAAI,YAAY,OACZ;CACJ,MAAM,SAAS,OAAO,YAAY,CAAC,MAAM,CAAC,GAAGA,QAAM,SAAS,IAAI,QAAQ,GAAG;AAC3E,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,KAAK,UAAU,QAAQ,EAAE;AACjE,MAAK,MAAM,QAAQA,QAAM,MACrB,KAAI,KAAK,MAAM,SACX,MAAM;UACD,KAAK,MAAM,SAChB,MAAM;AAEjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AGpND,MAAM,UAAU,CAAC,GAAG,eAAe,EAAE,KAAK;AACtC,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,SAAS,OACnD,QAAO,EAAE;AACb,QAAO;AACV;AAED,UAAiB,eAAe,GAAG,YAAY;AAC3C,KAAI,OAAO,eAAe,CAAC,SAAS,CAAC,EACjC,aAAa,QAAQ,EAAE;AAE3B,MAAK,MAAM,CAAC,OAAO,EAAE,IAAI,QAAQ,EAAE,EAC/B,MAAM,CAAC,GAAG,UAAW;AAEzB,MAAK,MAAM,CAAC,OAAO,EAAE,IAAI,QAAQ,EAAE,EAAE;EACjC,MAAM,OAAO,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5B,MAAM,SAAS,WAAW,SAAS,IAAI,aAAa,CAAC,CAAC,CAAC,GAAG,OAAO;EACjE,OAAO,eAAe,GAAG,OAAO;CACnC;AACJ;AAED,UAAiB,aAAa,GAAG,YAAY;AACzC,KAAI,OAAO,eAAe,CAAC,SAAS,CAAC,EACjC,aAAa,QAAQ,EAAE;AAE3B,MAAK,MAAM,CAAC,OAAO,EAAE,IAAI,QAAQ,EAAE,EAAE;EACjC,MAAM,CAAC,GAAG,UAAW;EACrB,MAAM,OAAO,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5B,MAAM,SAAS,WAAW,SAAS,IAAI,aAAa,CAAC,CAAC,CAAC,GAAG,OAAO;EACjE,OAAO,eAAe,GAAG,OAAO;CACnC;AACJ;AAED,SAAS,UAAU,GAAG;AAClB,QAAO,EAAE,QAAQ;AACpB;AAED,SAAS,UAAU,GAAG;AAClB,QAAO,EAAE,QAAQ;AACpB;AAED,UAAU,QAAQ,GAAG;AACjB,KAAI,UAAU,EAAE,EACZ,OAAO,EAAE,IAAI,SAAS;UAEjB,UAAU,EAAE,EACjB,OAAO,EAAE,IAAI,SAAS;UAEjB,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,CAE/B,MAEG,OAAM,IAAI,UAAU,CAAC,yCAAyC,CAAC;AAEtE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBD,MAAa,QAAQ,OAAO,UAE5B,iBAAiB;CACb,MAAM,OAAO,OAAO,iBAAiB,CAAC,MAAM,CAAC,GAAG,EAAE,QAAQ,aAAc,IAAG;CAC3E,MAAM,YAAY,KAAK,SAAS,CAAC,MAAM,CAAC;AACxC,KAAI,cAAc,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAC9C,MAAM,MAAM,KAAK;CAErB,MAAM,IAAI,QAAQ,QAAQ,MAAM,UAAU,CAAC;AAC3C,KAAI,cAAc,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAC7C,MAAM,MAAM,KAAK;AAErB,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2FD,gBAAgB,qBAAqB;CACjC,IAAIG;CACJ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAOA,YAAU;CACtC,IAAI,QAAQ;CACZ,MAAM,WAAW,MAAM;AACnB,MAAIA,WACAA,WAAS;EACb,IAAI,IAAI,QAAQ,CAAC,MAAOA,YAAU;CACrC;AACD,KAAI;AACA,SAAO,MAAM;GACT,QAAQ,WAAW,sBAAsB,SAAS;GAElD,MAAM,IAAI,MAAM;GAChB,MAAM;EACT;CACJ,UACO;AACJ,MAAIA,WACAA,WAAS;EACb,WAAW,qBAAqB,MAAM;CACzC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCD,gBAAuB,UAAUC,WAAS;CACtC,MAAM,YAAY,aAAaA,UAAQ;AACvC,KAAI,OAAO,cAAc,CAAC,SAAS,CAAC,CAChC,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;AAC1C,KAAI,YAAY,EACZ,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAC/C,KAAI,cAAc,EACd,QAAO,OAAO,oBAAoB;CACtC,IAAID;CACJ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAOA,YAAU;CACtC,IAAI;CACJ,MAAM,WAAW,MAAM;AACnB,MAAIA,WACAA,WAAS;EACb,IAAI,IAAI,QAAQ,CAAC,MAAOA,YAAU;CACrC;AACD,KAAI;AACA,SAAO,MAAM;GACT,QAAQ,WAAW,WAAW,UAAU,UAAU;GAElD,MAAM,IAAI,MAAM;GAChB,MAAM;EACT;CACJ,UACO;AACJ,MAAIA,WACAA,WAAS;AACb,MAAI,UAAU,QACV,WAAW,aAAa,MAAM;EAClC,QAAQ;CACX;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/LD,MAAa,UAAU,CAAC,UAAU,aAAa;AAC3C,KAAI,aAAa,OACb,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;CAErD,MAAM,aAAa,aAAa,SAAS;CACzC,YAAY,YAAY,YAAY,CAAC,SAAS,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;CAC7D,IAAI;CACJ,IAAI,YAAY;CAChB,IAAI,aAAa;CACjB,IAAI,kBAAkB;CACtB,IAAI,QAAQ,CAAC,IAAI,CAAC;CAClB,MAAM,QAAQ,MAAM;EAChB,YAAY;EACZ,WAAW,aAAa,MAAM;EAC9B,QAAQ,CAAC,IAAI,CAAC;CACjB;CACD,MAAM,QAAQ,OAAO,cAAc,UAAU,SAAS;EAClD,MAAM,IAAI,IAAI,QAAQ,CAACE,WAAS,WAAW;GACvC,YAAY,YAAY,KAAK;GAC7B,MAAM,eAAe,aAAa,YAAY;GAC9C,MAAM,KAAK,YAAY,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC;AACjE,OAAI,cAAc,GAAG,EAAE;IACnB,OAAO,cAAc,GAAG,CAAC;AACzB;GACH;AACD,WAAQ,OAAR;IACI,KAAK,CAAC,SAAS,CAAC,EAAE;KAEd,QAAQ;AACR;IACH;IACD,KAAK,CAAC,OAAO,CAAC,CAEV;GAEP;GACD,QAAQ,CAAC,SAAS,CAAC;GAEnB,QAAQ,WAAW,WAAW,YAAY;AACtC,QAAI,UAAU,CAAC,SAAS,CAAC,EAAE;KACvB,QAAQ,KAAK,CAAC,yDAAyD,CAAC,CAAC;KACzE,OAAO;AACP;IACH;IACD,MAAM,QAAQ,QAAQ,CAAE;IACxB;IACA;IACA,QAAQ,CAAC,OAAO,CAAC;IACjB,MAAM,SAAS,YAAY,KAAK,GAAG,WAAW,GAAG,MAAM;IACvD,QAAQ,CAAC,IAAI,CAAC;IACd,OAAO;IACPA,WAAS;GACZ,GAAE,aAAa;EACnB;AACD,SAAO;CACV;CACD,MAAM,SAAS,MAAM;AACjB,MAAI,UAAU,CAAC,IAAI,CAAC,CAChB;EACJ,OAAO;CACV;AACD,QAAO;EACH;EACA;EACA,IAAI,WAAW;AACX,UAAO;EACV;EACD,IAAI,aAAa;AACb,UAAO;EACV;EACD,IAAI,kBAAkB;AAClB,UAAO;EACV;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7DD,MAAa,WAAW,CAAC,UAAU,aAAa;CAC5C,MAAM,IAAI,QAAQ,UAAU,SAAS;AACrC,QAAO,CAAC,GAAG,SAAS;EAAE,EAAE,MAAM,QAAW,KAAK;CAAG;AACpD;;;;;;;;;;;;;;;;;;;ACnDD,IAAa,eAAb,MAA0B;CACtB;CACA,WAAW;CACX,MAAM,KAAK,MAAM,KAAK,QAAQ,GAAG,IAAI;CACrC,cAAc;EACV,KAAKC,YAAY,CAAE;CACtB;;;;;CAKD,UAAU;AACN,SAAO,KAAKA,UAAU,WAAW;CACpC;;;;;;;;;;;CAWD,IAAI,SAAS,UAAU,CAAE,GAAE;EACvB,KAAKC;EACL,MAAM,OAAO,QAAQ,QAAQ;EAC7B,MAAMC,SAAO;GACT,IAAI,GAAG,KAAKC,IAAI,GAAG,EAAE,KAAKF,UAAU;GACpC;GACA;EACH;EACD,KAAKD,UAAU,KAAKE,OAAK;AACzB,SAAOA,OAAK;CACf;;;;;;CAMD,OAAO,IAAI;EACP,MAAM,SAAS,KAAKF,UAAU;EAC9B,KAAKA,YAAY,KAAKA,UAAU,OAAO,aAAW,QAAQ,OAAO,GAAG;AACpE,SAAO,KAAKA,UAAU,WAAW;CACpC;;;;;CAKD,OAAOI,SAAO;AACV,OAAK,MAAM,WAAW,KAAKJ,WAAW;GAClC,QAAQ,QAAQI,QAAM;AACtB,OAAI,QAAQ,MACR,KAAK,OAAO,QAAQ,GAAG;EAE9B;CACJ;;;;CAID,QAAQ;EACJ,KAAKJ,YAAY,CAAE;CACtB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDD,MAAa,WAAW,CAAC,KAAK,aAAa;CACvC,YAAY,YAAY,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;CAChD,IAAI,UAAU;AACd,QAAO,CAAC,SAAS;EACb;AACA,MAAI,YAAY,KAAK;GACjB,UAAU;AACV,OAAI,UACA,SAAS,KAAK;AAClB,UAAO;EACV;AACD,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC8BD,MAAa,MAAM,OAAO,aAAa,OAAO,CAAE,GAAE,SAAS;CACvD,MAAM,UAAU,CAAE;CAClB,MAAM,kBAAkB,KAAK,QAAQ;CACrC,IAAI,mBAAmB,MAAM,QAAQ,YAAY,GAC1C,cACD,CAAC,WAAY;AACnB,KAAI,KAAK,SACL,mBAAmB,QAAQ,iBAAiB;AAChD,MAAK,IAAI,QAAQ,GAAG,QAAQ,iBAAiB,QAAQ,SAAS;EAC1D,MAAM,MAAM,iBAAiB;EAC7B,IAAI;AACJ,MAAI,OAAO,QAAQ,YAEf,IAAI,MAAM,IAAI,KAAK;OAGnB,IAAI;AAER,MAAI,MAAM,QAAW;GACjB,QAAQ,KAAK,EAAE;GACf,QAAQ,KAAK,gBAAgB;EAChC;AACD,MAAI,OAAO,KAAK,SAAS,aACrB;OAAI,KAAK,KAAK,GAAG,QAAQ,CACrB;EACH;CAER;AACD,KAAI,KAAK,OACL,QAAO,QAAQ,OAAO,KAAK,OAAO;AAEtC,QAAO;AACV;;;;;;;;;;;AAWD,MAAa,YAAY,OAAO,aAAa,OAAO,CAAE,GAAE,SAAS;CAC7D,MAAM,UAAU,MAAM,IAAI,aAAa,MAAM,KAAK;AAClD,KAAI,CAAC,QACD;AACJ,KAAI,QAAQ,WAAW,EACnB;CACJ,MAAM,KAAK,KAAK,MAAM;AACtB,QAAO,QAAQ,GAAG,GAAG;AACxB;;;;;;;;;;;;;;;;;;;;;;ACtGD,MAAa,YAAY,CAAC,QAAQ,YAAY,UAAU,CAAE,MAAK;CAC3D,MAAM,aAAa,QAAQ,aAAa;CACxC,MAAM,SAAS,QAAQ;CACvB,IAAI,YAAY;CAChB,IAAI,WAAW;CACf,IAAIK;CACJ,MAAM,UAAU,IAAI,QAAQ,CAACC,WAAS,WAAW;EAC7C,MAAM,UAAU,CAAC,UAAU;AACvB,OAAI,CAAC,IAAI,CAAC,IAAI,MACV,KAAI,WAAW,SAAS,MAAM,KAAK,EAAE;IACjC,YAAY;IACZA,UAAQ,MAAM;IACd,SAAS;GACZ,OAEG,QAAQ,KAAK,CAAC,sBAAsB,EAAE,MAAM,KAAK,0BAA0B,CAAC,CAAC;QAGhF;IACD,QAAQ,KAAK,CAAC,yDAAyD,CAAC,CAAC;IACzE,QAAQ,IAAI,MAAM;GACrB;EACJ;AACD,OAAK,MAAM,QAAQ,YACf,OAAO,iBAAiB,MAAM,QAAQ;EAE1C,MAAM,UAAU,MAAM;AAClB,OAAI,SACA;AACJ,OAAID,cAAY,QACZ,aAAaA,UAAQ;GACzBA,YAAU;GACV,WAAW;AACX,QAAK,MAAM,QAAQ,YACf,OAAO,oBAAoB,MAAM,QAAQ;EAEhD;EACDA,YAAU,WAAW,MAAM;AACvB,OAAI,aAAa,SACb;GACJ,SAAS;GACT,uBAAO,IAAI,MAAM,CAAC,qDAAqD,EAAE,KAAK,UAAU,WAAW,CAAC,WAAW,EAAE,YAAY,EAAE;EAClI,GAAE,WAAW;EACd,QAAQ,iBAAiB,CAAC,KAAK,CAAC,EAAE,MAAM;AACpC,OAAI,aAAa,SACb;GACJ,SAAS;GACT,uBAAO,IAAI,MAAM,CAAC,sBAAsB,EAAE,OAAO,QAAQ,EAAE;EAC9D,EAAC;CACL;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;AC9CD,MAAa,qBAAqB,CAAC,YAAY;CAC3C,MAAM,UAAU,oBAAoB;CACpC,MAAM,KAAK,YAAY;EACnB,GAAG;EACH,YAAY,CAACE,eAAa;GACtB,QAAQA,WAAS;EACpB;EACD,WAAW;AACP,UAAO,QAAQ,WAAW;EAC7B;CACJ,EAAC;AACF,QAAO,CAAC,MAAM;EACV,GAAG,EAAE;AACL,SAAO,SAAS;CACnB;AACJ;;;;;;;;;AC/BD,IAAa,WAAb,cAA8B,mBAAmB;CAC7C;CACA;CACA;CACA;CACA;CACA;;;;;;CAMA,YAAY,KAAK,UAAU;EACvB,OAAO;EACP,KAAK,MAAM;EACX,KAAK,WAAW;EAChB,KAAK,cAAc,YAAY,KAAK;EACpC,KAAK,QAAQ,SAAS;EACtB,KAAK,qBAAqB,KAAK,MAAM;EACrC,KAAK,SAAS,CAAC,IAAI,CAAC;EACpB,KAAK,MAAM,IAAI,IAAI,CAAC,mBAAmB,EAAE,KAAK,KAAK,CAAC;CACvD;;;;;CAKD,WAAW;AACP,MAAI,KAAK,WACL,QAAO,CAAC,yBAAyB,CAAC;AACtC,SAAO,CAAC,iBAAiB,EAAE,KAAK,OAAO,UAAU,EAAE,YAAY,KAAK,GAAG,KAAK,YAAY,OAAO,EAAE,KAAK,UAAU,KAAK,SAAS,KAAK,EAAE;CACxI;;;;;CAKD,YAAY;AACR,MAAI,KAAK,WAAW,CAAC,QAAQ,CAAC,CAC1B,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;EACvC,KAAK,cAAc,YAAY,KAAK;CACvC;;;;;;CAMD,SAAS,QAAQ,MAAM;AACnB,MAAI,KAAK,WAAW,CAAC,QAAQ,CAAC,CAC1B;EACJ,MAAM,WAAW,KAAK;EAEtB,KAAK,SAAS,CAAC,QAAQ,CAAC;EACxB,SAAS,SAAS,KAAK;EACvB,KAAK,MAAM,IAAI,IAAI,CAAC,sBAAsB,EAAE,KAAK,IAAI,SAAS,EAAE,QAAQ,CAAC;EACzE,KAAK,UAAU,CAAC,QAAQ,CAAC,EAAE;GAAE;GAAM;EAAQ,EAAC;EAC5C,MAAM,qBAAqB;CAC9B;;;;;CAKD,QAAQ,QAAQ;AACZ,MAAI,KAAK,WACL,OAAM,IAAI,MAAM,CAAC,aAAa,CAAC;EACnC,MAAM,WAAW,KAAK;EACtB,MAAM,OAAO,SAAS;EACtB,KAAK,MAAM,IAAI,IAAI,CAAC,sBAAsB,EAAE,KAAK,IAAI,SAAS,EAAE,QAAQ,CAAC;EACzE,KAAK,UAAU,CAAC,QAAQ,CAAC,EAAE;GAAE;GAAM;EAAQ,EAAC;EAC5C,KAAK,SAAS,CAAC,QAAQ,EAAE,QAAQ,EAAE,KAAK;CAC3C;CAED,IAAI,OAAO;AACP,MAAI,KAAK,WACL,OAAM,IAAI,MAAM,CAAC,aAAa,CAAC;AACnC,SAAO,KAAK,SAAS;CACxB;;;;;CAKD,IAAI,YAAY;AACZ,MAAI,KAAK,qBAAqB,EAC1B,QAAO,YAAY,KAAK,GAAG,KAAK,cAAc,KAAK;AAEvD,SAAO;CACV;;;;CAID,IAAI,UAAU;AACV,SAAO,YAAY,KAAK,GAAG,KAAK;CACnC;;;;CAID,IAAI,aAAa;AACb,SAAO,KAAK,WAAW,CAAC,QAAQ,CAAC;CACpC;;;;CAID,IAAI,UAAU;AACV,MAAI,KAAK,cAAc,KAAK,UACxB,QAAO;AACX,MAAI,KAAK,SAAS,WACd,QAAO;AACX,SAAO;CACV;AACJ;;;;AAID,IAAa,WAAb,MAAsB;CAClB;CACA;CACA;CACA;CACA;CACA;CACA;;;;;;CAMA,YAAY,MAAM,MAAM;EACpB,KAAK,OAAO;AACZ,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;AACnD,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;EACnD,KAAKC,QAAQ;EACb,KAAKC,mBAAmB;EACxB,KAAKC,qCACD,KAAK;EACT,KAAKC,uBAAuB,KAAK;EACjC,KAAKC,SAAS,CAAE;EAChB,KAAKC,SAAS,CAAC,IAAI,CAAC;CACvB;;;;;CAKD,IAAI,OAAO;AACP,MAAI,KAAKA,WAAW,CAAC,QAAQ,CAAC,CAC1B,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;AACvC,SAAO,KAAKL;CACf;;;;;;CAMD,WAAW,MAAM;AACb,MAAI,KAAKK,WAAW,CAAC,QAAQ,CAAC,CAC1B,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;AACvC,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;EACnD,KAAKL,QAAQ;CAChB;;;;;CAKD,WAAW;AACP,SAAO,CAAC,mBAAmB,EAAE,KAAK,mBAAmB,QAAQ,EAAE,KAAKI,OAAO,OAAO,SAAS,EAAE,KAAKC,OAAO,QAAQ,EAAE,KAAK,UAAU,KAAK,KAAK,EAAE;CACjJ;;;;;;CAMD,QAAQ,MAAM;EACV,MAAM,WAAW,KAAKD,OAAO,KAAK,CAAC,MAAM,MAAM,QAAQ,EAAE,QAAQ,KAAK,IAAI;AAC1E,MAAI,SACA,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;EAChE,KAAKA,OAAO,KAAK,KAAK;EACtB,KAAKH,mBAAmB,YAAY,KAAK;CAC5C;;;;;;CAMD,SAAS,MAAM;EACX,KAAKG,SAAS,KAAKA,OAAO,OAAO,CAAC,MAAM,MAAM,KAAK;EACnD,KAAK,KAAK,SAAS,KAAK;EACxB,KAAKH,mBAAmB,YAAY,KAAK;CAC5C;;;;CAID,IAAI,kBAAkB;AAClB,SAAO,KAAK,aAAa,KAAKE;CACjC;;;;CAID,IAAI,aAAa;AACb,SAAO,KAAKC,OAAO;CACtB;;;;;CAKD,IAAI,qBAAqB;AACrB,MAAI,KAAKF,sCAAsC,EAC3C,QAAO;AACX,MAAI,KAAKE,OAAO,SAAS,EACrB,QAAO;AACX,SAAQ,YAAY,KAAK,GACrB,KAAKF,qCAAqC,KAAKD;CACtD;;;;CAID,IAAI,aAAa;AACb,SAAO,KAAKI,WAAW,CAAC,QAAQ,CAAC;CACpC;;;;;;;CAOD,QAAQ,QAAQ;AACZ,MAAI,KAAKA,WAAW,CAAC,QAAQ,CAAC,CAC1B;EACJ,MAAM,OAAO,KAAKL;EAClB,KAAKK,SAAS,CAAC,QAAQ,CAAC;EACxB,KAAK,KAAK,IAAI,IAAI,CAAC,mBAAmB,EAAE,OAAO,CAAC,CAAC,CAAC;AAClD,OAAK,MAAM,KAAK,KAAKD,QACjB,EAAE,SAAS,CAAC,SAAS,EAAE,QAAQ,EAAE,KAAK;EAE1C,KAAKA,SAAS,CAAE;EAChB,KAAKH,mBAAmB,YAAY,KAAK;EACzC,KAAK,KAAK,iBAAiB,MAAM,OAAO;AACxC,MAAI,KAAK,KAAK,cACV,KAAK,KAAK,aAAa,KAAK;CACnC;AACJ;;;;;;;;;;;;AAYD,IAAa,OAAb,MAAkB;CACd;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,aAAmB,CAAC,IAAI,CAAC,CAAC;;;;;;;CAO1B,YAAY,UAAU,CAAE,GAAE;EACtB,KAAK,WAAW,QAAQ,YAAY;EACpC,KAAK,aAAa,QAAQ,cAAc,CAAC,KAAK,CAAC;EAC/C,KAAK,sBAAsB,QAAQ,uBAAuB;EAC1D,KAAK,oBAAoB,QAAQ,qBAAqB;EACtD,KAAK,oCACD,QAAQ,qCAAqC;EACjD,KAAK,mBAAmB,QAAQ;EAChC,KAAK,eAAe,QAAQ;EAC5B,KAAK,yBAAS,IAAI;EAClB,KAAK,aAAa,CAAE;EACpB,KAAK,aAAmB,CAAC,IAAI,CAAC,EAAE,QAAQ,SAAS,MAAM;EAGvD,MAAM,QAAQ,KAAK,IAAI,KAAK,mBAAmB,KAAK,kCAAkC;AACtF,MAAI,QAAQ,GACR,YAAY,MAAM;GACd,KAAK,UAAU;EAClB,GAAE,QAAQ,IAAI;CAEtB;;;;;CAKD,eAAe;EACX,IAAI,IAAI,CAAC;cACH,EAAE,KAAK,SAAS,oBAAoB,EAAE,KAAK,kBAAkB,sBAAsB,EAAE,KAAK,oBAAoB;qBACvG,EAAE,KAAK,WAAW,QAAQ;EACvC,MAAM,WAAW,KAAK,WAAW,IAAI,CAACK,QAAMA,IAAE,UAAU,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;EACxE,KAAK,CAAC,oBAAoB,CAAC,GAAG;EAC9B,KAAK,CAAC,eAAe,CAAC;AACtB,OAAK,MAAM,CAAC,GAAG,EAAE,IAAI,KAAK,OAAO,SAAS,EACtC,KAAK,CAAC,KAAK,EAAE,EAAE,IAAI,EAAE,EAAE,UAAU,CAAC,IAAI,CAAC;AAE3C,SAAO;CACV;;;;;CAKD,2BAA2B;AACvB,SAAO,CAAC,GAAG,KAAK,OAAO,QAAQ,AAAC,EAAC,KAAK,CAAC,GAAG,MAAM;GAC5C,MAAM,KAAK,EAAE;GACb,MAAM,KAAK,EAAE;AACb,OAAI,OAAO,GACP,QAAO;AACX,OAAI,KAAK,GACL,QAAO;AACX,UAAO;EACV,EAAC;CACL;;;;;CAKD,0BAA0B;AACtB,SAAO,CAAC,GAAG,KAAK,UAAW,EAAC,KAAK,CAAC,GAAG,MAAM;AACvC,OAAI,EAAE,eAAe,EAAE,WACnB,QAAO;AACX,OAAI,EAAE,aAAa,EAAE,WACjB,QAAO;AACX,UAAO;EACV,EAAC;CACL;;;;;;;CAOD,YAAY,UAAU;AAClB,MAAI,aAAa,OACb,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;AAEnD,MAAI,aAAa,KACb,OAAM,IAAI,UAAU,CAAC,wBAAwB,CAAC;AAClD,MAAI,KAAK,WAAW,KAAK,KAAK,WAAW,WAAW,KAAK,SACrD,OAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,KAAK,SAAS,2BAA2B,CAAC;EAEjF,KAAK,IAAI,IAAI,CAAC,iBAAiB,EAAE,KAAK,UAAU,SAAS,EAAE,CAAC;EAC5D,MAAM,KAAK,IAAI,SAAS,MAAM;EAC9B,KAAK,WAAW,KAAK,GAAG;AACxB,SAAO;CACV;;;;;CAKD,WAAW;EACP,IAAI,UAAU;EAEd,MAAM,OAAO,CAAE;AACf,OAAK,MAAM,KAAK,KAAK,WACjB,KAAI,EAAE,YAAY;GACd,KAAK,IAAI,IAAI,CAAC,6BAA6B,EAAE,KAAK,UAAU,EAAE,KAAK,EAAE,CAAC;GACtE,KAAK,KAAK,EAAE;EACf,WACQ,EAAE,oBAAoB;GAC3B,KAAK,IAAI,IAAI,CAAC,4BAA4B,EAAE,KAAK,UAAU,EAAE,KAAK,EAAE,CAAC;GACrE,KAAK,KAAK,EAAE;EACf;AAGL,MAAI,KAAK,SAAS,GAAG;AACjB,QAAK,MAAM,YAAY,MACnB,SAAS,QAAQ,CAAC,eAAe,CAAC,CAAC;GAEvC,UAAU;EACb;EAED,MAAM,mBAAmB,CAAE;AAC3B,OAAK,MAAM,CAAC,KAAK,KAAK,IAAI,KAAK,OAAO,SAAS,CAC3C,KAAI,CAAC,KAAK,SAAS;GACf,KAAK,IAAI,IAAI,CAAC,wBAAwB,EAAE,KAAK,IAAI,YAAY,EAAE,KAAK,WAAW,UAAU,EAAE,KAAK,UAAU,oBAAoB,EAAE,KAAK,SAAS,WAAW,CAAC,CAAC,CAAC;GAC5J,iBAAiB,KAAK,IAAI;GAC1B,KAAK,SAAS,CAAC,OAAO,CAAC,EAAE,KAAK,KAAK;EACtC;AAEL,OAAK,MAAM,WAAW,kBAAkB;GACpC,KAAK,OAAO,OAAO,QAAQ;GAC3B,UAAU;EACb;AACD,MAAI,SACA,KAAK,IAAI,IAAI,CAAC,mBAAmB,EAAE,KAAK,WAAW,OAAO,QAAQ,EAAE,KAAK,aAAa,CAAC;CAE9F;;;;;;CAMD,CAAC,YAAY;EACT,MAAM,WAAW,CAAC,GAAG,KAAK,UAAW;AACrC,OAAK,MAAM,KAAK,UACZ,MAAM;CAEb;;;;;;;;CAQD,CAAC,SAAS;EACN,MAAM,WAAW,CAAC,GAAG,KAAK,UAAW;AACrC,OAAK,MAAM,KAAK,UACZ,MAAM,EAAE;CAEf;;;;;CAKD,QAAQ,SAAS,QAAQ;EACrB,MAAM,KAAK,KAAK,OAAO,IAAI,QAAQ;AACnC,MAAI,CAAC,GACD;EACJ,GAAG,QAAQ,UAAU,CAAC,YAAY,CAAC,CAAC;CACvC;;;;;CAKD,SAAS,MAAM;EACX,KAAK,OAAO,OAAO,KAAK,IAAI;CAC/B;;;;;;CAMD,iBAAiB,UAAU,GAAG;EAC1B,KAAK,aAAa,KAAK,WAAW,OAAO,CAAC,MAAM,MAAM,SAAS;CAClE;;;;;;CAMD,YAAY,UAAU;EAClB,MAAM,QAAQ,KAAK,WAAW,KAAK,CAAC,MAAM,EAAE,SAAS,SAAS;AAC9D,SAAO,UAAU;CACpB;;;;;;CAMD,QAAQ,SAAS;AACb,SAAO,KAAK,OAAO,IAAI,QAAQ;CAClC;;;;;;;CAOD,QAAQ,KAAK,UAAU;EACnB,MAAM,IAAI,IAAI,SAAS,KAAK;EAC5B,KAAK,OAAO,IAAI,KAAK,EAAE;EACvB,SAAS,QAAQ,EAAE;AACnB,SAAO;CACV;;;;;;;CAOD,kBAAkB,SAAS;EAEvB,MAAM,SAAS,KAAK,yBAAyB;AAI7C,MAAI,OAAO,SAAS,KAAK,OAAO,GAAG,iBAAiB;GAGhD,MAAM,IAAI,KAAK,QAAQ,SAAS,OAAO,GAAG;AAC1C,UAAO;EACV;AAED,MAAI,KAAK,qBACJ,KAAK,WAAW,KAAK,KAAK,WAAW,SAAS,KAAK,WAAW;GAC/D,KAAK,IAAI,IAAI,CAAC,UAAU,EAAE,KAAK,SAAS,YAAY,EAAE,KAAK,WAAW,QAAQ,CAAC;GAC/E,MAAM,oBAAoB,KAAK,YAAY,KAAK,kBAAkB,CAAC;GACnE,MAAM,IAAI,KAAK,QAAQ,SAAS,kBAAkB;AAClD,UAAO;EACV;CACJ;;;;CAID,IAAI,cAAc;AACd,SAAO,CAAC,GAAG,KAAK,OAAO,QAAQ,AAAC,EAAC;CACpC;;;;;;CAMD,SAAS,SAAS;EACd,MAAM,WAAW,KAAK,IAAI,QAAQ;AAClC,SAAO,SAAS,SAAS;CAC5B;;;;;;;;;;;;;;;;;;CAkBD,IAAI,SAAS;EACT,MAAM,KAAK,KAAK,OAAO,IAAI,QAAQ;AACnC,MAAI,IAAI;GACJ,GAAG,WAAW;AACd,UAAO;EACV;EACD,KAAK,UAAU;EACf,MAAM,QAAQ,KAAKC,kBAAkB,QAAQ;AAC7C,MAAI,MACA,QAAO;AAEX,MAAI,KAAK,eAAe,CAAC,KAAK,CAAC,CAE3B,OAAM,IAAI,MAAM,CAAC,gCAAgC,EAAE,KAAK,WAAW,YAAY,EAAE,KAAK,SAAS,CAAC,CAAC;AAGrG,MAAI,KAAK,eAAe,CAAC,eAAe,CAAC,EAAE;GACvC,MAAM,QAAQ,KAAK,0BAA0B;AAC7C,OAAI,MAAM,SAAS,GAAG;IAClB,KAAK,QAAQ,MAAM,GAAG,KAAK,CAAC,iBAAiB,CAAC,CAAC;IAC/C,MAAM,SAAS,KAAKA,kBAAkB,QAAQ;AAC9C,QAAI,OACA,QAAO;GACd;EACJ;AAGD,QAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,KAAK,WAAW,CAAC,CAAC;CAC5D;AACJ;;;;;;AAMD,MAAa,SAAS,CAAC,UAAU,CAAE,MAAK,IAAI,KAAK;;;;;;;;;;;;;;;;;;;;;;AC5iBjD,SAAgB,uBAAuB;CACnC,IAAIC;CACJ,IAAI;CACJ,MAAM,UAAU,IAAI,QAAQ,CAAC,UAAU,YAAY;EAC/CA,YAAU;EACV,SAAS;CACZ;AAED,QAAO;EAAE;EAAS,SAASA;EAAiB;CAAQ;AACvD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqBD,MAAa,cAAc,CAAC,YAAY;CACpC,IAAI,WAAW;CACf,MAAM,IAAI,QAAQ,MAAM;AACpB,MAAI,SACA;EACJ,EAAE,OAAO;EACT,QAAQ,WAAW,QAAQ,UAAU,CAAC;CACzC,GAAE,QAAQ,SAAS;AACpB,KAAI,QAAQ,OACR,QAAQ,MAAM,iBAAiB,CAAC,KAAK,CAAC,EAAE,OAAK;EACzC,WAAW;EACX,EAAE,QAAQ;CACb,EAAC;CAEN,EAAE,OAAO;AACT,QAAO,CAAC,SAAS;AACb,MAAI,SACA,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;EAChD,EAAE,OAAO;EACT,QAAQ,WAAW,KAAK;CAC3B;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7BD,gBAAuB,OAAO,SAAS,MAAM;CACzC,MAAM,SAAS,KAAK,UAAU;CAC9B,MAAM,YAAY,KAAK,aAAa,CAAC,MAAM,CAAC;CAC5C,MAAM,QAAQ,KAAK,SAAS;CAC5B,MAAM,iBAAiB,KAAK,kBAAkB;CAC9C,MAAM,gBAAgB,KAAK,eAAe,aAAa,KAAK,aAAa,GAAG;CAC5E,MAAM,gBAAgB,KAAK;CAC3B,IAAI,YAAY;CAChB,IAAI,UAAU,aAAa,KAAK,OAAO,aAAa,KAAK,cAAc,EAAE,CAAC;CAC1E,IAAI,UAAU,YAAY,KAAK;CAC/B,MAAM,UAAU,YAAY;EACxB,MAAM,UAAU,YAAY,KAAK,GAAG;AACpC,MAAI,OAAO,kBAAkB,CAAC,SAAS,CAAC,EACpC,UAAU,KAAK,IAAI,GAAG,gBAAgB,QAAQ;AAElD,MAAI,SACA,MAAM,MAAM;GAAE,QAAQ;GAAS;EAAQ,EAAC;EAE5C,UAAU,YAAY,KAAK;AAC3B,MAAI,QAAQ,QACR,OAAM,IAAI,MAAM,CAAC,eAAe,EAAE,OAAO,QAAQ;CACxD;AACD,KAAI,MAAM,QAAQ,QAAQ,EACtB,UAAU,QAAQ,QAAQ;AAC9B,KAAI,KAAK,SACL,KAAK,SAAS;CAClB,IAAI,UAAU;CACd,IAAI,cAAc;AAClB,KAAI;AACA,SAAO,CAAC,WAAW;GACf;AACA,OAAI,cAAc,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAC9C,MAAM,SAAS;GACnB,MAAM,SAAS,MAAM,QAAQ,QAAQ;AACrC,OAAI,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,gBAClC,YAAY;QAEX;IACD,MAAM;AACN,QAAI,cAAc,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAC7C,MAAM,SAAS;AACnB,QAAI,UAAU,UAAa,eAAe,OACtC,YAAY;GACnB;AACD,OAAI,eACA;QAAI,CAAC,cAAc,YAAY,EAC3B,YAAY;GACf;EAER;EACD,UAAU;CACb,UACO;EACJ,YAAY;AACZ,MAAI,KAAK,YACL,KAAK,WAAW,QAAQ;CAC/B;AACJ;;;;;;;;;;;;;;;;AAiBD,UAAiB,WAAW,SAAS,MAAM;CACvC,MAAM,SAAS,KAAK,UAAU;CAC9B,MAAM,QAAQ,KAAK,SAAS;CAC5B,MAAM,iBAAiB,KAAK,kBAAkB;CAC9C,IAAI,YAAY;AAChB,KAAI,MAAM,QAAQ,QAAQ,EACtB,UAAU,QAAQ,QAAQ;AAC9B,KAAI,KAAK,SACL,KAAK,SAAS;CAClB,IAAI,UAAU;CACd,IAAI,cAAc;AAClB,KAAI;AACA,SAAO,CAAC,WAAW;GACf;GACA,MAAM,SAAS,YAAY,QAAQ;AACnC,OAAI,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,gBAClC,YAAY;QAEX;IACD,MAAM;AACN,QAAI,UAAU,UAAa,eAAe,OACtC,YAAY;AAChB,QAAI,QAAQ,SACR,YAAY;GACnB;EACJ;EACD,UAAU;CACb,UACO;EACJ,YAAY;AACZ,MAAI,KAAK,YACL,KAAK,WAAW,QAAQ;CAC/B;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpFD,IAAa,uBAAb,cAA0C,mBAAmB;CACzD;CACA;CACA;CACA;CACA,4BAAY,IAAI;CAChB;CACA,YAAY,UAAU,CAAE,GAAE;EACtB,OAAO;AACP,MAAI,OAAO,WAAW,CAAC,SAAS,CAAC,EAC7B,WAAW,SAAS;GACJ;GACE;EACjB;EAEL,KAAK,YAAY,QAAQ,aAAa;EACtC,KAAK,wBAAwB,QAAQ,yBAAyB,CAAC,KAAK,CAAC;EACrE,KAAKC,gBAAgB,aAAa,MAAM,KAAKC,WAAW,EAAE,KAAK,YAAY,EAAE;AAC7E,MAAI,QAAQ,KAAK;AACb,OAAI,QAAQ,WACR,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;AAChE,OAAI,QAAQ,YACR,OAAM,IAAI,MAAM,CAAC,2CAA2C,CAAC;GACjE,KAAK,aAAa,QAAQ;GAC1B,KAAK,cAAc,QAAQ;EAC9B,OACI;AACD,OAAI,CAAC,QAAQ,cAAc,CAAC,QAAQ,YAChC,OAAM,IAAI,MAAM,CAAC,yEAAyE,CAAC;GAE/F,KAAK,aAAa,QAAQ;GAC1B,KAAK,cAAc,QAAQ;EAC9B;CACJ;CACD,YAAY;EACR,MAAM,SAAS,CAAC,GAAG,KAAKC,UAAU,QAAQ,AAAC;EAC3C,MAAM,MAAM,KAAK,KAAK;AACtB,OAAK,MAAM,KAAK,OACZ,KAAI,EAAE,aAAa,KAAK;AACpB,OAAI,EAAE,eACF,EAAE,cAAc,CAAC,eAAe,CAAC,CAAC;GAEtC,MAAM,WAAW,EAAE;AACnB,OAAI,UACA,WAAW,MAAM;IACb,SAAS,MAAM,CAAC,eAAe,CAAC,CAAC;GACpC,GAAE,EAAE;GAET,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE;IAAE,SAAS,EAAE;IAAK,UAAU,CAAC,eAAe,CAAC;IAAE,SAAS;GAAO,EAAC;GAC5F,KAAKA,UAAU,OAAO,EAAE,GAAG;EAC9B;EAEL,KAAK,WAAW;AAChB,SAAO,KAAKA,UAAU,OAAO;CAChC;CACD,YAAY;EACR,MAAM,SAAS,CAAC,GAAG,KAAKA,UAAU,QAAQ,AAAC;EAC3C,MAAM,MAAM,KAAK,KAAK;AACtB,OAAK,MAAM,KAAK,QAAQ;GACpB,MAAM,SAAS,MAAM,EAAE;GACvB,QAAQ,IAAI,GAAG,EAAE,GAAG,aAAa,EAAE,KAAK,MAAM,SAAS,IAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;EAC9E;CACJ;;;;;;;;;CASD,QAAQ,SAAS,UAAU;AACvB,MAAI,aAAa,QAAW;GACxB,KAAKC,iBAAiB,SAAS,SAAS;AACxC;EACH;AACD,SAAO,KAAKC,cAAc,QAAQ;CACrC;;;;;CAKD,iBAAiB,SAAS;EACtB,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,MAAI,KAAKF,UAAU,IAAI,GAAG,CACtB,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,GAAG,CAAC,CAAC;EAC/D,MAAM,IAAI;GACN,WAAW,KAAK,KAAK,GAAG,KAAK;GAC7B;GACA,KAAK;EACR;EACD,KAAKA,UAAU,IAAI,IAAI,EAAE;EACzB,KAAKF,cAAc,OAAO;CAC7B;;;;;;;CAOD,cAAc,SAAS;EACnB,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,MAAI,KAAKE,UAAU,IAAI,GAAG,CACtB,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,GAAG,CAAC,CAAC;EAC/D,MAAM,IAAI,IAAI,QAAQ,CAACG,WAAS,WAAW;GACvC,MAAM,IAAI;IACN,WAAW,KAAK,KAAK,GAAG,KAAK;IAC7B;IACA,KAAK;IACL,gBAAgBA;IAChB,eAAe;GAClB;GACD,KAAKH,UAAU,IAAI,IAAI,EAAE;GACzB,KAAKF,cAAc,OAAO;EAC7B;AACD,SAAO;CACV;;;;;;CAMD,iBAAiB,SAAS,UAAU;EAChC,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,MAAI,KAAKE,UAAU,IAAI,GAAG,CACtB,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAE,GAAG,CAAC,CAAC;EAC/D,MAAM,IAAI;GACN,WAAW,KAAK,KAAK,GAAG,KAAK;GAC7B;GACA,KAAK;GACL;EACH;EACD,KAAKA,UAAU,IAAI,IAAI,EAAE;EACzB,KAAKF,cAAc,OAAO;CAC7B;;;;;;CAMD,SAAS,UAAU,WAAW;EAC1B,MAAM,KAAK,KAAK,YAAY,SAAS;EACrC,MAAM,UAAU,KAAKE,UAAU,IAAI,GAAG;AACtC,MAAI,CAAC,SAAS;AACV,OAAI,KAAK,0BAA0B,CAAC,KAAK,CAAC,CACtC,OAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,OAAO,SAAU;AAE9E,UAAO;EACV;AACD,MAAI,WAEA,QAAQ,YAAY,KAAK,KAAK,GAAG,KAAK;OAGtC,KAAKA,UAAU,OAAO,GAAG;AAE7B,MAAI,QAAQ,gBACR,QAAQ,eAAe,SAAS;AAEpC,MAAI,QAAQ,UACR,QAAQ,SAAS,OAAO,SAAS;EAErC,KAAK,UAAU,CAAC,KAAK,CAAC,EAAE;GAAE,SAAS,QAAQ;GAAe;EAAU,EAAC;AACrE,MAAI,CAAC,WACD,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE;GAAE,SAAS,QAAQ;GAAe;GAAU,SAAS;EAAM,EAAC;AAE5F,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpMD,UAAiB,iBAAiB,UAAU,CAAE,GAAE;CAC5C,MAAM,UAAU,QAAQ,WAAW;CACnC,IAAI,gBAAgB,QAAQ,iBAAiB,OAAO;CACpD,MAAM,aAAa,QAAQ;CAC3B,MAAM,QAAQ,QAAQ,SAAS;CAC/B,IAAII,UAAQ;CACZ,YAAY,YAAY,eAAe,CAAC,SAAS,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC,EAAE,WAAW,SAAS,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,EAAE,WAAW,eAAe,EAAE,EAAE,CAAC,aAAa,CAAC,CAAC,EAAE,MAAO,eAAe,SAAa,WAAW,YAAY,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC,GAAG,QAAW,WAAW,OAAO,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AAClR,QAAO,gBAAgB,GAAG;AAEtB,MAAI,cAAcA,WAAS,WACvB;EACJ;EACA,MAAMA;EAENA,WAAS,KAAK,IAAIA,SAAO,MAAM;CAClC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCD,MAAa,gBAAgB,CAAC,UAAU,UAAU,CAAE,MAAK;CACrD,MAAM,OAAO,EACT,MAAM,QAAQ;AACV,MAAI;GACA,MAAM,IAAI,MAAM,UAAU;AAC1B,OAAI,MAAM,OACN,QAAO;IAAE,OAAO,QAAQ;IAAmB,OAAO,CAAC,QAAQ,CAAC;IAAE,SAAS;GAAO;AAClF,UAAO;IAAE,OAAO;IAAG,SAAS;GAAM;EACrC,SACM,OAAO;AACV,UAAO;IAAE,SAAS;IAAc;GAAO;EAC1C;CACJ,EACJ;AACD,QAAO,UAAU,MAAM,QAAQ;AAClC;;;;;;;;;;;;;;;;;;;;;AAqBD,MAAa,YAAY,OAAO,MAAM,OAAO,CAAE,MAAK;CAChD,MAAM,SAAS,KAAK;CACpB,MAAM,MAAM,iBAAiB,KAAK,IAAI;CACtC,MAAM,aAAa,KAAK,cAAc;CACtC,MAAM,YAAY,cAAc;CAChC,IAAI,WAAW;CACf,MAAM,eAAe,KAAK,WAAW;CACrC,MAAM,gBAAgB,KAAK,iBAAiB,OAAO;CACnD,MAAM,aAAa,iBAAiB;EAAE,GAAG;EAAM,SAAS;EAAc;CAAe,EAAC;AACtF,KAAI,gBAAgB,EAChB,OAAM,IAAI,MAAM,CAAC,uCAAuC,CAAC;AAC7D,KAAI,aAAa,EACb,KAAI;EACA,MAAM,MAAM;GAAE,QAAQ;GAAoB;EAAQ,EAAC;CACtD,SACM,OAAO;AAEV,SAAO;GACH,SAAS;GACT;GACA,OAAO,KAAK;GACZ,SAAS,WAAW;GACpB,SAAS,gBAAgB,MAAM;EAClC;CACJ;AAEL,MAAK,MAAM,KAAK,YAAY;EACxB;EAEA,MAAM,SAAS,MAAM,KAAK,MAAM,SAAS;AACzC,MAAI,OAAO,QACP,QAAO;GAAE,SAAS,OAAO;GAAS,OAAO,OAAO;GAAO;GAAU,SAAS,WAAW;EAAE;EAE3F,IAAI,EACA,KAAK,CAAC,gBAAgB,EAAE,SAAS,UAAU,CAAC,IAAI,EAAE,qBAAqB,EAAE,EAAE,CAC9E,EAAC;AAEF,MAAI,YAAY,cACZ;AAGJ,MAAI;GACA,MAAM,MAAM;IAAE,QAAQ;IAAG;GAAQ,EAAC;EACrC,SACM,OAAO;AAEV,UAAO;IACH,SAAS;IACT;IACA,OAAO,KAAK;IACZ,SAAS,gBAAgB,MAAM;IAC/B,SAAS,WAAW;GACvB;EACJ;CACJ;AACD,QAAO;EACH,SAAS,CAAC,gBAAgB,EAAE,SAAS,UAAU,CAAC,UAAU,CAAC;EAC3D,SAAS;EACT;EACA,OAAO,KAAK;EACZ,SAAS,WAAW;CACvB;AACJ;;;;;;;;;;;;;;;;;;AChLD,MAAa,UAAU,CAAC,UAAU;CAC9B,IAAIC,QAAM;CACV,IAAI,UAAU;AACd,QAAO,MAAM;AACT,MAAIA,MACA,QAAO;EACXA,QAAM;EACN,UAAU,OAAO;AACjB,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;ACHD,IAAa,WAAb,MAAsB;CAClB;CACA;CACA;CACA,SAAS;AACL,MAAI,KAAKC,UAAU;GACf,KAAKA,UAAU;GACf,KAAKA,WAAW;EACnB;EACD,KAAKC,WAAW,QAAQ,SAAS;CACpC;;;;;CAKD,QAAQ;AACJ,MAAI,KAAKC,SAAS;GACd,KAAKA,QAAQ,CAAC,OAAO,CAAC,CAAC;GACvB,KAAKA,UAAU;EAClB;EACD,KAAKF,WAAW;EAChB,KAAKC,WAAW;CACnB;CACD,eAAe;EACX,MAAM,IAAI,IAAI,QAAQ,CAACE,WAAS,WAAW;GACvC,KAAKH,WAAWG;GAChB,KAAKD,UAAU;EAClB;EACD,KAAKD,WAAW;AAChB,SAAO;CACV;;;;;;CAMD,MAAM,UAAU,eAAe;EAC3B,IAAI,IAAI,KAAKA;EACb,MAAM,KAAKG,cAAc;AACzB,MAAI,eAAe;GACf,MAAM,SAAS,KAAKF;GACpB,WAAW,MAAM;AACb,QAAI,QACA,OAAO,CAAC,gBAAgB,EAAE,cAAc,UAAU,EAAE,CAAC;GAE5D,GAAE,cAAc;EACpB;EACD,MAAM;EACN,KAAKD,WAAW;EAChB,KAAKD,WAAW;EAChB,KAAKE,UAAU;CAClB;;;;;;;;;;;CAWD,MAAM,UAAU,eAAe;AAC3B,MAAI;GACA,MAAM,KAAK,UAAU,cAAc;AACnC,UAAO;EACV,QACK;AACF,UAAO;EACV;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1DD,IAAa,mBAAb,MAAa,yBAAyB,mBAAmB;CACrD,OAAO,SAAS,IAAI;CACpB;CACA;CACA,cAAc;EACV,OAAO;EACP,KAAK,oBAAyB;EAC9B,KAAK,QAAQ,aAAa,MAAM;AAC5B,UAAO,KAAK,cAAc;EAC7B,GAAE,IAAI;CACV;;;;;;;;;;;CAWD,QAAQ,MAAM;EACV,MAAM,SAAS,KAAK,OAAO,QAAQ,KAAK;AACxC,MAAI,KAAK,MAAM,aAAa,CAAC,IAAI,CAAC,EAAE;GAChC,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,CAAE,EAAC;GAC7B,KAAK,MAAM,OAAO;EACrB;AACD,SAAO;CACV;CACD,UAAU;AACN,SAAO,KAAK,OAAO,SAAS;CAC/B;CACD,MAAM,eAAe;EACjB,MAAM,OAAO,KAAK,OAAO,SAAS;AAClC,MAAI,SAAS,QAAW;GACpB,KAAK,UAAU,CAAC,KAAK,CAAC,EAAE,CAAE,EAAC;AAC3B,UAAO;EACV;AACD,MAAI;GACA,MAAM,MAAM;EACf,SACM,OAAO;GACV,QAAQ,MAAM,MAAM;EACvB;CACJ;;;;;;CAMD,QAAQ;AACJ,MAAI,KAAK,OAAO,WAAW,EACvB;EACJ,KAAK,OAAO,OAAO;EACnB,KAAK,MAAM,QAAQ;EACnB,KAAK,UAAU,CAAC,KAAK,CAAC,EAAE,CAAE,EAAC;CAC9B;;;;CAID,IAAI,UAAU;AACV,SAAO,KAAK,OAAO;CACtB;;;;CAID,IAAI,SAAS;AACT,SAAO,KAAK,OAAO;CACtB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7ED,MAAa,WAAW,CAAC,UAAU,kBAAkB;CACjD,IAAI,UAAU;AACd,QAAO,OAAO,GAAG,SAAS;EACtB,MAAM,UAAU,YAAY,KAAK,GAAG;AACpC,MAAI,WAAW,eAAe;GAC1B,MAAM,IAAI,SAAS,SAAS,GAAG,KAAK;AACpC,OAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EACrB,MAAM;GACV,UAAU,YAAY,KAAK;EAC9B;CACJ;AACJ;;;;;;;;;;;;;;;;;;ACrBD,SAAgB,WAAW,SAAS;CAChC,MAAM,IAAI,SAAS,aAAa,SAAS,EAAE,EAAE;EAAE,OAAO,6BAA6B;EAAE,YAAY;CAAM,EAAC;AACxG,QAAO,MAAM,EAAE;AAClB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCD,SAAgB,QAAQ,UAAU,OAAO,CAAE,GAAE;CACzC,MAAM,UAAU,aAAa,SAAS;AACtC,KAAI,CAAC,QACD,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;CAChD,MAAM,YAAY;EACd,GAAG;EACH,OAAO,6BAA6B;CACvC;CACD,IAAI;AACJ,QAAO,MAAM;EACT,MAAM,SAAS,SAAS,UAAU;AAClC,SAAO,EAAE;CACZ;AACJ;;;;;;;;;;;;;;;;;;;;;AAqBD,SAAgB,aAAa,YAAY,OAAO,CAAE,GAAE;CAChD,MAAM,YAAY;EACd,GAAG;EACH,OAAO,sBAAsB;CAChC;CACD,IAAI;AACJ,QAAO,MAAM;EACT,MAAM,SAAS,YAAY,UAAU;AACrC,SAAO,EAAE;CACZ;AACJ;;;;;;AAMD,MAAa,kBAAkB,OAAO;CAClC,SAAS;CACT,QAAQ;CAER,QAAQ,CACP;CAED,IAAI,KAAK,CACR;AACJ;;;;;;AAMD,MAAa,iBAAiB,OAAO;CACjC,SAAS;CACT,QAAQ;CAER,QAAQ,CACP;CAED,MAAM,CACL;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CD,MAAa,WAAW,CAAC,OAAO,UAAU,CAAE,MAAK;AAC7C,KAAI,CAAC,OAAO,SAAS,MAAM,CACvB,QAAO,iBAAiB;UAEnB,OAAO,MAAM,MAAM,CACxB,QAAO,gBAAgB;CAE3B,MAAM,aAAa,QAAQ,cAAc;CACzC,MAAM,YAAY,QAAQ,aAAa;AACvC,KAAI,cAAc,UACd,OAAM,IAAI,MAAM,CAAC,+CAA+C,CAAC;CACrE,IAAI,mBAAmB;CAEvB,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;CAE5D,IAAI,YAAY;CAChB,MAAM,iBAAiB,CAACG,YAAU;EAC9B,YAAYA;EACZ,IAAI,IAAIA,WAAS,QAAQ;AACzB,MAAI,YACA,IAAI,MAAM,EAAE;WACP,aAAa,KAAK,GACvB,IAAI,IAAI;AACZ,SAAO;CACV;AACD,QAAO;EACH,IAAI,KAAK;GACL,mBAAmB;EACtB;EACD,IAAI,SAAS;AAGT,UAAO,eAAe,UAAU,IAAI;EACvC;EACD,IAAI,UAAU;AACV,UAAO,eAAe,MAAM,QAAQ;EACvC;EACD,OAAO,MAAM;GACT,MAAM,OAAO;EAChB;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;AAuBD,MAAa,iBAAiB,CAAC,WAAW,UAAU,CAAE,MAAK;CACvD,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;CAC5D,MAAM,kBAAkB,YAAY;CACpC,IAAI,mBAAmB;CACvB,MAAM,iBAAiB,MAAM;EAEzB,MAAM,IAAI,MAAM,WAAW,kBAAkB;EAE7C,MAAM,IAAI,IAAI,KAAK,MAAM,EAAE;AAC3B,MAAI,IAAI,EACJ,OAAM,IAAI,MAAM,CAAC,gDAAgD,EAAE,EAAE,IAAI,EAAE,GAAG;AAElF,MAAI,IAAI,EACJ,OAAM,IAAI,MAAM,CAAC,gDAAgD,EAAE,EAAE,IAAI,EAAE,GAAG;AAElF,SAAO;CACV;AACD,QAAO;EACH,KAAK,CAAC,QAAQ;GACV,mBAAmB;EACtB;EACD,OAAO,MAAM;GACT,MAAM,OAAO;EAChB;EACD,IAAI,SAAS;AACT,UAAO,gBAAgB,IAAI;EAC9B;EACD,IAAI,UAAU;AACV,UAAO,gBAAgB;EAC1B;CACJ;AACJ;;;;;;;;;;;;AAYD,MAAa,8BAA8B,MAAM;CAC7C,IAAI,QAAQ,YAAY,KAAK;AAC7B,QAAO;EAIH,OAAO,MAAM;GACT,QAAQ,YAAY,KAAK;EAC5B;EAID,IAAI,UAAU;AACV,UAAO,YAAY,KAAK,GAAG;EAC9B;CACJ;AACJ;;;;;;;;;;;;;;;;;;AAkBD,MAAa,uBAAuB,MAAM;CACtC,IAAI,QAAQ;AACZ,QAAO;EAIH,OAAO,MAAM;GACT,QAAQ;EACX;EAID,IAAI,OAAO;AACP,UAAO;EACV;EASD,IAAI,UAAU;AACV,UAAO,EAAE;EACZ;CACJ;AACJ;;;;;;;;;;;;;;;;;;AAkBD,MAAa,oBAAoB,CAAC,IAAI,UAAU;AAC5C,KAAI,OAAO,OAAO,CAAC,QAAQ,CAAC,CACxB,OAAM,IAAI,MAAM,CAAC,sCAAsC,EAAE,OAAO,IAAI;CACxE,IAAI,aAAa;AACjB,QAAO;EACH,IAAI,UAAU;AACV,UAAO,MAAM;EAChB;EACD,IAAI,SAAS;AACT,UAAO,MAAM;EAChB;EACD,IAAI,WAAW;AACX,OAAI,MAAM,OACN,QAAO,CAAC,IAAI,CAAC;AACjB,UAAO,CAAC,SAAS,CAAC;EACrB;EAID,IAAI,aAAa;AACb,UAAO;EACV;EACD,IAAI,kBAAkB;AAClB,UAAO;EACV;EACD,SAAS,MAAM;GACX,MAAM,UAAU,MAAM;AACtB,UAAO,GAAG,QAAQ;EACrB;EACD,OAAO,MAAM;GACT,MAAM,OAAO;GACb;EACH;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnWD,MAAa,iBAAiB,CAAC,IAAI,UAAU,aAAa,CAAC,IAAI,CAAC,KAAK;CACjE,IAAI,UAAU;CACd,IAAI;CACJ,IAAI,oBAAoB,aAAa,UAAU,IAAK;AACpD,QAAO,MAEP,IAAI,QAAQ,OAAOC,WAAS,WAAW;EACnC,MAAM,UAAU,YAAY,KAAK,GAAG;AACpC,MAAI,cAAc,UAAa,UAAU,kBACrC,KAAI;GACA,UAAU,YAAY,KAAK;GAC3B,YAAY,MAAM,GAAG,QAAQ;GAC7B,oBAAoB,aAAa,UAAU,IAAK;EACnD,SACM,OAAO;AACV,OAAI,eAAe,CAAC,IAAI,CAAC,EAAE;IACvB,YAAY;IACZ,UAAU;GACb,WACQ,eAAe,CAAC,OAAO,CAAC,EAC7B,oBAAoB,KAAK,MAAM,oBAAoB,IAAI;GAG3D,OAAO,MAAM;AACb;EACH;EAELA,UAAQ,UAAU;CACrB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCD,IAAa,eAAb,MAA0B;CACtB;CACA;CACA,WAAW;CACX,cAAc;EACV,MAAM,EAAE,SAAS,oBAAS,GAAG,sBAAsB;EACnD,KAAKC,WAAW;EAChB,KAAKC,WAAWC;CACnB;;;;;;;;;;CAUD,MAAM;AACF,SAAO,KAAKF;CACf;;;;;;;CAOD,IAAIG,SAAO;AACP,MAAI,KAAKC,SACL,OAAM,IAAI,MAAM,CAAC,oCAAoC,CAAC;EAC1D,KAAKA,WAAW;EAChB,KAAKH,SAASE,QAAM;CACvB;;;;;CAKD,IAAI,SAAS;AACT,SAAO,KAAKC;CACf;AACJ;;;;AAID,MAAa,aAAa,MAAM,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACUpC,MAAa,UAAU,CAAC,WAAW,WAAW,eAAe;CACzD,IAAI;CACJ,IAAI,UAAU;CACd,MAAM,OAAO,CAAC,UAAU;AACpB,MAAI,MAAM,QAAW;GACjB,OAAO,aAAa,EAAE;GACtB,IAAI;EACP;AACD,MAAI,OACA,UAAU,MAAM;OAGhB,UAAU;AAEd,MAAI,eAAe,QACf,WAAW,QAAQ;CAC1B;CACD,IAAI,WAAW,WAAW,MAAM;EAC5B,IAAI;AACJ,MAAI;GACA,UAAU,CAAC,cAAc,EAAE,UAAU,EAAE,CAAC,CAAC;EAC5C,UACO;AACJ,OAAI,eAAe,QACf,WAAW,QAAQ;EAC1B;CACJ,GAAE,UAAU;AACb,QAAO;AACV;;;;;;;;;ACpGD,MAAa,aAAa,CAAC,YAAY;AACnC,QAAO,OAAO,OAAO;EACjB,OAAO,QAAQ;EACf,SAAS,CAAC,GAAG,QAAQ,OAAQ;EAC7B,SAAS,QAAQ;CACpB,EAAC;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BD,MAAa,OAAO,CAAC,cAAc,iBAAiB;CAChD,MAAM,CAAC,SAAS,uBAAuB,GAAG,gBAAgB,aAAa;AACvE,KAAI,CAAC,QACD,OAAM,IAAI,MAAM;CACpB,MAAM,QAEL,gBAAiB,OAAO,KAAK,QAAQ,OAAO,CAAC;AAC9C,KAAI,OAAO,QAAQ,OAAO,WAAW,CAAC,SAAS,CAAC,CAC5C,OAAM,IAAI,UAAU,CAAC,gBAAgB,EAAE,MAAM,YAAY,CAAC;CAG9D,MAAM,cAAc,gCAAgC,QAAQ,OAAO;AACnE,KAAI,gBAAgB,OAChB,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AAErD,QAAO,OAAO,OAAO;EACjB,OAAO;EACP,SAAS,CAAE;EACX,SAAS,OAAO,OAAO,OAAO,YAAY,YAAY,CAAC;CAC1D,EAAC;AACL;AACD,MAAa,QAAQ,CAAC,OAAO;AACzB,QAAO,KAAK,GAAG,QAAQ;AAC1B;AACD,MAAa,kBAAkB,CAAC,oBAAoB;AAChD,KAAI,OAAO,oBAAoB,CAAC,SAAS,CAAC,CACtC,QAAO,CAAC,QAAW,CAAC,mBAAmB,CAAC,AAAC;AAE7C,KAAI,oBAAoB,KACpB,QAAO,CAAC,QAAW,CAAC,cAAc,CAAC,AAAC;AAExC,KAAI,CAAC,MAAM,CAAC,IAAI,gBAEZ,QAAO,CAAC,iBAAiB,EAAE,AAAC;AAEhC,KAAI,OAAO,oBAAoB,CAAC,MAAM,CAAC,CACnC,QAAO,CACH,EACI,QAAQ,gBACX,GACD,EAAE,AACL;AAEL,QAAO,CACH,QACA,CAAC,iBAAiB,EAAE,OAAO,gBAAgB,iBAAiB,CAAC,AAChE;AACJ;;;;;;AA8BD,MAAa,SAAS,CAAC,OAAO;AAC1B,QAAO,SAAS,GAAG,CAAC,WAAW;AAClC;;;;;;;AAOD,MAAa,kBAAkB,CAAC,OAAO;CAEnC,qBAAqB,GAAG;CAExB,MAAM,QAAQ,GAAG,QAAQ,GAAG;AAC5B,KAAI,MAAM,WAAW,KAAK,MAAM,GAAG,UAAU,KACzC,QAAO,CAAE;AACb,QAAO;AACV;;;;;;;;AAQD,MAAa,WAAW,CAAC,OAAO;CAC5B,MAAM,UAAU,gBAAgB,GAAG;AACnC,QAAO,QAAQ,IAAI,CAAC,MAAM,EAAE,MAAM;AACrC;AACD,MAAa,mBAAmB,CAAC,YAAY;CACzC,MAAM,wBAAwB,CAAC,WAAW;AAEtC,MAAI,WAAW,KACX,QAAO,EAAE,OAAO,KAAM;AAE1B,MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAC1B,QAAO,EACH,OAAO,OACV;WAEI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,QAAQ;GACtD,MAAM,cAAc,OAAO;AAC3B,OAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CAC/B,OAAM,IAAI,UAAU,CAAC,2CAA2C,EAAE,OAAO,aAAa;AAE1F,OAAI,CAAC,aAAa,CAAC,IAAI,OACnB,QAAO;IACH,OAAO;IACP,eAAe,OAAO;GACzB;AAEL,UAAO,EAAE,OAAO,YAAa;EAChC,MAEG,OAAM,IAAI,MAAM,CAAC,iBAAiB,EAAE,OAAO,OAAO,+CAA+C,CAAC;CAEzG;AAED,KAAI,MAAM,QAAQ,QAAQ,EAAE;EACxB,IAAI,eAAe;EACnB,MAAM,aAAa,QAAQ,IAAI,CAAC,MAAM;GAClC,MAAM,IAAI,sBAAsB,EAAE;AAClC,OAAI,CAAC,EACD,OAAM,IAAI,MAAM,CAAC,cAAc,CAAC;GACpC,eAAe,gBAAgB,EAAE,UAAU;AAC3C,UAAO;EACV,EAAC;AACF,MAAI,gBAAgB,WAAW,SAAS,EACpC,OAAM,IAAI,MAAM,CAAC,qCAAqC,CAAC;AAE3D,SAAO;CACV,OACI;EACD,MAAM,SAAS,sBAAsB,QAAQ;AAC7C,MAAI,CAAC,OACD;AACJ,SAAO,CAAC,MAAO;CAClB;AACJ;AACD,MAAM,kCAAkC,CAAC,MAAM;CAC3C,MAAM,4BAAY,IAAI;AAEtB,MAAK,MAAM,CAAC,eAAe,gBAAgB,IAAI,OAAO,QAAQ,EAAE,EAAE;AAC9D,MAAI,OAAO,kBAAkB,CAAC,SAAS,CAAC,CACpC,OAAM,IAAI,UAAU,CAAC,yBAAyB,CAAC;AAEnD,MAAI,OAAO,oBAAoB,CAAC,SAAS,CAAC,CACtC,OAAM,IAAI,UAAU,CAAC,2BAA2B,EAAE,eAAe;AAErE,MAAI,UAAU,IAAI,cAAc,CAC5B,OAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,eAAe;AAE3D,MAAI,cAAc,SAAS,CAAC,CAAC,CAAC,CAAC,CAC3B,OAAM,IAAI,MAAM,CAAC,iCAAiC,CAAC;EAEvD,UAAU,IAAI,eAAe,CAAE,EAAC;CACnC;AAED,MAAK,MAAM,CAAC,eAAe,gBAAgB,IAAI,OAAO,QAAQ,EAAE,EAAE;EAC9D,MAAM,UAAU,iBAAiB,gBAAgB;AACjD,MAAI,YAAY,OACZ,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAChD,MAAI,YAAY,MAAM;GAElB,MAAM,6BAAa,IAAI;AACvB,QAAK,MAAM,UAAU,SAAS;AAC1B,QAAI,WAAW,IAAI,OAAO,MAAM,CAC5B,OAAM,IAAI,MAAM,CAAC,cAAc,EAAE,OAAO,MAAM,sBAAsB,EAAE,cAAc,CAAC,CAAC;IAE1F,WAAW,IAAI,OAAO,MAAM;AAC5B,QAAI,OAAO,UAAU,KACjB;AACJ,QAAI,CAAC,UAAU,IAAI,OAAO,MAAM,CAC5B,OAAM,IAAI,MAAM,CAAC,cAAc,EAAE,OAAO,MAAM,uDAAuD,EAAE,cAAc,CAAC,CAAC;GAE9H;GACD,UAAU,IAAI,eAAe,QAAQ;EACxC;CACJ;AACD,QAAO;AACV;;;;;;;AAOD,MAAM,uBAAuB,CAAC,UAAU;AACpC,KAAI,OAAO,UAAU,CAAC,SAAS,CAAC,CAC5B,OAAM,IAAI,UAAU,CAAC,0BAA0B,CAAC;AAEpD,KAAI,OAAO,MAAM,UAAU,CAAC,MAAM,CAAC,CAC/B,OAAM,IAAI,UAAU,CAAC,8BAA8B,CAAC;AAE3D;;;;;;;;;;;;;;;;AAgBD,MAAa,KAAK,CAAC,IAAI,YAAY;CAC/B,qBAAqB,GAAG;CACxB,mBAAmB,IAAI,QAAQ;AAC/B,QAAO,OAAO,OAAO;EACjB,OAAO;EACP,SAAS,GAAG;EACZ,SAAS,OAAO,CAAC,GAAG,SAAS,CAAC,GAAG,KAAM,CAAC,EAAC;CAC5C,EAAC;AACL;AACD,MAAa,OAAO,CAAC,OAAO;CAExB,MAAM,QAAQ,gBAAgB,GAAG,CAAC,GAAG,EAAE;AAEvC,KAAI,CAAC,SAAS,MAAM,UAAU,KAC1B,OAAM,IAAI,MAAM,CAAC,2CAA2C,EAAE,GAAG,OAAO;AAE5E,QAAO,GAAG,IAAI,MAAM,MAAM;AAC7B;;;;;;;AAOD,MAAa,oBAAoB,CAAC,IAAI,YAAY;AAC9C,KAAI;EACA,mBAAmB,IAAI,QAAQ;AAC/B,SAAO;CACV,QACK;AACF,SAAO;CACV;AACJ;AACD,MAAa,qBAAqB,CAAC,IAAI,YAAY;AAC/C,KAAI,YAAY,KACZ,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AACrD,KAAI,OAAO,YAAY,CAAC,SAAS,CAAC,CAC9B,OAAM,IAAI,MAAM,CAAC,oCAAoC,CAAC;AAE1D,KAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC3B,OAAM,IAAI,UAAU,CAAC,6CAA6C,EAAE,OAAO,SAAS;CAIxF,MAAM,IAAI,SAAS,GAAG;AACtB,KAAI,EAAE,WAAW,EACb,OAAM,IAAI,MAAM,CAAC,4BAA4B,CAAC;AAClD,KAAI,CAAC,EAAE,SAAS,QAAQ,CACpB,OAAM,IAAI,MAAM,CAAC,cAAc,EAAE,QAAQ,kCAAkC,EAAE,GAAG,MAAM,oBAAoB,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,EAAE;AAEjI;;;;;;;;;;;;;;;;;;AAkBD,MAAa,WAAW,CAAC,GAAG,WAAW;CACnC,MAAM,IAAI,CAAE;AACZ,KAAI,CAAC,MAAM,QAAQ,OAAO,CACtB,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAC/C,KAAI,OAAO,UAAU,EACjB,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACjD,MAAK,IAAI,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;EAChD,MAAM,IAAI,OAAO;AACjB,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACrB,OAAM,IAAI,UAAU,CAAC,qCAAqC,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,EAAE;EAExG,EAAE,KAAM,UAAU,OAAO,SAAS,IAAK,OAAO,OAAO,QAAQ;CAChE;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;AAkBD,MAAa,wBAAwB,CAAC,GAAG,WAAW;CAChD,MAAM,IAAI,CAAE;AACZ,KAAI,CAAC,MAAM,QAAQ,OAAO,CACtB,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAC/C,KAAI,OAAO,SAAS,EAChB,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACjD,MAAK,MAAM,CAAC,OAAO,EAAE,IAAI,OAAO,SAAS,EAAE;AACvC,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACrB,OAAM,IAAI,UAAU,CAAC,qCAAqC,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,EAAE;EAExG,EAAE,KAAK,CAAE;CACZ;AACD,MAAK,IAAI,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;EAChD,MAAM,IAAI,EAAE,OAAO;AACnB,MAAI,UAAU,OAAO,SAAS,EAC1B,KAAI,OAAO,SAAS,GAChB,EAAE,KAAK,OAAO,QAAQ,GAAG;OAGzB,EAAE,OAAO,UAAU;OAGtB;GACD,EAAE,KAAK,OAAO,QAAQ,GAAG;AACzB,OAAI,QAAQ,GACR,EAAE,KAAK,OAAO,QAAQ,GAAG;EAChC;CACJ;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChUD,eAAsB,OAAO,SAAS,gBAAgB;CAClD,MAAM,OAAO,MAAM,QAAQ,eAAe,GACpC,EACE,UAAU,eACb,IACC;CACN,MAAMC,2BAA+B,KAAK,OAAO,EAC7C,UAAU,CAAC,kBAAkB,CAAC,CACjC,EAAC;CAGF,MAAM,0BAAU,IAAI;AACpB,MAAK,MAAM,KAAK,KAAK,UAAU;EAC3B,MAAM,UAAU,MAAM,QAAQ,EAAE,GAAG,GAAG,EAAE,KAAK,CAAC,EAAE,EAAG;AACnD,OAAK,MAAM,SAAS,SAAS;AACzB,OAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzB,OAAM,IAAI,UAAU,CAAC,8DAA8D,EAAE,OAAO,MAAM,EAAE,CAAC;AAEzG,OAAI,QAAQ,IAAI,MAAM,CAClB,OAAM,IAAI,MAAM,CAAC,qCAAqC,EAAE,MAAM,+BAA+B,CAAC;GAElG,QAAQ,IAAI,OAAO,EAAE;EACxB;CACJ;CACD,MAAM,UAAU;EAEZ,MAAM,CAAC,GAAG,MAAM;AACZ,UAAO,gBAAgB,EAAE,SAAS,GAAG,EAAE,SAAS,EAAE;EACrD;EACD,SAAS,KAAK,mBAAmB;CACpC;CACD,IAAI,KAAKC,KAAY,QAAQ;AAE7B,MAAK,MAAM,CAAC,QAAQ,IAAI,QAEpB,KAAI,OAAO,GAAG,QAAQ,aAAa,CAAC,SAAS,CAAC,IAC1C,YAAY,CAAC,UAAU,CAAC,CACxB,OAAM,IAAI,MAAM,CAAC,gDAAgD,EAAE,QAAQ,+EAA+E,CAAC;CAGnK,MAAMC,QAAM,YAAY;EACpBF,QAAM,CAAC,YAAY,EAAE,GAAG,OAAO,CAAC;EAChC,MAAM,QAAQ,GAAG;EACjB,IAAI,UAAU,QAAQ,IAAI,MAAM;AAChC,MAAI,YAAY,QAAW;GACvBA,QAAM,CAAC,wBAAwB,EAAE,MAAM,oBAAoB,CAAC,CAAC;GAE7D,UAAU,QAAQ,IAAI,CAAC,UAAU,CAAC,CAAC;EACtC;AACD,MAAI,YAAY,QAAW;GACvBA,QAAM,CAAC,uBAAuB,CAAC,CAAC;AAChC;EACH;EAGD,MAAM,uBAAuB,QAAQ,iBAAiB,CAAC,KAAK,CAAC,GACvD;GACE,GAAG;GACH,MAAM,CAAC,WAAW;AACd,QAAI,CAAC,OACD,QAAO;AACX,QAAI,CAAC,KAAK,CAAC,IAAI,OACX,QAAO;AACX,QAAI,CAAC,IAAI,CAAC,IAAI,UAAU,OAAO,SAAS,OACpC,QAAO;AACX,WAAO;GACV;EACJ,IACC;EACN,MAAM,UAAU,UAAkB,QAAQ,MAAM,sBAAsB,GAAG;EACzEA,QAAM,CAAC,YAAY,EAAE,GAAG,MAAM,WAAW,EAAE,QAAQ,OAAO,UAAU,EAAE,QAAQ,cAAc,CAAC;EAG7F,IAAI;AACJ,UAAQ,QAAQ,gBAAgB,CAAC,OAAO,CAAC,EAAzC;GACI,KAAK,CAAC,OAAO,CAAC,EAAE;IACZ,IAAI,QAAQ,GAAG,GAAG;AAClB;GACH;GACD,KAAK,CAAC,KAAK,CAAC,EAAE;IACV,IAAI,QAAQ;AACZ;GACH;GACD,KAAK,CAAC,MAAM,CAAC,EAAE;IACX,IAAI,QAAQ,GAAG,EAAE;AACjB;GACH;GACD,KAAK,CAAC,MAAM,CAAC,EAAE;IACX,IAAI,cAAc,QAAQ;AAC1B;GACH;GACD,QACI,OAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,QAAQ,aAAa,2CAA2C,CAAC;EAE1H;EACDA,QAAM,CAAC,iBAAiB,EAAE,KAAK,UAAU,EAAE,EAAE,CAAC;AAE9C,MAAI,GAAG,OACH,KAAKG,MAAa,GAAG;WAEhB,KAAK,EAAE,KACZ,KAAI,OAAO,EAAE,SAAS,CAAC,OAAO,CAAC,EAC3B,KAAKC,KAAY,GAAG;OAEnB;GACDJ,QAAM,KAAK,UAAU,QAAQ,CAAC;GAC9B,KAAKK,GAAU,IAAI,EAAE,KAAK;EAC7B;AAEL,SAAO;CACV;AACD,QAAO;EACH,OAAO,MAAM;GACT,KAAKF,MAAa,GAAG;EACxB;EACD,UAAU,MAAM,GAAG;EACnB;EACA,IAAI,CAAC,UAAU;GACX,KAAKE,GAAU,IAAI,MAAM;AACzB,UAAO;EACV;CACJ;AACJ;;;;;;;;;;;;;;;;;;ACpLD,IAAa,yBAAb,cAA4C,mBAAmB;CAC3D;CACA;CACA;CACA,qBAAqB;CACrB,UAAU;CACV,aAAa,iBAAiB;;;;;;CAM9B,YAAY,GAAG,OAAO,CAAE,GAAE;EACtB,OAAO;EACP,KAAKC,SAAS,KAAK,SAAS;EAC5B,KAAKC,WAAwB,GAAG,KAAK,QAAQ;EAC7C,KAAKC,wBAAqC,KAAKD,IAAI;CACtD;CACD,WAAW,GAAG;AACV,MAAI,KAAKE,YAAY,EACjB;EACJ,KAAKA,UAAU;AACf,MAAI,GAAG;GACH,KAAKC,qBAAqB;GAC1B,WAAW,MAAM;AACb,QAAI,CAAC,KAAKA,mBACN;IACJ,KAAKA,qBAAqB;IAE1B,KAAK,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,OAAO,KAAKH,IAAI,MAAO,EAAC;GACpD,GAAE,EAAE;EACR,OAEG,KAAKG,qBAAqB;CAEjC;;;;;;;CAOD,IAAI,iBAAiB;AACjB,kBAA6B,KAAKH,IAAI;CACzC;;;;CAID,IAAI,gBAAgB;AAChB,SAAO,OAAO,KAAK,KAAKA,IAAI,QAAQ;CACvC;;;;;;;CAOD,OAAO;EACH,MAAM,aAA0B,KAAKA,IAAI;AACzC,MAAI,EAAE,WAAW,EACb,QAAO;EACX,KAAK,QAAQ,EAAE;AACf,SAAO,EAAE;CACZ;;;;;;CAMD,IAAI,SAAS;AACT,gBAA2B,KAAKA,IAAI;CACvC;;;;CAID,QAAQ;EACJ,KAAKI,WAAW,MAAM;EACtB,KAAKJ,iBAA8B,KAAKC,WAAW;EACnD,KAAKI,aAAa,cAAc;CACnC;;;;;;CAMD,mBAAmB,UAAU;qBACO,KAAKL,KAAK,SAAS;CACtD;;;;;;;CAOD,QAAQ,UAAU;AACd,2BAAsC,KAAKA,KAAK,SAAS;CAC5D;;;;;;;CAOD,IAAI,MAAM,UAAU;EAChB,MAAM,aAAa,KAAKA,IAAI;AAC5B,MAAI,aAAa,KAAKA,IAAI,MACtB;EAEJ,KAAKA,SAAsB,KAAKA,KAAK,SAAS;AAC9C,MAAI,KAAKD,QACL,QAAQ,IAAI,CAAC,cAAc,EAAE,WAAW,IAAI,EAAE,UAAU,CAAC;EAE7D,KAAKM,aAAa,cAAc;EAChC,WAAW,MAAM;GACb,KAAK,UAAU,CAAC,MAAM,CAAC,EAAE;IAAY;IAAsB;GAAY,EAAC;EAC3E,GAAE,EAAE;AACL,aAAwB,KAAKL,IAAI,EAC7B,KAAKI,WAAW,KAAK;CAC5B;CACD,IAAI,QAAQ;AACR,SAAO,KAAKJ,IAAI;CACnB;;;;;CAKD,IAAI,YAAY;AACZ,SAAO,KAAKK,YAAY;CAC3B;;;;;CAKD,IAAI,UAAU;AACV,SAAO,KAAKA,YAAY;CAC3B;AACJ"}