{"version":3,"file":"visual-BZUeb5I-.js","names":["isEqual","pt: Point","angleNormalisation: `` | `unipolar` | `bipolar`","origin: Point","line: Line","line","a: Point | number","b?: number","aa: Point | number","bb?: number","opts: TrackOpts","_reason: TrimReason","p: PointerEvent | MouseEvent","_p: TimestampedObject<Point>[]","initialRel: PointTrack","markRel: PointTrack | undefined","lastRel: PointTrack","r: PointTrackerResults","LinesEmpty","PointsPlaceholder","event: PointerEvent","Empty","Placeholder","op: ApplyFieldOp","rectOrWidth: RectPositioned | Rect | number","heightValue?: number","op: ApplyMergeOp","rect: Rect | RectPositioned","parameter: number","rect","a: Rect | RectPositioned","b: Rect | RectPositioned","a: number","b: number","rect: Rect | RectPositioned","amount: number","rect","Placeholder","grid: Grid","cell: GridCell","grid","cell: GridCell","grid?: Grid","grid","grid: Grid","grid: Grid","cell: GridCell","wrap: GridBoundsLogic","grid","wrap","grid: Grid","start?: GridCell","wrap","grid","grid: Grid","start?: GridCell","rowCells: Array<GridCell>","grid","grid: Grid","start: GridCell","vector: GridCell","bounds: GridBoundsLogic","grid","grid: Grid","cell: GridCell","wrap: GridBoundsLogic","grid","wrap","opts: StackOpts","stack: ReadonlyArray<V>","toAdd: ReadonlyArray<V>","opts: StackOpts","data: ReadonlyArray<V>","fn: (v: V) => void","scaleBy: ScaleBy","defaultRect?: Rect","PlaceholderRect","a: number | Point","b?: number | Rect","c?: number | Rect","d?: number","abs: boolean","x: number","y: number","w: number","h: number","abs","resolve: ((value?: undefined) => void) | undefined","timeout: Interval","timer: ReturnType<typeof globalThis.setTimeout> | undefined","elOrQuery: HTMLElement | string","elOrQuery: T | string","options: ElementSizerOptions<T>","#el","#containerEl","#stretch","#onSetSize","#size","#naturalRatio","#naturalSize","#viewport","#byViewport","#byContainer","reason?: string","#disposed","#resizeObservable","canvasElementOrQuery: HTMLCanvasElement | string","options: ElementSizerOptions<HTMLCanvasElement>","el","options: { zIndex?: number } & ElementSizerOptions<HTMLCanvasElement>","opts: ElementSizerOptions<HTMLCanvasElement>","svg: SVGElement","onSizeSet?: (size: Rects.Rect) => void","#onParentResize","#computeSizeBasedOnParent","#onViewportResize","size: Rect","parentSize: Rects.Rect","args: ResizeObserverEntry[]","size: Rects.Rect","__export","clamp","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","fromCss","value: string","toCss","rgb: Rgb","toLibrary","abs","fromLibrary","rgb: C.RGB","to8bit","toScalar","guard","SrgbSpace","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","fromCss","value: string","toCss","hsl: Hsl","abs","toLibrary","fromLibrary","hsl: C.HSL","toAbsolute","toScalar","guard","HslSpace","cssDefinedHexColours","hexStringToColour","hexString: string","toCssColour","colour: Colourish","fromCssColour","colour: string","cssDefinedHexColours","fromCss","guard","colour: Colour","toColour","colourish: Colourish","c: Colour | undefined","multiplyOpacity","colourish: string","amount: number","withOpacity","colourish: Colourish","fn: (scalarOpacity: number) => number","result: Colour | undefined","applyOpts","arc","push","pop","circle","pos","line","withOpacity","fromCss","toCss","toLibrary","abs","fromLibrary","toScalar","guard","#scaler","#scalerSize","#init","#logicalSize","#disposed","#resizer","#ctx","#drawHelper","#getContext","#handleEvents","#viewport","grid","withOpacity","abs","guard","fromCss","guard","circle","el","capture","c"],"sources":["../../packages/geometry/src/point/is-equal.ts","../../packages/geometry/src/point/centroid.ts","../../packages/geometry/src/vector.ts","../../packages/geometry/src/point/relation.ts","../../packages/geometry/src/point/point-tracker.ts","../../packages/geometry/src/line/index.ts","../../packages/geometry/src/rect/apply.ts","../../packages/geometry/src/rect/is-equal.ts","../../packages/geometry/src/rect/multiply.ts","../../packages/geometry/src/rect/placeholder.ts","../../packages/geometry/src/grid/inside.ts","../../packages/geometry/src/grid/guards.ts","../../packages/geometry/src/grid/apply-bounds.ts","../../packages/geometry/src/grid/enumerators/cells.ts","../../packages/geometry/src/grid/as.ts","../../packages/geometry/src/grid/offset.ts","../../packages/geometry/src/grid/indexing.ts","../../packages/collections/src/stack/StackFns.ts","../../packages/collections/src/stack/StackImmutable.ts","../../packages/geometry/src/scaler.ts","../../packages/flow/src/delay.ts","../../packages/dom/src/css.ts","../../packages/dom/src/element-sizing.ts","../../node_modules/.pnpm/colorizr@3.0.7/node_modules/colorizr/dist/index.mjs","../../packages/visual/src/colour/srgb.ts","../../packages/visual/src/colour/hsl.ts","../../packages/visual/src/colour/css-colours.ts","../../packages/visual/src/colour/conversion.ts","../../packages/visual/src/colour/math.ts","../../packages/visual/dist/src/drawing.js","../../packages/visual/dist/src/colour/srgb.js","../../packages/visual/dist/src/image-data-grid.js","../../packages/visual/dist/src/canvas-helper.js","../../packages/visual/dist/src/svg/apply.js","../../packages/visual/dist/src/svg/create.js","../../packages/visual/dist/src/colour/hsl.js","../../packages/visual/dist/src/colour/css-colours.js","../../packages/visual/dist/src/colour/conversion.js","../../packages/visual/dist/src/svg/stroke.js","../../packages/visual/dist/src/svg/elements.js","../../packages/visual/dist/src/pointer-visualise.js","../../packages/visual/dist/src/colour/generate.js","../../packages/visual/dist/src/colour/math.js","../../packages/visual/dist/src/colour/index.js","../../packages/visual/dist/src/video.js","../src/visual.ts"],"sourcesContent":["import type { Point } from \"./point-type.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: ReadonlyArray<Point | undefined>): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import type { Line } from './line/line-type.js';\nimport type { Point } from './point/point-type.js';\nimport { normalise as PointsNormalise } from './point/normalise.js';\nimport { isPoint } from './point/guard.js';\nimport * as Polar from './polar/index.js';\nimport { divide as PointDivide } from './point/divider.js';\nimport { guard as LinesGuard } from './line/guard.js';\nimport { sum as PointsSum } from './point/sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/dot-product.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/magnitude.js';\nimport { distance as PointsDistance } from './point/distance.js';\nimport { Empty as PointEmpty } from './point/empty.js';\n\nexport type Vector = Point | Polar.Coord;\n\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\n\nexport const fromRadians = (radians: number) => {\n  return Object.freeze({\n    x: Math.cos(radians),\n    y: Math.sin(radians)\n  });\n}\n\nexport const toRadians = (point: Point) => {\n  return Math.atan2(point.y, point.x);\n}\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2π\n * if `bipolar` normalisation is used, direction will be fixed to -π...π\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (\n  pt: Point,\n  angleNormalisation: `` | `unipolar` | `bipolar` = ``,\n  origin: Point = EmptyCartesian\n): Polar.Coord => {\n  pt = PointsSubtract(pt, origin);\n\n  //eslint-disable-next-line functional/no-let\n  let direction = Math.atan2(pt.y, pt.x);\n  if (angleNormalisation === `unipolar` && direction < 0) direction += piPi;\n  else if (angleNormalisation === `bipolar`) {\n    if (direction > pi) direction -= piPi;\n    else if (direction <= -pi) direction += piPi;\n  }\n\n  return Object.freeze({\n    distance: PointsDistance(pt),\n    angleRadian: direction,\n  });\n};\n\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line: Line): Point =>\n  PointsSubtract(line.b, line.a);\n\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line: Line): Polar.Coord => {\n  LinesGuard(line, `line`);\n  const pt = PointsSubtract(line.b, line.a);\n  return fromPointPolar(pt);\n};\n\nconst isPolar = (v: Vector): v is Polar.Coord => {\n  if (Polar.isPolarCoord(v)) return true;\n  return false;\n};\n\nconst isCartesian = (v: Vector): v is Point => {\n  if (isPoint(v)) return true;\n  return false;\n};\n\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v: Vector): Vector => {\n  if (isPolar(v)) {\n    return Polar.normalise(v);\n  } else if (isCartesian(v)) {\n    return PointsNormalise(v);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\nexport const quadrantOffsetAngle = (p: Point): number => {\n  if (p.x >= 0 && p.y >= 0) return 0; // Q1\n  if (p.x < 0 && p.y >= 0) return pi; // Q2\n  if (p.x < 0 && p.y < 0) return pi; // Q3\n  return piPi; // Q4\n};\n\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v: Vector, origin = PointEmpty): Polar.Coord => {\n  if (isPolar(v)) {\n    return v;\n  } else if (isCartesian(v)) {\n    return Polar.fromCartesian(v, origin);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v: Vector): Point => {\n  if (isPolar(v)) {\n    return Polar.toPoint(v);\n  } else if (isCartesian(v)) {\n    return v;\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v: Vector, digits?: number) => {\n  if (isPolar(v)) {\n    return Polar.toString(v, digits);\n  } else if (isCartesian(v)) {\n    return PointsToString(v, digits);\n  }\n\n  throw new Error(`Expected polar/cartesian vector. Got: ${ v }`);\n};\n\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Vector, b: Vector) => {\n  if (isPolar(a) && isPolar(b)) {\n    return Polar.dotProduct(a, b);\n  } else if (isCartesian(a) && isCartesian(b)) {\n    return PointsDotProduct(a, b);\n  }\n  throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v: Vector, max = 1, min = 0) => {\n  if (isPolar(v)) {\n    return Polar.clampMagnitude(v, max, min);\n  } else if (isCartesian(v)) {\n    return PointsClampMagnitude(v, max, min);\n  }\n  throw new Error(`Expected either polar or Cartesian vector`);\n};\n\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSum(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsSubtract(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointsMultiply(a, b);\n  return polar ? toPolar(c) : c;\n};\n\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a: Vector, b: Vector) => {\n  const polar = isPolar(a);\n  a = toCartesian(a);\n  b = toCartesian(b);\n  const c = PointDivide(a, b);\n  return polar ? toPolar(c) : c;\n};\n","import { angleRadian } from \"./angle.js\";\nimport { centroid } from \"./centroid.js\";\nimport { distance } from \"./distance.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport type { PointRelation } from \"./point-relation-types.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link Trackers.points}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angleRadian(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","import {\n  TrackedValueMap,\n  type TrackedValueOpts as TrackOpts,\n  type TimestampedObject,\n} from '@ixfx/core/trackers';\nimport { ObjectTracker } from '@ixfx/core/trackers';\nimport { length as LineLength } from '../line/length.js';\nimport * as Vectors from '../vector.js';\nimport { Empty as LinesEmpty } from '../line/index.js';\nimport type { Coord as PolarCoord } from '../polar/index.js';\nimport type { Line, PolyLine } from '../line/line-type.js';\nimport type { Point, Point3d } from './point-type.js';\nimport type { PointRelation } from './point-relation-types.js';\nimport { joinPointsToLines } from '../line/join-points-to-lines.js';\nimport type { TrimReason } from '@ixfx/core/trackers';\nimport type { PointRelationResult } from \"./point-relation-types.js\";\nimport { relation } from './relation.js';\nimport { distance } from './distance.js';\nimport { subtract } from './subtract.js';\nimport { angleRadian } from './angle.js';\nimport { Placeholder as PointsPlaceholder } from './point-type.js';\n/**\n * Information about seen points\n */\nexport type PointTrack = PointRelationResult & {\n  // readonly speedFromInitial:number\n};\n\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = Readonly<{\n  /**\n   * Relation of last point to previous point\n   */\n  fromLast: PointTrack;\n  /**\n   * Relation of last point to 'initial' point.\n   * This will be the oldest point in the buffer of the tracker.\n   */\n  fromInitial: PointTrack;\n  /**\n   * Relation of last point to a 'mark' point,\n   * which is manually set.\n   * \n   * Will give _undefined_ if `.mark()` has not been called on tracker.\n   */\n  fromMark: PointTrack | undefined;\n  values: readonly Point[];\n}>;\n\n\n\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link points}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n * \n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n  initialRelation: PointRelation | undefined;\n  markRelation: PointRelation | undefined;\n  lastResult: PointTrackerResults | undefined;\n\n  constructor(opts: TrackOpts = {}) {\n    super(opts);\n  }\n\n  /**\n   * Notification that buffer has been knocked down to `sampleLimit`.\n   * \n   * This will reset the `initialRelation`, which will use the new oldest value.\n   */\n  onTrimmed(_reason: TrimReason): void {\n    // Force new relation calculations\n    this.initialRelation = undefined;\n  }\n\n  /**\n   * @ignore\n   */\n  onReset(): void {\n    super.onReset();\n    this.lastResult = undefined;\n    this.initialRelation = undefined;\n    this.markRelation = undefined\n  }\n\n  /**\n   * Adds a PointerEvent along with its\n   * coalesced events, if available.\n   * @param p \n   * @returns \n   */\n  seenEvent(p: PointerEvent | MouseEvent): PointTrackerResults {\n    if (`getCoalescedEvents` in p) {\n      const events = p.getCoalescedEvents();\n      const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n      return this.seen(...asPoints);\n    } else {\n      return this.seen({ x: (p).clientX, y: (p).clientY });\n    }\n  }\n\n  /**\n   * Makes a 'mark' in the tracker, allowing you to compare values\n   * to this point.\n   */\n  mark() {\n    this.markRelation = relation(this.last);\n  }\n\n  /**\n   * Tracks a point, returning data on its relation to the\n   * initial point and the last received point.\n   * \n   * Use {@link seenEvent} to track a raw `PointerEvent`.\n   * \n   * @param _p Point\n   */\n  computeResults(\n    _p: TimestampedObject<Point>[]\n  ): PointTrackerResults {\n    const currentLast = this.last;\n\n\n    const previousLast = this.values.at(-2);\n\n    if (this.initialRelation === undefined && this.initial) {\n      // Don't yet have an initial relation function\n      // Use the oldest point in the buffer (this.initial)\n      this.initialRelation = relation(this.initial);\n    } else if (this.initialRelation === undefined) {\n      // Don't have an initial relation, but also don't have an initial point :()\n      throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n    }\n\n    // Make a new relator based on previous point\n    const lastRelation = previousLast === undefined ? relation(currentLast) : relation(previousLast);\n\n    // Compute relation from initial point to latest\n    const initialRel: PointTrack = this.initialRelation(currentLast);\n\n    const markRel: PointTrack | undefined = (this.markRelation !== undefined) ? this.markRelation(currentLast) : undefined;\n\n    const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n\n    // Compute relation from current point to the previous\n    const lastRel: PointTrack = {\n      ...lastRelation(currentLast),\n      speed,\n    };\n\n    const r: PointTrackerResults = {\n      fromInitial: initialRel,\n      fromLast: lastRel,\n      fromMark: markRel,\n      values: [ ...this.values ],\n    };\n    this.lastResult = r;\n    return r;\n  }\n\n  /**\n   * Returns a polyline representation of stored points.\n   * Returns an empty array if points were not saved, or there's only one.\n   */\n  get line(): PolyLine {\n    if (this.values.length === 1) return [];\n    return joinPointsToLines(...this.values);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a polar coordinate\n   */\n  get vectorPolar(): PolarCoord {\n    return Vectors.fromLinePolar(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a vector of the initial/last points of the tracker.\n   * Returns as a Cartesian coordinate\n   */\n  get vectorCartesian(): Point {\n    return Vectors.fromLineCartesian(this.lineStartEnd);\n  }\n\n  /**\n   * Returns a line from initial point to last point.\n   *\n   * If there are less than two points, Lines.Empty is returned\n   */\n  get lineStartEnd(): Line {\n    const initial = this.initial;\n    if (this.values.length < 2 || !initial) return LinesEmpty;\n    return {\n      a: initial,\n      b: this.last,\n    };\n  }\n\n  /**\n   * Returns distance from latest point to initial point.\n   * If there are less than two points, zero is returned.\n   *\n   * This is the direct distance from initial to last,\n   * not the accumulated length.\n   * @returns Distance\n   */\n  distanceFromStart(): number {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? distance(initial, this.last) : 0;\n  }\n\n  /**\n   * Difference between last point and the initial point, calculated\n   * as a simple subtraction of x,y & z.\n   *\n   * `Points.Placeholder` is returned if there's only one point so far.\n   */\n  difference(): Point | Point3d {\n    const initial = this.initial;\n    return this.values.length >= 2 && initial !== undefined ? subtract(this.last, initial) : PointsPlaceholder;\n  }\n\n  /**\n   * Returns angle (in radians) from latest point to the initial point\n   * If there are less than two points, undefined is return.\n   * @returns Angle in radians\n   */\n  angleFromStart(): number | undefined {\n    const initial = this.initial;\n    if (initial !== undefined && this.values.length > 2) {\n      return angleRadian(initial, this.last);\n    }\n  }\n\n  /**\n   * Returns the total length of accumulated points.\n   * Returns 0 if points were not saved, or there's only one\n   */\n  get length(): number {\n    if (this.values.length === 1) return 0;\n    const l = this.line;\n    return LineLength(l);\n  }\n\n  /**\n * Returns the last x coord\n */\n  get x() {\n    return this.last.x;\n  }\n\n  /**\n   * Returns the last y coord\n   */\n  get y() {\n    return this.last.y;\n  }\n\n  /**\n   * Returns the last z coord (or _undefined_ if not available)\n   */\n  get z() {\n    return this.last.z;\n  }\n}\n\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class PointsTracker extends TrackedValueMap<\n  Point,\n  PointTracker,\n  PointTrackerResults\n> {\n\n  constructor(opts: TrackOpts = {}) {\n    super((key, start) => {\n      if (start === undefined) throw new Error(`Requires start point`);\n      const p = new PointTracker({\n        ...opts,\n        id: key,\n      });\n      p.seen(start);\n      return p;\n    });\n  }\n\n  /**\n   * Track a PointerEvent\n   * @param event\n   */\n  seenEvent(event: PointerEvent): Promise<PointTrackerResults[]> {\n    if (`getCoalescedEvents` in event) {\n      const events = event.getCoalescedEvents();\n      const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n      return Promise.all(seens);\n    } else {\n\n      return Promise.all([ super.seen((event as PointerEvent).pointerId.toString(), event) ]);\n    }\n  }\n}\n\n/**\n * Track several named points over time, eg a TensorFlow body pose point.\n * Call `seen()` to track a point. Mutable. If you want to compare\n * a single coordinate with a reference coordinate, {@link point} may be a better choice.\n *\n * See also:\n * * {@link Geometry.Points.relation}: Compute relation info between two points\n * * {@link Trackers.point}: Track relation between points over time\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n * \n * Basic usage\n * ```js\n * const pt = trackPoints();\n *\n * // Track a point under a given id\n * document.addEventListener(`pointermove`, e => {\n *  const info = await pt.seen(e.pointerId, { x: e.x, y: e.y });\n *  // Yields some info on relation of the point to initial value\n * });\n * ```\n *\n * Do something with last values for all points\n * ```js\n * const c = Points.centroid(...Array.from(pt.last()));\n * ```\n *\n * More functions...\n * ```js\n * pt.size;       // How many named points are being tracked\n * pt.delete(id); // Delete named point\n * pt.reset();    // Clear data\n * ```\n *\n * Accessing by id:\n *\n * ```js\n * pt.get(id);  // Get named point (or _undefined_)\n * pt.has(id);  // Returns true if id exists\n * ```\n *\n * Iterating over data\n *\n * ```js\n * pt.trackedByAge(); // Iterates over tracked points, sorted by age (oldest first)\n * pt.tracked(); // Tracked values\n * pt.ids();     // Iterator over ids\n *\n * // Last received value for each named point\n * pt.last();\n *\n * pt.initialValues(); // Iterator over initial values for each point\n * ```\n *\n * You can work with 'most recently updated' points:\n *\n * ```js\n * // Iterates over points, sorted by age (oldest first)\n * pt.valuesByAge();\n * ```\n *\n * Options:\n * * `id`: Id of this tracker. Optional\n * * `sampleLimit`: How many samples to store\n * * `storeIntermediate`: If _true_, all points are stored internally\n * * `resetAfterSamples`: If set above 0, it will automatically reset after the given number of samples have been seen\n * @param options\n * @returns\n */\nexport const trackPoints = (options: TrackOpts = {}) =>\n  new PointsTracker(options);\n\n/**\n * Track a single point. Use {@link trackPoints} to track several points.\n * @param opts \n * @returns \n */\nexport const track = (opts: TrackOpts = {}) => new PointTracker(opts);\n","import type { Point } from '../point/point-type.js';\nimport type { Line } from './line-type.js';\n//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/normalise-by-rect.js';\nimport { minFast } from '@ixfx/numbers';\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isLine } from './guard.js';\nimport { length } from './length.js';\nimport { interpolate } from './interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/guard.js';\n\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport type * from './line-path-type.js';\nexport type * from './line-type.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\n\n\nexport const Empty = Object.freeze({\n  a: Object.freeze({ x: 0, y: 0 }),\n  b: Object.freeze({ x: 0, y: 0 })\n});\n\n\nexport const Placeholder = Object.freeze({\n  a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n  b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l \n * @returns \n */\nexport const isEmpty = (l: Line): boolean => PointIsEmpty(l.a) && PointIsEmpty(l.b);\n\nexport const isPlaceholder = (l: Line): boolean => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n\n\n\n\n/**\n * Applies `fn` to both start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n * \n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n * \n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns \n */\nexport const apply = (line: Line, fn: (p: Point) => Point) => Object.freeze<Line>(\n  {\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n  }\n);\n\n\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint \n * @param b \n * @returns \n */\nexport const angleRadian = (lineOrPoint: Line | Point, b?: Point): number => {\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b point must be provided`);\n  }\n  return Math.atan2(b.y - a.y, b.x - a.x);\n};\n\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line \n * @param width\n * @param height \n * @returns \n */\nexport const normaliseByRect = (line: Line, width: number, height: number): Line => Object.freeze({\n  ...line,\n  a: PointsNormaliseByRect(line.a, width, height),\n  b: PointsNormaliseByRect(line.b, width, height)\n});\n\n\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange \n * @returns True if point is within range\n */\nexport const withinRange = (line: Line, point: Point, maxRange: number): boolean => {\n  const calculatedDistance = distance(line, point);\n  return calculatedDistance <= maxRange;\n};\n\n\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n * \n * @example\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns \n */\nexport const slope = (lineOrPoint: Line | Point, b?: Point): number => {\n\n  let a: Point;\n  if (isLine(lineOrPoint)) {\n\n    a = lineOrPoint.a;\n    b = lineOrPoint.b;\n  } else {\n    a = lineOrPoint;\n    if (b === undefined) throw new Error(`b parameter required`);\n  }\n  if (b === undefined) {\n    throw new TypeError(`Second point missing`)\n  } else {\n    return (b.y - a.y) / (b.x - a.x);\n  }\n};\n\n\n/**\n * Scales a line from its midpoint\n * \n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor \n */\nexport const scaleFromMidpoint = (line: Line, factor: number): Line => {\n  const a = interpolate(factor / 2, line);\n  const b = interpolate(0.5 + factor / 2, line);\n  return { a, b };\n};\n\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line: Line, x: number): Point => {\n  const y = line.a.y + (x - line.a.x) * slope(line);\n  return Object.freeze({ x: x, y });\n};\n\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line: Line, distance: number): Line => {\n  const calculatedLength = length(line);\n  return Object.freeze({\n    ...line,\n    a: line.a,\n    b: Object.freeze({\n      x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n      y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n    })\n  });\n};\n\n/**\n * Yields every integer point along `line`. \n * \n * @example Basic usage\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n * \n * Some precision is lost as start and end\n * point is also returned as an integer.\n * \n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\n\nexport function* pointsOf(line: Line): Generator<Point> {\n  // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n  const { a, b } = line;\n  let x0 = Math.floor(a.x);\n  let y0 = Math.floor(a.y);\n  const x1 = Math.floor(b.x);\n  const y1 = Math.floor(b.y);\n  const dx = Math.abs(x1 - x0);\n  const dy = -Math.abs(y1 - y0);\n  const sx = x0 < x1 ? 1 : -1;\n  const sy = y0 < y1 ? 1 : -1;\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  let err = dx + dy;\n\n  while (true) {\n    yield { x: x0, y: y0 };\n    if (x0 === x1 && y0 === y1) break;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const e2 = 2 * err;\n    if (e2 >= dy) {\n      err += dy;\n      x0 += sx;\n    }\n    if (e2 <= dx) {\n      err += dx;\n      y0 += sy;\n    }\n  }\n}\n\n/**\n * Returns the distance of `point` to the \n * nearest point on `line`.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n * \n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line: Line | readonly Line[], point: Point): number => {\n  if (Array.isArray(line)) {\n    const distances = line.map(l => distanceSingleLine(l, point));\n    return minFast(distances);\n  } else {\n    return distanceSingleLine(line as Line, point);\n  }\n};\n\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n * \n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a: Point | Line, b: Point): readonly number[] => {\n  if (isLine(a)) {\n    return [ a.a.x, a.a.y, a.b.x, a.b.y ];\n  } else if (isPoint(a) && isPoint(b)) {\n    return [ a.x, a.y, b.x, b.y ];\n  } else {\n    throw new Error(`Expected single line parameter, or a and b points`);\n  }\n};\n\n/**\n * Yields all the points of all the lines.\n * \n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines \n */\n\nexport function* asPoints(lines: Iterable<Line>) {\n  for (const l of lines) {\n    yield l.a;\n    yield l.b;\n  }\n}\n\n/**\n * Returns an SVG description of line\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const toSvgString = (a: Point, b: Point): readonly string[] => [ `M${ a.x } ${ a.y } L ${ b.x } ${ b.y }` ];\n","import { guard } from \"./guard.js\";\nimport type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./guard.js\";\n\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number\n\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number\n\nexport function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\n\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth \n * @param heightValue \n * @returns \n */\nexport function applyFields(op: ApplyFieldOp, rectOrWidth: RectPositioned | Rect | number, heightValue?: number): RectPositioned | Rect {\n  let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n  let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n  if (width === undefined) throw new Error(`Param 'width' undefined`);\n  if (height === undefined) throw new Error(`Param 'height' undefined`);\n\n  width = op(width, `width`);\n  height = op(height, `height`);\n\n  if (typeof rectOrWidth === `object`) {\n    if (isPositioned(rectOrWidth)) {\n      const x = op(rectOrWidth.x, `x`);\n      const y = op(rectOrWidth.y, `y`);\n      return { ...rectOrWidth, width, height, x, y };\n    } else {\n      return {\n        ...rectOrWidth, width, height\n      }\n    }\n  }\n  return { width, height };\n}\n\nexport function applyMerge(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op \n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function applyMerge(\n  op: ApplyMergeOp,\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  guard(a, `a`);\n\n  if (isRect(b)) {\n    // Math op by another rectangle\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b.width),\n      y: op(a.y, b.height),\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b.width),\n      height: op(a.height, b.height),\n    });\n  } else {\n    // Math op with a series of values\n    if (typeof b !== `number`) {\n      throw new TypeError(\n        `Expected second parameter of type Rect or number. Got ${ JSON.stringify(\n          b\n        ) }`\n      );\n    }\n    if (typeof c !== `number`) throw new Error(`Expected third param as height. Got ${ JSON.stringify(c) }`);\n    return isRectPositioned(a) ? Object.freeze({\n      ...a,\n      x: op(a.x, b),\n      y: op(a.y, c),\n      width: op(a.width, b),\n      height: op(a.height, c),\n    }) : Object.freeze({\n      ...a,\n      width: op(a.width, b),\n      height: op(a.height, c),\n    });\n  }\n}\n\n/**\n * Uses `op` with `param` to width and height.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op \n * @param rect \n * @param parameter \n */\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: RectPositioned,\n  parameter: number\n): RectPositioned;\n\nexport function applyScalar(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return isPositioned(rect) ? Object.freeze({\n    ...rect,\n    x: op(rect.x, parameter),\n    y: op(rect.y, parameter),\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  }) : Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}\n\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op \n * @param rect \n * @param parameter \n * @returns \n */\nexport function applyDim(\n  op: ApplyMergeOp,\n  rect: Rect | RectPositioned,\n  parameter: number\n): Rect | RectPositioned {\n  return Object.freeze({\n    ...rect,\n    width: op(rect.width, parameter),\n    height: op(rect.height, parameter),\n  });\n}","import { isPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a: Rect, b: Rect): boolean => {\n  if (a === undefined) throw new Error(`a undefined`);\n  if (b === undefined) throw new Error(`b undefined`);\n  return a.width === b.width && a.height === b.height;\n};\n\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (\n  a: Rect | RectPositioned,\n  b: Rect | RectPositioned\n): boolean => {\n  if (isPositioned(a) && isPositioned(b)) {\n    if (!PointsIsEqual(a, b)) return false;\n    return a.width === b.width && a.height === b.height;\n  } else if (!isPositioned(a) && !isPositioned(b)) {\n    return a.width === b.width && a.height === b.height;\n  } else {\n    // One param is positioned, the other is not\n    return false;\n  }\n};","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport { applyMerge, applyDim, applyScalar } from \"./apply.js\";\n\nconst multiplyOp = (a: number, b: number) => a * b;\n\n\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n * x/y value of second parameter are ignored.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport function multiply(\n  rect: RectPositioned,\n  width: number,\n  height?: number\n): RectPositioned;\n\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport function multiply(rect: Rect, width: number, height: number): Rect;\n\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n * \n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a \n * @param b \n */\nexport function multiply(a: Rect, b: Rect): Rect;\n\n/**\n * @internal\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport function multiply(\n  a: RectPositioned | Rect,\n  b: Rect | number,\n  c?: number\n): RectPositioned | Rect {\n  // @ts-ignore\n  return applyMerge(multiplyOp, a, b, c) as RectPositioned | Rect;\n}\n\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect: Rect, amount: number): Rect;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: RectPositioned,\n  amount: number\n): RectPositioned;\n\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n * \n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * \n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyScalar(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n\n\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n * \n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns \n */\nexport function multiplyDim(\n  rect: Rect | RectPositioned,\n  amount: number\n): Rect | RectPositioned {\n  return applyDim(multiplyOp, rect, amount);\n  // return isPositioned(rect) ? Object.freeze({\n  //   ...rect,\n  //   x: rect.x * amount,\n  //   y: rect.y * amount,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // }) : Object.freeze({\n  //   ...rect,\n  //   width: rect.width * amount,\n  //   height: rect.height * amount,\n  // });\n}\n","export const Placeholder = Object.freeze({\n  width: Number.NaN,\n  height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n  x: Number.NaN,\n  y: Number.NaN,\n  width: Number.NaN,\n  height: Number.NaN,\n});\n","import type { Grid, GridCell } from \"./types.js\";\n\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid: Grid, cell: GridCell): boolean => {\n  if (cell.x < 0 || cell.y < 0) return false;\n  if (cell.x >= grid.cols || cell.y >= grid.rows) return false;\n  return true;\n};\n\n\n","import { inside } from \"./inside.js\";\nimport type { GridCell, Grid } from \"./types.js\";\n\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell: GridCell | undefined): cell is GridCell => {\n  if (cell === undefined) return false;\n  return `x` in cell && `y` in cell;\n};\n\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (\n  cell: GridCell,\n  parameterName = `Param`,\n  grid?: Grid\n) => {\n  if (cell === undefined) {\n    throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n  }\n  if (cell.x === undefined) throw new Error(parameterName + `.x is undefined`);\n  if (cell.y === undefined) throw new Error(parameterName + `.y is undefined`);\n  if (Number.isNaN(cell.x)) throw new Error(parameterName + `.x is NaN`);\n  if (Number.isNaN(cell.y)) throw new Error(parameterName + `.y is NaN`);\n  if (!Number.isInteger(cell.x)) {\n    throw new TypeError(parameterName + `.x is non-integer`);\n  }\n  if (!Number.isInteger(cell.y)) {\n    throw new TypeError(parameterName + `.y is non-integer`);\n  }\n  if (grid !== undefined && !inside(grid, cell)) {\n    throw new Error(\n      `${ parameterName } is outside of grid. Cell: ${ cell.x },${ cell.y } Grid: ${ grid.cols }, ${ grid.rows }`\n    );\n  }\n};\n\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid: Grid, parameterName = `Param`) => {\n  if (grid === undefined) {\n    throw new Error(`${ parameterName } is undefined. Expecting grid.`);\n  }\n  if (!(`rows` in grid)) throw new Error(`${ parameterName }.rows is undefined`);\n  if (!(`cols` in grid)) throw new Error(`${ parameterName }.cols is undefined`);\n\n  if (!Number.isInteger(grid.rows)) {\n    throw new TypeError(`${ parameterName }.rows is not an integer`);\n  }\n  if (!Number.isInteger(grid.cols)) {\n    throw new TypeError(`${ parameterName }.cols is not an integer`);\n  }\n};","import { clampIndex } from \"@ixfx/numbers\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport type { GridBoundsLogic, GridCell, Grid } from \"./types.js\";\n\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid \n * @param cell \n * @param wrap \n * @returns \n */\nexport const applyBounds = function (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  guardGrid(grid, `grid`);\n  guardCell(cell, `cell`);\n\n  let x = cell.x;\n  let y = cell.y;\n  switch (wrap) {\n    case `wrap`: {\n      x = x % grid.cols;\n      y = y % grid.rows;\n      if (x < 0) x = grid.cols + x;\n      else if (x >= grid.cols) {\n        x -= grid.cols;\n      }\n      if (y < 0) y = grid.rows + y;\n      else if (y >= grid.rows) {\n        y -= grid.rows;\n      }\n      x = Math.abs(x);\n      y = Math.abs(y);\n      break;\n    }\n    case `stop`: {\n      x = clampIndex(x, grid.cols);\n      y = clampIndex(y, grid.rows);\n      break;\n    }\n    case `undefined`: {\n      if (x < 0 || y < 0) return;\n      if (x >= grid.cols || y >= grid.rows) return;\n      break;\n    }\n    case `unbounded`: {\n      break;\n    }\n    default: {\n      throw new Error(`Unknown BoundsLogic '${ wrap }'. Expected: wrap, stop, undefined or unbounded`);\n    }\n  }\n  return Object.freeze({ x, y });\n};","import { guardGrid, guardCell } from \"../guards.js\";\nimport type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../types.js\";\nimport { values } from \"../values.js\";\n\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n * \n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n * \n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n * \n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n * \n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid: Grid, start?: GridCell, wrap = true) {\n  if (!start) start = { x: 0, y: 0 }\n\n  guardGrid(grid, `grid`);\n  guardCell(start, `start`, grid);\n\n  let { x, y } = start;\n  let canMove = true;\n  do {\n    yield { x, y };\n    x++;\n    if (x === grid.cols) {\n      y++;\n      x = 0;\n    }\n    if (y === grid.rows) {\n      if (wrap) {\n        y = 0;\n        x = 0;\n      } else {\n        canMove = false;\n      }\n    }\n    if (x === start.x && y === start.y) canMove = false; // Complete\n  } while (canMove);\n};\n\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n * \n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true) {\n  yield* values(grid, cells(grid, start, wrap));\n}\n\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n * \n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid \n * @param start \n * @param wrap \n */\nexport function* cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap = true): Generator<GridCellAndValue<T>> {\n  for (const cell of cells(grid, start, wrap)) {\n    yield { cell, value: grid.get(cell) }\n  }\n}","import type { GridCell, Grid, GridReadable } from \"./types.js\";\nimport { cells } from \"./enumerators/cells.js\";\n\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n * \n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 }\n  let row = start.y;\n  let rowCells: Array<GridCell> = [];\n\n  for (const c of cells(grid, start)) {\n    if (c.y === row) {\n      rowCells.push(c);\n    } else {\n      yield rowCells;\n      rowCells = [ c ];\n      row = c.y;\n    }\n  }\n  if (rowCells.length > 0) yield rowCells;\n};\n\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n * \n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n * \n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid \n * @param start \n */\nexport function* columns(grid: Grid, start?: GridCell) {\n  if (!start) start = { x: 0, y: 0 };\n  for (let x = start.x; x < grid.cols; x++) {\n    let colCells: Array<GridCell> = [];\n    for (let y = start.y; y < grid.rows; y++) {\n      colCells.push({ x, y });\n    }\n    yield colCells;\n  }\n}","//import { clampIndex } from '@ixfx/numbers';\nimport { applyBounds } from './apply-bounds.js';\n//import { guardCell, guardGrid } from './guards.js';\nimport type { Grid, GridCell, GridBoundsLogic } from './types.js';\n\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n * \n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (\n  grid: Grid,\n  start: GridCell,\n  vector: GridCell,\n  bounds: GridBoundsLogic = `undefined`\n): GridCell | undefined {\n  return applyBounds(grid, {\n    x: start.x + vector.x,\n    y: start.y + vector.y\n  }, bounds)\n  // guardCell(start, `start`, grid);\n  // guardCell(vector);\n  // guardGrid(grid, `grid`);\n\n  // // eslint-disable-next-line functional/no-let\n  // let x = start.x;\n  // // eslint-disable-next-line functional/no-let\n  // let y = start.y;\n  // switch (bounds) {\n  //   case `wrap`: {\n  //     x += vector.x % grid.cols;\n  //     y += vector.y % grid.rows;\n  //     if (x < 0) x = grid.cols + x;\n  //     else if (x >= grid.cols) {\n  //       x -= grid.cols;\n  //     }\n  //     if (y < 0) y = grid.rows + y;\n  //     else if (y >= grid.rows) {\n  //       y -= grid.rows;\n  //     }\n  //     break;\n  //   }\n  //   case `stop`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     x = clampIndex(x, grid.cols);\n  //     y = clampIndex(y, grid.rows);\n  //     break;\n  //   }\n  //   case `undefined`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     if (x < 0 || y < 0) return;\n  //     if (x >= grid.cols || y >= grid.rows) return;\n  //     break;\n  //   }\n  //   case `unbounded`: {\n  //     x += vector.x;\n  //     y += vector.y;\n  //     break;\n  //   }\n  //   default: {\n  //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n  //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n  //   }\n  // }\n  // return Object.freeze({ x, y });\n};\n\n","import { throwIntegerTest } from \"@ixfx/guards\";\nimport { guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\nimport type { Grid, GridCell, GridBoundsLogic } from \"./types.js\";\n\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (\n  grid: Grid,\n  cell: GridCell,\n  wrap: GridBoundsLogic\n): number | undefined => {\n  guardGrid(grid, `grid`);\n\n  if (cell.x < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        //cell = { ...cell, x: grid.cols + cell.x };\n        cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`)!;\n        break;\n      }\n    }\n  }\n  if (cell.y < 0) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: 0 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: grid.rows + cell.y };\n        break;\n      }\n    }\n  }\n  if (cell.x >= grid.cols) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, x: grid.cols - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, x: cell.x % grid.cols };\n        break;\n      }\n    }\n  }\n  if (cell.y >= grid.rows) {\n    switch (wrap) {\n      case `stop`: {\n        cell = { ...cell, y: grid.rows - 1 };\n        break;\n      }\n      case `unbounded`: {\n        throw new Error(`unbounded not supported`);\n      }\n      case `undefined`: {\n        return undefined;\n      }\n      case `wrap`: {\n        cell = { ...cell, y: cell.y % grid.rows };\n        break;\n      }\n    }\n  }\n\n  const index = cell.y * grid.cols + cell.x;\n\n  return index;\n};\n\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (\n  colsOrGrid: number | Grid,\n  index: number\n): GridCell => {\n  let cols = 0;\n  cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n  throwIntegerTest(cols, `aboveZero`, `colsOrGrid`);\n\n  return {\n    x: index % cols,\n    y: Math.floor(index / cols),\n  };\n};","import type { StackOpts } from './Types.js';\n\nexport const trimStack = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = stack.length + toAdd.length;\n  const policy = opts.discardPolicy ?? `additions`;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  if (opts.debug) {\n    console.log(\n      `Stack.push: stackLen: ${ stack.length } potentialLen: ${ potentialLength } toRemove: ${ toRemove } policy: ${ policy }`\n    );\n  }\n  switch (policy) {\n    case `additions`: {\n      if (opts.debug) {\n        console.log(\n          `Stack.push:DiscardAdditions: stackLen: ${ stack.length } slice: ${ potentialLength - capacity\n          } toAddLen: ${ toAdd.length }`\n        );\n      }\n\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (stack.length === opts.capacity) {\n        return stack; // Completely full\n      } else {\n        // Only add some from the new array\n        return [ ...stack, ...toAdd.slice(0, toAdd.length - toRemove) ];\n      }\n    }\n    case `newer`: {\n      if (toRemove >= stack.length) {\n        // New items will completely flush out old\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n      } else {\n        // Keep some of the old (from 0)\n        //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n        if (opts.debug) {\n          console.log(` from orig: ${ JSON.stringify(stack.slice(0, stack.length - toRemove)) }`);\n        }\n        return [\n          ...stack.slice(0, stack.length - toRemove),\n          ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n        ];\n      }\n    }\n    case `older`: {\n      // Oldest item in stack is position 0\n      return [ ...stack, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown discard policy ${ policy }`);\n    }\n  }\n};\n\n// Add to top (last index)\nexport const push = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  // If stack is A, B and toAdd is C, D this yields A, B, C, D\n  //const mutated = [...stack, ...toAdd];\n  const potentialLength = stack.length + toAdd.length;\n\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n  const toReturn = overSize\n    ? trimStack(opts, stack, toAdd)\n    : [ ...stack, ...toAdd ];\n  return toReturn;\n};\n\n// Remove from top (last index)\nexport const pop = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (stack.length === 0) throw new Error(`Stack is empty`);\n  return stack.slice(0, - 1);\n};\n\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): V | undefined => stack.at(-1);\n\nexport const isEmpty = <V>(opts: StackOpts, stack: ReadonlyArray<V>): boolean =>\n  stack.length === 0;\n\nexport const isFull = <V>(\n  opts: StackOpts,\n  stack: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return stack.length >= opts.capacity;\n  }\n  return false;\n};\n","// -------------------------\n// Immutable\n// -------------------------\nimport type { IStackImmutable } from './IStackImmutable.js';\nimport { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nimport type { StackOpts } from './Types.js';\n\nexport class StackImmutable<V> implements IStackImmutable<V> {\n  private readonly opts: StackOpts;\n  /* eslint-disable-next-line functional/prefer-readonly-type */\n  readonly data: ReadonlyArray<V>;\n\n  constructor(opts: StackOpts = {}, data: ReadonlyArray<V> = []) {\n    this.opts = opts;\n    this.data = data;\n  }\n\n  push(...toAdd: ReadonlyArray<V>): StackImmutable<V> {\n    return new StackImmutable<V>(\n      this.opts,\n      push(this.opts, this.data, ...toAdd)\n    );\n  }\n\n  pop(): IStackImmutable<V> {\n    return new StackImmutable<V>(this.opts, pop(this.opts, this.data));\n  }\n\n  forEach(fn: (v: V) => void): void {\n    this.data.forEach(fn);\n  }\n\n  forEachFromTop(fn: (v: V) => void): void {\n    [ ...this.data ].reverse().forEach(fn);\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.opts, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.opts, this.data);\n  }\n\n  get peek(): V | undefined {\n    return peek(this.opts, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n}\n\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = <V>(\n  options: StackOpts = {},\n  ...startingItems: ReadonlyArray<V>\n): IStackImmutable<V> => new StackImmutable({ ...options }, [ ...startingItems ]);\n","\nimport type { Point } from './point/point-type.js';\nimport type { Rect } from './rect/index.js';\nimport { isPoint } from './point/index.js';\nimport { isRect } from './rect/guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/placeholder.js';\n\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (\n  a: number | Point,\n  b?: number | Rect,\n  c?: number | Rect,\n  d?: number\n) => Point;\n\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n  /**\n   * Relative to absolute coordinates\n   */\n  readonly abs: Scaler;\n  /**\n   * Absolute to relative coordintes\n   */\n  readonly rel: Scaler;\n\n  readonly width: number;\n\n  readonly height: number;\n\n  computeScale(): Point\n};\n\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (\n  scaleBy: ScaleBy = `both`,\n  defaultRect?: Rect\n): ScalerCombined => {\n  const defaultBounds = defaultRect ?? PlaceholderRect;\n\n  let sw = 1;\n  let sh = 1;\n  let s = { x: 1, y: 1 };\n\n  const computeScale = () => {\n    switch (scaleBy) {\n      case `height`: {\n        return { x: sh, y: sh };\n      }\n      case `width`: {\n        return { x: sw, y: sw };\n      }\n      case `min`: {\n        return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n      }\n      case `max`: {\n        return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n      }\n      default: {\n        return { x: sw, y: sh };\n      }\n    }\n  };\n\n  const normalise = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): [ x: number, y: number, w: number, h: number ] => {\n    let inX = Number.NaN;\n    let inY = Number.NaN;\n    let outW = defaultBounds.width;\n    let outH = defaultBounds.height;\n\n    if (typeof a === `number`) {\n      inX = a;\n      if (typeof b === `number`) {\n        inY = b;\n        if (c === undefined) return [ inX, inY, outW, outH ];\n        if (isRect(c)) {\n          outW = c.width;\n          outH = c.height;\n        } else if (typeof c === `number`) {\n          outW = c;\n          if (typeof d === `number`) {\n            outH = d;\n          } else {\n            throw new TypeError(`Missing final height value`);\n          }\n        } else throw new Error(`Missing valid output range`);\n      } else if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else {\n        throw new Error(\n          `Expected input y or output Rect to follow first number parameter`\n        );\n      }\n    } else if (isPoint(a)) {\n      inX = a.x;\n      inY = a.y;\n      if (b === undefined) return [ inX, inY, outW, outH ];\n      if (isRect(b)) {\n        outW = b.width;\n        outH = b.height;\n      } else if (typeof b === `number`) {\n        outW = b;\n        if (typeof c === `number`) {\n          outH = c;\n        } else {\n          throw new TypeError(\n            `Expected height as third parameter after Point and output width`\n          );\n        }\n      } else {\n        throw new TypeError(\n          `Expected Rect or width as second parameter when first parameter is a Point`\n        );\n      }\n    } else {\n      throw new Error(`Expected input Point or x value as first parameter`);\n    }\n    return [ inX, inY, outW, outH ];\n  };\n\n  const scaleAbs = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(true, ...n);\n  };\n\n  const scaleRel = (\n    a: number | Point,\n    b?: number | Rect,\n    c?: number | Rect,\n    d?: number\n  ): Point => {\n    const n = normalise(a, b, c, d);\n    return scaleNormalised(false, ...n);\n  };\n\n  const scaleNormalised = (\n    abs: boolean,\n    x: number,\n    y: number,\n    w: number,\n    h: number\n  ): Point => {\n    if (Number.isNaN(w)) throw new Error(`Output width range missing`);\n    if (Number.isNaN(h)) throw new Error(`Output height range missing`);\n\n    // If output dimensions has changed since last, create a new scale\n    if (w !== sw || h !== sh) {\n      sw = w;\n      sh = h;\n      s = computeScale();\n    }\n\n    return abs ? {\n      x: x * s.x,\n      y: y * s.y,\n    } : {\n      x: x / s.x,\n      y: y / s.y,\n    };\n  };\n\n  return {\n    computeScale,\n    rel: scaleRel,\n    abs: scaleAbs,\n    width: defaultBounds.width,\n    height: defaultBounds.height\n  };\n};\n\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }","import { intervalToMs, type Interval } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n\n/**\n * Delay options\n */\nexport type DelayOpts = Interval & {\n  /**\n   * Signal for cancelling delay\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When delay is applied. \"before\" is default.\n   */\n  readonly delay?: `before` | `after` | `both`;\n};\n\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async <V>(\n  callback: () => Promise<V>,\n  //eslint-disable-next-line functional/prefer-immutable-types\n  optsOrMillis: DelayOpts | number\n): Promise<V> => {\n  const opts =\n    typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n  const delayWhen = opts.delay ?? `before`;\n  if (delayWhen === `before` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  const r = Promise.resolve(await callback());\n  if (delayWhen === `after` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  return r;\n};\n\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n\n//     // Yield value\n//     yield v;\n\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n * \n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n * \n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n * \n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n * \n * The below example shows how to do this.\n * \n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n * \n * // Execution continues while loop also runs\n * ```\n *\n */\n\nasync function* delayAnimationLoop() {\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer = 0;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.requestAnimationFrame(callback);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    globalThis.cancelAnimationFrame(timer);\n  }\n}\n\n/**\n * Async generator that loops at a given interval.\n * \n * @example \n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n * \n * @example \n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n * \n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport async function* delayLoop(timeout: Interval) {\n  const timeoutMs = intervalToMs(timeout);\n  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);\n  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);\n  if (timeoutMs === 0) return yield* delayAnimationLoop();\n\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer: ReturnType<typeof globalThis.setTimeout> | undefined;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.setTimeout(callback, timeoutMs);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    if (timer !== undefined) globalThis.clearTimeout(timer);\n    timer = undefined;\n  }\n}\n","\nimport type { RectPositioned } from \"@ixfx/geometry/rect\";\nimport { resolveEl, resolveEls, type QueryOrElements } from \"./resolve-el.js\";\n\n// const tw = getComputedStyle(this.#el).borderTopWidth;\n// const bw = getComputedStyle(this.#el).borderBottomWidth;\n// const leftW = getComputedStyle(this.#el).borderLeftWidth;\n// const rightW = getComputedStyle(this.#el).borderRightWidth;\n\ntype ComputedPixelsMap<T extends readonly (keyof CSSStyleDeclaration)[]> = Record<T[ number ], number>\n\n/**\n * Returns the value of `getBoundingClientRect` plus the width of all the borders\n * @param elOrQuery \n * @returns \n */\nexport const getBoundingClientRectWithBorder = (elOrQuery: SVGElement | HTMLElement | string): RectPositioned => {\n  let el = resolveEl(elOrQuery);\n  const size = el.getBoundingClientRect();\n  if (el instanceof SVGElement) {\n    el = el.parentElement!;\n  }\n  const border = getComputedPixels(el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);\n\n  return {\n    x: size.x,\n    y: size.y,\n    width: size.width + border.borderLeftWidth + border.borderRightWidth,\n    height: size.height + border.borderTopWidth + border.borderBottomWidth\n  }\n}\n\n/**\n * Returns the computed measurements of CSS properties via [getComputedStyle](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle).\n * ```js\n * const v = getComputedPixels(`#some-el`, `borderTopWidth`, `borderLeftWidth`);\n * v.borderTopWidth;  // number\n * b.borderLeftWidth; // number\n * ```\n * \n * Throws an error if value from `getComputedStyle` is not a string or does not end in 'px'.\n * @param elOrQuery \n * @param properties \n * @returns \n */\nexport const getComputedPixels = <T extends readonly (keyof CSSStyleDeclaration)[]>(elOrQuery: HTMLElement | string, ...properties: T): ComputedPixelsMap<T> => {\n  const s = getComputedStyle(resolveEl(elOrQuery));\n  const returnValue = {};\n  for (const property of properties) {\n    const v = s[ property ];\n    if (typeof v === `string`) {\n      if (v.endsWith(`px`)) {\n        (returnValue as any)[ property ] = Number.parseFloat(v.substring(0, v.length - 2));\n      } else {\n        throw new Error(`Property '${ String(property) }' does not end in 'px'. Value: ${ v }`);\n      }\n    } else {\n      throw new Error(`Property '${ String(property) }' is not type string. Got: ${ typeof v } Value: ${ v }`);\n    }\n  }\n  return returnValue as ComputedPixelsMap<T>;\n}\n\n\n/**\n * Adds `cssClass` to element(s) if `value` is true.\n * ```js\n * setClass(`#someId`, true, `activated`);\n * ```\n * @param selectors \n * @param value \n * @param cssClass \n * @returns \n */\nexport const setCssClass = (selectors: QueryOrElements, value: boolean, cssClass: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n\n  for (const element of elements) {\n    if (value) element.classList.add(cssClass);\n    else element.classList.remove(cssClass);\n  }\n};\n\n/**\n * Toggles a CSS class on all elements that match selector\n * @param selectors \n * @param cssClass \n * @returns \n */\nexport const setCssToggle = (selectors: QueryOrElements, cssClass: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  for (const element of elements) {\n    element.classList.toggle(cssClass);\n  }\n}\n\nexport const setCssDisplay = (selectors: QueryOrElements, value: string) => {\n  const elements = resolveEls(selectors);\n  if (elements.length === 0) return;\n  for (const element of elements) {\n    (element).style.display = value;\n  }\n};","import { resolveEl } from \"./resolve-el.js\";\nimport { getComputedPixels } from \"./css.js\";\nimport { Rects } from \"@ixfx/geometry\";\nimport type { Rect } from \"@ixfx/geometry/rect\";\n\n/**\n * * width: use width of parent, set height based on original aspect ratio of element. Assumes parent has a determined width.\n * * height: use height of parent, set width based on original aspect ratio of element. Assumes parent has a determined height.\n * * both: use height & width of parent, so the element adopts the ratio of the parent. Be sure that parent has a width and height set.\n * * min: use the smallest dimension of parent\n * * max: use the largest dimension of parent\n */\nexport type ElementResizeLogic = `width` | `height` | `both` | `none` | `min` | `max`;\n\n/**\n * Options\n */\nexport type ElementSizerOptions<T extends HTMLElement | SVGElement> = {\n  /**\n   * @defaultValue 'none'\n   */\n  stretch?: ElementResizeLogic\n  naturalSize?: Rects.Rect\n  /**\n   * If not specified, the element's parent is used\n   */\n  containerEl?: HTMLElement | string\n  onSetSize: (size: Rects.Rect, el: T) => void\n}\n\n/**\n * Consider using static methods:\n * \n * ```js\n * // Resize an <SVG> element to match viewport\n * Dom.ElementSizer.svgViewport(svg);\n * \n * // Resize canvas to match its parent\n * Dom.ElementSizer.canvasParent(canvas);\n * \n * // Resize canvas to match viewport\n * Dom.ElementSizer.canvasViewport(canvas);\n * ```\n */\nexport class ElementSizer<T extends HTMLElement | SVGElement> {\n  #stretch: ElementResizeLogic;\n  #size: Rects.Rect;\n  #naturalSize: Rects.Rect;\n  #naturalRatio: number;\n  #viewport: Rects.RectPositioned;\n  #onSetSize;\n  #el: T;\n  #containerEl: HTMLElement;\n  #disposed = false;\n  #resizeObservable: ResizeObserver | undefined;\n\n  constructor(elOrQuery: T | string, options: ElementSizerOptions<T>) {\n    this.#el = resolveEl(elOrQuery);\n    this.#containerEl = options.containerEl ? resolveEl(options.containerEl) : this.#el.parentElement!;\n\n    this.#stretch = options.stretch ?? `none`;\n    this.#onSetSize = options.onSetSize;\n    this.#size = Rects.Empty;\n\n    let naturalSize = options.naturalSize;\n    if (naturalSize === undefined) {\n      naturalSize = this.#el.getBoundingClientRect();\n    }\n    this.#naturalRatio = 1;\n    this.#naturalSize = naturalSize;\n    this.setNaturalSize(naturalSize);\n    this.#viewport = Rects.EmptyPositioned;\n\n    if (this.#containerEl === document.body) {\n      this.#byViewport();\n    } else {\n      this.#byContainer();\n    }\n  }\n\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizeObservable) {\n      this.#resizeObservable.disconnect();\n      this.#resizeObservable = undefined;\n    }\n  }\n\n  static canvasParent(canvasElementOrQuery: HTMLCanvasElement | string, options: ElementSizerOptions<HTMLCanvasElement>): ElementSizer<HTMLCanvasElement> {\n    const el = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    const er = new ElementSizer<HTMLCanvasElement>(el, {\n      ...options,\n      onSetSize(size, el) {\n        el.width = size.width;\n        el.height = size.height;\n        if (options.onSetSize) options.onSetSize(size, el);\n      },\n    });\n    return er;\n  }\n\n  static canvasViewport(canvasElementOrQuery: HTMLCanvasElement | string, options: { zIndex?: number } & ElementSizerOptions<HTMLCanvasElement>): ElementSizer<HTMLCanvasElement> {\n    const el = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    el.style.position = `absolute`;\n    el.style.zIndex = (options.zIndex ?? 0).toString();\n    el.style.left = `0px`;\n    el.style.top = `0px`;\n    const opts: ElementSizerOptions<HTMLCanvasElement> = { ...options, containerEl: document.body }\n    return this.canvasParent(canvasElementOrQuery, opts);\n  }\n\n  /**\n   * Size an SVG element to match viewport\n   * @param svg \n   * @returns \n   */\n  static svgViewport(svg: SVGElement, onSizeSet?: (size: Rects.Rect) => void): ElementSizer<SVGElement> {\n    const er = new ElementSizer<SVGElement>(svg, {\n      containerEl: document.body,\n      stretch: `both`,\n      onSetSize(size) {\n        svg.setAttribute(`width`, size.width.toString());\n        svg.setAttribute(`height`, size.height.toString());\n        if (onSizeSet) onSizeSet(size);\n      },\n    });\n    return er;\n  }\n\n\n  #byContainer() {\n    const c = this.#containerEl;\n    if (!c) throw new Error(`No container element`);\n\n    // Listen for resize\n    const r = new ResizeObserver((entries) => {\n      this.#onParentResize(entries);\n    });\n    r.observe(c);\n    // Get current value\n    const current = this.#computeSizeBasedOnParent(c.getBoundingClientRect());\n    this.size = current;\n\n    this.#resizeObservable = r;\n  }\n\n  #byViewport() {\n    const r = new ResizeObserver((entries) => {\n      this.#onViewportResize();\n    });\n    r.observe(document.documentElement);\n    this.#resizeObservable = r;\n    this.#onViewportResize();\n  }\n\n  #onViewportResize() {\n    this.size = { width: window.innerWidth, height: window.innerHeight };\n    this.#viewport = {\n      x: 0, y: 0,\n      ...this.size\n    };\n  }\n  /**\n   * Sets the 'natural' size of an element.\n   * This can also be specified when creating ElementSizer.\n   * @param size \n   */\n  setNaturalSize(size: Rect) {\n    this.#naturalSize = size;\n    this.#naturalRatio = size.width / size.height;\n  }\n\n  get naturalSize() {\n    return this.#naturalSize;\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  #computeSizeBasedOnParent(parentSize: Rects.Rect) {\n    let { width, height } = parentSize;\n\n    let stretch = this.#stretch;\n    if (stretch === `min`) {\n      stretch = width < height ? `width` : `height`;\n    } else if (stretch === `max`) {\n      stretch = width > height ? `width` : `height`;\n    }\n\n    if (stretch === `width`) {\n      height = width / this.#naturalRatio;\n    } else if (stretch === `height`) {\n      width = height * this.#naturalRatio;\n    }\n\n    // If we have a border, take that into account\n    if (this.#el instanceof HTMLElement) {\n      const b = getComputedPixels(this.#el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);\n      width -= (b.borderLeftWidth + b.borderRightWidth);\n      height -= (b.borderTopWidth + b.borderBottomWidth);\n    }\n\n    return { width, height };\n  }\n\n\n  #onParentResize(args: ResizeObserverEntry[]) {\n    const box = args[ 0 ].contentBoxSize[ 0 ];\n    const parentSize = { width: box.inlineSize, height: box.blockSize };\n    this.size = this.#computeSizeBasedOnParent(parentSize);\n    this.#viewport = {\n      x: 0, y: 0,\n      width: parentSize.width,\n      height: parentSize.height\n    }\n  }\n\n  set size(size: Rects.Rect) {\n    Rects.guard(size, `size`);\n    this.#size = size;\n    this.#onSetSize(size, this.#el);\n  }\n\n  get size() {\n    return this.#size;\n  }\n}","var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name2 in all)\n    __defProp(target, name2, { get: all[name2], enumerable: true });\n};\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/modules/invariant.ts\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n  if (process.env.NODE_ENV !== \"production\") {\n    if (message === void 0) {\n      throw new Error(\"invariant requires an error message argument\");\n    }\n  }\n  const error = !message ? new Error(\n    \"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\"\n  ) : new Error(message);\n  error.name = \"colorizr\";\n  throw error;\n}\n\n// src/modules/constants.ts\nvar COLOR_KEYS = {\n  hsl: [\"h\", \"s\", \"l\"],\n  oklab: [\"l\", \"a\", \"b\"],\n  oklch: [\"l\", \"c\", \"h\"],\n  rgb: [\"r\", \"g\", \"b\"]\n};\nvar COLOR_MODELS = [\"hsl\", \"oklab\", \"oklch\", \"rgb\"];\nvar DEG2RAD = Math.PI / 180;\nvar LAB_TO_LMS = {\n  l: [0.3963377773761749, 0.2158037573099136],\n  m: [-0.1055613458156586, -0.0638541728258133],\n  s: [-0.0894841775298119, -1.2914855480194092]\n};\nvar LRGB_TO_LMS = {\n  l: [0.4122214708, 0.5363325363, 0.0514459929],\n  m: [0.2119034982, 0.6806995451, 0.1073969566],\n  s: [0.0883024619, 0.2817188376, 0.6299787005]\n};\nvar LSM_TO_LAB = {\n  l: [0.2104542553, 0.793617785, 0.0040720468],\n  a: [1.9779984951, 2.428592205, 0.4505937099],\n  b: [0.0259040371, 0.7827717662, 0.808675766]\n};\nvar LSM_TO_RGB = {\n  r: [4.076741636075958, -3.307711539258063, 0.2309699031821043],\n  g: [-1.2684379732850315, 2.609757349287688, -0.341319376002657],\n  b: [-0.0041960761386756, -0.7034186179359362, 1.7076146940746117]\n};\nvar SRGB_TO_P3 = [\n  [0.8224270476, 0.1775729524, 0],\n  [0.0331008087, 0.9668991913, 0],\n  [0.0170720188, 0.0723477973, 0.9105801839]\n];\nvar PRECISION = 5;\nvar RAD2DEG = 180 / Math.PI;\nvar MESSAGES = {\n  alpha: \"amount must be a number between 0 and 1\",\n  hueRange: \"hue must be a number between 0 and 360\",\n  input: \"input is required\",\n  inputHex: \"input is required and must be a hex\",\n  inputNumber: \"input is required and must be a number\",\n  inputString: \"input is required and must be a string\",\n  invalid: \"invalid input\",\n  invalidCSS: \"invalid CSS string\",\n  left: \"left is required and must be a string\",\n  lightnessRange: \"lightness must be a number between 0 and 1\",\n  options: \"invalid options\",\n  right: \"right is required and must be a string\",\n  threshold: \"threshold must be a number between 0 and 255\"\n};\n\n// src/modules/css-colors.ts\nvar cssColors = {\n  aliceblue: \"#f0f8ff\",\n  antiquewhite: \"#faebd7\",\n  aqua: \"#00ffff\",\n  aquamarine: \"#7fffd4\",\n  azure: \"#f0ffff\",\n  beige: \"#f5f5dc\",\n  bisque: \"#ffe4c4\",\n  black: \"#000000\",\n  blanchedalmond: \"#ffebcd\",\n  blue: \"#0000ff\",\n  blueviolet: \"#8a2be2\",\n  brown: \"#a52a2a\",\n  burlywood: \"#deb887\",\n  cadetblue: \"#5f9ea0\",\n  chartreuse: \"#7fff00\",\n  chocolate: \"#d2691e\",\n  coral: \"#ff7f50\",\n  cornflowerblue: \"#6495ed\",\n  cornsilk: \"#fff8dc\",\n  crimson: \"#dc143c\",\n  cyan: \"#00ffff\",\n  darkblue: \"#00008b\",\n  darkcyan: \"#008b8b\",\n  darkgoldenrod: \"#b8860b\",\n  darkgray: \"#a9a9a9\",\n  darkgreen: \"#006400\",\n  darkkhaki: \"#bdb76b\",\n  darkmagenta: \"#8b008b\",\n  darkolivegreen: \"#556b2f\",\n  darkorange: \"#ff8c00\",\n  darkorchid: \"#9932cc\",\n  darkred: \"#8b0000\",\n  darksalmon: \"#e9967a\",\n  darkseagreen: \"#8fbc8f\",\n  darkslateblue: \"#483d8b\",\n  darkslategray: \"#2f4f4f\",\n  darkslategrey: \"#2f4f4f\",\n  darkturquoise: \"#00ced1\",\n  darkviolet: \"#9400d3\",\n  deeppink: \"#ff1493\",\n  deepskyblue: \"#00bfff\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1e90ff\",\n  firebrick: \"#b22222\",\n  floralwhite: \"#fffaf0\",\n  forestgreen: \"#228b22\",\n  fuchsia: \"#ff00ff\",\n  gainsboro: \"#dcdcdc\",\n  ghostwhite: \"#f8f8ff\",\n  gold: \"#ffd700\",\n  goldenrod: \"#daa520\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#adff2f\",\n  honeydew: \"#f0fff0\",\n  hotpink: \"#ff69b4\",\n  indianred: \"#cd5c5c\",\n  indigo: \"#4b0082\",\n  ivory: \"#fffff0\",\n  khaki: \"#f0e68c\",\n  lavender: \"#e6e6fa\",\n  lavenderblush: \"#fff0f5\",\n  lawngreen: \"#7cfc00\",\n  lemonchiffon: \"#fffacd\",\n  lightblue: \"#add8e6\",\n  lightcoral: \"#f08080\",\n  lightcyan: \"#e0ffff\",\n  lightgoldenrodyellow: \"#fafad2\",\n  lightgray: \"#d3d3d3\",\n  lightgreen: \"#90ee90\",\n  lightgrey: \"#d3d3d3\",\n  lightpink: \"#ffb6c1\",\n  lightsalmon: \"#ffa07a\",\n  lightseagreen: \"#20b2aa\",\n  lightskyblue: \"#87cefa\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#b0c4de\",\n  lightyellow: \"#ffffe0\",\n  lime: \"#00ff00\",\n  limegreen: \"#32cd32\",\n  linen: \"#faf0e6\",\n  magenta: \"#ff00ff\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66cdaa\",\n  mediumblue: \"#0000cd\",\n  mediumorchid: \"#ba55d3\",\n  mediumpurple: \"#9370db\",\n  mediumseagreen: \"#3cb371\",\n  mediumslateblue: \"#7b68ee\",\n  mediumspringgreen: \"#00fa9a\",\n  mediumturquoise: \"#48d1cc\",\n  mediumvioletred: \"#c71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#f5fffa\",\n  mistyrose: \"#ffe4e1\",\n  moccasin: \"#ffe4b5\",\n  navajowhite: \"#ffdead\",\n  navy: \"#000080\",\n  oldlace: \"#fdf5e6\",\n  olive: \"#808000\",\n  olivedrab: \"#6b8e23\",\n  orange: \"#ffa500\",\n  orangered: \"#ff4500\",\n  orchid: \"#da70d6\",\n  palegoldenrod: \"#eee8aa\",\n  palegreen: \"#98fb98\",\n  paleturquoise: \"#afeeee\",\n  palevioletred: \"#db7093\",\n  papayawhip: \"#ffefd5\",\n  peachpuff: \"#ffdab9\",\n  peru: \"#cd853f\",\n  pink: \"#ffc0cb\",\n  plum: \"#dda0dd\",\n  powderblue: \"#b0e0e6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#ff0000\",\n  rosybrown: \"#bc8f8f\",\n  royalblue: \"#4169e1\",\n  saddlebrown: \"#8b4513\",\n  salmon: \"#fa8072\",\n  sandybrown: \"#f4a460\",\n  seagreen: \"#2e8b57\",\n  seashell: \"#fff5ee\",\n  sienna: \"#a0522d\",\n  silver: \"#c0c0c0\",\n  skyblue: \"#87ceeb\",\n  slateblue: \"#6a5acd\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#fffafa\",\n  springgreen: \"#00ff7f\",\n  steelblue: \"#4682b4\",\n  tan: \"#d2b48c\",\n  teal: \"#008080\",\n  thistle: \"#d8bfd8\",\n  tomato: \"#ff6347\",\n  turquoise: \"#40e0d0\",\n  violet: \"#ee82ee\",\n  wheat: \"#f5deb3\",\n  white: \"#ffffff\",\n  whitesmoke: \"#f5f5f5\",\n  yellow: \"#ffff00\",\n  yellowgreen: \"#9acd32\"\n};\n\n// src/modules/validators.ts\nfunction hasValidMatches(input) {\n  return Array.isArray(input) && input.length === 6;\n}\nfunction isNamedColor(input) {\n  return isString(input) && Object.keys(cssColors).includes(input.toLowerCase());\n}\nfunction isNumber(input) {\n  return typeof input === \"number\" && !Number.isNaN(input);\n}\nfunction isPlainObject(input) {\n  if (!input) {\n    return false;\n  }\n  const { toString } = Object.prototype;\n  const prototype = Object.getPrototypeOf(input);\n  return toString.call(input) === \"[object Object]\" && (prototype === null || prototype === Object.getPrototypeOf({}));\n}\nfunction isString(input, validate = true) {\n  const isValid = typeof input === \"string\";\n  if (validate) {\n    return isValid && !!input.trim().length;\n  }\n  return isValid;\n}\nfunction isValidColorModel(input) {\n  return isHSL(input) || isRGB(input) || isLAB(input) || isLCH(input);\n}\nfunction isHex(input) {\n  if (!isString(input)) {\n    return false;\n  }\n  return /^#([\\da-f]{3,4}|[\\da-f]{6,8})$/i.test(input);\n}\nfunction isHSL(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"h\") {\n      return value >= 0 && value <= 360;\n    }\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.hsl.includes(key) && value >= 0 && value <= 100;\n  });\n}\nfunction isLAB(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"l\") {\n      return value >= 0 && value <= 100;\n    }\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.oklab.includes(key) && value >= -1 && value <= 1;\n  });\n}\nfunction isLCH(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"l\") {\n      return value >= 0 && value <= 100;\n    }\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.oklch.includes(key) && value >= 0 && value <= (key === \"h\" ? 360 : 1);\n  });\n}\nfunction isRGB(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(([key, value]) => {\n    if (key === \"alpha\") {\n      return value >= 0 && value <= 1;\n    }\n    return COLOR_KEYS.rgb.includes(key) && value >= 0 && value <= 255;\n  });\n}\n\n// src/modules/utils.ts\nfunction addAlpha(input, alpha) {\n  invariant(isValidColorModel(input), MESSAGES.invalid);\n  let value = alpha;\n  if (!value) {\n    return input;\n  }\n  if (value > 1) {\n    value /= 100;\n  }\n  if (value === 1) {\n    return input;\n  }\n  return { ...input, alpha: value };\n}\nfunction clamp(value, min = 0, max = 100) {\n  return Math.min(Math.max(value, min), max);\n}\nfunction constrainDegrees(input, amount) {\n  invariant(isNumber(input), MESSAGES.inputNumber);\n  let value = input + amount;\n  if (value > 360) {\n    value %= 360;\n  }\n  if (value < 0) {\n    value += 360;\n  }\n  return Math.abs(value);\n}\nfunction limit(input, model, key) {\n  invariant(isNumber(input), \"Input is not a number\");\n  invariant(COLOR_MODELS.includes(model), `Invalid model${model ? `: ${model}` : \"\"}`);\n  invariant(COLOR_KEYS[model].includes(key), `Invalid key${key ? `: ${key}` : \"\"}`);\n  switch (model) {\n    case \"hsl\": {\n      invariant(COLOR_KEYS.hsl.includes(key), \"Invalid key\");\n      if ([\"s\", \"l\"].includes(key)) {\n        return clamp(input);\n      }\n      return clamp(input, 0, 360);\n    }\n    case \"rgb\": {\n      invariant(COLOR_KEYS.rgb.includes(key), \"Invalid key\");\n      return clamp(input, 0, 255);\n    }\n    /* c8 ignore next 3 */\n    default: {\n      throw new Error(\"Invalid inputs\");\n    }\n  }\n}\nfunction parseInput(input, model) {\n  const keys = COLOR_KEYS[model];\n  const validator = {\n    hsl: isHSL,\n    oklab: isLAB,\n    oklch: isLCH,\n    rgb: isRGB\n  };\n  invariant(isPlainObject(input) || Array.isArray(input), MESSAGES.invalid);\n  const value = Array.isArray(input) ? { [keys[0]]: input[0], [keys[1]]: input[1], [keys[2]]: input[2] } : input;\n  invariant(validator[model](value), `invalid ${model} color`);\n  return value;\n}\nfunction restrictValues(input, precision = PRECISION, forcePrecision = true) {\n  const output = new Map(Object.entries(input));\n  for (const [key, value] of output.entries()) {\n    output.set(key, round(value, precision, forcePrecision));\n  }\n  return Object.fromEntries(output);\n}\nfunction round(input, precision = 2, forcePrecision = true) {\n  if (!isNumber(input) || input === 0) {\n    return 0;\n  }\n  if (forcePrecision) {\n    const factor2 = 10 ** precision;\n    return Math.round(input * factor2) / factor2;\n  }\n  const absInput = Math.abs(input);\n  let digits = Math.abs(Math.ceil(Math.log(absInput) / Math.LN10));\n  if (digits === 0) {\n    digits = 2;\n  } else if (digits > precision) {\n    digits = precision;\n  }\n  let exponent = precision - (digits < 0 ? 0 : digits);\n  if (exponent <= 1 && precision > 1) {\n    exponent = 2;\n  } else if (exponent > precision || exponent === 0) {\n    exponent = precision;\n  }\n  const factor = 10 ** exponent;\n  return Math.round(input * factor) / factor;\n}\n\n// src/modules/hex-utils.ts\nfunction addAlphaToHex(input, alpha) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  invariant(isNumber(alpha), MESSAGES.inputNumber);\n  if (alpha >= 1) {\n    return removeAlphaFromHex(input);\n  }\n  return `${removeAlphaFromHex(input)}${convertAlphaToHex(alpha)}`;\n}\nfunction convertAlphaToHex(input) {\n  invariant(isNumber(input), MESSAGES.inputNumber);\n  let alpha = input;\n  if (input > 1) {\n    alpha /= 100;\n  }\n  return Math.round(alpha * 255).toString(16).padStart(2, \"0\");\n}\nfunction extractAlphaFromHex(input) {\n  invariant(isHex(input), MESSAGES.inputString);\n  const alpha = input.substring(7, 9);\n  if (!alpha) {\n    return 1;\n  }\n  return round(parseInt(alpha, 16) / 255);\n}\nfunction hexadecimalToNumber(input) {\n  return round(parseInt(input, 16));\n}\nfunction removeAlphaFromHex(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  if (input.length === 5) {\n    return input.substring(0, 4);\n  }\n  return input.substring(0, 7);\n}\n\n// src/converters/index.ts\nvar converters_exports = {};\n__export(converters_exports, {\n  hex2hsl: () => hex2hsl,\n  hex2oklab: () => hex2oklab,\n  hex2oklch: () => hex2oklch,\n  hex2rgb: () => hex2rgb,\n  hsl2hex: () => hsl2hex,\n  hsl2oklab: () => hsl2oklab,\n  hsl2oklch: () => hsl2oklch,\n  hsl2rgb: () => hsl2rgb,\n  oklab2hex: () => oklab2hex,\n  oklab2hsl: () => oklab2hsl,\n  oklab2oklch: () => oklab2oklch,\n  oklab2rgb: () => oklab2rgb,\n  oklch2hex: () => oklch2hex,\n  oklch2hsl: () => oklch2hsl,\n  oklch2oklab: () => oklch2oklab,\n  oklch2rgb: () => oklch2rgb,\n  rgb2hex: () => rgb2hex,\n  rgb2hsl: () => rgb2hsl,\n  rgb2oklab: () => rgb2oklab,\n  rgb2oklch: () => rgb2oklch\n});\n\n// src/format-hex.ts\nfunction formatHex(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  let color = input.replace(\"#\", \"\");\n  if (color.length === 3 || color.length === 4) {\n    const values = [...color];\n    color = \"\";\n    values.forEach((d) => {\n      color += `${d}${d}`;\n    });\n  }\n  const hex = `#${color}`;\n  invariant(isHex(hex), \"invalid hex\");\n  return hex;\n}\n\n// src/converters/hex2rgb.ts\nfunction hex2rgb(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  const hex = formatHex(input).slice(1);\n  return {\n    r: parseInt(hex.charAt(0) + hex.charAt(1), 16),\n    g: parseInt(hex.charAt(2) + hex.charAt(3), 16),\n    b: parseInt(hex.charAt(4) + hex.charAt(5), 16)\n  };\n}\n\n// src/converters/rgb2hsl.ts\nfunction rgb2hsl(input) {\n  const value = parseInput(input, \"rgb\");\n  const rLimit = limit(value.r, \"rgb\", \"r\") / 255;\n  const gLimit = limit(value.g, \"rgb\", \"g\") / 255;\n  const bLimit = limit(value.b, \"rgb\", \"b\") / 255;\n  const min = Math.min(rLimit, gLimit, bLimit);\n  const max = Math.max(rLimit, gLimit, bLimit);\n  const delta = max - min;\n  let h = 0;\n  let s;\n  const l = (max + min) / 2;\n  let rate;\n  switch (max) {\n    case rLimit:\n      rate = !delta ? 0 : (gLimit - bLimit) / delta;\n      h = 60 * rate;\n      break;\n    case gLimit:\n      rate = (bLimit - rLimit) / delta;\n      h = 60 * rate + 120;\n      break;\n    case bLimit:\n      rate = (rLimit - gLimit) / delta;\n      h = 60 * rate + 240;\n      break;\n    /* c8 ignore next 2 */\n    default:\n      break;\n  }\n  if (h < 0) {\n    h = 360 + h;\n  }\n  if (min === max) {\n    s = 0;\n  } else {\n    s = l < 0.5 ? delta / (2 * l) : delta / (2 - 2 * l);\n  }\n  return {\n    h: Math.abs(+(h % 360).toFixed(2)),\n    s: +(s * 100).toFixed(2),\n    l: +(l * 100).toFixed(2)\n  };\n}\n\n// src/converters/hex2hsl.ts\nfunction hex2hsl(input) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  return rgb2hsl(hex2rgb(input));\n}\n\n// src/converters/rgb2oklab.ts\nvar { cbrt, sign } = Math;\nfunction rgb2lrgb(input) {\n  const abs2 = Math.abs(input);\n  if (abs2 < 0.04045) {\n    return input / 12.92;\n  }\n  return (sign(input) || 1) * ((abs2 + 0.055) / 1.055) ** 2.4;\n}\nfunction rgb2oklab(input, precision = PRECISION) {\n  const value = parseInput(input, \"rgb\");\n  const [lr, lg, lb] = [rgb2lrgb(value.r / 255), rgb2lrgb(value.g / 255), rgb2lrgb(value.b / 255)];\n  const l = cbrt(LRGB_TO_LMS.l[0] * lr + LRGB_TO_LMS.l[1] * lg + LRGB_TO_LMS.l[2] * lb);\n  const m = cbrt(LRGB_TO_LMS.m[0] * lr + LRGB_TO_LMS.m[1] * lg + LRGB_TO_LMS.m[2] * lb);\n  const s = cbrt(LRGB_TO_LMS.s[0] * lr + LRGB_TO_LMS.s[1] * lg + LRGB_TO_LMS.s[2] * lb);\n  const lab = {\n    l: LSM_TO_LAB.l[0] * l + LSM_TO_LAB.l[1] * m - LSM_TO_LAB.l[2] * s,\n    a: LSM_TO_LAB.a[0] * l - LSM_TO_LAB.a[1] * m + LSM_TO_LAB.a[2] * s,\n    b: LSM_TO_LAB.b[0] * l + LSM_TO_LAB.b[1] * m - LSM_TO_LAB.b[2] * s\n  };\n  return restrictValues(lab, precision);\n}\n\n// src/converters/hex2oklab.ts\nfunction hex2oklab(input, precision) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  return rgb2oklab(hex2rgb(input), precision);\n}\n\n// src/converters/oklab2oklch.ts\nvar { atan2, sqrt } = Math;\nfunction oklab2oklch(input, precision) {\n  const { l, a, b } = restrictValues(parseInput(input, \"oklab\"));\n  const c = sqrt(a ** 2 + b ** 2);\n  let h = (atan2(b, a) * RAD2DEG + 360) % 360;\n  if (round(c * 1e4) === 0) {\n    h = 0;\n  }\n  return restrictValues({ l, c, h }, precision);\n}\n\n// src/converters/rgb2oklch.ts\nfunction rgb2oklch(input, precision) {\n  const value = parseInput(input, \"rgb\");\n  return oklab2oklch(rgb2oklab(value, precision), precision);\n}\n\n// src/converters/hex2oklch.ts\nfunction hex2oklch(input, precision) {\n  invariant(isHex(input), MESSAGES.inputHex);\n  return rgb2oklch(hex2rgb(input), precision);\n}\n\n// src/modules/hue2rgb.ts\nfunction hue2rgb(point, chroma2, h) {\n  invariant(isNumber(point) && isNumber(chroma2) && isNumber(h), \"point, chroma and h are required\");\n  let hue = h;\n  if (hue < 0) {\n    hue += 1;\n  }\n  if (hue > 1) {\n    hue -= 1;\n  }\n  if (hue < 1 / 6) {\n    return round(point + (chroma2 - point) * 6 * hue, 4);\n  }\n  if (hue < 1 / 2) {\n    return round(chroma2, 4);\n  }\n  if (hue < 2 / 3) {\n    return round(point + (chroma2 - point) * (2 / 3 - hue) * 6, 4);\n  }\n  return round(point, 4);\n}\n\n// src/converters/hsl2rgb.ts\nfunction hsl2rgb(input) {\n  const value = parseInput(input, \"hsl\");\n  const h = round(value.h) / 360;\n  const s = round(value.s) / 100;\n  const l = round(value.l) / 100;\n  let r;\n  let g;\n  let b;\n  let point;\n  let chroma2;\n  if (s === 0) {\n    r = l;\n    g = l;\n    b = l;\n  } else {\n    chroma2 = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    point = 2 * l - chroma2;\n    r = hue2rgb(point, chroma2, h + 1 / 3);\n    g = hue2rgb(point, chroma2, h);\n    b = hue2rgb(point, chroma2, h - 1 / 3);\n  }\n  return {\n    r: Math.round(r * 255),\n    g: Math.round(g * 255),\n    b: Math.round(b * 255)\n  };\n}\n\n// src/converters/rgb2hex.ts\nfunction rgb2hex(input) {\n  const rgb = parseInput(input, \"rgb\");\n  return `#${Object.values(rgb).map((d) => `0${Math.floor(d).toString(16)}`.slice(-2)).join(\"\")}`;\n}\n\n// src/converters/hsl2hex.ts\nfunction hsl2hex(input) {\n  const value = parseInput(input, \"hsl\");\n  return rgb2hex(hsl2rgb(value));\n}\n\n// src/converters/hsl2oklab.ts\nfunction hsl2oklab(input, precision) {\n  const value = parseInput(input, \"hsl\");\n  return rgb2oklab(hsl2rgb(value), precision);\n}\n\n// src/converters/hsl2oklch.ts\nfunction hsl2oklch(input, precision) {\n  const value = parseInput(input, \"hsl\");\n  return rgb2oklch(hsl2rgb(value), precision);\n}\n\n// src/converters/oklab2rgb.ts\nvar { abs } = Math;\nfunction lrgb2rgb(input) {\n  const absoluteNumber = abs(input);\n  const sign2 = input < 0 ? -1 : 1;\n  if (absoluteNumber > 31308e-7) {\n    return sign2 * (absoluteNumber ** (1 / 2.4) * 1.055 - 0.055);\n  }\n  return input * 12.92;\n}\nfunction oklab2rgb(input, precision = 0) {\n  const { l: L, a: A, b: B } = parseInput(input, \"oklab\");\n  const l = (L + LAB_TO_LMS.l[0] * A + LAB_TO_LMS.l[1] * B) ** 3;\n  const m = (L + LAB_TO_LMS.m[0] * A + LAB_TO_LMS.m[1] * B) ** 3;\n  const s = (L + LAB_TO_LMS.s[0] * A + LAB_TO_LMS.s[1] * B) ** 3;\n  const r = 255 * lrgb2rgb(LSM_TO_RGB.r[0] * l + LSM_TO_RGB.r[1] * m + LSM_TO_RGB.r[2] * s);\n  const g = 255 * lrgb2rgb(LSM_TO_RGB.g[0] * l + LSM_TO_RGB.g[1] * m + LSM_TO_RGB.g[2] * s);\n  const b = 255 * lrgb2rgb(LSM_TO_RGB.b[0] * l + LSM_TO_RGB.b[1] * m + LSM_TO_RGB.b[2] * s);\n  return {\n    r: clamp(round(r, precision), 0, 255),\n    g: clamp(round(g, precision), 0, 255),\n    b: clamp(round(b, precision), 0, 255)\n  };\n}\n\n// src/converters/oklab2hex.ts\nfunction oklab2hex(input) {\n  const value = parseInput(input, \"oklab\");\n  return rgb2hex(oklab2rgb(value));\n}\n\n// src/converters/oklab2hsl.ts\nfunction oklab2hsl(input) {\n  const value = parseInput(input, \"oklab\");\n  return rgb2hsl(oklab2rgb(value));\n}\n\n// src/converters/oklch2oklab.ts\nvar { sin, cos } = Math;\nfunction oklch2oklab(input, precision) {\n  let { l, c, h } = parseInput(input, \"oklch\");\n  if (Number.isNaN(h) || h < 0) {\n    h = 0;\n  }\n  return restrictValues({ l, a: c * cos(h * DEG2RAD), b: c * sin(h * DEG2RAD) }, precision);\n}\n\n// src/converters/oklch2rgb.ts\nfunction oklch2rgb(input, precision = 0) {\n  const value = parseInput(input, \"oklch\");\n  return oklab2rgb(oklch2oklab(value), precision);\n}\n\n// src/converters/oklch2hex.ts\nfunction oklch2hex(input) {\n  const value = parseInput(input, \"oklch\");\n  return rgb2hex(oklch2rgb(value));\n}\n\n// src/converters/oklch2hsl.ts\nfunction oklch2hsl(input) {\n  const value = parseInput(input, \"oklch\");\n  return rgb2hsl(oklch2rgb(value));\n}\n\n// src/extract-color-parts.ts\nfunction extractColorParts(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  if (isHex(input)) {\n    const keys2 = COLOR_KEYS.rgb;\n    const { r, g, b } = hex2rgb(input);\n    const alpha2 = extractAlphaFromHex(input);\n    return {\n      model: \"rgb\",\n      [keys2[0]]: r,\n      [keys2[1]]: g,\n      [keys2[2]]: b,\n      alpha: alpha2 < 1 ? alpha2 : void 0\n    };\n  }\n  const colorRegex = /(?:(rgb|hsl|oklab|oklch)a?\\s*\\(\\s*([\\d%.-]+)\\s*[ ,/]\\s*([\\d%.-]+)\\s*[ ,/]\\s*([\\d%.-]+)(?:\\s*[ ,/]\\s*([\\d%.-]+))?\\s*\\))/i;\n  const matches = colorRegex.exec(input);\n  invariant(hasValidMatches(matches), MESSAGES.invalidCSS);\n  const model = matches[1];\n  const keys = COLOR_KEYS[model];\n  let alpha = matches[5] ? parseFloat(matches[5]) : 1;\n  if (alpha > 1) {\n    alpha /= 100;\n  }\n  return {\n    model,\n    [keys[0]]: parseFloat(matches[2]),\n    [keys[1]]: parseFloat(matches[3]),\n    [keys[2]]: parseFloat(matches[4]),\n    alpha: alpha < 1 ? alpha : void 0\n  };\n}\n\n// src/parse-css.ts\nfunction parseCSS(input, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  let result;\n  const value = isNamedColor(input) ? cssColors[input.toLowerCase()] : input;\n  const output = format ?? (isHex(value) ? \"hex\" : extractColorParts(value).model);\n  const colorParams = (params) => Object.values(params);\n  if (isHex(value)) {\n    const alpha = extractAlphaFromHex(value);\n    switch (output) {\n      case \"hsl\": {\n        result = addAlpha(hex2hsl(value), alpha);\n        break;\n      }\n      case \"oklab\": {\n        result = addAlpha(hex2oklab(value), alpha);\n        break;\n      }\n      case \"oklch\": {\n        result = addAlpha(hex2oklch(value), alpha);\n        break;\n      }\n      case \"rgb\": {\n        result = addAlpha(hex2rgb(value), alpha);\n        break;\n      }\n      default: {\n        result = `${removeAlphaFromHex(value)}${alpha !== 1 ? convertAlphaToHex(alpha) : \"\"}`;\n        break;\n      }\n    }\n    return result;\n  }\n  switch (output) {\n    case \"hsl\": {\n      const { alpha, model, ...color } = extractColorParts(value);\n      if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n      result = addAlpha(\n        model === \"hsl\" ? color : converters_exports[`${model}2hsl`](colorParams(color)),\n        alpha\n      );\n      break;\n    }\n    case \"oklab\": {\n      const { alpha, model, ...color } = extractColorParts(value);\n      if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n      result = addAlpha(\n        model === \"oklab\" ? color : converters_exports[`${model}2oklab`](colorParams(color)),\n        alpha\n      );\n      break;\n    }\n    case \"oklch\": {\n      const { alpha, model, ...color } = extractColorParts(value);\n      if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n      result = addAlpha(\n        model === \"oklch\" ? color : converters_exports[`${model}2oklch`](colorParams(color)),\n        alpha\n      );\n      break;\n    }\n    case \"rgb\": {\n      const { alpha, model, ...color } = extractColorParts(value);\n      if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n        color.l /= 100;\n      }\n      result = addAlpha(\n        model === \"rgb\" ? color : converters_exports[`${model}2rgb`](colorParams(color)),\n        alpha\n      );\n      break;\n    }\n    case \"hex\":\n    default: {\n      const { alpha, model, ...color } = extractColorParts(value);\n      let alphaPrefix = \"\";\n      if ([\"oklab\", \"oklch\"].includes(model) && color.l > 1) {\n        color.l = round(color.l / 100, PRECISION);\n      }\n      if (alpha) {\n        alphaPrefix = convertAlphaToHex(alpha);\n      }\n      result = `${converters_exports[`${model}2hex`](colorParams(color))}${alphaPrefix}`;\n      break;\n    }\n  }\n  return result;\n}\n\n// src/modules/parse-color.ts\nfunction parseColor(color) {\n  invariant(!!color, MESSAGES.input);\n  const output = {};\n  if (isString(color)) {\n    const { alpha = 1 } = extractColorParts(color);\n    const type = isHex(color) ? \"hex\" : extractColorParts(color).model;\n    output.hex = addAlphaToHex(parseCSS(color, \"hex\"), alpha);\n    output.hsl = addAlpha(parseCSS(color, \"hsl\"), alpha);\n    output.oklab = addAlpha(parseCSS(color, \"oklab\"), alpha);\n    output.oklch = addAlpha(parseCSS(color, \"oklch\"), alpha);\n    output.rgb = addAlpha(parseCSS(color, \"rgb\"), alpha);\n    output.alpha = alpha;\n    output.type = type;\n  } else if (isPlainObject(color)) {\n    const { alpha = 1 } = color;\n    if (isHSL(color)) {\n      output.hsl = {\n        h: limit(color.h, \"hsl\", \"h\"),\n        s: limit(color.s, \"hsl\", \"s\"),\n        l: limit(color.l, \"hsl\", \"l\")\n      };\n      output.rgb = hsl2rgb(output.hsl);\n      output.oklab = hsl2oklab(output.hsl);\n      output.oklch = hsl2oklch(output.hsl);\n      output.type = \"hsl\";\n    } else if (isLAB(color)) {\n      output.hsl = oklab2hsl(color);\n      output.oklab = color;\n      output.oklch = oklab2oklch(color);\n      output.rgb = oklab2rgb(color);\n      output.type = \"oklab\";\n    } else if (isLCH(color)) {\n      output.hsl = oklch2hsl(color);\n      output.oklab = oklch2oklab(color);\n      output.oklch = color;\n      output.rgb = oklch2rgb(color);\n      output.type = \"oklch\";\n    } else if (isRGB(color)) {\n      output.rgb = {\n        r: limit(color.r, \"rgb\", \"r\"),\n        g: limit(color.g, \"rgb\", \"g\"),\n        b: limit(color.b, \"rgb\", \"b\")\n      };\n      output.hsl = rgb2hsl(output.rgb);\n      output.oklab = rgb2oklab(output.rgb);\n      output.oklch = rgb2oklch(output.rgb);\n      output.type = \"rgb\";\n    } else {\n      throw new Error(\"invalid color\");\n    }\n    output.hex = addAlphaToHex(hsl2hex(output.hsl), alpha);\n    output.hsl = addAlpha(output.hsl, alpha);\n    output.oklab = addAlpha(output.oklab, alpha);\n    output.oklch = addAlpha(output.oklch, alpha);\n    output.rgb = addAlpha(output.rgb, alpha);\n    output.alpha = alpha;\n  } else {\n    throw new Error(MESSAGES.input);\n  }\n  return output;\n}\n\n// src/brightness-difference.ts\nfunction brightnessDifference(left, right, precision = PRECISION) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const RGBLeft = parseCSS(left, \"rgb\");\n  const RGBRight = parseCSS(right, \"rgb\");\n  const brightnessLeft = (RGBLeft.r * 299 + RGBLeft.g * 587 + RGBLeft.b * 114) / 1e3;\n  const brightnessRight = (RGBRight.r * 299 + RGBRight.g * 587 + RGBRight.b * 114) / 1e3;\n  return round(Math.abs(brightnessRight - brightnessLeft), precision);\n}\n\n// src/chroma.ts\nfunction chroma(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const { r, g, b } = parseCSS(input, \"rgb\");\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  return round((max - min) / 255, 4);\n}\n\n// src/color-difference.ts\nfunction colorDifference(left, right) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const RGBLeft = parseCSS(left, \"rgb\");\n  const RGBRight = parseCSS(right, \"rgb\");\n  return Math.max(RGBLeft.r, RGBRight.r) - Math.min(RGBLeft.r, RGBRight.r) + (Math.max(RGBLeft.g, RGBRight.g) - Math.min(RGBLeft.g, RGBRight.g)) + (Math.max(RGBLeft.b, RGBRight.b) - Math.min(RGBLeft.b, RGBRight.b));\n}\n\n// src/luminance.ts\nfunction luminance(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const { r, g, b } = parseCSS(input, \"rgb\");\n  const rgb = [r / 255, g / 255, b / 255];\n  for (let index = 0; index < rgb.length; index++) {\n    if (rgb[index] <= 0.03928) {\n      rgb[index] /= 12.92;\n    } else {\n      rgb[index] = ((rgb[index] + 0.055) / 1.055) ** 2.4;\n    }\n  }\n  return round(0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2], 4);\n}\n\n// src/contrast.ts\nfunction contrast(left, right) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const LuminanceLeft = luminance(left);\n  const LuminanceRight = luminance(right);\n  return round(\n    LuminanceLeft >= LuminanceRight ? (LuminanceLeft + 0.05) / (LuminanceRight + 0.05) : (LuminanceRight + 0.05) / (LuminanceLeft + 0.05)\n  );\n}\n\n// src/compare.ts\nfunction compare(left, right) {\n  invariant(isString(left), MESSAGES.left);\n  invariant(isString(right), MESSAGES.right);\n  const colorThreshold = 500;\n  const brightnessThreshold = 125;\n  const colorDifference2 = colorDifference(left, right);\n  const contrast2 = contrast(left, right);\n  const brightnessDifference2 = brightnessDifference(left, right);\n  const isBright = brightnessDifference2 >= brightnessThreshold;\n  const hasEnoughDifference = colorDifference2 >= colorThreshold;\n  let compliant = 0;\n  if (isBright && hasEnoughDifference) {\n    compliant = 2;\n  } else if (isBright || hasEnoughDifference) {\n    compliant = 1;\n  }\n  return {\n    brightnessDifference: brightnessDifference2,\n    colorDifference: colorDifference2,\n    compliant,\n    contrast: contrast2,\n    largeAA: contrast2 >= 3,\n    largeAAA: contrast2 >= 4.5,\n    normalAA: contrast2 >= 4.5,\n    normalAAA: contrast2 >= 7\n  };\n}\n\n// src/format-css.ts\nfunction getColorModel(input) {\n  if (isHex(input) || isNamedColor(input)) {\n    return \"hex\";\n  }\n  if (isString(input)) {\n    return extractColorParts(input).model;\n  } else if (isHSL(input)) {\n    return \"hsl\";\n  } else if (isLAB(input)) {\n    return \"oklab\";\n  } else if (isLCH(input)) {\n    return \"oklch\";\n  } else if (isRGB(input)) {\n    return \"rgb\";\n  }\n  throw new Error(MESSAGES.invalid);\n}\nfunction getColorValue(input, output) {\n  const value = isNamedColor(input) ? cssColors[input.toLowerCase()] : input;\n  const from = getColorModel(value);\n  if (from === output) {\n    return value;\n  }\n  const converterKey = `${from}2${output}`;\n  const converter = converters_exports[converterKey];\n  if (!converter) {\n    throw new Error(`Converter not found for ${from} to ${output}`);\n  }\n  switch (from) {\n    case \"hex\": {\n      if (output === \"hex\") {\n        return value;\n      }\n      return converter(value);\n    }\n    case \"hsl\": {\n      if (output === \"hsl\") {\n        return value;\n      }\n      return converter(value);\n    }\n    case \"oklab\": {\n      if (output === \"oklab\") {\n        return value;\n      }\n      return converter(value);\n    }\n    case \"oklch\": {\n      if (output === \"oklch\") {\n        return value;\n      }\n      return converter(value);\n    }\n    default: {\n      if (output === \"rgb\") {\n        return value;\n      }\n      return converter(value);\n    }\n  }\n}\nfunction formatCSS(input, options = {}) {\n  invariant(isHex(input) || isValidColorModel(input), MESSAGES.invalid);\n  const { alpha, format = \"hex\", precision = PRECISION, separator: baseSeparator = \" \" } = options;\n  const opacity2 = alpha && alpha !== 1 ? `${round(alpha * 100)}%` : null;\n  let params = [];\n  let separator = baseSeparator;\n  switch (format) {\n    case \"hsl\": {\n      const { h, s, l } = getColorValue(input, \"hsl\");\n      params = [h, `${s}%`, `${l}%`];\n      break;\n    }\n    case \"oklab\": {\n      separator = \" \";\n      const { l, a, b } = restrictValues(getColorValue(input, \"oklab\"), precision);\n      params = [`${round(l * 100, precision)}%`, a, b];\n      break;\n    }\n    case \"oklch\": {\n      separator = \" \";\n      const { l, c, h } = restrictValues(getColorValue(input, \"oklch\"), precision);\n      params = [`${round(l * 100, precision)}%`, c, h];\n      break;\n    }\n    case \"rgb\": {\n      const { r, g, b } = getColorValue(input, \"rgb\");\n      params = [r, g, b];\n      break;\n    }\n    default: {\n      const hex = removeAlphaFromHex(getColorValue(input, \"hex\"));\n      if (alpha && alpha !== 1) {\n        return `${hex}${convertAlphaToHex(alpha)}`;\n      }\n      return hex;\n    }\n  }\n  return `${format}(${params.join(separator)}${opacity2 ? ` / ${opacity2}` : \"\"})`;\n}\n\n// src/modules/updater.ts\nfunction updater(key, operator, format) {\n  return (input, amount) => {\n    invariant(isString(input), MESSAGES.inputString);\n    invariant(isNumber(amount), MESSAGES.alpha);\n    const color = parseCSS(input, \"hsl\");\n    const output = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n    return formatCSS(\n      {\n        ...color,\n        [key]: clamp(color[key] + (operator === \"+\" ? amount : -amount), 0, 100)\n      },\n      { format: format ?? output }\n    );\n  };\n}\n\n// src/darken.ts\nfunction darken(input, amount, format) {\n  return updater(\"l\", \"-\", format)(input, amount);\n}\n\n// src/desaturate.ts\nfunction desaturate(input, amount, format) {\n  return updater(\"s\", \"-\", format)(input, amount);\n}\n\n// src/rotate.ts\nfunction rotate(input, degrees, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(degrees), \"degrees must be a number\");\n  const color = parseCSS(input, \"hsl\");\n  const output = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  return formatCSS(\n    {\n      ...color,\n      h: constrainDegrees(color.h, degrees)\n    },\n    { format: format ?? output }\n  );\n}\n\n// src/invert.ts\nfunction invert(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const format = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const hex = parseCSS(input, \"hex\");\n  return formatCSS(rotate(hex, 180), { format });\n}\n\n// src/lighten.ts\nfunction lighten(input, amount, format) {\n  return updater(\"l\", \"+\", format)(input, amount);\n}\n\n// src/opacify.ts\nfunction opacify(input, alpha, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(alpha), MESSAGES.alpha);\n  const type = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const rgb = parseCSS(input, \"rgb\");\n  return formatCSS(rgb, { format: format ?? type, alpha });\n}\n\n// src/opacity.ts\nfunction opacity(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  if (isHex(input)) {\n    return extractAlphaFromHex(input);\n  } else if (Object.keys(cssColors).includes(input)) {\n    return 1;\n  }\n  const { alpha } = extractColorParts(input);\n  if (!alpha) {\n    return 1;\n  }\n  return alpha;\n}\n\n// src/saturate.ts\nfunction saturate(input, amount, format) {\n  return updater(\"s\", \"+\", format)(input, amount);\n}\n\n// src/text-color.ts\nfunction textColor(input, options = {}) {\n  const { darkColor = \"#000000\", lightColor = \"#ffffff\", threshold = 128 } = options;\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(threshold >= 0 && threshold <= 255, MESSAGES.threshold);\n  try {\n    const { r, g, b } = hex2rgb(parseCSS(input, \"hex\"));\n    const yiq = (r * 299 + g * 587 + b * 114) / 1e3;\n    return yiq >= threshold ? darkColor : lightColor;\n  } catch (error) {\n    console.warn(`Invalid color input: ${input}`);\n    console.warn(error);\n    return darkColor;\n  }\n}\n\n// src/transparentize.ts\nfunction transparentize(input, alpha, format) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isNumber(alpha), MESSAGES.alpha);\n  invariant(alpha >= -1 && alpha <= 1, MESSAGES.alpha);\n  const oklch = parseCSS(input, \"oklab\");\n  const value = round(clamp(opacity(input) - alpha, 0, 1));\n  return formatCSS(oklch, { format, alpha: value });\n}\n\n// src/colorizr.ts\nvar Colorizr = class {\n  constructor(color, options = {}) {\n    __publicField(this, \"alpha\");\n    __publicField(this, \"hex\");\n    __publicField(this, \"hsl\");\n    __publicField(this, \"oklab\");\n    __publicField(this, \"oklch\");\n    __publicField(this, \"rgb\");\n    __publicField(this, \"type\");\n    invariant(!!color, \"color is required\");\n    const { alpha, hex, hsl, oklab, oklch, rgb, type } = parseColor(color);\n    this.hex = hex;\n    this.hsl = hsl;\n    this.oklab = oklab;\n    this.oklch = oklch;\n    this.rgb = rgb;\n    this.alpha = alpha;\n    this.type = options.format ?? type;\n  }\n  /**\n   * Get css string\n   */\n  get css() {\n    return this.selectedColor;\n  }\n  /**\n   * Get the red value\n   */\n  get red() {\n    return Number(this.rgb.r);\n  }\n  /**\n   * Get the green value\n   */\n  get green() {\n    return Number(this.rgb.g);\n  }\n  /**\n   * Get the blue value\n   */\n  get blue() {\n    return Number(this.rgb.b);\n  }\n  /**\n   * Get the hue value\n   */\n  get hue() {\n    return Number(this.hsl.h);\n  }\n  /**\n   * Get the saturation value\n   */\n  get saturation() {\n    return Number(this.hsl.s);\n  }\n  /**\n   * Get the lightness value\n   */\n  get lightness() {\n    return Number(this.hsl.l);\n  }\n  /**\n   * Get the luminance value\n   */\n  get luminance() {\n    return luminance(this.selectedColor);\n  }\n  /**\n   * Get the chroma value\n   */\n  get chroma() {\n    return chroma(this.selectedColor);\n  }\n  get opacity() {\n    return opacity(this.selectedColor);\n  }\n  /**\n   * Get the contrasted color\n   */\n  get textColor() {\n    return textColor(this.selectedColor);\n  }\n  get selectedColor() {\n    return formatCSS(this[this.type], { format: this.type, alpha: this.alpha });\n  }\n  brightnessDifference(input) {\n    return brightnessDifference(this.selectedColor, input);\n  }\n  colorDifference(input) {\n    return colorDifference(this.selectedColor, input);\n  }\n  /**\n   * Test 2 colors for compliance\n   */\n  compare(input) {\n    return compare(this.selectedColor, input);\n  }\n  contrast(input) {\n    return contrast(this.selectedColor, input);\n  }\n  format(type, precision) {\n    return formatCSS(this.rgb, {\n      alpha: this.alpha,\n      format: type,\n      precision\n    });\n  }\n  /**\n   * Increase lightness\n   */\n  lighten(amount) {\n    return lighten(this.selectedColor, amount);\n  }\n  /**\n   * Decrease lightness\n   */\n  darken(amount) {\n    return darken(this.selectedColor, amount);\n  }\n  /**\n   * Increase saturation\n   */\n  saturate(amount) {\n    return saturate(this.selectedColor, amount);\n  }\n  /**\n   * Decrease saturation\n   */\n  desaturate(amount) {\n    return desaturate(this.selectedColor, amount);\n  }\n  /**\n   * Invert color\n   */\n  invert() {\n    return invert(this.selectedColor);\n  }\n  /**\n   * Add opacity to the color.\n   */\n  opacify(alpha = 0.9) {\n    return opacify(this.selectedColor, alpha, this.type);\n  }\n  /**\n   * Rotate color\n   */\n  rotate(degrees) {\n    return rotate(this.selectedColor, degrees);\n  }\n  /**\n   * Make the color more transparent\n   */\n  transparentize(alpha = 0.1) {\n    return transparentize(this.selectedColor, alpha, this.type);\n  }\n};\n\n// src/convert.ts\nfunction convert(input, format) {\n  const value = parseCSS(input, format);\n  return formatCSS(value, { format });\n}\n\n// src/is-valid-color.ts\nfunction isValidColor(input) {\n  try {\n    parseCSS(input);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// src/name.ts\nfunction name(input) {\n  invariant(isString(input), MESSAGES.inputString);\n  const hex = parseCSS(input, \"hex\");\n  const [color] = Object.entries(cssColors).find(([, value]) => value === hex) || [];\n  return color ?? hex;\n}\n\n// src/palette.ts\nfunction palette(input, options = {}) {\n  invariant(isString(input), MESSAGES.inputString);\n  invariant(isPlainObject(options), MESSAGES.options);\n  const { format, lightness, saturation, size = 6, type } = options;\n  const hsl = parseCSS(input, \"hsl\");\n  const colorFormat = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const output = [];\n  if (type === \"monochromatic\") {\n    const step = 80 / size;\n    for (let index = size; index > 0; index--) {\n      output.push(hsl2hex({ ...hsl, l: step * index }));\n    }\n  } else {\n    const step = 360 / size;\n    output.push(hsl2hex({ ...hsl, l: lightness ?? hsl.l, s: saturation ?? hsl.s }));\n    for (let index = 1; index < size; index++) {\n      const color = rotate(input, hsl.h + step * index, \"hex\");\n      output.push(hsl2hex({ ...hex2hsl(color), l: lightness ?? hsl.l, s: saturation ?? hsl.s }));\n    }\n  }\n  return output.map((color) => convert(color, format ?? colorFormat));\n}\n\n// src/p3.ts\nfunction multiplyMatrix(matrix, vector) {\n  return [\n    matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],\n    matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],\n    matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2]\n  ];\n}\nfunction isInP3Gamut(color) {\n  const epsilon = 1e-6;\n  return color.every((component) => component >= 0 - epsilon && component <= 1 + epsilon);\n}\nfunction oklabToLinearSRGB(L, a, b) {\n  const l = (L + LAB_TO_LMS.l[0] * a + LAB_TO_LMS.l[1] * b) ** 3;\n  const m = (L + LAB_TO_LMS.m[0] * a + LAB_TO_LMS.m[1] * b) ** 3;\n  const s = (L + LAB_TO_LMS.s[0] * a + LAB_TO_LMS.s[1] * b) ** 3;\n  return [\n    LSM_TO_RGB.r[0] * l + LSM_TO_RGB.r[1] * m + LSM_TO_RGB.r[2] * s,\n    LSM_TO_RGB.g[0] * l + LSM_TO_RGB.g[1] * m + LSM_TO_RGB.g[2] * s,\n    LSM_TO_RGB.b[0] * l + LSM_TO_RGB.b[1] * m + LSM_TO_RGB.b[2] * s\n  ];\n}\nfunction oklabToLinearP3(L, a, b) {\n  const srgb = oklabToLinearSRGB(L, a, b);\n  return multiplyMatrix(SRGB_TO_P3, srgb);\n}\nfunction getOkLCHMaxChroma(input, precision = PRECISION) {\n  const { l, h } = isString(input) ? parseCSS(input, \"oklch\") : input;\n  invariant(isNumber(l) && l >= 0 && l <= 1, MESSAGES.lightnessRange);\n  invariant(isNumber(h) && h >= 0 && h <= 360, MESSAGES.hueRange);\n  const epsilon = 1e-6;\n  let low = 0;\n  let high = 0.5;\n  while (high - low > epsilon) {\n    const mid = (low + high) / 2;\n    const { l: L, a, b } = oklch2oklab({ l, c: mid, h }, 16);\n    const p3Color = oklabToLinearP3(L, a, b);\n    if (isInP3Gamut(p3Color)) {\n      low = mid;\n    } else {\n      high = mid;\n    }\n  }\n  return round(low, precision);\n}\nfunction getP3Color(input) {\n  const lch = isString(input) ? parseCSS(input, \"oklch\") : input;\n  return `oklch(${lch.l} ${getOkLCHMaxChroma(lch)} ${lch.h})`;\n}\n\n// src/random.ts\nfunction random(type = \"hex\") {\n  const hsl = {\n    h: Math.floor(Math.random() * 360) + 1,\n    s: Math.floor(Math.random() * 90) + 10,\n    l: Math.floor(Math.random() * 80) + 10\n  };\n  return formatCSS(hsl, { format: type });\n}\n\n// src/scheme.ts\nfunction scheme(input, typeOrOptions) {\n  invariant(isString(input), MESSAGES.inputString);\n  const { format, type = \"complementary\" } = isString(typeOrOptions) ? { type: typeOrOptions } : typeOrOptions ?? {};\n  const output = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const colors = [];\n  switch (type) {\n    case \"analogous\": {\n      colors.push(rotate(input, -30), input, rotate(input, 30));\n      break;\n    }\n    case \"complementary\": {\n      colors.push(input, rotate(input, 180));\n      break;\n    }\n    case \"split\":\n    case \"split-complementary\": {\n      colors.push(input, rotate(input, 150), rotate(input, 210));\n      break;\n    }\n    case \"triadic\": {\n      colors.push(input, rotate(input, 120), rotate(input, 240));\n      break;\n    }\n    case \"tetradic\":\n    case \"rectangle\": {\n      colors.push(input, rotate(input, 60), rotate(input, 180), rotate(input, 240));\n      break;\n    }\n    case \"square\": {\n      colors.push(input, rotate(input, 90), rotate(input, 180), rotate(input, 270));\n      break;\n    }\n    default: {\n      throw new TypeError(\"invalid type\");\n    }\n  }\n  return colors.map((color) => convert(color, format ?? output));\n}\n\n// src/swatch.ts\nfunction shadeColor(input, lightness) {\n  const { c, h } = input;\n  const chromaScale = c === 0 ? 1 : 4 * lightness * (1 - lightness);\n  const chroma2 = c * chromaScale;\n  const adjustedChroma = clamp(chroma2, 0, 0.4);\n  return { l: lightness, c: adjustedChroma, h };\n}\nfunction swatch(input, options = {}) {\n  invariant(isString(input), MESSAGES.inputString);\n  const {\n    format,\n    lightnessFactor = 1.5,\n    maxLightness = 0.97,\n    minLightness = 0.2,\n    scale = \"dynamic\",\n    variant = \"base\"\n  } = options;\n  invariant(\n    maxLightness > minLightness && maxLightness <= 1 && minLightness >= 0,\n    \"maxLightness must be greater than minLightness and within the range [0, 1].\"\n  );\n  const lch = parseCSS(input, \"oklch\");\n  const chromaScale = {\n    base: 1,\n    deep: 0.8,\n    neutral: 0.5,\n    pastel: 0.3,\n    subtle: 0.2,\n    vibrant: 1.25\n  }[variant];\n  lch.l = 0.7;\n  lch.c *= chromaScale;\n  if (variant === \"deep\") {\n    lch.l *= 0.7;\n  }\n  const colorFormat = isHex(input) || isNamedColor(input) ? \"hex\" : extractColorParts(input).model;\n  const steps = 11;\n  let palette2 = {};\n  if (scale === \"dynamic\") {\n    for (let index = 0; index < steps; index++) {\n      const lightness = maxLightness - (maxLightness - minLightness) * (index / (steps - 1)) ** lightnessFactor;\n      let tone = index * 100;\n      if (index === 0) {\n        tone = 50;\n      } else if (index === 10) {\n        tone = 950;\n      }\n      palette2[tone] = lightness;\n    }\n  } else {\n    palette2 = {\n      50: 0.97,\n      100: 0.92,\n      200: 0.85,\n      300: 0.78,\n      400: 0.69,\n      500: 0.57,\n      600: 0.46,\n      700: 0.35,\n      800: 0.24,\n      900: 0.18,\n      950: 0.1\n    };\n  }\n  const output = Object.entries(palette2).reduce(\n    (acc, [key, value]) => {\n      acc[Number(key)] = shadeColor(lch, value);\n      return acc;\n    },\n    {}\n  );\n  return Object.entries(output).reduce((acc, [key, value]) => {\n    return {\n      ...acc,\n      [key]: formatCSS(value, { format: format ?? colorFormat })\n    };\n  }, {});\n}\n\n// src/index.ts\nvar index_default = Colorizr;\nexport {\n  addAlphaToHex,\n  brightnessDifference,\n  chroma,\n  colorDifference,\n  compare,\n  contrast,\n  convert,\n  convertAlphaToHex,\n  darken,\n  index_default as default,\n  desaturate,\n  extractAlphaFromHex,\n  extractColorParts,\n  formatCSS,\n  formatHex,\n  getOkLCHMaxChroma,\n  getP3Color,\n  hex2hsl,\n  hex2oklab,\n  hex2oklch,\n  hex2rgb,\n  hexadecimalToNumber,\n  hsl2hex,\n  hsl2oklab,\n  hsl2oklch,\n  hsl2rgb,\n  isHSL,\n  isHex,\n  isLAB,\n  isLCH,\n  isRGB,\n  isValidColor,\n  lighten,\n  luminance,\n  name,\n  oklab2hex,\n  oklab2hsl,\n  oklab2oklch,\n  oklab2rgb,\n  oklch2hex,\n  oklch2hsl,\n  oklch2oklab,\n  oklch2rgb,\n  opacify,\n  opacity,\n  palette,\n  parseCSS,\n  random,\n  removeAlphaFromHex,\n  rgb2hex,\n  rgb2hsl,\n  rgb2oklab,\n  rgb2oklch,\n  rotate,\n  saturate,\n  scheme,\n  swatch,\n  textColor,\n  transparentize\n};\n//# sourceMappingURL=index.mjs.map","import * as C from \"colorizr\";\nimport type { Rgb, Rgb8Bit, RgbScalar } from \"./types.js\";\nimport { throwNumberInclusiveRangeTest, throwNumberTest } from \"@ixfx/guards\";\n\nconst withOpacity = <T extends Rgb>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `8bit`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 255) / 255, value) * 255\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nconst fromCss = (value: string): Rgb8Bit => {\n  if (value.startsWith(`rgb`)) throw new Error(`Expecting CSS string in the form of 'rgb(...)'. Got: '${ value }'`);\n  const c = C.extractColorParts(value);\n  if (c.model !== `rgb`) throw new Error(`Expecting RGB colour space. Got: ${ c.model }`);\n  return fromLibrary(c as any as C.RGB);\n}\n\nconst toCss = (rgb: Rgb): string => {\n  guard(rgb);\n  switch (rgb.unit) {\n    case `8bit`:\n      return `rgb(${ rgb.r } ${ rgb.b } ${ rgb.g } / ${ (rgb.opacity ?? 255) / 255 })`;\n    case `scalar`:\n      return `rgb(${ rgb.r * 100 }% ${ rgb.b * 100 }% ${ rgb.g * 100 }% / ${ (rgb.opacity ?? 1) * 100 }%)`;\n    default:\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      throw new Error(`Unknown unit: ${ (rgb as any).unit }`);\n  }\n}\n\nconst toLibrary = (rgb: Rgb): C.RGB => {\n  const abs = to8bit(rgb);\n  return {\n    r: abs.r,\n    g: abs.g,\n    b: abs.b,\n    alpha: abs.opacity,\n  }\n}\n\nconst fromLibrary = (rgb: C.RGB): Rgb8Bit => {\n  return {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b,\n    opacity: rgb.alpha ?? 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nconst to8bit = (rgb: Rgb): Rgb8Bit => {\n  guard(rgb);\n  if (rgb.unit === `8bit`) return rgb;\n  return {\n    r: rgb.r * 255,\n    g: rgb.g * 255,\n    b: rgb.b * 255,\n    opacity: rgb.opacity ?? 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nconst toScalar = (rgb: Rgb): RgbScalar => {\n  guard(rgb);\n  if (rgb.unit === `scalar`) return rgb;\n  return {\n    r: rgb.r / 255,\n    g: rgb.g / 255,\n    b: rgb.b / 255,\n    opacity: (rgb.opacity ?? 1) / 255,\n    unit: `scalar`,\n    space: `srgb`\n  }\n}\n\nconst guard = (rgb: Rgb) => {\n  const { r, g, b, opacity, space, unit } = rgb;\n  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${ space }`);\n  if (unit === `8bit`) {\n    throwNumberInclusiveRangeTest(r, 0, 255, `r`);\n    throwNumberInclusiveRangeTest(g, 0, 255, `g`);\n    throwNumberInclusiveRangeTest(b, 0, 255, `b`);\n    if (typeof opacity === `number`) {\n      throwNumberInclusiveRangeTest(opacity, 0, 255, `opacity`);\n    }\n  } else if (unit === `scalar`) {\n    throwNumberTest(r, `percentage`, `r`);\n    throwNumberTest(g, `percentage`, `g`);\n    throwNumberTest(b, `percentage`, `b`);\n    if (typeof opacity === `number`) {\n      throwNumberTest(opacity, `percentage`, `opacity`);\n    }\n  } else {\n    throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport const SrgbSpace = { withOpacity, toCss, fromCss, toLibrary, fromLibrary, guard, toScalar, to8bit };\n","import * as C from \"colorizr\";\nimport type { Hsl, HslAbsolute, HslScalar } from \"./types.js\";\nimport { throwNumberInclusiveRangeTest, throwNumberTest } from \"@ixfx/guards\";\n\nconst withOpacity = <T extends Hsl>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nconst fromCss = (value: string): HslAbsolute => {\n  if (value.startsWith(`hsl`)) throw new Error(`Expecting CSS string in the form of 'hsl(...) or hsla(...)'. Got: '${ value }'`);\n  const c = C.extractColorParts(value);\n  if (c.model !== `hsl`) throw new Error(`Expecting HSL colour space. Got: ${ c.model }`);\n  return fromLibrary(c as any as C.HSL);\n}\n\nconst toCss = (hsl: Hsl): string => {\n  const abs = toAbsolute(hsl);\n  let css = `hsl(${ abs.h }deg ${ abs.s }% ${ abs.l }%`;\n  if (`opacity` in abs && abs.opacity !== undefined) {\n    css += ` / ${ abs.opacity / 100 }`;\n  }\n  css += ')';\n  return css;\n}\n\nconst toLibrary = (hsl: Hsl): C.HSL => {\n  const abs = toAbsolute(hsl);\n  return {\n    h: abs.h,\n    s: abs.s,\n    l: abs.l,\n    alpha: abs.opacity,\n  }\n}\n\nconst fromLibrary = (hsl: C.HSL): HslAbsolute => {\n  return {\n    h: hsl.h,\n    s: hsl.s,\n    l: hsl.l,\n    opacity: hsl.alpha ?? 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\nconst toAbsolute = (hsl: Hsl): HslAbsolute => {\n  guard(hsl);\n  if (hsl.unit === `absolute`) return hsl;\n  return {\n    h: hsl.h * 360,\n    s: hsl.s * 100,\n    l: hsl.l * 100,\n    opacity: hsl.opacity ?? 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\nconst toScalar = (hsl: Hsl): HslScalar => {\n  guard(hsl);\n  if (hsl.unit === `scalar`) return hsl;\n  return {\n    h: hsl.h / 360,\n    s: hsl.s / 100,\n    l: hsl.l / 100,\n    opacity: (hsl.opacity ?? 1) / 100,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\nconst guard = (hsl: Hsl) => {\n  const { h, s, l, opacity, space, unit } = hsl;\n  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${ space }`);\n  if (unit === `absolute`) {\n    throwNumberTest(h, `finite`, `h`);\n    throwNumberInclusiveRangeTest(s, 0, 100, `s`);\n    throwNumberInclusiveRangeTest(l, 0, 100, `l`);\n    if (typeof opacity === `number`) {\n      throwNumberInclusiveRangeTest(opacity, 0, 100, `s`);\n    }\n  } else if (unit === `scalar`) {\n    throwNumberTest(h, `percentage`, `h`);\n    throwNumberTest(s, `percentage`, `s`);\n    throwNumberTest(l, `percentage`, `l`);\n    if (typeof opacity === `number`) {\n      throwNumberTest(opacity, `percentage`, `opacity`);\n    }\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport const HslSpace = { withOpacity, fromCss, toCss, toLibrary, fromLibrary, guard, toScalar, toAbsolute };\n","export const cssDefinedHexColours = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",\n  \"blue\": \"#0000ff\",\n  \"blueviolet\": \"#8a2be2\",\n  \"brown\": \"#a52a2a\",\n  \"burlywood\": \"#deb887\",\n  \"cadetblue\": \"#5f9ea0\",\n  \"chartreuse\": \"#7fff00\",\n  \"chocolate\": \"#d2691e\",\n  \"coral\": \"#ff7f50\",\n  \"cornflowerblue\": \"#6495ed\",\n  \"cornsilk\": \"#fff8dc\",\n  \"crimson\": \"#dc143c\",\n  \"cyan\": \"#00ffff\",\n  \"darkblue\": \"#00008b\",\n  \"darkcyan\": \"#008b8b\",\n  \"darkgoldenrod\": \"#b8860b\",\n  \"darkgray\": \"#a9a9a9\",\n  \"darkgreen\": \"#006400\",\n  \"darkkhaki\": \"#bdb76b\",\n  \"darkmagenta\": \"#8b008b\",\n  \"darkolivegreen\": \"#556b2f\",\n  \"darkorange\": \"#ff8c00\",\n  \"darkorchid\": \"#9932cc\",\n  \"darkred\": \"#8b0000\",\n  \"darksalmon\": \"#e9967a\",\n  \"darkseagreen\": \"#8fbc8f\",\n  \"darkslateblue\": \"#483d8b\",\n  \"darkslategray\": \"#2f4f4f\",\n  \"darkturquoise\": \"#00ced1\",\n  \"darkviolet\": \"#9400d3\",\n  \"deeppink\": \"#ff1493\",\n  \"deepskyblue\": \"#00bfff\",\n  \"dimgray\": \"#696969\",\n  \"dodgerblue\": \"#1e90ff\",\n  \"firebrick\": \"#b22222\",\n  \"floralwhite\": \"#fffaf0\",\n  \"forestgreen\": \"#228b22\",\n  \"fuchsia\": \"#ff00ff\",\n  \"gainsboro\": \"#dcdcdc\",\n  \"ghostwhite\": \"#f8f8ff\",\n  \"gold\": \"#ffd700\",\n  \"goldenrod\": \"#daa520\",\n  \"gray\": \"#808080\",\n  \"green\": \"#008000\",\n  \"greenyellow\": \"#adff2f\",\n  \"honeydew\": \"#f0fff0\",\n  \"hotpink\": \"#ff69b4\",\n  \"indianred\": \"#cd5c5c\",\n  \"indigo\": \"#4b0082\",\n  \"ivory\": \"#fffff0\",\n  \"khaki\": \"#f0e68c\",\n  \"lavender\": \"#e6e6fa\",\n  \"lavenderblush\": \"#fff0f5\",\n  \"lawngreen\": \"#7cfc00\",\n  \"lemonchiffon\": \"#fffacd\",\n  \"lightblue\": \"#add8e6\",\n  \"lightcoral\": \"#f08080\",\n  \"lightcyan\": \"#e0ffff\",\n  \"lightgoldenrodyellow\": \"#fafad2\",\n  \"lightgray\": \"#d3d3d3\",\n  \"lightgreen\": \"#90ee90\",\n  \"lightpink\": \"#ffb6c1\",\n  \"lightsalmon\": \"#ffa07a\",\n  \"lightseagreen\": \"#20b2aa\",\n  \"lightskyblue\": \"#87cefa\",\n  \"lightslategray\": \"#778899\",\n  \"lightsteelblue\": \"#b0c4de\",\n  \"lightyellow\": \"#ffffe0\",\n  \"lime\": \"#00ff00\",\n  \"limegreen\": \"#32cd32\",\n  \"linen\": \"#faf0e6\",\n  \"magenta\": \"#ff00ff\",\n  \"maroon\": \"#800000\",\n  \"mediumaquamarine\": \"#66cdaa\",\n  \"mediumblue\": \"#0000cd\",\n  \"mediumorchid\": \"#ba55d3\",\n  \"mediumpurple\": \"#9370db\",\n  \"mediumseagreen\": \"#3cb371\",\n  \"mediumslateblue\": \"#7b68ee\",\n  \"mediumspringgreen\": \"#00fa9a\",\n  \"mediumturquoise\": \"#48d1cc\",\n  \"mediumvioletred\": \"#c71585\",\n  \"midnightblue\": \"#191970\",\n  \"mintcream\": \"#f5fffa\",\n  \"mistyrose\": \"#ffe4e1\",\n  \"moccasin\": \"#ffe4b5\",\n  \"navajowhite\": \"#ffdead\",\n  \"navy\": \"#000080\",\n  \"oldlace\": \"#fdf5e6\",\n  \"olive\": \"#808000\",\n  \"olivedrab\": \"#6b8e23\",\n  \"orange\": \"#ffa500\",\n  \"orangered\": \"#ff4500\",\n  \"orchid\": \"#da70d6\",\n  \"palegoldenrod\": \"#eee8aa\",\n  \"palegreen\": \"#98fb98\",\n  \"paleturquoise\": \"#afeeee\",\n  \"palevioletred\": \"#db7093\",\n  \"papayawhip\": \"#ffefd5\",\n  \"peachpuff\": \"#ffdab9\",\n  \"peru\": \"#cd853f\",\n  \"pink\": \"#ffc0cb\",\n  \"plum\": \"#dda0dd\",\n  \"powderblue\": \"#b0e0e6\",\n  \"purple\": \"#800080\",\n  \"rebeccapurple\": \"#663399\",\n  \"red\": \"#ff0000\",\n  \"rosybrown\": \"#bc8f8f\",\n  \"royalblue\": \"#4169e1\",\n  \"saddlebrown\": \"#8b4513\",\n  \"salmon\": \"#fa8072\",\n  \"sandybrown\": \"#f4a460\",\n  \"seagreen\": \"#2e8b57\",\n  \"seashell\": \"#fff5ee\",\n  \"sienna\": \"#a0522d\",\n  \"silver\": \"#c0c0c0\",\n  \"skyblue\": \"#87ceeb\",\n  \"slateblue\": \"#6a5acd\",\n  \"slategray\": \"#708090\",\n  \"snow\": \"#fffafa\",\n  \"springgreen\": \"#00ff7f\",\n  \"steelblue\": \"#4682b4\",\n  \"tan\": \"#d2b48c\",\n  \"teal\": \"#008080\",\n  \"thistle\": \"#d8bfd8\",\n  \"tomato\": \"#ff6347\",\n  \"turquoise\": \"#40e0d0\",\n  \"violet\": \"#ee82ee\",\n  \"wheat\": \"#f5deb3\",\n  \"white\": \"#ffffff\",\n  \"whitesmoke\": \"#f5f5f5\",\n  \"yellow\": \"#ffff00\",\n  \"yellowgreen\": \"#9acd32\"\n}\n","import * as C from \"colorizr\";\nimport type { Colour, Colourish } from \"./types.js\";\nimport { SrgbSpace } from \"./srgb.js\";\nimport { HslSpace } from './hsl.js';\nimport { cssDefinedHexColours } from \"./css-colours.js\";\n\nconst hexStringToColour = (hexString: string): Colour => {\n  const rgb = C.hex2rgb(hexString);\n  return SrgbSpace.fromLibrary(rgb);\n}\n\nexport const toCssColour = (colour: Colourish): string => {\n  if (typeof colour === `string`) return colour;\n  switch (colour.space) {\n    case `hsl`:\n      return HslSpace.toCss(colour);\n    case `srgb`:\n      return SrgbSpace.toCss(colour);\n    default:\n      throw new Error(`Unknown colour space: '${ colour.space }'`);\n  }\n}\n\nexport const fromCssColour = (colour: string): Colour => {\n  if (colour.startsWith(`#`)) {\n    return hexStringToColour(colour);\n  }\n\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return hexStringToColour(cssDefinedHexColours[ colour ] as string);\n  }\n\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0) throw new Error(`Variable missing: ${ colour }`);\n    if (fromCss.startsWith(`#`)) hexStringToColour(fromCss);\n    if (fromCss.startsWith(`rgb`)) return SrgbSpace.fromCss(fromCss);\n    if (fromCss.startsWith(`hsl`)) return HslSpace.fromCss(fromCss);\n    throw new Error(`CSS variable value not a hex, rgb or hsl colour function: '${ fromCss }'`);\n  }\n  throw new Error(`String colour is not a hex colour nor well-defined colour name`);\n}\n\nexport const guard = (colour: Colour) => {\n  switch (colour.space) {\n    case `hsl`:\n      HslSpace.guard(colour);\n      break;\n    case `srgb`:\n      SrgbSpace.guard(colour);\n      break;\n    default:\n      throw new Error(`Unknown colour space: '${ colour.space }'`);\n  }\n}\n\nexport const toColour = (colourish: Colourish): Colour => {\n  let c: Colour | undefined;\n  if (typeof colourish === `string`) c = fromCssColour(colourish);\n  else c = colourish;\n  if (c === undefined) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n\n  guard(c);\n  return c;\n}\n\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const toStringFirst = (...colours: (Colourish | undefined)[]): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    try {\n      const c = toColour(colour);\n      return toCssColour(c);\n    } catch { /* empty */ }\n  }\n  return `rebeccapurple`;\n}","import type { Colour, Colourish, Hsl, Rgb } from './types.js';\nimport { toColour, toCssColour } from './conversion.js';\nimport { HslSpace } from './hsl.js';\nimport { SrgbSpace } from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\n\nexport function multiplyOpacity(colourish: string, amount: number): string {\n  return withOpacity(colourish, o => clamp(o * amount));\n}\n\nexport function withOpacity(colourish: string, fn: (scalarOpacity: number) => number): string;\nexport function withOpacity(colourish: Hsl, fn: (scalarOpacity: number) => number): Hsl;\nexport function withOpacity(colourish: Rgb, fn: (scalarOpacity: number) => number): Rgb;\nexport function withOpacity(colourish: Colourish, fn: (scalarOpacity: number) => number): Colourish {\n  const colour = toColour(colourish);\n  let result: Colour | undefined;\n  switch (colour.space) {\n    case `hsl`:\n      result = HslSpace.withOpacity(colour, fn);\n      break;\n    case `srgb`:\n      result = SrgbSpace.withOpacity(colour, fn);\n      break;\n    default:\n      throw new Error(`Unknown space: '${ colour.space }'. Expected hsl, srgb, oklch`)\n  }\n  if (!result) throw new Error(`Is colour in correct form?`);\n  if (typeof colourish === `string`) {\n    // Convert back to string if input was a string\n    return toCssColour(result);\n  }\n  return result;\n};\n\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };","import { throwArrayTest } from '@ixfx/guards';\nimport { Colour } from '@ixfx/visual';\nimport { resolveEl } from '@ixfx/dom';\nimport { StackImmutable } from '@ixfx/collections/stack';\nimport { Beziers, Lines, Points, Rects, Triangles } from '@ixfx/geometry';\nimport { quantiseEvery } from '@ixfx/numbers';\n// import type { Point } from '../geometry/point/PointType.js';\n// import type { Line } from '../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../geometry/circle/CircleType.js';\n// import type { Rect, RectPositioned } from '../geometry/rect/index.js';\n// import type { Path } from '../geometry/path/PathType.js';\n// import type { Triangle } from '../geometry/triangle/TriangleType.js';\n// import { Empty as RectsEmpty } from '../geometry/rect/Empty.js';\n// import { corners as RectsCorners } from '../geometry/rect/Corners.js';\n// import { isLine } from '../geometry/line/Guard.js';\n// import { quantiseEvery } from '../numbers/Quantise.js';\nconst PIPI = Math.PI * 2;\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElementContextOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (canvasElementContextOrQuery) => {\n    if (canvasElementContextOrQuery === null) {\n        throw new Error(`canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`);\n    }\n    if (canvasElementContextOrQuery === undefined) {\n        throw new Error(`canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`);\n    }\n    const ctx = canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n        ? canvasElementContextOrQuery\n        : canvasElementContextOrQuery instanceof HTMLCanvasElement\n            ? canvasElementContextOrQuery.getContext(`2d`)\n            : typeof canvasElementContextOrQuery === `string`\n                ? resolveEl(canvasElementContextOrQuery).getContext(`2d`)\n                : canvasElementContextOrQuery;\n    if (ctx === null)\n        throw new Error(`Could not create 2d context for canvas`);\n    return ctx;\n};\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (ctxOrCanvasEl, canvasBounds) => {\n    const ctx = getContext(ctxOrCanvasEl);\n    return {\n        ctx,\n        paths(pathsToDraw, opts) {\n            paths(ctx, pathsToDraw, opts);\n        },\n        line(lineToDraw, opts) {\n            line(ctx, lineToDraw, opts);\n        },\n        rect(rectsToDraw, opts) {\n            rect(ctx, rectsToDraw, opts);\n        },\n        bezier(bezierToDraw, opts) {\n            bezier(ctx, bezierToDraw, opts);\n        },\n        connectedPoints(pointsToDraw, opts) {\n            connectedPoints(ctx, pointsToDraw, opts);\n        },\n        pointLabels(pointsToDraw, opts) {\n            pointLabels(ctx, pointsToDraw, opts);\n        },\n        dot(dotPosition, opts) {\n            dot(ctx, dotPosition, opts);\n        },\n        circle(circlesToDraw, opts) {\n            circle(ctx, circlesToDraw, opts);\n        },\n        arc(arcsToDraw, opts) {\n            arc(ctx, arcsToDraw, opts);\n        },\n        textBlock(lines, opts) {\n            if (opts.bounds === undefined && canvasBounds !== undefined) {\n                opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n            }\n            textBlock(ctx, lines, opts);\n        },\n    };\n};\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts) => coloringOp(opts.strokeStyle, opts.fillStyle);\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (ctx, opts = {}, ...additionalOps) => {\n    if (ctx === undefined)\n        throw new Error(`ctx undefined`);\n    // Create a drawing stack, pushing an op generated from drawing options\n    const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n    // Apply stack to context\n    stack.apply();\n    return stack;\n};\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (ctx, arcs, opts = {}) => {\n    applyOpts(ctx, opts);\n    const draw = (arc) => {\n        ctx.beginPath();\n        ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n        ctx.stroke();\n    };\n    const arcsArray = Array.isArray(arcs) ? arcs : [arcs];\n    for (const arc of arcsArray) {\n        draw(arc);\n    }\n};\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (strokeStyle, fillStyle) => {\n    const apply = (ctx) => {\n        if (fillStyle)\n            ctx.fillStyle = fillStyle;\n        if (strokeStyle)\n            ctx.strokeStyle = strokeStyle;\n    };\n    return apply;\n};\nconst lineOp = (lineWidth, lineJoin, lineCap) => {\n    const apply = (ctx) => {\n        if (lineWidth)\n            ctx.lineWidth = lineWidth;\n        if (lineJoin)\n            ctx.lineJoin = lineJoin;\n        if (lineCap)\n            ctx.lineCap = lineCap;\n    };\n    return apply;\n};\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (ctx, stk) => {\n    if (stk === undefined)\n        stk = new StackImmutable();\n    const push = (...ops) => {\n        if (stk === undefined)\n            stk = new StackImmutable();\n        const s = stk.push(...ops);\n        for (const o of ops)\n            o(ctx);\n        return drawingStack(ctx, s);\n    };\n    const pop = () => {\n        const s = stk?.pop();\n        return drawingStack(ctx, s);\n    };\n    const apply = () => {\n        if (stk === undefined)\n            return drawingStack(ctx);\n        for (const op of stk.data)\n            op(ctx);\n        return drawingStack(ctx, stk);\n    };\n    return { push, pop, apply };\n};\n/**\n * Draws a curved line through a set of points\n * @param ctx\n * @param points\n * @param opts\n */\nexport const lineThroughPoints = (ctx, points, opts) => {\n    applyOpts(ctx, opts);\n    // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n    ctx.moveTo(points[0].x, points[0].y);\n    for (const [index, p] of points.entries()) {\n        if (index + 2 >= points.length)\n            continue;\n        const pNext = points[index + 1];\n        const mid = {\n            x: (p.x + pNext.x) / 2,\n            y: (p.y + pNext.y) / 2,\n        };\n        const cpX1 = (mid.x + p.x) / 2;\n        const cpX2 = (mid.x + pNext.x) / 2;\n        ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n        ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n    }\n};\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (ctx, circlesToDraw, opts = {}) => {\n    applyOpts(ctx, opts);\n    const draw = (c) => {\n        ctx.beginPath();\n        ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n        if (opts.strokeStyle)\n            ctx.stroke();\n        if (opts.fillStyle)\n            ctx.fill();\n    };\n    if (Array.isArray(circlesToDraw)) {\n        for (const c of circlesToDraw)\n            draw(c);\n    }\n    else {\n        draw(circlesToDraw);\n    }\n};\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (ctx, ellipsesToDraw, opts = {}) => {\n    applyOpts(ctx, opts);\n    const draw = (ellipse) => {\n        ctx.beginPath();\n        const rotation = ellipse.rotation ?? 0;\n        const startAngle = ellipse.startAngle ?? 0;\n        const endAngle = ellipse.endAngle ?? PIPI;\n        ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n        if (opts.strokeStyle)\n            ctx.stroke();\n        if (opts.fillStyle)\n            ctx.fill();\n    };\n    const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ellipsesToDraw];\n    for (const ellipse of ellipsesArray) {\n        draw(ellipse);\n    }\n};\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (ctx, pathsToDraw, opts = {}) => {\n    applyOpts(ctx, opts);\n    const draw = (path) => {\n        // Call appropriate drawing function depending on the type of path\n        if (Beziers.isQuadraticBezier(path))\n            quadraticBezier(ctx, path, opts);\n        else if (Lines.isLine(path))\n            line(ctx, path, opts);\n        else\n            throw new Error(`Unknown path type ${JSON.stringify(path)}`);\n    };\n    if (Array.isArray(pathsToDraw)) {\n        for (const p of pathsToDraw)\n            draw(p);\n    }\n    else {\n        draw(pathsToDraw);\n    }\n};\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (ctx, pts, opts = {}) => {\n    const shouldLoop = opts.loop ?? false;\n    throwArrayTest(pts);\n    if (pts.length === 0)\n        return;\n    // Throw an error if any point is invalid\n    for (const [index, pt] of pts.entries())\n        Points.guard(pt, `Index ${index}`);\n    applyOpts(ctx, opts);\n    // Draw points\n    if (opts.lineWidth)\n        ctx.lineWidth = opts.lineWidth;\n    ctx.beginPath();\n    ctx.moveTo(pts[0].x, pts[0].y);\n    for (const pt of pts)\n        ctx.lineTo(pt.x, pt.y);\n    if (shouldLoop)\n        ctx.lineTo(pts[0].x, pts[0].y);\n    // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n    if (opts.strokeStyle ||\n        (opts.strokeStyle === undefined && opts.fillStyle === undefined)) {\n        ctx.stroke();\n    }\n    if (opts.fillStyle) {\n        ctx.fill();\n    }\n};\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (ctx, pts, opts = {}, labels) => {\n    if (pts.length === 0)\n        return;\n    // Throw an error if any point is invalid\n    for (const [index, pt] of pts.entries())\n        Points.guard(pt, `Index ${index}`);\n    applyOpts(ctx, opts);\n    for (const [index, pt] of pts.entries()) {\n        const label = labels !== undefined && index < labels.length ? labels[index] : index.toString();\n        ctx.fillText(label.toString(), pt.x, pt.y);\n    }\n};\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (ctx, point) => {\n    const m = ctx.getTransform();\n    return {\n        x: point.x * m.a + point.y * m.c + m.e,\n        y: point.x * m.b + point.y * m.d + m.f,\n    };\n};\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl) => {\n    const img = document.createElement(`img`);\n    img.src = canvasEl.toDataURL(`image/jpeg`);\n    return img;\n};\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (ctx, pos, opts) => {\n    if (opts === undefined)\n        opts = {};\n    const radius = opts.radius ?? 10;\n    const positions = Array.isArray(pos) ? pos : [pos];\n    const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== undefined;\n    let filled = opts.filled ? opts.filled : opts.fillStyle !== undefined;\n    if (!stroke && !filled)\n        filled = true;\n    applyOpts(ctx, opts);\n    for (const pos of positions) {\n        ctx.beginPath();\n        if (`radius` in pos) {\n            ctx.arc(pos.x, pos.y, pos.radius, 0, 2 * Math.PI);\n        }\n        else {\n            ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\n        }\n        if (filled) {\n            ctx.fill();\n        }\n        if (stroke) {\n            ctx.stroke();\n        }\n    }\n    // const makePath = () => {\n    //   ctx.beginPath();\n    //   // x&y for arc is the center of circle\n    //   if (Array.isArray(pos)) {\n    //     for (const p of pos) {\n    //       ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n    //     }\n    //   } else {\n    //     const p = pos as Point;\n    //     ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n    //   }\n    // }\n    // makePath();\n    // if (opts.filled || !opts.stroke) {\n    //   ctx.fill();\n    // }\n    // if (opts.stroke) {\n    //   if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n    //   //makePath();\n    //   ctx.stroke();\n    // }\n};\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (ctx, bezierToDraw, opts) => {\n    if (Beziers.isQuadraticBezier(bezierToDraw)) {\n        quadraticBezier(ctx, bezierToDraw, opts);\n    }\n    else if (Beziers.isCubicBezier(bezierToDraw)) {\n        cubicBezier(ctx, bezierToDraw, opts);\n    }\n};\nconst cubicBezier = (ctx, bezierToDraw, opts = {}) => {\n    let stack = applyOpts(ctx, opts);\n    const { a, b, cubic1, cubic2 } = bezierToDraw;\n    const isDebug = opts.debug ?? false;\n    if (isDebug) {\n        /*\n         * const ss = ctx.strokeStyle;\n         * ctx.strokeStyle = ss;\n         */\n    }\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n    ctx.stroke();\n    if (isDebug) {\n        stack = stack.push(optsOp({\n            ...opts,\n            strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n            fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n        }));\n        stack.apply();\n        ctx.moveTo(a.x, a.y);\n        ctx.lineTo(cubic1.x, cubic1.y);\n        ctx.stroke();\n        ctx.moveTo(b.x, b.y);\n        ctx.lineTo(cubic2.x, cubic2.y);\n        ctx.stroke();\n        ctx.fillText(`a`, a.x + 5, a.y);\n        ctx.fillText(`b`, b.x + 5, b.y);\n        ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n        ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n        dot(ctx, cubic1, { radius: 3 });\n        dot(ctx, cubic2, { radius: 3 });\n        dot(ctx, a, { radius: 3 });\n        dot(ctx, b, { radius: 3 });\n        stack = stack.pop();\n        stack.apply();\n    }\n};\nconst quadraticBezier = (ctx, bezierToDraw, opts = {}) => {\n    const { a, b, quadratic } = bezierToDraw;\n    const isDebug = opts.debug ?? false;\n    let stack = applyOpts(ctx, opts);\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n    ctx.stroke();\n    if (isDebug) {\n        /*\n         * const fs = ctx.fillStyle;\n         * const ss = ctx.strokeStyle;\n         * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n         * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n         */\n        stack = stack.push(optsOp({\n            ...opts,\n            strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n            fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n        }));\n        connectedPoints(ctx, [a, quadratic, b]);\n        ctx.fillText(`a`, a.x + 5, a.y);\n        ctx.fillText(`b`, b.x + 5, b.y);\n        ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n        dot(ctx, quadratic, { radius: 3 });\n        dot(ctx, a, { radius: 3 });\n        dot(ctx, b, { radius: 3 });\n        /*\n         * ctx.fillStyle = fs;\n         * ctx.strokeStyle = ss;\n         */\n        stack = stack.pop();\n        stack.apply();\n    }\n};\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (ctx, toDraw, opts = {}) => {\n    const isDebug = opts.debug ?? false;\n    const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n    applyOpts(ctx, opts, o);\n    const draw = (d) => {\n        const { a, b } = d;\n        ctx.beginPath();\n        ctx.moveTo(a.x, a.y);\n        ctx.lineTo(b.x, b.y);\n        if (isDebug) {\n            ctx.fillText(`a`, a.x, a.y);\n            ctx.fillText(`b`, b.x, b.y);\n            dot(ctx, a, { radius: 5, strokeStyle: `black` });\n            dot(ctx, b, { radius: 5, strokeStyle: `black` });\n        }\n        ctx.stroke();\n    };\n    if (Array.isArray(toDraw)) {\n        for (const t of toDraw)\n            draw(t);\n    }\n    else {\n        draw(toDraw);\n    }\n};\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (ctx, toDraw, opts = {}) => {\n    applyOpts(ctx, opts);\n    const draw = (t) => {\n        connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n        if (opts.debug) {\n            pointLabels(ctx, Triangles.corners(t), undefined, [`a`, `b`, `c`]);\n        }\n    };\n    if (Array.isArray(toDraw)) {\n        for (const t of toDraw) {\n            draw(t);\n        }\n    }\n    else {\n        draw(toDraw);\n    }\n};\n/**\n * Draws one or more rectangles.\n *\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (ctx, toDraw, opts = {}) => {\n    applyOpts(ctx, opts);\n    const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n    const stroke = opts.stroke ?? (opts.strokeStyle === undefined ? false : true);\n    const draw = (d) => {\n        const x = `x` in d ? d.x : 0;\n        const y = `y` in d ? d.y : 0;\n        if (filled)\n            ctx.fillRect(x, y, d.width, d.height);\n        if (stroke) {\n            if (opts.strokeWidth)\n                ctx.lineWidth = opts.strokeWidth;\n            //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n            ctx.strokeRect(x, y, d.width, d.height);\n        }\n        if (opts.crossed) {\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(d.width, d.height);\n            ctx.stroke();\n            ctx.moveTo(0, d.height);\n            ctx.lineTo(d.width, 0);\n            ctx.stroke();\n        }\n        if (opts.debug) {\n            pointLabels(ctx, Rects.corners(d), undefined, [`NW`, `NE`, `SE`, `SW`]);\n        }\n    };\n    if (Array.isArray(toDraw)) {\n        for (const t of toDraw) {\n            draw(t);\n        }\n    }\n    else {\n        draw(toDraw);\n    }\n};\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (ctx, text, padding = 0, widthMultiple) => {\n    const rect = textRect(ctx, text, padding, widthMultiple);\n    return rect.width;\n};\nexport const textRect = (ctx, text, padding = 0, widthMultiple) => {\n    if (text === undefined || text === null || text.length === 0)\n        return Rects.Empty;\n    const m = ctx.measureText(text);\n    const width = (widthMultiple) ? quantiseEvery(m.width, widthMultiple) + padding : m.width + padding;\n    return {\n        width: width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n    };\n};\nexport const textHeight = (ctx, text, padding = 0) => {\n    const rect = textRect(ctx, text, padding);\n    return rect.height;\n    // if (text === undefined || text === null || text.length === 0) return 0;\n    // const m = ctx.measureText(text);\n    // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n};\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (ctx, lines, opts) => {\n    applyOpts(ctx, opts);\n    const anchorPadding = opts.anchorPadding ?? 0;\n    const align = opts.align ?? `top`;\n    const anchor = opts.anchor;\n    const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n    // Measure each line\n    const blocks = lines.map((l) => ctx.measureText(l));\n    // Get width and height\n    const widths = blocks.map((tm) => tm.width);\n    const heights = blocks.map((tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3);\n    // Find extremes\n    const maxWidth = Math.max(...widths);\n    const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n    let { x, y } = anchor;\n    if (anchor.x + maxWidth > bounds.width) {\n        x = bounds.width - (maxWidth + anchorPadding);\n    }\n    else\n        x -= anchorPadding;\n    if (x < bounds.x)\n        x = bounds.x + anchorPadding;\n    if (anchor.y + totalHeight > bounds.height) {\n        y = bounds.height - (totalHeight + anchorPadding);\n    }\n    else\n        y -= anchorPadding;\n    if (y < bounds.y)\n        y = bounds.y + anchorPadding;\n    if (align === `top`) {\n        ctx.textBaseline = `top`;\n    }\n    else {\n        ctx.textBaseline = `middle`;\n    }\n    for (const [index, line] of lines.entries()) {\n        ctx.fillText(line, x, y);\n        y += heights[index];\n    }\n};\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (ctx, text, opts) => {\n    const { bounds } = opts;\n    const { horiz = `left`, vert = `top` } = opts;\n    const lines = typeof text === `string` ? [text] : text;\n    applyOpts(ctx, opts);\n    ctx.save();\n    ctx.translate(bounds.x, bounds.y);\n    ctx.textAlign = `left`;\n    ctx.textBaseline = `top`;\n    const middleX = bounds.width / 2;\n    const middleY = bounds.height / 2;\n    // Measure each line\n    const blocks = lines.map((l) => ctx.measureText(l));\n    const heights = blocks.map((tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent);\n    const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n    let y = 0;\n    if (vert === `center`)\n        y = middleY - totalHeight / 2;\n    else if (vert === `bottom`) {\n        y = bounds.height - totalHeight;\n    }\n    for (const [index, line] of lines.entries()) {\n        let x = 0;\n        if (horiz === `center`)\n            x = middleX - blocks[index].width / 2;\n        else if (horiz === `right`)\n            x = bounds.width - blocks[index].width;\n        ctx.fillText(line, x, y);\n        y += heights[index];\n    }\n    ctx.restore();\n};\n","import * as C from \"colorizr\";\nimport { throwNumberInclusiveRangeTest, throwNumberTest } from \"@ixfx/guards\";\nconst withOpacity = (value, fn) => {\n    switch (value.unit) {\n        case `8bit`:\n            return {\n                ...value,\n                opacity: fn((value.opacity ?? 255) / 255, value) * 255\n            };\n        case `scalar`:\n            return {\n                ...value,\n                opacity: fn((value.opacity ?? 1), value)\n            };\n    }\n};\nconst fromCss = (value) => {\n    if (value.startsWith(`rgb`))\n        throw new Error(`Expecting CSS string in the form of 'rgb(...)'. Got: '${value}'`);\n    const c = C.extractColorParts(value);\n    if (c.model !== `rgb`)\n        throw new Error(`Expecting RGB colour space. Got: ${c.model}`);\n    return fromLibrary(c);\n};\nconst toCss = (rgb) => {\n    guard(rgb);\n    switch (rgb.unit) {\n        case `8bit`:\n            return `rgb(${rgb.r} ${rgb.b} ${rgb.g} / ${(rgb.opacity ?? 255) / 255})`;\n        case `scalar`:\n            return `rgb(${rgb.r * 100}% ${rgb.b * 100}% ${rgb.g * 100}% / ${(rgb.opacity ?? 1) * 100}%)`;\n        default:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            throw new Error(`Unknown unit: ${rgb.unit}`);\n    }\n};\nconst toLibrary = (rgb) => {\n    const abs = to8bit(rgb);\n    return {\n        r: abs.r,\n        g: abs.g,\n        b: abs.b,\n        alpha: abs.opacity,\n    };\n};\nconst fromLibrary = (rgb) => {\n    return {\n        r: rgb.r,\n        g: rgb.g,\n        b: rgb.b,\n        opacity: rgb.alpha ?? 255,\n        unit: `8bit`,\n        space: `srgb`\n    };\n};\nconst to8bit = (rgb) => {\n    guard(rgb);\n    if (rgb.unit === `8bit`)\n        return rgb;\n    return {\n        r: rgb.r * 255,\n        g: rgb.g * 255,\n        b: rgb.b * 255,\n        opacity: rgb.opacity ?? 255,\n        unit: `8bit`,\n        space: `srgb`\n    };\n};\nconst toScalar = (rgb) => {\n    guard(rgb);\n    if (rgb.unit === `scalar`)\n        return rgb;\n    return {\n        r: rgb.r / 255,\n        g: rgb.g / 255,\n        b: rgb.b / 255,\n        opacity: (rgb.opacity ?? 1) / 255,\n        unit: `scalar`,\n        space: `srgb`\n    };\n};\nconst guard = (rgb) => {\n    const { r, g, b, opacity, space, unit } = rgb;\n    if (space !== `srgb`)\n        throw new Error(`Space is expected to be 'srgb'. Got: ${space}`);\n    if (unit === `8bit`) {\n        throwNumberInclusiveRangeTest(r, 0, 255, `r`);\n        throwNumberInclusiveRangeTest(g, 0, 255, `g`);\n        throwNumberInclusiveRangeTest(b, 0, 255, `b`);\n        if (typeof opacity === `number`) {\n            throwNumberInclusiveRangeTest(opacity, 0, 255, `opacity`);\n        }\n    }\n    else if (unit === `scalar`) {\n        throwNumberTest(r, `percentage`, `r`);\n        throwNumberTest(g, `percentage`, `g`);\n        throwNumberTest(b, `percentage`, `b`);\n        if (typeof opacity === `number`) {\n            throwNumberTest(opacity, `percentage`, `opacity`);\n        }\n    }\n    else {\n        throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${unit}`);\n    }\n};\nexport const SrgbSpace = { withOpacity, toCss, fromCss, toLibrary, fromLibrary, guard, toScalar, to8bit };\n","import { Grids } from '@ixfx/geometry';\nimport { SrgbSpace } from './colour/srgb.js';\n/**\n * Returns a {@link Grids.Grid} based on the provided `image`\n * @param image ImageData\n * @returns Grid\n */\nexport const grid = (image) => {\n    const g = { rows: image.width, cols: image.height };\n    return g;\n};\n/**\n * Returns an object that allows get/set grid semantics on the underlying `image` data.\n * Uses 8-bit sRGB values, meaning 0..255 range for red, green, blue & opacity.\n *\n * ```js\n * // Get CANVAS element, drawing context and then image data\n * const canvasEl = document.querySelector(`#my-canvas`);\n * const ctx = canvasEl.getContext(`2d`);\n * const imageData = ctx.getImageData();\n *\n * // Now that we have image data, we can wrap it:\n * const asGrid = ImageDataGrid.wrap(imageData);\n * asGrid.get({ x:10, y: 20 }); // Get pixel at 10,20\n * asGrid.set(colour, { x:10, y: 20 }); // Set pixel value\n *\n * // Display changes back on the canvas\n * ctx.putImageData(imageData, 0, 0)\n * ```\n * @param image\n * @returns\n */\nexport const wrap = (image) => {\n    return {\n        ...grid(image),\n        get: accessor(image),\n        set: setter(image)\n    };\n};\n/**\n * Returns a function to access pixel values by x,y\n * @param image\n * @returns\n */\nexport const accessor = (image) => {\n    const g = grid(image);\n    const data = image.data;\n    const fn = (cell, bounds = `undefined`) => {\n        const index = Grids.indexFromCell(g, cell, bounds);\n        if (index === undefined)\n            return;\n        const pxIndex = index * 4;\n        return {\n            r: data[pxIndex],\n            g: data[pxIndex + 1],\n            b: data[pxIndex + 2],\n            opacity: data[pxIndex + 3],\n            unit: `8bit`,\n            space: `srgb`\n        };\n    };\n    return fn;\n};\n/**\n * Returns a function that sets pixel values\n * @param image\n * @returns\n */\nexport const setter = (image) => {\n    const g = grid(image);\n    const data = image.data;\n    const fn = (value, cell, bounds = `undefined`) => {\n        const index = Grids.indexFromCell(g, cell, bounds);\n        if (index === undefined)\n            throw new Error(`Cell out of range. ${cell.x},${cell.y}`);\n        const pixel = SrgbSpace.to8bit(value);\n        const pxIndex = index * 4;\n        data[pxIndex] = pixel.r;\n        data[pxIndex + 1] = pixel.g;\n        data[pxIndex + 2] = pixel.b;\n        data[pxIndex + 3] = pixel.opacity ?? 255;\n    };\n    return fn;\n};\n// export function* visit(image: ImageData, visitor: Grids.VisitGenerator) {\n//   const a = accessor(image);\n//   for (const cell of visitor) {\n//     yield a(cell, `undefined`);\n//   }\n// }\n/**\n * Yields pixels of an image row by row\n * @param image\n */\nexport function* byRow(image) {\n    const a = accessor(image);\n    const g = grid(image);\n    const v = Grids.As.rows(g, { x: 0, y: 0 });\n    for (const row of v) {\n        const pixels = row.map(p => a(p, `undefined`));\n        yield pixels;\n    }\n}\n/**\n * Yields pixels of an image column by column\n * @param image\n */\nexport function* byColumn(image) {\n    const a = accessor(image);\n    const g = grid(image);\n    for (let x = 0; x < g.cols; x++) {\n        const col = [];\n        for (let y = 0; y < g.rows; y++) {\n            const p = a({ x, y }, `undefined`);\n            if (p)\n                col.push(p);\n        }\n        yield col;\n    }\n}\n","import { ElementSizer, resolveEl } from '@ixfx/dom';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { Rects, scaler } from '@ixfx/geometry';\nimport * as Drawing from './drawing.js';\nimport * as ImageDataGrid from './image-data-grid.js';\nimport { cloneFromFields } from '@ixfx/core/records';\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n *\n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n *\n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...\n * });\n * ```\n *\n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, onResize });\n * ```\n *\n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, draw });\n * ```\n */\nexport class CanvasHelper extends SimpleEventEmitter {\n    el;\n    opts;\n    #scaler;\n    #scalerSize;\n    #viewport = Rects.EmptyPositioned;\n    #logicalSize = Rects.Empty;\n    #ctx;\n    #drawHelper;\n    #resizer;\n    #disposed = false;\n    constructor(domQueryOrEl, opts = {}) {\n        super();\n        if (!domQueryOrEl)\n            throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n        this.el = resolveEl(domQueryOrEl);\n        if (this.el.nodeName !== `CANVAS`) {\n            throw new Error(`Expected CANVAS HTML element. Got: ${this.el.nodeName}`);\n        }\n        const size = this.el.getBoundingClientRect();\n        this.opts = {\n            resizeLogic: opts.resizeLogic ?? `none`,\n            disablePointerEvents: opts.disablePointerEvents ?? false,\n            pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),\n            height: opts.height ?? size.height,\n            width: opts.width ?? size.width,\n            zIndex: opts.zIndex ?? -1,\n            coordinateScale: opts.coordinateScale ?? `both`,\n            onResize: opts.onResize,\n            clearOnResize: opts.clearOnResize ?? true,\n            draw: opts.draw,\n            skipCss: opts.skipCss ?? false,\n            colourSpace: `srgb`\n        };\n        this.#scaler = scaler(`both`);\n        this.#scalerSize = scaler(`both`, size);\n        this.#init();\n    }\n    getRectangle() {\n        return {\n            x: 0, y: 0,\n            ...this.#logicalSize\n        };\n    }\n    dispose(reason) {\n        if (this.#disposed)\n            return;\n        this.#disposed = true;\n        if (this.#resizer) {\n            this.#resizer.dispose(`CanvasHelper disposing ${reason}`.trim());\n            this.#resizer = undefined;\n        }\n    }\n    #getContext(reset = false) {\n        if (this.#ctx === undefined || reset) {\n            const ratio = this.ratio;\n            const c = this.el.getContext(`2d`);\n            if (c === null)\n                throw new Error(`Could not create drawing context`);\n            this.#ctx = c;\n            // Reset scale\n            c.setTransform(1, 0, 0, 1, 0, 0);\n            c.scale(ratio, ratio);\n        }\n        return this.#ctx;\n    }\n    ;\n    /**\n     * Gets the drawable area of the canvas.\n     * This accounts for scaling due to high-DPI displays etc.\n     * @returns\n     */\n    getPhysicalSize() {\n        return {\n            width: this.width * this.ratio,\n            height: this.height * this.ratio\n        };\n    }\n    /**\n     * Creates a drawing helper for the canvas.\n     * If one is already created it is reused.\n     */\n    getDrawHelper() {\n        if (!this.#drawHelper) {\n            this.#drawHelper = Drawing.makeHelper(this.#getContext(), {\n                width: this.width, height: this.height\n            });\n        }\n    }\n    setLogicalSize(logicalSize) {\n        Rects.guard(logicalSize, `logicalSize`);\n        const logicalSizeInteger = Rects.applyFields(v => Math.floor(v), logicalSize);\n        const ratio = this.opts.pixelZoom;\n        // Scaler for going between relative and logical units\n        this.#scaler = scaler(this.opts.coordinateScale, logicalSize);\n        this.#scalerSize = scaler(`both`, logicalSize);\n        // Scaled logical size for DPI\n        const pixelScaled = Rects.multiplyScalar(logicalSize, ratio);\n        // Canvas will actually be much larger, based on DPI\n        this.el.width = pixelScaled.width;\n        this.el.height = pixelScaled.height;\n        // But scaled down on screen\n        this.el.style.width = logicalSizeInteger.width.toString() + `px`;\n        this.el.style.height = logicalSizeInteger.height.toString() + `px`;\n        // Since dimensions have change, reset context\n        this.#getContext(true);\n        if (this.opts.clearOnResize) {\n            this.ctx.clearRect(0, 0, this.width, this.height);\n        }\n        this.#logicalSize = logicalSizeInteger;\n        //console.log(`setting logical size to ${ this.#logicalSize.width }x${ this.#logicalSize.height }`);\n        // Notify listeners of resize\n        const r = this.opts.onResize;\n        if (r) {\n            setTimeout(() => { r(this.ctx, this.size, this); }, 100);\n        }\n        this.fireEvent(`resize`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n    }\n    #init() {\n        //console.log(`init`, this.opts);\n        // If there is a 'draw' callback, set up an animation loop\n        const d = this.opts.draw;\n        if (d) {\n            const sched = () => {\n                d(this.ctx, this.#logicalSize, this);\n                requestAnimationFrame(sched);\n            };\n            setTimeout(() => { sched(); }, 100);\n        }\n        if (!this.opts.disablePointerEvents) {\n            this.#handleEvents();\n        }\n        const resizeLogic = this.opts.resizeLogic ?? `none`;\n        if (resizeLogic === `none`) {\n            this.setLogicalSize({ width: this.opts.width, height: this.opts.height });\n        }\n        else {\n            const resizerOptions = {\n                onSetSize: (size) => {\n                    if (Rects.isEqual(this.#logicalSize, size))\n                        return;\n                    this.setLogicalSize(size);\n                },\n                naturalSize: { width: this.opts.width, height: this.opts.height },\n                stretch: this.opts.resizeLogic ?? `none`\n            };\n            this.#resizer = new ElementSizer(this.el, resizerOptions);\n        }\n        this.#getContext();\n    }\n    #handleEvents() {\n        const handlePointerEvent = (event) => {\n            const { offsetX, offsetY } = event;\n            const physicalX = offsetX * this.ratio;\n            const physicalY = offsetY * this.ratio;\n            event = cloneFromFields(event);\n            const eventData = {\n                physicalX, physicalY,\n                // eslint-disable-next-line @typescript-eslint/no-misused-spread\n                ...event\n            };\n            switch (event.type) {\n                case `pointerup`: {\n                    {\n                        this.fireEvent(`pointerup`, eventData);\n                        break;\n                    }\n                    ;\n                }\n                case `pointermove`: {\n                    {\n                        this.fireEvent(`pointermove`, eventData);\n                        break;\n                    }\n                    ;\n                }\n                case `pointerdown`: {\n                    {\n                        this.fireEvent(`pointerup`, eventData);\n                        break;\n                    }\n                    ;\n                }\n            }\n            ;\n        };\n        this.el.addEventListener(`pointermove`, handlePointerEvent);\n        this.el.addEventListener(`pointerdown`, handlePointerEvent);\n        this.el.addEventListener(`pointerup`, handlePointerEvent);\n    }\n    /**\n     * Clears the canvas.\n     *\n     * Shortcut for:\n     * `ctx.clearRect(0, 0, this.width, this.height)`\n     */\n    clear() {\n        if (!this.#ctx)\n            return;\n        this.#ctx.clearRect(0, 0, this.width, this.height);\n    }\n    /**\n     * Fills the canvas with a given colour.\n     *\n     * Shortcut for:\n     * ```js\n        * ctx.fillStyle = ``;\n     * ctx.fillRect(0, 0, this.width, this.height);\n     * ```\n     * @param colour Colour\n     */\n    fill(colour) {\n        if (!this.#ctx)\n            return;\n        if (colour)\n            this.#ctx.fillStyle = colour;\n        this.#ctx.fillRect(0, 0, this.width, this.height);\n    }\n    /**\n     * Gets the drawing context\n     */\n    get ctx() {\n        if (this.#ctx === undefined)\n            throw new Error(`Context not available`);\n        return this.#getContext();\n    }\n    get viewport() {\n        return this.#viewport;\n    }\n    /**\n     * Gets the logical width of the canvas\n     * See also: {@link height}, {@link size}\n     */\n    get width() {\n        return this.#logicalSize.width;\n    }\n    /**\n     * Gets the logical height of the canvas\n     * See also: {@link width}, {@link size}\n     */\n    get height() {\n        return this.#logicalSize.height;\n    }\n    /**\n     * Gets the logical size of the canvas\n     * See also: {@link width}, {@link height}\n     */\n    get size() {\n        return this.#logicalSize;\n    }\n    /**\n     * Gets the current scaling ratio being used\n     * to compensate for high-DPI display\n     */\n    get ratio() {\n        return window.devicePixelRatio || 1;\n    }\n    /**\n     * Returns the width or height, whichever is smallest\n     */\n    get dimensionMin() {\n        return Math.min(this.width, this.height);\n    }\n    /**\n     * Returns the width or height, whichever is largest\n     */\n    get dimensionMax() {\n        return Math.max(this.width, this.height);\n    }\n    drawBounds(strokeStyle = `green`) {\n        const ctx = this.#getContext();\n        Drawing.rect(ctx, { x: 0, y: 0, width: this.width, height: this.height }, { crossed: true, strokeStyle, strokeWidth: 1 });\n        Drawing.rect(ctx, this.#viewport, { crossed: true, strokeStyle: `silver`, strokeWidth: 3 });\n    }\n    /**\n     * Returns a Scaler that converts from absolute\n     * to relative coordinates.\n     * This is based on the canvas size.\n     *\n     * ```js\n        * // Assuming a canvas of 800x500\n     * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }\n     * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }\n     * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n     * ```\n     */\n    get toRelative() {\n        return this.#scaler.rel;\n    }\n    /**\n     * Returns a scaler for points based on width & height\n     */\n    get toAbsoluteFixed() {\n        return this.#scalerSize.abs;\n    }\n    /**\n     * Returns a scaler for points based on width & height\n     */\n    get toRelativeFixed() {\n        return this.#scalerSize.rel;\n    }\n    get logicalCenter() {\n        return {\n            x: this.#logicalSize.width / 2,\n            y: this.#logicalSize.height / 2\n        };\n    }\n    /**\n   * Returns a Scaler that converts from relative to absolute\n   * coordinates.\n   * This is based on the canvas size.\n   *\n   * ```js\n   * // Assuming a canvas of 800x600\n   * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n   * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n   * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n   * ```\n   */\n    get toAbsolute() {\n        return this.#scaler.abs;\n    }\n    /**\n     * Gets the center coordinate of the canvas\n     */\n    get center() {\n        return { x: this.width / 2, y: this.height / 2 };\n    }\n    /**\n     * Gets the image data for the canvas.\n     * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be\n     * 536x536 with a high-DPI display.\n     * @returns\n     */\n    getImageData() {\n        const size = this.getPhysicalSize();\n        const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (data === null || data === undefined)\n            throw new Error(`Could not get image data from context`);\n        return data;\n    }\n    /**\n     * Returns the canvas frame data as a writable grid.\n     * When editing, make as many edits as needed before calling\n     * `flip`, which writes buffer back to the canvas.\n     * ```js\n        * const g = helper.getWritableBuffer();\n     * // Get {r,g,b,opacity} of pixel 10,10\n     * const pixel = g.get({ x: 10, y: 10 });\n     *\n     * // Set a colour to pixel 10,10\n     * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });\n     *\n     * // Write buffer to canvas\n     * g.flip();\n     * ```\n     *\n     * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will\n     * mean a higher number of rows and columns compared to the logical size.\n     * @returns\n     */\n    getWritableBuffer() {\n        const ctx = this.ctx;\n        const data = this.getImageData();\n        const grid = ImageDataGrid.grid(data);\n        const get = ImageDataGrid.accessor(data);\n        const set = ImageDataGrid.setter(data);\n        const flip = () => {\n            ctx.putImageData(data, 0, 0);\n        };\n        return { grid, get, set, flip };\n    }\n}\n// export const imageDataAsGrid = (canvas: HTMLCanvasElement, colorSpace: PredefinedColorSpace = `srgb`) => {\n//   const ctx = canvas.getContext(`2d`);\n//   if (!ctx) throw new Error(`Could not create context`);\n//   const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace });\n//   if (!data) throw new Error(`Could not get image data from context`);\n//   const get = ImageDataGrid.accessor(data);\n//   const set = ImageDataGrid.setter(data);\n// }\n","/**\n * Applies drawing options to given SVG element.\n * Applies: fillStyle\n * @param elem Element\n * @param opts Drawing options\n */\nexport const applyOpts = (elem, opts) => {\n    if (opts.fillStyle)\n        elem.setAttributeNS(null, `fill`, opts.fillStyle);\n    if (opts.opacity) {\n        elem.setAttributeNS(null, `opacity`, opts.opacity.toString());\n    }\n};\n","/**\n * Creates an element of `type` and with `id` (if specified)\n * @param type Element type, eg `circle`\n * @param id Optional id to assign to element\n * @returns Element\n */\nexport const createEl = (type, id) => {\n    const m = document.createElementNS(`http://www.w3.org/2000/svg`, type);\n    if (id) {\n        m.id = id;\n    }\n    return m;\n};\n/**\n * Creates and appends a SVG element.\n *\n * ```js\n * // Create a circle\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`);\n * ```\n *\n * If `queryOrExisting` is specified, it is used as a query to find an existing element. If\n * query starts with `#`, this will be set as the element id, if created.\n *\n * ```js\n * // Creates an element with id 'myCircle' if it doesn't exist\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`, `#myCircle`);\n * ```\n * @param parent Parent element\n * @param type Type of SVG element\n * @param queryOrExisting Query, eg `#id`\n * @returns\n */\nexport const createOrResolve = (parent, type, queryOrExisting, suffix) => {\n    let existing = null;\n    if (queryOrExisting !== undefined) {\n        existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;\n    }\n    if (existing === null) {\n        const p = document.createElementNS(`http://www.w3.org/2000/svg`, type);\n        parent.append(p);\n        if (queryOrExisting && typeof queryOrExisting === `string` &&\n            queryOrExisting.startsWith(`#`)) {\n            p.id = suffix !== undefined && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);\n        }\n        return p;\n    }\n    return existing;\n};\n","import * as C from \"colorizr\";\nimport { throwNumberInclusiveRangeTest, throwNumberTest } from \"@ixfx/guards\";\nconst withOpacity = (value, fn) => {\n    switch (value.unit) {\n        case `absolute`:\n            return {\n                ...value,\n                opacity: fn((value.opacity ?? 100) / 100, value) * 100\n            };\n        case `scalar`:\n            return {\n                ...value,\n                opacity: fn((value.opacity ?? 1), value)\n            };\n    }\n};\nconst fromCss = (value) => {\n    if (value.startsWith(`hsl`))\n        throw new Error(`Expecting CSS string in the form of 'hsl(...) or hsla(...)'. Got: '${value}'`);\n    const c = C.extractColorParts(value);\n    if (c.model !== `hsl`)\n        throw new Error(`Expecting HSL colour space. Got: ${c.model}`);\n    return fromLibrary(c);\n};\nconst toCss = (hsl) => {\n    const abs = toAbsolute(hsl);\n    let css = `hsl(${abs.h}deg ${abs.s}% ${abs.l}%`;\n    if (`opacity` in abs && abs.opacity !== undefined) {\n        css += ` / ${abs.opacity / 100}`;\n    }\n    css += ')';\n    return css;\n};\nconst toLibrary = (hsl) => {\n    const abs = toAbsolute(hsl);\n    return {\n        h: abs.h,\n        s: abs.s,\n        l: abs.l,\n        alpha: abs.opacity,\n    };\n};\nconst fromLibrary = (hsl) => {\n    return {\n        h: hsl.h,\n        s: hsl.s,\n        l: hsl.l,\n        opacity: hsl.alpha ?? 100,\n        unit: `absolute`,\n        space: `hsl`\n    };\n};\nconst toAbsolute = (hsl) => {\n    guard(hsl);\n    if (hsl.unit === `absolute`)\n        return hsl;\n    return {\n        h: hsl.h * 360,\n        s: hsl.s * 100,\n        l: hsl.l * 100,\n        opacity: hsl.opacity ?? 100,\n        unit: `absolute`,\n        space: `hsl`\n    };\n};\nconst toScalar = (hsl) => {\n    guard(hsl);\n    if (hsl.unit === `scalar`)\n        return hsl;\n    return {\n        h: hsl.h / 360,\n        s: hsl.s / 100,\n        l: hsl.l / 100,\n        opacity: (hsl.opacity ?? 1) / 100,\n        unit: `scalar`,\n        space: `hsl`\n    };\n};\nconst guard = (hsl) => {\n    const { h, s, l, opacity, space, unit } = hsl;\n    if (space !== `hsl`)\n        throw new Error(`Space is expected to be 'hsl'. Got: ${space}`);\n    if (unit === `absolute`) {\n        throwNumberTest(h, `finite`, `h`);\n        throwNumberInclusiveRangeTest(s, 0, 100, `s`);\n        throwNumberInclusiveRangeTest(l, 0, 100, `l`);\n        if (typeof opacity === `number`) {\n            throwNumberInclusiveRangeTest(opacity, 0, 100, `s`);\n        }\n    }\n    else if (unit === `scalar`) {\n        throwNumberTest(h, `percentage`, `h`);\n        throwNumberTest(s, `percentage`, `s`);\n        throwNumberTest(l, `percentage`, `l`);\n        if (typeof opacity === `number`) {\n            throwNumberTest(opacity, `percentage`, `opacity`);\n        }\n    }\n    else {\n        throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${unit}`);\n    }\n};\nexport const HslSpace = { withOpacity, fromCss, toCss, toLibrary, fromLibrary, guard, toScalar, toAbsolute };\n","export const cssDefinedHexColours = {\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",\n    \"bisque\": \"#ffe4c4\",\n    \"black\": \"#000000\",\n    \"blanchedalmond\": \"#ffebcd\",\n    \"blue\": \"#0000ff\",\n    \"blueviolet\": \"#8a2be2\",\n    \"brown\": \"#a52a2a\",\n    \"burlywood\": \"#deb887\",\n    \"cadetblue\": \"#5f9ea0\",\n    \"chartreuse\": \"#7fff00\",\n    \"chocolate\": \"#d2691e\",\n    \"coral\": \"#ff7f50\",\n    \"cornflowerblue\": \"#6495ed\",\n    \"cornsilk\": \"#fff8dc\",\n    \"crimson\": \"#dc143c\",\n    \"cyan\": \"#00ffff\",\n    \"darkblue\": \"#00008b\",\n    \"darkcyan\": \"#008b8b\",\n    \"darkgoldenrod\": \"#b8860b\",\n    \"darkgray\": \"#a9a9a9\",\n    \"darkgreen\": \"#006400\",\n    \"darkkhaki\": \"#bdb76b\",\n    \"darkmagenta\": \"#8b008b\",\n    \"darkolivegreen\": \"#556b2f\",\n    \"darkorange\": \"#ff8c00\",\n    \"darkorchid\": \"#9932cc\",\n    \"darkred\": \"#8b0000\",\n    \"darksalmon\": \"#e9967a\",\n    \"darkseagreen\": \"#8fbc8f\",\n    \"darkslateblue\": \"#483d8b\",\n    \"darkslategray\": \"#2f4f4f\",\n    \"darkturquoise\": \"#00ced1\",\n    \"darkviolet\": \"#9400d3\",\n    \"deeppink\": \"#ff1493\",\n    \"deepskyblue\": \"#00bfff\",\n    \"dimgray\": \"#696969\",\n    \"dodgerblue\": \"#1e90ff\",\n    \"firebrick\": \"#b22222\",\n    \"floralwhite\": \"#fffaf0\",\n    \"forestgreen\": \"#228b22\",\n    \"fuchsia\": \"#ff00ff\",\n    \"gainsboro\": \"#dcdcdc\",\n    \"ghostwhite\": \"#f8f8ff\",\n    \"gold\": \"#ffd700\",\n    \"goldenrod\": \"#daa520\",\n    \"gray\": \"#808080\",\n    \"green\": \"#008000\",\n    \"greenyellow\": \"#adff2f\",\n    \"honeydew\": \"#f0fff0\",\n    \"hotpink\": \"#ff69b4\",\n    \"indianred\": \"#cd5c5c\",\n    \"indigo\": \"#4b0082\",\n    \"ivory\": \"#fffff0\",\n    \"khaki\": \"#f0e68c\",\n    \"lavender\": \"#e6e6fa\",\n    \"lavenderblush\": \"#fff0f5\",\n    \"lawngreen\": \"#7cfc00\",\n    \"lemonchiffon\": \"#fffacd\",\n    \"lightblue\": \"#add8e6\",\n    \"lightcoral\": \"#f08080\",\n    \"lightcyan\": \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgray\": \"#d3d3d3\",\n    \"lightgreen\": \"#90ee90\",\n    \"lightpink\": \"#ffb6c1\",\n    \"lightsalmon\": \"#ffa07a\",\n    \"lightseagreen\": \"#20b2aa\",\n    \"lightskyblue\": \"#87cefa\",\n    \"lightslategray\": \"#778899\",\n    \"lightsteelblue\": \"#b0c4de\",\n    \"lightyellow\": \"#ffffe0\",\n    \"lime\": \"#00ff00\",\n    \"limegreen\": \"#32cd32\",\n    \"linen\": \"#faf0e6\",\n    \"magenta\": \"#ff00ff\",\n    \"maroon\": \"#800000\",\n    \"mediumaquamarine\": \"#66cdaa\",\n    \"mediumblue\": \"#0000cd\",\n    \"mediumorchid\": \"#ba55d3\",\n    \"mediumpurple\": \"#9370db\",\n    \"mediumseagreen\": \"#3cb371\",\n    \"mediumslateblue\": \"#7b68ee\",\n    \"mediumspringgreen\": \"#00fa9a\",\n    \"mediumturquoise\": \"#48d1cc\",\n    \"mediumvioletred\": \"#c71585\",\n    \"midnightblue\": \"#191970\",\n    \"mintcream\": \"#f5fffa\",\n    \"mistyrose\": \"#ffe4e1\",\n    \"moccasin\": \"#ffe4b5\",\n    \"navajowhite\": \"#ffdead\",\n    \"navy\": \"#000080\",\n    \"oldlace\": \"#fdf5e6\",\n    \"olive\": \"#808000\",\n    \"olivedrab\": \"#6b8e23\",\n    \"orange\": \"#ffa500\",\n    \"orangered\": \"#ff4500\",\n    \"orchid\": \"#da70d6\",\n    \"palegoldenrod\": \"#eee8aa\",\n    \"palegreen\": \"#98fb98\",\n    \"paleturquoise\": \"#afeeee\",\n    \"palevioletred\": \"#db7093\",\n    \"papayawhip\": \"#ffefd5\",\n    \"peachpuff\": \"#ffdab9\",\n    \"peru\": \"#cd853f\",\n    \"pink\": \"#ffc0cb\",\n    \"plum\": \"#dda0dd\",\n    \"powderblue\": \"#b0e0e6\",\n    \"purple\": \"#800080\",\n    \"rebeccapurple\": \"#663399\",\n    \"red\": \"#ff0000\",\n    \"rosybrown\": \"#bc8f8f\",\n    \"royalblue\": \"#4169e1\",\n    \"saddlebrown\": \"#8b4513\",\n    \"salmon\": \"#fa8072\",\n    \"sandybrown\": \"#f4a460\",\n    \"seagreen\": \"#2e8b57\",\n    \"seashell\": \"#fff5ee\",\n    \"sienna\": \"#a0522d\",\n    \"silver\": \"#c0c0c0\",\n    \"skyblue\": \"#87ceeb\",\n    \"slateblue\": \"#6a5acd\",\n    \"slategray\": \"#708090\",\n    \"snow\": \"#fffafa\",\n    \"springgreen\": \"#00ff7f\",\n    \"steelblue\": \"#4682b4\",\n    \"tan\": \"#d2b48c\",\n    \"teal\": \"#008080\",\n    \"thistle\": \"#d8bfd8\",\n    \"tomato\": \"#ff6347\",\n    \"turquoise\": \"#40e0d0\",\n    \"violet\": \"#ee82ee\",\n    \"wheat\": \"#f5deb3\",\n    \"white\": \"#ffffff\",\n    \"whitesmoke\": \"#f5f5f5\",\n    \"yellow\": \"#ffff00\",\n    \"yellowgreen\": \"#9acd32\"\n};\n","import * as C from \"colorizr\";\nimport { SrgbSpace } from \"./srgb.js\";\nimport { HslSpace } from './hsl.js';\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nconst hexStringToColour = (hexString) => {\n    const rgb = C.hex2rgb(hexString);\n    return SrgbSpace.fromLibrary(rgb);\n};\nexport const toCssColour = (colour) => {\n    if (typeof colour === `string`)\n        return colour;\n    switch (colour.space) {\n        case `hsl`:\n            return HslSpace.toCss(colour);\n        case `srgb`:\n            return SrgbSpace.toCss(colour);\n        default:\n            throw new Error(`Unknown colour space: '${colour.space}'`);\n    }\n};\nexport const fromCssColour = (colour) => {\n    if (colour.startsWith(`#`)) {\n        return hexStringToColour(colour);\n    }\n    if (typeof cssDefinedHexColours[colour] !== `undefined`) {\n        return hexStringToColour(cssDefinedHexColours[colour]);\n    }\n    if (colour.startsWith(`--`)) {\n        const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n        if (fromCss.length === 0)\n            throw new Error(`Variable missing: ${colour}`);\n        if (fromCss.startsWith(`#`))\n            hexStringToColour(fromCss);\n        if (fromCss.startsWith(`rgb`))\n            return SrgbSpace.fromCss(fromCss);\n        if (fromCss.startsWith(`hsl`))\n            return HslSpace.fromCss(fromCss);\n        throw new Error(`CSS variable value not a hex, rgb or hsl colour function: '${fromCss}'`);\n    }\n    throw new Error(`String colour is not a hex colour nor well-defined colour name`);\n};\nexport const guard = (colour) => {\n    switch (colour.space) {\n        case `hsl`:\n            HslSpace.guard(colour);\n            break;\n        case `srgb`:\n            SrgbSpace.guard(colour);\n            break;\n        default:\n            throw new Error(`Unknown colour space: '${colour.space}'`);\n    }\n};\nexport const toColour = (colourish) => {\n    let c;\n    if (typeof colourish === `string`)\n        c = fromCssColour(colourish);\n    else\n        c = colourish;\n    if (c === undefined)\n        throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n    guard(c);\n    return c;\n};\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n *\n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n *\n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns\n */\nexport const toStringFirst = (...colours) => {\n    for (const colour of colours) {\n        if (colour === undefined)\n            continue;\n        if (colour === null)\n            continue;\n        try {\n            const c = toColour(colour);\n            return toCssColour(c);\n        }\n        catch { /* empty */ }\n    }\n    return `rebeccapurple`;\n};\n","/**\n * Applies drawing options to given SVG element.\n * Applies: strokeStyle, strokeWidth, strokeDash, strokeLineCap\n * @param elem Element\n * @param opts\n */\nexport const applyStrokeOpts = (elem, opts) => {\n    if (opts.strokeStyle)\n        elem.setAttributeNS(null, `stroke`, opts.strokeStyle);\n    if (opts.strokeWidth) {\n        elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());\n    }\n    if (opts.strokeDash)\n        elem.setAttribute(`stroke-dasharray`, opts.strokeDash);\n    if (opts.strokeLineCap) {\n        elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);\n    }\n};\n","//import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\n//import type { Point } from '../../geometry/point/PointType.js';\n//import type { Line } from '../../geometry/line/LineType.js';\n//import * as Lines from '../geometry/line/index.js';\nimport { Lines, Polar } from '@ixfx/geometry';\n//import * as Svg from './index.js';\nimport { toStringFirst as ColourStringFirst } from '../colour/conversion.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { createEl, createOrResolve } from './create.js';\nimport { applyPathOpts } from './path.js';\n//import type { PolarRay } from 'src/geometry/polar/Types.js';\n//import { toCartesian as polarRayToCartesian } from 'src/geometry/polar/Ray.js';\n//import {Palette} from \".\";\nconst numberOrPercentage = (v) => {\n    if (v >= 0 && v <= 1)\n        return `${v * 100}%`;\n    return v.toString();\n};\n/**\n * Creates and adds an SVG path element\n * @example\n * ```js\n * const paths = [\n *  `M300,200`,\n *  `a25,25 -30 0,1 50, -25 l 50,-25`\n * ]\n * const pathEl = path(paths, parentEl);\n * ```\n * @param svgOrArray Path syntax, or array of paths. Can be empty if path data will be added later\n * @param parent SVG parent element\n * @param opts Options Drawing options\n * @returns\n */\nexport const path = (svgOrArray, parent, opts, queryOrExisting) => {\n    const elem = createOrResolve(parent, `path`, queryOrExisting);\n    const svg = typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`\\n`);\n    elem.setAttributeNS(null, `d`, svg);\n    parent.append(elem);\n    return pathUpdate(elem, opts);\n};\nexport const pathUpdate = (elem, opts) => {\n    if (opts)\n        applyOpts(elem, opts);\n    if (opts)\n        applyStrokeOpts(elem, opts);\n    return elem;\n};\n/**\n * Updates an existing `SVGCircleElement` with potentially updated circle data and drawing options\n * @param elem Element\n * @param circle Circle\n * @param opts Drawing options\n * @returns SVGCircleElement\n */\nexport const circleUpdate = (elem, circle, opts) => {\n    elem.setAttributeNS(null, `cx`, circle.x.toString());\n    elem.setAttributeNS(null, `cy`, circle.y.toString());\n    elem.setAttributeNS(null, `r`, circle.radius.toString());\n    if (opts)\n        applyOpts(elem, opts);\n    if (opts)\n        applyStrokeOpts(elem, opts);\n    return elem;\n};\n/**\n * Creates or reuses a `SVGCircleElement`.\n *\n * To update an existing element, use `circleUpdate`\n * @param circle\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const circle = (circle, parent, opts, queryOrExisting) => {\n    const p = createOrResolve(parent, `circle`, queryOrExisting);\n    return circleUpdate(p, circle, opts);\n};\n/**\n * Creates or resuses a `SVGGElement` (group)\n *\n * To update an existing elemnet, use `groupUpdate`\n * @param children\n * @param parent\n * @param queryOrExisting\n * @returns\n */\nexport const group = (children, parent, queryOrExisting) => {\n    const p = createOrResolve(parent, `g`, queryOrExisting);\n    return groupUpdate(p, children);\n};\nexport const groupUpdate = (elem, children) => {\n    for (const c of children) {\n        if (c.parentNode !== elem) {\n            elem.append(c);\n        }\n    }\n    return elem;\n};\n/**\n * Creates or reuses a SVGLineElement.\n *\n * @param line\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const line = (line, parent, opts, queryOrExisting) => {\n    const lineEl = createOrResolve(parent, `line`, queryOrExisting);\n    return lineUpdate(lineEl, line, opts);\n};\n/**\n * Updates a SVGLineElement instance with potentially changed line and drawing data\n * @param lineEl\n * @param line\n * @param opts\n * @returns\n */\nexport const lineUpdate = (lineEl, line, opts) => {\n    lineEl.setAttributeNS(null, `x1`, line.a.x.toString());\n    lineEl.setAttributeNS(null, `y1`, line.a.y.toString());\n    lineEl.setAttributeNS(null, `x2`, line.b.x.toString());\n    lineEl.setAttributeNS(null, `y2`, line.b.y.toString());\n    if (opts)\n        applyOpts(lineEl, opts);\n    if (opts)\n        applyPathOpts(lineEl, opts);\n    if (opts)\n        applyStrokeOpts(lineEl, opts);\n    return lineEl;\n};\nexport const polarRayUpdate = (lineEl, ray, opts) => {\n    const l = Polar.Ray.toCartesian(ray);\n    lineEl.setAttributeNS(null, `x1`, l.a.x.toString());\n    lineEl.setAttributeNS(null, `y1`, l.a.y.toString());\n    lineEl.setAttributeNS(null, `x2`, l.b.x.toString());\n    lineEl.setAttributeNS(null, `y2`, l.b.y.toString());\n    if (opts)\n        applyOpts(lineEl, opts);\n    if (opts)\n        applyPathOpts(lineEl, opts);\n    if (opts)\n        applyStrokeOpts(lineEl, opts);\n    return lineEl;\n};\n/**\n * Updates an existing SVGTextPathElement instance with text and drawing options\n * @param el\n * @param text\n * @param opts\n * @returns\n */\nexport const textPathUpdate = (el, text, opts) => {\n    if (opts?.method)\n        el.setAttributeNS(null, `method`, opts.method);\n    if (opts?.side)\n        el.setAttributeNS(null, `side`, opts.side);\n    if (opts?.spacing)\n        el.setAttributeNS(null, `spacing`, opts.spacing);\n    if (opts?.startOffset) {\n        el.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));\n    }\n    if (opts?.textLength) {\n        el.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));\n    }\n    if (text) {\n        el.textContent = text;\n    }\n    if (opts)\n        applyOpts(el, opts);\n    if (opts)\n        applyStrokeOpts(el, opts);\n    return el;\n};\n/**\n * Creates or reuses a SVGTextPathElement.\n * @param pathReference\n * @param text\n * @param parent\n * @param opts\n * @param textQueryOrExisting\n * @param pathQueryOrExisting\n * @returns\n */\nexport const textPath = (pathReference, text, parent, opts, textQueryOrExisting, pathQueryOrExisting) => {\n    const textEl = createOrResolve(parent, `text`, textQueryOrExisting, `-text`);\n    // Update text properties, but don't pass in position or text\n    textUpdate(textEl, undefined, undefined, opts);\n    const p = createOrResolve(textEl, `textPath`, pathQueryOrExisting);\n    p.setAttributeNS(null, `href`, pathReference);\n    return textPathUpdate(p, text, opts);\n};\n/**\n * Updates an existing SVGTextElement instance with position, text and drawing options\n * @param el\n * @param pos\n * @param text\n * @param opts\n * @returns\n */\nexport const textUpdate = (el, pos, text, opts) => {\n    if (pos) {\n        el.setAttributeNS(null, `x`, pos.x.toString());\n        el.setAttributeNS(null, `y`, pos.y.toString());\n    }\n    if (text) {\n        el.textContent = text;\n    }\n    if (opts) {\n        applyOpts(el, opts);\n        if (opts)\n            applyStrokeOpts(el, opts);\n        if (opts.anchor)\n            el.setAttributeNS(null, `text-anchor`, opts.anchor);\n        if (opts.align)\n            el.setAttributeNS(null, `alignment-baseline`, opts.align);\n        const userSelect = opts.userSelect ?? true;\n        if (!userSelect) {\n            el.style.userSelect = `none`;\n        }\n    }\n    return el;\n};\n/**\n * Creates or reuses a SVGTextElement\n * @param pos Position of text\n * @param text Text\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const text = (text, parent, pos, opts, queryOrExisting) => {\n    const p = createOrResolve(parent, `text`, queryOrExisting);\n    return textUpdate(p, pos, text, opts);\n};\n/**\n * Creates a square grid based at a center point, with cells having `spacing` height and width.\n *\n * It fits in as many cells as it can within `width` and `height`.\n *\n * Returns a SVG group, consisting of horizontal and vertical lines\n * @param parent Parent element\n * @param center Center point of grid\n * @param spacing Width/height of cells\n * @param width How wide grid should be\n * @param height How high grid should be\n * @param opts\n */\nexport const grid = (parent, center, spacing, width, height, opts = {}) => {\n    if (!opts.strokeStyle) {\n        opts = { ...opts, strokeStyle: ColourStringFirst(`bg-dim`, `silver`) };\n    }\n    if (!opts.strokeWidth)\n        opts = { ...opts, strokeWidth: 1 };\n    const g = createEl(`g`);\n    applyOpts(g, opts);\n    applyPathOpts(g, opts);\n    applyStrokeOpts(g, opts);\n    // Horizontals\n    let y = 0;\n    while (y < height) {\n        const horiz = Lines.fromNumbers(0, y, width, y);\n        line(horiz, g);\n        y += spacing;\n    }\n    // Verticals\n    let x = 0;\n    while (x < width) {\n        const vert = Lines.fromNumbers(x, 0, x, height);\n        line(vert, g);\n        x += spacing;\n    }\n    parent.append(g);\n    return g;\n};\n","import { PointsTracker } from '@ixfx/geometry/point';\nimport * as Svg from './svg/index.js';\nimport { ElementSizer, resolveEl } from '@ixfx/dom';\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery Element to monitor\n * @param options Options\n */\nexport const pointerVisualise = (elOrQuery, options = {}) => {\n    const touchRadius = options.touchRadius ?? 45;\n    const mouseRadius = options.touchRadius ?? 20;\n    const trace = options.trace ?? false;\n    const hue = options.hue ?? 100;\n    const startFillStyle = `hsla(${hue}, 100%, 10%, 10%)`;\n    let currentHue = hue;\n    const el = resolveEl(elOrQuery);\n    const tracker = new PointsTracker({\n        storeIntermediate: trace,\n    });\n    const svg = document.createElementNS(`http://www.w3.org/2000/svg`, `svg`);\n    svg.id = `pointerVis`;\n    svg.style.zIndex = `-1000`;\n    svg.style.position = `fixed`;\n    svg.style.top = `0`;\n    svg.style.left = `0`;\n    svg.style.width = `100%`;\n    svg.style.height = `100%`;\n    svg.style.boxSizing = `border-box`;\n    svg.style.border = `3px solid red`;\n    svg.style.pointerEvents = `none`;\n    svg.style.touchAction = `none`;\n    // const er = new ElementSizer(svg, {\n    //   containerEl:document.body,\n    //   stretch:`both`,\n    //   onSetSize(size) {\n    //     svg.setAttribute(`width`, size.width.toString());\n    //     svg.setAttribute(`height`, size.height.toString());\n    //   },\n    // })\n    const er = ElementSizer.svgViewport(svg);\n    //fullSizeElement(svg);\n    let pointerCount = 0;\n    const lostPointer = (event) => {\n        const id = event.pointerId.toString();\n        tracker.delete(id);\n        currentHue = hue;\n        svg.querySelector(`#pv-start-${id}`)?.remove();\n        for (let index = 0; index < pointerCount + 10; index++) {\n            svg.querySelector(`#pv-progress-${id}-${index}`)?.remove();\n        }\n        pointerCount = 0;\n    };\n    const trackPointer = async (event) => {\n        const id = event.pointerId.toString();\n        const pt = { x: event.x, y: event.y };\n        const type = event.pointerType;\n        if (event.type === `pointermove` && !tracker.has(id)) {\n            return;\n        }\n        const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n        if (info.values.length === 1) {\n            const el = Svg.Elements.circle({\n                ...info.values[0],\n                radius: type === `touch` ? touchRadius : mouseRadius,\n            }, svg, {\n                fillStyle: startFillStyle,\n            }, `#pv-start-${id}`);\n            el.style.pointerEvents = `none`;\n            el.style.touchAction = `none`;\n        }\n        const fillStyle = `hsla(${currentHue}, 100%, 50%, 50%)`;\n        const el2 = Svg.Elements.circle({ ...pt, radius: type === `touch` ? touchRadius : mouseRadius }, svg, {\n            fillStyle,\n        }, `#pv-progress-${id}-${info.values.length}`);\n        el2.style.pointerEvents = `none`;\n        el2.style.touchAction = `none`;\n        currentHue += 1;\n        pointerCount = info.values.length;\n    };\n    document.body.append(svg);\n    el.addEventListener(`pointerdown`, trackPointer);\n    el.addEventListener(`pointermove`, trackPointer);\n    el.addEventListener(`pointerup`, lostPointer);\n    el.addEventListener(`pointerleave`, lostPointer);\n    el.addEventListener(`contextmenu`, (event) => {\n        event.preventDefault();\n    });\n};\n","import { throwNumberTest } from '@ixfx/guards';\nimport {} from '@ixfx/random';\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (index, saturation = 0.5, lightness = 0.75, alpha = 1) => {\n    throwNumberTest(index, `positive`, `index`);\n    throwNumberTest(saturation, `percentage`, `saturation`);\n    throwNumberTest(lightness, `percentage`, `lightness`);\n    throwNumberTest(alpha, `percentage`, `alpha`);\n    // Via Stackoverflow\n    const hue = index * 137.508; // use golden angle approximation\n    return alpha === 1 ? `hsl(${hue},${saturation * 100}%,${lightness * 100}%)` : `hsl(${hue},${saturation * 100}%,${lightness * 100}%,${alpha * 100}%)`;\n};\n/**\n * Returns a random hue component (0..359)\n * ```\n * // Generate hue\n * const h =randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand = Math.random) => {\n    const r = rand();\n    return r * 360;\n};\n","import { toColour, toCssColour } from './conversion.js';\nimport { HslSpace } from './hsl.js';\nimport { SrgbSpace } from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\nexport function multiplyOpacity(colourish, amount) {\n    return withOpacity(colourish, o => clamp(o * amount));\n}\nexport function withOpacity(colourish, fn) {\n    const colour = toColour(colourish);\n    let result;\n    switch (colour.space) {\n        case `hsl`:\n            result = HslSpace.withOpacity(colour, fn);\n            break;\n        case `srgb`:\n            result = SrgbSpace.withOpacity(colour, fn);\n            break;\n        default:\n            throw new Error(`Unknown space: '${colour.space}'. Expected hsl, srgb, oklch`);\n    }\n    if (!result)\n        throw new Error(`Is colour in correct form?`);\n    if (typeof colourish === `string`) {\n        // Convert back to string if input was a string\n        return toCssColour(result);\n    }\n    return result;\n}\n;\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };\n","export * from './generate.js';\nexport * from './conversion.js';\nexport { HslSpace } from './hsl.js';\n//export * from './interpolate.js';\nexport * from './math.js';\n//export * from './oklch.js';\nexport { SrgbSpace as RgbSpace } from './srgb.js';\n","import { continuously } from '@ixfx/core';\nimport { delayLoop } from '@ixfx/flow';\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import { Video } from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\nexport async function* frames(sourceVideoEl, opts = {}) {\n    // TODO: Ideally use OffscreenCanvas when it has wider support?\n    // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n    const maxIntervalMs = opts.maxIntervalMs ?? 0;\n    const showCanvas = opts.showCanvas ?? false;\n    let canvasEl = opts.canvasEl;\n    let w, h;\n    w = h = 0;\n    // Create & setup canvas\n    if (canvasEl === undefined) {\n        canvasEl = document.createElement(`CANVAS`);\n        canvasEl.classList.add(`ixfx-frames`);\n        if (!showCanvas) {\n            canvasEl.style.display = `none`;\n        }\n        document.body.appendChild(canvasEl);\n    }\n    // Update size of canvas based on video\n    const updateSize = () => {\n        if (canvasEl === undefined)\n            return;\n        w = sourceVideoEl.videoWidth;\n        h = sourceVideoEl.videoHeight;\n        canvasEl.width = w;\n        canvasEl.height = h;\n    };\n    let c = null;\n    const looper = delayLoop(maxIntervalMs);\n    for await (const _ of looper) {\n        // If we don't yet have the size of video, get it\n        if (w === 0 || h === 0)\n            updateSize();\n        // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n        if (w === 0 || h === 0)\n            continue;\n        // Draw current frame from video element to hidden canvas\n        if (c === null)\n            c = canvasEl.getContext(`2d`);\n        if (c === null)\n            return;\n        c.drawImage(sourceVideoEl, 0, 0, w, h);\n        // Get pixels\n        const pixels = c.getImageData(0, 0, w, h);\n        yield pixels;\n    }\n}\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (sourceVideoEl, opts = {}) => {\n    const maxIntervalMs = opts.maxIntervalMs ?? 0;\n    const showCanvas = opts.showCanvas ?? false;\n    const onFrame = opts.onFrame;\n    // Ideally use OffscreenCanvas when it has support?\n    const w = sourceVideoEl.videoWidth;\n    const h = sourceVideoEl.videoHeight;\n    // Create canvas\n    const canvasEl = document.createElement(`CANVAS`);\n    canvasEl.classList.add(`ixfx-capture`);\n    if (!showCanvas) {\n        canvasEl.style.display = `none`;\n    }\n    canvasEl.width = w;\n    canvasEl.height = h;\n    let c = null;\n    let worker;\n    if (opts.workerScript) {\n        worker = new Worker(opts.workerScript);\n    }\n    // Should we get image data?\n    const getPixels = worker || onFrame;\n    if (!getPixels && !showCanvas) {\n        console.warn(`Video will be captured to hidden element without any processing. Is this what you want?`);\n    }\n    const loop = continuously(() => {\n        // Draw current frame from video element to hidden canvas\n        if (c === null)\n            c = canvasEl.getContext(`2d`);\n        if (c === null)\n            return;\n        c.drawImage(sourceVideoEl, 0, 0, w, h);\n        let pixels;\n        if (getPixels) {\n            // ImageData necessary\n            pixels = c.getImageData(0, 0, w, h);\n        }\n        if (worker) {\n            // Send to worker\n            worker.postMessage({\n                pixels: pixels.data.buffer,\n                width: w,\n                height: h,\n                channels: 4,\n            }, [pixels.data.buffer]);\n        }\n        if (onFrame) {\n            // Send to callback\n            try {\n                onFrame(pixels);\n            }\n            catch (e) {\n                console.error(e);\n            }\n        }\n    }, maxIntervalMs);\n    return {\n        start: () => { loop.start(); },\n        cancel: () => { loop.cancel(); },\n        canvasEl,\n    };\n};\nexport const manualCapture = (sourceVideoEl, opts = {}) => {\n    const showCanvas = opts.showCanvas ?? false;\n    // Ideally use OffscreenCanvas when it has support?\n    const w = sourceVideoEl.videoWidth;\n    const h = sourceVideoEl.videoHeight;\n    // Create canvas if necessary\n    const definedCanvasEl = opts.canvasEl !== undefined;\n    let canvasEl = opts.canvasEl;\n    if (!canvasEl) {\n        canvasEl = document.createElement(`CANVAS`);\n        canvasEl.classList.add(`ixfx-capture`);\n        document.body.append(canvasEl);\n        if (!showCanvas)\n            canvasEl.style.display = `none`;\n    }\n    canvasEl.width = w;\n    canvasEl.height = h;\n    const capture = () => {\n        let c;\n        // Draw current frame from video element to canvas\n        if (!c)\n            c = canvasEl.getContext(`2d`, { willReadFrequently: true });\n        if (!c)\n            throw new Error(`Could not create graphics context`);\n        c.drawImage(sourceVideoEl, 0, 0, w, h);\n        const pixels = c.getImageData(0, 0, w, h);\n        pixels.currentTime = sourceVideoEl.currentTime;\n        if (opts.postCaptureDraw)\n            opts.postCaptureDraw(c, w, h);\n        return pixels;\n    };\n    const dispose = () => {\n        if (definedCanvasEl)\n            return; // we didn't create it\n        try {\n            canvasEl.remove();\n        }\n        catch (_) {\n            // no-op\n        }\n    };\n    const c = {\n        canvasEl,\n        capture,\n        dispose,\n    };\n    return c;\n};\n","export * from '@ixfx/visual';"],"x_google_ignoreList":[23],"mappings":"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"}