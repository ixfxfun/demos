{"version":3,"sources":["../src/rx/index.ts","../src/rx/sources/Function.ts","../src/iterables/IterableAsync.ts","../src/rx/sources/Iterator.ts","../src/rx/ResolveSource.ts","../src/rx/Cache.ts","../src/rx/InitStream.ts","../src/dom/SetProperty.ts","../src/rx/sinks/Dom.ts","../src/rx/ToReadable.ts","../src/rx/ops/Annotate.ts","../src/rx/ops/Chunk.ts","../src/rx/ops/Transform.ts","../src/rx/ops/CloneFromFields.ts","../src/rx/ops/CombineLatestToArray.ts","../src/data/Pathed.ts","../src/data/Util.ts","../src/rx/sources/Object.ts","../src/rx/ops/CombineLatestToObject.ts","../src/rx/ops/ComputeWithPrevious.ts","../src/rx/ops/Debounce.ts","../src/rx/ops/Elapsed.ts","../src/rx/ops/Field.ts","../src/rx/ops/Filter.ts","../src/numbers/Wrap.ts","../src/modulation/easing/index.ts","../src/modulation/easing/EasingsNamed.ts","../src/modulation/Gaussian.ts","../src/geometry/point/index.ts","../src/geometry/point/Abs.ts","../src/geometry/point/Angle.ts","../src/geometry/point/Apply.ts","../src/numbers/AverageWeighted.ts","../src/numbers/MovingAverage.ts","../src/geometry/point/Averager.ts","../src/geometry/point/FindMinimum.ts","../src/geometry/rect/Max.ts","../src/geometry/point/Bbox.ts","../src/geometry/point/Centroid.ts","../src/geometry/point/Clamp.ts","../src/geometry/point/Compare.ts","../src/geometry/point/IsEqual.ts","../src/geometry/point/ConvexHull.ts","../src/geometry/point/GetPointParameter.ts","../src/geometry/point/Distance.ts","../src/geometry/circle/Guard.ts","../src/geometry/circle/DistanceCenter.ts","../src/geometry/circle/DistanceFromExterior.ts","../src/geometry/rect/Guard.ts","../src/geometry/circle/IsEqual.ts","../src/geometry/point/Sum.ts","../src/geometry/point/Subtract.ts","../src/geometry/circle/Intersections.ts","../src/geometry/Intersects.ts","../src/geometry/rect/Intersects.ts","../src/geometry/rect/Center.ts","../src/geometry/point/PointType.ts","../src/geometry/rect/Distance.ts","../src/geometry/point/DistanceToCenter.ts","../src/geometry/point/DistanceToExterior.ts","../src/geometry/point/Divider.ts","../src/geometry/point/ToArray.ts","../src/geometry/point/DotProduct.ts","../src/geometry/point/Empty.ts","../src/geometry/point/From.ts","../src/geometry/line/Guard.ts","../src/geometry/line/GetPointsParameter.ts","../src/geometry/line/Length.ts","../src/geometry/line/Interpolate.ts","../src/geometry/point/Interpolate.ts","../src/geometry/point/Invert.ts","../src/geometry/point/Multiply.ts","../src/geometry/point/Magnitude.ts","../src/geometry/point/Most.ts","../src/geometry/point/Normalise.ts","../src/geometry/point/NormaliseByRect.ts","../src/geometry/point/Pipeline.ts","../src/geometry/point/ProgressBetween.ts","../src/geometry/point/Project.ts","../src/numbers/Quantise.ts","../src/geometry/point/Quantise.ts","../src/geometry/point/Random.ts","../src/geometry/point/Reduce.ts","../src/geometry/point/Relation.ts","../src/geometry/Polar.ts","../src/data/index.ts","../src/data/Correlate.ts","../src/data/CloneFromFields.ts","../src/data/KeysToNumbers.ts","../src/data/MapObject.ts","../src/data/Pool.ts","../src/data/Process.ts","../src/data/BasicProcessors.ts","../src/data/ResolveFields.ts","../src/data/maps/index.ts","../src/geometry/Angles.ts","../src/geometry/point/Rotate.ts","../src/geometry/point/RotatePointArray.ts","../src/geometry/point/Round.ts","../src/geometry/point/To.ts","../src/geometry/point/WithinRange.ts","../src/geometry/point/Wrap.ts","../src/geometry/bezier/index.ts","../node_modules/bezier-js/src/utils.js","../node_modules/bezier-js/src/poly-bezier.js","../node_modules/bezier-js/src/bezier.js","../src/geometry/rect/FromTopLeft.ts","../src/geometry/bezier/Guard.ts","../src/modulation/easing/Line.ts","../src/modulation/ModulatorTimed.ts","../src/numbers/Interpolate.ts","../src/rx/ops/Interpolate.ts","../src/rx/ops/Math.ts","../src/rx/ops/Pipe.ts","../src/rx/ops/SingleFromArray.ts","../src/rx/ops/Split.ts","../src/rx/ops/Switcher.ts","../src/rx/ops/SyncToArray.ts","../src/rx/ops/SyncToObject.ts","../src/rx/ops/Tap.ts","../src/rx/ops/Throttle.ts","../src/rx/ops/TimeoutValue.ts","../src/rx/ops/TimeoutPing.ts","../src/rx/ops/ValueToPing.ts","../src/rx/ops/WithValue.ts","../src/collections/graphs/DirectedGraph.ts","../src/collections/queue/PriorityMutable.ts","../src/collections/Table.ts","../src/rx/Graph.ts","../src/rx/Types.ts","../src/rx/ToArray.ts","../src/rx/ToGenerator.ts","../src/rx/Wrap.ts","../src/rx/Count.ts","../src/rx/Dom.ts","../src/text/Segments.ts","../src/rx/sources/index.ts","../src/rx/sources/Array.ts","../src/rx/sources/ArrayObject.ts","../src/rx/sources/Boolean.ts","../src/rx/sources/Colour.ts","../src/rx/sources/Derived.ts","../src/rx/sources/Event.ts","../src/rx/sources/Dom.ts","../src/rx/sources/Merged.ts","../src/rx/sources/Number.ts","../src/rx/sources/ObjectProxy.ts","../src/rx/sources/Observable.ts","../src/rx/sources/String.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/unbound-method */\n//#region imports\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet, ReactivePingable, ReactiveStream } from \"./Types.js\";\nimport type { ChunkOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/Types.js\";\nimport type { RankFunction, RankOptions } from \"../data/Types.js\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"./sources/Types.js\";\nimport { type Interval, intervalToMs } from '../flow/IntervalType.js';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./Util.js\";\nimport { initStream } from \"./InitStream.js\";\nimport { resolveSource } from './ResolveSource.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\n\n//#endregion\n\n//#region exports\n//export * from './Chain.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './Graph.js';\nexport * from './Types.js';\nexport * from './ToArray.js';\nexport * from './ToGenerator.js';\nexport * from './Util.js';\nexport * from './Wrap.js';\nexport * from './ResolveSource.js';\nexport * from './Count.js';\nexport * as Dom from './Dom.js';\nexport * as From from './sources/index.js';\n//#endregion\n\nexport function run<TIn, TOut>(source: ReactiveOrSource<any>, ...ops: Array<ReactiveOp<any, any>>) {\n  let s = resolveSource(source);\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  return s;\n  //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\nexport function writable<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveWritable<TIn, TOut> {\n  let s = resolveSource(source);\n  const head = s;\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  let ss = s as any as Reactive<TOut>;\n  return {\n    ...ss,\n    set(value: TIn) {\n      if (isWritable(head)) {\n        head.set(value);\n      } else throw new Error(`Original source is not writable`);\n    }\n  } as ReactiveWritable<TIn, TOut>\n  //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    onValue: events.onValue\n  };\n}\n\nexport const Sinks = {\n  setHtmlText: (options: SinkFns.SetHtmlOptions) => {\n    return (source: ReactiveOrSource<string>) => {\n      SinkFns.setHtmlText(source, options);\n    }\n  }\n}\n\nexport const Ops = {\n  /**\n * Annotates values with the result of a function.\n * The input value needs to be an object.\n * \n * For every value `input` emits, run it through `annotator`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param annotator \n * @returns \n */\n  annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => opify(OpFns.annotate, annotator),\n  /**\n   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n   * \n   * ```js\n   * // Emit values from an array\n   * const r1 = Rx.run(\n   *  Rx.From.array([ 1, 2, 3 ]),\n   *  Rx.Ops.annotateWithOp(\n   *    // Add the 'max' operator to emit the largest-seen value\n   *    Rx.Ops.sum()\n   *  )\n   * );\n   * const data = await Rx.toArray(r1);\n   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n   * ```\n   * @param annotatorOp \n   * @returns \n   */\n  annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => opify(OpFns.annotateWithOp, annotatorOp),\n  /**\n   * Takes a stream of values and chunks them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  chunk: <V>(options: Partial<ChunkOptions>): ReactiveOp<V, Array<V>> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.chunk(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.debounce(source, options);\n    }\n  },\n  elapsed: <V>(): ReactiveOp<V, number> => opify(OpFns.elapsed),\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options: FieldOptions<TSource, TFieldType>) => {\n    return (source: ReactiveOrSource<TSource>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate \n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @param options \n   * @returns \n   */\n  interpolate: <TIn = number>(options?: Partial<OpFns.OpInterpolateOptions>) => opify<TIn, ReactivePingable<number>>(OpFns.interpolate as any, options),\n  /**\n * Outputs the minimum numerical value of the stream.\n * A value is only emitted when minimum decreases.\n * @returns \n */\n  min: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.min, options),\n  /**\n   * Outputs the maxium numerical value of the stream.\n   * A value is only emitted when maximum increases.\n   * @returns \n   */\n  max: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.max, options),\n  sum: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.sum, options),\n  average: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.average, options),\n  tally: <TIn>(options?: OpFns.TallyOptions) => opify<TIn, Reactive<number>>(OpFns.tally, options),\n  rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => opify<TIn>(OpFns.rank, rank, options),\n\n  pipe: <TInput, TOutput>(...streams: Array<Reactive<any> & ReactiveWritable<any>>) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<Array<V>>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: Array<string>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  tapProcess: <In>(processor: ((value: In) => any)): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapProcess(source, processor);\n    }\n  },\n  tapStream: <In>(divergedStream: ReactiveWritable<In>): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapStream(source, divergedStream);\n    }\n  },\n  tapOps: <In, Out>(...ops: Array<ReactiveOp<In, Out>>) => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapOps(source, ...ops);\n    }\n  },\n\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutValue: <V, TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutValue<V, TTriggerValue>(source, options);\n    }\n  },\n\n  timeoutPing: <V>(options: TimeoutPingOptions) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutPing(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out), options: Partial<OpFns.TransformOpts> = {}): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer, options);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n\n\n\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      const value = transform ? transform(message.value) : message.value as TB;\n      b.set(value);\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        b.dispose(`Source closed (${ message.context ?? `` })`);\n      }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      console.warn(`Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { ReactivePingable } from \"../Types.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./Types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}): ReactivePingable<V> {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n  let manual = options.manual ?? false;\n\n  // If niether interval or manual is set, assume manual\n  if (options.interval === undefined && options.manual === undefined) manual = true;\n\n  if (manual && options.interval) throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n  const predelay = intervalToMs(options.predelay, 0);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  let enabled = false;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    enabled = false;\n    if (run) run.cancel();\n  }\n\n  const ping = async () => {\n    if (!enabled) return false;\n    if (predelay) await sleep(predelay);\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false;\n    }\n    //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      sentResults++;\n      events.set(value);\n      return true;\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n        return true;\n      }\n    }\n  }\n\n  const run = manual ? undefined : continuously(async () => {\n    const pingResult = await ping();\n    if (!pingResult) return false;\n\n    // if (!loop) {\n    //   done(`fromFunction done`);\n    //   return false; // Stop loop\n    // }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n\n  }, intervalMs);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      enabled = true;\n      if (run) run.start();\n    },\n    onStop() {\n\n      enabled = false;\n      if (run) run.cancel();\n    },\n  });\n\n  if (lazy === `never` && run) run.start();\n  return { ...events, ping };\n}\n\n","import { intervalToMs, type Interval } from '../flow/IntervalType.js';\nimport { type IsEqual } from '../util/IsEqual.js';\nimport { sleep, type SleepOpts } from '../flow/Sleep.js';\nimport { isAsyncIterable, isIterable } from './Iterable.js';\nimport { toStringDefault } from '../util/ToString.js';\nimport type { ForEachOptions, ToArrayOptions } from './Types.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: Array<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator \n * @param repeatsOrSignal \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function <T>(\n  iterator: AsyncIterable<T> | Array<T>,\n  fn: (v?: T) => Promise<boolean> | Promise<void> | boolean | void,\n  options: Partial<ForEachOptions> = {}\n) {\n  const interval = options.interval;\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  }\n};\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Calls `callback` whenever the async generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport async function asCallback<V>(input: AsyncIterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for await (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it \n * @param delay \n */\nexport async function* withDelay<V>(it: Iterable<V>, delay: Interval) {\n  for (const v of it) {\n    await sleep(delay);\n    yield v;\n  }\n}\n\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout<V>(it: AsyncIterableIterator<V> | IterableIterator<V>, options: SleepOpts<any>) {\n  const ms = intervalToMs(options, 1000);\n\n  const value: IteratorResult<V> | undefined = await Promise.race([\n    (async () => {\n      await sleep({ millis: ms, signal: options.signal });\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      return undefined;\n    })(),\n    (async () => {\n      return await it.next();\n    })()\n  ]);\n  if (value === undefined) throw new Error(`Timeout`);\n  return value;\n}\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n * \n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Promise<Array<V>> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const whileFunc = options.while;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n\n  while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n    if (whileFunc) {\n      if (!whileFunc(result.length)) break;\n    }\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | Array<AsyncIterable<V>>\n) {\n  const buffer: Array<any> = [];\n  const itera: Array<AsyncIterable<V>> = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: (value: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { nextWithTimeout } from \"../../iterables/IterableAsync.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { isAsyncIterable } from \"../../iterables/Iterable.js\";\nimport type { Reactive } from \"../Types.js\";\nimport type { GeneratorOptions } from \"./Types.js\";\nimport { StateMachine } from \"../../flow/index.js\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | Array<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.iterator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n    // eslint-disable-next-line unicorn/no-null\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      // @ts-expect-error\n      const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc?.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.From.iterator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isAsyncIterable, isIterable } from \"../iterables/Iterable.js\";\nimport { func } from \"./sources/Function.js\";\nimport { iterator } from \"./sources/Iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./sources/Types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./Types.js\";\nimport { isReactive, isWrapped } from \"./Util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import type { Reactive, ReactiveInitial, ReactiveNonInitial, ReactiveWritable } from \"./Types.js\";\n\nexport type CacheStream<T> = {\n  resetCachedValue: () => void\n  last: () => T | undefined\n}\n\nexport type CacheStreamInitial<T> = CacheStream<T> & {\n  last: () => T\n}\n\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue): CacheStreamInitial<TValue> & RT;\n\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue | undefined): CacheStream<TValue> & RT {\n  let lastValue: TValue | undefined = initialValue;\n  r.onValue(value => {\n    lastValue = value;\n  });\n  return {\n    ...r,\n    last() {\n      return lastValue\n    },\n    resetCachedValue() {\n      lastValue = undefined;\n    }\n  }\n}","import { type Dispatch, DispatchList } from \"../flow/DispatchList.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveInitialStream, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./Types.js\";\nimport { messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { cache } from \"./Cache.js\";\n\n\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n * \n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport function initUpstream<In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out> {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  //console.log(`initUpstream${ debugLabel } creating`);\n\n  const onStop = () => {\n    //console.log(`Rx.initStream${ debugLabel } stop`);\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const onStart = () => {\n    //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n    if (unsub !== undefined) return;\n    if (options.onStart) options.onStart();\n\n    unsub = source.on(value => {\n      //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          onStop();\n          events.signal(value.signal, value.context);\n          if (disposeIfSourceDone) events.dispose(`Upstream source ${ debugLabel } has completed (${ value.context ?? `` })`);\n        } else {\n          //events.through_(value);\n          events.signal(value.signal, value.context);\n        }\n      } else if (messageHasValue(value)) {\n        //lastValue = value.value;\n        onValue(value.value);\n      }\n    });\n  }\n\n\n\n  //const initOpts = \n  // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n  //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n  //   initLazyStream<Out>(initOpts);\n  //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart,\n    onStop\n  });\n  return events;\n}\n\n\nexport function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveInitialStream<V> {\n  const r = initLazyStream<V>(options);\n  const c = cache<V, typeof r>(r, options.initialValue);\n  return c;\n}\n\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) {\n        //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n        onStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) {\n        //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n        onStop();\n      }\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n\n/**\n * Initialises a new stream.\n * \n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe ${ debugLabel }`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n      if (onFirstSubscribe) onFirstSubscribe();\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    removeAllSubscribers: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    // through: (pass: Passed<V>) => {\n    //   if (disposed) throw new Error(`Disposed, cannot through`);\n    //   dispatcher?.notify(pass)\n    // },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    onValue: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","import { resolveEls, type QueryOrElements } from \"./ResolveEl.js\";\n\nexport function setText(selectors: QueryOrElements): (value: any) => string;\nexport function setText(selectors: QueryOrElements, value?: any): string;\nexport function setText(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`textContent`, selectors, value)\n};\n\nexport function setHtml(selectors: QueryOrElements): (value: any) => string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`innerHTML`, selectors, value)\n};\n\nexport function setProperty(property: string, selectors: QueryOrElements): (value: any) => string;\nexport function setProperty(property: string, selectors: QueryOrElements, value: any): string;\n\nexport function setProperty(property: string, selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  let elements: Array<HTMLElement> = [];\n  const set = (v: any) => {\n    const typ = typeof v;\n    const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v as string :\n      JSON.stringify(v);\n\n    if (elements.length === 0) {\n      elements = resolveEls(selectors);\n    }\n    for (const element of elements) {\n      (element as any)[ property ] = vv;\n    }\n    return vv;\n  }\n  return value === undefined ? set : set(value);\n};","import { setProperty } from \"../../dom/SetProperty.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\n\nexport type SetHtmlOptionsQuery = {\n  query: string\n}\n\nexport type SetHtmlOptionsElement = {\n  el: HTMLElement\n}\n\nexport type SetHtmlOptions = (SetHtmlOptionsQuery | SetHtmlOptionsElement) & {\n  /**\n   * If _true_ .innerHTML is used\n   * If _false_ (default) .textContent is used\n   */\n  asHtml?: boolean;\n};\n\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource \n * @param optionsOrElementOrQuery \n */\nexport const setHtmlText = (rxOrSource: ReactiveOrSource<any>, optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement) => {\n  let el: HTMLElement | null | undefined;\n  let options: SetHtmlOptions | undefined;\n  if (typeof optionsOrElementOrQuery === `string`) {\n    options = { query: optionsOrElementOrQuery };\n  }\n  if (typeof optionsOrElementOrQuery === `object`) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (`nodeName` in optionsOrElementOrQuery) {\n      options = { el: optionsOrElementOrQuery };\n    } else {\n      options = optionsOrElementOrQuery;\n    }\n  }\n  if (options === undefined) throw new TypeError(`Missing element as second parameter or option`);\n  if (`el` in options) {\n    el = options.el;\n  } else if (`query` in options) {\n    el = document.querySelector<HTMLElement>(options.query);\n  } else {\n    throw new TypeError(`Options does not include 'el' or 'query' fields`);\n  }\n  if (el === null || el === undefined) throw new Error(`Element could not be resolved.`);\n\n  const stream = resolveSource(rxOrSource);\n  const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n  const off = stream.onValue(value => {\n    setter(value)\n  });\n  return off;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveStream } from \"./Types.js\";\n\n/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = <V>(stream: ReactiveStream<V>): Reactive<V> => ({\n  on: stream.on,\n  dispose: stream.dispose,\n  isDisposed: stream.isDisposed,\n  onValue: stream.onValue\n});\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveOp } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n * \n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n * \n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, annotator: (value: In) => TAnnotation, options: Partial<TransformOpts> = {}): Reactive<{ value: In, annotation: TAnnotation }> {\n  const upstream = initUpstream<In, { value: In, annotation: TAnnotation }>(input, {\n    ...options,\n    onValue(value) {\n      const annotation = annotator(value);\n      upstream.set({ value, annotation });\n    },\n  })\n  return toReadable(upstream);\n}\n\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n * \n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns \n */\nexport function annotateWithOp<In, TAnnotation>(input: ReactiveOrSource<In>, annotatorOp: ReactiveOp<In, TAnnotation>): Reactive<{ value: In, annotation: TAnnotation }> {\n\n  const inputStream = resolveSource(input);\n\n  // Create annotations from input\n  const stream = annotatorOp(inputStream);\n\n  const synced = syncToObject({\n    value: inputStream,\n    annotation: stream\n  })\n  return synced as Reactive<{ value: In, annotation: TAnnotation }>;\n}\n\n","import { QueueMutable } from \"../../collections/queue/QueueMutable.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ChunkOptions } from \"./Types.js\";\n\n/**\n * Queue from `source`, emitting when thresholds are reached. \n * The resulting Reactive produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport function chunk<V>(source: ReactiveOrSource<V>, options: Partial<ChunkOptions> = {}): Reactive<Array<V>> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      if (timer !== undefined && timer.runState === `idle`) {\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(source, upstreamOpts);\n\n  //let testElapsed = performance.now();\n  const send = () => {\n    //console.log(`Elapsed: ${ performance.now() - testElapsed }`);\n    //testElapsed = performance.now();\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    setTimeout(() => upstream.set(data));\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const traceInput = options.traceInput ?? false;\n  const traceOutput = options.traceOutput ?? false;\n\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      if (traceInput && traceOutput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) } output: ${ JSON.stringify(t) }`);\n      } else if (traceInput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) }`);\n      } else if (traceOutput) {\n        console.log(`Rx.Ops.transform output: ${ JSON.stringify(t) }`);\n      }\n\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n","\nimport { isPlainObjectOrPrimitive } from \"../../util/GuardObject.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source \n * @returns \n */\nexport const cloneFromFields = <In>(source: ReactiveOrSource<In>) => {\n  return transform<In, In>(source, (v): In => {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in v) {\n      const value = (v)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return Object.fromEntries(entries) as In;\n  })\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../Util.js\";\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n * \n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]  \n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): Reactive<RxValueTypes<T>> {\n  const event = initStream<RxValueTypes<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  const sources = reactiveSources.map(source => resolveSource(source));\n  const noop = () => {/** no-op */ };\n  const sourceOff = sources.map(_ => noop);\n  const doneSources = sources.map(_ => false);\n\n  const unsub = () => {\n    for (const v of sourceOff) { v() }\n  }\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    sourceOff[ index ] = v.on(message => {\n      if (messageIsDoneSignal(message)) {\n        doneSources[ index ] = true;\n        sourceOff[ index ]();\n        sourceOff[ index ] = noop;\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is set`);\n          return;\n        }\n        if (!doneSources.includes(false)) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        data[ index ] = message.value;\n        event.set([ ...data ] as RxValueTypes<T>);\n      }\n    });\n  }\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n}\n","import * as TraversableObject from '../collections/tree/TraverseObject.js';\nimport { isPrimitive } from '../IsPrimitive.js';\nimport { isPlainObjectOrPrimitive } from '../util/GuardObject.js';\nimport { isInteger } from '../util/IsInteger.js';\nimport { isEqualContextString, type IsEqualContext } from './Util.js';\nimport { compareKeys } from './Compare.js';\nimport type { Result } from '../util/Results.js';\n\nexport type PathData<V> = {\n  path: string\n  value: V\n}\n\nexport type PathDataChange<V> = PathData<V> & {\n  previous?: V\n  state: `change` | `added` | `removed`\n}\n\nexport type CompareDataOptions<V> = {\n  /**\n   * If _true_, it treats the B value as a partial\n   * version of B. Only the things present in B are compared.\n   * Omissions from B are not treated as removed keys.\n   */\n  asPartial: boolean\n  /**\n   * If _true_ (default), if a value is undefined,\n   * it signals that the key itself is removed.\n   */\n  undefinedValueMeansRemoved: boolean\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n}\n\nconst getEntries = <V extends Record<string, any>>(target: V, deepProbe: boolean) => {\n  if (target === undefined) throw new Error(`Param 'target' is undefined`);\n  if (target === null) throw new Error(`Param 'target' is null`);\n  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${ typeof target })`);\n  if (deepProbe) {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  if (a === undefined) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (b === undefined) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const asPartial = options.asPartial ?? false;\n  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n\n  //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  if (isPrimitive(b)) {\n    yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n\n    const keyOfAInB = key in b;\n    const valueOfKeyInB = b[ key ];\n    //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n\n    if (typeof valueA === `object` && valueA !== null) {\n      if (keyOfAInB) {\n        //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n        if (valueOfKeyInB === undefined) {\n          throw new Error(`Pathed.compareData Value for key ${ key } is undefined`);\n        } else {\n          const sub = [ ...compareData(valueA, valueOfKeyInB, {\n            ...options,\n            pathPrefix: pathPrefix + key + `.`\n          }) ];\n          if (sub.length > 0) {\n            for (const s of sub) yield s;\n            if (includeParents) {\n              yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n            }\n          }\n        }\n      } else {\n        if (asPartial) continue;\n        //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n        yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (keyOfAInB) {\n        // B contains key from A\n        if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n          //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n          yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n        } else {\n          if (!eq(valueA, valueOfKeyInB, subPath)) {\n            //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n          }\n        }\n      } else {\n        // B does not contain key from A\n        if (asPartial) continue; // Ignore\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: Array<PathDataChange<any>>): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: Array<string>, value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): Result<V> => {\n  if (typeof path !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Param string 'path' is empty`);\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (object === null) throw new Error(`Param 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: Array<string>): Result<V> => {\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path has run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n    if (typeof object[ index ] === `undefined`) {\n      return { success: false, error: `Index '${ index }' does not exist. Length: ${ object.length }` };\n    }\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return { value: object[ index ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (typeof object === `object` && start in object) {\n    //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return { value: object[ start ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    return { success: false, error: `Path '${ start }' not found` };\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = TraversableObject.depthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, onlyLeaves = false, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    const value = entries[ 1 ];\n    const leaf = (typeof value !== `object`);\n\n    if (onlyLeaves && leaf || !onlyLeaves) {\n      yield { path: sub, value };\n    }\n    yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n  }\n}","//import { stringify } from 'json5';\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<any> = (a: any, b: any, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { DispatchList } from \"../../flow/DispatchList.js\";\nimport * as Pathed from \"../../data/Pathed.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ObjectFieldHandler, ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\nimport type { ObjectOptions } from \"./Types.js\";\nimport { isEqualContextString } from \"../../data/Util.js\";\nimport { throwResult } from \"../../util/Results.js\";\nimport { wildcard } from \"../../Text.js\";\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * \n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Array<Pathed.PathDataChange<any>>>();\n\n  //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n  const fieldChangeEvents: Array<[ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ]> = [];\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    const diff = [ ...Pathed.compareData(value ?? {} as V, v, { ...options, includeMissingFromA: true }) ];\n    if (diff.length === 0) return;\n    value = v;\n    setEvent.set(v);\n    diffEvent.set(diff);\n  }\n\n  const fireFieldUpdate = (field: string, value: any) => {\n    for (const [ matcher, pattern, list ] of fieldChangeEvents) {\n      if (matcher(field)) {\n        list.notify({ fieldName: field, pattern, value });\n      }\n    }\n    //const l = fieldChangeEvents.get(field.toLowerCase());\n    //if (l === undefined) return;\n    //l.notify(value);\n  }\n\n  const updateCompareOptions: Partial<Pathed.CompareDataOptions<V>> = {\n    asPartial: true,\n    includeParents: true\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (value === undefined) {\n      value = toMerge as V;\n      setEvent.set(value);\n      for (const [ k, v ] of Object.entries(toMerge as V)) {\n        fireFieldUpdate(k, v);\n      }\n      return value;\n    } else {\n      const diff = [ ...Pathed.compareData(value, toMerge, updateCompareOptions) ];\n      //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n      if (diff.length === 0) return value; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      setEvent.set(value);\n      diffEvent.set(diff);\n      //console.log(`diff`, diff);\n      for (const d of diff) {\n        fireFieldUpdate(d.path, d.value);\n      }\n      return value;\n    }\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Pathed.getField<any>(value, path);\n    throwResult(existing); // Eg if path not found\n\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing.value, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = [ ...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true }) ];\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Pathed.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    setEvent.set(o);\n    diffEvent.set(diff);\n    fireFieldUpdate(path, valueForField);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onValue: setEvent.onValue,\n    onDiff: diffEvent.onValue,\n    onField(fieldPattern: string, handler: (result: ObjectFieldHandler) => void) {\n      const matcher = wildcard(fieldPattern);\n      const listeners = new DispatchList<ObjectFieldHandler>();\n      fieldChangeEvents.push([ matcher, fieldPattern, listeners ]);\n      const id = listeners.add(handler);\n      return () => listeners.remove(id);\n      // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n      // if (listeners === undefined) {\n      //   listeners = new DispatchList();\n      //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n      // }\n      // const id = listeners.add((value) => {\n      //   setTimeout(() => { handler(value, fieldName) }, 1);\n      // });\n      // return () => listeners.remove(id);\n    },\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport * as MapFns from \"../../data/maps/MapFns.js\"\nimport { initStream } from \"../InitStream.js\"\nimport { resolveSource } from \"../ResolveSource.js\"\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypeObject, ReactiveInitial, RxValueTypeRx, ReactiveDiff } from \"../Types.js\"\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../Util.js\"\nimport { object } from \"../sources/Object.js\"\n\nexport type CombineLatestToObject<T extends Record<string, ReactiveOrSource<any>>> = {\n  hasSource: (field: string) => boolean,\n  replaceSource: (field: Extract<keyof T, string>, source: ReactiveOrSource<any>) => void\n  /**\n   * Reactive sources being combined\n   */\n  sources: RxValueTypeRx<T>\n  /**\n   * Updates writable sources with values.\n   * @param data \n   * @returns Keys and values set to writable source(s)\n   */\n  setWith: (data: Partial<RxValueTypeObject<T>>) => Partial<RxValueTypeObject<T>>\n} & ReactiveDiff<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>>;\n\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n * \n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n * \n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): CombineLatestToObject<T> {// { sources: RxValueTypeRx<T> } & Reactive<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>> {\n  type State<V> = {\n    source: Reactive<V>\n    done: boolean\n    data: V | undefined\n    off: () => void\n  }\n  const disposeSources = options.disposeSources ?? true;\n  const event = object<RxValueTypeObject<T>>(undefined);\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const emitInitial = options.emitInitial ?? true;\n  let emitInitialDone = false;\n\n  const states = new Map<string, State<any>>();\n  for (const [ key, source ] of Object.entries(reactiveSources)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const initialData = (`last` in source) ? (source as any).last() : undefined;\n    //console.log(`initialData: ${ initialData } src: ${ (source as any).last() }`);\n    const s: State<any> = {\n      source: resolveSource(source),\n      done: false,\n      data: initialData,\n      off: () => { /** no-op */ }\n    }\n    states.set(key, s);\n  }\n  const sources = Object.fromEntries(Object.entries(states).map(entry => [ entry[ 0 ], entry[ 1 ].source ])) as RxValueTypeRx<T>;\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const someUnfinished = () => MapFns.some(states, v => !v.done);\n\n  const unsub = () => {\n    //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n    for (const state of states.values()) state.off();\n  }\n\n  const getData = () => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      const d = state.data;\n      if (d !== undefined) {\n        (r as any)[ key ] = state.data;\n      }\n    }\n    //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n\n    return r as RxValueTypeObject<T>;\n  }\n\n  const trigger = () => {\n    emitInitialDone = true;\n    const d = getData();\n    //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n    event.set(d);\n  }\n\n  const wireUpState = (state: State<any>) => {\n    state.off = state.source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        state.done = true;\n        state.off();\n        state.off = () => {/**no-op */ }\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is behaviour`);\n          return;\n        }\n        if (!someUnfinished()) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        state.data = message.value;\n        trigger();\n      }\n    });\n  }\n\n  for (const state of states.values()) {\n    wireUpState(state);\n  }\n\n  if (!emitInitialDone && emitInitial) {\n    //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n    trigger();\n  }\n  return {\n    ...event,\n    hasSource(field: string) {\n      return states.has(field)\n    },\n    replaceSource(field, source) {\n      const state = states.get(field);\n      if (state === undefined) throw new Error(`Field does not exist: '${ field }'`);\n      state.off();\n      const s = resolveSource(source);\n      state.source = s;\n      wireUpState(state);\n    },\n    setWith(data) {\n      let written = {};\n      for (const [ key, value ] of Object.entries(data)) {\n        const state = states.get(key);\n        if (state !== undefined) {\n          if (isWritable(state.source)) {\n            state.source.set(value);\n            (written as any)[ key ] = value;\n          }\n          state.data = value;\n        }\n      }\n      return written;\n    },\n    sources,\n    last() {\n      return getData()\n    },\n    dispose(reason: string) {\n      unsub();\n      event.dispose(reason);\n      if (disposeSources) {\n        for (const v of states.values()) {\n          v.source.dispose(`Part of disposed mergeToObject`)\n        }\n      }\n    }\n  }\n}","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../Types.js\";\nimport { hasLast } from \"../Util.js\";\n\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n * \n * `fn` is provided the previous value as well as the most recent value.\n * \n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input \n * @param fn \n * @returns \n */\nexport function computeWithPrevious<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, current: TIn) => TIn): ReactivePingable<TIn> {\n  let previousValue: TIn | undefined;\n  let currentValue: TIn | undefined;\n  if (hasLast(input)) {\n    currentValue = previousValue = input.last();\n  }\n\n  const trigger = () => {\n    if (previousValue === undefined && currentValue !== undefined) {\n      previousValue = currentValue;\n      upstream.set(previousValue);\n    } else if (previousValue !== undefined && currentValue !== undefined) {\n      const vv = fn(previousValue, currentValue);\n      //console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n      previousValue = vv;\n      upstream.set(vv);\n    }\n  }\n\n  const upstream = initUpstream<TIn, TIn>(input, {\n    lazy: \"very\",\n    debugLabel: `computeWithPrevious`,\n    onValue(value) {\n      //console.log(`onValue ${ value }`);\n      currentValue = value;\n      trigger();\n    },\n  })\n  if (currentValue) trigger();\n\n  return {\n    ...toReadable(upstream),\n    ping: () => {\n      if (currentValue !== undefined) trigger()\n    }\n  }\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { DebounceOptions } from \"./Types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n\n","import type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input \n * @returns \n */\nexport const elapsed = <In>(input: ReactiveOrSource<In>) => {\n  let last = 0;\n  return transform<In, number>(input, (_ignored) => {\n    const elapsed = last === 0 ? 0 : Date.now() - last;\n    last = Date.now();\n    return elapsed;\n  });\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FieldOptions } from \"./Types.js\";\n\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n * \n * If a source value doesn't have that field, it is skipped.\n *\n * @returns \n */\nexport function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options: Partial<FieldOptions<TIn, TFieldType>> = {}): Reactive<TFieldType> {\n  const fallbackFieldValue = options.fallbackFieldValue;\n  const fallbackObject = options.fallbackObject;\n\n  const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      let v: TFieldType | undefined;\n      // 1. Try to read from value\n      if (fieldName in value) {\n        v = value[ fieldName ] as TFieldType;\n      } else if (fallbackObject && fieldName in fallbackObject) {\n        // 2. Read from fallback object\n        v = fallbackObject[ fieldName ] as TFieldType;\n      }\n      // 3. Use fallback value\n      if (v === undefined) {\n        v = fallbackFieldValue;\n      }\n      if (v !== undefined) {\n        upstream.set(v);\n      }\n    },\n  })\n  return toReadable(upstream);\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FilterPredicate } from \"./Types.js\";\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (!predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { throwNumberTest, throwIntegerTest } from '../util/GuardNumbers.js';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min = 0, max = 360) => {\n  throwIntegerTest(v, undefined, `v`);\n  throwIntegerTest(min, undefined, `min`);\n  throwIntegerTest(max, undefined, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min = 0, max = 1) => {\n  throwNumberTest(v, ``, `min`);\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","import * as Named from './EasingsNamed.js';\nimport { throwStringTest } from '../../util/GuardString.js';\nimport { type Interval } from '../../flow/IntervalType.js';\nimport type { Modulate, ModulatorTimed } from '../Types.js';\nexport * as Named from './EasingsNamed.js';\nexport * from './Line.js';\n\nimport * as ModTimed from '../ModulatorTimed.js';\n\n/**\n * Easing name\n */\nexport type EasingName = keyof typeof Named;\n\nexport type Options = (TickOptions | TimeOptions) & {\n  name?: EasingName\n  fn?: Modulate\n}\n\nexport type TimeOptions = {\n  duration: Interval\n}\nexport type TickOptions = {\n  ticks: number\n}\n\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({ \n *  duration: 1000, \n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options \n * @returns \n */\nexport const create = (options: Options): () => number => {\n  let name = resolveEasingName(options.name ?? `quintIn`);\n  const fn = name ?? options.fn;\n  if (!fn) throw new Error(`Either 'name' or 'fn' must be set`);\n\n  if (`duration` in options) {\n    return time(fn, options.duration);\n  } else if (`ticks` in options) {\n    return ticks(fn, options.ticks);\n  } else {\n    throw new Error(`Expected 'duration' or 'ticks' in options`);\n  }\n}\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * \n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * \n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * \n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.timeModulator(fn, duration);\n  // const timer = Timer.elapsedMillisecondsAbsolute();\n  // const durationMs = intervalToMs(duration);\n  // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  // const relativeTimer = Timer.relative(\n  //   durationMs,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.time(fn, duration);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n\n\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  totalTicks: number\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.ticks(fn, totalTicks);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n/**\n * Creates an easing based on ticks. \n * \n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  durationTicks: number\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.tickModulator(fn, durationTicks);\n  // const timer = Timer.elapsedTicksAbsolute();\n  // const relativeTimer = Timer.relative(\n  //   durationTicks,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\nconst resolveEasingName = (nameOrFunction: EasingName | ((v: number) => number)): Modulate => {\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (fn === undefined) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n    throw error;\n  }\n  return fn;\n}\n\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\n\n\nlet easingsMap: Map<string, ((v: number) => number)> | undefined;\n\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): Modulate {\n  throwStringTest(easingName, `non-empty`, `easingName`);\n\n  const found = cacheEasings().get(easingName.toLowerCase());\n  if (found === undefined) throw new Error(`Easing not found: '${ easingName }'`);\n  return found;\n};\n\n// Cache named easings\nfunction cacheEasings() {\n  if (easingsMap === undefined) {\n    easingsMap = new Map();\n    for (const [ k, v ] of Object.entries(Named)) {\n      easingsMap.set(k.toLowerCase(), v);\n    }\n    return easingsMap\n  } else return easingsMap;\n}\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames(): Iterable<string> {\n  const map = cacheEasings();\n  yield* map.keys();\n};\n\n","import { gaussian } from \"../Gaussian.js\";\n// Easings from https://easings.net/\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\nexport const bounceOut = (x: number) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nexport const quintIn = (x: number) => x * x * x * x * x;\nexport const quintOut = (x: number) => 1 - pow(1 - x, 5);\nexport const arch = (x: number) => x * (1 - x) * 4;\n\nexport const smoothstep = (x: number) => x * x * (3 - 2 * x);\nexport const smootherstep = (x: number) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x: number) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x: number) => sin((x * pi) / 2);\nexport const quadIn = (x: number) => x * x;\nexport const quadOut = (x: number) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x: number) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x: number) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x: number) => x * x * x;\nexport const cubicOut = (x: number) => 1 - pow(1 - x, 3);\nexport const quartIn = (x: number) => x * x * x * x;\nexport const quartOut = (x: number) => 1 - pow(1 - x, 4);\nexport const expoIn = (x: number) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x: number) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x: number) =>\n  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x: number) =>\n  x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? pow(2, 20 * x - 10) / 2\n        : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x: number) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x: number) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x: number) =>\n  x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n\nexport const backInOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c2 = c1 * 1.525;\n\n  return x < 0.5\n    ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n    : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\n\nexport const bounceIn = (x: number) => 1 - bounceOut(1 - x);\n\nexport const bell = gaussian();\n\nexport const elasticInOut = (x: number) => {\n  const c5 = (2 * pi) / 4.5;\n\n  return x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x: number) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n  //const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = gaussianA / standardDeviation;\n    // p:-8 pinched\n    let p = -2.5; // -1/1.25;\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n    return v;\n  };\n};","export * from './Abs.js';\nexport * from './Angle.js';\nexport * from './Apply.js';\nexport * from './Averager.js';\nexport * from './Bbox.js';\nexport * from './Centroid.js';\nexport * from './Clamp.js';\nexport * from './Compare.js';\nexport * from './ConvexHull.js';\nexport * from './Distance.js';\nexport * from './DistanceToCenter.js';\nexport * from './DistanceToExterior.js';\nexport * from './Divider.js';\nexport * from './DotProduct.js';\nexport * from './Empty.js';\nexport * from './FindMinimum.js';\nexport * from './From.js';\nexport * from './GetPointParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './Invert.js';\nexport * from './IsEqual.js';\nexport * from './Magnitude.js';\nexport * from './Most.js';\nexport * from './Multiply.js';\nexport * from './Normalise.js';\nexport * from './NormaliseByRect.js';\nexport * from './Pipeline.js';\nexport * from './PointRelationTypes.js';\nexport * from './PointType.js';\nexport * from './ProgressBetween.js';\nexport * from './Project.js';\nexport * from './Quantise.js';\nexport * from './Random.js';\nexport * from './Reduce.js';\nexport * from './Relation.js';\nexport * from './Rotate.js';\nexport * from './RotatePointArray.js';\nexport * from './Round.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './To.js';\nexport * from './ToArray.js';\nexport * from './WithinRange.js';\nexport * from './Wrap.js';\nexport type { Point, Point3d } from './PointType.js';\n","import { isPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function abs(pt: Point3d): Point3d;\nexport function abs(pt: Point): Point;\n\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt: Point): Point {\n  if (isPoint3d(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y),\n      z: Math.abs(pt.z)\n    });\n  } else if (isPoint(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y)\n    });\n  } else throw new TypeError(`Param 'pt' is not a point`);\n};","import { piPi } from \"../../numbers/Interpolate.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","import { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n// type PointFields = `x` | `y`;\n// type Point3dFields = PointFields & 'z';\n\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\n\nexport function apply(pt: Point3d, fn: Point3dApplyFn): Point3d\nexport function apply(pt: Point, fn: PointApplyFn): Point;\n\n/**\n * Applies `fn` on x,y & z (if present) fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport function apply(\n  pt: Point,\n  fn: Point3dApplyFn | PointApplyFn\n): Point {\n  guard(pt, `pt`);\n  if (isPoint3d(pt)) {\n    return Object.freeze<Point3d>({\n      ...pt,\n      x: fn(pt.x, `x`),\n      y: fn(pt.y, `y`),\n      z: (fn as Point3dApplyFn)(pt.z, `z`)\n    });\n  }\n  return Object.freeze<Point>({\n    ...pt,\n    x: fn(pt.x, `x`),\n    y: fn(pt.y, `y`),\n  });\n}","import { zip } from '../data/arrays/Zip.js';\nimport { weight } from './NumericArrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * import { averageWeighted } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * import { weight,averageWeighted } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * averageWeighted[1,2,3], gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * import { weight,averageWeighted } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * const data = [1,2,3];\n * const w = weight(data, gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (\n  data: Array<number> | ReadonlyArray<number>,\n  weightings: Array<number> | ReadonlyArray<number> | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n  const ww = zip(data, weightings);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const [ totalV, totalW ] = ww.reduce(\n    (accumulator: Array<number>, v: Array<number>) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","import type { Interval } from '../flow/IntervalType.js';\nimport { averageWeighted } from '../numbers/AverageWeighted.js';\nimport { average } from '../numbers/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { throwNumberTest, numberTest } from \"../util/GuardNumbers.js\";\nimport { rateMinimum } from '../flow/RateMinimum.js';\nconst PiPi = Math.PI * 2;\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r[ 0 ] && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n};\n\nexport type MovingAverageTimedOptions = Readonly<{\n  interval: Interval\n  default?: number\n  abort?: AbortSignal\n}>\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n * \n * mat(); // Get current average\n * ```\n * \n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * \n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options: MovingAverageTimedOptions) => {\n  const average = movingAverageLight();\n  const rm = rateMinimum({\n    ...options,\n    whatToCall: (distance: number) => {\n      average(distance);\n    },\n    fallback() {\n      return options.default ?? 0;\n    }\n  })\n\n  return (v: number) => {\n    rm(v);\n    return average();\n  }\n};\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n * \n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * \n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  const q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  return (v?: number | undefined) => {\n    const r = numberTest(v);\n    if (r[ 0 ] && v !== undefined) {\n      q.enqueue(v);\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n};\n\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { movingAverageLight as mal } from \"../../numbers/MovingAverage.js\"\nimport { isPoint3d } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n\n\n/**\n * Uses {@link Numbers.movingAverageLight} to keep track of \n * average x, y and z values.\n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n * \n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns \n */\nexport function averager(kind: `moving-average-light`, opts: Partial<{ scaling: number }>): PointAverager;\n\nexport function averager(kind: PointAverageKinds, opts: any): PointAverager {\n  let x: (v: number) => number;\n  let y: (v: number) => number;\n  let z: (v: number) => number;\n  switch (kind) {\n    case `moving-average-light`:\n      const scaling = opts.scaling ?? 3;\n      x = mal(scaling);\n      y = mal(scaling);\n      z = mal(scaling);\n      break;\n    default:\n      throw new Error(`Unknown averaging kind '${ kind }'. Expected: 'moving-average-light'`);\n  }\n\n  return (point: Point) => {\n    let ax = x(point.x);\n    let ay = y(point.y);\n    if (isPoint3d(point)) {\n      let az = z(point.z);\n      return Object.freeze({\n        x: ax,\n        y: ay,\n        z: az\n      })\n    } else {\n      return Object.freeze({\n        x: ax,\n        y: ay\n      })\n    }\n  }\n}","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport const findMinimum = (\n  comparer: (a: Point, b: Point) => Point,\n  ...points: ReadonlyArray<Point>\n): Point => {\n  if (points.length === 0) throw new Error(`No points provided`);\n  let min = points[ 0 ];\n  for (const p of points) {\n    min = comparer(min, p);\n  }\n  return min;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Geometry.Points.bbox | Geometry.Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (\n  topLeft: Point,\n  topRight: Point,\n  bottomRight: Point,\n  bottomLeft: Point\n): RectPositioned => {\n  if (topLeft.y > bottomRight.y) {\n    throw new Error(`topLeft.y greater than bottomRight.y`);\n  }\n  if (topLeft.y > bottomLeft.y) {\n    throw new Error(`topLeft.y greater than bottomLeft.y`);\n  }\n\n  const w1 = topRight.x - topLeft.x;\n  const w2 = bottomRight.x - bottomLeft.x;\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\n  const h2 = Math.abs(bottomRight.y - topRight.y);\n  return {\n    x: Math.min(topLeft.x, bottomLeft.x),\n    y: Math.min(topRight.y, topLeft.y),\n    width: Math.max(w1, w2),\n    height: Math.max(h1, h2),\n  };\n};\n","import type { RectPositioned } from \"../rect/RectTypes.js\";\nimport { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/Max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points: ReadonlyArray<Point>): RectPositioned => {\n  const leftMost = findMinimum((a, b) => {\n    return a.x < b.x ? a : b;\n  }, ...points);\n  const rightMost = findMinimum((a, b) => {\n    return a.x > b.x ? a : b;\n  }, ...points);\n  const topMost = findMinimum((a, b) => {\n    return a.y < b.y ? a : b;\n  }, ...points);\n  const bottomMost = findMinimum((a, b) => {\n    return a.y > b.y ? a : b;\n  }, ...points);\n\n  const topLeft = { x: leftMost.x, y: topMost.y };\n  const topRight = { x: rightMost.x, y: topMost.y };\n  const bottomRight = { x: rightMost.x, y: bottomMost.y };\n  const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n  return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\n","import { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: ReadonlyArray<Point | undefined>): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import { clamp as clampNumber } from '../../numbers/Clamp.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function clamp(a: Point, min?: number, max?: number): Point;\nexport function clamp(a: Point3d, min?: number, max?: number): Point3d;\n\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(\n  a: Point,\n  min: number = 0,\n  max: number = 1\n): Point {\n\n  if (isPoint3d(a)) {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n      z: clampNumber(a.z, min, max)\n    });\n  } else {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n    });\n  }\n}\n","import type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}\n\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a: Point3d, b: Point3d): number => {\n  if (a.z === b.z) return 0;\n  if (a.z < b.z) return -1;\n  return 1;\n}","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import { compareByX } from \"./Compare.js\";\nimport { isEqual } from \"./IsEqual.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts: ReadonlyArray<Point>): ReadonlyArray<Point> => {\n  const sorted = [ ...pts ].sort(compareByX);\n  if (sorted.length === 1) return sorted;\n\n  const x = (points: Array<Point>) => {\n    const v: Array<Point> = [];\n    for (const p of points) {\n      while (v.length >= 2) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const q = v.at(-1)!;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const r = v.at(-2)!;\n        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n          //eslint-disable-next-line functional/immutable-data\n          v.pop();\n        } else break;\n      }\n      //eslint-disable-next-line functional/immutable-data\n      v.push(p);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    v.pop();\n    return v;\n  };\n\n  const upper = x(sorted);\n  //eslint-disable-next-line functional/immutable-data\n  const lower = x(sorted.reverse());\n\n  if (upper.length === 1 && lower.length === 1 && isEqual(lower[ 0 ], upper[ 0 ])) {\n    return upper;\n  }\n  return [ ...upper, ...lower ];\n};","import { isPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function getTwoPointParameters(a: Point, b: Point): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, b: Point3d): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a: Point, x: number, y: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number) {\n  if (isPoint3d(a1) && isPoint3d(ab2)) return [ a1, ab2 ];\n  if (isPoint(a1) && isPoint(ab2)) return [ a1, ab2 ];\n  if (isPoint3d(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3,\n      z: ab4\n    }\n    if (!isPoint3d(b)) throw new Error(`Expected x, y & z parameters`);\n    return [ a1, b ];\n  }\n  if (isPoint(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3\n    }\n    if (!isPoint(b)) throw new Error(`Expected x & y parameters`);\n    return [ a1, b ];\n  }\n\n  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n    const a = {\n      x: a1,\n      y: ab2,\n      z: ab3\n    };\n    const b = {\n      x: ab4,\n      y: ab5,\n      z: ab6\n    }\n    if (!isPoint3d(a)) throw new Error(`Expected x,y,z for first point`);\n    if (!isPoint3d(b)) throw new Error(`Expected x,y,z for second point`);\n    return [ a, b ];\n  }\n\n  const a = {\n    x: a1,\n    y: ab2\n  };\n  const b = {\n    x: ab3,\n    y: ab4\n  }\n  if (!isPoint(a)) throw new Error(`Expected x,y for first point`);\n  if (!isPoint(b)) throw new Error(`Expected x,y for second point`);\n  return [ a, b ];\n\n}\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from './PointType.js';\nimport { getPointParameter } from \"./GetPointParameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import { guard as guardPoint } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Circle, CirclePositioned } from './CircleType.js';\n\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle \n * @param parameterName \n */\nexport const guard = (circle: CirclePositioned | Circle, parameterName = `circle`) => {\n  if (isCirclePositioned(circle)) {\n    guardPoint(circle, `circle`);\n  }\n\n  if (Number.isNaN(circle.radius)) throw new Error(`${ parameterName }.radius is NaN`);\n  if (circle.radius <= 0) throw new Error(`${ parameterName }.radius must be greater than zero`);\n};\n\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle \n * @param parameterName \n * @returns \n */\nexport const guardPositioned = (circle: CirclePositioned, parameterName = `circle`) => {\n  if (!isCirclePositioned(circle)) throw new Error(`Expected a positioned circle with x,y`);\n  guard(circle, parameterName);\n};\n\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a: Circle | CirclePositioned): boolean => {\n  if (Number.isNaN(a.radius)) return true;\n  if (isCirclePositioned(a)) {\n    if (Number.isNaN(a.x)) return true;\n    if (Number.isNaN(a.y)) return true;\n  }\n  return false;\n};\n\n\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n * \n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns \n */\nexport const isPositioned = (p: Circle | Point): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCircle = (p: any): p is Circle => (p as Circle).radius !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCirclePositioned = (p: any): p is CirclePositioned => isCircle(p) && isPositioned(p);","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between two circle centers.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a \n * @param b \n * @returns Distance\n */\nexport const distanceCenter = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    guardPositioned(b, `b`);\n  }\n  return pointsDistance(a, b);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isPoint as PointsIsPoint } from \"../point/Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b \n */\nexport const distanceFromExterior = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n  } else if (PointsIsPoint(b)) {\n    const distribution = PointsDistance(a, b);\n    if (distribution < a.radius) return 0;\n    return distribution;\n  } else throw new Error(`Second parameter invalid type`);\n};","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d \n * @param name \n */\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n * \n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *  \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect \n * @param name \n */\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect \n * @returns \n */\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\n\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect \n * @returns \n */\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  rect: Point | Rect | RectPositioned\n): rect is Point =>\n  (rect as Point).x !== undefined && (rect as Point).y !== undefined;\n\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect: unknown): rect is Rect => {\n  if (rect === undefined) return false;\n  if ((rect as Rect).width === undefined) return false;\n  if ((rect as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (\n  rect: any\n): rect is RectPositioned => isRect(rect) && isPositioned(rect);\n","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n * \n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n * \n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: CirclePositioned | Circle, b: CirclePositioned | Circle): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isCirclePositioned(a) && isCirclePositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return false;\n};","import { getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  let pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function subtract(a: Point, b: Point): Point;\nexport function subtract(a: Point3d, b: Point3d): Point3d;\nexport function subtract(a: Point, x: number, y: number): Point;\nexport function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n * \n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  let pt: Writeable<Point> = {\n    x: ptA.x - ptB.x,\n    y: ptA.y - ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { isEqual } from \"./IsEqual.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\nimport type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns the point(s) of intersection between a circle and line.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle \n * @param line \n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle: CirclePositioned, line: Line): ReadonlyArray<Point> => {\n  const v1 = {\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n  };\n  const v2 = {\n    x: line.a.x - circle.x,\n    y: line.a.y - circle.y\n  };\n\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n  if (Number.isNaN(d)) return []; // no intercept\n\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  const u2 = (b + d) / c;\n\n  const returnValue = [];\n  if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u1,\n      y: line.a.y + v1.y * u1\n    });\n  }\n  if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u2,\n      y: line.a.y + v1.y * u2\n    });\n  }\n  return returnValue;\n};\n\n\n/**\n * \n * Returns the points of intersection betweeen `a` and `b`.\n * \n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a: CirclePositioned, b: CirclePositioned): ReadonlyArray<Point> => {\n  const vector = PointsSubtract(b, a);\n  const centerD = Math.hypot((vector.y), (vector.x));\n\n  // Do not intersect\n  if (centerD > a.radius + b.radius) return [];\n\n  // Circle contains another\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\n\n  // Circles are the same\n  if (isEqual(a, b)) return [];\n\n  const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n  const centroid = {\n    x: a.x + (vector.x * centroidD / centerD),\n    y: a.y + (vector.y * centroidD / centerD)\n  };\n\n  const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n\n  const intersection = {\n    x: -vector.y * (centroidIntersectionD / centerD),\n    y: vector.x * (centroidIntersectionD / centerD)\n  };\n  return [\n    PointsSum(centroid, intersection),\n    PointsSubtract(centroid, intersection)\n  ];\n};\n","import { intersections as circleIntersections } from \"./circle/Intersections.js\";\nimport type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { RectPositioned } from \"./rect/index.js\";\n\nexport const circleRect = (a: CirclePositioned, b: RectPositioned) => {\n  // https://yal.cc/rectangle-circle-intersection-test/\n  const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n  const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n  return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\n\nexport const circleCircle = (a: CirclePositioned, b: CirclePositioned) => circleIntersections(a, b).length === 2;","import { guard } from \"./Guard.js\";\nimport { isPositioned, isRectPositioned } from \"./Guard.js\";\nimport { isCirclePositioned } from '../circle/Guard.js';\nimport * as Intersects from '../Intersects.js';\nimport { isPoint } from \"../point/Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"../circle/CircleType.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  point: Point\n): boolean;\n\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  x: number,\n  y: number\n): boolean;\n\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  a: Point | number,\n  b?: number\n): boolean {\n  guard(rect, `rect`);\n  //eslint-disable-next-line functional/no-let\n  let x = 0;\n  //eslint-disable-next-line functional/no-let\n  let y = 0;\n  if (typeof a === `number`) {\n    if (b === undefined) throw new Error(`x and y coordinate needed`);\n    x = a;\n    y = b;\n  } else {\n    x = a.x;\n    y = a.y;\n  }\n  if (isPositioned(rect)) {\n    if (x - rect.x > rect.width || x < rect.x) return false;\n    if (y - rect.y > rect.height || y < rect.y) return false;\n  } else {\n    // Assume 0,0\n    if (x > rect.width || x < 0) return false;\n    if (y > rect.height || y < 0) return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (\n  a: RectPositioned,\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  b: CirclePositioned | Point\n): boolean => {\n  if (!isRectPositioned(a)) {\n    throw new Error(`a parameter should be RectPositioned`);\n  }\n\n  if (isCirclePositioned(b)) {\n    return Intersects.circleRect(b, a);\n  } else if (isPoint(b)) {\n    return intersectsPoint(a, b);\n  }\n  throw new Error(`Unknown shape for b: ${ JSON.stringify(b) }`);\n};","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { getRectPositioned, guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the center of a rectangle as a {@link Geometry.Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): Point => {\n  guard(rect);\n  if (origin === undefined && isPoint(rect)) origin = rect;\n  else if (origin === undefined) origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n\n  const r = getRectPositioned(rect, origin);\n  return Object.freeze({\n    x: origin.x + rect.width / 2,\n    y: origin.y + rect.height / 2,\n  });\n};","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });","import { guardPositioned } from \"./Guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./Center.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { type Point } from '../point/PointType.js';\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { distance as PointsDistance } from '../point/Distance.js';\n\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (\n  rect: RectPositioned,\n  pt: Point\n): number => {\n  guardPositioned(rect, `rect`);\n  PointsGuard(pt, `pt`);\n  if (intersectsPoint(rect, pt)) return 0;\n  const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n  const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n  return Math.hypot(dx, dy);\n};\n\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (\n  rect: RectPositioned,\n  pt: Point\n): number => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance } from \"./Distance.js\";\nimport { isPoint } from \"./Guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport type { Point } from \"./PointType.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance, isPoint } from \"./index.js\";\nimport type { Point, PointCalculableShape } from \"../Types.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\n\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { getPointParameter, getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  let pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | Array<number>, b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | Array<number>,\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p: Point): ReadonlyArray<number> => [ p.x, p.y ];\n","import { dotProduct as ArraysDotProduct } from '../../numbers/NumericArrays.js';\nimport type { Point } from './PointType.js';\nimport { toArray } from './ToArray.js';\n\nexport const dotProduct = (...pts: ReadonlyArray<Point>): number => {\n  const a = pts.map(p => toArray(p));\n  return ArraysDotProduct(a);\n};","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 } as const;\n\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 } as const;\n\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 } as const;\n\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 } as const;","import { guard } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function from(x: number, y: number, z: number): Point3d;\nexport function from(x: number, y: number): Point;\nexport function from(arr: [ x: number, y: number, z: number ]): Point3d;\nexport function from(arr: [ x: number, y: number ]): Point;\n\n/**\n * Returns a point from two or three coordinates or an array of [x,y] or [x,y,z].\n * @example\n * ```js\n * let p = from([10, 5]);    // yields {x:10, y:5}\n * let p = from([10, 5, 2]); // yields: {x:10, y:5, z:2}\n * let p = from(10, 5);      // yields {x:10, y:5}\n * let p = from(10, 5, 2);   // yields: {x:10, y:5, z:2}\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport function from(\n  xOrArray?: number | ReadonlyArray<number>,\n  y?: number,\n  z?: number\n): Point {\n  if (Array.isArray(xOrArray)) {\n    if (xOrArray.length === 3) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n        z: xOrArray[ 2 ]\n      });\n    } else if (xOrArray.length === 2) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n      });\n    } else {\n      throw new Error(`Expected array of length two or three, got ${ xOrArray.length }`);\n    }\n  } else {\n    if (xOrArray === undefined) throw new Error(`Requires an array of [x,y] or x,y parameters at least`)\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\n    if (y === undefined) throw new Error(`Param 'y' is missing`);\n    else if (Number.isNaN(y)) throw new Error(`y is NaN`);\n    if (z === undefined) {\n      return Object.freeze({ x: xOrArray as number, y: y });\n    } else {\n      return Object.freeze({ x: xOrArray as number, y, z })\n    }\n  }\n};\n\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n * \n * Throws an error if `str` is not a string.\n * \n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n * \n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param str \n */\nexport const fromString = (str: string): Point => {\n  if (typeof str !== `string`) throw new TypeError(`Param 'str' ought to be a string. Got: ${ typeof str }`);\n  const comma = str.indexOf(`,`);\n  const x = Number.parseFloat(str.substring(0, comma));\n  const nextComma = str.indexOf(',', comma + 1);\n  if (nextComma > 0) {\n    // z component\n    const y = Number.parseFloat(str.substring(comma + 1, nextComma - comma + 2));\n    const z = Number.parseFloat(str.substring(nextComma + 1));\n    return { x, y, z };\n  } else {\n    const y = Number.parseFloat(str.substring(comma + 1));\n    return { x, y };\n  }\n}\n\n\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (\n  ...coords: ReadonlyArray<ReadonlyArray<number>> | ReadonlyArray<number>\n): ReadonlyArray<Point> => {\n  const pts: Array<Point> = [];\n\n  if (Array.isArray(coords[ 0 ])) {\n    // [[x,y],[x,y]...]\n    for (const coord of (coords as Array<Array<number>>)) {\n      if (!(coord.length % 2 === 0)) {\n        throw new Error(`coords array should be even-numbered`);\n      }\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(Object.freeze({ x: coord[ 0 ], y: coord[ 1 ] }));\n    }\n  } else {\n    // [x,y,x,y,x,y]\n    if (coords.length % 2 !== 0) {\n      throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n    }\n\n    for (let index = 0; index < coords.length; index += 2) {\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(\n        Object.freeze({ x: coords[ index ] as number, y: coords[ index + 1 ] as number })\n      );\n    }\n  }\n  return pts;\n};\n","import { isPoint } from \"../point/Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/PointType.js\";\nimport { isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard as guardPoint } from '../point/Guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/PointType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { isPolyLine } from \"./Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { throwNumberTest, throwPercentTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { length } from \"./Length.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\n//eslint-disable-next-line func-style\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n  // eslint-disable-next-line unicorn/no-negated-condition\n  if (!allowOverflow) throwPercentTest(amount, `amount`);\n  else throwNumberTest(amount, ``, `amount`);\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n","import type { Point } from \"./PointType.js\";\nimport { interpolate as lineInterpolate } from '../line/Interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import { getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function multiply(a: Point, b: Point): Point;\nexport function multiply(a: Point3d, b: Point3d): Point3d;\nexport function multiply(a: Point, x: number, y: number): Point;\nexport function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  let pt: Writeable<Point> = {\n    x: ptA.x * ptB.x,\n    y: ptA.y * ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./Distance.js\";\nimport { multiply } from \"./Multiply.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./Empty.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Rect } from \"../rect/RectTypes.js\";\nimport { isRect } from \"../rect/Guard.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Normalises a point by a given width and height\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport function normaliseByRect(\n  point: Point,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point by a given rect's width and height\n * @param pt \n * @param rect \n */\nexport function normaliseByRect(pt: Point, rect: Rect): Point;\n\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function normaliseByRect(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point so it is on a 0..1 scale\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(\n  a: Point | number,\n  b: number | Rect,\n  c?: number,\n  d?: number\n): Point {\n  //  Unit tested\n  if (isPoint(a)) {\n    if (typeof b === `number` && c !== undefined) {\n      throwNumberTest(b, `positive`, `width`);\n      throwNumberTest(c, `positive`, `height`);\n    } else {\n      if (!isRect(b)) {\n        throw new Error(`Expected second parameter to be a rect`);\n      }\n      c = b.height;\n      b = b.width;\n    }\n    return Object.freeze({\n      x: a.x / b,\n      y: a.y / c,\n    });\n  } else {\n    throwNumberTest(a, `positive`, `x`);\n    if (typeof b !== `number`) {\n      throw new TypeError(`Expecting second parameter to be a number (width)`);\n    }\n    if (typeof c !== `number`) {\n      throw new TypeError(`Expecting third parameter to be a number (height)`);\n    }\n\n    throwNumberTest(b, `positive`, `y`);\n    throwNumberTest(c, `positive`, `width`);\n    if (d === undefined) throw new Error(`Expected height parameter`);\n    throwNumberTest(d, `positive`, `height`);\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}","import type { Point } from \"./PointType.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","\nimport { isPoint3d } from \"./Guard.js\";\nimport type { Point3d, Point } from \"./PointType.js\";\nimport { subtract } from \"./Subtract.js\";\n\n/**\n * Computes the progress between two waypoints, given `position`.\n * \n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns \n */\nexport const progressBetween = (\n  position: Point | Point3d,\n  waypointA: Point | Point3d,\n  waypointB: Point | Point3d\n) => {\n  // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n  // from -> current\n  const a = subtract(position, waypointA);\n\n  // from -> to\n  const b = subtract(waypointB, waypointA);\n\n  return isPoint3d(a) && isPoint3d(b) ? (\n    (a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)\n  ) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin: Point, distance: number, angle: number) => {\n  const x = Math.cos(angle) * distance + origin.x;\n  const y = Math.sin(angle) * distance + origin.y;\n  return { x, y };\n};","import { throwIntegerTest, throwNumberTest } from \"../util/GuardNumbers.js\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyStr = every.toString();\n  const decimal = everyStr.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    let d = everyStr.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n  throwNumberTest(v, ``, `v`);\n  throwIntegerTest(every, ``, `every`);\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { quantiseEvery as quantiseEveryNumber } from '../../numbers/Quantise.js';\nimport { guard, isPoint3d } from './Guard.js';\nimport type { Point, Point3d } from './PointType.js';\n\nexport function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n\n/**\n * Quantises a point.\n * @param pt \n * @param snap \n * @param middleRoundsUp \n * @returns \n */\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp = true): Point {\n  guard(pt, `pt`);\n  guard(snap, `snap`);\n  if (isPoint3d(pt)) {\n    if (!isPoint3d(snap)) throw new TypeError(`Param 'snap' is missing 'z' field`);\n    return Object.freeze({\n      x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n      y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n      z: quantiseEveryNumber(pt.z, snap.z, middleRoundsUp)\n    });\n  }\n\n  return Object.freeze({\n    x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n    y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n  });\n}","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport type { Point, Point3d } from './PointType.js';\n\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): Point => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n  });\n};\n\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random3d = (rando?: RandomSource): Point3d => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    z: rando()\n  });\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (\n  pts: ReadonlyArray<Point>,\n  fn: (p: Point, accumulated: Point) => Point,\n  initial?: Point\n): Point => {\n  if (initial === undefined) initial = { x: 0, y: 0 }\n  let accumulator = initial;\n  for (const p of pts) {\n    accumulator = fn(p, accumulator);\n  };\n  return accumulator;\n};","import { angleRadian } from \"./Angle.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { distance } from \"./Distance.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport type { PointRelation } from \"./PointRelationTypes.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link Trackers.points}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angleRadian(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","import { degreeToRadian, radianToDegree } from './Angles.js';\nimport { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport type { Point } from './point/PointType.js';\nimport { subtract } from './point/Subtract.js';\nimport { Empty } from './point/Empty.js';\nimport { isPoint, guard as PointGuard } from './point/Guard.js';\n\n//eslint-disable-next-line @typescript-eslint/naming-convention\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\n/**\n * Polar coordinate, made up of a distance and angle in radians.\n * Most computations involving PolarCoord require an `origin` as well.\n */\nexport type Coord = {\n  readonly distance: number;\n  readonly angleRadian: number;\n};\n\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtract(point, origin);\n  //eslint-disable-next-line functional/no-let\n  //let a =  Math.atan2(point.y, point.x);\n  //if (a < 0) a = Math.abs(a);\n  //else a = Math.PI + (Math.PI - a);\n\n  const angle = Math.atan2(point.y, point.x);\n  //if (point.x < 0 && point.y > 0) angle += 180;\n  //if (point.x > 0 && point.y < 0) angle += 360;\n  //if (point.x < 0 && point.y < 0) angle += 180;\n\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = Empty;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = Empty;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\n//eslint-disable-next-line func-style\nexport function* spiral(\n  smoothness: number,\n  zoom: number\n): IterableIterator<Coord & { readonly step: number }> {\n  //eslint-disable-next-line functional/no-let\n  let step = 0;\n\n  while (true) {\n    //eslint-disable-next-line functional/no-let\n    const a = smoothness * step++;\n    yield {\n      distance: zoom * a,\n      angleRadian: a,\n      step: step,\n    };\n  }\n}\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c: Coord, amountRadian: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n  });\n\nexport const normalise = (c: Coord): Coord => {\n  //guard(v, `v`);\n  if (c.distance === 0) throw new Error(`Cannot normalise vector of length 0`);\n  return Object.freeze({\n    ...c,\n    distance: 1,\n  });\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Coord, b: Coord): number => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p: Coord): Coord => {\n  guard(p, `c`);\n  return Object.freeze({\n    ...p,\n    angleRadian: p.angleRadian - Math.PI,\n  });\n};\n\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  if (a.distance !== b.distance) return false;\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === b.angleRadian;\n};\n\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c: Coord, amountDeg: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n  });\n\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (\n  step: number,\n  smoothness: number,\n  zoom: number\n): Coord => {\n  const a = smoothness * step;\n  return Object.freeze({\n    distance: zoom * a,\n    angleRadian: a,\n  });\n};\n\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance * amt,\n  });\n};\n\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance / amt,\n  });\n};\n\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v: Coord, max = 1, min = 0): Coord => {\n  let mag = v.distance;\n  if (mag > max) mag = max;\n  if (mag < min) mag = min;\n  return Object.freeze({\n    ...v,\n    distance: mag,\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = Empty\n): Point => {\n  PointGuard(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyCartesian): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};\n","\nexport * from './Compare.js';\nexport * as Correlate from './Correlate.js';\nexport * from './CloneFromFields.js';\nexport * from './KeysToNumbers.js';\nexport * from './MapObject.js';\n\n/**\n * Means of accessing, creating and comparing objects\n * based on 'paths'. This is useful for serialisation.\n * \n */\nexport * as Pathed from './Pathed.js'\nexport * as Pool from './Pool.js';\nexport * as Process from './Process.js';\nexport * from './Pull.js';\nexport * from './Resolve.js';\nexport * from './ResolveFields.js';\nexport * from './Types.js';\nexport * from './Util.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * These array functions do not change the input data, unless noted.\n * \n * Import example:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * For arrays of numbers:\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * See also {@link Numbers} module for working with numbers in general.\n *\n * Randomisation\n * * {@link randomIndex}: Return a random array index\n * * {@link randomElement}: Return a random value\n * * {@link randomPluck}: Remove a random element from an array, returning it and the new array\n * * {@link shuffle}: Returns a randomly-sorted copy of arra\n *\n * Comparing\n * * {@link contains}: compare overlap of arrays\n * * {@link isEqual}: _true_ if two arrays contain same values at same locations\n * * {@link unique}: Returns values from two arrays, without duplicates.\n * \n * Iterating\n * * {@link pairwise}: loop in sets of two\n * \n * Finding/accessing\n * * {@link cycle}: every time function is called, the next item from array is returned\n * * {@link filterBetween}: Same as `Array.filter` but only looks within a specified index range\n * * {@link filterAB}: Like array.filter, but returns two arrays. One containing values that the predicate gives _true_, another for _false.\n * * {@link sample}: Returns a new array with a random sampling of input\n*  * {@link until}: Returns items from input until predicate returns _true_\n* \n* Sort\n* * {@link sortByNumericProperty}: Sort objects by a given numeric field\n* * {@link sortByProperty}: Sort objects by a given field\n* \n* Duplicates\n* * {@link containsDuplicateValues}: _true_ if array has at least one value is repeated\n * * {@link containsDuplicateInstances}: _true_ if array has at least one object appears twice\n * * {@link isContentsTheSame}: _true_ if all values in array are the same\n * \n * Changing the shape\n * * {@link chunks}: Chunk into sub-arrays\n * * {@link ensureLength}: Returns a copy of array with designated length, either padding it out or truncating as necessary\n * * {@link groupBy}: Groups data into a new Map\n * * {@link flatten}\n * * {@link filterBetween}: Like array.filter, but only checks within given range\n * * {@link interleave}: Flattens several arrays into one, interleaving their values.\n * * {@link remove}: Remove an item by index\n * * {@link pairwiseReduce}: Reducer that operates in pairwise fashion\n * * {@link mergeByKey}+: Merges two arrays left-to-right, using a reconcile function\n * * {@link without}: Returns an array with specified value omitted\n * * {@link zip}: Groups together elements from several arrays based on their index\n */\nexport * as Arrays from './arrays/index.js';\n\n/**\n * Maps associate keys with values. Several helper functions are provided\n * for working with the standard JS Map class.\n *\n * Import example\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Adding\n * * {@link addKeepingExisting} Adds items to a map only if their key does not exist already\n * * {@link addObject}: Adds an object, assuming each top-level property of an object is a key\n * * {@link getOrGenerate}: Solves a common scenario of wanting a value by a particular key, or generating it if it doesn't exist\n * \n * Deleting\n * * {@link deleteByValue}\n * \n * Finding/Iterating\n * * {@link filter}: Yield values that return _true_ for predicate\n * * {@link find}: Finds the first value that matches a predicate, or _undefined_ if nothing found\n * * {@link hasAnyValue}: Searches through all keys, returning true if any occurence of _value_ was found\n * * {@link hasKeyValue}: _true_ if value is stored under a key\n * * {@link firstEntryByPredicate}: Returns first entry which matches predicate\n * * {@link firstEntryByValue}: Returns first entry where value matches\n * * {@link getClosestIntegerKey}: Assuming numeric keys, find the closest to a target value\n * * {@link getFromKeys}: Given an iterable of keys, returns the first value where the key is present\n * * {@link some}: _true_ if predicate is true for any value in map\n * \n * Transforming values\n * * {@link mapToArray}: Applies a function to convert a map's values to an array\n * * {@link mapToObjectTransform}: Converts a map to a plain object, but applying a function to values\n * * {@link transformMap}: Like `Array.map`, but for Maps. Useful for generating a map as a transform of an input map.\n * \n * Creating\n * * {@link fromIterable}: Generates a map from an interable\n * * {@link fromObject}\n * * {@link zipKeyValue}: Given an array of keys and values, combines them together into a map\n * \n * To some other data\n * * {@link toArray}: Returns the values of the map as an array\n * * {@link toObject}: Coverts a Map to a plain object, useful for JSON serialising.\n * \n * Etc\n * * {@link sortByValue}: Returns a sorted set of entries\n * * {@link sortByValueProperty}: Returns a sorted set of entries\n * \n * See also ixfx's Collections module for custom map implementations.\n */\nexport * as Maps from './maps/index.js'\n","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\n//eslint-disable-next-line functional/immutable-data\nexport const align = <V>(\n  similarityFn: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  options: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = options.matchThreshold ?? 0;\n  const debug = options.debug ?? false;\n  const results = new Map();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map();\n  lastData?.forEach((d, index) => {\n    if (d === undefined) {\n      throw new Error(`'lastData' contains undefined (index: ${ index })`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < newData.length; i++) {\n    const newD = newData[ i ];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${ newD.id }`);\n\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: last.id,\n      score: last === null ? -1 : similarityFn(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${ newD.id }`);\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n    //eslint-disable-next-line functional/immutable-data\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[ 0 ];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${ top.score } id: ${ newD.id }`\n        );\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${ newD.id } -> ${ top.id } (score: ${ top.score })`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    //eslint-disable-next-line functional/immutable-data\n    lastMap.delete(top.id);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, options: AlignOpts = {}) => {\n  let lastData: readonly DataWithId<V>[] = [];\n\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, options);\n    return [ ...lastData ];\n  };\n  return compute;\n};\n","import { isPlainObjectOrPrimitive } from \"../util/GuardObject.js\";\n\nexport const cloneFromFields = <T extends object>(source: T) => {\n  const entries: Array<[ key: string, value: any ]> = [];\n  for (const field in source) {\n    const value = (source)[ field ];\n    if (isPlainObjectOrPrimitive(value as unknown)) {\n      entries.push([ field, value ]);\n    }\n  }\n  return Object.fromEntries(entries) as T;\n}","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n * \n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n * \n * \n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n * \n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object \n * @param onInvalidKey \n * @returns \n */\nexport const keysToNumbers = <T>(object: Record<any, T>, onInvalidKey: `throw` | `ignore` | `keep` = `throw`): Record<number, T> => {\n  const returnObject: Record<number, T> = {};\n  for (const entry of Object.entries(object)) {\n    const asNumber = Number.parseInt(entry[ 0 ]);\n    if (Number.isNaN(asNumber)) {\n      switch (onInvalidKey) {\n        case `throw`: {\n          throw new TypeError(`Cannot convert key '${ entry[ 0 ] }' to an integer`);\n        }\n        case `ignore`: {\n          continue;\n        }\n        case `keep`: {\n          (returnObject as any)[ entry[ 0 ] ] = entry[ 1 ];\n          continue;\n        }\n        default: {\n          throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n        }\n      }\n    }\n    returnObject[ asNumber ] = entry[ 1 ];\n  }\n  return returnObject;\n}\n","import type { RemapObjectPropertyType } from \"../TsUtil.js\";\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  // eslint-disable-next-line indent\n  object: TSource,\n  // eslint-disable-next-line indent\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n  // eslint-disable-next-line indent\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n  ]) as Array<MapResult>;\n  // @ts-expect-error\n  return Object.fromEntries(mapped);\n};\n\nexport type MapObjectArgs = {\n  field: string\n  path: string\n  value: any\n  index: number\n}\n\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data \n * @param mapper \n * @returns \n */\nexport function mapObjectByObject(data: any, mapper: Record<string, (value: any, context: any) => any>) {\n  const entries = Object.entries(data);\n  for (let i = 0; i < entries.length; i++) {\n    const e = entries[ i ];\n    if (e[ 0 ] in mapper) {\n      const m = mapper[ e[ 0 ] ];\n      e[ 1 ] = (typeof m === `object`) ?\n        mapObjectByObject(e[ 1 ], m) :\n        m(e[ 1 ], data);\n    }\n  }\n  return Object.fromEntries(entries);\n}","import { SimpleEventEmitter } from '../Events.js';\nimport * as Debug from '../debug/index.js';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type Opts<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string, data: V) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    //const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`, data);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: Array<PoolUser<V>>;\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`, data);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'. \n * All resources in the Pool are meant to be the same kind of object.\n * \n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n * \n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n * \n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport class Pool<V> {\n  private _resources: Array<Resource<V>>;\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet;\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param options Pool options\n   */\n  constructor(options: Opts<V> = {}) {\n    this.capacity = options.capacity ?? -1;\n    this.fullPolicy = options.fullPolicy ?? `error`;\n    this.capacityPerResource = options.capacityPerResource ?? 1;\n    this.userExpireAfterMs = options.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      options.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = options.generate;\n    this.freeResource = options.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, options.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    //eslint-disable-next-line functional/no-let\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a shared resource to the pool\n   * @throws Error if the capacity limit is reached or resource is null\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new TypeError(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    //eslint-disable-next-line functional/no-let\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Array<Resource<V>> = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: Array<string> = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`, user.data);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * Allocates a resource for `userKey`\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  #allocateResource(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    //eslint-disable-next-line functional/no-let\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a 'user' key.\n   * \n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * \n   * If a 'user' already has a resource, it will 'keep alive' their use.\n   * If a 'user' does not already have resource\n   *  - if there is capacity, a resource is allocated to user\n   *  - if pool is full\n   *    - fullPolicy = 'error': an error is thrown\n   *    - fullPolicy = 'evictOldestUser': evicts an older user\n   *    - Throw error\n   * @param userKey\n   * @throws Error If all resources are used and fullPolicy = 'error'\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this.#allocateResource(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      //console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this.#allocateResource(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport const create = <V>(options: Opts<V> = {}): Pool<V> => new Pool<V>(options);\n","import { toStringDefault } from \"../util/ToString.js\";\nimport { isEqualDefault } from \"../util/IsEqual.js\";\nexport { average, max, min, tally, sum, rank } from './BasicProcessors.js';\n\nexport type Process<TIn, TOut> = (value: TIn) => TOut;\nexport type ProcessFactory<TIn, TOut> = () => Process<TIn, TOut>;\n\nexport type Processors1<T1, T2> = [\n  Process<T1, T2>\n]\n\nexport type Processors2<T1, T2, T3> = [\n  Process<T1, T2>,\n  Process<T2, T3>\n]\n\nexport type Processors3<T1, T2, T3, T4> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>\n]\n\nexport type Processors4<T1, T2, T3, T4, T5> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>\n]\n\nexport type Processors5<T1, T2, T3, T4, T5, T6> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>,\n  Process<T5, T6>\n]\nexport type Processors<T1, T2, T3, T4, T5, T6> = Processors1<T1, T2> | Processors2<T1, T2, T3> | Processors3<T1, T2, T3, T4> | Processors4<T1, T2, T3, T4, T5> | Processors5<T1, T2, T3, T4, T5, T6>;\n\nexport function flow<T1, T2>(...processors: [ Process<T1, T2> ]): (value: T1) => T2;\nexport function flow<T1, T2, T3>(...processors: [ Process<T1, T2>, Process<T2, T3> ]): (value: T1) => T3;\nexport function flow<T1, T2, T3, T4>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4> ]): (value: T1) => T4;\nexport function flow<T1, T2, T3, T4, T5>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5> ]): (value: T1) => T5;\nexport function flow<T1, T2, T3, T4, T5, T6>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5>, Process<T5, T6> ]): (value: T1) => T6;\n\n/**\n * Creates a flow of data processors (up to 5 are supported).\n * The flow is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = flow(\n *  (value:string) => value.toUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A') // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param processors \n * @returns \n */\nexport function flow<T1, T2, T3, T4, T5, T6>(...processors: Processors<T1, T2, T3, T4, T5, T6>): (value: T1) => T2 | T3 | T4 | T5 | T6 {\n  return (value: T1) => {\n    let v = value;\n    for (const p of processors) {\n      try {\n        // @ts-expect-error\n        v = p(v);\n      } catch (err) {\n        if (err instanceof CancelError) {\n          break;\n        } else {\n          throw err;\n        }\n      }\n    }\n    return v as T2 | T3 | T4 | T5 | T6;\n  }\n}\n\n/**\n * If a value is same as the previous value, _undefined_ is emitted instead.\n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenLastToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  if (eq === undefined) eq = isEqualDefault;\n  let lastValue: TIn | undefined;\n  return (value: TIn) => {\n    if (value !== lastValue) {\n      lastValue = value;\n      return value;\n    }\n    return undefined;\n  }\n}\n\n/**\n * If a value is same as any previously-seen value, _undefined_ is emitted instead.\n * It stores all previous values and compares against them for each new value. \n * This would likely be not very efficient compared to {@link seenToUndefinedByKey} which uses a one-time computed\n * key and efficient storage of only the keys (using a Set).\n *  \n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  let seen: TIn[] = [];\n  if (eq === undefined) eq = isEqualDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    for (const s of seen) {\n      if (eq(s, value)) return;\n    }\n    seen.push(value);\n    return value;\n  }\n}\n\n/**\n * If a value is the same as any previously-seen value, _undefined_ is emitted instead.\n * This version uses a function to create a string key of the object, by default JSON.stringify.\n * Thus we don't need to store all previously seen objects, just their keys.\n * \n * Alternatively, if a key function doesn't make sense for the value, use\n * {@link seenToUndefined}, which stores the values (less efficient).\n * \n * @param toString \n * @returns \n */\nexport function seenToUndefinedByKey<TIn>(toString?: (value: TIn) => string): Process<TIn, TIn | undefined> {\n  let seen = new Set<string>();\n  if (toString === undefined) toString = toStringDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    const key = toString(value);\n    if (seen.has(key)) return;\n    seen.add(key);\n    return value;\n  }\n}\n/**\n * Calls a function if the input value is not undefined.\n * Return value from function is passed to next function in flow.\n * \n * ```js\n * const flow = Process.flow(\n *  Process.max(),\n *  Process.seenLastToUndefined(),\n *  Process.ifNotUndefined(v => {\n *    console.log(`v:`, v);\n *  })\n * );\n * flow(100); // Prints 'v:100'\n * flow(90);  // Nothing happens max value has not changed\n * flow(110); // Prints 'v:110'\n * ```\n * @param fn \n * @returns \n */\nexport function ifNotUndefined<TIn, TOut>(fn: (value: Exclude<TIn, undefined>) => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return value;\n    const v = fn(value as Exclude<TIn, undefined>);\n    return v;\n  }\n}\n\nexport class CancelError extends Error {\n  constructor(message: any) {\n    super(message);\n    this.name = `CancelError`;\n  }\n}\n\n/**\n * Cancels the remaining flow operations if _undefined_ is an input.\n * See also {@link ifUndefined} or {@link ifNotUndefined}.\n * \n * ```js\n * const c3 = Process.flow(\n *  Basic.max(),\n *  Process.seenLastToUndefined(),\n *  Process.cancelIfUndefined(),\n *  (v => {\n *   console.log(v);\n *  })\n * );\n * c3(100); // Prints '100'\n * c3(90);  // Doesn't print anything since max does not change\n * c3(110); // Prints '110'\n * ```\n * @returns \n */\nexport function cancelIfUndefined<TIn>() {\n  return (value: TIn | undefined) => {\n    if (value === undefined) throw new CancelError(`cancel`);\n    return value as TIn;\n  }\n}\n/**\n * Returns the output of `fn` if the input value is _undefined_.\n * See also: {@link ifNotUndefined} and {@link cancelIfUndefined}.\n * @param fn \n * @returns \n */\nexport function ifUndefined<TIn, TOut>(fn: () => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return fn();\n    else return value;\n  }\n}","import type { Process } from \"./Process.js\";\nimport type { RankFunction, RankOptions } from \"./Types.js\";\n\n/**\n * Outputs the current largest-seen value\n * @returns \n */\nexport const max = (): Process<number | Array<number>, number> => {\n  let max = Number.MIN_SAFE_INTEGER;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      max = Math.max(subValue, max);\n    }\n    return max;\n  }\n  return compute;\n}\n\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = (): Process<number | Array<number>, number> => {\n  let min = Number.MAX_SAFE_INTEGER;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      min = Math.min(subValue, min);\n    }\n    return min;\n  }\n  return compute;\n}\n\n/**\n * Returns a sum of values\n * @returns \n */\nexport const sum = (): Process<number | Array<number>, number> => {\n  let t = 0;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      t += subValue;\n    }\n    return t;\n  }\n  return compute;\n}\n\n/**\n * Returns the current average of input values\n * @returns \n */\nexport const average = (): Process<number | Array<number>, number> => {\n  let total = 0;\n  let tally = 0;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      tally++;\n      total += subValue;\n    }\n    return total / tally;\n  }\n  return compute;\n}\n\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems \n * @returns \n */\nexport const tally = (countArrayItems: boolean): Process<any, number> => {\n  let t = 0;\n  const compute = (value: number | Array<number>) => {\n    if (countArrayItems) {\n      if (Array.isArray(value)) t += value.length;\n      else t++;\n    } else {\n      t++;\n    }\n    return t;\n  }\n  return compute;\n}\n\n\n\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r \n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}) {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  let best: In | undefined;\n  return (value: In) => {\n    if (includeType && typeof value !== includeType) return;\n    if (best === undefined) {\n      best = value;\n      return best;\n    } else {\n      const result = r(value, best);\n      //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n      if (result == `a`) {\n        // New value is the current best\n        best = value;\n        return best;\n      } else if (result === `eq` && emitEqualRanked) {\n        // New value is same rank as previous, but we have flag on\n        return best;\n      } else if (emitRepeatHighest) {\n        // Emit current highest due to flag\n        return best;\n      }\n    }\n  }\n}\n\n\n","import type { ReactiveNonInitial } from \"src/rx/Types.js\";\nimport { resolve, resolveSync, type ResolveToValue } from \"./Resolve.js\";\nimport { zip } from \"./arrays/Zip.js\";\n\nexport type ResolvedObject<T extends Record<string, ResolveToValue<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number :\n    T[ K ] extends string ? string :\n    T[ K ] extends boolean ? boolean :\n    T[ K ] extends bigint ? bigint :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends ReactiveNonInitial<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V : // array needed?\n    T[ K ] extends object ? T[ K ] : never\n  };\n\n\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n * \n * Use {@link resolveFieldsSync} for a synchronous version.\n * \n * Not recursive.\n * \n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n * \n * It also works with generators\n * ```js\n * import { count } from './numbers.js';\n * \n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object \n * @returns \n */\nexport async function resolveFields<T extends Record<string, ResolveToValue<any>>>(object: T): Promise<ResolvedObject<T>> {\n  const resolvers = [];\n  const keys = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    resolvers.push(resolve(resolvable));\n    keys.push(entry[ 0 ]);\n  }\n  const results = await Promise.all(resolvers);\n  const entries = zip(keys, results);\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\nexport function resolveFieldsSync<T extends Record<string, ResolveToValue<any>>>(object: T): ResolvedObject<T> {\n  const entries: [ key: string, value: any ][] = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    const value = resolveSync(resolvable);\n    entries.push([ entry[ 0 ], value ]);\n  }\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\n\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n","export * from './GetOrGenerate.js';\nexport type * from './IMappish.js';\nexport * from './MapFns.js';","import { piPi } from '../data/index.js';\nimport type { Point } from './point/PointType.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: ReadonlyArray<number>): ReadonlyArray<number>;\n\n//eslint-disable-next-line func-style\nexport function degreeToRadian(angleInDegrees: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: ReadonlyArray<number>): ReadonlyArray<number>;\n\n//eslint-disable-next-line func-style\nexport function radianToDegree(angleInRadians: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start: number, amount: number, clockwise = true) => {\n  if (clockwise) {\n    const x = start - amount;\n    if (x < 0) {\n      return piPi + x;\n    }\n    return x;\n  } else {\n    let x = start + amount;\n    if (x >= piPi) x = x % piPi;\n    return x;\n  }\n}\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n * \n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start: number, amount: number, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n * \n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n * \n * See {@link degreeArc} to operate in degrees.\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start: number, end: number, clockwise = true) => {\n  let s = start;\n  if (end < s) {\n    s = 0;\n    end = piPi - start + end;\n  }\n  let d = end - s;\n  if (clockwise) d = piPi - d;\n  if (d >= piPi) return d % piPi;\n  return d;\n}\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n * \n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n * \n * See {@link radianArc} to operate in radians.\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start: number, end: number, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../Polar.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../Polar.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport function rotate(\n  pt: ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): ReadonlyArray<Point>;\n\nexport function rotate(\n  pt: Point | ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): Point | ReadonlyArray<Point> {\n  if (origin === undefined) origin = { x: 0, y: 0 };\n  guard(origin, `origin`);\n  throwNumberTest(amountRadian, ``, `amountRadian`);\n  const arrayInput = Array.isArray(pt);\n\n  // no-op\n  if (amountRadian === 0) return pt;\n\n  if (!arrayInput) {\n    pt = [ pt as Point ];\n  }\n\n  const ptAr = pt as ReadonlyArray<Point>;\n  for (const [ index, p ] of ptAr.entries()) guard(p, `pt[${ index }]`);\n\n  const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n  const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n  const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n  return arrayInput ? asCartesisan : asCartesisan[ 0 ];\n}","\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (\n  v: ReadonlyArray<ReadonlyArray<number>>,\n  amountRadian: number\n): Array<Array<number>> => {\n  const mat = [\n    [ Math.cos(amountRadian), -Math.sin(amountRadian) ],\n    [ Math.sin(amountRadian), Math.cos(amountRadian) ],\n  ];\n  const result = [];\n  for (const [ index, element ] of v.entries()) {\n    //eslint-disable-next-line functional/immutable-data\n    result[ index ] = [\n      mat[ 0 ][ 0 ] * element[ 0 ] + mat[ 0 ][ 1 ] * element[ 1 ],\n      mat[ 1 ][ 0 ] * element[ 0 ] + mat[ 1 ][ 1 ] * element[ 1 ],\n    ];\n  }\n  return result;\n};","import { round as roundNumber } from '../../numbers/Round.js';\nimport { getPointParameter } from './GetPointParameter.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX \n * @param yOrDigits \n * @param digits \n * @returns \n */\nexport const round = (ptOrX: Point | number, yOrDigits?: number, digits?: number): Point => {\n  const pt = getPointParameter(ptOrX, yOrDigits);\n  digits = digits ?? yOrDigits;\n  digits = digits ?? 2;\n  return Object.freeze({\n    ...pt,\n    x: roundNumber(digits, pt.x),\n    y: roundNumber(digits, pt.y)\n  })\n}","import { guard } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (\n  pt: Point,\n  rounder: (x: number) => number = Math.round\n): Point => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    x: rounder(pt.x),\n    y: rounder(pt.y),\n  });\n};\n\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt \n * @returns \n */\nexport const to2d = (pt: Point): Point => {\n  guard(pt, `pt`);\n  let copy = {\n    ...pt\n  };\n  delete copy.z;\n  return Object.freeze(copy);\n}\n\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns \n */\nexport const to3d = (pt: Point, z: number = 0): Point3d => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    ...pt,\n    z\n  });\n}\n\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p: Point, digits?: number): string {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n  guard(p, `pt`);\n\n  const x = digits ? p.x.toFixed(digits) : p.x;\n  const y = digits ? p.y.toFixed(digits) : p.y;\n\n  if (p.z === undefined) {\n    return `(${ x },${ y })`;\n  } else {\n    const z = digits ? p.z.toFixed(digits) : p.z;\n    return `(${ x },${ y },${ z })`;\n  }\n}","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns true if two points are within a specified range on both axes.\n * \n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (\n  a: Point,\n  b: Point,\n  maxRange: Point | number\n): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n\n  if (typeof maxRange === `number`) {\n    throwNumberTest(maxRange, `positive`, `maxRange`);\n    maxRange = { x: maxRange, y: maxRange };\n  } else {\n    guard(maxRange, `maxRange`);\n  }\n  const x = Math.abs(b.x - a.x);\n  const y = Math.abs(b.y - a.y);\n  return x <= maxRange.x && y <= maxRange.y;\n};","import { wrap as wrapNumber } from '../../numbers/Wrap.js';\nimport { guard } from './Guard.js';\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (\n  pt: Point,\n  ptMax?: Point,\n  ptMin?: Point\n): Point => {\n\n  if (ptMax === undefined) ptMax = { x: 1, y: 1 };\n  if (ptMin === undefined) ptMin = { x: 0, y: 0 };\n\n  //  Unit tested\n  guard(pt, `pt`);\n  guard(ptMax, `ptMax`);\n  guard(ptMin, `ptMin`);\n\n  return Object.freeze({\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n  });\n};\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/Interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport type { Point } from '../point/PointType.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './BezierType.js';\nimport { isCubicBezier, isQuadraticBezier } from './Guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './BezierType.js';\nexport * from './Guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x' + y')^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z') + (z'x\" - z\"x') + (x'y\" - x\"y'))\n    //   k(t) = -------------------------------------------------------\n    //                     (x' + y' + z')^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import type { Point } from \"../point/PointType.js\";\nimport { guardDim } from \"./Guard.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import type { Path } from \"../path/PathType.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./BezierType.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n","import * as Points from '../../geometry/point/index.js';\nimport * as Bezier from '../../geometry/bezier/index.js';\nimport { scale } from '../../numbers/Scale.js';\n\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns \n */\nexport const line = (bend: number = 0, warp: number = 0) => {\n  const max = 1;\n  const cubicB = {\n    x: scale(bend, -1, 1, 0, max),\n    y: scale(bend, -1, 1, max, 0),\n  }\n\n  // Add in bend as 'drive'\n  let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n\n  // Warp\n  if (bend !== 0 && warp > 0) {\n    if (bend > 0) {\n      cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n    } else {\n      cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n    }\n  }\n\n  const bzr = Bezier.cubic(Points.Empty, Points.Unit,\n    cubicA, cubicB\n  );\n\n  const inter = Bezier.interpolator(bzr);\n  return (value: number) => inter(value);\n}","import { intervalToMs, type Interval } from \"../flow/IntervalType.js\";\nimport type { Modulate, ModulatorTimed } from \"./Types.js\";\nimport * as Timer from '../flow/Timer.js';\nimport { throwFunctionTest } from \"../util/GuardFunction.js\";\n\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  fn: Modulate,\n  duration: Interval\n): () => number => {\n  throwFunctionTest(fn, `fn`);\n  let relative: undefined | (() => number);\n  return () => {\n    if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n * \n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (\n  fn: Modulate,\n  duration: Interval\n): ModulatorTimed => {\n  throwFunctionTest(fn, `fn`);\n\n  const timer = Timer.elapsedMillisecondsAbsolute();\n  const durationMs = intervalToMs(duration);\n  if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  const relativeTimer = Timer.relative(\n    durationMs,\n    {\n      timer,\n      clampValue: true\n    });\n  return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n * \n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  fn: Modulate,\n  totalTicks: number\n): () => number => {\n  throwFunctionTest(fn, `fn`);\n\n  let relative: undefined | (() => number);\n  return () => {\n    if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n/**\n * Creates an modulator based on ticks. \n * \n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (\n  fn: Modulate,\n  durationTicks: number\n): ModulatorTimed => {\n  throwFunctionTest(fn, `fn`);\n  const timer = Timer.elapsedTicksAbsolute();\n  const relativeTimer = Timer.relative(\n    durationTicks,\n    {\n      timer,\n      clampValue: true\n    });\n  return Timer.timerWithFunction(fn, relativeTimer);\n};","import type { Interval } from '../flow/IntervalType.js';\nimport { wrap } from './Wrap.js';\nimport { ofTotal } from '../flow/Timer.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { clamp } from '../numbers/Clamp.js';\nimport { get as getEasing, type EasingName } from '../modulation/easing/index.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * \n * Limit\n * What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. \n */\nexport type InterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  easing: EasingName,\n  transform: (v: number) => number\n}\n\n\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * Interpolation is often used for animation. In that case, `amount`\n * would start at 0 and you would keep interpolating up to `1`\n * @example\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { percentPingPong } from 'https://unpkg.com/ixfx/dist/modulation.js'\n *\n * // Go back and forth between 0 and 1 by 0.1\n * let pp = percentPingPong(0.1);\n * continuously(() => {\n *  // Get position in ping-pong\n *  const amt = pp.next().value;\n *  // interpolate between Math.PI and Math.PI*2\n *  const v = interpolate(amt, Math.PI, Math.PI*2);\n *  // do something with v...\n * }).start();\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * If two parameters are given, it instead returns a function which interpolates:\n * ```js\n * const i = interpolate(100, 200);\n * i(0.5); // 150\n * \n * // Compared to:\n * interpolate(0.5, 100, 200); // 150\n * ```\n * \n * This is useful if you want to reuse the interpolator with fixed `a` and `b` values.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    throwNumberTest(_a, ``, `a`);\n    throwNumberTest(_b, ``, `b`);\n    throwNumberTest(_amt, ``, `amount`);\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easingFn = getEasing(o.easing);\n      if (!easingFn) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easingFn;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    let amount = handleAmount(pos1);\n    readOpts(pos2);\n    throwNumberTest(amount, ``, `amount`);\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n","import type { ReactiveOrSource, ReactivePingable } from \"../Types.js\";\nimport { interpolate as interpolateFunction, type InterpolateOptions } from \"../../numbers/Interpolate.js\";\nimport { computeWithPrevious } from \"./ComputeWithPrevious.js\";\n\nexport type OpInterpolateOptions = InterpolateOptions & {\n  amount: number\n  /**\n   * Percentage of value that we consider 'done'.\n   * Since interpolation can never converge to target exactly, this allows us to snap to completion.\n   * Default: 0.99, meaning if value gets to within 99%, return the target.\n   */\n  snapAt: number\n}\n\n/**\n * Interpolates to the source value.\n * \n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n * \n * Options can specify an easing name or custom transform of easing progress.\n * @param input \n * @param options \n * @returns \n */\nexport function interpolate(input: ReactiveOrSource<number>, options: Partial<OpInterpolateOptions> = {}): ReactivePingable<number> {\n  const amount = options.amount ?? 0.1;\n  const snapAt = options.snapAt ?? 0.99;\n\n  const i = interpolateFunction(amount, options);\n\n  return computeWithPrevious<number>(input, (previous, target) => {\n    const v = i(previous, target);\n    if (target > previous) {\n      if (v / target >= snapAt) return target;\n    }\n    return v;\n  });\n}\n\n\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n// export function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n//   let previousValue: TIn | undefined;\n//   let target: TIn | undefined;\n//   if (hasLast(input)) {\n//     target = previousValue = input.last();\n//   }\n\n//   const ping = () => {\n//     if (previousValue === undefined && target !== undefined) {\n//       previousValue = target;\n//     } else if (previousValue !== undefined && target !== undefined) {\n//       previousValue = fn(previousValue, target);\n//     }\n//     upstream.set(previousValue!);\n//   }\n\n//   const upstream = initUpstream<TIn, TIn>(input, {\n//     lazy: \"very\",\n//     debugLabel: `computeWithPrevious`,\n//     onValue(value) {\n//       target = value;\n//       ping();\n//     },\n//   })\n//   if (target) ping();\n\n//   return {\n//     ...toReadable(upstream),\n//     ping: () => {\n//       if (target !== undefined) ping()\n//     }\n//   }\n// }","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport * as BasicProcessors from '../../data/BasicProcessors.js';\nimport type { Process } from \"../../data/Process.js\";\nimport type { OpAsAnnotation, OpMathOptions } from \"./Types.js\";\nimport type { RankFunction, RankOptions } from \"../../data/Types.js\";\n\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function max(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, max: number }>;\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, max: number }> {\n  const p = BasicProcessors.max();\n  return process(p, `max`, input, options);\n}\n\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function min(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, min: number }>;\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, min: number }> {\n  const p = BasicProcessors.min();\n  return process(p, `min`, input, options);\n}\n\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function average(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, average: number }>;\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, average: number }> {\n  const p = BasicProcessors.average();\n  return process(p, `average`, input, options);\n}\n\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function sum(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, sum: number }>;\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, sum: number }> {\n  const p = BasicProcessors.sum();\n  return process(p, `sum`, input, options);\n}\n\nexport type TallyOptions = OpMathOptions & {\n  countArrayItems: boolean\n}\n\nexport function tally(input: ReactiveOrSource<any>, options: Partial<TallyOptions>): Reactive<number>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: OpAsAnnotation & Partial<TallyOptions>): Reactive<{ value: TIn, tally: number }>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: Partial<TallyOptions> = {}): Reactive<number> | Reactive<{ value: TIn, tally: number }> {\n  const countArrayItems = options.countArrayItems ?? true;\n  const p = BasicProcessors.tally(countArrayItems);\n  return process(p, `tally`, input, options);\n}\n\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: OpAsAnnotation & Partial<RankOptions & OpMathOptions>): Reactive<{ value: TIn, rank: TIn }>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn> | Reactive<{ value: TIn, rank: TIn }> {\n  const p = BasicProcessors.rank(rank, options);\n  return process(p, `rank`, input, options);\n}\n\nfunction process(processor: Process<any, any>, annotationField: string, input: ReactiveOrSource<any>, options: OpMathOptions = {}) {\n  const annotate = options.annotate;\n  let previous: number | undefined;\n  const skipUndefined = options.skipUndefined ?? true;\n  const skipIdentical = options.skipIdentical ?? true;\n  const upstream = initUpstream<any, any>(input, {\n    ...options,\n    onValue(value) {\n      const x = processor(value);\n      if (x === undefined && skipUndefined) return;\n      if (skipIdentical && x === previous) return;\n      previous = x;\n      if (annotate) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const ret: any = { value };\n        ret[ annotationField ] = x;\n        upstream.set(ret);\n      } else {\n        upstream.set(x);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n//todo testing for annotation and non - annotated\n\n\n// rankArray\n\n// chunk, reduce\n\n// debounce, delay\n\n// duration, take","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { PipeSet, Reactive, Passed } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> => {\n  const event = initStream<TOutput>();\n  const unsubs: Array<() => void> = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (!s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    onValue: event.onValue,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}","import { shuffle } from \"../../data/arrays/Random.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport type { SingleFromArrayOptions } from \"./Types.js\";\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<Array<V>>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: Array<V>) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<Array<V>, V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, ReactiveStream, Reactive } from \"../Types.js\";\nimport type { SplitOptions } from \"./Types.js\";\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource \n * @param options \n * @returns \n */\nexport const split = <T>(rxOrSource: ReactiveOrSource<T>, options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  const outputs: Array<ReactiveStream<T>> = [];\n  const source = resolveSource(rxOrSource);\n  for (let index = 0; index < quantity; index++) {\n    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n  }\n  return outputs;\n}\n\n/**\n * Splits `source` into several duplicated streams. \n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param rxOrSource \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(rxOrSource: ReactiveOrSource<T>, labels: Array<K>): Record<K, Reactive<T>> => {\n  const source = resolveSource(rxOrSource);\n  const t: Partial<Record<K, Reactive<T>>> = {}\n  for (const label of labels) {\n    t[ label ] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n  }\n  return t as Record<K, Reactive<T>>;\n}","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveStream } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./Types.js\";\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options: Partial<SwitcherOptions> = {}): Record<TLabel, Reactive<TValue>> => {\n  // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n  const match = options.match ?? `first`;\n  const source = resolveSource(reactiveOrSource);\n  let disposed = false;\n  // Setup output streams\n  const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n  for (const label of Object.keys(cases)) {\n    (t as any)[ label ] = initStream<TValue>();\n  }\n\n  const performDispose = () => {\n    if (disposed) return;\n    unsub();\n    disposed = true;\n    for (const stream of Object.values(t)) {\n      (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n    }\n  }\n\n  // Listen to source\n  const unsub = source.on(message => {\n    // Got a value\n    if (messageHasValue(message)) {\n      for (const [ lbl, pred ] of Object.entries(cases)) {\n        if (pred(message.value)) {\n          ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n          if (match === `first`) break;\n        }\n      }\n    } else if (messageIsDoneSignal(message)) {\n      performDispose();\n    }\n  })\n  return t as Record<TLabel, Reactive<TValue>>;\n  // }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsSignal } from \"../Util.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypes<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const maximumWait = intervalToMs(options.maximumWait, 2000);\n\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  type State<V> = {\n    done: boolean,\n    finalData: V | undefined,\n    source: Reactive<V>\n    unsub: () => void\n  }\n\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  //const finalData: Array<RxValueTypes<T> | undefined> = [];\n\n  // Resolve sources\n  //const sources = reactiveSources.map(source => resolveSource(source));\n  //const noop = () => {/*no-op*/ }\n  //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n\n  const states: Array<State<any>> = reactiveSources.map(source => ({\n    finalData: undefined,\n    done: false,\n    source: resolveSource(source),\n    unsub: () => {/**no-op */ }\n  }));\n\n\n  const unsubscribe = () => {\n    for (const s of states) {\n      s.unsub();\n      s.unsub = () => {/**no-op */ }\n    }\n  }\n\n  const isDataSetComplete = () => {\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < data.length; index++) {\n      if (onSourceDone === `allow` && states[ index ].done) continue;\n      if (data[ index ] === undefined) return false;\n    }\n    return true;\n  }\n\n  const hasIncompleteSource = () => states.some(s => !s.done);\n  const resetDataSet = () => {\n    for (let index = 0; index < data.length; index++) {\n      if (finalValue === `last` && states[ index ].done) continue; // Don't overwrite\n      data[ index ] = undefined;\n    }\n  }\n\n  const onWatchdog = () => {\n    done(`Sync timeout exceeded (${ maximumWait.toString() })`);\n  }\n\n  const done = (reason: string) => {\n    if (watchdog) clearTimeout(watchdog);\n    unsubscribe();\n    event.dispose(reason);\n  }\n\n  const init = () => {\n    watchdog = setTimeout(onWatchdog, maximumWait);\n\n    for (const [ index, state ] of states.entries()) {\n      data[ index ] = undefined; // init array positions to be undefined\n\n      state.unsub = state.source.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            state.finalData = data[ index ];\n            state.unsub();\n            state.done = true;\n            state.unsub = () => { /** no-op */ }\n            if (finalValue === `undefined`) data[ index ] = undefined;\n            if (onSourceDone === `break`) {\n              done(`Source '${ index.toString() }' done, and onSourceDone:'break' is set`);\n              return;\n            }\n            if (!hasIncompleteSource()) {\n              done(`All sources done`);\n              return;\n            }\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (isDataSetComplete()) {\n          // All array elements contain values\n          // Emit data and reset\n          event.set([ ...data ] as RxValueTypes<T>);\n          resetDataSet();\n          if (watchdog) clearTimeout(watchdog);\n          watchdog = setTimeout(onWatchdog, maximumWait);\n        }\n      });\n    }\n  }\n\n  const event = initStream<RxValueTypes<T>>({\n    onFirstSubscribe() {\n      unsubscribe();\n      init();\n    },\n    onNoSubscribers() {\n      if (watchdog) clearTimeout(watchdog);\n      unsubscribe();\n\n    },\n  });\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n\n}\n","import { zipKeyValue } from \"../../data/maps/MapFns.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../Types.js\";\nimport { syncToArray } from \"./SyncToArray.js\";\nimport { transform } from \"./Transform.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\nexport function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypeObject<T>> {\n  const keys = Object.keys(reactiveSources)\n  const values = Object.values(reactiveSources);\n\n  const s = syncToArray(values, options);\n  const st = transform(s, (streamValues) => {\n    return zipKeyValue(keys, streamValues);\n  });\n  return st as Reactive<RxValueTypeObject<T>>;\n}","import * as Process from \"../../data/Process.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveWritable, ReactiveOp } from \"../Types.js\";\n\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns \n */\nexport function tapProcess<In, T2, T3, T4, T5, T6>(input: ReactiveOrSource<In>, ...processors: Process.Processors<In, T2, T3, T4, T5, T6>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  // @ts-expect-error\n  const chain = Process.flow(...processors);\n  inputStream.onValue(value => {\n    chain(value);\n  });\n  return inputStream;\n}\n\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to \n * @returns \n */\nexport function tapStream<In>(input: ReactiveOrSource<In>, diverged: ReactiveWritable<In>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  inputStream.onValue(value => {\n    diverged.set(value);\n  });\n  return inputStream;\n}\n\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns \n */\nexport const tapOps = <TIn, TOut>(input: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>): Reactive<TOut> => {\n  for (const op of ops) {\n    // @ts-expect-error\n    input = op(input);\n  }\n  return input as any as Reactive<TOut>;\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ThrottleOptions } from \"./Types.js\";\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { isTrigger, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutValueOptions } from \"../sources/Types.js\";\n\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n * \n * If `source` emits faster than the `interval`, it won't get triggered.\n * \n * Default for 'timeout': 1000s.\n * \n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n * \n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n * \n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source \n * @param options \n */\nexport function timeoutValue<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutValueOptions<TTriggerValue>): Reactive<TSource | TTriggerValue> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const immediate = options.immediate ?? true;\n  const repeat = options.repeat ?? false;\n  const timeoutMs = intervalToMs(options.interval, 1000);\n  if (!isTrigger(options)) {\n    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n  }\n\n  // Send value from trigger\n  const sendFallback = () => {\n    const [ value, done ] = resolveTriggerValue(options);\n    if (done) {\n      events.dispose(`Trigger completed`);\n    } else {\n      if (events.isDisposed()) return;\n      events.set(value);\n      if (repeat) {\n        timer = setTimeout(sendFallback, timeoutMs);\n      }\n    }\n  }\n\n  const events = initUpstream<TSource, TSource | TTriggerValue>(source, {\n    disposeIfSourceDone: true,\n    // Received a value from upstream source\n    onValue(v) {\n      // Reset timeout\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(sendFallback, timeoutMs);\n      // Emit value\n      events.set(v);\n    },\n    onDispose() {\n      if (timer) clearTimeout(timer);\n    },\n  });\n\n  if (immediate && !timer) {\n    timer = setTimeout(sendFallback, timeoutMs);\n  }\n  return events;\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../Types.js\";\nimport { isPingable, isTrigger, messageHasValue, messageIsDoneSignal, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"../sources/Types.js\";\n\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n * \n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n * \n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source \n * @param options \n */\nexport function timeoutPing<TSource>(source: ReactiveOrSource<TSource>, options: TimeoutPingOptions): Reactive<TSource> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const rx = resolveSource(source);\n  const abort = options.abort;\n  const timeoutMs = intervalToMs(options, 1000);\n\n  // Send ping\n  const sendPing = () => {\n    if (abort?.aborted || rx.isDisposed()) {\n      off();\n      return;\n    }\n    if (isPingable(rx)) rx.ping(); // ignore if not pingable\n    timer = setTimeout(sendPing, timeoutMs);\n  }\n\n  const cancel = () => {\n    if (timer) clearTimeout(timer);\n  }\n\n  const off = rx.on(msg => {\n    if (messageHasValue(msg)) {\n      // Reset timeout\n      cancel();\n      timer = setTimeout(sendPing, timeoutMs);\n    } else if (messageIsDoneSignal(msg)) {\n      off();\n      cancel();\n    }\n  });\n\n  timer = setTimeout(sendPing, timeoutMs);\n  return rx;\n}\n","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ValueToPingOptions } from \"../sources/Types.js\";\nimport type { Reactive, ReactiveOrSource, ReactivePingable, Unsubscriber } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../Util.js\";\n\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n * \n * Returns a new stream capturing the output of `target`.\n * \n * It `source` or `target` closes, output stream closes too.\n * \n * @returns \n */\nexport function valueToPing<TSource, TTarget>(source: ReactiveOrSource<TSource>, target: ReactivePingable<TTarget>, options: Partial<ValueToPingOptions<TSource>> = {}): Reactive<TTarget> {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const sourceRx = resolveSource(source);\n  const gate = options.gate ?? ((value: TSource) => true);\n  let upstreamOff: Unsubscriber | undefined;\n  let downstreamOff: Unsubscriber | undefined;\n\n  if (signal) {\n    signal.addEventListener(`abort`, () => {\n      done(`Abort signal ${ signal.reason }`);\n    }, { once: true });\n  }\n\n  const events = initStream<TTarget>({\n    onFirstSubscribe() {\n      if (lazy !== `never` && upstreamOff === undefined) start();\n    },\n    onNoSubscribers() {\n      // Unsubscribe from source if we're very lazy\n      // Stay subscribed if we're only initially lazy or not lazy at all\n      if (lazy === `very` && upstreamOff !== undefined) {\n        upstreamOff();\n        upstreamOff = undefined;\n      }\n    },\n  })\n\n  const start = () => {\n    //console.log(`Rx.valueToPing  start`);\n\n    upstreamOff = sourceRx.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Upstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal);\n      } else if (messageHasValue(message)) {\n        //console.log(`Rx.valueToPing got value: ${ message.value }`);\n        if (gate(message.value)) {\n          target.ping();\n        }\n      }\n    });\n    downstreamOff = target.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Downstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal, message.context);\n      } else if (messageHasValue(message)) {\n        events.set(message.value);\n      }\n    });\n  }\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    if (upstreamOff) upstreamOff();\n    if (downstreamOff) downstreamOff();\n  }\n\n  if (lazy === `never`) start();\n  return events;\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\n\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n * \n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input \n * @param options \n * @returns \n */\nexport function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In> {\n  let lastValue: In | undefined = options.initial;\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      //console.log(`Rx.Ops.WithValue onValue: ${ value }`);\n      lastValue = value;\n      upstream.set(value);\n    },\n  })\n\n  const readable = toReadable(upstream);\n  return {\n    ...readable,\n    last() {\n      return lastValue!;\n    },\n  }\n}","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { QueueMutable } from \"../queue/QueueMutable.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport * as Sync from \"../../iterables/IterableSync.js\"\nimport { Table } from \"../Table.js\"\nimport { throwStringTest } from \"../../util/GuardString.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable.\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n/**\n * Returns _true_ if graph contains `key`.\n * \n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key \n * @returns \n */\nexport function hasKey(graph: DirectedGraph, key: string): boolean {\n  throwGraphTest(graph);\n  return graph.vertices.has(key);\n}\n\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n * \n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph \n * @param key \n * @returns \n */\nexport function get(graph: DirectedGraph, key: string): Vertex | undefined {\n  throwGraphTest(graph);\n  throwStringTest(key, `non-empty`, `key`);\n  return graph.vertices.get(key);\n\n}\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  throwGraphTest(graph);\n\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\nfunction testGraph(g: DirectedGraph, paramName = `graph`) {\n  if (g === undefined) return [ false, `Param '${ paramName }' is undefined. Expected Graph` ];\n  if (g === null) return [ false, `Param '${ paramName }' is null. Expected Graph` ];\n  if (typeof g === `object`) {\n    if (!(`vertices` in g)) return [ false, `Param '${ paramName }.vertices' does not exist. Is it a Graph type?` ]\n  } else {\n    return [ false, `Param '${ paramName } is type '${ typeof g }'. Expected an object Graph` ];\n  }\n  return [ true ];\n}\n\nfunction throwGraphTest(g: DirectedGraph, paramName = `graph`) {\n  const r = testGraph(g, paramName);\n  if (r[ 0 ]) return;\n  throw new Error(r[ 1 ] as string)\n}\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  throwGraphTest(graph);\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  throwGraphTest(graph);\n\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  throwGraphTest(graph);\n\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  throwGraphTest(graph);\n\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  throwGraphTest(graph);\n\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  throwGraphTest(graph);\n\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  throwGraphTest(graph);\n\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  throwGraphTest(graph);\n\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  throwGraphTest(graph);\n\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const result = connectWithEdges(graph, options);\n  return result.graph;\n}\n\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well. \n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connectWithEdges(graph: DirectedGraph, options: ConnectOptions): { graph: DirectedGraph, edges: Edge[] } {\n  throwGraphTest(graph);\n\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  let edges: Edge[] = []\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n\n  if (!bidi) return { graph, edges };\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n  return { graph, edges };\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  throwGraphTest(graph);\n\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  throwGraphTest(graph);\n\n  if (idOrVertex === undefined) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  throwGraphTest(graph);\n\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  throwGraphTest(graph);\n\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  throwGraphTest(graph);\n\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  throwGraphTest(graph);\n\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n * \n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  throwGraphTest(graph);\n\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  throwGraphTest(graph);\n\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  throwGraphTest(graph);\n\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { maxScore as IterablesMax, min as IterablesMin } from \"../../iterables/CompareValues.js\";\nimport type { IPriorityQueueMutable, PriorityItem } from \"./IPriorityQueueMutable.js\";\nimport { QueueMutable } from \"./QueueMutable.js\";\nimport type { QueueOpts } from \"./QueueTypes.js\";\n\n/**\n * Simple priority queue implementation.\n * Higher numbers mean higher priority.\n * \n * ```js\n * const pm = new PriorityMutable();\n * \n * // Add items with a priority (higher numeric value = higher value)\n * pm.enqueueWithPriority(`hello`, 4);\n * pm.enqueueWithPriotity(`there`, 1);\n * \n * ```\n */\nexport class PriorityMutable<V> extends QueueMutable<PriorityItem<V>> implements IPriorityQueueMutable<V> {\n  constructor(opts: QueueOpts<PriorityItem<V>> = {}) {\n    if (opts.eq === undefined) {\n      opts = {\n        ...opts,\n        eq: (a, b) => {\n          return isEqualDefault(a.item, b.item);\n        }\n      }\n    }\n    super(opts);\n  }\n\n  /**\n   * Adds an item with a given priority\n   * @param item Item\n   * @param priority Priority (higher numeric value means higher priority)\n   */\n  enqueueWithPriority(item: V, priority: number) {\n    throwNumberTest(priority, `positive`)\n    super.enqueue({ item, priority });\n  }\n\n  changePriority(item: V, priority: number, addIfMissing = false, eq?: IsEqual<V>) {\n    if (item === undefined) throw new Error(`Item cannot be undefined`);\n    let toDelete: PriorityItem<V> | undefined;\n    for (const d of this.data) {\n      if (eq) {\n        if (eq(d.item, item)) {\n          toDelete = d;\n          break;\n        }\n      } else {\n        if (this.eq(d, { item, priority: 0 })) {\n          toDelete = d;\n          break;\n        }\n      }\n    }\n    if (toDelete === undefined && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${ JSON.stringify(item) }`);\n    if (toDelete !== undefined) {\n      this.removeWhere(item => toDelete === item)\n    }\n    this.enqueueWithPriority(item, priority);\n  }\n\n  dequeueMax(): V | undefined {\n    const m = IterablesMax(this.data, v => v.priority);\n    if (m === undefined) return;\n    this.removeWhere(item => item === m);\n    return m.item;\n  }\n\n  dequeueMin(): V | undefined {\n    const m = IterablesMin(this.data, v => v.priority);\n    if (m === undefined) return;\n    this.removeWhere(item => item === m);\n    return m.item;\n  }\n\n  peekMax(): V | undefined {\n    const m = IterablesMax(this.data, v => v.priority);\n    if (m === undefined) return;\n    return m.item;\n  }\n\n  peekMin(): V | undefined {\n    const m = IterablesMin(this.data, v => v.priority);\n    if (m === undefined) return;\n    return m.item;\n  }\n}\n\n/**\n * Creates a {@link PriorityMutable} queue.\n * \n * Options:\n * * eq: Equality function\n * * capacity: limit on number of items\n * * discardPolicy: what to do if capacity is reached\n * @param opts \n * @returns \n */\nexport function priority<V>(\n  opts: QueueOpts<PriorityItem<V>> = {}\n): IPriorityQueueMutable<V> {\n  return new PriorityMutable(opts);\n}","\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","import * as DiGraph from \"../collections/graphs/DirectedGraph.js\";\nimport { initStream } from \"./InitStream.js\";\nimport type { Reactive } from \"./Types.js\";\nimport { isReactive } from \"./Util.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx \n */\nexport function prepare<V extends Record<string, any>>(_rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Rx.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Rx.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: events.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: events.isDisposed,\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: events.onValue\n  }\n  return returnValue;\n}\n\n","import type { Primitive } from '../PrimitiveTypes.js';\nimport type { Interval } from '../flow/IntervalType.js';\nimport * as Immutable from '../data/Pathed.js';\nimport type { ChunkOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/Types.js';\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './sources/Types.js';\nimport type { SetHtmlOptions } from './sinks/Dom.js';\nimport type { Processors } from '../data/Process.js';\nimport type { TallyOptions } from './ops/Math.js';\nimport type { ChangeRecord } from '../data/Compare.js';\nimport type { RecursivePartial } from 'src/TsUtil.js';\n\n\nexport type CombineLatestOptions = {\n  /**\n   * If _true_, disposes all the merged sources when the merged reactive closes.\n   * Default: _true_.\n   */\n  disposeSources: boolean\n  /**\n   * How to handle when a source ends.\n   * * 'allow': continue combined stream, last value for done stream will kept\n   * * 'break': stop combined stream\n   * \n   * Default: 'break'\n   */\n  onSourceDone: `allow` | `break`\n  /**\n   * If _true_ (default), emits a value when initialised.\n   */\n  emitInitial: boolean\n}\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: SignalKinds\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: Lazy\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n  debugLabel: string\n  onDispose: (reason: string) => void\n}\n\nexport type UpstreamInitialOptions<In> = UpstreamOptions<In> & {\n  initialValue: In\n}\n\n//export type Processor = <TIn, TOptions>(source: ReactiveOrSource<TIn>) => (options: TOptions) => () => void;\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  enacts: {\n    setHtmlText: (options: SetHtmlOptions) => () => void\n  }\n  source: Reactive<TIn>,\n\n  /**\n   * Annotate values with output from the `annotation` function.\n   * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{ value: TIn, annotation: TAnnotation }>\n  annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>) => Wrapped<{ value: TIn, annotation: TOut }>\n  /**\n  * Accumulate a chunk of values, emitted as an array\n  * @param options \n  * @returns \n  */\n  chunk: (options: Partial<ChunkOptions>) => Wrapped<Array<TIn>>\n\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name: string } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  min: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  max: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  average: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  sum: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  tally: (options?: Partial<TallyOptions>) => Wrapped<number>\n\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options?: Partial<SplitOptions>) => Array<Wrapped<TIn>>\n  /**\n * Emits values when this stream and any additional streams produce a value. The resulting stream is\n * thus an array of values, each source at a given index.\n * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n * the slowest stream.\n * @returns \n */\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[ TIn, ...RxValueTypes<T> ]>\n\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: { name?: string } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => Record<K, Wrapped<TIn>>\n  /**\n   * Taps the stream, passing values to one or more 'processor' functions.\n   * This processing essentially happens in parallel, not affecting the main stream.\n   * \n   * ```js\n   * // Stream of pointermove events with {x:0,y:0} as default\n   * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n   * // Wrap it for fluent access\n   * const ptr = Rx.wrap(move)\n   *  .tapProcess(\n   *    // Create a string representation\n   *    v => `${v.x},${v.y}`\n   *    // Set to DOM\n   *    v => {\n   *      document.getElementById(`coords`).innerText = v;\n   *    }\n   *   )\n   *  .onValue(value => {\n   *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n   *    // not affecting stream\n   *  });\n   * ```\n   * @param processors One-five processing functions\n   * @returns \n   */\n  tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>\n  tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>\n  tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => Wrapped<TIn>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  /**\n   * Emits a value if `source` does not emit a value after `interval`\n   * has elapsed. This can be useful to reset a reactive to some\n   * 'zero' state if nothing is going on.\n   * \n   * If `source` emits faster than the `interval`, it won't get triggered.\n   * \n   * Default for 'timeout': 1000s.\n   * \n   * ```js\n   * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n   * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n   * ```\n   * \n   * Can also emit results from a function or generator\n   * ```js\n   * // Emits a random number if 'source' doesn't emit a value after 500ms\n   * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n   * ```\n   * \n   * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n   * Otherwise it won't start until it observes the first value from `source`.\n   * @param options \n   */\n  timeoutValue: <TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>\n  /**\n   * 'Pings' reactive (if it supports it) if a value is not received within a given interval.\n   * Behaviour can be stopped using an abort signal.\n   * @param options \n   * @returns \n   */\n  timeoutPing: (options: TimeoutPingOptions) => Wrapped<TIn>\n\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn>>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn | undefined>>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  onValue: (callback: (value: TIn) => void) => void\n\n}\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n  lazy?: Lazy\n  debugLabel?: string\n  onStart: () => void\n  onStop: () => void\n};\n\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n  initialValue: T\n}\n\nexport type CountOptions = { lazy: Lazy, amount: number, offset: number, interval: Interval, signal: AbortSignal }\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V> | (() => V)\n\nexport type BindUpdateOpts<V> = {\n  initial: (v: V, el: HTMLElement) => void,\n  binds: Record<string, DomBindValueTarget & {\n    transform?: (value: any) => string\n  }>\n}\n\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `onValue` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): Unsubscriber\n  /**\n   * Subscribes to a reactive's values.\n   * Returns a function that unsubscribes.\n   * @param handler\n   */\n  onValue(handler: (value: V) => void): Unsubscriber\n\n  dispose(reason: string): void\n  isDisposed(): boolean\n  set?(value: V): void\n}\n\n/**\n * A reactive that can be 'pinged' to produce a value.\n * \n * Use {@link isPingable} to check if a reactive is pingable.\n * \n * Pingable reactives are returned from\n * * interpolate\n * * computeWithPrevious\n * * valueToPing\n */\nexport type ReactivePingable<V> = Reactive<V> & {\n  ping(): void\n}\n\nexport type Unsubscriber = () => void;\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\nexport type ReactiveWritable<TIn, TOut = TIn> = Reactive<TOut> & {\n  set(value: TIn): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveArray<V> = ReactiveWritable<Array<V>> & {\n  push(value: V): void\n  deleteAt(index: number): void\n  deleteWhere(filter: (value: V) => boolean): number\n  setAt(index: number, value: V): void\n  insertAt(index: number, value: V): void\n  onArray(handler: (changes: Passed<Array<ChangeRecord<number>>>) => void): () => void\n}\nexport type ObjectFieldHandler = { value: any, fieldName: string, pattern: string };\n\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Notifies when the value of `fieldName` is changed.\n   * \n   * Use the returned function to unsubscribe.\n   * @param fieldName \n   * @param handler \n   */\n  onField(fieldName: string, handler: (result: ObjectFieldHandler) => void): () => void\n  /**\n   * Notifies of which field(s) were changed.\n   * If you just care about the whole, changed data use the `value` event.\n   * \n   * Use the returned function to unsubscribe.\n   * @param changes \n   */\n  onDiff(changes: (changes: Array<Immutable.PathDataChange<any>>) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   * @returns Returns new value\n   */\n  update(changedPart: RecursivePartial<V>): V\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n  //through_(message: Passed<V>): void\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  removeAllSubscribers(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\nexport type ReactiveInitialStream<V> = ReactiveStream<V> & ReactiveInitial<V>;\n\nexport type DomBindValueTarget = {\n  /**\n   * If _true_ `innerHTML` is set (a shortcut for elField:`innerHTML`)\n   */\n  htmlContent?: boolean\n  /**\n   * If _true_, 'textContent' is set (a shortcut for elField:'textContext')\n   */\n  textContent?: boolean\n  /**\n   * If set, this DOM element field is set. Eg 'textContent'\n   */\n  elField?: string\n  /**\n   * If set, this DOM attribute is set, Eg 'width'\n   */\n  attribName?: string\n  /**\n   * If set, this CSS variable is set, Eg 'hue' (sets '--hue')\n   */\n  cssVariable?: string\n  /**\n   * If set, this CSS property is set, Eg 'background-color'\n   */\n  cssProperty?: string\n}\n\nexport type ElementBind = {\n  /**\n   * Tag name for this binding.\n   * Overrides `defaultTag`\n   */\n  tagName?: string\n  /**\n   * If _true_, sub-paths are appended to element, rather than `container`\n   */\n  nestChildren?: boolean\n  transform?: (value: any) => string\n}\nexport type ElementsOptions = {\n  container: HTMLElement | string\n  defaultTag: string,\n  binds: Record<string, DomBindValueTarget & ElementBind>\n}\n\nexport type DomBindTargetNode = {\n  query?: string\n  element?: HTMLElement\n}\n\nexport type DomBindTargetNodeResolved = {\n  element: HTMLElement\n}\n\nexport type DomBindUnresolvedSource<TSource, TDestination> = DomBindTargetNode & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\nexport type DomBindResolvedSource<TSource, TDestination> = DomBindTargetNodeResolved & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\n\nexport type DomBindSourceValue<TSource, TDestination> = {\n  twoway?: boolean\n  /**\n   * Field from source value to pluck and use.\n   * This will also be the value passed to the transform\n   */\n  sourceField?: keyof TSource\n  transform?: (input: TSource) => TDestination\n  transformValue?: (input: any) => TDestination\n}\n\nexport type DomBindInputOptions<TSource, TDestination> = DomBindSourceValue<TSource, TDestination> & {\n  transformFromInput: (input: TDestination) => TSource\n}\n\n// export type PipeSet<In, Out> = [\n//   Reactive<In>,\n//   ...Array<Reactive<any> & ReactiveWritable<any>>,\n//   ReactiveWritable<Out> & Reactive<any>\n// ]\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...Array<Reactive<any> & ReactiveWritable<any>>\n]\n\nexport type InitStreamOptions = {\n  /**\n   * Optional label to associate with this stream. Useful for debugging.\n   */\n  debugLabel: string\n  /**\n   * Called when there is a subscriber after there were no subscribers.\n   * Useful for 'startup' types of things that we want to run only when someone is actually listening.\n   * \n   * During the lifeycle of a stream, this could be called multiple times. Eg if all subscribers are removed\n   * next time someone subscribes it will get called again.\n   * @returns \n   */\n  onFirstSubscribe: () => void\n  /**\n   * Called when there are no longer any subscribers. Useful for shutting down\n   * activities now that no-one is listening.\n   * \n   * During the lifecycle of a stream, this could be called multiple times.\n   * @returns\n   */\n  onNoSubscribers: () => void\n  /**\n   * Called whenever the stream disposes. Useful for cleaning up.\n   * @param reason \n   * @returns \n   */\n  onDispose: (reason: string) => void\n}\n\n\nexport type DomCreateOptions = {\n  tagName: string\n  parentEl: string | HTMLElement\n}\n\nexport type PipeDomBinding = {\n  /**\n   * Remove binding and optionally delete element(s) (false by default)\n   */\n  remove(deleteElements: boolean): void\n}\n\n\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n  /**\n   * Initial value\n   */\n  initial: V,\n  /**\n   * Laziness\n   */\n  lazy?: Lazy\n}\n\n\n\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n\n  lazy: Lazy\n}\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...Array<ReactiveOp<any, any>>,\n  ReactiveOp<any, Out>\n]\n\nexport type RxValueTypes<T extends ReadonlyArray<ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V :\n    T[ K ] extends Wrapped<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V :\n    never };\n\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? Reactive<V> :\n    T[ K ] extends Wrapped<infer V> ? Reactive<V> :\n    T[ K ] extends Generator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncGenerator<infer V> ? Reactive<V> :\n    T[ K ] extends IterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncIterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends Array<infer V> ? Reactive<V> :\n    never };\n\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    never };\n\n\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport type { ReactiveOrSource, ToArrayOptions } from \"./Types.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V | undefined>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: Array<V | undefined> = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<Array<V | undefined>>((resolve, reject) => {\n    const done = () => {\n      clearTimeout(maxWait);\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) {\n            //console.log(`Rx.toArray filling at index: ${ index }`);\n            read[ index ] = options.fillValue;\n          }\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as Array<V>;\n\n}","import { resolveSource } from \"./ResolveSource.js\";\nimport type { ReactiveOrSource } from \"./Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n","import * as Ops from \"./ops/index.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { toArray, toArrayOrThrow } from \"./ToArray.js\";\nimport type { ReactiveOrSource, Wrapped, ToArrayOptions, InitStreamOptions, Reactive, RxValueTypes, CombineLatestOptions, ReactiveOp, } from \"./Types.js\";\nimport type { ChunkOptions, FieldOptions, FilterPredicate, DebounceOptions, SwitcherOptions, SplitOptions, ThrottleOptions, TransformOpts, SyncOptions, } from './ops/Types.js'\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './sources/Types.js'\nimport { messageHasValue } from \"./Util.js\";\nimport { mapObjectShallow } from '../data/MapObject.js';\nimport * as Enacts from './sinks/index.js';\nimport type { Processors } from \"../data/Process.js\";\n\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n * \n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    enacts: {\n      setHtmlText: (options) => {\n        return Enacts.setHtmlText(source, options);\n      },\n    },\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation): Wrapped<{ value: TIn, annotation: TAnnotation }> => {\n      const a = Ops.annotate<TIn, TAnnotation>(source, transformer);\n      return wrap(a);\n    },\n    annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>): Wrapped<{ value: TIn, annotation: TOut }> => {\n      const a = Ops.annotateWithOp<TIn, TOut>(source, op);\n      return wrap(a);\n    },\n\n    chunk: (options: Partial<ChunkOptions>): Wrapped<Array<TIn>> => {\n      const w = wrap<Array<TIn>>(Ops.chunk(source, options));\n      return w;\n    },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(Ops.debounce<TIn>(source, options));\n    },\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>> = {}) => {\n      // Ops.field requires TIn extends object\n      // Would be good if `wrap` returns different versions depending on TIn, so .field\n      // would not be present at all if we had Reactive<number>, for example\n      // @ts-expect-error\n      const f = Ops.field<TIn, TFieldType>(source, fieldName, options);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(Ops.filter(source, predicate, options));\n    },\n    combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}) => {\n      const srcs = [ source, ...sources ] as any as T;\n      return wrap(Ops.combineLatestToArray(srcs, options));\n    },\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<CombineLatestOptions>) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.combineLatestToObject(o, options));\n    },\n    min: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.min(source, options));\n    },\n    max: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.max(source, options));\n    },\n    average: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.average(source, options));\n    },\n    sum: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.sum(source, options));\n    },\n    tally: (options: Partial<Ops.TallyOptions> = {}) => {\n      return wrap(Ops.tally(source, options));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = Ops.split<TIn>(source, options).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => {\n      const l = Ops.splitLabelled<TIn, keyof TIn>(source, labels);\n      const m = mapObjectShallow<typeof l, Wrapped<TIn>>(l, args => wrap(args.value as Reactive<TIn>)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = Ops.switcher<TIn, TRec, TLabel>(source, cases, options);\n      const m = mapObjectShallow<typeof s, Wrapped<TIn>>(s, args => wrap(args.value as Reactive<TIn>));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(additionalSources: T, options: Partial<SyncOptions> = {}) => {\n      const unwrapped = [ source, ...additionalSources ].map(v => resolveSource(v));\n      const x = Ops.syncToArray(unwrapped, options) as Reactive<[ TIn, ...RxValueTypes<T> ]>;\n      return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n    },\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<SyncOptions> = {}) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.syncToObject(o, options));\n    },\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => {\n      Ops.tapProcess(source, ...processors)\n      return wrap(source);\n    },\n    tapStream: (divergedStream) => {\n      Ops.tapStream(source, divergedStream);\n      return wrap(source);\n    },\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => {\n      Ops.tapOps(source, ...ops);\n      return wrap(source);\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(Ops.throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(Ops.transform(source, transformer, options));\n    },\n    timeoutValue: <TTrigger>(options: TimeoutValueOptions<TTrigger>) => {\n      return wrap(Ops.timeoutValue<TIn, TTrigger>(source, options));\n    },\n    timeoutPing: (options: TimeoutPingOptions) => {\n      return wrap(Ops.timeoutPing(source, options));\n    },\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    onValue: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    }\n  }\n}\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport { continuously } from \"../flow/Continuously.js\";\nimport type { CountOptions } from \"./Types.js\";\nimport { initLazyStream } from \"./InitStream.js\";\n\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n * \n * ```js\n * const r = Rx.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n * \n * The `limit` is exclusive\n * ```js\n * const r = Rx.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n * \n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n * \n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.count({ start: 10, amount: 2, interval: 500 });\n * ```\n * \n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options \n */\nexport function count(options: Partial<CountOptions> = {}) {\n\n  const lazy = options.lazy ?? `initial`;\n  const interval = intervalToMs(options.interval, 1000);\n  const amount = options.amount ?? 1;\n  const offset = options.offset ?? 0;\n\n  let produced = 0;\n  let value = offset;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n  }\n\n  const timer = continuously(() => {\n    if (options.signal?.aborted) {\n      done(`Aborted (${ options.signal.reason })`);\n      return false;\n    }\n    events.set(value);\n    value += 1;\n    produced++;\n    if (produced >= amount) {\n      done(`Limit reached`);\n      return false;\n    }\n  }, interval);\n\n  const events = initLazyStream<number>({\n    onStart() {\n      timer.start();\n    },\n    onStop() {\n      timer.cancel();\n    },\n    onDispose() {\n      timer.cancel();\n    },\n    lazy\n  });\n  return events;\n}\n","import * as Immutable from \"../data/Pathed.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport * as Rx from \"./index.js\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind } from './Types.js';\nimport { hasLast, messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { getFromKeys } from \"../data/maps/MapFns.js\";\nimport { afterMatch, beforeMatch } from \"../Text.js\";\nimport { stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"../text/Segments.js\";\nimport { QueueMutable } from \"../collections/queue/QueueMutable.js\";\nimport { object } from \"./sources/Object.js\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as Array<HTMLElement>;\n\n  return object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.s\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\nexport const bindValueText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n}\n\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\nconst setupInput = <TSource, TDestination>(b: PipeDomBinding, input: Rx.Reactive<TDestination>, source: Rx.Reactive<TSource>, twoway: boolean, transformFromInput: (value: TDestination) => TSource) => {\n  input.onValue(value => {\n    const v = transformFromInput(value);\n    if (twoway && Rx.isWritable(source)) {\n      source.set(v);\n    }\n  });\n  const dispose = () => {\n    input.dispose(`bindInput twoway dispose`);\n    b.remove(false);\n  }\n  return { ...b, dispose, input };\n}\n\nconst validateElement = (elOrQuery: string | HTMLInputElement | null, type?: string): HTMLInputElement => {\n  const el = resolveEl(elOrQuery);\n  if (el.nodeName !== `INPUT`) throw new Error(`HTML INPUT element expected. Got: ${ el.nodeName }`);\n  if (type !== undefined && el.type !== type) throw new Error(`HTML INPUT element expected with type 'range'. Got: ${ el.type }`);\n  return el;\n}\n\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<TSource, string> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery Element to update to, or query string such as '#someid'\n * @param source Source of data\n * @param binds Bindings\n */\nexport const bindElement = <TSource, TDestination>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, ...binds: Array<DomBindSourceValue<TSource, TDestination> & Rx.DomBindValueTarget>): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<TSource, TDestination>;\n    return { ...bind, element: el } as DomBindResolvedSource<TSource, TDestination>\n  });\n  return bind<TSource, TDestination>(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <TSource, TDestination>(bind: DomBindSourceValue<TSource, TDestination>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: TSource) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: TSource) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <TSource, TDestination>(source: Rx.Reactive<TSource>, ...bindsUnresolvedElements: Array<Rx.DomBindUnresolvedSource<TSource, TDestination>>): PipeDomBinding => {\n  const binds: Array<DomBindResolvedSource<TSource, TDestination>> = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<TSource, TDestination>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: TSource) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      update(message.value);\n    } else if (messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Array<Immutable.PathDataChange<any>>, el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  //const binds = opts.binds;\n  const update = (value: Array<Immutable.PathDataChange<any>>) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(value => {\n    update(value);\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = getFromKeys(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: Array<Immutable.PathDataChange<any> | Immutable.PathData<any>>) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (!(`previous` in d) || d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = [ ...Immutable.getPathsAndData(d.value, false, Number.MAX_SAFE_INTEGER, path) ];\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(value => {\n    //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n    changes(value);\n  });\n\n  // Source has an initial value, use that\n  if (hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes([ ...Immutable.getPathsAndData(last as object, false, 1) ]);\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = Rx.From.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = Rx.From.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n","export * from './Array.js';\nexport * from './ArrayObject.js';\nexport * from './Boolean.js';\nexport * from './Colour.js';\nexport * from './Derived.js';\nexport * from './Dom.js';\nexport * from './Event.js';\nexport * from './Function.js';\nexport * from './Iterator.js';\nexport * from './Merged.js';\nexport * from './Number.js';\nexport * from './Object.js';\nexport * from './ObjectProxy.js';\nexport * from './Observable.js';\nexport * from './String.js';\nexport * from './Types.js';","\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveFinite, ReactiveInitial } from \"../Types.js\";\nimport type { ArrayOptions } from \"./Types.js\";\n\nexport const of = <V>(source: Array<V> | Iterable<V>, options: Partial<ArrayOptions> = {}) => {\n  if (Array.isArray(source)) {\n    return array(source, options);\n  } else {}\n}\n\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n * \n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n * \n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n * \n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray \n * @param options \n * @returns \n */\nexport const array = <V>(sourceArray: Array<V>, options: Partial<ArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const whenStopped = options.whenStopped ?? `continue`;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const array = [ ...sourceArray ];\n\n  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${ lazy }'. Use lazy:'very' instead.`);\n\n  const intervalMs = intervalToMs(options.interval, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);\n      c.start();\n    },\n    onStop() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${ whenStopped } index: ${ index }`);\n\n      c.cancel();\n      if (whenStopped === `reset`) index = 0;\n    },\n    // onFirstSubscribe() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n    //   // Start if in lazy mode and not running\n    //   if (lazy !== `never` && c.runState === `idle`) c.start();\n    // },\n    // onNoSubscribers() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n    //   if (lazy === `very`) {\n    //     c.cancel();\n    //     if (whenStopped === `reset`) {\n    //       index = 0;\n    //     }\n    //   }\n    // }\n  });\n\n  const c = continuously(() => {\n    if (signal?.aborted) {\n      s.dispose(`Signalled (${ signal.reason })`);\n      return false; // stop looping\n    }\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      s.dispose(`Source array complete`);\n      return false; // stop loop\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: s.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: s.isDisposed,\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: s.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: s.onValue\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveInitial, ReactiveNonInitial, ReactiveArray, Reactive } from \"../Types.js\";\nimport type { ArrayObjectOptions } from \"./Types.js\";\nimport { compareArrays, type ChangeRecord } from \"../../data/Compare.js\";\nimport { remove as ArraysRemove } from '../../data/arrays/Remove.js';\nimport { insertAt as ArraysInsertAt } from \"../../data/arrays/InsertAt.js\";\n/**\n * Wraps an array object.\n * \n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue \n * @param options \n * @returns \n */\nexport function arrayObject<V>(initialValue: ReadonlyArray<V> = [], options: Partial<ArrayObjectOptions<V>> = {}): ReactiveArray<V> & ReactiveInitial<ReadonlyArray<V>> {\n  const eq = options.eq ?? isEqualValueDefault;\n  const setEvent = initStream<Array<V>>();\n  //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n  const arrayEvent = initStream<Array<ChangeRecord<number>>>();\n  let value: ReadonlyArray<V> = initialValue;\n  let disposed = false;\n\n  const set = (replacement: Array<V> | ReadonlyArray<V>) => {\n    const diff = compareArrays<V>(value as Array<V>, replacement as Array<V>, eq);\n    //console.log(`Rx.fromArray.set diff`, diff);\n    //if (diff.length === 0) return;\n    //diffEvent.set(diff);\n    value = replacement;\n    setEvent.set([ ...replacement ]);\n  }\n\n  const setAt = (index: number, v: V) => {\n    (value as Array<V>)[ index ] = v;\n    setEvent.set([ ...value ]);\n  }\n\n  const push = (v: V) => {\n    value = [ ...value, v ];\n    setEvent.set([ ...value ]);\n    const cr: ChangeRecord<number> = [ `add`, value.length - 1, v ];\n    arrayEvent.set([ cr ]);\n  }\n\n  const deleteAt = (index: number) => {\n    const valueChanged = ArraysRemove(value, index);\n    if (valueChanged.length === value.length) return; // no change\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    //console.log(diff.summary);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  const deleteWhere = (filter: (value: V) => boolean) => {\n    const valueChanged = value.filter(v => !filter(v));\n    const count = value.length - valueChanged.length;\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n    return count;\n  }\n\n  const insertAt = (index: number, v: V) => {\n    const valueChanged = ArraysInsertAt(value, index, v);\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  // const update = (toMerge: Partial<V>) => {\n  //   // eslint-disable-next-line unicorn/prefer-ternary\n  //   if (value === undefined) {\n  //     value = toMerge as V;\n  //   } else {\n  //     const diff = Immutable.compareData(toMerge, value);\n  //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n  //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n  //     if (diff.length === 0) return; // No changes\n  //     value = {\n  //       ...value,\n  //       ...toMerge\n  //     }\n  //     diffEvent.set(diff);\n  //   }\n  //   setEvent.set(value);\n  // }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    //diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  const r = {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    last: () => value,\n    on: setEvent.on,\n    onArray: arrayEvent.on,\n    onValue: setEvent.onValue,\n    setAt,\n    push,\n    deleteAt,\n    deleteWhere,\n    insertAt,\n    /**\n     * Set the whole object\n     */\n    set\n  }\n  return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function boolean(initialValue: boolean): ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport function boolean(): ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\nexport function boolean(initialValue?: boolean): ReactiveWritable<boolean> & (ReactiveNonInitial<boolean> | ReactiveInitial<boolean>) {\n  let value = initialValue;\n  const events = initStream<boolean>();\n\n  const set = (v: boolean) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type Color from \"colorjs.io\";\nimport * as Colour from '../../visual/Colour.js';\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport type ReactiveColour = ReactiveWritable<Color> & {\n  setHsl: (hsl: Colour.Hsl) => void;\n}\n\nexport function colour(initialValue: Color): ReactiveColour & ReactiveInitial<Color>;\nexport function colour(): ReactiveColour & ReactiveNonInitial<Color>;\nexport function colour(initialValue?: Color): ReactiveColour & (ReactiveNonInitial<Color> | ReactiveInitial<Color>) {\n  let value = initialValue;\n  const events = initStream<Color>();\n\n  const set = (v: Color) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set,\n    setHsl: (hsl: Colour.Hsl) => {\n      set(Colour.resolve(hsl))\n    }\n  }\n}\n","import { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { cache } from \"../Cache.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport { type CombineLatestToObject, combineLatestToObject } from \"../ops/CombineLatestToObject.js\";\nimport type { ReactiveNonInitial, ReactiveOrSource, RxValueTypeObject } from \"../Types.js\";\nimport type { DerivedOptions } from \"./Types.js\";\n\nexport function derived<TResult, const T extends Record<string, ReactiveOrSource<any>>>(fn: (combined: RxValueTypeObject<T>) => TResult | undefined, reactiveSources: T, options: Partial<DerivedOptions<TResult, CombineLatestToObject<T>>> = {}): ReactiveNonInitial<TResult> {\n  const ignoreIdentical = options.ignoreIdentical ?? true;\n  const eq = options.eq ?? isEqualValueDefault<TResult>;\n\n  const sources = combineLatestToObject(reactiveSources);\n\n  const handle = (v: RxValueTypeObject<T>) => {\n    const last = output.last();\n    const vv = fn(v);\n    if (vv !== undefined) {\n      if (ignoreIdentical && last !== undefined) {\n        if (eq(vv, last)) return vv;\n      }\n      output.set(vv);\n    }\n\n    return vv;\n  }\n\n  // When the combined stream emits a value, output it\n  const s = initUpstream<RxValueTypeObject<T>, TResult>(sources, {\n    ...options,\n    onValue(v) {\n      handle(v);\n    },\n  });\n  const output = cache(s, fn(sources.last()));\n  return output;\n}\n\n","import type { Passed, Reactive, ReactiveInitial } from \"../Types.js\";\nimport { field } from \"../ops/Field.js\";\nimport { object } from \"./Object.js\";\nimport type { FieldOptions } from \"../ops/Types.js\";\nimport type { EventOptions, EventTriggerOptions } from \"./Types.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { Elapsed } from \"../../flow/index.js\";\n/**\n * Fired when `eventName` fires on `target`. \n * \n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n * \n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId') \n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options: Partial<EventOptions & FieldOptions<any, TFieldValue>> = {}) {\n\n  const initial: Record<string, any> = {};\n  initial[ fieldName ] = initialValue;\n\n  const rxField = field<any, TFieldValue>(\n    event(targetOrQuery, eventName, initial, options),\n    fieldName,\n    options\n  );\n  return rxField;\n}\n\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options: Partial<EventOptions> = {}): ReactiveInitial<TEventArgs> & Reactive<TEventArgs> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const lazy = options.lazy ?? false;\n  if (initialValue === undefined) initialValue = {} as TEventArgs;\n  const rxObject = object<TEventArgs>(initialValue, { deepEntries: true });\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(args as TEventArgs);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<TEventArgs>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    onValue: (handler: (v: TEventArgs) => void) => {\n      if (lazy) add();\n      return rxObject.onValue(handler);\n    }\n  }\n}\n\nexport type TriggerData = {\n  sinceLast: number\n  total: number\n}\n\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of \n * times event has been fired.\n * @param targetOrQuery \n * @param name \n * @param options \n * @returns \n */\nexport function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options: Partial<EventTriggerOptions> = {}): Reactive<TriggerData> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const fireInitial = options.fireInitial ?? false;\n\n  let count = 0;\n  const elapsed = Elapsed.interval();\n\n  const stream = initLazyStream<TriggerData>({\n    lazy: options.lazy ?? `very`,\n    onStart() {\n      target.addEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger add '${ name }'`);\n      }\n      if (fireInitial && count === 0) {\n        if (debugLifecycle || debugFiring) console.log(`Rx.From.eventTrigger: firing initial`);\n        callback();\n      }\n    },\n    onStop() {\n      target.removeEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger remove '${ name }'`);\n      }\n    },\n  });\n\n  const callback = (_args?: any) => {\n    if (debugFiring) console.log(`Rx.From.eventTrigger '${ name }' triggered'`)\n    stream.set({\n      sinceLast: elapsed(),\n      total: ++count\n    });\n  }\n\n  return stream;\n}","import * as Colour from '../../visual/Colour.js';\nimport type { ReactiveInitial, ReactiveWritable, Reactive } from \"../Types.js\";\nimport { eventTrigger } from \"./Event.js\";\nimport type { DomFormOptions, DomNumberInputValueOptions, DomValueOptions } from \"./Types.js\";\nimport { resolveEl } from '../../dom/ResolveEl.js';\nimport { transform } from '../ops/Transform.js';\nimport { hasLast } from '../Util.js';\n\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n * \n * Options:\n * - relative: if _true_, values are 0..1 (default: false)\n * - inverted: if _true_, values are 1..0 (default: false)\n * \n * If element is missing a 'type' attribute, this will be set to 'range'.\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domNumberInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomNumberInputValueOptions> = {}): ReactiveInitial<number> & ReactiveWritable<number> {\n  const input = domInputValue(targetOrQuery, options);\n  const el = input.el;\n  const relative = options.relative ?? false;\n  const inverted = options.inverted ?? false;\n\n  const rx = transform(input, v => {\n    return Number.parseFloat(v);\n  });\n\n  if (relative) {\n    //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n    el.max = inverted ? \"0\" : \"1\";\n    //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n    el.min = inverted ? \"1\" : \"0\";\n    if (!el.hasAttribute(`step`)) {\n      //el.setAttribute(`step`, \"0.1\");\n      el.step = \"0.1\";\n    }\n  }\n  if (el.getAttribute(`type`) === null) {\n    el.type = `range`;\n  }\n\n  const set = (value: number) => {\n    input.set(value.toString());\n  }\n\n  return {\n    ...rx,\n    last() {\n      //console.log(`domNumberInputValue last: ${ input.last() }`);\n      return Number.parseFloat(input.last())\n    },\n    set\n  };\n}\n\nexport function domHslInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): ReactiveInitial<Colour.Hsl> & Reactive<Colour.Hsl> & ReactiveWritable<Colour.Hsl> {\n\n  const input = domInputValue(targetOrQuery, {\n    ...options,\n    upstreamFilter(value) {\n      return (typeof value === `object`) ? Colour.toHex(value) : value;\n    },\n  });\n  const rx = transform(input, v => {\n    return Colour.toHsl(v, true);\n  });\n  return {\n    ...rx,\n    last() {\n      return Colour.toHsl(input.last(), true)\n    },\n    set(value) {\n      input.set(Colour.toHex(value));\n    },\n  };\n}\n\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n * \n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): { el: HTMLInputElement } & ReactiveInitial<string> & ReactiveWritable<string> {\n  const target: HTMLInputElement | null = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${ targetOrQuery }'`);\n  if (target === null) throw new Error(`targetOrQuery is null`)\n\n  const el = resolveEl(targetOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const fallbackValue = options.fallbackValue ?? ``;\n  const upstreamSource = options.upstreamSource;\n  let upstreamSourceUnsub = () => {}\n\n  let attribName = options.attributeName;\n  let fieldName = options.fieldName;\n\n  if (fieldName === undefined && attribName === undefined) {\n    attribName = fieldName = `value`;\n  }\n\n  const readValue = () => {\n    let value: string | null | undefined;\n    if (attribName) {\n      value = el.getAttribute(attribName);\n      //console.log(`  attrib: ${ attribName } value: ${ value }`);\n    }\n    if (fieldName) {\n      value = (el as any)[ fieldName ]\n    }\n    if (value === undefined || value === null) value = fallbackValue;\n    //console.log(`domInputValue readValue: ${ value }. attrib: ${ attribName } field: ${ fieldName }`);\n    return value;\n  }\n\n  const setValue = (value: string) => {\n    if (attribName) {\n      el.setAttribute(attribName, value);\n    }\n    if (fieldName) {\n      (el as any)[ fieldName ] = value;\n    }\n  }\n\n  const setUpstream = (v: any) => {\n    v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n    setValue(v);\n  }\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n    if (hasLast(upstreamSource)) {\n      setUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(el, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el,\n    last() {\n      return readValue()\n    },\n    set(value) {\n      setValue(value);\n    },\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}\n\n/**\n * Listens for data changes from elements within a HTML form element.\n * Input elements must have a 'name' attribute.\n * \n * Simple usage:\n * ```js\n * const rx = Rx.From.domForm(`#my-form`);\n * rx.onValue(value => {\n *  // Object containing values from form\n * });\n * \n * rx.last(); // Read current values of form\n * ```\n * \n * UI can be updated\n * ```js\n * // Set using an object of key-value pairs\n * rx.set({\n *  size: 'large'\n * });\n * \n * // Or set a single name-value pair\n * rx.setNamedValue(`size`, `large`);\n * ```\n * \n * If an 'upstream' reactive is provided, this is used to set initial values of the UI, overriding\n * whatever may be in the HTML. Upstream changes modify UI elements, but UI changes do not modify the upstream\n * source.\n * \n * ```js\n * // Create a reactive object\n * const obj = Rx.From.object({\n *  when: `2024-10-03`,\n *  size: 12,\n *  checked: true\n * });\n * \n * // Use this as initial values for a HTML form\n * // (assuming appropriate INPUT/SELECT elements exist)\n * const rx = Rx.From.domForm(`form`, { \n *  upstreamSource: obj\n * });\n * \n * // Listen for changes in the UI\n * rx.onValue(value => {\n *  \n * });\n * ```\n * @param formElOrQuery \n * @param options \n * @returns \n */\nexport function domForm<T extends Record<string, any>>(formElOrQuery: HTMLFormElement | string, options: Partial<DomFormOptions<T>> = {}): {\n  setNamedValue: (name: string, value: any) => void,\n  el: HTMLFormElement\n} & ReactiveInitial<T> & ReactiveWritable<T> {\n  const formEl = resolveEl<HTMLFormElement>(formElOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const upstreamSource = options.upstreamSource;\n\n  const typeHints = new Map<string, string>();\n\n  let upstreamSourceUnsub = () => {}\n\n  const readValue = () => {\n    const fd = new FormData(formEl);\n    const entries = [];\n    for (const [ k, v ] of fd.entries()) {\n      const vStr = v.toString();\n\n      // Get type hint for key\n      let typeHint = typeHints.get(k);\n      if (!typeHint) {\n        // If not found, use the kind of input element as a hint\n        const el = getFormElement(k, vStr);\n        if (el) {\n          if (el.type === `range` || el.type === `number`) {\n            typeHint = `number`;\n          } else if (el.type === `color`) {\n            typeHint = `colour`;\n          } else if (el.type === `checkbox` && (v === `true` || v === `on`)) {\n            typeHint = `boolean`;\n          } else {\n            typeHint = `string`;\n          }\n          typeHints.set(k, typeHint);\n        }\n      }\n\n      if (typeHint === `number`) {\n        entries.push([ k, Number.parseFloat(vStr) ]);\n      } else if (typeHint === `boolean`) {\n        const vBool = (vStr === `true`) ? true : false;\n        entries.push([ k, vBool ]);\n      } else if (typeHint === `colour`) {\n        const vRgb = Colour.resolve(vStr, true);\n        entries.push([ k, Colour.toRgb(vRgb) ]);\n      } else {\n        entries.push([ k, v.toString() ]);\n      }\n    }\n\n    // Checkboxes that aren't checked don't give a value, so find those\n    for (const el of formEl.querySelectorAll<HTMLInputElement>(`input[type=\"checkbox\"]`)) {\n      if (!el.checked && el.value === `true`) {\n        entries.push([ el.name, false ]);\n      }\n    }\n    const asObj = Object.fromEntries(entries);\n    //console.log(`readValue`, asObj);\n    return asObj;\n  }\n\n  const getFormElement = (name: string, value: string): HTMLSelectElement | HTMLInputElement | undefined => {\n    const el = formEl.querySelector(`[name=\"${ name }\"]`) as HTMLInputElement | null;\n    if (!el) {\n      console.warn(`Form does not contain an element with name=\"${ name }\"`);\n      return;\n    }\n    if (el.type === `radio`) {\n      // Get right radio option\n      const radioEl = formEl.querySelector(`[name=\"${ name }\"][value=\"${ value }\"]`) as HTMLInputElement | null;\n      if (!radioEl) {\n        console.warn(`Form does not contain radio option for name=${ name } value=${ value }`);\n        return;\n      }\n      return radioEl;\n    }\n    return el;\n  }\n  const setNamedValue = (name: string, value: any) => {\n    const el = getFormElement(name, value);\n    if (!el) return;\n\n    //let typeHint = typeHints.get(name);\n    // if (typeHint) {\n    //   console.log(`${ name } hint: ${ typeHint } input type: ${ el.type }`);\n    // } else {\n    //   console.warn(`Rx.Sources.Dom.domForm no type hint for: ${ name }`);\n    // }\n    if (el.nodeName === `INPUT` || el.nodeName === `SELECT`) {\n      if (el.type === `color`) {\n        if (typeof value === `object`) {\n          // Try to parse colour if value is an object\n          const c = Colour.resolve(value, true);\n          value = Colour.toHex(c);\n        }\n      } else if (el.type === `checkbox`) {\n        if (typeof value === `boolean`) {\n          el.checked = value;\n          return;\n        } else {\n          console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${ name } Value: ${ value } (${ typeof value })`);\n        }\n      } else if (el.type === `radio`) {\n        el.checked = true;\n        return;\n      }\n      el.value = value;\n    }\n  }\n\n  const setFromUpstream = (value: T) => {\n    //console.log(`setUpstream`, value);\n    for (const [ name, v ] of Object.entries(value)) {\n      let hint = typeHints.get(name);\n      if (!hint) {\n        hint = typeof v;\n        if (hint === `object`) {\n          const rgb = Colour.parseRgbObject(v);\n          if (rgb.success) {\n            hint = `colour`;\n          }\n        }\n        typeHints.set(name, hint);\n      }\n      const valueFiltered = options.upstreamFilter ? options.upstreamFilter(name, v) : v;\n      setNamedValue(name, valueFiltered);\n    }\n  }\n\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setFromUpstream);\n    if (hasLast(upstreamSource)) {\n      setFromUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(formEl, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el: formEl,\n    last() {\n      return readValue()\n    },\n    set: setFromUpstream,\n    setNamedValue,\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}","import { initLazyStream } from \"../InitStream.js\";\nimport type { InitLazyStreamOptions, Reactive, Unsubscriber } from \"../Types.js\";\n\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources \n * @returns \n */\nexport function merged<T>(...sources: Reactive<T>[]): Reactive<T> {\n  return mergedWithOptions(sources);\n}\n\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * \n * @param sources \n * @param options \n * @returns \n */\nexport function mergedWithOptions<T>(sources: Reactive<T>[], options: Partial<InitLazyStreamOptions> = {}): Reactive<T> {\n  let unsubs: Unsubscriber[] = [];\n  const stream = initLazyStream<T>({\n    ...options,\n    onStart() {\n      for (const s of sources) {\n        unsubs.push(s.onValue(v => {\n          stream.set(v);\n        }));\n      }\n    },\n    onStop() {\n      for (const un of unsubs) {\n        un();\n      }\n      unsubs = [];\n    },\n  });\n  return stream;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function number(initialValue: number): ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}\n","import { object } from \"./Object.js\";\nimport { symbol, type ReactiveArray, type ReactiveDiff, type ReactiveInitial } from \"../Types.js\";\nimport { array } from \"./Array.js\";\nimport { arrayObject } from \"./ArrayObject.js\";\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n * \n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n * \n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target \n * @returns \n */\nexport const objectProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n\n  const rx = object(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      const isArray = Array.isArray(target);\n      console.log(`Rx.Sources.object set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (isArray && p === `length`) return true;\n\n      if (typeof p === `string`) {\n        rx.updateField(p, newValue);\n      }\n\n      // If target is array and field looks like an array index...\n      if (isArray && typeof p === `string`) {\n        const pAsNumber = Number.parseInt(p);\n        if (!Number.isNaN(pAsNumber)) {\n          target[ pAsNumber ] = newValue;\n          return true;\n        }\n      }\n      (target as any)[ p ] = newValue;\n      return true;\n    }\n  });\n  return { proxy, rx }\n}\n\nexport const arrayProxy = <V, T extends Array<V>>(target: T): { proxy: T, rx: ReactiveArray<V> & ReactiveInitial<ReadonlyArray<V>> } => {\n  const rx = arrayObject(target);\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      //console.log(`Rx.Sources.arrayProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (p === `length`) return true;\n      if (typeof p !== `string`) throw new Error(`Expected numeric index, got type: ${ typeof p } value: ${ JSON.stringify(p) }`);\n      const pAsNumber = Number.parseInt(p);\n      if (!Number.isNaN(pAsNumber)) {\n        rx.setAt(pAsNumber, newValue);\n        target[ pAsNumber ] = newValue;\n\n        return true;\n      } else {\n        throw new Error(`Expected numeric index, got: '${ p }'`);\n      }\n    }\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const objectProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = objectProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../Types.js\";\nimport { messageHasValue } from \"../Util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V> {\n  const ow = observableWritable(init);\n  return {\n    dispose: ow.dispose,\n    isDisposed: ow.isDisposed,\n    on: ow.on,\n    onValue: ow.onValue\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V> {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    onValue: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function string(initialValue: string): ReactiveWritable<string> & ReactiveInitial<string>;\nexport function string(): ReactiveWritable<string> & ReactiveNonInitial<string>;\nexport function string(initialValue?: string): ReactiveWritable<string> & (ReactiveNonInitial<string> | ReactiveInitial<string>) {\n  let value = initialValue;\n  const events = initStream<string>();\n\n  const set = (v: string) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}"],"mappings":"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","names":["average","filter","interpolate","max","min","rank","sum","tally","toArray","wrap","manual","run","filter","find","fromIterable","map","min","some","toArray","zip","array","fromIterable","count","filter","find","iterator","map","max","min","some","toArray","toString","zip","iterator","isEmpty","elements","t","field","event","compareData","field","compareData","split","object","compareData","field","value","event","field","elapsed","elapsed","filter","min","max","create","ticks","time","t","pow","clamp","dotProduct","interpolate","quantiseEvery","reduce","rotate","round","toArray","toString","wrap","average","count","distance","smoothingFactor","min","sum","clamp","min","max","b","a","guard","isNaN","guard","isPositioned","guardPositioned","isEmpty","isPlaceholder","isEqual","line","isEqual","centroid","guard","isPositioned","guard","distanceFromExterior","guardPositioned","distanceFromExterior","distanceFromExterior","toArray","dotProduct","toArray","guard","line","getPointParameter","sum","getPointParameter","getPointParameter","interpolate","max","min","length","length","pipeline","distance","every","quantiseEvery","reduce","count","clampMagnitude","divide","dotProduct","guard","invert","multiply","normalise","cloneFromFields","piPi","t","cloneFromFields","field","object","object","r","pi","average","max","min","sum","max","min","sum","t","average","tally","toString","object","piPi","piPi","normalise","guard","dotProduct","invert","multiply","divide","clampMagnitude","max","min","distance","rotate","round","toString","wrap","abs","cos","sin","sqrt","pow","pi","t","t2","sum","bbox","intersections","min","max","line","reduce","a","b","c","d","v1","q","bbox","abs","min","max","cos","sin","acos","sqrt","pi","point","t","abs","pi","sqrt","acos","d","ls","le","segments","tlen","alen","line","min","max","intersections","cos","sin","cubic","cubic2","t","quadratic","max","interpolate","relative","create","time","ticks","map","interpolate","interpolate","t","interpolate","max","min","average","sum","tally","rank","annotate","event","t","t","event","elapsed","repeat","distance","get","priority","item","object","graph","get","vertices","line","distance","from","to","t","weight","edges","process","toArray","resolve","resolve","wrap","filter","min","max","average","sum","tally","source","toArray","elements","bind","field","create","changes","array","filter","count","insertAt","resolve","remove","count","elapsed","relative","resolve","target","filter","interpolate","min","max","sum","average","tally","rank","resolve","transform"]}