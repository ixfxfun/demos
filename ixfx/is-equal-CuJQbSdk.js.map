{"version":3,"file":"is-equal-CuJQbSdk.js","names":["itemToMakeStringFor: V","object: any","itemToMakeStringFor: unknown","key: string","value: unknown","a: T","b: T","isEqualContextString: IsEqualContext<unknown>","a: unknown","b: unknown","_path: string"],"sources":["../../../ixfx/packages/core/src/to-string.ts","../../../ixfx/packages/core/src/is-equal.ts"],"sourcesContent":["\n// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultToString = (object: any): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (object === null) return `null`;\n  if (typeof object === `boolean` || typeof object === `number`) {\n    return object.toString();\n  }\n\n  if (typeof object === `string`) return object;\n  if (typeof object === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  return JSON.stringify(object);\n};","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: unknown) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n   \n  JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string,unknown>, b: Record<string,unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string,unknown>, valueB as Record<string,unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}"],"mappings":";;;;AAcA,MAAa,kBAAkB,CAAIA,+BAC1B,yBAAyB,UAC5B,sBACA,KAAK,UAAU,oBAAoB;AAGzC,MAAa,kBAAkB,CAACC,WAAwB;AAEtD,KAAI,WAAW,KAAM,SAAQ;AAC7B,YAAW,YAAY,mBAAmB,YAAY,QACpD,QAAO,OAAO,UAAU;AAG1B,YAAW,YAAY,QAAS,QAAO;AACvC,YAAW,YAAY,QAAS,OAAM,IAAI,WAAW;AACrD,QAAO,KAAK,UAAU,OAAO;AAC9B;;;;;;;;;;;;ACfD,MAAa,kBAAkB,CAACC,wBAAiC;AAC/D,YAAW,yBAAyB,QAAS,QAAO;CACpD,MAAM,UAAU,IAAI;AAEpB,MAAK,UAAU,qBAAqB,CAACC,KAAaC,WAAoB,QAAQ,IAAI,IAAI,EAAE,OAAO;AAC/F,QAAO,KAAK,UAAU,qBAAqB,CAAE,GAAG,OAAS,EAAC,MAAM,CAAC;AAClE;;;;;AAOD,MAAa,iBAAiB,CAAIC,GAAMC,MAAkB,MAAM;;;;;;;;;;;;;;;;;;;AAoBhE,MAAa,sBAAsB,CAAID,GAAMC,MAAkB;AAE7D,KAAI,MAAM,EAAG,QAAO;AACpB,QAAO,gBAAgB,EAAE,KAAK,gBAAgB,EAAE;AACjD;;;;;;;;;;;;;;AAgED,MAAa,0BAA0B,CAAID,GAAMC,MAAkB;AAEjE,KAAI,MAAM,EAAG,QAAO;AACpB,QAAO,gBAAgB,EAAE,KAAK,gBAAgB,EAAE;AACjD;;;;;;;;;AAuBD,MAAaC,uBAAgD,CAACC,GAAYC,GAAYC,UAA2B;AAC/G,QAAO,KAAK,UAAU,EAAE,KAAK,KAAK,UAAU,EAAE;AAC/C"}