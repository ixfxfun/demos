import{n as e}from"./chunk-CVLEGGlw.js";import{_ as t,y as n}from"./numbers-BlBexQl9.js";import{t as r}from"./string-CraS4SMa.js";import{V as i}from"./src-kD5hEVnd.js";import{t as a}from"./queue-mutable-DkFlFSVY.js";import{t as o}from"./StackMutable-CC_MLivw.js";import{t as s}from"./priority-mutable-B2l7ClRd.js";const c=(e,t)=>{let n=new Map(e.entries());for(let e of t){if(e[0]===void 0)throw Error(`key cannot be undefined`);if(e[1]===void 0)throw Error(`value cannot be undefined`);n.set(e[0],e[1])}return n},l=(e,t)=>{let n=new Map(e.entries());for(let e of t){if(e.key===void 0)throw Error(`key cannot be undefined`);if(e.value===void 0)throw Error(`value cannot be undefined`);n.set(e.key,e.value)}return n},u=(e,t)=>e.has(t),d=(e,...t)=>{if(e===void 0)throw Error(`map parameter is undefined`);if(t===void 0)throw Error(`data parameter i.s undefined`);if(t.length===0)return e;let n=t[0];return n.key!==void 0&&n.value!==void 0?l(e,t):c(e,t)},f=(e,t,n)=>{let r=new Map(e.entries());return r.set(t,n),r},p=(e,t)=>{let n=new Map(e.entries());return n.delete(t),n},m=e=>{if(e===void 0)return m([]);if(Array.isArray(e))return m(d(new Map,...e));let t=e;return{add:(...e)=>m(d(t,...e)),set:(e,n)=>m(f(t,e,n)),get:e=>t.get(e),delete:e=>m(p(t,e)),clear:()=>m(),has:e=>t.has(e),entries:()=>t.entries(),values:()=>t.values(),isEmpty:()=>t.size===0}};var h=class extends Map{defaultValue;constructor(e=0){super(),this.defaultValue=e}get(e){let t=super.get(e);return t===void 0?this.defaultValue:t}reset(e){return super.set(e,this.defaultValue),this.defaultValue}multiply(e,t){let n=super.get(e)??this.defaultValue;return n*=t,super.set(e,n),n}add(e,t=1){let n=super.get(e)??this.defaultValue;return n+=t,super.set(e,n),n}subtract(e,t=1){let n=super.get(e)??this.defaultValue;return n-=t,super.set(e,n),n}},g=class{rows=[];rowLabels=[];colLabels=[];columnMaxLength=0;getColumnLabelIndex(e){for(let[t,n]of this.colLabels.entries())if(n===e)return t}getRowLabelIndex(e){for(let[t,n]of this.rowLabels.entries())if(n===e)return t}print(){console.table([...this.rowsWithLabelsObject()])}asArray(){let e=[];for(let t of this.rows)t===void 0?e.push([]):e.push([...t]);return e}get rowCount(){return this.rows.length}get columnCount(){return this.columnMaxLength}*rowsWithLabelsObject(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsObject(e)}*rowsWithLabelsArray(){for(let e=0;e<this.rows.length;e++)yield this.getRowWithLabelsArray(e)}labelColumns(...e){this.colLabels=e}labelColumn(e,t){this.colLabels[e]=t}labelRows(...e){this.rowLabels=e}labelRow(e,t){this.rowLabels[e]=t}appendRow(...e){return this.columnMaxLength=Math.max(this.columnMaxLength,e.length),this.rows.push(e),e}getRowWithLabelsArray(e){let t=this.rows.at(e);if(t!==void 0)return t.map((e,t)=>[this.colLabels.at(t),e])}getRowWithLabelsObject(e){let t=this.rows.at(e);if(t===void 0)return;let n={};for(let e=0;e<this.colLabels.length;e++){let r=this.colLabels.at(e)??e.toString();n[r]=t[e]}return n}#e(e){let t=typeof e==`number`?e:this.getRowLabelIndex(e);if(t===void 0)return{success:!1,error:`row-label-notfound`};if(t<0)return{success:!1,error:`row-index-invalid`};if(t<this.rows.length)return{success:!0,value:this.rows[t]};let n=[];return this.rows[t]=n,{success:!0,value:n}}row(e){let n=this.#t(e);if(t(n))throw Error(n.error);return[...n.value]}set(e,n,r){let i=this.#e(e);if(t(i))throw Error(i.error);let a=i.value,o=typeof n==`number`?n:this.getColumnLabelIndex(n);if(o===void 0)throw Error(`Column label '${n}' not found or is invalid`);if(o<0)throw Error(`Column index invalid (less than zero)`);a[o]=r}get(e,n){let r=this.#t(e);if(t(r))throw Error(r.error);let i=this.#n(r.value,n);if(t(i))throw Error(i.error);return i.value.value}#t(e){let t=0;if(typeof e==`number`)t=e;else if(t=this.getRowLabelIndex(e),typeof t!=`number`)return{error:`row-label-notfound`,success:!1};return typeof t==`number`?t<0||t>=this.rows.length?{error:`row-index-out-of-range`,success:!1}:{success:!0,value:this.rows[t]}:{error:`row-invalid`,success:!1}}#n(e,t){let n=typeof t==`number`?t:this.getColumnLabelIndex(t);return typeof n==`number`?n<0||n>=e.length?{success:!1,error:`col-index-out-of-range`}:{success:!0,value:{index:n,value:e[n]}}:{success:!1,error:`col-label-notfound`}}setRow(e,n,r){let i=this.#e(e);if(t(i))throw Error(i.error);let a=i.value,o=typeof r==`number`?r:this.columnMaxLength;for(let e=0;e<o;e++)a[e]=n;return a}},_=e({adjacentVertices:()=>w,areAdjacent:()=>ce,bfs:()=>F,clone:()=>R,connect:()=>M,connectTo:()=>j,connectWithEdges:()=>N,createVertex:()=>v,dfs:()=>I,disconnect:()=>A,distance:()=>b,distanceDefault:()=>oe,dumpGraph:()=>ne,edges:()=>x,get:()=>te,getCycles:()=>U,getOrCreate:()=>D,getOrFail:()=>O,graph:()=>z,graphFromVertices:()=>H,hasKey:()=>ee,hasNoOuts:()=>ae,hasOnlyOuts:()=>T,hasOut:()=>E,isAcyclic:()=>B,pathDijkstra:()=>L,toAdjacencyMatrix:()=>y,topologicalSort:()=>V,transitiveReduction:()=>W,updateGraphVertex:()=>k,vertexHasOut:()=>ie,vertices:()=>S});const v=e=>({id:e,out:[]});function ee(e,t){return n(C(e)),e.vertices.has(t)}function te(e,t){return n(C(e)),n(r(t,`non-empty`,`key`)),e.vertices.get(t)}function y(e){n(C(e));let t=[...e.vertices.values()],r=new g;r.labelColumns(...t.map(e=>e.id)),r.labelRows(...t.map(e=>e.id));for(let e=0;e<t.length;e++){r.setRow(e,!1,t.length);let n=t[e];for(let[i,a]of t.entries())n.out.some(e=>e.id===a.id)&&r.set(e,i,!0)}return r}const ne=e=>re(e).join(`
`),re=e=>{let t=[],n=`vertices`in e?e.vertices.values():e;for(let e of n){let n=se(e);t.push(...n.map(e=>` ${e}`))}return t},b=(e,t)=>t.weight===void 0?1:t.weight;function*x(e){n(C(e));let t=[...e.vertices.values()];for(let e of t)for(let t of e.out)yield t}function*S(e){n(C(e));let t=[...e.vertices.values()];for(let e of t)yield e}function C(e,t=`graph`){if(e===void 0)return{success:!1,error:`Param '${t}' is undefined. Expected Graph`};if(e===null)return{success:!1,error:`Param '${t}' is null. Expected Graph`};if(typeof e==`object`){if(!(`vertices`in e))return{success:!1,error:`Param '${t}.vertices' does not exist. Is it a Graph type?`}}else return{success:!1,error:`Param '${t} is type '${typeof e}'. Expected an object Graph`};return{success:!0,value:e}}function*w(e,t){if(n(C(e)),t===void 0)return;let r=typeof t==`string`?e.vertices.get(t):t;if(r===void 0)throw Error(`Vertex not found ${JSON.stringify(t)}`);for(let t of r.out){let n=e.vertices.get(t.id);if(n===void 0)throw Error(`Could not find vertex: ${t.id}`);yield n}}const ie=(e,t)=>{if(e===void 0)return!1;let n=typeof t==`string`?t:t.id;return e.out.some(e=>e.id===n)},ae=(e,t)=>{n(C(e));let r=typeof t==`string`?e.vertices.get(t):t;return r===void 0?!1:r.out.length===0},T=(e,t,...r)=>{n(C(e));let i=P(e,t),a=r.map(t=>P(e,t));if(a.length!==i.out.length)return!1;for(let t of a)if(!E(e,i,t))return!1;return!0},E=(e,t,r)=>{n(C(e));let i=P(e,t),a=typeof r==`string`?r:r.id;return i.out.some(e=>e.id===a)},D=(e,t)=>{n(C(e));let r=e.vertices.get(t);if(r!==void 0)return{graph:e,vertex:r};let i=v(t);return{graph:k(e,i),vertex:i}},O=(e,t)=>{n(C(e));let r=e.vertices.get(t);if(r===void 0)throw Error(`Vertex '${t}' not found in graph`);return r},k=(e,t)=>(n(C(e)),{...e,vertices:e.vertices.set(t.id,t)}),oe=(e,t)=>t.weight===void 0?1:t.weight;function A(e,t,r){n(C(e));let i=P(e,t),a=P(e,r);return E(e,i,a)?k(e,{...i,out:i.out.filter(e=>e.id!==a.id)}):e}function j(e,t,r,i){n(C(e));let a=D(e,t);e=a.graph;let o=D(e,r);e=o.graph;let s={id:r,weight:i};return E(e,a.vertex,o.vertex)||(e=k(e,{...a.vertex,out:[...a.vertex.out,s]})),{graph:e,edge:s}}function M(e,t){if(typeof e!=`object`)throw TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${typeof e}`);if(typeof t!=`object`)throw TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${typeof t}`);return N(e,t).graph}function N(e,t){n(C(e));let{to:r,weight:i,from:a}=t,o=t.bidi??!1,s=Array.isArray(r)?r:[r],c=[];for(let t of s){let n=j(e,a,t,i);e=n.graph,c.push(n.edge)}if(!o)return{graph:e,edges:c};for(let t of s){let n=j(e,t,a,i);e=n.graph,c.push(n.edge)}return{graph:e,edges:c}}const se=e=>{let t=[e.id],n=e=>e.weight===void 0?e.id:`${e.id} (${e.weight})`;for(let r of e.out)t.push(` -> ${n(r)}`);return e.out.length===0&&(t[0]+=` (terminal)`),t};function ce(e,t,r){if(n(C(e)),E(e,t,r.id)||E(e,r,t.id))return!0}function P(e,t){if(n(C(e)),t===void 0)throw Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);let r=typeof t==`string`?e.vertices.get(t):t;if(r===void 0)throw Error(`Id not found ${t}`);return r}function*F(e,t,r){n(C(e));let i=P(e,t),o=r===void 0?void 0:P(e,r),s=new a,c=new Set;for(s.enqueue(i);!s.isEmpty;){let t=s.dequeue();if(yield t,o!==void 0&&o===t)return;for(let n of w(e,t))c.has(n.id)||(c.add(n.id),s.enqueue(P(e,n.id)))}}function*I(e,t){n(C(e));let r=P(e,t),i=new o,a=new Set;for(i.push(r);!i.isEmpty;){let t=i.pop();if(t!==void 0&&!a.has(t.id)){a.add(t.id),yield t;for(let n of t.out){let t=e.vertices.get(n.id);t&&i.push(t)}}}}const L=(e,t)=>{n(C(e));let r=typeof t==`string`?e.vertices.get(t):t;if(r===void 0)throw Error(`source vertex not found`);let i=new Map,a=new Map;i.set(r.id,0);let o=new s,c=[...e.vertices.values()];for(let e of c)e.id!==r.id&&(i.set(e.id,2**53-1),a.set(e.id,null)),o.enqueueWithPriority(e.id,2**53-1);for(;!o.isEmpty;){let t=o.dequeueMin();if(t===void 0)throw Error(`Bug. Queue unexpectedly empty`);let n=e.vertices.get(t);for(let r of n.out){let s=i.get(t)+b(e,r);s<i.get(r.id)&&(i.set(r.id,s),a.set(r.id,n),o.changePriority(r.id,s,!0))}}return{distances:i,previous:a,pathTo:e=>{let t=[];for(;e!==r.id;){let n=a.get(e);if(n==null)throw Error(`Id not present: ${e}`);t.push({id:e,weight:i.get(e)}),e=n.id}return t}}},R=e=>(n(C(e)),{vertices:m([...e.vertices.entries()])}),z=(...e)=>{let t={vertices:m()};for(let n of e)t=M(t,n);return t};function B(e){return n(C(e)),U(e).length===0}function V(e){n(C(e));let t=new h(0);for(let n of x(e))t.add(n.id,1);let r=new a,i=0;for(let n of S(e))t.get(n.id)===0&&r.enqueue(n),i++;let o=[];for(;!r.isEmpty;){let n=r.dequeue();o.push(n);for(let i of n.out)t.subtract(i.id,1)===0&&r.enqueue(e.vertices.get(i.id))}if(o.length!==i)throw Error(`Graph contains cycles`);return H(o)}function H(e){return{vertices:m([...i(e,e=>[e.id,e])])}}function U(e){n(C(e));let t=0,r=new o,i=new Map,a=[];for(let t of e.vertices.values())i.set(t.id,{...t,lowlink:NaN,index:NaN,onStack:!1});let s=e=>{e.index=t,e.lowlink=t,t++,r.push(e),e.onStack=!0;for(let t of e.out){let n=i.get(t.id);Number.isNaN(n.index)?(s(n),e.lowlink=Math.min(e.lowlink,n.lowlink)):n.onStack&&(e.lowlink=Math.min(e.lowlink,n.lowlink))}if(e.lowlink===e.index){let t=[],n;for(;e!==n;)n=r.pop(),n.onStack=!1,t.push({id:n.id,out:n.out});t.length>1&&a.push(t)}};for(let e of i.values())Number.isNaN(e.index)&&s(e);return a}function W(e){n(C(e));for(let t of S(e))for(let n of w(e,t))for(let r of I(e,n))if(n.id!==r.id&&E(e,t,r))return W(A(e,t,r));return e}var le=e({adjacentVertices:()=>he,connect:()=>Q,connectTo:()=>Z,connectWithEdges:()=>$,createVertex:()=>G,dumpGraph:()=>fe,edgesForVertex:()=>ge,getConnection:()=>X,getOrCreate:()=>q,graph:()=>ue,hasConnection:()=>Y,toAdjacencyMatrix:()=>de,updateGraphVertex:()=>K});const G=e=>({id:e}),K=(e,t)=>({...e,vertices:e.vertices.set(t.id,t)}),q=(e,t)=>{let n=e.vertices.get(t);if(n!==void 0)return{graph:e,vertex:n};let r=G(t);return{graph:K(e,r),vertex:r}};function J(e,t){if(typeof t!=`string`&&typeof t!=`object`)throw TypeError(`Param 'idOrVertex' is undefined. Expected string or Vertex. Got: ${typeof t}`);if(typeof e!=`object`)throw TypeError(`Param 'graph' is expected to be object. Got: ${typeof e}`);let n=typeof t==`string`?e.vertices.get(t):t;if(n===void 0)throw Error(`Id not found ${t}`);return n}const Y=(e,t,n)=>X(e,t,n)!==void 0,X=(e,t,n)=>{let r=J(e,t),i=J(e,n);for(let t of e.edges)if(t.a==r.id&&t.b===i.id||t.a==i.id&&t.b===r.id)return t};function Z(e,t,n,r){e=q(e,t).graph,e=q(e,n).graph;let i=X(e,t,n);return i===void 0?(i={a:t,b:n,weight:r},{graph:{...e,edges:[...e.edges,i]},edge:i}):{graph:e,edge:i}}function Q(e,t){return $(e,t).graph}function $(e,t){let{a:n,weight:r,b:i}=t,a=Array.isArray(i)?i:[i],o=[];for(let t of a){let i=Z(e,n,t,r);e=i.graph,o.push(i.edge)}return{graph:e,edges:o}}const ue=(...e)=>{let t={vertices:m(),edges:[]};for(let n of e)t=Q(t,n);return t};function de(e){let t=[...e.vertices.values()],n=new g;n.labelColumns(...t.map(e=>e.id)),n.labelRows(...t.map(e=>e.id));for(let r=0;r<t.length;r++){n.setRow(r,!1,t.length);let i=t[r];for(let[a,o]of t.entries())Y(e,i,o)&&n.set(r,a,!0)}return n}const fe=e=>pe(e).join(`
`),pe=e=>{let t=[];t.push(`Vertices: ${[...e.vertices.values()].map(e=>e.id).join(`, `)}`),t.push(`Edges:`);for(let n of e.edges)t.push(me(n));return t},me=e=>{let t=e.weight?` (${e.weight})`:``;return`${e.a} <-> ${e.b}${t}`};function*he(e,t){if(t!==void 0){if((typeof t==`string`?e.vertices.get(t):t)===void 0)throw Error(`Vertex not found ${JSON.stringify(t)}`);for(let n of e.edges)n.a===t?yield J(e,n.b):n.b===t&&(yield J(e,n.a))}}function*ge(e,t){if(typeof e!=`object`)throw TypeError(`Param 'graph' is expected to be an object. Got: ${typeof e}`);if(t!==void 0){if((typeof t==`string`?e.vertices.get(t):t)===void 0)throw Error(`Vertex not found ${JSON.stringify(t)}`);for(let n of e.edges)(n.a===t||n.b===t)&&(yield n)}}var _e=e({Directed:()=>_,Undirected:()=>le});export{h as a,p as c,g as i,u as l,M as n,m as o,z as r,d as s,_e as t,f as u};