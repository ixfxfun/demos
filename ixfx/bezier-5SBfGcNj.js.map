{"version":3,"file":"bezier-5SBfGcNj.js","names":["max","min","min","max","max","min","mti","float","integer","min","max","min","max","max","min","#store","#keyString","t","count","t","#resetAfterSamples","#sampleLimit","#resetTimer","#fromTime","#events","min","max","count","t","pi","t","sqrt","abs","min","max","cos","sin","a","b","c","d","v1","q","acos","point","t","pi","d","ls","le","segments","tlen","alen"],"sources":["../../random/dist/src/weighted-index.js","../../random/dist/src/arrays.js","../../random/dist/src/chance.js","../../random/dist/src/float-source.js","../../random/dist/src/non-zero.js","../../random/dist/src/gaussian.js","../../random/dist/src/guid.js","../../random/dist/src/util/count.js","../../random/dist/src/integer.js","../../random/dist/src/seeded.js","../../random/dist/src/string.js","../../random/dist/src/time.js","../../random/dist/src/util/clamp.js","../../random/dist/src/weighted-integer.js","../../random/dist/src/weighted.js","../../random/dist/src/index.js","../../trackers/dist/src/changes.js","../../trackers/dist/src/frequency-mutable.js","../../trackers/dist/src/tracker-base.js","../../trackers/dist/src/primitive-tracker.js","../../trackers/dist/src/number-tracker.js","../../trackers/dist/src/interval-tracker.js","../../trackers/dist/src/rate-tracker.js","../../trackers/dist/src/object-tracker.js","../../trackers/dist/src/tracked-value.js","../../trackers/dist/src/index.js","../../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/utils.js","../../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/poly-bezier.js","../../../node_modules/.pnpm/bezier-js@6.1.4/node_modules/bezier-js/src/bezier.js"],"sourcesContent":["import {} from \"./types.js\";\n/**\n* Returns a random number from 0..weightings.length, distributed by the weighting values.\n*\n* eg: produces 0 20% of the time, 1 50% of the time, 2 30% of the time\n* ```js\n* weightedIndex([0.2, 0.5, 0.3]);\n* ```\n* @param weightings\n* @param rand\n* @returns\n*/\nexport const weightedIndex = (weightings, rand = Math.random) => {\n    const precompute = [];\n    let total = 0;\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < weightings.length; index++) {\n        total += weightings[index];\n        precompute[index] = total;\n    }\n    if (total !== 1)\n        throw new Error(`Weightings should add up to 1. Got: ${total}`);\n    return () => {\n        const v = rand();\n        // eslint-disable-next-line unicorn/no-for-loop\n        for (let index = 0; index < precompute.length; index++) {\n            if (v <= precompute[index])\n                return index;\n        }\n        throw new Error(`Bug: weightedIndex could not select index`);\n    };\n};\n","import { arrayTest, resultThrow } from \"@ixfx/guards\";\nimport { weightedIndex } from \"./weighted-index.js\";\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = (array, rand = Math.random) => Math.floor(rand() * array.length);\n/**\n * Plucks a random value from an array, optionally mutating\n * the original array.\n *\n * @example Get a random element without modifying array\n * ```js\n * const { value, remainder } = randomPluck(inputArray);\n * ```\n *\n * @example Get a random element, removing it from original array\n * ```js\n * const value = randomPluck(inputArray, { mutate: true });\n * ```\n *\n * If the input array is empty, _undefined_ is returned as the value.\n * @typeParam V - Type of items in array\n * @param array Array to pluck item from\n * @param options Options. By default { mutate: false, source: Math.random }\n * @param rand Random generator. `Math.random` by default.\n *\n */\nexport function randomPluck(array, options = {}) {\n    if (typeof array === `undefined`)\n        throw new Error(`Param 'array' is undefined`);\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array`);\n    const mutate = options.mutate ?? false;\n    const rand = options.source ?? Math.random;\n    if (array.length === 0) {\n        if (mutate)\n            return undefined;\n        return { value: undefined, remainder: [] };\n    }\n    const index = randomIndex(array, rand);\n    if (mutate) {\n        // Return bare value\n        const v = array[index];\n        array.splice(index, 1);\n        return v;\n    }\n    else {\n        // Copy array, remove item from that\n        const inputCopy = [...array];\n        inputCopy.splice(index, 1);\n        return {\n            value: array[index],\n            remainder: inputCopy,\n        };\n    }\n}\n;\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = (array, rand = Math.random) => {\n    resultThrow(arrayTest(array, `array`));\n    return array[Math.floor(rand() * array.length)];\n};\n/**\n * Selects a random array index, biased by the provided `weightings`.\n *\n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ]\n * ```\n * @param array\n * @param weightings\n * @param randomSource\n */\nexport const randomElementWeightedSource = (array, weightings, randomSource = Math.random) => {\n    if (array.length !== weightings.length)\n        throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n    const r = weightedIndex(weightings, randomSource);\n    return () => {\n        const index = r();\n        return array[index];\n    };\n};\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = (dataToShuffle, rand = Math.random) => {\n    const array = [...dataToShuffle];\n    for (let index = array.length - 1; index > 0; index--) {\n        const index_ = Math.floor(rand() * (index + 1));\n        [array[index], array[index_]] = [array[index_], array[index]];\n    }\n    return array;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Chance of returning `a` or `b`, based on threshold `p`.\n *\n * `p` sets the threshold for picking `b`. The higher the value (up to 1),\n * the more likely `b` will be picked.\n *\n * ```js\n * // 50% of the time it will return 100, 50% 110\n * chance(0.5, 100, 110);\n * // 90% of the time it will yield 110, 10% it will yield 100\n * chance(0.9, 100, 110);\n * ```\n *\n * @param p Threshold to choose option B (value or function)\n * @param a Value or function for option A\n * @param b Value or function for option B\n * @param randomSource Source of random numbers\n * @returns\n */\nexport const chance = (p, a, b, randomSource) => {\n    const source = randomSource ?? Math.random;\n    const resolve = (x) => {\n        if (typeof x === `function`)\n            return x();\n        return x;\n    };\n    const pp = resolve(p);\n    resultThrow(numberTest(pp, `percentage`, `p`));\n    if (source() <= pp) {\n        return resolve(b);\n    }\n    else {\n        return resolve(a);\n    }\n};\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport {} from \"./types.js\";\n/**\n * Source for random bipolar values\n * ```js\n * const r = bipolarSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n *\n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * bipolarSource({ max: 0.5 });\n * ```\n *\n *\n * @param maxOrOptions Maximum value (number) or options for random generation\n * @returns\n */\nexport const bipolarSource = (maxOrOptions) => {\n    const source = floatSource(maxOrOptions);\n    return () => (source() * 2) - 1;\n};\n/**\n * Returns a random bipolar value\n * ```js\n * const r = bipolar(); // -1...1 random\n * ```\n *\n * Options can be provided, eg.\n * ```js\n * bipolar({ max: 0.5 }); // -0.5..0.5 random\n * ```\n *\n * Use {@link bipolarSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions\n * @returns\n */\nexport const bipolar = (maxOrOptions) => {\n    const source = bipolarSource(maxOrOptions);\n    return source();\n};\n/**\n * Returns a function that produces random float values.\n * Use {@link float} to produce a valued directly.\n *\n * Random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n *\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const r = floatSource();\n * r(); // Execute to produce random value\n *\n * // Random float between 0..100 (but not including 100)\n * const v = floatSource(100)();\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const r = floatSource({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const floatSource = (maxOrOptions = 1) => {\n    const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n    let max = options.max ?? 1;\n    let min = options.min ?? 0;\n    const source = options.source ?? Math.random;\n    resultThrow(numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (!options.min && max < 0) {\n        min = max;\n        max = 0;\n    }\n    if (min > max) {\n        throw new Error(`Min is greater than max. Min: ${min.toString()} max: ${max.toString()}`);\n    }\n    return () => source() * (max - min) + min;\n};\n/**\n * Returns a random float between `max` (exclusive) and 0 (inclusive).\n *\n * Max is 1 if unspecified.\n * Use {@link floatSource} to get a function that produces values. This is used internally.\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const v = float();\n * // Random float between 0..100 (but not including 100)\n * const v = float(100);\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const v = float({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const float = (maxOrOptions = 1) => floatSource(maxOrOptions)();\n","/**\n * Keeps generating a random number until\n * it's not 0\n * @param source Random number generator\n * @returns Non-zero number\n */\nexport const calculateNonZero = (source = Math.random) => {\n    let v = 0;\n    while (v === 0) {\n        v = source();\n    }\n    return v;\n};\n","import { calculateNonZero } from \"./non-zero.js\";\n/**\n * Returns a random number with gaussian (ie. bell-curved) distribution\n *\n * @example Random number between 0..1 with gaussian distribution\n * ```js\n * gaussian();\n * ```\n *\n * @example Distribution can be skewed\n * ```js\n * gaussian(10);\n * ```\n *\n * Use {@link gaussianSource} if you want a function with skew value baked-in.\n * @param skew Skew factor. Defaults to 1, no skewing. Above 1 will skew to left, below 1 will skew to right\n * @returns\n */\nexport const gaussian = (skew = 1) => gaussianSource(skew)();\n/**\n * Returns a function that generates a gaussian-distributed random number\n * @example\n * Random number between 0..1 with gaussian distribution\n * ```js\n * // Create function\n * const r = gaussianSource();\n *\n * // Generate random value\n * r();\n * ```\n *\n * @example\n * Pass the random number generator elsewhere\n * ```js\n * const r = gaussianSource(10);\n *\n * // Randomise array with gaussian distribution\n * Arrays.shuffle(r);\n * ```\n *\n * If you want to fit a value to a gaussian curve, see Modulation.gaussian instead.\n * @param skew\n * @returns\n */\nexport const gaussianSource = (skew = 1) => {\n    const min = 0;\n    const max = 1;\n    // Source: https://stackoverflow.com/questions/25582882/javascript-math-random-normal-distribution-gaussian-bell-curve\n    const compute = () => {\n        const u = calculateNonZero();\n        const v = calculateNonZero();\n        let result = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);\n        result = result / 10 + 0.5; // Translate to 0 -> 1\n        if (result > 1 || result < 0) {\n            result = compute(); //;gaussian(skew); // resample between 0 and 1 if out of range\n        }\n        else {\n            result = Math.pow(result, skew); // Skew\n            result *= max - min; // Stretch to fill range\n            result += min; // offset to min\n        }\n        return result;\n    };\n    return compute;\n};\n","/**\n * Generates a six-digit roughly unique id\n * ```js\n * const id = shortGuid();\n * ```\n * @param options Options.\n * @returns\n */\nexport const shortGuid = (options = {}) => {\n    const source = options.source ?? Math.random;\n    // Via Stackoverflow...\n    const firstPart = Math.trunc(source() * 46_656);\n    const secondPart = Math.trunc(source() * 46_656);\n    const firstPartString = `000${firstPart.toString(36)}`.slice(-3);\n    const secondPartString = `000${secondPart.toString(36)}`.slice(-3);\n    return firstPartString + secondPartString;\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount, offset = 0) {\n    resultThrow(integerTest(amount, ``, `amount`), integerTest(offset, ``, `offset`));\n    if (amount === 0)\n        return;\n    let index = 0;\n    do {\n        yield (amount < 0 ? -index + offset : index + offset);\n    } while (index++ < Math.abs(amount) - 1);\n}\n;\n","import { numberTest, integerTest, resultThrow } from \"@ixfx/guards\";\nimport { count } from \"./util/count.js\";\nimport { shuffle } from \"./arrays.js\";\n/**\n * Returns a function that produces a random integer between `max` (exclusive) and 0 (inclusive)\n * Use {@link integer} if you want a random number directly.\n *\n * Invoke directly:\n * ```js\n * integerSource(10)();  // Random number 0-9\n * ```\n *\n * Or keep a reference to re-compute:\n * ```js\n * const r = integerSource(10);\n * r(); // Produce a random integer\n * ```\n *\n * If a negative value is given, this is assumed to be the\n * minimum (inclusive), with 0 as the max (inclusive)\n * ```js\n * integerSource(-5)();  // Random number from -5 to 0\n * ```\n *\n * Specify options for a custom minimum or source of random:\n * ```js\n * integerSource({ max: 5,  min: 10 })();  // Random number 4-10\n * integerSource({ max: -5, min: -10 })(); // Random number from -10 to -6\n * integerSource({ max: 10, source: Math.random })(); // Random number between 0-9, with custom source of random\n * ```\n *\n * Throws an error if max & min are equal\n * @param maxOrOptions Max value (exclusive), or set of options\n * @returns Random integer\n */\nexport const integerSource = (maxOrOptions) => {\n    if (typeof maxOrOptions === `undefined`) {\n        throw new TypeError(`maxOrOptions is undefined`);\n    }\n    const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n    let max = Math.floor(options.max ?? 100);\n    let min = Math.floor(options.min ?? 0);\n    // If we just get -5 as the max, invert so\n    // max:1 and min: -5 instead for -5...0 range\n    if (!options.min && max < 0) {\n        max = 1;\n        min = options.max ?? 0;\n    }\n    const randomSource = options.source ?? Math.random;\n    if (min > max) {\n        throw new Error(`Min value is greater than max (min: ${min.toString()} max: ${max.toString()})`);\n    }\n    resultThrow(numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (max === min) {\n        throw new Error(`Max and min values cannot be the same (${max.toString()})`);\n    }\n    // Distance\n    const amt = Math.abs(max - min);\n    return () => Math.floor(randomSource() * amt) + min;\n};\n/**\n * Returns a random integer between `max` (exclusive) and 0 (inclusive)\n * Use {@link integerSource} to return a function instead.\n *\n * ```js\n * integer(10);  // Random number 0,1..9\n * ```\n *\n * If a negative value is given, this is assumed to be the\n * minimum (inclusive), with 0 as the max (inclusive)\n * ```js\n * integer(-5);  // Random number -5,-4,...0\n * ```\n *\n * Specify options for a custom minimum or source of random:\n * ```js\n * integer({ max: 5,  min: 10 });  // Random number 4-10\n * integer({ max: -5, min: -10 }); // Random number from -10 to -6\n * integer({ max: 10, source: Math.random }); // Random number between 0-9, with custom source of random\n * ```\n *\n * Throws an error if max & min are equal\n * @param maxOrOptions Max value (exclusive), or set of options\n * @returns Random integer\n */\nexport const integer = (maxOrOptions) => integerSource(maxOrOptions)();\n/**\n * Returns a generator over random unique integers, up to\n * but not including the given max value.\n *\n * @example 0..9 range\n * ```js\n * const rand = [ ...integerUniqueGen(10) ];\n * // eg: [2, 9, 6, 0, 8, 7, 3, 4, 5, 1]\n * ```\n *\n * @example Options can be provided:\n * ```js\n * // 5..9 range\n * const rand = [ ...integerUniqueGen({ min: 5, max: 10 })];\n * ```\n *\n * Range can be looped. Once the initial random walk through the number\n * range completes, it starts again in a new random way.\n *\n * ```js\n * for (const r of integerUniqueGen({ max: 10, loop: true })) {\n *  // Warning: loops forever\n * }\n * ```\n *\n * Behind the scenes, an array of numbers is created that captures the range, this is then\n * shuffled on the first run, and again whenever the iterator loops, if that's allowed.\n *\n * As a consequence, large ranges will consume larger amounts of memory.\n * @param maxOrOptions\n * @returns\n */\nexport function* integerUniqueGen(maxOrOptions) {\n    const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n    const min = options.min ?? 0;\n    const max = options.max ?? 100;\n    const source = options.source ?? Math.random;\n    const loop = options.loop ?? false;\n    resultThrow(integerTest(min, ``, `min`), integerTest(max, ``, `max`));\n    if (min > max) {\n        throw new Error(`Min value is greater than max. Min: ${min.toString()} Max: ${max.toString()}`);\n    }\n    const origRange = [...count(max - min, min)];\n    let numberRange = shuffle(origRange);\n    let index = 0;\n    while (true) {\n        if (index === numberRange.length) {\n            if (loop)\n                numberRange = shuffle(origRange, source);\n            else\n                return;\n        }\n        yield numberRange[index++];\n    }\n}\n","/**\n * Reproducible random values using the Merseene Twister algorithm.\n * With the same seed value, it produces the same series of random values.\n *\n * ```js\n * // Seed with a value of 100\n * const r = mersenneTwister(100);\n * r.float();         // 0..1\n * ```\n *\n * Integer values can also be produced. First parameter\n * is the maximum value (exclusive), the optional second\n * parameter is the minimum value (inclusive).\n * ```js\n * r.integer(10);     // 0..9\n * r.integer(10, 5);  // 5..9\n *\n * // Eg random array index:\n * r.integer(someArray.length);\n * ```\n *\n * Adapted from George MacKerron's implementation. MIT License.\n * https://github.com/jawj/mtwist/\n * @param seed Seed value 0..4294967295. Default: random seed.\n */\nexport function mersenneTwister(seed) {\n    if (!seed)\n        seed = Math.random() * 4294967295;\n    // Initialisation\n    let mt = new Array(624);\n    mt[0] = seed >>> 0;\n    const n1 = 1812433253;\n    for (let mti = 1; mti < 624; mti++) {\n        const n2 = mt[mti - 1] ^ (mt[mti - 1] >>> 30);\n        // uint32 multiplication, low 16 bits and high 16 bits multiplied separately and reassembled:\n        mt[mti] = ((((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) + mti) >>> 0;\n    }\n    let mti = 624;\n    const randomUint32 = () => {\n        let y;\n        if (mti >= 624) {\n            for (let i = 0; i < 227; i++) {\n                y = ((mt[i] & 0x80000000) | (mt[i + 1] & 0x7fffffff)) >>> 0;\n                mt[i] = (mt[i + 397] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;\n            }\n            for (let i = 227; i < 623; i++) {\n                y = ((mt[i] & 0x80000000) | (mt[i + 1] & 0x7fffffff)) >>> 0;\n                mt[i] = (mt[i - 227] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;\n            }\n            y = ((mt[623] & 0x80000000) | (mt[0] & 0x7fffffff)) >>> 0;\n            mt[623] = (mt[396] ^ (y >>> 1) ^ (y & 1 ? 0x9908b0df : 0)) >>> 0;\n            mti = 0;\n        }\n        y = mt[mti++];\n        y = (y ^ (y >>> 11)) >>> 0;\n        y = (y ^ ((y << 7) & 0x9d2c5680)) >>> 0;\n        y = (y ^ ((y << 15) & 0xefc60000)) >>> 0;\n        y = (y ^ (y >>> 18)) >>> 0;\n        return y;\n    };\n    const float = () => randomUint32() / 4294967296; // 2^32\n    // Max is exclusive\n    const integer = (maxExclusive, minInclusive = 0) => {\n        if (maxExclusive < 1)\n            throw new Error(\"Upper bound must be greater than or equal to 1\");\n        if (maxExclusive > 4294967296)\n            throw new Error(\"Upper bound must not be greater than 4294967296\");\n        if (maxExclusive === 1)\n            return 0;\n        let range = maxExclusive - minInclusive;\n        const bitsNeeded = Math.ceil(Math.log2(range)), bitMask = (1 << bitsNeeded) - 1;\n        while (true) {\n            const int = randomUint32() & bitMask;\n            if (int < range)\n                return minInclusive + int;\n        }\n    };\n    return { integer, float };\n}\n","import {} from \"./types.js\";\n/**\n * Returns a string of random letters and numbers of a given `length`.\n *\n * ```js\n * string();  // Random string of length 5\n * string(4); // eg. `4afd`\n * ```\n * @param lengthOrOptions Length of random string, or options.\n * @returns Random string\n */\nexport const string = (lengthOrOptions = 5) => {\n    const options = typeof lengthOrOptions === `number` ? { length: lengthOrOptions } : lengthOrOptions;\n    const calculate = options.source ?? Math.random;\n    const length = options.length ?? 5;\n    let returnValue = ``;\n    while (returnValue.length < length) {\n        returnValue += calculate()\n            .toString(36)\n            .slice(2);\n    }\n    return returnValue.substring(0, length);\n};\n","import { integer, integerSource } from \"./integer.js\";\n/**\n * Returns a random number of minutes, with a unit of milliseconds.\n *\n * Max value is exclusive, defaulting to 5.\n * Use {@link minutesMs} to get a value directly, or {@link minutesMsSource} to return a function.\n *\n * @example Random value from 0 to one milli less than 5 * 60 * 1000\n * ```js\n * // Create function that returns value\n * const f = minutesMsSource(5);\n *\n * f(); // Generate value\n * ```\n *\n * @example Specified options:\n * ```js\n * // Random time between one minute and 5 minutes\n * const f = minutesMsSource({ max: 5, min: 1 });\n * f();\n * ```\n *\n * @remarks\n * It's a very minor function, but can make\n * code a little more literate:\n * ```js\n * // Random timeout of up to 5 mins\n * setTimeout(() => { ... }, minutesMsSource(5));\n * ```\n * @param maxMinutesOrOptions\n * @see {@link minutesMs}\n * @returns Function that produces a random value\n */\nexport const minutesMsSource = (maxMinutesOrOptions) => {\n    const options = typeof maxMinutesOrOptions === `number`\n        ? { max: maxMinutesOrOptions }\n        : maxMinutesOrOptions;\n    const min = (options.min ?? 0) * 60 * 1000;\n    const max = (options.max ?? 5) * 60 * 1000;\n    return integerSource({ ...options, max, min });\n};\n/**\n * Return a random time value in milliseconds, using minute values to set range.\n *\n * @example Random value from 0 to one milli less than 5 * 60 * 1000\n * ```js\n * // Random value from 0 to one milli less than 5*60*1000\n * minuteMs(5);\n * ```\n *\n * @example Specified options:\n * ```js\n * // Random time between one minute and 5 minutes\n * minuteMs({ max: 5, min: 1 });\n * ```\n *\n * @param maxMinutesOrOptions\n * @see {@link minutesMsSource}\n * @returns Milliseconds\n */\nexport const minutesMs = (maxMinutesOrOptions) => minutesMsSource(maxMinutesOrOptions)();\n/**\n * Returns function which produces a random number of seconds, with a unit of milliseconds.\n *\n * Maximum value is exclusive, defaulting to 5\n * Use {@link secondsMs} to return a random value directly, or {@link secondsMsSource} to return a function.\n *\n * @example Random milliseconds between 0..4999\n * ```js\n * // Create function\n * const f = secondsMsSource(5000);\n * // Produce a value\n * const value = f();\n * ```\n *\n * @example Options can be provided\n * ```js\n * // Random milliseconds between 1000-4999\n * const value = secondsMsSource({ max:5, min:1 })();\n * // Note the extra () at the end to execute the function\n * ```\n *\n * @remarks\n * It's a very minor function, but can make\n * code a little more literate:\n * ```js\n * // Random timeout of up to 5 seconds\n * setTimeout(() => { ...}, secondsMsSource(5));\n * ```\n * @param maxSecondsOrOptions Maximum seconds, or options.\n * @returns Milliseconds\n */\nexport const secondsMsSource = (maxSecondsOrOptions) => {\n    const options = typeof maxSecondsOrOptions === `number`\n        ? { max: maxSecondsOrOptions }\n        : maxSecondsOrOptions;\n    const min = (options.min ?? 0) * 1000;\n    const max = (options.max ?? 5) * 1000;\n    return () => integer({ ...options, max, min });\n};\n/**\n * Generate random time in milliseconds, using seconds to set the bounds\n *\n * @example Random milliseconds between 0..4999\n * ```js\n * secondsMs(5000);\n * ```\n *\n * @example Options can be provided\n * ```js\n * // Random milliseconds between 1000-4999\n * secondsMs({ max:5, min:1 });\n * ```\n * @param maxSecondsOrOptions\n * @returns\n */\nexport const secondsMs = (maxSecondsOrOptions) => secondsMsSource(maxSecondsOrOptions)();\n","export function clamp(v, min = 0, max = 1) {\n    if (v < min)\n        return min;\n    if (v > max)\n        return max;\n    return v;\n}\n","import {} from \"./types.js\";\nimport { clamp } from \"./util/clamp.js\";\n/**\n * Random integer, weighted according to an easing function.\n * Number will be inclusive of `min` and below `max`.\n *\n * @example 0..99\n * ```js\n * const r = Random.weightedIntegerFn(100);\n * r(); // Produce value\n * ```\n *\n * @example 20..29\n * ```js\n * const r = Random.weightedIntegerFn({ min: 20, max: 30 });\n * r(); // Produce value\n * ```\n *\n * @example  0..99 with 'quadIn' easing\n * ```js\n * const r = Random.weightedInteger({ max: 100, easing: `quadIn` });\n * ```\n *\n * Note: result from easing function will be clamped to\n * the min/max (by default 0-1);\n *\n * @param options Options. By default { max:1, min: 0 }\n * @returns Function that produces a random weighted integer\n */\nexport const weightedIntegerSource = (options) => {\n    const source = options.source ?? Math.random;\n    if (typeof options.easingFunction === `undefined`)\n        throw new Error(`Param 'easingFunction' is undefined`);\n    const max = options.max ?? 1;\n    const min = options.min ?? 0;\n    if (max === min)\n        throw new Error(`Param 'max' is the same as  'min'`);\n    if (max < min)\n        throw new Error(`Param 'max' should be greater than  'min'`);\n    const compute = () => {\n        const r = clamp(options.easingFunction(source()));\n        return Math.floor(r * (max - min)) + min;\n    };\n    return compute;\n};\n/**\n * Generate a weighted-random integer.\n *\n * @example 0..99\n * ```js\n * Random.weightedInteger(100);\n * ```\n *\n * @example 20..29\n * ```js\n * Random.weightedInteger({ min: 20, max: 30 });\n * ```\n *\n * @example  0..99 with 'quadIn' easing\n * ```js\n * Random.weightedInteger({ max: 100, easing: `quadIn` })\n * ```\n * @param options Options. Default: { max: 1, min: 0 }\n * @returns Random weighted integer\n */\nexport const weightedInteger = (options) => weightedIntegerSource(options)();\n","import {} from './types.js';\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * See @ixfx/modulation.weighted to use a named easing function.\n * Use {@link weightedSource} to return a function instead.\n *\n * @see {@link weightedSource} Returns a function rather than value\n * @returns Random number (0-1)\n */\nexport const weighted = (options) => weightedSource(options)();\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * See @ixfx/modulation.weighted to use a named easing function.\n * Use {@link weighted} to get a value directly.\n *\n * @see {@link weighted} Returns value instead of function\n * @returns Function which returns a weighted random value\n */\nexport const weightedSource = (options) => {\n    const source = options.source ?? Math.random;\n    if (typeof options.easing !== `undefined`)\n        throw new Error(`Param 'easingName' unavailable. Use @ixfx/modulation.weighted instead.`);\n    if (typeof options.easingFunction === `undefined`)\n        throw new Error(`Param 'easingFunction' is undefined`);\n    return () => options.easingFunction(source());\n};\n","export * from './arrays.js';\nexport * from './chance.js';\nexport * from './float-source.js';\nexport * from './gaussian.js';\nexport * from './guid.js';\nexport * from './integer.js';\nexport * from './non-zero.js';\nexport * from './seeded.js';\nexport * from './string.js';\nexport * from './time.js';\nexport * from './types.js';\nexport * from './weighted-index.js';\nexport * from './weighted-integer.js';\nexport * from './weighted.js';\n// export { randomElement as arrayElement } from '../data/arrays/Random.js';\n// export { randomHue as hue } from '../visual/colour/index.js';\n// export { randomIndex as arrayIndex } from '../data/arrays/Random.js';\n","/**\n * Run a function if a value changes\n * ```js\n * const r = handleChangeResult(trackNumberChange, (value) => {\n *  // Called when value changes\n * });\n * r(10);\n * ```\n * @param monitor\n * @param onChanged\n * @param onNotChanged\n * @returns\n */\nexport function handleChangeResult(monitor, onChanged, onNotChanged) {\n    return (v) => {\n        const r = monitor(v);\n        if (r.changed) {\n            onChanged(v, r.changes, r.total);\n        }\n        else if (typeof onNotChanged !== `undefined`) {\n            onNotChanged(v, r.identicalRun, r.total);\n        }\n    };\n}\n/**\n * Returns a function to monitor value changes.\n * ```js\n * const f = trackNumberChange(true);\n * f(10); // { changed: true, changesCount: 1 }\n * f(10); // { changed: false, changesCount: 1 }\n * ```\n *\n * Default options:\n * * nanHandling: error\n * * includeFirstValueInCount: false\n *\n * NaN handling:\n * * allow: use NaN value as a legal value and report a change\n * * skip: ignore NaN values, reporting back no change and use the same changes count\n * * error: throw an error if a NaN value is received\n *\n *\n * @returns\n */\nexport function trackNumberChange(options = {}) {\n    const nanHandling = options.nanHandling ?? `error`;\n    const includeFirstValueInCount = options.includeFirstValueInCount ?? false;\n    let lastValue = options.initial;\n    let changes = 0;\n    let total = 0;\n    let identicalRun = 0;\n    return (v) => {\n        if (typeof v !== `number`)\n            throw new TypeError(`Parameter should be number. Got type: ${typeof v}`);\n        if (Number.isNaN(v)) {\n            switch (nanHandling) {\n                case `error`:\n                    throw new Error(`Parameter is NaN`);\n                case `skip`:\n                    return { changed: false, changes, total, identicalRun };\n            }\n        }\n        total++;\n        let eq = lastValue === v;\n        // Because two NaNs don't equal (!?)\n        if (Number.isNaN(lastValue) && Number.isNaN(v))\n            eq = true;\n        if (!eq) {\n            identicalRun = 0;\n            if (lastValue !== undefined || includeFirstValueInCount) {\n                changes++;\n            }\n            lastValue = v;\n            return { changed: true, changes, total, identicalRun };\n        }\n        else {\n            identicalRun++;\n        }\n        return { changed: false, changes, total, identicalRun };\n    };\n}\n/**\n * Returns a function to track changes in a boolean value\n * ```js\n * const t = trackBooleanChange();\n * t(true); // { changed:false }\n * t(true); // { changed:false }\n * t(false); // { changed: true }\n * ```\n *\n * Default options:\n * * includeFirstValueInCount: false\n * @param options\n * @returns\n */\nexport function trackBooleanChange(options = {}) {\n    const includeFirstValueInCount = options.includeFirstValueInCount ?? false;\n    let lastValue = options.initial;\n    let changes = 0;\n    let total = 0;\n    let identicalRun = 0;\n    return (v) => {\n        if (typeof v !== `boolean`)\n            throw new TypeError(`Parameter should be boolean. Got type: ${typeof v}`);\n        total++;\n        if (lastValue !== v) {\n            identicalRun = 0;\n            if (lastValue !== undefined || includeFirstValueInCount) {\n                changes++;\n            }\n            lastValue = v;\n            return { changed: true, changes, total, identicalRun };\n        }\n        else {\n            identicalRun++;\n        }\n        return { changed: false, changes, total, identicalRun };\n    };\n}\n","import { keyValueSorter } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { numberArrayCompute } from '@ixfx/numbers';\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = new FrequencyTracker();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = new FrequencyTracker();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequency( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @typeParam V - Type of items\n */\nexport class FrequencyTracker extends SimpleEventEmitter {\n    #store;\n    #keyString;\n    /**\n     * Constructor\n     * @param keyString Function to key items. Uses JSON.stringify by default\n     */\n    constructor(keyString) {\n        super();\n        this.#store = new Map();\n        if (typeof keyString === `undefined`) {\n            keyString = (a) => {\n                if (a === undefined)\n                    throw new Error(`Cannot create key for undefined`);\n                return typeof a === `string` ? a : JSON.stringify(a);\n            };\n        }\n        this.#keyString = keyString;\n    }\n    /**\n     * Clear data. Fires `change` event\n     */\n    clear() {\n        this.#store.clear();\n        this.fireEvent(`change`, { context: this });\n    }\n    /**\n     * @returns Iterator over keys (ie. groups)\n     */\n    keys() {\n        return this.#store.keys();\n    }\n    /**\n     * @returns Iterator over frequency counts\n     */\n    values() {\n        return this.#store.values();\n    }\n    /**\n     * @returns Copy of entries as an array of `[key, count]`\n     */\n    toArray() {\n        return [...this.#store.entries()];\n    }\n    /**\n     * Returns a string with keys and counts, useful for debugging.\n     * @returns\n     */\n    debugString() {\n        let t = ``;\n        for (const [key, count] of this.#store.entries()) {\n            t += `${key}: ${count.toString()}, `;\n        }\n        if (t.endsWith(`, `))\n            return t.slice(0, Math.max(0, t.length - 2));\n        return t;\n    }\n    /**\n     *\n     * @param value Value to count\n     * @returns Frequency of value, or _undefined_ if it does not exist\n     */\n    frequencyOf(value) {\n        if (typeof value === `string`)\n            return this.#store.get(value);\n        const key = this.#keyString(value);\n        return this.#store.get(key);\n    }\n    /**\n     *\n     * @param value Value to count\n     * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n     */\n    relativeFrequencyOf(value) {\n        let freq;\n        if (typeof value === `string`)\n            freq = this.#store.get(value);\n        else {\n            const key = this.#keyString(value);\n            freq = this.#store.get(key);\n        }\n        if (freq === undefined)\n            return;\n        const mma = this.computeValues();\n        return freq / mma.total;\n    }\n    /**\n     * Returns copy of entries as an array\n     * @returns Copy of entries as an array\n     */\n    entries() {\n        return [...this.#store.entries()];\n    }\n    /**\n     * Calculate min,max,avg,total & count from values\n     * @returns Returns `{min,max,avg,total}`\n     */\n    computeValues() {\n        const valuesAsNumbers = [...this.values()];\n        return numberArrayCompute(valuesAsNumbers);\n    }\n    /**\n     * Return entries sorted\n     * @param sortStyle Sorting style (default: _value_, ie. count)\n     * @returns Sorted array of [key,frequency]\n     */\n    entriesSorted(sortStyle = `value`) {\n        const s = keyValueSorter(sortStyle);\n        return s(this.entries());\n    }\n    /**\n     * Add one or more values, firing _change_ event.\n     * @param values Values to add. Fires _change_ event after adding item(s)\n     */\n    add(...values) {\n        if (typeof values === `undefined`)\n            throw new Error(`Param 'values' undefined`);\n        const keys = values.map(v => this.#keyString(v));\n        //const key = this.#keyString(value);\n        for (const key of keys) {\n            const score = this.#store.get(key) ?? 0;\n            this.#store.set(key, score + 1);\n        }\n        this.fireEvent(`change`, { context: this });\n    }\n}\nexport const frequency = (keyString) => new FrequencyTracker(keyString);\n","/**\n * Base tracker class\n */\nexport class TrackerBase {\n    /**\n     * @ignore\n     */\n    seenCount;\n    /**\n     * @ignore\n     */\n    storeIntermediate;\n    /**\n     * @ignore\n     */\n    resetAfterSamples;\n    /**\n     * @ignore\n     */\n    sampleLimit;\n    id;\n    debug;\n    constructor(opts = {}) {\n        this.id = opts.id ?? `tracker`;\n        this.debug = opts.debug ?? false;\n        this.sampleLimit = opts.sampleLimit ?? -1;\n        this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n        this.storeIntermediate =\n            opts.storeIntermediate ??\n                (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n        this.seenCount = 0;\n        if (this.debug) {\n            console.log(`TrackerBase: sampleLimit: ${this.sampleLimit} resetAfter: ${this.resetAfterSamples} store: ${this.storeIntermediate}`);\n        }\n    }\n    /**\n     * Reset tracker\n     */\n    reset() {\n        this.seenCount = 0;\n        this.onReset();\n    }\n    /**\n     * Adds a value, returning computed result.\n     *\n     * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.\n     * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is\n     * called to take it down to sample limit, and `onTrimmed()` is called.\n     * @param p\n     * @returns\n     */\n    seen(...p) {\n        if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n            this.reset();\n        }\n        else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n            this.seenCount = this.trimStore(this.sampleLimit);\n            this.onTrimmed(`resize`);\n        }\n        this.seenCount += p.length;\n        const t = this.filterData(p);\n        return this.computeResults(t);\n    }\n}\n","import { TrackerBase } from \"./tracker-base.js\";\nexport class PrimitiveTracker extends TrackerBase {\n    values;\n    timestamps;\n    constructor(opts) {\n        super(opts);\n        this.values = [];\n        this.timestamps = [];\n    }\n    /**\n     * Reduces size of value store to `limit`. Returns\n     * number of remaining items\n     * @param limit\n     */\n    trimStore(limit) {\n        if (limit >= this.values.length)\n            return this.values.length;\n        this.values = this.values.slice(-limit);\n        this.timestamps = this.timestamps.slice(-limit);\n        return this.values.length;\n    }\n    onTrimmed(reason) {\n        // no-op\n    }\n    get last() {\n        return this.values.at(-1);\n    }\n    get initial() {\n        return this.values.at(0);\n    }\n    /**\n     * Returns number of recorded values (this can include the initial value)\n     */\n    get size() {\n        return this.values.length;\n    }\n    /**\n     * Returns the elapsed time, in milliseconds since the instance was created\n     */\n    get elapsed() {\n        if (this.values.length < 0)\n            throw new Error(`No values seen yet`);\n        return Date.now() - this.timestamps[0];\n    }\n    onReset() {\n        this.values = [];\n        this.timestamps = [];\n    }\n    /**\n     * Tracks a value\n     */\n    filterData(rawValues) {\n        const lastValue = rawValues.at(-1);\n        const last = { value: lastValue, at: performance.now() };\n        const values = rawValues.map(value => ({\n            at: performance.now(),\n            value: value\n        }));\n        //const now = Date.now();\n        if (this.storeIntermediate) {\n            this.values.push(...rawValues);\n            this.timestamps.push(...values.map(v => v.at));\n        }\n        else\n            switch (this.values.length) {\n                case 0: {\n                    // Add as initial value\n                    this.values.push(last.value);\n                    this.timestamps.push(last.at);\n                    break;\n                }\n                case 2: {\n                    // Replace last value\n                    this.values[1] = last.value;\n                    this.timestamps[1] = last.at;\n                    break;\n                }\n                case 1: {\n                    // Add last value\n                    this.values.push(last.value);\n                    this.timestamps.push(last.at);\n                    break;\n                }\n                // No default\n            }\n        return values;\n    }\n}\n","import { PrimitiveTracker } from \"./primitive-tracker.js\";\nimport { minFast, maxFast, totalFast } from \"@ixfx/numbers\";\nexport class NumberTracker extends PrimitiveTracker {\n    total = 0;\n    min = Number.MAX_SAFE_INTEGER;\n    max = Number.MIN_SAFE_INTEGER;\n    get avg() {\n        return this.total / this.seenCount;\n    }\n    /**\n     * Difference between last value and initial.\n     * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)\n     * If either of those is missing, undefined is returned\n     */\n    difference() {\n        if (this.last === undefined)\n            return;\n        if (this.initial === undefined)\n            return;\n        return this.last - this.initial;\n    }\n    /**\n     * Relative difference between last value and initial.\n     * Eg if last value was 10 and initial value was 5, 2 is returned (200%)\n     */\n    relativeDifference() {\n        if (this.last === undefined)\n            return;\n        if (this.initial === undefined)\n            return;\n        return this.last / this.initial;\n    }\n    onReset() {\n        this.min = Number.MAX_SAFE_INTEGER;\n        this.max = Number.MIN_SAFE_INTEGER;\n        this.total = 0;\n        super.onReset();\n    }\n    /**\n     * When trimmed, recomputes to set total/min/max to be based on\n     * current values.\n     * @param reason\n     */\n    onTrimmed(reason) {\n        this.min = minFast(this.values);\n        this.max = maxFast(this.values);\n        this.total = totalFast(this.values);\n    }\n    computeResults(values) {\n        if (values.some((v) => Number.isNaN(v)))\n            throw new Error(`Cannot add NaN`);\n        const numbers = values.map(value => value.value);\n        this.total = numbers.reduce((accumulator, v) => accumulator + v, this.total);\n        this.min = Math.min(...numbers, this.min);\n        this.max = Math.max(...numbers, this.max);\n        const r = {\n            max: this.max,\n            min: this.min,\n            total: this.total,\n            avg: this.avg\n        };\n        return r;\n    }\n    getMinMaxAvg() {\n        return {\n            min: this.min,\n            max: this.max,\n            avg: this.avg,\n        };\n    }\n}\n/**\n * Keeps track of the total, min, max and avg in a stream of values. By default values\n * are not stored.\n *\n * Usage:\n *\n * ```js\n * import { number } from '@ixfx/trackers.js';\n *\n * const t = number();\n * t.seen(10);\n *\n * t.avg / t.min/ t.max\n * t.initial; // initial value\n * t.size;    // number of seen values\n * t.elapsed; // milliseconds since intialisation\n * t.last;    // last value\n * ```\n *\n * To get `{ avg, min, max, total }`\n * ```\n * t.getMinMax()\n * ```\n *\n * Use `t.reset()` to clear everything.\n *\n * Trackers can automatically reset after a given number of samples\n * ```\n * // reset after 100 samples\n * const t = number({ resetAfterSamples: 100 });\n * ```\n *\n * To store values, use the `storeIntermediate` option:\n *\n * ```js\n * const t = number({ storeIntermediate: true });\n * ```\n *\n * Difference between last value and initial value:\n * ```js\n * t.relativeDifference();\n * ```\n *\n * Get raw data (if it is being stored):\n * ```js\n * t.values; // array of numbers\n * t.timestampes; // array of millisecond times, indexes correspond to t.values\n * ```\n */\nexport const number = (opts = {}) => new NumberTracker(opts);\n","import { NumberTracker } from './number-tracker.js';\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n */\nexport class IntervalTracker extends NumberTracker {\n    lastMark = 0;\n    mark() {\n        if (this.lastMark > 0) {\n            this.seen(performance.now() - this.lastMark);\n        }\n        this.lastMark = performance.now();\n    }\n}\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { interval } from '@ixfx/trackers.js';\n *\n * const t = interval();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = interval({ resetAfterSamples: 100} );\n * ```\n * @param options Options for tracker\n * @returns New interval tracker\n */\nexport const interval = (options) => new IntervalTracker(options);\n","import { timeout } from \"@ixfx/flow\";\n/**\n * Tracks the rate of events.\n * It's also able to compute the min,max and average interval between events.\n *\n * @example\n * ```js\n * const clicks = Trackers.rate();\n *\n * // Mark when a click happens\n * document.addEventListener(`click`, () => clicks.mark());\n *\n * // Get details\n * clicks.perSecond; // How many clicks per second\n * clicks.perMinute; // How many clicks per minute\n * ```\n *\n * `timeoutInterval` is a useful option to make the tracker reset\n * after some period without `mark()` being called.\n *\n * Another useful option is `sampleLimit`, which sets an upper bound\n * for how many events to track. A smaller value means the results\n * will more accurately track, but it might be less smooth.\n *\n * ```js\n * // Eg reset tracker after 5 seconds of inactivity\n * const clicks = Trackers.rate({\n *  sampleLimit: 10,\n *  timeoutInterval: { secs: 5 }\n * });\n * ```\n */\nexport class RateTracker {\n    #events = [];\n    #fromTime;\n    #resetAfterSamples;\n    #sampleLimit;\n    #resetTimer;\n    constructor(opts = {}) {\n        this.#resetAfterSamples = opts.resetAfterSamples ?? Number.MAX_SAFE_INTEGER;\n        this.#sampleLimit = opts.sampleLimit ?? Number.MAX_SAFE_INTEGER;\n        if (opts.timeoutInterval) {\n            this.#resetTimer = timeout(() => {\n                this.reset();\n            }, opts.timeoutInterval);\n        }\n        this.#fromTime = performance.now();\n    }\n    /**\n     * Mark that an event has happened\n     */\n    mark() {\n        if (this.#events.length >= this.#resetAfterSamples) {\n            this.reset();\n        }\n        else if (this.#events.length >= this.#sampleLimit) {\n            this.#events = this.#events.slice(1);\n            this.#fromTime = this.#events[0];\n        }\n        this.#events.push(performance.now());\n        if (this.#resetTimer) {\n            this.#resetTimer.start();\n        }\n    }\n    /**\n     * Compute {min,max,avg} for the interval _between_ events.\n     * @returns\n     */\n    computeIntervals() {\n        const intervals = [];\n        let min = Number.MAX_SAFE_INTEGER;\n        let max = Number.MIN_SAFE_INTEGER;\n        let total = 0;\n        let count = 0;\n        let start = 0;\n        for (const event of this.#events) {\n            if (count > 0) {\n                const index = event - start;\n                min = Math.min(index, min);\n                max = Math.max(index, max);\n                total += index;\n                intervals.push(index);\n            }\n            start = event;\n            count++;\n        }\n        const avg = total / count;\n        return {\n            min, max, avg\n        };\n    }\n    /**\n     * Returns the time period (in milliseconds) that encompasses\n     * the data set. Eg, a result of 1000 means there's data that\n     * covers a one second period.\n     */\n    get elapsed() {\n        return performance.now() - this.#fromTime;\n    }\n    /**\n     * Resets the tracker.\n     */\n    reset() {\n        this.#events = [];\n        this.#fromTime = performance.now();\n    }\n    /**\n     * Get the number of events per second\n     */\n    get perSecond() {\n        return this.#events.length / (this.elapsed / 1000);\n    }\n    /**\n     * Get the number of events per minute\n     */\n    get perMinute() {\n        return this.#events.length / (this.elapsed / 1000 / 60);\n    }\n}\n/**\n * @inheritdoc RateTracker\n * @param opts\n * @returns\n */\nexport const rate = (opts = {}) => new RateTracker(opts);\n","import { TrackerBase } from './tracker-base.js';\n/**\n * A tracked value of type `V`.\n */\nexport class ObjectTracker extends TrackerBase {\n    values;\n    constructor(opts = {}) {\n        super(opts);\n        this.values = [];\n    }\n    onTrimmed(reason) {\n        // no-op\n    }\n    /**\n     * Reduces size of value store to `limit`.\n     * Returns number of remaining items\n     * @param limit\n     */\n    trimStore(limit) {\n        if (limit >= this.values.length)\n            return this.values.length;\n        // Index 0 will be the oldest\n        this.values = this.values.slice(-limit);\n        return this.values.length;\n    }\n    /**\n     * Allows sub-classes to be notified when a reset happens\n     * @ignore\n     */\n    onReset() {\n        this.values = [];\n    }\n    /**\n     * Tracks a value\n     * @ignore\n     */\n    filterData(p) {\n        // Make sure values have a timestamp\n        const ts = p.map((v) => `at` in v\n            ? v\n            : {\n                ...v,\n                at: Date.now(),\n            });\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const last = ts.at(-1);\n        if (this.storeIntermediate)\n            this.values.push(...ts);\n        else\n            switch (this.values.length) {\n                case 0: {\n                    // Add as initial value\n                    this.values.push(last);\n                    break;\n                }\n                case 1: {\n                    // Add last value\n                    this.values.push(last);\n                    break;\n                }\n                case 2: {\n                    // Replace last value\n                    this.values[1] = last;\n                    break;\n                }\n            }\n        return ts;\n    }\n    /**\n     * Last seen value. If no values have been added, it will return the initial value\n     */\n    get last() {\n        if (this.values.length === 1)\n            return this.values[0];\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.values.at(-1);\n    }\n    /**\n     * Returns the oldest value in the buffer\n     */\n    get initial() {\n        return this.values.at(0);\n    }\n    /**\n     * Returns number of recorded values (includes the initial value in the count)\n     */\n    get size() {\n        return this.values.length;\n    }\n    /**\n     * Returns the elapsed time, in milliseconds since the initial value\n     */\n    get elapsed() {\n        return Date.now() - this.values[0].at;\n    }\n}\n","import { getOrGenerate } from '@ixfx/core/maps';\nimport { TrackerBase } from './tracker-base.js';\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class PointsTracker extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap {\n    store;\n    gog;\n    constructor(creator) {\n        this.store = new Map();\n        this.gog = getOrGenerate(this.store, creator);\n    }\n    /**\n     * Number of named values being tracked\n     */\n    get size() {\n        return this.store.size;\n    }\n    /**\n     * Returns _true_ if `id` is stored\n     * @param id\n     * @returns\n     */\n    has(id) {\n        return this.store.has(id);\n    }\n    /**\n     * For a given id, note that we have seen one or more values.\n     * @param id Id\n     * @param values Values(s)\n     * @returns Information about start to last value\n     */\n    async seen(id, ...values) {\n        const trackedValue = await this.getTrackedValue(id, ...values);\n        // Pass it over to the TrackedValue\n        const result = trackedValue.seen(...values);\n        return result;\n    }\n    /**\n     * Creates or returns a TrackedValue instance for `id`.\n     * @param id\n     * @param values\n     * @returns\n     */\n    async getTrackedValue(id, ...values) {\n        if (id === null)\n            throw new Error(`id parameter cannot be null`);\n        if (id === undefined)\n            throw new Error(`id parameter cannot be undefined`);\n        // Create or recall TrackedValue by id\n        const trackedValue = await this.gog(id, values[0]);\n        return trackedValue;\n    }\n    /**\n     * Remove a tracked value by id.\n     * Use {@link reset} to clear them all.\n     * @param id\n     */\n    delete(id) {\n        this.store.delete(id);\n    }\n    /**\n     * Remove all tracked values.\n     * Use {@link delete} to remove a single value by id.\n     */\n    reset() {\n        this.store = new Map();\n    }\n    /**\n     * Enumerate ids\n     */\n    *ids() {\n        yield* this.store.keys();\n    }\n    /**\n     * Enumerate tracked values\n     */\n    *tracked() {\n        yield* this.store.values();\n    }\n    /**\n     * Iterates TrackedValues ordered with oldest first\n     * @returns\n     */\n    *trackedByAge() {\n        const tp = [...this.store.values()];\n        tp.sort((a, b) => {\n            const aa = a.elapsed;\n            const bb = b.elapsed;\n            if (aa === bb)\n                return 0;\n            if (aa > bb)\n                return -1;\n            return 1;\n        });\n        for (const t of tp) {\n            yield t;\n        }\n    }\n    /**\n     * Iterates underlying values, ordered by age (oldest first)\n     * First the named values are sorted by their `elapsed` value, and then\n     * we return the last value for that group.\n     */\n    *valuesByAge() {\n        for (const tb of this.trackedByAge()) {\n            yield tb.last;\n        }\n    }\n    /**\n     * Enumerate last received values\n     *\n     * @example Calculate centroid of latest-received values\n     * ```js\n     * const pointers = pointTracker();\n     * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n     * ```\n     */\n    *last() {\n        for (const p of this.store.values()) {\n            yield p.last;\n        }\n    }\n    /**\n     * Enumerate starting values\n     */\n    *initialValues() {\n        for (const p of this.store.values()) {\n            yield p.initial;\n        }\n    }\n    /**\n     * Returns a tracked value by id, or undefined if not found\n     * @param id\n     * @returns\n     */\n    get(id) {\n        return this.store.get(id);\n    }\n}\n","export * from './changes.js';\nexport * from './frequency-mutable.js';\nexport * from './interval-tracker.js';\nexport * from './number-tracker.js';\nexport * from './rate-tracker.js';\nexport * from \"./object-tracker.js\";\nexport * from './primitive-tracker.js';\nexport * from \"./tracked-value.js\";\nexport * from './tracker-base.js';\nexport * from './types.js';\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x' + y')^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z') + (z'x\" - z\"x') + (x'y\" - x\"y'))\n    //   k(t) = -------------------------------------------------------\n    //                     (x' + y' + z')^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n"],"x_google_ignoreList":[26,27,28],"mappings":"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"}