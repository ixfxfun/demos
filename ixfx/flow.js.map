{"version":3,"file":"flow.js","names":["rateMinimum","t: BtNode","pathPrefix?: string","n: BtNode","callback: () => Promise<V>","optsOrMillis: DelayOpts | number","resolve: ((value?: undefined) => void) | undefined","resolve","timeout: Interval","timeout","timer: ReturnType<typeof globalThis.setTimeout> | undefined","timeout","callback: TimeoutSyncCallback | TimeoutAsyncCallback","interval: Interval","timer: ReturnType<typeof setTimeout>","state: HasCompletionRunStates","altInterval: Interval","args: unknown[]","resolve","callback: TimeoutSyncCallback | TimeoutAsyncCallback","interval: Interval","timeout","#id","#handlers","handler: Dispatch<V>","options: { once?: boolean }","#counter","wrap: DispatchEntry<V>","id: string","value: V","nth: number","callback?: (data: T) => void","data: T","expressions:\n    | ExpressionOrResult<ArgsType, ResultType>[]\n    | ExpressionOrResult<ArgsType, ResultType>\n    | readonly ExpressionOrResult<ArgsType, ResultType>[]","opts: RunOpts<ResultType>","args?: ArgsType","results: ResultType[]","r: ResultType","expressions: readonly ExpressionOrResult<ArgsType, ResultType>[]","opts: RunSingleOpts<ResultType>","target: EventTarget","eventNames: string[]","options: Partial<{ timeoutMs: number, signal: AbortSignal }>","timeout: ReturnType<typeof setTimeout> | undefined","resolve","event: Event","timeout","options: MovingAverageTimedOptions","rateMinimum","distance: number","v: number","key: string","resource: Resource<V>","reason: string","data: V","#capacityPerResource","#resourcesWithoutUserExpireAfterMs","pool: Pool<V>","#data","#lastUsersChange","#users","#state","user: PoolUser<V>","options: PoolOptions<V>","r","resource: V","nuke: Resource<V>[]","userKeysToRemove: string[]","userKey: string","reason?: string","_: string","#allocateResource","resolve: undefined | ((value: T) => void)","reject: undefined | ((reason: any) => void)","resolve","options: RateMinimumOptions<TInput>","timeout","args: TInput","produce: ResolveToValue<T> | ArrayLike<T>","opts: RepeatDelayOpts","produce: ResolveToValueSync<T> | ArrayLike<T>","opts: RepeatOpts","options: Partial<RequestResponseOptions<TRequest, TResp>>","#maintainLoop","#maintain","#outgoing","request: TRequest","callback?: (error: boolean, response: TResp | string) => void","#requestCallback","#requestAwait","r: SeenRequest<TRequest, TResp>","resolve","callback: (error: boolean, response: TResp | string) => void","response: TResp","keepAlive: boolean","options: Partial<BackoffOptions>","callback: () => Promise<T | undefined>","options: Partial<RetryOpts<T>>","task: RetryTask<T>","task: RetryTask<V>","opts: Partial<RetryOpts<V>>","onRun: () => boolean","run","#resolve","#promise","#reject","resolve","maximumWaitMs?: number","#initPromise","maximumWaitMs: number","task: () => Promise<void>","callback: (\n    elapsedMs: number,\n    ...args: readonly unknown[]\n  ) => void | Promise<unknown>","intervalMinMs: number","elapsed: Interval","duration: Interval","opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean }","t: ModulationTimer | undefined","totalTicks: number","total: number","options: Partial<RelativeTimerOpts>","value: number","amt: number","frequency: number","options: Partial<TimerOpts>","fn: ((v: number) => number)","timer: CompletionTimer","fn: (elapsedMs?: number) => Promise<V>","interval: Interval","updateFail: UpdateFailPolicy","lastValue: V | undefined","resolve","#promise","#resolve","resolve","value: T","#written","timeoutMs: number","onAborted: (reason: string) => void","onComplete?: (success: boolean) => void","t: ReturnType<typeof globalThis.setTimeout> | undefined","error?: string","toClone: MachineState<V>","stateMachine: Machine<V> | Transitions | TransitionsStrict","initialState?: StateNames<V>","state: StateNames<V>","sm: MachineState<V>","smOrTransitions: Machine<V> | Transitions | TransitionsStrict","targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    | StateTargetStrict<V>","target: string | undefined | null | object","d: Transitions","state: MachineState<V>","toState: StateNames<V>","machine: Machine<V> | Transitions","handlersOrOpts: readonly DriverStatesHandler<V>[] | DriverOptions<V>","opts: DriverOptions<V>","runOpts: Execute.RunOpts<DriverResult<V>>","machineInit","run","latest: DriverResult<V> | undefined","r: DriverResult<V> | undefined","machineReset","machineNext","machineTo","state: StateNames<V>","m: V","opts: StateMachineWithEventsOptions<V>","#debug","#sm","#smInitial","v: boolean","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt","newState: StateNames<V>"],"sources":["../../flow/dist/src/rate-minimum.js","../../flow/src/behaviour-tree.ts","../../flow/src/delay.ts","../../flow/src/timeout.ts","../../flow/src/debounce.ts","../../flow/src/dispatch-list.ts","../../flow/src/every.ts","../../flow/src/execute.ts","../../flow/src/event-race.ts","../../flow/src/moving-average.ts","../../flow/src/pool.ts","../../flow/src/promise-with-resolvers.ts","../../flow/src/rate-minimum.ts","../../flow/src/repeat.ts","../../flow/src/req-resp-match.ts","../../flow/src/retry.ts","../../flow/src/run-once.ts","../../flow/src/sync-wait.ts","../../flow/src/task-queue-mutable.ts","../../flow/src/throttle.ts","../../flow/src/timer.ts","../../flow/src/update-outdated.ts","../../flow/src/wait-for-value.ts","../../flow/src/wait-for.ts","../../flow/src/state-machine/state-machine.ts","../../flow/src/state-machine/driver.ts","../../flow/src/state-machine/with-events.ts","../../flow/src/state-machine/index.ts"],"sourcesContent":["import { timeout } from \"./timeout.js\";\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n *\n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n *\n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n *\n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ```\n *\n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n *\n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n *\n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n *\n * @param options\n * @returns\n */\nexport const rateMinimum = (options) => {\n    let disposed = false;\n    const t = timeout(() => {\n        if (disposed)\n            return;\n        t.start();\n        options.whatToCall(options.fallback());\n    }, options.interval);\n    if (options.abort) {\n        options.abort.addEventListener(`abort`, _ => {\n            disposed = true;\n            t.cancel();\n        });\n    }\n    t.start();\n    return (args) => {\n        if (disposed)\n            throw new Error(`AbortSignal has been fired`);\n        t.start();\n        options.whatToCall(args);\n    };\n};\n","export type TaskState = `Failed` | `Running` | `Success`;\nexport type Task = {\n  readonly state: TaskState\n}\nexport type Traversal = readonly [\n  node: BtNode,\n  path: string\n];\n\n// Sequence runs children until the first one fails (serial)\n// Selector runs children until the first succeeds\n\n/**\n * Node can have conditions as to whether they should even be considered\n * Conditions can have dependencies on values, ideally this is responsive\n * Conditions might abort sibling nodes, as in example: https://docs.unrealengine.com/4.27/en-US/InteractiveExperiences/ArtificialIntelligence/BehaviorTrees/BehaviorTreesOverview/\n */\n\nexport type BtNodeBase = {\n  readonly name?: string\n}\n\nexport type SeqNode = BtNodeBase & {\n  readonly seq: ReadonlyArray<BtNode>\n}\nexport type SelNode = BtNodeBase & {\n  readonly sel: ReadonlyArray<BtNode>\n}\n\nexport type BtNode = SeqNode | SelNode | string;\n\nconst t: BtNode = {\n  name: `root`,\n  seq: [\n    `walk_to_door`,\n    {\n      name: `door_locked`,\n      sel: [\n        `open_door`,\n        {\n          name: `open_locked_door`,\n          seq: [ `unlock_door`, `open_door` ]\n        },\n        `smash_door` ]\n    },\n    `walk_through_door`,\n    `close_door`\n  ]\n};\n\n\n\nconst getName = (t: BtNode, defaultValue = ``) => {\n  if (typeof t === `object` && `name` in t && t.name !== undefined) return t.name;\n  return defaultValue;\n};\n\n//eslint-disable-next-line func-style\nexport function* iterateBreadth(t: BtNode, pathPrefix?: string): Generator<Traversal> {\n  if (typeof pathPrefix === `undefined`) {\n    pathPrefix = getName(t);\n  }\n\n  for (const [ index, n ] of entries(t)) {\n    yield [ n, pathPrefix ];\n  }\n  for (const [ index, n ] of entries(t)) {\n    const name = getName(n, `?`);\n    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n    yield* iterateBreadth(n, prefix);\n  }\n}\n\n//eslint-disable-next-line func-style\nexport function* iterateDepth(t: BtNode, pathPrefix?: string): Generator<Traversal> {\n  if (typeof pathPrefix === `undefined`) {\n    pathPrefix = getName(t);\n  }\n  for (const [ index, n ] of entries(t)) {\n    yield [ n, pathPrefix ];\n    const name = getName(n, `?`);\n    const prefix = pathPrefix.length > 0 ? pathPrefix + `.` + name : name;\n    yield* iterateBreadth(n, prefix);\n  }\n}\n\ntype ValidateOpts = {\n  readonly duplicatesAllowed: boolean\n}\n\n//eslint-disable-next-line func-style\nfunction isSeqNode(n: BtNode): n is SeqNode {\n  return (n as SeqNode).seq !== undefined;\n}\n\n//eslint-disable-next-line func-style\nfunction isSelNode(n: BtNode): n is SelNode {\n  return (n as SelNode).sel !== undefined;\n}\n\n//eslint-disable-next-line func-style\nfunction* entries(n: BtNode) {\n  if (isSeqNode(n)) {\n    yield* n.seq.entries();\n  } else if (isSelNode(n)) {\n    yield* n.sel.entries();\n  } else if (typeof n === `string`) {\n    // no-op\n  } else {\n    throw new TypeError(`Unexpected shape of node. seq/sel missing`);\n  }\n}\n\n// for (const tn of iterateBreadth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n\n// console.log(`---`);\n\n// for (const tn of iterateDepth(t)) {\n//   console.log(`Path: ${ tn[ 1 ] }`);\n//   console.log(`Node: ${ JSON.stringify(tn[ 0 ]) }`);\n// }\n","import { intervalToMs, type Interval } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n\n/**\n * Delay options\n */\nexport type DelayOpts = Interval & {\n  /**\n   * Signal for cancelling delay\n   */\n  readonly signal?: AbortSignal;\n  /**\n   * When delay is applied. \"before\" is default.\n   */\n  readonly delay?: `before` | `after` | `both`;\n};\n\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async <V>(\n  callback: () => Promise<V>,\n  //eslint-disable-next-line functional/prefer-immutable-types\n  optsOrMillis: DelayOpts | number\n): Promise<V> => {\n  const opts =\n    typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n  const delayWhen = opts.delay ?? `before`;\n  if (delayWhen === `before` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  const r = Promise.resolve(await callback());\n  if (delayWhen === `after` || delayWhen === `both`) {\n    await sleep(opts);\n  }\n  return r;\n};\n\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n\n//     // Yield value\n//     yield v;\n\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n * \n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n * \n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n * \n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n * \n * The below example shows how to do this.\n * \n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n * \n * // Execution continues while loop also runs\n * ```\n *\n */\n\nasync function* delayAnimationLoop() {\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer = 0;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.requestAnimationFrame(callback);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    globalThis.cancelAnimationFrame(timer);\n  }\n}\n\n/**\n * Async generator that loops at a given interval.\n * \n * @example \n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n * \n * @example \n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n * \n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport async function* delayLoop(timeout: Interval) {\n  const timeoutMs = intervalToMs(timeout);\n  if (typeof timeoutMs === `undefined`) throw new Error(`timeout is undefined`);\n  if (timeoutMs < 0) throw new Error(`Timeout is less than zero`);\n  if (timeoutMs === 0) return yield* delayAnimationLoop();\n\n  let resolve: ((value?: undefined) => void) | undefined;\n  let p = new Promise<undefined>((r) => (resolve = r));\n  let timer: ReturnType<typeof globalThis.setTimeout> | undefined;\n  const callback = () => {\n    if (resolve) resolve();\n    p = new Promise<undefined>((r) => (resolve = r));\n  };\n\n  try {\n    while (true) {\n      timer = globalThis.setTimeout(callback, timeoutMs);\n      // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n      const _ = await p;\n      yield _;\n    }\n  } finally {\n    if (resolve) resolve();\n    if (timer !== undefined) globalThis.clearTimeout(timer);\n    timer = undefined;\n  }\n}\n","import { integerTest, resultToError, resultIsError, resultThrow } from '@ixfx/guards';\nimport { type HasCompletion, type HasCompletionRunStates } from '@ixfx/core';\n\nimport { intervalToMs, type Interval } from '@ixfx/core';\n\nexport type TimeoutSyncCallback = (\n  elapsedMs?: number,\n  ...args: readonly unknown[]\n) => void;\nexport type TimeoutAsyncCallback = (\n  elapsedMs?: number,\n  ...args: readonly unknown[]\n) => Promise<void>;\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  /**\n   * Starts the timer.\n   * If the timer has already been started and has a scheduled execution, this is cancelled \n   * and re-scheduled.\n   * @param altTimeoutMs Optional override for the interval. Use _undefined_ to use the original interval\n   * @param args \n   */\n  start(altTimeoutMs?: number, args?: readonly unknown[]): void;\n  /**\n   * Cancels the timer, aborting any scheduled execution.\n   */\n  cancel(): void;\n};\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * \n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): Timeout => {\n  if (callback === undefined) {\n    throw new Error(`callback parameter is undefined`);\n  }\n  const intervalMs = intervalToMs(interval);\n  resultThrow(integerTest(intervalMs, `aboveZero`, `interval`));\n  let timer: ReturnType<typeof setTimeout>;\n  let startedAt = 0;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let state: HasCompletionRunStates = `idle`;\n\n  const clear = () => {\n    startedAt = 0;\n    globalThis.clearTimeout(timer);\n    state = `idle`;\n  }\n\n  const start = async (\n    altInterval: Interval = interval,\n    args: unknown[]\n  ): Promise<void> => {\n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      const altTimeoutMs = intervalToMs(altInterval);\n      const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      if (resultIsError(it)) {\n        reject(resultToError(it));\n        return;\n      }\n\n      switch (state) {\n        case `scheduled`: {\n          // Cancel other scheduled execution\n          cancel();\n          break;\n        }\n        case `running`: {\n          //console.warn(`Timeout being rescheduled while task is already running`);\n          break;\n        }\n      }\n      state = `scheduled`;\n\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      timer = globalThis.setTimeout(async () => {\n        if (state !== `scheduled`) {\n          console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n          clear();\n          return;\n        }\n        const args_ = args ?? [];\n        startCount++;\n        startCountTotal++;\n        state = `running`;\n        await callback(performance.now() - startedAt, ...args_);\n        state = `idle`\n        clear();\n        resolve();\n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (state === `idle`) return;\n    clear();\n  };\n\n  return {\n\n    start,\n    cancel,\n    get runState() {\n      return state;\n    },\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    }\n  };\n};\n\n\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });","import type { Interval } from '@ixfx/core';\n\nimport {\n  timeout,\n  type TimeoutSyncCallback,\n  type TimeoutAsyncCallback,\n} from './timeout.js';\n\n/**\n * Returns a debounce function which acts to filter calls to a given function `fn`.\n *\n * Eg, Let's create a debounced wrapped for a function:\n * ```js\n * const fn = () => console.log('Hello');\n * const debouncedFn = debounce(fn, 1000);\n * ```\n *\n * Now we can call `debouncedFn()` as often as we like, but it will only execute\n * `fn()` after 1 second has elapsed since the last invocation. It essentially filters\n * many calls to fewer calls. Each time `debounceFn()` is called, the timeout is\n * reset, so potentially `fn` could never be called if the rate of `debounceFn` being called\n * is faster than the provided timeout.\n *\n * Remember that to benefit from `debounce`, you must call the debounced wrapper, not the original function.\n *\n * ```js\n * // Create\n * const d = debounce(fn, 1000);\n *\n * // Don't do this if we want to benefit from the debounce\n * fn();\n *\n * // Use the debounced wrapper\n * d(); // Only calls fn after 1000s\n * ```\n *\n * A practical use for this is handling high-frequency streams of data, where we don't really\n * care about processing every event, only last event after a period. Debouncing is commonly\n * used on microcontrollers to prevent button presses being counted twice.\n *\n * @example Handle most recent pointermove event after 1000ms\n * ```js\n * // Set up debounced handler\n * const moveDebounced = debounce((elapsedMs, evt) => {\n *    // Handle event\n * }, 500);\n *\n * // Wire up event\n * el.addEventListener(`pointermove`, moveDebounced);\n * ```\n *\n * Arguments can be passed to the debounced function:\n *\n * ```js\n * const fn = (x) => console.log(x);\n * const d = debounce(fn, 1000);\n * d(10);\n * ```\n *\n * If the provided function is asynchronous, it's possible to await the debounced\n * version as well. If the invocation was filtered, it returns instantly.\n *\n * ```js\n * const d = debounce(fn, 1000);\n * await d();\n * ```\n * @param callback Function to filter access to\n * @param interval Minimum time between invocations\n * @returns Debounce function\n */\nexport const debounce = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): DebouncedFunction => {\n  const t = timeout(callback, interval);\n  return (...args: unknown[]) => { t.start(undefined, args); };\n};\n\n/**\n * Debounced function\n */\nexport type DebouncedFunction = (...args: readonly unknown[]) => void;\n","export type Dispatch<V> = (value: V) => void;\n\n/**\n * Dispatcher\n */\ntype DispatchEntry<V> = {\n  /**\n   * Handler function\n   */\n  readonly handler: Dispatch<V>\n  /**\n   * Generated id of entry\n   */\n  readonly id: string\n  /**\n   * If true, dispatcher is removed after first firing\n   */\n  readonly once: boolean\n}\n\n/**\n * Maintains a list of listeners to receive data\n * \n * ```js\n * const d = new DispatchList();\n * \n * // Eg: add a listener\n * d.add(v => {\n *  // Handle a value\n * });\n * \n * // Eg. send a value to all listeners\n * d.notify(`some value`);\n * ```\n */\nexport class DispatchList<V> {\n  #handlers: DispatchEntry<V>[]\n  #counter = 0;\n  readonly #id = Math.floor(Math.random() * 100);\n  constructor() {\n    this.#handlers = [];\n  }\n\n  /**\n   * Returns _true_ if list is empty\n   * @returns \n   */\n  isEmpty() {\n    return this.#handlers.length === 0;\n  }\n\n  /**\n   * Adds a handler. You get back an id which can be used\n   * to remove the handler later.\n   * \n   * Handlers can be added with 'once' flag set to _true_. This will\n   * automatically remove them after the first value is sent to them.\n   * @param handler \n   * @param options \n   * @returns \n   */\n  add(handler: Dispatch<V>, options: { once?: boolean } = {}): string {\n    this.#counter++;\n    const once = options.once ?? false;\n    const wrap: DispatchEntry<V> = {\n      id: `${ this.#id } - ${ this.#counter }`,\n      handler,\n      once\n    }\n    this.#handlers.push(wrap);\n    return wrap.id;\n  }\n\n  /**\n   * Remove a handler by its id.\n   * @param id \n   * @returns _True_ if handler was removed, _false_ if not found.\n   */\n  remove(id: string): boolean {\n    const length = this.#handlers.length;\n    this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n    return this.#handlers.length !== length;\n  }\n\n  /**\n   * Emit a value to all handlers\n   * @param value \n   */\n  notify(value: V) {\n    for (const handler of this.#handlers) {\n      handler.handler(value);\n      if (handler.once) {\n        this.remove(handler.id);\n      }\n    }\n  }\n\n  /**\n   * Remove all handlers\n   */\n  clear() {\n    this.#handlers = [];\n  }\n}","import { integerTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Returns true for every _n_th call, eg 2 for every second call.\n *\n * If `nth` is 1, returns true for everything. 0 will be false for everything.\n *\n * Usage:\n * ```js\n * const tenth = everyNth(10);\n * window.addEventListener(`pointermove`, evt => {\n *  if (!tenth(evt)) return; // Filter out\n *  // Continue processing, it is the 10th thing.\n *\n * });\n * ```\n *\n * Alternative:\n * ```js\n * window.addEventListener(`pointermove`, everyNth(10, evt => {\n *  // Do something with tenth item...\n * });\n * ```\n * @param nth Every nth item\n * @param callback\n * @returns Function which in turn returns true if nth call has been hit, false otherwise\n */\nexport const everyNth = <T>(nth: number, callback?: (data: T) => void) => {\n  resultThrow(integerTest(nth, `positive`, `nth`));\n\n  let counter = 0;\n\n  return (data: T) => {\n    counter++;\n    if (counter === nth) {\n      counter = 0;\n      if (callback) callback(data);\n      return true;\n    }\n    return false;\n  }\n};\n\n","import { defaultComparer, type Comparer } from '@ixfx/core';\nimport { shuffle } from '@ixfx/arrays';\n\nexport type ExpressionOrResult<ArgsType, ResultType> =\n  | ResultType\n  | ((\n    args: ArgsType | undefined\n  ) => Promise<ResultType | undefined> | ResultType | undefined | void);\n\nexport type RunOpts<ResultType> = {\n  /**\n   * If provided, filters the set of results prior to returning.\n   * @param result\n   * @returns\n   */\n  readonly filter?: (result: ResultType) => boolean;\n  /**\n   * If true, execution order is shuffled each time\n   */\n  readonly shuffle?: boolean;\n  /**\n   * Function to rank results. By default uses {@link defaultComparer} which orders\n   * by numeric value or alphabetical.\n   */\n  readonly rank?: Comparer<ResultType>;\n  /**\n   * If provided, stops execution if _true_ is returned.\n   * Result(s) include most recent execution.\n   * @param latest Latest result\n   * @param sorted Sorted list of current results, not including latest\n   * @returns\n   */\n  readonly stop?: (\n    latest: ResultType | undefined,\n    sorted: readonly ResultType[]\n  ) => boolean;\n};\n\nexport type RunSingleOpts<V> = RunOpts<V> & {\n  readonly at?: number;\n};\n/**\n * Runs a series of async expressions, returning the results.\n * Use {@link runSingle} if it's only a single result you care about.\n *\n * @example Run three functions, returning the highest-ranked result.\n * ```js\n * const result = runSingle([\n *  () => 10,\n *  () => 2,\n *  () => 3\n * ]);\n * // Yields: 10\n * ```\n *\n * Options can be passed for evaluation:\n * ```js\n * const result = run([\n *  (args) => {\n *    if (args === 'apple') return 100;\n *  },\n *  () => {\n *    return 10;\n *  }\n * ])\n * ```\n *\n * ```js\n * const expr = [\n *  (opts) => 10,\n *  (opts) => 2,\n *  (opts) => 3\n * ];\n * const opts = {\n *  rank: (a, b) => {\n *    if (a < b) return -1;\n *    if (a > b) return 1;\n *    return 0;\n *  }\n * }\n * const result = await run(expr, opts);\n * // Returns: 2\n * ```\n *\n * In terms of typing, it takes an generic arguments `ArgsType` and `ResultType`:\n * - `ArgsType`: type of expression arguments. This might be `void` if no arguments are used.\n * - `ResultType`:  return type of expression functions\n *\n * Thus the `expressions` parameter is an array of functions:\n * ```js\n * (args:ArgsType|undefined) => ResultType|undefined\n * // or\n * (args:ArgsType|undefined) => Promise<ResultType|undefined>\n * ```\n *\n * Example:\n * ```js\n * const expressions = [\n *  // Function takes a string arg\n *  (args:string) => return true; // boolean is the necessary return type\n * ];\n * const run<string,boolean>(expressions, opts, 'hello');\n * ```\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const run = async <ArgsType, ResultType>(\n  expressions:\n    | ExpressionOrResult<ArgsType, ResultType>[]\n    | ExpressionOrResult<ArgsType, ResultType>\n    | readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType[]> => {\n  const results: ResultType[] = [];\n  const compareFunction = opts.rank ?? defaultComparer;\n  let expressionsArray = Array.isArray(expressions)\n    ? (expressions)\n    : [ expressions as ExpressionOrResult<ArgsType, ResultType> ];\n  if (opts.shuffle) expressionsArray = shuffle(expressionsArray);\n\n  for (let index = 0; index < expressionsArray.length; index++) {\n    const exp = expressionsArray[ index ];\n\n    let r: ResultType;\n    if (typeof exp === 'function') {\n      // @ts-ignore\n      r = await exp(args);\n    } else {\n      r = exp;\n    }\n    if (r !== undefined) {\n      results.push(r);\n      results.sort(compareFunction);\n    }\n\n    if (typeof opts.stop !== 'undefined') {\n      if (opts.stop(r, results)) {\n        break;\n      }\n    }\n  }\n\n  if (opts.filter) {\n    return results.filter(opts.filter);\n  }\n  return results;\n};\n\n/**\n * Like {@link run}, but it returns a single result or _undefined_.\n * Use the `at` option to specify which index of results to use.\n * By default it's -1, which is the presumably the highest-ranked result.\n *\n * @param expressions\n * @param opts\n * @param args\n * @returns\n */\nexport const runSingle = async <ArgsType, ResultType>(\n  expressions: readonly ExpressionOrResult<ArgsType, ResultType>[],\n  opts: RunSingleOpts<ResultType> = {},\n  args?: ArgsType\n): Promise<ResultType | undefined> => {\n  const results = await run(expressions, opts, args);\n  if (!results) return;\n  if (results.length === 0) return;\n  const at = opts.at ?? -1;\n  return results.at(at);\n};\n","/**\n * Subscribes to events on `target`, returning the event data\n * from the first event that fires.\n * \n * By default waits a maximum of 1 minute.\n * \n * Automatically unsubscribes on success or failure (ie. timeout)\n * \n * ```js\n * // Event will be data from either event, whichever fires first\n * // Exception is thrown if neither fires within 1 second\n * const event = await eventRace(document.body, [`pointermove`, `pointerdown`], { timeout: 1000 });\n * ```\n * @param target Event source\n * @param eventNames Event name(s)\n * @param options Options\n * @returns \n */\nexport const eventRace = (target: EventTarget, eventNames: string[], options: Partial<{ timeoutMs: number, signal: AbortSignal }> = {}) => {\n  const intervalMs = options.timeoutMs ?? 60_1000; //intervalToMs(options.timeout, 60 * 1000);\n  const signal = options.signal;\n  let triggered = false;\n  let disposed = false;\n  let timeout: ReturnType<typeof setTimeout> | undefined;\n\n  const promise = new Promise<Event>((resolve, reject) => {\n    const onEvent = (event: Event) => {\n      if (`type` in event) {\n        if (eventNames.includes(event.type)) {\n          triggered = true;\n          resolve(event);\n          dispose();\n        } else {\n          console.warn(`eventRace: Got event '${ event.type }' that is not in race list`);\n        }\n      } else {\n        console.warn(`eventRace: Event data does not have expected 'type' field`);\n        console.log(event);\n      }\n    }\n\n    for (const name of eventNames) {\n      target.addEventListener(name, onEvent);\n    }\n\n    const dispose = () => {\n      if (disposed) return;\n      if (timeout !== undefined) clearTimeout(timeout);\n      timeout = undefined;\n      disposed = true;\n      for (const name of eventNames) {\n        target.removeEventListener(name, onEvent);\n      }\n    }\n\n    timeout = setTimeout(() => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`eventRace: Events not fired within interval. Events: ${ JSON.stringify(eventNames) } Interval: ${ intervalMs }`));\n    }, intervalMs);\n\n\n    signal?.addEventListener(`abort`, () => {\n      if (triggered || disposed) return;\n      dispose();\n      reject(new Error(`Abort signal received ${ signal.reason }`));\n    });\n  });\n  return promise;\n}","\nimport type { Interval } from \"@ixfx/core\";\nimport { movingAverageLight } from \"@ixfx/numbers\";\nimport { rateMinimum } from \"@ixfx/flow\";\n\nexport type MovingAverageTimedOptions = Readonly<{\n  interval: Interval\n  default?: number\n  abort?: AbortSignal\n}>\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n * \n * mat(); // Get current average\n * ```\n * \n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * \n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options: MovingAverageTimedOptions) => {\n  const average = movingAverageLight();\n  const rm = rateMinimum({\n    ...options,\n    whatToCall: (distance: number) => {\n      average(distance);\n    },\n    fallback() {\n      return options.default ?? 0;\n    }\n  })\n\n  return (v: number) => {\n    rm(v);\n    return average();\n  }\n};\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as Debug from '@ixfx/debug';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type PoolOptions<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string, data: V) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    //const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`, data);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: PoolUser<V>[];\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs: number;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`, data);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'. \n * All resources in the Pool are meant to be the same kind of object.\n * \n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n * \n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n * \n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport class Pool<V> {\n  private _resources: Resource<V>[];\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet = Debug.logSet(`Pool`);\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param options Pool options\n   */\n  constructor(options: PoolOptions<V> = {}) {\n    this.capacity = options.capacity ?? -1;\n    this.fullPolicy = options.fullPolicy ?? `error`;\n    this.capacityPerResource = options.capacityPerResource ?? 1;\n    this.userExpireAfterMs = options.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      options.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = options.generate;\n    this.freeResource = options.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, options.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a shared resource to the pool\n   * @throws Error if the capacity limit is reached or resource is null\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new TypeError(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Resource<V>[] = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: string[] = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`, user.data);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * Allocates a resource for `userKey`\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  #allocateResource(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a 'user' key.\n   * \n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * \n   * If a 'user' already has a resource, it will 'keep alive' their use.\n   * If a 'user' does not already have resource\n   *  - if there is capacity, a resource is allocated to user\n   *  - if pool is full\n   *    - fullPolicy = 'error': an error is thrown\n   *    - fullPolicy = 'evictOldestUser': evicts an older user\n   *    - Throw error\n   * @param userKey\n   * @throws Error If all resources are used and fullPolicy = 'error'\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this.#allocateResource(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      //console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this.#allocateResource(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport const create = <V>(options: PoolOptions<V> = {}): Pool<V> => new Pool<V>(options);\n","/**\n * Creates a new Promise, returning the promise\n * along with its resolve and reject functions.\n * \n * ```js\n * const { promise, resolve, reject } = promiseWithResolvers();\n * \n * setTimeout(() => {\n *  resolve();\n * }, 1000);\n * \n * await promise;\n * ```\n * \n * Promise would be passed somewhere that expects a promise,\n * and you're free to call `resolve` or `reject` when needed.\n * @returns \n */\nexport function promiseWithResolvers<T>() {\n  let resolve: undefined | ((value: T) => void);\n  let reject: undefined | ((reason: any) => void);\n  const promise = new Promise<T>(\n    (_resolve, _reject) => {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return { promise, resolve: resolve!, reject: reject! };\n}","import type { Interval } from \"@ixfx/core\";\nimport { timeout } from \"./timeout.js\";\n\nexport type RateMinimumOptions<TInput> = Readonly<{\n  whatToCall: (args: TInput) => void\n  fallback: () => TInput\n  interval: Interval\n  abort?: AbortSignal\n}>;\n\n/**\n * Ensures that `whatToCall` is executed with a given tempo.\n * \n * ```js\n * const rm = rateMinimum({\n *  fallback: () => {\n *    return Math.random();\n *  },\n *  whatToCall: (value:number) => {\n *    console.log(value);\n *  },\n *  interval: { secs: 10 }\n * });\n * \n * // Invokes `whatToCall`, resetting timeout\n * rm(10);\n * \n * // If we don't call rm() before 'interval' has elapsed,\n * // 'fallback' will be invoked\n * ``` \n * \n * A practical use for this is to update calculations based on firing of events\n * as well as when they don't fire. For example user input.\n * \n * ```js\n * // Average distances\n * const average = movingAverageLight();\n * const rm = rateMinimum({\n *  interval: { secs: 1 },\n *  whatToCall: (distance: number) => {\n *    average(distance);\n *  },\n *  // If there are no pointermove events, distance is 0\n *  fallback() {\n *    return 0;\n *  }\n * })\n * \n * // Report total movemeent\n * document.addEventListener(`pointermove`, event => {\n *  rm(event.movementX + event.movementY);\n * });\n * ```\n * \n * @param options \n * @returns \n */\nexport const rateMinimum = <TInput>(options: RateMinimumOptions<TInput>) => {\n  let disposed = false;\n\n  const t = timeout(() => {\n    if (disposed) return;\n    t.start();\n    options.whatToCall(options.fallback());\n  }, options.interval);\n\n\n  if (options.abort) {\n    options.abort.addEventListener(`abort`, _ => {\n      disposed = true;\n      t.cancel();\n    });\n  }\n  t.start();\n\n  return (args: TInput) => {\n    if (disposed) throw new Error(`AbortSignal has been fired`);\n    t.start();\n    options.whatToCall(args);\n  }\n}","import type { BasicType } from '@ixfx/core';\nimport { resolve, resolveSync, type ResolveToValue, type ResolveToValueSync } from '@ixfx/core';\nimport { intervalToMs, type Interval } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n\nexport type RepeatDelayOpts = RepeatOpts & Readonly<Partial<{\n  /**\n * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n */\n  delay: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  delayMinimum: Interval;\n\n  /**\n * When to perform delay. Default is before 'produce' is invoked.\n * Default: 'before'\n */\n  delayWhen: `before` | `after` | `both`;\n}>>\n\n\n/**\n * Options for repeat\n */\nexport type RepeatOpts = Partial<Readonly<{\n  /**\n   * If specified, repeating stops if this function returns false\n   * @param count\n   * @returns \n   */\n  while: (count: number) => boolean\n  /**\n   * By default, if the callback returns\n   * _undefined_ the repeating exits. Set this to _true_ to\n   * ignore undefined values\n   * @default false\n   */\n  allowUndefined: boolean\n  /**\n   * Optional signal to abort\n   */\n  signal: AbortSignal;\n\n  /**\n   * Maximum times to repeat (default: no limit)\n   */\n  count: number\n  /**\n   * Function to call when initialising\n   * @returns \n   */\n  onStart: () => void\n\n  /**\n   * Function to call when done (or an error occurs)\n   * @returns \n   */\n  onComplete: (withError: boolean) => void\n}>>;\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat<T extends BasicType>(\n  produce: ResolveToValue<T> | ArrayLike<T>,\n  opts: RepeatDelayOpts\n): AsyncGenerator<T> {\n  const signal = opts.signal ?? undefined;\n  const delayWhen = opts.delayWhen ?? `before`;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n  const whileFunction = opts.while;\n\n  let cancelled = false;\n  let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n  let started = performance.now();\n\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      if (delayWhen === `before` || delayWhen === `both`) await doDelay();\n      const result = await resolve<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (delayWhen === `after` || delayWhen === `both`) await doDelay();\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n      }\n      if (whileFunction) {\n        if (!whileFunction(loopedTimes)) {\n          cancelled = true;\n        }\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks. \n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync<T extends BasicType>(\n  produce: ResolveToValueSync<T> | ArrayLike<T>,\n  opts: RepeatOpts\n) {\n  const signal = opts.signal ?? undefined;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  let cancelled = false;\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      const result = resolveSync<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n        if (signal?.aborted) cancelled = true;\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n\n\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n\n\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };","/* eslint-disable unicorn/prevent-abbreviations */\nimport { continuously } from \"@ixfx/core\"\nimport { SimpleEventEmitter } from \"@ixfx/events\"\n\nexport type RequestResponseOptions<TRequest, TResp> = {\n  timeoutMs: number\n  key: (requestOrResp: TRequest | TResp) => string\n  keyRequest: (request: TRequest) => string\n  keyResponse: (resp: TResp) => string\n  whenUnmatchedResponse: `ignore` | `throw`\n}\n\ntype SeenRequest<TRequest, TResp> = {\n  expiresAt: number\n  id: string\n  req: TRequest\n  promiseResolve?: (value: TResp) => void\n  promiseReject?: (message: string) => void\n  callback?: (error: boolean, value: TResp | string) => void\n}\n\nexport type RequestResponseMatchEvents<TRequest, TResp> = {\n  match: { request: TRequest, response: TResp }\n  completed: { request: TRequest, response: TResp | string, success: boolean }\n}\n\n/**\n * Matches responses with requests, expiring requests if they do not get a response in a timely manner.\n * \n * Basic usage:\n * ```js\n * const m = new RequestResponseMatch(options);\n * // Listen for when a response matches a request\n * m.addEventListener(`match`, event => {\n *  // event: { request:Req, response:Resp}\n * });\n * // Or alternatively, listen for success and failures\n * m.addEventListener(`completed`, event => {\n *  // { request:Resp, response:Req|undefined, success:boolean }\n *  // 'response' will be data or a string error message\n * });\n * m.request(req); // Note that some request was sent\n * ...\n * m.response(resp); // Call when a response is received\n * ```\n * \n * It's also possible to wait for specific replies:\n * ```js\n * // With a promise\n * const resp = await m.requestAwait(req);\n * // With a callback\n * m.requestCallback(req, (success, resp) => {\n *  // Runs on success or failure\n * })\n * ```\n * It relies on creating an id of a request/response for them to be matched up. Use the `key`\n * option if the function can generate a key from either request or response. Or alternatively set both `keyRequest` and `keyResponse` for two functions that can generate a key for request and response respectively.\n * \n * \n * The easy case is if req & resp both have the same field:\n * ```js\n * const m = new RequestResponseMatch({\n *  key: (reqOrResp) => {\n *    // Requests has an 'id' field\n *    // Response also has an 'id' field that corresponds to the request id\n *    return reqOrResp.id; \n *  }\n * });\n * ```\n * \n * A more complicated case:\n * ```js\n * const m = new RequestResponseMatch({\n *  keyRequest: (req) => {\n *    // Requests have an 'id' field\n *    return req.id; \n *  },\n *  keyResponse: (resp) => {\n *    // Responses have id under a different field\n *    return resp.reply_to\n *  }\n * })\n * ```\n * \n * By default, error will be thrown if a response is received that doesn't match up to any request.\n */\nexport class RequestResponseMatch<TRequest, TResp> extends SimpleEventEmitter<RequestResponseMatchEvents<TRequest, TResp>> {\n  timeoutMs;\n  whenUnmatchedResponse;\n  keyRequest;\n  keyResponse;\n\n  #outgoing = new Map<string, SeenRequest<TRequest, TResp>>();\n  #maintainLoop;\n\n  constructor(options: Partial<RequestResponseOptions<TRequest, TResp>> = {}) {\n    super();\n    if (typeof window === `undefined`) {\n      (globalThis as any).window = {\n        setTimeout: setTimeout,\n        clearTimeout: clearTimeout\n      }\n    }\n    this.timeoutMs = options.timeoutMs ?? 1000;\n    this.whenUnmatchedResponse = options.whenUnmatchedResponse ?? `throw`;\n    this.#maintainLoop = continuously(() => this.#maintain(), this.timeoutMs * 2);\n    if (options.key) {\n      if (options.keyRequest) throw new Error(`Cannot set 'keyRequest' when 'key' is set `);\n      if (options.keyResponse) throw new Error(`Cannot set 'keyResponse' when 'key' is set `);\n\n      this.keyRequest = options.key;\n      this.keyResponse = options.key;\n    } else {\n      if (!options.keyRequest || !options.keyResponse) {\n        throw new Error(`Expects 'keyRequest' & 'keyResponse' fields to be set if 'key' is not set`);\n      }\n      this.keyRequest = options.keyRequest;\n      this.keyResponse = options.keyResponse;\n    }\n  }\n\n  #maintain() {\n    const values = [ ...this.#outgoing.values() ];\n    const now = Date.now();\n    for (const v of values) {\n      if (v.expiresAt <= now) {\n\n        if (v.promiseReject) {\n          v.promiseReject(`Request timeout`);\n        }\n        const callback = v.callback;\n        if (callback) {\n          setTimeout(() => {\n            callback(true, `Request timeout`);\n          }, 1);\n        }\n        this.fireEvent(`completed`, { request: v.req, response: `Request timeout`, success: false });\n        this.#outgoing.delete(v.id);\n      }\n    }\n    this.debugDump();\n    return this.#outgoing.size > 0;\n  }\n\n  debugDump() {\n    const values = [ ...this.#outgoing.values() ];\n    const now = Date.now();\n    for (const v of values) {\n      const expire = now - v.expiresAt;\n      console.log(`${ v.id } Expires in: ${ Math.floor(expire / 1000).toString() }s`);\n    }\n  }\n\n  /**\n   * Make a request and get the outcome via a Promise\n   * @param request \n   */\n  request(request: TRequest): Promise<TResp>;\n\n  /**\n   * Makes a request with a callback for the outcome\n   * @param request \n   * @param callback \n   */\n  request(request: TRequest, callback: (error: boolean, response: TResp | string) => void): void;\n\n  /**\n   * Makes a request.\n   * If `callback` is set, it's equivalent to calling `requestCallback`.\n   * If `callback` is not set, a promise is returned\n   * @param request \n   * @param callback \n   * @returns \n   */\n\n  request(request: TRequest, callback?: (error: boolean, response: TResp | string) => void): void | Promise<TResp> {\n    if (callback !== undefined) { this.#requestCallback(request, callback); return; }\n    return this.#requestAwait(request);\n  }\n\n  /**\n   * Make a request and don't wait for the outcome.\n   * @param request \n   */\n  requestAndForget(request: TRequest) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const r: SeenRequest<TRequest, TResp> = {\n      expiresAt: Date.now() + this.timeoutMs,\n      id,\n      req: request\n    };\n    this.#outgoing.set(id, r);\n    this.#maintainLoop.start();\n  }\n\n  /**\n   * Make a request, returning a Promise for the outcome.\n   * Errors will throw an exception.\n   * @param request \n   * @returns \n   */\n  #requestAwait(request: TRequest) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const p = new Promise<TResp>((resolve, reject) => {\n      const r: SeenRequest<TRequest, TResp> = {\n        expiresAt: Date.now() + this.timeoutMs,\n        id,\n        req: request,\n        promiseResolve: resolve,\n        promiseReject: reject\n      };\n      this.#outgoing.set(id, r);\n      this.#maintainLoop.start();\n\n    });\n    return p;\n  }\n\n  /**\n   * Make a request, and get notified of outcome with a callback\n   * @param request \n   * @param callback \n   */\n  #requestCallback(request: TRequest, callback: (error: boolean, response: TResp | string) => void) {\n    const id = this.keyRequest(request);\n    if (this.#outgoing.has(id)) throw new Error(`Already a request pending with id '${ id }'`);\n\n    const r: SeenRequest<TRequest, TResp> = {\n      expiresAt: Date.now() + this.timeoutMs,\n      id,\n      req: request,\n      callback\n    };\n    this.#outgoing.set(id, r);\n    this.#maintainLoop.start();\n  }\n\n  /**\n   * Response has been received\n   * @param response Response\n   * @returns _True_ if response matched a request \n   */\n  response(response: TResp, keepAlive: boolean): boolean {\n    const id = this.keyResponse(response);\n    const request = this.#outgoing.get(id);\n    if (!request) {\n      if (this.whenUnmatchedResponse === `throw`) throw new Error(`Unmatched response with id: '${ id }'`, { cause: response });\n      // otherwise ignore\n      return false;\n    }\n\n    if (keepAlive) {\n      // Continue life of request\n      request.expiresAt = Date.now() + this.timeoutMs\n    } else {\n      this.#outgoing.delete(id);\n    }\n    if (request.promiseResolve) {\n      request.promiseResolve(response);\n    }\n    if (request.callback) {\n      request.callback(false, response);\n    }\n    this.fireEvent(`match`, { request: request.req, response: response });\n    if (!keepAlive) {\n      this.fireEvent(`completed`, { request: request.req, response: response, success: true });\n    }\n    return true;\n  }\n}","import { elapsedSince, sleep } from '@ixfx/core';\nimport { resolveLogOption } from '@ixfx/debug';\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { getErrorMessage } from '@ixfx/debug';\nimport type { Result } from '@ixfx/guards';\nimport { elapsedToHumanString } from '@ixfx/core';\n/**\n * Result of backoff\n */\nexport type RetryResult<V> = {\n  /**\n   * Message describing outcome.\n   *\n   * If retry was aborted, message will be abort reason.\n   */\n  readonly message?: string;\n  /**\n   * True if callback function was invoked once where it returned _true_\n   */\n  readonly success: boolean;\n  /**\n   * Number of times callback was attempted\n   */\n  readonly attempts: number;\n  /**\n   * Total elapsed time since beginning of call to `retry`\n   */\n  readonly elapsed: number;\n\n  /**\n   * Value returned by succeeding function,\n   * or _undefined_ if it failed\n   */\n  readonly value: V | undefined;\n};\n\nexport type BackoffOptions = {\n  /**\n   * Initial value.\n   * Default: 1\n   */\n  startAt: number,\n  /**\n   * Maximum times to run.\n   * Default: continues forever\n   */\n  limitAttempts: number,\n  /**\n   * Stop retrying if this maximum is reached\n   * Default: no limit\n   */\n  limitValue: number\n  /**\n   * Math power. \n   * Default: 1.1\n   */\n  power: number\n};\n\n/**\n * Generates an expoential backoff series of values\n * ```js\n * // Default: start at 1, power 1.1\n * for (const v of backoffGenerator()) {\n *  // v: numeric value\n * }\n * ```\n * \n * By default the generator runs forever. Use either\n * `limitAttempts` or `limitValue` to stop it when it produces a\n * given quantity of values, or when the value itself reaches a threshold.\n * \n * For example:\n * ```js\n * // `values` will have five values in it\n * const values = [...backoffGenerator({ limitAttempts: 5 })];\n * // Keep generating values until max is reached\n * const values = [...backoffGenerator({ limitValue: 1000 })];\n * ```\n * \n * Options:\n * * startAt: start value\n * * limitAttempts: cap the number of values to generate\n * * limitValue: cap the maximum calculated value\n * * power: power value (default 1.1)\n * \n * @param options \n * @returns \n */\nexport function* backoffGenerator(options: Partial<BackoffOptions> = {}) {\n  const startAt = options.startAt ?? 1;\n  let limitAttempts = options.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const limitValue = options.limitValue;\n  const power = options.power ?? 1.1;\n  let value = startAt;\n  resultThrow(\n    integerTest(limitAttempts, `aboveZero`, `limitAttempts`),\n    numberTest(startAt, ``, `startAt`),\n    numberTest(limitAttempts, ``, `limitAttempts`),\n    () => (limitValue !== undefined) ? numberTest(limitValue, ``, `limitValue`) : undefined,\n    numberTest(power, ``, `power`)\n  );\n\n  while (limitAttempts > 0) {\n    // Value has climbed to the limit\n    if (limitValue && value >= limitValue) return;\n    limitAttempts--;\n    yield value;\n\n    // Increase value for next iteration\n    value += Math.pow(value, power);\n  }\n}\n\n/**\n * Backoff options\n */\nexport type RetryOpts<T> = BackoffOptions & {\n  /**\n   * Initial waiting period before first attempt (optional)\n   */\n  readonly predelayMs: number;\n  /**\n   * Optional abort signal\n   */\n  readonly abort: AbortSignal;\n  /**\n   * Log: _true_ monitors the task execution by logging to console\n   */\n  readonly log: boolean;\n\n  /***\n   * Default task value to return if it fails\n   */\n  readonly taskValueFallback: T;\n};\n\nexport type RetryTask<T> = {\n  /**\n   * If `probe` returns {success:true} task is considered\n   * complete and retrying stops\n   * @returns \n   */\n  probe: (attempts: number) => Promise<Result<T, any>>\n}\n\n/**\n * Keeps calling `callback` until it returns something other than _undefined_. \n * There is an exponentially-increasing delay between each retry attempt.\n * \n * If `callback` throws an exception, the retry is cancelled, bubbling the exception.\n *\n * ```js\n * // A function that only works some of the time\n * const flakyFn = async () => {\n *  // do the thing\n *  if (Math.random() > 0.9) return true; // success\n *  return; // fake failure\n * };\n *\n * // Retry it up to five times,\n * // starting with 1000ms interval\n * const result = await retryFunction(flakyFn, {\n *  limitAttempts: 5\n * });\n *\n * if (result.success) {\n *  // Yay\n * } else {\n *  console.log(`Failed after ${result.attempts} attempts. Elapsed: ${result.elapsed}`);\n *  console.log(result.message);\n * }\n * ```\n *\n * An `AbortSignal` can be used to cancel process.\n * ```js\n * const abort = new AbortController();\n * const result = await retryFunction(cb, { signal: abort.signal });\n *\n * // Somewhere else...\n * abort('Cancel!'); // Trigger abort\n * ```\n * @param callback Function to run\n * @param options Options\n * @returns\n */\nexport const retryFunction = <T>(callback: () => Promise<T | undefined>, options: Partial<RetryOpts<T>> = {}) => {\n  const task: RetryTask<T> = {\n    async probe() {\n      try {\n        const v = await callback();\n        if (v === undefined) return { value: options.taskValueFallback, error: `Fallback`, success: false };\n        return { value: v, success: true };\n      } catch (error) {\n        return { success: false, error: error as Error };\n      }\n    },\n  }\n  return retryTask(task, options);\n}\n\n/**\n * Keeps trying to run `task`.\n * \n * ```js\n * const task = (attempts) => {\n *  // attempts is number of times it has been retried\n *  \n *  if (Math.random() > 0.5) {\n *    // Return a succesful result\n *    return { success: true }\n *  } else {\n *  }\n * \n * }\n * const t = await retryTask(task, opts);\n * ```\n * @param task \n * @param opts \n * @returns \n */\nexport const retryTask = async <V>(\n  task: RetryTask<V>,\n  opts: Partial<RetryOpts<V>> = {}\n): Promise<RetryResult<V>> => {\n  const signal = opts.abort;\n  const log = resolveLogOption(opts.log);\n  const predelayMs = opts.predelayMs ?? 0;\n  const startedAt = elapsedSince();\n\n  let attempts = 0;\n  const initialValue = opts.startAt ?? 1000;\n  const limitAttempts = opts.limitAttempts ?? Number.MAX_SAFE_INTEGER;\n  const backoffGen = backoffGenerator({ ...opts, startAt: initialValue, limitAttempts });\n\n  if (initialValue <= 0) throw new Error(`Param 'initialValue' must be above zero`);\n\n  if (predelayMs > 0) {\n    try {\n      await sleep({ millis: predelayMs, signal: signal });\n    } catch (error) {\n      // Could happen due to abort signal\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        elapsed: startedAt(),\n        message: getErrorMessage(error),\n      };\n    }\n  }\n\n  for (const t of backoffGen) {\n    attempts++;\n\n    // Run task\n    const result = await task.probe(attempts);\n    if (result.success) {\n      return { success: result.success, value: result.value, attempts, elapsed: startedAt() };\n    }\n    log({\n      msg: `retry attempts: ${ attempts.toString() } t: ${ elapsedToHumanString(t) }`,\n    });\n\n    // Did not succeed.\n    if (attempts >= limitAttempts) {\n      break; // Out of attempts, no point sleeping again\n    }\n    // Sleep\n    try {\n      await sleep({ millis: t, signal });\n    } catch (error) {\n      // Eg if abort signal fires\n      return {\n        success: false,\n        attempts,\n        value: opts.taskValueFallback,\n        message: getErrorMessage(error),\n        elapsed: startedAt(),\n      };\n    }\n  }\n\n  return {\n    message: `Giving up after ${ attempts.toString() } attempts.`,\n    success: false,\n    attempts,\n    value: opts.taskValueFallback,\n    elapsed: startedAt(),\n  };\n};\n","/**\n * Runs a function once\n *\n * ```js\n * const init = runOnce(() => {\n *  // do some initialisation\n * });\n *\n * init(); // Runs once\n * init(); // no-op\n * ```\n * @param onRun\n * @returns\n */\nexport const runOnce = (onRun: () => boolean): (() => boolean) => {\n  let run = false;\n  let success = false;\n  return () => {\n    if (run) return success;\n    run = true;\n    success = onRun();\n    return success;\n  };\n};\n","/**\n * Simple synchronisation. Supports only a single signal/waiter.\n * Expects one or more calls to .signal() for .forSignal() to resolve\n * \n * ```js\n * const sw = new SyncWait();\n * obj.addEventListener(`click`, () => {\n *  sw.signal();\n * });\n * \n * // Wait until click event\n * await sw.forSignal();\n * ```\n * \n * `forSignal` can also take a maximum time to wait. If the\n * time elapses, an exception is thrown.\n * \n * {@link didSignal} returns _true_/_false_ if signal happened rather\n * than throwing an exception.\n * \n */\nexport class SyncWait {\n  #resolve?: (value?: any) => void;\n  #reject?: (reason?: string) => void;\n  #promise?: Promise<any>;\n\n  signal() {\n    if (this.#resolve) {\n      this.#resolve();\n      this.#resolve = undefined;\n    }\n    this.#promise = Promise.resolve();\n  }\n\n  /**\n   * Throw away any previous signalled state.\n   * This will cause any currently waiters to throw\n   */\n  flush() {\n    if (this.#reject) {\n      this.#reject(`Flushed`);\n      this.#reject = undefined;\n    }\n    this.#resolve = undefined;\n    this.#promise = undefined;\n  }\n\n  #initPromise() {\n    const p = new Promise((resolve, reject) => {\n      this.#resolve = resolve;\n      this.#reject = reject;\n    });\n    this.#promise = p;\n    return p;\n  }\n\n  /**\n   * Call with `await` to wait until .signal() happens.\n   * If a wait period is specified, an exception is thrown if signal does not happen within this time.\n   * @param maximumWaitMs \n   */\n  async forSignal(maximumWaitMs?: number) {\n    let p = this.#promise;\n    p ??= this.#initPromise();\n    if (maximumWaitMs) {\n      const reject = this.#reject;\n      setTimeout(() => {\n        if (reject) {\n          reject(`Timeout elapsed ${ maximumWaitMs.toString() }`);\n        }\n      }, maximumWaitMs);\n    }\n    await p;\n    this.#promise = undefined;\n    this.#resolve = undefined;\n    this.#reject = undefined;\n  }\n\n  /**\n   * An alternative to {@link forSignal}, returning _true_\n   * if signalled, or _false_ if wait period was exceeded \n   * \n   * ```js\n   * const s = await sw.didSignal(5000);\n   * ```\n   * @param maximumWaitMs \n   * @returns \n   */\n  async didSignal(maximumWaitMs: number): Promise<boolean> {\n    try {\n      await this.forSignal(maximumWaitMs);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}","import { SimpleEventEmitter } from '@ixfx/events';\nimport { Queues } from '@ixfx/collections';\nimport { continuously } from '@ixfx/core';\n\nexport type AsyncTask = () => Promise<void>;\n\nexport type TaskQueueEvents = {\n  /**\n   * Task queue has emptied.\n   * @returns\n   */\n  empty: any\n  /**\n   * Task queue was empty and now processing\n   * @returns \n   */\n  started: any\n}\n\n/**\n * Simple task queue. Each task is awaited and run\n * in turn.\n * \n * The TaskQueueMutable is shared across your code,\n * so you don't create it directly. Rather, use:\n * \n * ```js\n * const queue = TaskQueueMutable.shared;\n * ```\n *\n * @example Usage\n * ```js\n * const queue = TaskQueueMutable.shared;\n * q.enqueue(async () => {\n *  // Takes one second to run\n *  await sleep(1000);\n * });\n * ```\n * \n * You can listen to events from the TaskQueue:\n * ```js\n * TaskQueueMutable.shared.addEventListener(`started`, () => {\n *  // Queue was empty, now started processing\n * });\n * \n * TaskQueueMutable.shared.addEventListener(`empty`, () => {\n *  // Queue has finished processing all items\n * });\n * ```\n */\nexport class TaskQueueMutable extends SimpleEventEmitter<TaskQueueEvents> {\n  static readonly shared = new TaskQueueMutable();\n  private _loop;\n  private _queue;\n\n  private constructor() {\n    super();\n    this._queue = Queues.mutable<AsyncTask>();\n    this._loop = continuously(() => {\n      return this.processQueue();\n    }, 100);\n  }\n\n  /**\n   * Adds a task. This triggers processing loop if not already started.\n   *\n   * ```js\n   * queue.add(async () => {\n   *  await sleep(1000);\n   * });\n   * ```\n   * @param task Task to run\n   */\n  enqueue(task: () => Promise<void>) {\n    const length = this._queue.enqueue(task);\n    if (this._loop.runState === `idle`) {\n      this.fireEvent(`started`, {});\n      this._loop.start();\n    }\n    return length;\n  }\n\n  dequeue() {\n    return this._queue.dequeue();\n  }\n\n  private async processQueue() {\n    const task = this._queue.dequeue();\n    if (task === undefined) {\n      this.fireEvent(`empty`, {});\n      return false;\n\n    }\n\n    try {\n      await task();\n    } catch (error) {\n      console.error(error);\n    }\n\n  }\n\n  /**\n   * Clears all tasks, and stops any scheduled processing.\n   * Currently running tasks will continue.\n   * @returns \n   */\n  clear() {\n    if (this._queue.length === 0) return;\n    this._queue.clear();\n    this._loop.cancel();\n    this.fireEvent(`empty`, {});\n  }\n\n  /**\n  * Returns true if queue is empty\n  */\n  get isEmpty() {\n    return this._queue.isEmpty;\n  }\n\n\n  /**\n   * Number of items in queue\n   */\n  get length() {\n    return this._queue.length\n  }\n}\n","/***\n * Throttles a function. Callback only allowed to run after minimum of `intervalMinMs`.\n *\n * @example Only handle move event every 500ms\n * ```js\n * const moveThrottled = throttle( (elapsedMs, args) => {\n *  // Handle ar\n * }, 500);\n * el.addEventListener(`pointermove`, moveThrottled)\n * ```\n *\n * Note that `throttle` does not schedule invocations, but rather acts as a filter that\n * sometimes allows follow-through to `callback`, sometimes not. There is an expectation then\n * that the return function from `throttle` is repeatedly called, such as the case for handling\n * a stream of data/events.\n *\n * @example Manual trigger\n * ```js\n * // Set up once\n * const t = throttle( (elapsedMs, args) => { ... }, 5000);\n *\n * // Later, trigger throttle. Sometimes the callback will run,\n * // with data passed in to args[0]\n * t(data);\n * ```\n */\nexport const throttle = (\n  callback: (\n    elapsedMs: number,\n    ...args: readonly unknown[]\n  ) => void | Promise<unknown>,\n  intervalMinMs: number\n) => {\n  let trigger = 0;\n  return async (...args: unknown[]) => {\n    const elapsed = performance.now() - trigger;\n    if (elapsed >= intervalMinMs) {\n      const r = callback(elapsed, ...args);\n      if (typeof r === `object`) await r;\n      trigger = performance.now();\n    }\n  };\n};\n","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs, type HasCompletion, type Interval } from '@ixfx/core';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * Implementations: {@link elapsedMillisecondsAbsolute}, {@link elapsedTicksAbsolute}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relative}\n */\nexport type CompletionTimer = Timer & {\n  /**\n   * Returns _true_ if this timer has completed.\n   */\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link elapsedMillisecondsAbsolute}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * const oneSecond = hasElapsed(1000);\n * \n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n * \n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n  return () => t.isDone;\n}\n\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * const timer = Flow.ofTotal(1000);\n * \n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n * \n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`Param 'duration' not valid`);\n  const timerOpts = {\n    ...opts,\n    timer: elapsedMillisecondsAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalMs, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks: number, opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const timerOpts = {\n    ...opts,\n    timer: elapsedTicksAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalTicks, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns \n */\nexport const timerAlwaysDone = (): ModulationTimer => ({\n  elapsed: 1,\n  isDone: true,\n  reset(): void {\n\n  },\n  mod(amt) {\n\n  },\n})\n\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns \n */\nexport const timerNeverDone = (): ModulationTimer => (\n  {\n    elapsed: 0,\n    isDone: false,\n    reset() {\n\n    },\n    mod() {\n\n    }\n  }\n);\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (\n  total: number,\n  options: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  if (!Number.isFinite(total)) {\n    return timerAlwaysDone()\n  } else if (Number.isNaN(total)) {\n    return timerNeverDone();\n  }\n\n  const clampValue = options.clampValue ?? false;\n  const wrapValue = options.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  // Keep track of value to avoid over-advancing the tick counter\n  let lastValue = 0;\n  const computeElapsed = (value: number) => {\n    lastValue = value;\n    let v = value / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      //const tmp = computeElapsed();\n      //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n      return computeElapsed(lastValue) >= 1;\n    },\n    get elapsed() {\n      return computeElapsed(timer.elapsed);\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  options: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = (): Timer & { peek: number } => {\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Get current ticks without incrementing.\n     */\n    get peek() {\n      return start;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     * \n     * Use {@link peek} to get the current ticks without incrementing.\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n\n\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n * \n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n * \n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n * \n * @param fn \n * @param timer \n * @returns \n */\nexport const timerWithFunction = (\n  fn: ((v: number) => number),\n  timer: CompletionTimer\n): HasCompletion & CompletionTimer & { compute: () => number } => {\n  if (typeof fn !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${ typeof fn }`);\n  let startCount = 1;\n  return {\n    get elapsed() {\n      return timer.elapsed;\n    },\n    get isDone() {\n      return timer.isDone;\n    },\n    get runState() {\n      if (timer.isDone) return `idle`;\n      return `scheduled`;\n    },\n    /**\n     * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n     */\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCount;\n    },\n    compute: () => {\n      const elapsed = timer.elapsed;\n      return fn(elapsed);\n    },\n    reset: () => {\n      timer.reset();\n      startCount++;\n    },\n  };\n};","import { intervalToMs, type Interval } from \"@ixfx/core\";\n\nexport type UpdateFailPolicy = `fast` | `slow` | `backoff`;\n/**\n * Calls the async `fn` to generate a value if there is no prior value or\n * `interval` has elapsed since value was last generated.\n * @example\n * ```js\n * const f = updateOutdated(async () => {\n *  const r = await fetch(`blah`);\n *  return await r.json();\n * }, 60*1000);\n *\n * // Result will be JSON from fetch. If fetch happened already in the\n * // last 60s, return cached result. Otherwise it will fetch data\n * const result = await f();\n * ```\n *\n * Callback `fn` is passed how many milliseconds have elapsed since last update. Its minimum value will be `interval`.\n *\n * ```js\n * const f = updateOutdated(async elapsedMs => {\n *  // Do something with elapsedMs?\n * }, 60*1000;\n * ```\n *\n * There are different policies for what to happen if `fn` fails. `slow` is the default.\n * * `fast`: Invocation will happen immediately on next attempt\n * * `slow`: Next invocation will wait `interval` as if it was successful\n * * `backoff`: Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.\n *\n * @param fn Async function to call. Must return a value.\n * @param interval Maximum age of cached result\n * @param updateFail `slow` by default\n * @typeParam V - Return type of `fn`\n * @returns Value\n */\nexport const updateOutdated = <V>(\n  fn: (elapsedMs?: number) => Promise<V>,\n  interval: Interval,\n  updateFail: UpdateFailPolicy = `slow`\n): (() => Promise<V>) => {\n  let lastRun = 0;\n  let lastValue: V | undefined;\n  let intervalMsCurrent = intervalToMs(interval, 1000);\n\n  return () =>\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    new Promise(async (resolve, reject) => {\n      const elapsed = performance.now() - lastRun;\n      if (lastValue === undefined || elapsed > intervalMsCurrent) {\n        try {\n          lastRun = performance.now();\n          lastValue = await fn(elapsed);\n          intervalMsCurrent = intervalToMs(interval, 1000);\n        } catch (error) {\n          if (updateFail === `fast`) {\n            lastValue = undefined;\n            lastRun = 0;\n          } else if (updateFail === `backoff`) {\n            intervalMsCurrent = Math.floor(intervalMsCurrent * 1.2);\n          }\n          // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n          reject(error);\n          return;\n        }\n      }\n      resolve(lastValue);\n    });\n};\n","import { promiseWithResolvers } from \"./promise-with-resolvers.js\";\n\n/**\n * Queue of a single item, only once, allows for simple synchronisation.\n * \n * It has a 'first write wins' behaviour\n * \n * ```js\n * const q = new WaitForValue(); // or singleItem();\n * \n * // In some part of the code add a value\n * const value = q.add(`some-val`);\n * \n * // Somewhere else, wait for value\n * await q.get(value);\n * ```\n * \n * It is not possible to `add` a second item (an exception will throw), however\n * it is possible to call `get` as many times as you need.\n * \n * The `.isUsed` property allows you to to check if a value\n * has been already added to the queue.\n * \n * Based on: https://2ality.com/2024/05/proposal-promise-with-resolvers.html\n */\nexport class WaitForValue<T> {\n  #promise\n  #resolve\n  #written = false;\n  constructor() {\n    const { promise, resolve } = promiseWithResolvers<T>();\n    this.#promise = promise;\n    this.#resolve = resolve;\n  }\n\n  /**\n   * Gets the promise\n   * ```js\n   * const wv = new WaitForValue();\n   * \n   * await wv.get();\n   * ```\n   * @returns\n   */\n  get(): Promise<T> {\n    return this.#promise;\n  }\n\n  /**\n   * Adds a value, triggering promise resolution.\n   * \n   * Throws an exception if queue has already been used. Use {@link isUsed} to check.\n   * @param value \n   */\n  add(value: T) {\n    if (this.#written) throw new Error(`QueueSingleUse has already been used`);\n    this.#written = true;\n    this.#resolve(value);\n  }\n\n  /**\n   * Returns _true_ if a value has been added\n   * and therefore no more values can be written\n   */\n  get isUsed() {\n    return this.#written;\n  }\n}\n\n/**\n * {@inheritDoc WaitForValue}\n */\nexport const singleItem = <T>() => new WaitForValue<T>();","/**\n * Helper function for calling code that should fail after a timeout.\n * In short, it allows you to signal when the function succeeded, to cancel it, or\n * to be notified if it was canceled or completes.\n *\n * It does not execute or track the outcome of execution itself. Rather it's a bit\n * of machinery that needs to be steered by your own logic.\n * \n * `waitFor` takes a timeout, and two lifecycle functions, `onAborted` and `onComplete`.\n * `onAborted` is called if the timeout has elapsed. `onComplete` will run on either success or failure.\n * \n * ```js\n * waitFor(1000, \n * (error) => {\n *  // Failed\n * },\n * (success) => {\n *  if (success) {\n *    // Succeeded\n *  }\n * });\n * ```\n * \n * When calling `waitFor` you get back a function to signal success or failure:\n * ```js\n * const done = waitFor(1000, onAborted, onComplete);\n * done();          // No parameters signals success\n * done('failed');  // A string parameter indicates failure\n * ```\n * \n * @example Compact\n * ```js\n * const done = waitFor(1000,\n *  (reason) => {\n *    console.log(`Aborted: ${reason}`);\n *  });\n *\n * try {\n *  runSomethingThatMightScrewUp();\n *  done(); // Signal it succeeded\n * } catch (e) {\n *  done(e); // Signal there was an error\n * }\n * ```\n * \n * @example Verbose\n * ```js\n * // This function is called by `waitFor` if it was cancelled\n * const onAborted = (reason:string) => {\n *  // 'reason' is a string describing why it has aborted.\n *  // ie: due to timeout or because done() was called with an error\n * };\n *\n * // This function is called by `waitFor` if it completed\n * const onComplete = (success:boolean) => {\n *  // Called if we were aborted or finished succesfully.\n *  // onComplete will be called after onAborted, if it was an error case\n * }\n *\n * // If done() is not called after 1000, onAborted will be called\n * // if done() is called or there was a timeout, onComplete is called\n * const done = waitFor(1000, onAborted, onComplete);\n *\n * // Signal completed successfully (thus calling onComplete(true))\n * done();\n *\n * // Signal there was an error (thus calling onAborted and onComplete(false))\n * done(`Some error`);\n * ```\n *\n * The completion handler is useful for removing event handlers.\n *\n\n * @param timeoutMs\n * @param onAborted\n * @param onComplete\n * @returns\n */\nexport const waitFor = (\n  timeoutMs: number,\n  onAborted: (reason: string) => void,\n  onComplete?: (success: boolean) => void\n) => {\n  let t: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  let success = false;\n  const done = (error?: string) => {\n    if (t !== undefined) {\n      window.clearTimeout(t);\n      t = undefined;\n    }\n    if (error) {\n      onAborted(error);\n    } else {\n      success = true;\n    }\n    if (onComplete !== undefined) onComplete(success);\n  };\n\n  t = globalThis.setTimeout(() => {\n    t = undefined;\n    try {\n      onAborted(`Timeout after ${ timeoutMs }ms`);\n    } finally {\n      if (onComplete !== undefined) onComplete(success);\n    }\n  }, timeoutMs);\n\n  return done;\n};\n","import { unique } from '@ixfx/arrays';\nimport type { Machine, MachineState, StateNames, StateTarget, StateTargetStrict, TransitionCondition, Transitions, TransitionsStrict } from './types.js';\n\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = <V extends Transitions>(\n  toClone: MachineState<V>\n): MachineState<V> => {\n  return Object.freeze({\n    value: toClone.value,\n    visited: [ ...toClone.visited ],\n    machine: toClone.machine,\n  });\n};\n/**\n * Initialises a state machine. [Read more in the ixfx Guide](https://ixfx.fun/flow/state-machine/overview/)\n * \n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * \n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * \n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * \n * StateMachine.isDone(sm); // false\n * StateMachine.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = <V extends Transitions>(\n  stateMachine: Machine<V> | Transitions | TransitionsStrict,\n  initialState?: StateNames<V>\n): MachineState<V> => {\n  const [ machine, machineValidationError ] = validateMachine(stateMachine);\n  if (!machine) throw new Error(machineValidationError);\n\n  const state: StateNames<V> =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState!) ?? Object.keys(machine.states)[ 0 ];\n  if (typeof machine.states[ state ] === `undefined`) {\n    throw new TypeError(`Initial state ('${ state }') not found`);\n  }\n\n  // Normalise states\n  const transitions = validateAndNormaliseTransitions(machine.states);\n  if (transitions === undefined) {\n    throw new Error(`Could not normalise transitions`);\n  }\n  return Object.freeze({\n    value: state,\n    visited: [],\n    machine: Object.freeze(Object.fromEntries(transitions)) as any as Readonly<Record<StateNames<V>, readonly StateTargetStrict<V>[]>>,\n  });\n};\n\nexport const reset = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  return init<V>(sm.machine as any);\n};\n\nexport const validateMachine = <V extends Transitions>(\n  smOrTransitions: Machine<V> | Transitions | TransitionsStrict\n): [ machine: Machine<V> | undefined, msg: string ] => {\n  if (typeof smOrTransitions === `undefined`) {\n    return [ undefined, `Parameter undefined` ];\n  }\n  if ((smOrTransitions as unknown) === null) {\n    return [ undefined, `Parameter null` ];\n  }\n  if (`states` in smOrTransitions) {\n    // Assume Machine type\n    return [ smOrTransitions as Machine<V>, `` ];\n  }\n  if (typeof smOrTransitions === `object`) {\n    return [\n      {\n        states: smOrTransitions as V,\n      },\n      ``,\n    ];\n  }\n  return [\n    undefined,\n    `Unexpected type: ${ typeof smOrTransitions }. Expected object`,\n  ];\n};\n\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = <V extends Transitions>(sm: MachineState<V>): boolean => {\n  return possible(sm).length === 0;\n};\n\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = <V extends Transitions>(\n  sm: MachineState<V>\n): readonly StateTargetStrict<V>[] => {\n  // Validate current state\n  validateMachineState(sm);\n  // get list of possible targets\n  const fromS = sm.machine[ sm.value ];\n\n  if (fromS.length === 1 && fromS[ 0 ].state === null) return [];\n  return fromS;\n};\n\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = <V extends Transitions>(\n  sm: MachineState<V>\n): (StateNames<V> | null)[] => {\n  const targets = possibleTargets(sm);\n  return targets.map((v) => v.state);\n};\n\nexport const normaliseTargets = <V extends Transitions>(\n  targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    | StateTargetStrict<V>\n): StateTargetStrict<V>[] | null | undefined => {\n  const normaliseSingleTarget = (\n    target: string | undefined | null | object\n  ): StateTargetStrict<V> | undefined => {\n    // Terminal target\n    if (target === null) return { state: null };\n    // String is the target state\n    if (typeof target === `string`) {\n      return {\n        state: target,\n      };\n    } else if (typeof target === `object` && `state` in target) {\n      const targetState = target.state;\n      if (typeof targetState !== `string`) {\n        throw new TypeError(\n          `Target 'state' field is not a string. Got: ${ typeof targetState }`\n        );\n      }\n      if (`preconditions` in target) {\n        return {\n          state: targetState,\n          preconditions: target.preconditions as TransitionCondition<V>[],\n        };\n      }\n      return { state: targetState };\n    } else {\n      throw new Error(\n        `Unexpected type: ${ typeof target }. Expected string or object with 'state' field.`\n      );\n    }\n  };\n\n  // Array of targets (either strings or objects)\n  if (Array.isArray(targets)) {\n    let containsNull = false;\n    const mapResults = targets.map((t) => {\n      const r = normaliseSingleTarget(t);\n      if (!r) throw new Error(`Invalid target`);\n      containsNull = containsNull || r.state === null;\n      return r;\n    });\n    if (containsNull && mapResults.length > 1) {\n      throw new Error(`Cannot have null as an possible state`);\n    }\n    return mapResults;\n  } else {\n    const target = normaliseSingleTarget(targets);\n    if (!target) return;\n    return [ target ];\n  }\n};\n\nconst validateAndNormaliseTransitions = (\n  d: Transitions\n): Map<string, StateTargetStrict<typeof d>[]> | undefined => {\n  const returnMap = new Map<string, StateTargetStrict<typeof d>[]>();\n\n  // 1. Index top-level states\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    if (typeof topLevelState === `undefined`) {\n      throw new TypeError(`Top-level undefined state`);\n    }\n    if (typeof topLevelTargets === `undefined`) {\n      throw new TypeError(`Undefined target state for ${ topLevelState }`);\n    }\n    if (returnMap.has(topLevelState)) {\n      throw new Error(`State defined twice: ${ topLevelState }`);\n    }\n    if (topLevelState.includes(` `)) {\n      throw new Error(`State names cannot contain spaces`);\n    }\n    returnMap.set(topLevelState, []);\n  }\n\n  // 2. Normalise target\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    const targets = normaliseTargets(topLevelTargets);\n    if (targets === undefined) throw new Error(`Could not normalise target`);\n    if (targets !== null) {\n      // Check that they all exist as top-level states\n      const seenStates = new Set();\n      for (const target of targets) {\n        if (seenStates.has(target.state)) {\n          throw new Error(\n\n            `Target state '${ target.state }' already exists for '${ topLevelState }'`\n          );\n        }\n        seenStates.add(target.state);\n        if (target.state === null) continue;\n        if (!returnMap.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' is not defined as a top-level state. Defined under: '${ topLevelState }'`\n          );\n        }\n      }\n      returnMap.set(topLevelState, targets);\n    }\n  }\n  return returnMap;\n};\n\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = <V extends Transitions>(\n  state: MachineState<V>\n): void => {\n  if (typeof state === `undefined`) {\n    throw new TypeError(`Param 'state' is undefined`);\n  }\n  if (typeof state.value !== `string`) {\n    throw new TypeError(`Existing state is not a string`);\n  }\n};\n\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * \n * @example Attempts to transition to 'name-of-state'\n * ```js\n * const newState = StateMachine.to(currentState, `name-of-state`);\n * ```\n * \n * Note that 'currentState' is not changed.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): MachineState<V> => {\n  validateMachineState(sm); // throws if not OK\n  validateTransition(sm, toState); // throws if not OK\n  return Object.freeze({\n    value: toState,\n    machine: sm.machine,\n    visited: unique<string>([ sm.visited as string[], [ sm.value ] as string[] ]),\n  });\n};\n\nexport const next = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  //validateMachineState(sm);\n  const first = possibleTargets(sm).at(0);\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (!first || first.state === null) {\n    throw new Error(\n      `Not possible to move to a next state from '${ sm.value }`\n    );\n  }\n  return to(sm, first.state);\n};\n\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): boolean => {\n  try {\n    validateTransition(sm, toState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const validateTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): void => {\n  if ((toState as unknown) === null) throw new Error(`Cannot transition to null state`);\n  if (typeof toState === `undefined`) {\n    throw new Error(`Cannot transition to undefined state`);\n  }\n  if (typeof toState !== `string`) {\n    throw new TypeError(\n      `Parameter 'toState' should be a string. Got: ${ typeof toState }`\n    );\n  }\n\n  //const toS = sm.machine[toState];\n  //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n\n  const p = possible(sm);\n  if (p.length === 0) throw new Error(`Machine is in terminal state`);\n  if (!p.includes(toState)) {\n    throw new Error(\n      `Target state '${ toState }' not available at current state '${ sm.value\n      }'. Possible states: ${ p.join(`, `) }`\n    );\n  }\n};\n\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n * \n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states: readonly string[]): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length <= 2) throw new Error(`Expects at least two states`);\n  for (let index = 0; index < states.length; index++) {\n    const s = states[ index ] as string;\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index.toString() }`\n      );\n    }\n    t[ s ] = (index === states.length - 1) ? null : states[ index + 1 ] as string;\n  }\n  return t;\n};\n\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n * \n * See also {@link fromList}.\n * \n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (\n  ...states: readonly string[]\n): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length < 2) throw new Error(`Expects at least two states`);\n\n  for (const [ index, s ] of states.entries()) {\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index.toString() }`\n      );\n    }\n    t[ s ] = [];\n  }\n\n  for (let index = 0; index < states.length; index++) {\n    const v = t[ states[ index ] as string ] as string[];\n    if (index === states.length - 1) {\n      if (states.length > 1) {\n        v.push(states[ index - 1 ] as string);\n      } else {\n        t[ states[ index ] as string ] = null;\n      }\n    } else {\n      v.push(states[ index + 1 ] as string);\n      if (index > 0) v.push(states[ index - 1 ] as string);\n    }\n  }\n  return t;\n};\n\n","import * as Execute from '../execute.js';\nimport { type DriverOptions, type DriverResult, type DriverRunner, type DriverStatesHandler, type Machine, type MachineState, type StateNames, type Transitions } from './types.js';\nimport { defaultComparer } from '@ixfx/core';\nimport { randomElement } from '@ixfx/arrays';\nimport * as Debug from '@ixfx/debug';\nimport { init as machineInit, reset as machineReset, next as machineNext, to as machineTo } from './state-machine.js';\n\n\n\n// export type Prerequisite<V extends StateMachine.Transitions> =\n//   | readonly StateMachine.StateNames<V>[]\n//   | ((\n//       potentialState: StateMachine.StateNames<V>,\n//       state: StateMachine.MachineState<V>\n//     ) => boolean);\n\n// export type StatePrerequisites<V extends StateMachine.Transitions> = {\n//   readonly states:\n//     | readonly StateMachine.StateNames<V>[]\n//     | StateMachine.StateNames<V>;\n//   readonly condition?: Prerequisite<V>;\n// };\n\n\n\n// async function run<V extends StateMachine.Transitions>(\n//   machine: StateMachine.Machine<V>,\n//   handlers: readonly StatesHandler<V>[]\n// );\n\n\n/**\n * Drives a state machine.\n *\n * [Read more on the ixfx Guide](https://ixfx.fun/flow/state-machine/driver/)\n * \n * Uses a 'handlers' structure to determine when to change\n * state and actions to take.\n * \n * The structure is a set of logical conditions: if we're in\n * this state, then move to this other state etc.\n * \n * ```js\n * const handlers = [\n *  {\n *    // If we're in the 'sleeping' state, move to next state\n *    if: 'sleeping',\n *    then: { next: true }\n *  },\n *  {\n *    // If we're in the 'waking' state, randomly either go to 'resting' or 'sleeping' state\n *    if: 'waking',\n *    then: [\n *      () => {\n *        if (Math.random() > 0.5) {\n *          return { next: 'resting' }\n *        } else {\n *          return { next: 'sleeping' }\n *        }\n *      }\n *    ]\n *   }\n * ];\n * ```\n * \n * Set up the driver, and call `run()` when you want to get\n * the machine to change state or take action:\n * \n * ```js\n * const driver = await StateMachine.driver(states, handlers);\n * setInterval(async () => {\n *  await driver.run(); // Note use of 'await' again\n * }, 1000);\n * ```\n * \n * Essentially, the 'handlers' structure gets run through each time `run()`\n * is called.\n * \n * Defaults to selecting the highest-ranked result to determine\n * what to do next.\n * @param machine\n * @param handlersOrOpts\n * @returns\n */\nexport async function driver<V extends Transitions>(\n  machine: Machine<V> | Transitions,\n  handlersOrOpts: readonly DriverStatesHandler<V>[] | DriverOptions<V>\n): Promise<DriverRunner<V>> {\n  const opts: DriverOptions<V> = Array.isArray(handlersOrOpts)\n    ? {\n      handlers: handlersOrOpts as readonly DriverStatesHandler<V>[],\n    }\n    : (handlersOrOpts as DriverOptions<V>);\n\n  const debug = Debug.resolveLogOption(opts.debug, {\n    category: `StateMachineDriver`,\n  });\n\n  // Index handlers by state, making sure there are not multiple\n  // handlers for a given state.\n  const byState = new Map<string, DriverStatesHandler<V>>();\n  for (const h of opts.handlers) {\n    const ifBlock = Array.isArray(h.if) ? h.if : [ h.if ];\n    for (const state of ifBlock) {\n      if (typeof state !== `string`) {\n        throw new TypeError(\n          `Expected single or array of strings for the 'if' field. Got: '${ typeof state }'.`\n        );\n      }\n\n      if (byState.has(state)) {\n        throw new Error(\n          `Multiple handlers defined for state '${ state\n          }'. There should be at most one.`\n        );\n      }\n      byState.set(state, h);\n    }\n  }\n\n  const runOpts: Execute.RunOpts<DriverResult<V>> = {\n    // Rank results by score\n    rank: (a, b) => {\n      return defaultComparer(a.score ?? 0, b.score ?? 0);\n    },\n    shuffle: opts.shuffleHandlers ?? false,\n  };\n\n  let sm = machineInit(machine);\n\n  // Check that all 'if' states are actually defined on machine\n  for (const [ ifState ] of byState) {\n    // Check if state is defined\n    if (\n      typeof sm.machine[ ifState ] === `undefined` &&\n      ifState !== `__fallback`\n    ) {\n      throw new Error(\n        `StateMachineDriver handler references a state ('${ ifState }') which is not defined on the machine. Therefore this handler will never run.'`\n      );\n    }\n  }\n\n  const run = async (): Promise<MachineState<V> | undefined> => {\n    debug(`Run. State: ${ sm.value }`);\n    const state = sm.value;\n    let handler = byState.get(state);\n    if (handler === undefined) {\n      debug(`  No handler for state '${ state }', trying __fallback`);\n\n      // Is there a fallback?\n      handler = byState.get(`__fallback`);\n    }\n    if (handler === undefined) {\n      debug(`  No __fallback handler`);\n      return;\n    }\n\n    // If the `first` option is given, stop executing fns as soon as we get\n    // a valid result.\n    const runOptionsForHandler =\n      handler.resultChoice === `first`\n        ? {\n          ...runOpts,\n          stop: (latest: DriverResult<V> | undefined) => {\n            if (!latest) return false;\n            if (`reset` in latest) return true;\n            if (`next` in latest && latest.next !== undefined) return true;\n            return false;\n          },\n        }\n        : runOpts;\n\n    const results = await Execute.run<MachineState<V>, DriverResult<V>>(\n      handler.then,\n      runOptionsForHandler,\n      sm\n    );\n    debug(\n      `  In state '${ sm.value }' results: ${ results.length }. Choice: ${ handler.resultChoice\n      }`\n    );\n\n    // Apply selection logic\n    //eslint-disable-next-line functional/no-let\n    let r: DriverResult<V> | undefined;\n    switch (handler.resultChoice ?? `highest`) {\n      case `highest`: {\n        r = results.at(-1);\n        break;\n      }\n      case `first`: {\n        r = results[ 0 ]; // Since we break on the first result\n        break;\n      }\n      case `lowest`: {\n        r = results.at(0);\n        break;\n      }\n      case `random`: {\n        r = randomElement(results);\n        break;\n      }\n      default: {\n        throw new Error(\n          `Unknown 'resultChoice' option: ${ handler.resultChoice }. Expected highest, first, lowest or random`\n        );\n      }\n    }\n\n    debug(`  Chosen result: ${ JSON.stringify(r) }`);\n    // Apply result\n    if (r?.reset) {\n      sm = machineReset(sm);\n    } else if (r && r.next) {\n      if (typeof r.next === `boolean`) {\n        sm = machineNext(sm);\n      } else {\n        debug(JSON.stringify(results));\n        sm = machineTo(sm, r.next);\n      }\n    }\n    return sm;\n  };\n\n  return {\n    reset: () => {\n      sm = machineReset(sm);\n    },\n    getValue: () => sm.value,\n    run,\n    to: (state: StateNames<V>) => {\n      sm = machineTo(sm, state);\n      return sm;\n    },\n  };\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport type { StateNames, Transitions, MachineState } from './types.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type StateMachineWithEventsOptions<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\n/**\n * A state machine that fires events when state changes.\n * \n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = elapsedInfinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param m Machine description\n   * @param opts Options for machine (defaults to `{debug:false}`)\n   */\n  constructor(m: V, opts: StateMachineWithEventsOptions<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): readonly (StateNames<V> | null)[] {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): readonly StateNames<V>[] {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[ 0 ]!;\n    return p[ 0 ]!;\n  }\n\n  /**\n   * Returns _true_ if state machine is in its final state\n   *\n   * @returns\n   */\n  get isDone(): boolean {\n    return StateMachine.isDone(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n    this.#changedAt = elapsedSince();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `isValid()` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${ priorState } -> ${ newState }`);\n    }\n    this.#changedAt = elapsedSince();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.isDone(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n","export * from './driver.js';\nexport * from './state-machine.js';\nexport * from './with-events.js';\nexport type * from './types.js';"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA,MAAaA,gBAAc,CAAC,YAAY;CACpC,IAAI,WAAW;CACf,MAAM,IAAI,QAAQ,MAAM;AACpB,MAAI,SACA;EACJ,EAAE,OAAO;EACT,QAAQ,WAAW,QAAQ,UAAU,CAAC;CACzC,GAAE,QAAQ,SAAS;AACpB,KAAI,QAAQ,OACR,QAAQ,MAAM,iBAAiB,CAAC,KAAK,CAAC,EAAE,OAAK;EACzC,WAAW;EACX,EAAE,QAAQ;CACb,EAAC;CAEN,EAAE,OAAO;AACT,QAAO,CAAC,SAAS;AACb,MAAI,SACA,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;EAChD,EAAE,OAAO;EACT,QAAQ,WAAW,KAAK;CAC3B;AACJ;;;;ACjBD,MAAM,UAAU,CAACC,GAAW,eAAe,EAAE,KAAK;AAChD,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,KAAK,EAAE,SAAS,OAAW,QAAO,EAAE;AAC3E,QAAO;AACR;AAGD,UAAiB,eAAeA,GAAWC,YAA2C;AACpF,KAAI,OAAO,eAAe,CAAC,SAAS,CAAC,EACnC,aAAa,QAAQ,EAAE;AAGzB,MAAK,MAAM,CAAE,OAAO,EAAG,IAAI,QAAQ,EAAE,EACnC,MAAM,CAAE,GAAG,UAAY;AAEzB,MAAK,MAAM,CAAE,OAAO,EAAG,IAAI,QAAQ,EAAE,EAAE;EACrC,MAAM,OAAO,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5B,MAAM,SAAS,WAAW,SAAS,IAAI,aAAa,CAAC,CAAC,CAAC,GAAG,OAAO;EACjE,OAAO,eAAe,GAAG,OAAO;CACjC;AACF;AAGD,UAAiB,aAAaD,GAAWC,YAA2C;AAClF,KAAI,OAAO,eAAe,CAAC,SAAS,CAAC,EACnC,aAAa,QAAQ,EAAE;AAEzB,MAAK,MAAM,CAAE,OAAO,EAAG,IAAI,QAAQ,EAAE,EAAE;EACrC,MAAM,CAAE,GAAG,UAAY;EACvB,MAAM,OAAO,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;EAC5B,MAAM,SAAS,WAAW,SAAS,IAAI,aAAa,CAAC,CAAC,CAAC,GAAG,OAAO;EACjE,OAAO,eAAe,GAAG,OAAO;CACjC;AACF;AAOD,SAAS,UAAUC,GAAyB;AAC1C,QAAQ,EAAc,QAAQ;AAC/B;AAGD,SAAS,UAAUA,GAAyB;AAC1C,QAAQ,EAAc,QAAQ;AAC/B;AAGD,UAAU,QAAQA,GAAW;AAC3B,KAAI,UAAU,EAAE,EACd,OAAO,EAAE,IAAI,SAAS;UACb,UAAU,EAAE,EACrB,OAAO,EAAE,IAAI,SAAS;UACb,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,CAEjC,MACC,OAAM,IAAI,UAAU,CAAC,yCAAyC,CAAC;AAElE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjDD,MAAa,QAAQ,OACnBC,UAEAC,iBACe;CACf,MAAM,OACJ,OAAO,iBAAiB,CAAC,MAAM,CAAC,GAAG,EAAE,QAAQ,aAAc,IAAG;CAChE,MAAM,YAAY,KAAK,SAAS,CAAC,MAAM,CAAC;AACxC,KAAI,cAAc,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAChD,MAAM,MAAM,KAAK;CAEnB,MAAM,IAAI,QAAQ,QAAQ,MAAM,UAAU,CAAC;AAC3C,KAAI,cAAc,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAC/C,MAAM,MAAM,KAAK;AAEnB,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiGD,gBAAgB,qBAAqB;CACnC,IAAIC;CACJ,IAAI,IAAI,IAAI,QAAmB,CAAC,MAAOC,YAAU;CACjD,IAAI,QAAQ;CACZ,MAAM,WAAW,MAAM;AACrB,MAAIA,WAASA,WAAS;EACtB,IAAI,IAAI,QAAmB,CAAC,MAAOA,YAAU;CAC9C;AAED,KAAI;AACF,SAAO,MAAM;GACX,QAAQ,WAAW,sBAAsB,SAAS;GAElD,MAAM,IAAI,MAAM;GAChB,MAAM;EACP;CACF,UAAS;AACR,MAAIA,WAASA,WAAS;EACtB,WAAW,qBAAqB,MAAM;CACvC;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCD,gBAAuB,UAAUC,WAAmB;CAClD,MAAM,YAAY,aAAaC,UAAQ;AACvC,KAAI,OAAO,cAAc,CAAC,SAAS,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;AAC5E,KAAI,YAAY,EAAG,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAC9D,KAAI,cAAc,EAAG,QAAO,OAAO,oBAAoB;CAEvD,IAAIH;CACJ,IAAI,IAAI,IAAI,QAAmB,CAAC,MAAOC,YAAU;CACjD,IAAIG;CACJ,MAAM,WAAW,MAAM;AACrB,MAAIH,WAASA,WAAS;EACtB,IAAI,IAAI,QAAmB,CAAC,MAAOA,YAAU;CAC9C;AAED,KAAI;AACF,SAAO,MAAM;GACX,QAAQ,WAAW,WAAW,UAAU,UAAU;GAElD,MAAM,IAAI,MAAM;GAChB,MAAM;EACP;CACF,UAAS;AACR,MAAIA,WAASA,WAAS;AACtB,MAAI,UAAU,QAAW,WAAW,aAAa,MAAM;EACvD,QAAQ;CACT;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpLD,MAAaI,YAAU,CACrBC,UACAC,aACY;AACZ,KAAI,aAAa,OACf,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;CAEnD,MAAM,aAAa,aAAa,SAAS;CACzC,YAAY,YAAY,YAAY,CAAC,SAAS,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;CAC7D,IAAIC;CACJ,IAAI,YAAY;CAChB,IAAI,aAAa;CACjB,IAAI,kBAAkB;CACtB,IAAIC,QAAgC,CAAC,IAAI,CAAC;CAE1C,MAAM,QAAQ,MAAM;EAClB,YAAY;EACZ,WAAW,aAAa,MAAM;EAC9B,QAAQ,CAAC,IAAI,CAAC;CACf;CAED,MAAM,QAAQ,OACZC,cAAwB,UACxBC,SACkB;EAClB,MAAM,IAAI,IAAI,QAAc,CAACC,WAAS,WAAW;GAC/C,YAAY,YAAY,KAAK;GAC7B,MAAM,eAAe,aAAa,YAAY;GAC9C,MAAM,KAAK,YAAY,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC;AACjE,OAAI,cAAc,GAAG,EAAE;IACrB,OAAO,cAAc,GAAG,CAAC;AACzB;GACD;AAED,WAAQ,OAAR;IACE,KAAK,CAAC,SAAS,CAAC,EAAE;KAEhB,QAAQ;AACR;IACD;IACD,KAAK,CAAC,OAAO,CAAC,CAEZ;GAEH;GACD,QAAQ,CAAC,SAAS,CAAC;GAGnB,QAAQ,WAAW,WAAW,YAAY;AACxC,QAAI,UAAU,CAAC,SAAS,CAAC,EAAE;KACzB,QAAQ,KAAK,CAAC,yDAAyD,CAAC,CAAC;KACzE,OAAO;AACP;IACD;IACD,MAAM,QAAQ,QAAQ,CAAE;IACxB;IACA;IACA,QAAQ,CAAC,OAAO,CAAC;IACjB,MAAM,SAAS,YAAY,KAAK,GAAG,WAAW,GAAG,MAAM;IACvD,QAAQ,CAAC,IAAI,CAAC;IACd,OAAO;IACPA,WAAS;GACV,GAAE,aAAa;EACjB;AACD,SAAO;CACR;CAED,MAAM,SAAS,MAAM;AACnB,MAAI,UAAU,CAAC,IAAI,CAAC,CAAE;EACtB,OAAO;CACR;AAED,QAAO;EAEL;EACA;EACA,IAAI,WAAW;AACb,UAAO;EACR;EACD,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,kBAAkB;AACpB,UAAO;EACR;CACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/FD,MAAa,WAAW,CACtBC,UACAC,aACsB;CACtB,MAAM,IAAIC,UAAQ,UAAU,SAAS;AACrC,QAAO,CAAC,GAAG,SAAoB;EAAE,EAAE,MAAM,QAAW,KAAK;CAAG;AAC7D;;;;;;;;;;;;;;;;;;;ACzCD,IAAa,eAAb,MAA6B;CAC3B;CACA,WAAW;CACX,AAASC,MAAM,KAAK,MAAM,KAAK,QAAQ,GAAG,IAAI;CAC9C,cAAc;EACZ,KAAKC,YAAY,CAAE;CACpB;;;;;CAMD,UAAU;AACR,SAAO,KAAKA,UAAU,WAAW;CAClC;;;;;;;;;;;CAYD,IAAIC,SAAsBC,UAA8B,CAAE,GAAU;EAClE,KAAKC;EACL,MAAM,OAAO,QAAQ,QAAQ;EAC7B,MAAMC,OAAyB;GAC7B,IAAI,GAAI,KAAKL,IAAK,GAAG,EAAG,KAAKI,UAAW;GACxC;GACA;EACD;EACD,KAAKH,UAAU,KAAK,KAAK;AACzB,SAAO,KAAK;CACb;;;;;;CAOD,OAAOK,IAAqB;EAC1B,MAAM,SAAS,KAAKL,UAAU;EAC9B,KAAKA,YAAY,KAAKA,UAAU,OAAO,aAAW,QAAQ,OAAO,GAAG;AACpE,SAAO,KAAKA,UAAU,WAAW;CAClC;;;;;CAMD,OAAOM,OAAU;AACf,OAAK,MAAM,WAAW,KAAKN,WAAW;GACpC,QAAQ,QAAQ,MAAM;AACtB,OAAI,QAAQ,MACV,KAAK,OAAO,QAAQ,GAAG;EAE1B;CACF;;;;CAKD,QAAQ;EACN,KAAKA,YAAY,CAAE;CACpB;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5ED,MAAa,WAAW,CAAIO,KAAaC,aAAiC;CACxE,YAAY,YAAY,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;CAEhD,IAAI,UAAU;AAEd,QAAO,CAACC,SAAY;EAClB;AACA,MAAI,YAAY,KAAK;GACnB,UAAU;AACV,OAAI,UAAU,SAAS,KAAK;AAC5B,UAAO;EACR;AACD,SAAO;CACR;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACmED,MAAa,MAAM,OACjBC,aAIAC,OAA4B,CAAE,GAC9BC,SAC0B;CAC1B,MAAMC,UAAwB,CAAE;CAChC,MAAM,kBAAkB,KAAK,QAAQ;CACrC,IAAI,mBAAmB,MAAM,QAAQ,YAAY,GAC5C,cACD,CAAE,WAAyD;AAC/D,KAAI,KAAK,SAAS,mBAAmB,QAAQ,iBAAiB;AAE9D,MAAK,IAAI,QAAQ,GAAG,QAAQ,iBAAiB,QAAQ,SAAS;EAC5D,MAAM,MAAM,iBAAkB;EAE9B,IAAIC;AACJ,MAAI,OAAO,QAAQ,YAEjB,IAAI,MAAM,IAAI,KAAK;OAEnB,IAAI;AAEN,MAAI,MAAM,QAAW;GACnB,QAAQ,KAAK,EAAE;GACf,QAAQ,KAAK,gBAAgB;EAC9B;AAED,MAAI,OAAO,KAAK,SAAS,aACvB;OAAI,KAAK,KAAK,GAAG,QAAQ,CACvB;EACD;CAEJ;AAED,KAAI,KAAK,OACP,QAAO,QAAQ,OAAO,KAAK,OAAO;AAEpC,QAAO;AACR;;;;;;;;;;;AAYD,MAAa,YAAY,OACvBC,aACAC,OAAkC,CAAE,GACpCJ,SACoC;CACpC,MAAM,UAAU,MAAM,IAAI,aAAa,MAAM,KAAK;AAClD,KAAI,CAAC,QAAS;AACd,KAAI,QAAQ,WAAW,EAAG;CAC1B,MAAM,KAAK,KAAK,MAAM;AACtB,QAAO,QAAQ,GAAG,GAAG;AACtB;;;;;;;;;;;;;;;;;;;;;;ACzJD,MAAa,YAAY,CAACK,QAAqBC,YAAsBC,UAA+D,CAAE,MAAK;CACzI,MAAM,aAAa,QAAQ,aAAa;CACxC,MAAM,SAAS,QAAQ;CACvB,IAAI,YAAY;CAChB,IAAI,WAAW;CACf,IAAIC;CAEJ,MAAM,UAAU,IAAI,QAAe,CAACC,WAAS,WAAW;EACtD,MAAM,UAAU,CAACC,UAAiB;AAChC,OAAI,CAAC,IAAI,CAAC,IAAI,MACZ,KAAI,WAAW,SAAS,MAAM,KAAK,EAAE;IACnC,YAAY;IACZD,UAAQ,MAAM;IACd,SAAS;GACV,OACC,QAAQ,KAAK,CAAC,sBAAsB,EAAG,MAAM,KAAM,0BAA0B,CAAC,CAAC;QAE5E;IACL,QAAQ,KAAK,CAAC,yDAAyD,CAAC,CAAC;IACzE,QAAQ,IAAI,MAAM;GACnB;EACF;AAED,OAAK,MAAM,QAAQ,YACjB,OAAO,iBAAiB,MAAM,QAAQ;EAGxC,MAAM,UAAU,MAAM;AACpB,OAAI,SAAU;AACd,OAAIE,cAAY,QAAW,aAAaA,UAAQ;GAChDA,YAAU;GACV,WAAW;AACX,QAAK,MAAM,QAAQ,YACjB,OAAO,oBAAoB,MAAM,QAAQ;EAE5C;EAEDA,YAAU,WAAW,MAAM;AACzB,OAAI,aAAa,SAAU;GAC3B,SAAS;GACT,uBAAO,IAAI,MAAM,CAAC,qDAAqD,EAAG,KAAK,UAAU,WAAW,CAAE,WAAW,EAAG,YAAa,EAAE;EACpI,GAAE,WAAW;EAGd,QAAQ,iBAAiB,CAAC,KAAK,CAAC,EAAE,MAAM;AACtC,OAAI,aAAa,SAAU;GAC3B,SAAS;GACT,uBAAO,IAAI,MAAM,CAAC,sBAAsB,EAAG,OAAO,QAAS,EAAE;EAC9D,EAAC;CACH;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;ACrCD,MAAa,qBAAqB,CAACC,YAAuC;CACxE,MAAM,UAAU,oBAAoB;CACpC,MAAM,KAAKC,cAAY;EACrB,GAAG;EACH,YAAY,CAACC,aAAqB;GAChC,QAAQ,SAAS;EAClB;EACD,WAAW;AACT,UAAO,QAAQ,WAAW;EAC3B;CACF,EAAC;AAEF,QAAO,CAACC,MAAc;EACpB,GAAG,EAAE;AACL,SAAO,SAAS;CACjB;AACF;;;;;;;;;ACsBD,IAAa,WAAb,cAAiC,mBAAwC;CACvE,AAAQ;CACR,AAAQ;CACR,AAAQ;CACR,AAAQ;;;;;;CAOR,YAAqBC,KAAsBC,UAAuB;EAChE,OAAO;EADY;EAAsB;EAEzC,KAAK,cAAc,YAAY,KAAK;EACpC,KAAK,QAAQ,SAAS;EACtB,KAAK,qBAAqB,KAAK,MAAM;EACrC,KAAK,SAAS,CAAC,IAAI,CAAC;EACpB,KAAK,MAAM,IAAI,IAAI,CAAC,mBAAmB,EAAG,KAAK,KAAM,CAAC;CACvD;;;;;CAMD,WAAW;AACT,MAAI,KAAK,WAAY,QAAO,CAAC,yBAAyB,CAAC;AAEvD,SAAO,CAAC,iBAAiB,EAAG,KAAK,OAAQ,UAAU,EAAG,YAAY,KAAK,GAAG,KAAK,YAAa,OAAO,EAAG,KAAK,UAAU,KAAK,SAAS,KAAK,EAAG;CAC5I;;;;;CAMD,YAAY;AACV,MAAI,KAAK,WAAW,CAAC,QAAQ,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;EACnE,KAAK,cAAc,YAAY,KAAK;CACrC;;;;;;CAOD,SAASC,QAAgBC,MAAS;AAChC,MAAI,KAAK,WAAW,CAAC,QAAQ,CAAC,CAAE;EAChC,MAAM,WAAW,KAAK;EAEtB,KAAK,SAAS,CAAC,QAAQ,CAAC;EACxB,SAAS,SAAS,KAAK;EACvB,KAAK,MAAM,IAAI,IAAI,CAAC,sBAAsB,EAAG,KAAK,IAAK,SAAS,EAAG,QAAS,CAAC;EAC7E,KAAK,UAAU,CAAC,QAAQ,CAAC,EAAE;GAAE;GAAM;EAAQ,EAAC;EAC5C,MAAM,qBAAqB;CAC5B;;;;;CAMD,QAAQD,QAAgB;AACtB,MAAI,KAAK,WAAY,OAAM,IAAI,MAAM,CAAC,aAAa,CAAC;EACpD,MAAM,WAAW,KAAK;EACtB,MAAM,OAAO,SAAS;EACtB,KAAK,MAAM,IAAI,IAAI,CAAC,sBAAsB,EAAG,KAAK,IAAK,SAAS,EAAG,QAAS,CAAC;EAC7E,KAAK,UAAU,CAAC,QAAQ,CAAC,EAAE;GAAE;GAAM;EAAQ,EAAC;EAC5C,KAAK,SAAS,CAAC,QAAQ,EAAG,QAAS,EAAE,KAAK;CAC3C;CAGD,IAAI,OAAU;AACZ,MAAI,KAAK,WAAY,OAAM,IAAI,MAAM,CAAC,aAAa,CAAC;AACpD,SAAO,KAAK,SAAS;CACtB;;;;;CAMD,IAAI,YAAY;AACd,MAAI,KAAK,qBAAqB,EAC5B,QAAO,YAAY,KAAK,GAAG,KAAK,cAAc,KAAK;AAErD,SAAO;CACR;;;;CAKD,IAAI,UAAU;AACZ,SAAO,YAAY,KAAK,GAAG,KAAK;CACjC;;;;CAKD,IAAI,aAAa;AACf,SAAO,KAAK,WAAW,CAAC,QAAQ,CAAC;CAClC;;;;CAKD,IAAI,UAAU;AACZ,MAAI,KAAK,cAAc,KAAK,UAAW,QAAO;AAC9C,MAAI,KAAK,SAAS,WAAY,QAAO;AACrC,SAAO;CACR;AAEF;;;;AAKD,IAAa,WAAb,MAAyB;CACvB;CACA;CACA;CACA,AAASE;CACT,AAASC;CACT;;;;;;CAOA,YAAqBC,MAAeH,MAAS;EAAxB;AACnB,MAAI,SAAS,OAAW,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;AACvE,MAAI,SAAS,OAAW,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;EAEvE,KAAKI,QAAQ;EACb,KAAKC,mBAAmB;EACxB,KAAKH,qCACH,KAAK;EACP,KAAKD,uBAAuB,KAAK;EACjC,KAAKK,SAAS,CAAE;EAChB,KAAKC,SAAS,CAAC,IAAI,CAAC;CACrB;;;;;CAMD,IAAI,OAAO;AACT,MAAI,KAAKA,WAAW,CAAC,QAAQ,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;AACnE,SAAO,KAAKH;CACb;;;;;;CAOD,WAAWJ,MAAS;AAClB,MAAI,KAAKO,WAAW,CAAC,QAAQ,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;AACnE,MAAI,SAAS,OAAW,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;EACvE,KAAKH,QAAQ;CACd;;;;;CAMD,WAAW;AACT,SAAO,CAAC,mBAAmB,EAAG,KAAK,mBAAoB,QAAQ,EAAG,KAAKE,OAAO,OAAQ,SAAS,EAAG,KAAKC,OAAQ,QAAQ,EAAG,KAAK,UAAU,KAAK,KAAK,EAAG;CACvJ;;;;;;CAOD,QAAQC,MAAmB;EACzB,MAAM,WAAW,KAAKF,OAAO,KAAK,CAAC,MAAM,MAAM,QAAQ,EAAE,QAAQ,KAAK,IAAI;AAC1E,MAAI,SAAU,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;EAC1E,KAAKA,OAAO,KAAK,KAAK;EACtB,KAAKD,mBAAmB,YAAY,KAAK;CAC1C;;;;;;CAOD,SAASG,MAAmB;EAC1B,KAAKF,SAAS,KAAKA,OAAO,OAAO,CAAC,MAAM,MAAM,KAAK;EACnD,KAAK,KAAK,SAAS,KAAK;EACxB,KAAKD,mBAAmB,YAAY,KAAK;CAC1C;;;;CAKD,IAAI,kBAAkB;AACpB,SAAO,KAAK,aAAa,KAAKJ;CAC/B;;;;CAKD,IAAI,aAAa;AACf,SAAO,KAAKK,OAAO;CACpB;;;;;CAMD,IAAI,qBAAqB;AACvB,MAAI,KAAKJ,sCAAsC,EAAG,QAAO;AACzD,MAAI,KAAKI,OAAO,SAAS,EAAG,QAAO;AACnC,SACE,YAAY,KAAK,GACjB,KAAKJ,qCAAqC,KAAKG;CAElD;;;;CAKD,IAAI,aAAa;AACf,SAAO,KAAKE,WAAW,CAAC,QAAQ,CAAC;CAClC;;;;;;;CAQD,QAAQR,QAAgB;AACtB,MAAI,KAAKQ,WAAW,CAAC,QAAQ,CAAC,CAAE;EAChC,MAAM,OAAO,KAAKH;EAClB,KAAKG,SAAS,CAAC,QAAQ,CAAC;EACxB,KAAK,KAAK,IAAI,IAAI,CAAC,mBAAmB,EAAG,OAAQ,CAAC,CAAC,CAAC;AACpD,OAAK,MAAM,KAAK,KAAKD,QACnB,EAAE,SAAS,CAAC,SAAS,EAAG,QAAS,EAAE,KAAK;EAE1C,KAAKA,SAAS,CAAE;EAChB,KAAKD,mBAAmB,YAAY,KAAK;EACzC,KAAK,KAAK,iBAAiB,MAAM,OAAO;AAExC,MAAI,KAAK,KAAK,cAAc,KAAK,KAAK,aAAa,KAAK;CACzD;AACF;;;;;;;;;;;;AAaD,IAAa,OAAb,MAAqB;CACnB,AAAQ;CACR,AAAQ;CAER,AAAS;CACT,AAAS;CACT,AAAS;CAET,AAAS;CACT,AAAS;CACT,AAAQ;CACR,AAAS;CAET,AAAS,aAAiC,CAAC,IAAI,CAAC,CAAC;;;;;;;CAQjD,YAAYI,UAA0B,CAAE,GAAE;EACxC,KAAK,WAAW,QAAQ,YAAY;EACpC,KAAK,aAAa,QAAQ,cAAc,CAAC,KAAK,CAAC;EAC/C,KAAK,sBAAsB,QAAQ,uBAAuB;EAC1D,KAAK,oBAAoB,QAAQ,qBAAqB;EACtD,KAAK,oCACH,QAAQ,qCAAqC;EAE/C,KAAK,mBAAmB,QAAQ;EAChC,KAAK,eAAe,QAAQ;EAE5B,KAAK,yBAAS,IAAI;EAClB,KAAK,aAAa,CAAE;EAEpB,KAAK,aAAmB,CAAC,IAAI,CAAC,EAAE,QAAQ,SAAS,MAAM;EAIvD,MAAM,QAAQ,KAAK,IACjB,KAAK,mBACL,KAAK,kCACN;AACD,MAAI,QAAQ,GACV,YAAY,MAAM;GAChB,KAAK,UAAU;EAChB,GAAE,QAAQ,IAAI;CAElB;;;;;CAMD,eAAe;EACb,IAAI,IAAI,CAAC;cACC,EAAG,KAAK,SAAU,oBAAoB,EAAG,KAAK,kBAAmB,sBAAsB,EAAG,KAAK,oBAAqB;qBAC7G,EAAG,KAAK,WAAW,QAAS;EAE7C,MAAM,WAAW,KAAK,WAAW,IAAI,CAACC,QAAMA,IAAE,UAAU,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;EACxE,KAAK,CAAC,oBAAoB,CAAC,GAAG;EAE9B,KAAK,CAAC,eAAe,CAAC;AACtB,OAAK,MAAM,CAAE,GAAG,EAAG,IAAI,KAAK,OAAO,SAAS,EAC1C,KAAK,CAAC,KAAK,EAAG,EAAG,IAAI,EAAG,EAAE,UAAU,CAAE,IAAI,CAAC;AAE7C,SAAO;CACR;;;;;CAMD,2BAA2B;AACzB,SAAO,CAAE,GAAG,KAAK,OAAO,QAAQ,AAAE,EAAC,KAAK,CAAC,GAAG,MAAM;GAChD,MAAM,KAAK,EAAE;GACb,MAAM,KAAK,EAAE;AACb,OAAI,OAAO,GAAI,QAAO;AACtB,OAAI,KAAK,GAAI,QAAO;AACpB,UAAO;EACR,EAAC;CACH;;;;;CAMD,0BAA0B;AACxB,SAAO,CAAE,GAAG,KAAK,UAAY,EAAC,KAAK,CAAC,GAAG,MAAM;AAC3C,OAAI,EAAE,eAAe,EAAE,WAAY,QAAO;AAC1C,OAAI,EAAE,aAAa,EAAE,WAAY,QAAO;AACxC,UAAO;EACR,EAAC;CACH;;;;;;;CAQD,YAAYC,UAAa;AACvB,MAAI,aAAa,OACf,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;AAEjD,MAAI,aAAa,KAAM,OAAM,IAAI,UAAU,CAAC,wBAAwB,CAAC;AAErE,MAAI,KAAK,WAAW,KAAK,KAAK,WAAW,WAAW,KAAK,SACvD,OAAM,IAAI,MACR,CAAC,gBAAgB,EAAG,KAAK,SAAU,2BAA2B,CAAC;EAInE,KAAK,IAAI,IAAI,CAAC,iBAAiB,EAAG,KAAK,UAAU,SAAS,EAAG,CAAC;EAC9D,MAAM,KAAK,IAAI,SAAY,MAAM;EACjC,KAAK,WAAW,KAAK,GAAG;AACxB,SAAO;CACR;;;;;CAMD,WAAW;EACT,IAAI,UAAU;EAGd,MAAMC,OAAsB,CAAE;AAC9B,OAAK,MAAM,KAAK,KAAK,WACnB,KAAI,EAAE,YAAY;GAChB,KAAK,IAAI,IAAI,CAAC,6BAA6B,EAAG,KAAK,UAAU,EAAE,KAAK,EAAG,CAAC;GACxE,KAAK,KAAK,EAAE;EACb,WAAU,EAAE,oBAAoB;GAC/B,KAAK,IAAI,IAAI,CAAC,4BAA4B,EAAG,KAAK,UAAU,EAAE,KAAK,EAAG,CAAC;GACvE,KAAK,KAAK,EAAE;EACb;AAIH,MAAI,KAAK,SAAS,GAAG;AACnB,QAAK,MAAM,YAAY,MACrB,SAAS,QAAQ,CAAC,eAAe,CAAC,CAAC;GAErC,UAAU;EACX;EAGD,MAAMC,mBAA6B,CAAE;AACrC,OAAK,MAAM,CAAE,KAAK,KAAM,IAAI,KAAK,OAAO,SAAS,CAC/C,KAAI,CAAC,KAAK,SAAS;GACjB,KAAK,IAAI,IACP,CAAC,wBAAwB,EAAG,KAAK,IAAK,YAAY,EAAG,KAAK,WAAY,UAAU,EAAG,KAAK,UAAW,oBAAoB,EAAG,KAAK,SAAS,WAAY,CAAC,CAAC,CACvJ;GAED,iBAAiB,KAAK,IAAI;GAC1B,KAAK,SAAS,CAAC,OAAO,CAAC,EAAE,KAAK,KAAK;EACpC;AAGH,OAAK,MAAM,WAAW,kBAAkB;GACtC,KAAK,OAAO,OAAO,QAAQ;GAC3B,UAAU;EACX;AAED,MAAI,SACF,KAAK,IAAI,IACP,CAAC,mBAAmB,EAAG,KAAK,WAAW,OAAQ,QAAQ,EAAG,KAAK,aAAc,CAC9E;CAEJ;;;;;;CAOD,CAAC,YAAY;EACX,MAAM,WAAW,CAAE,GAAG,KAAK,UAAY;AACvC,OAAK,MAAM,KAAK,UACd,MAAM;CAET;;;;;;;;CASD,CAAC,SAAS;EACR,MAAM,WAAW,CAAE,GAAG,KAAK,UAAY;AACvC,OAAK,MAAM,KAAK,UACd,MAAM,EAAE;CAEX;;;;;CAMD,QAAQC,SAAiBC,QAAuB;EAC9C,MAAM,KAAK,KAAK,OAAO,IAAI,QAAQ;AACnC,MAAI,CAAC,GAAI;EACT,GAAG,QAAQ,UAAU,CAAC,YAAY,CAAC,CAAC;CACrC;;;;;CAMD,SAASP,MAAmB;EAC1B,KAAK,OAAO,OAAO,KAAK,IAAI;CAC7B;;;;;;CAOD,iBAAiBV,UAAuBkB,GAAW;EACjD,KAAK,aAAa,KAAK,WAAW,OAAO,CAAC,MAAM,MAAM,SAAS;CAChE;;;;;;CAOD,YAAYL,UAAsB;EAChC,MAAM,QAAQ,KAAK,WAAW,KAAK,CAAC,MAAM,EAAE,SAAS,SAAS;AAC9D,SAAO,UAAU;CAClB;;;;;;CAOD,QAAQG,SAA0B;AAChC,SAAO,KAAK,OAAO,IAAI,QAAQ;CAChC;;;;;;;CAQD,AAAQ,QAAQjB,KAAaC,UAAuB;EAClD,MAAM,IAAI,IAAI,SAAY,KAAK;EAC/B,KAAK,OAAO,IAAI,KAAK,EAAE;EACvB,SAAS,QAAQ,EAAE;AACnB,SAAO;CACR;;;;;;;CAQD,kBAAkBgB,SAA0C;EAE1D,MAAM,SAAS,KAAK,yBAAyB;AAI7C,MAAI,OAAO,SAAS,KAAK,OAAQ,GAAI,iBAAiB;GAGpD,MAAM,IAAI,KAAK,QAAQ,SAAS,OAAQ,GAAI;AAC5C,UAAO;EACR;AAGD,MACE,KAAK,qBACJ,KAAK,WAAW,KAAK,KAAK,WAAW,SAAS,KAAK,WACpD;GACA,KAAK,IAAI,IACP,CAAC,UAAU,EAAG,KAAK,SAAU,YAAY,EAAG,KAAK,WAAW,QAAS,CACtE;GACD,MAAM,oBAAoB,KAAK,YAAY,KAAK,kBAAkB,CAAC;GACnE,MAAM,IAAI,KAAK,QAAQ,SAAS,kBAAkB;AAClD,UAAO;EACR;CACF;;;;CAKD,IAAI,cAAc;AAChB,SAAO,CAAE,GAAG,KAAK,OAAO,QAAQ,AAAE,EAAC;CACpC;;;;;;CAOD,SAASA,SAAoB;EAC3B,MAAM,WAAW,KAAK,IAAI,QAAQ;AAClC,SAAO,SAAS,SAAS;CAC1B;;;;;;;;;;;;;;;;;;CAmBD,IAAIA,SAA8B;EAChC,MAAM,KAAK,KAAK,OAAO,IAAI,QAAQ;AACnC,MAAI,IAAI;GACN,GAAG,WAAW;AACd,UAAO;EACR;EAED,KAAK,UAAU;EAEf,MAAM,QAAQ,KAAKG,kBAAkB,QAAQ;AAC7C,MAAI,MAAO,QAAO;AAGlB,MAAI,KAAK,eAAe,CAAC,KAAK,CAAC,CAE7B,OAAM,IAAI,MACR,CAAC,gCAAgC,EAAG,KAAK,WAAY,YAAY,EAAG,KAAK,SAAU,CAAC,CAAC;AAIzF,MAAI,KAAK,eAAe,CAAC,eAAe,CAAC,EAAE;GACzC,MAAM,QAAQ,KAAK,0BAA0B;AAC7C,OAAI,MAAM,SAAS,GAAG;IACpB,KAAK,QAAQ,MAAO,GAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;IAEjD,MAAM,SAAS,KAAKA,kBAAkB,QAAQ;AAC9C,QAAI,OAAQ,QAAO;GACpB;EACF;AAKD,QAAM,IAAI,MAAM,CAAC,oBAAoB,EAAG,KAAK,WAAY,CAAC,CAAC;CAC5D;AACF;;;;;;AAOD,MAAa,SAAS,CAAIR,UAA0B,CAAE,MAAc,IAAI,KAAQ;;;;;;;;;;;;;;;;;;;;;;AClqBhF,SAAgB,uBAA0B;CACxC,IAAIS;CACJ,IAAIC;CACJ,MAAM,UAAU,IAAI,QAClB,CAAC,UAAU,YAAY;EACrBC,YAAU;EACV,SAAS;CACV;AAEH,QAAO;EAAE;EAAS,SAASA;EAAkB;CAAS;AACvD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC6BD,MAAa,cAAc,CAASC,YAAwC;CAC1E,IAAI,WAAW;CAEf,MAAM,IAAIC,UAAQ,MAAM;AACtB,MAAI,SAAU;EACd,EAAE,OAAO;EACT,QAAQ,WAAW,QAAQ,UAAU,CAAC;CACvC,GAAE,QAAQ,SAAS;AAGpB,KAAI,QAAQ,OACV,QAAQ,MAAM,iBAAiB,CAAC,KAAK,CAAC,EAAE,OAAK;EAC3C,WAAW;EACX,EAAE,QAAQ;CACX,EAAC;CAEJ,EAAE,OAAO;AAET,QAAO,CAACC,SAAiB;AACvB,MAAI,SAAU,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;EAC1D,EAAE,OAAO;EACT,QAAQ,WAAW,KAAK;CACzB;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqBD,gBAAuB,OACrBC,SACAC,MACmB;CACnB,MAAM,SAAS,KAAK,UAAU;CAC9B,MAAM,YAAY,KAAK,aAAa,CAAC,MAAM,CAAC;CAC5C,MAAM,QAAQ,KAAK,SAAS;CAC5B,MAAM,iBAAiB,KAAK,kBAAkB;CAC9C,MAAM,gBAAgB,KAAK,eAAe,aAAa,KAAK,aAAa,GAAG;CAC5E,MAAM,gBAAgB,KAAK;CAE3B,IAAI,YAAY;CAChB,IAAI,UAAU,aAAa,KAAK,OAAO,aAAa,KAAK,cAAc,EAAE,CAAC;CAC1E,IAAI,UAAU,YAAY,KAAK;CAE/B,MAAM,UAAU,YAAY;EAC1B,MAAM,UAAU,YAAY,KAAK,GAAG;AACpC,MAAI,OAAO,kBAAkB,CAAC,SAAS,CAAC,EACtC,UAAU,KAAK,IAAI,GAAG,gBAAgB,QAAQ;AAEhD,MAAI,SACF,MAAM,MAAM;GAAE,QAAQ;GAAS;EAAQ,EAAC;EAE1C,UAAU,YAAY,KAAK;AAC3B,MAAI,QAAQ,QAAS,OAAM,IAAI,MAAM,CAAC,eAAe,EAAG,OAAO,QAAS;CACzE;AAED,KAAI,MAAM,QAAQ,QAAQ,EAAE,UAAU,QAAQ,QAAQ;AAEtD,KAAI,KAAK,SAAS,KAAK,SAAS;CAEhC,IAAI,UAAU;CACd,IAAI,cAAc;AAClB,KAAI;AACF,SAAO,CAAC,WAAW;GACjB;AACA,OAAI,cAAc,CAAC,MAAM,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,MAAM,SAAS;GACnE,MAAM,SAAS,MAAM,QAAW,QAAQ;AACxC,OAAI,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,gBACpC,YAAY;QACP;IACL,MAAM;AACN,QAAI,cAAc,CAAC,KAAK,CAAC,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE,MAAM,SAAS;AAClE,QAAI,UAAU,UAAa,eAAe,OAAO,YAAY;GAC9D;AACD,OAAI,eACF;QAAI,CAAC,cAAc,YAAY,EAC7B,YAAY;GACb;EAEJ;EACD,UAAU;CACX,UAAS;EACR,YAAY;AACZ,MAAI,KAAK,YAAY,KAAK,WAAW,QAAQ;CAC9C;AACF;;;;;;;;;;;;;;;;AAkBD,UAAiB,WACfC,SACAC,MACA;CACA,MAAM,SAAS,KAAK,UAAU;CAC9B,MAAM,QAAQ,KAAK,SAAS;CAC5B,MAAM,iBAAiB,KAAK,kBAAkB;CAC9C,IAAI,YAAY;AAEhB,KAAI,MAAM,QAAQ,QAAQ,EAAE,UAAU,QAAQ,QAAQ;AAEtD,KAAI,KAAK,SAAS,KAAK,SAAS;CAEhC,IAAI,UAAU;CACd,IAAI,cAAc;AAElB,KAAI;AACF,SAAO,CAAC,WAAW;GACjB;GACA,MAAM,SAAS,YAAe,QAAQ;AACtC,OAAI,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,gBACpC,YAAY;QACP;IACL,MAAM;AACN,QAAI,UAAU,UAAa,eAAe,OAAO,YAAY;AAC7D,QAAI,QAAQ,SAAS,YAAY;GAClC;EACF;EACD,UAAU;CACX,UAAS;EACR,YAAY;AACZ,MAAI,KAAK,YAAY,KAAK,WAAW,QAAQ;CAC9C;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1HD,IAAa,uBAAb,cAA2D,mBAAgE;CACzH;CACA;CACA;CACA;CAEA,4BAAY,IAAI;CAChB;CAEA,YAAYC,UAA4D,CAAE,GAAE;EAC1E,OAAO;AACP,MAAI,OAAO,WAAW,CAAC,SAAS,CAAC,EAC9B,WAAmB,SAAS;GACf;GACE;EACf;EAEH,KAAK,YAAY,QAAQ,aAAa;EACtC,KAAK,wBAAwB,QAAQ,yBAAyB,CAAC,KAAK,CAAC;EACrE,KAAKC,gBAAgB,aAAa,MAAM,KAAKC,WAAW,EAAE,KAAK,YAAY,EAAE;AAC7E,MAAI,QAAQ,KAAK;AACf,OAAI,QAAQ,WAAY,OAAM,IAAI,MAAM,CAAC,0CAA0C,CAAC;AACpF,OAAI,QAAQ,YAAa,OAAM,IAAI,MAAM,CAAC,2CAA2C,CAAC;GAEtF,KAAK,aAAa,QAAQ;GAC1B,KAAK,cAAc,QAAQ;EAC5B,OAAM;AACL,OAAI,CAAC,QAAQ,cAAc,CAAC,QAAQ,YAClC,OAAM,IAAI,MAAM,CAAC,yEAAyE,CAAC;GAE7F,KAAK,aAAa,QAAQ;GAC1B,KAAK,cAAc,QAAQ;EAC5B;CACF;CAED,YAAY;EACV,MAAM,SAAS,CAAE,GAAG,KAAKC,UAAU,QAAQ,AAAE;EAC7C,MAAM,MAAM,KAAK,KAAK;AACtB,OAAK,MAAM,KAAK,OACd,KAAI,EAAE,aAAa,KAAK;AAEtB,OAAI,EAAE,eACJ,EAAE,cAAc,CAAC,eAAe,CAAC,CAAC;GAEpC,MAAM,WAAW,EAAE;AACnB,OAAI,UACF,WAAW,MAAM;IACf,SAAS,MAAM,CAAC,eAAe,CAAC,CAAC;GAClC,GAAE,EAAE;GAEP,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE;IAAE,SAAS,EAAE;IAAK,UAAU,CAAC,eAAe,CAAC;IAAE,SAAS;GAAO,EAAC;GAC5F,KAAKA,UAAU,OAAO,EAAE,GAAG;EAC5B;EAEH,KAAK,WAAW;AAChB,SAAO,KAAKA,UAAU,OAAO;CAC9B;CAED,YAAY;EACV,MAAM,SAAS,CAAE,GAAG,KAAKA,UAAU,QAAQ,AAAE;EAC7C,MAAM,MAAM,KAAK,KAAK;AACtB,OAAK,MAAM,KAAK,QAAQ;GACtB,MAAM,SAAS,MAAM,EAAE;GACvB,QAAQ,IAAI,GAAI,EAAE,GAAI,aAAa,EAAG,KAAK,MAAM,SAAS,IAAK,CAAC,UAAU,CAAE,CAAC,CAAC,CAAC;EAChF;CACF;;;;;;;;;CAwBD,QAAQC,SAAmBC,UAAsF;AAC/G,MAAI,aAAa,QAAW;GAAE,KAAKC,iBAAiB,SAAS,SAAS;AAAE;EAAS;AACjF,SAAO,KAAKC,cAAc,QAAQ;CACnC;;;;;CAMD,iBAAiBH,SAAmB;EAClC,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,MAAI,KAAKD,UAAU,IAAI,GAAG,CAAE,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAG,GAAI,CAAC,CAAC;EAEzF,MAAMK,IAAkC;GACtC,WAAW,KAAK,KAAK,GAAG,KAAK;GAC7B;GACA,KAAK;EACN;EACD,KAAKL,UAAU,IAAI,IAAI,EAAE;EACzB,KAAKF,cAAc,OAAO;CAC3B;;;;;;;CAQD,cAAcG,SAAmB;EAC/B,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,MAAI,KAAKD,UAAU,IAAI,GAAG,CAAE,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAG,GAAI,CAAC,CAAC;EAEzF,MAAM,IAAI,IAAI,QAAe,CAACM,WAAS,WAAW;GAChD,MAAMD,IAAkC;IACtC,WAAW,KAAK,KAAK,GAAG,KAAK;IAC7B;IACA,KAAK;IACL,gBAAgBC;IAChB,eAAe;GAChB;GACD,KAAKN,UAAU,IAAI,IAAI,EAAE;GACzB,KAAKF,cAAc,OAAO;EAE3B;AACD,SAAO;CACR;;;;;;CAOD,iBAAiBG,SAAmBM,UAA8D;EAChG,MAAM,KAAK,KAAK,WAAW,QAAQ;AACnC,MAAI,KAAKP,UAAU,IAAI,GAAG,CAAE,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAG,GAAI,CAAC,CAAC;EAEzF,MAAMK,IAAkC;GACtC,WAAW,KAAK,KAAK,GAAG,KAAK;GAC7B;GACA,KAAK;GACL;EACD;EACD,KAAKL,UAAU,IAAI,IAAI,EAAE;EACzB,KAAKF,cAAc,OAAO;CAC3B;;;;;;CAOD,SAASU,UAAiBC,WAA6B;EACrD,MAAM,KAAK,KAAK,YAAY,SAAS;EACrC,MAAM,UAAU,KAAKT,UAAU,IAAI,GAAG;AACtC,MAAI,CAAC,SAAS;AACZ,OAAI,KAAK,0BAA0B,CAAC,KAAK,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,6BAA6B,EAAG,GAAI,CAAC,CAAC,EAAE,EAAE,OAAO,SAAU;AAExH,UAAO;EACR;AAED,MAAI,WAEF,QAAQ,YAAY,KAAK,KAAK,GAAG,KAAK;OAEtC,KAAKA,UAAU,OAAO,GAAG;AAE3B,MAAI,QAAQ,gBACV,QAAQ,eAAe,SAAS;AAElC,MAAI,QAAQ,UACV,QAAQ,SAAS,OAAO,SAAS;EAEnC,KAAK,UAAU,CAAC,KAAK,CAAC,EAAE;GAAE,SAAS,QAAQ;GAAe;EAAU,EAAC;AACrE,MAAI,CAAC,WACH,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE;GAAE,SAAS,QAAQ;GAAe;GAAU,SAAS;EAAM,EAAC;AAE1F,SAAO;CACR;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxLD,UAAiB,iBAAiBU,UAAmC,CAAE,GAAE;CACvE,MAAM,UAAU,QAAQ,WAAW;CACnC,IAAI,gBAAgB,QAAQ,iBAAiB,OAAO;CACpD,MAAM,aAAa,QAAQ;CAC3B,MAAM,QAAQ,QAAQ,SAAS;CAC/B,IAAI,QAAQ;CACZ,YACE,YAAY,eAAe,CAAC,SAAS,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC,EACxD,WAAW,SAAS,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC,EAClC,WAAW,eAAe,EAAE,EAAE,CAAC,aAAa,CAAC,CAAC,EAC9C,MAAO,eAAe,SAAa,WAAW,YAAY,EAAE,EAAE,CAAC,UAAU,CAAC,CAAC,GAAG,QAC9E,WAAW,OAAO,EAAE,EAAE,CAAC,KAAK,CAAC,CAAC,CAC/B;AAED,QAAO,gBAAgB,GAAG;AAExB,MAAI,cAAc,SAAS,WAAY;EACvC;EACA,MAAM;EAGN,SAAS,KAAK,IAAI,OAAO,MAAM;CAChC;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0ED,MAAa,gBAAgB,CAAIC,UAAwCC,UAAiC,CAAE,MAAK;CAC/G,MAAMC,OAAqB,EACzB,MAAM,QAAQ;AACZ,MAAI;GACF,MAAM,IAAI,MAAM,UAAU;AAC1B,OAAI,MAAM,OAAW,QAAO;IAAE,OAAO,QAAQ;IAAmB,OAAO,CAAC,QAAQ,CAAC;IAAE,SAAS;GAAO;AACnG,UAAO;IAAE,OAAO;IAAG,SAAS;GAAM;EACnC,SAAQ,OAAO;AACd,UAAO;IAAE,SAAS;IAAc;GAAgB;EACjD;CACF,EACF;AACD,QAAO,UAAU,MAAM,QAAQ;AAChC;;;;;;;;;;;;;;;;;;;;;AAsBD,MAAa,YAAY,OACvBC,MACAC,OAA8B,CAAE,MACJ;CAC5B,MAAM,SAAS,KAAK;CACpB,MAAM,MAAM,iBAAiB,KAAK,IAAI;CACtC,MAAM,aAAa,KAAK,cAAc;CACtC,MAAM,YAAY,cAAc;CAEhC,IAAI,WAAW;CACf,MAAM,eAAe,KAAK,WAAW;CACrC,MAAM,gBAAgB,KAAK,iBAAiB,OAAO;CACnD,MAAM,aAAa,iBAAiB;EAAE,GAAG;EAAM,SAAS;EAAc;CAAe,EAAC;AAEtF,KAAI,gBAAgB,EAAG,OAAM,IAAI,MAAM,CAAC,uCAAuC,CAAC;AAEhF,KAAI,aAAa,EACf,KAAI;EACF,MAAM,MAAM;GAAE,QAAQ;GAAoB;EAAQ,EAAC;CACpD,SAAQ,OAAO;AAEd,SAAO;GACL,SAAS;GACT;GACA,OAAO,KAAK;GACZ,SAAS,WAAW;GACpB,SAAS,gBAAgB,MAAM;EAChC;CACF;AAGH,MAAK,MAAM,KAAK,YAAY;EAC1B;EAGA,MAAM,SAAS,MAAM,KAAK,MAAM,SAAS;AACzC,MAAI,OAAO,QACT,QAAO;GAAE,SAAS,OAAO;GAAS,OAAO,OAAO;GAAO;GAAU,SAAS,WAAW;EAAE;EAEzF,IAAI,EACF,KAAK,CAAC,gBAAgB,EAAG,SAAS,UAAU,CAAE,IAAI,EAAG,qBAAqB,EAAE,EAAG,CAChF,EAAC;AAGF,MAAI,YAAY,cACd;AAGF,MAAI;GACF,MAAM,MAAM;IAAE,QAAQ;IAAG;GAAQ,EAAC;EACnC,SAAQ,OAAO;AAEd,UAAO;IACL,SAAS;IACT;IACA,OAAO,KAAK;IACZ,SAAS,gBAAgB,MAAM;IAC/B,SAAS,WAAW;GACrB;EACF;CACF;AAED,QAAO;EACL,SAAS,CAAC,gBAAgB,EAAG,SAAS,UAAU,CAAE,UAAU,CAAC;EAC7D,SAAS;EACT;EACA,OAAO,KAAK;EACZ,SAAS,WAAW;CACrB;AACF;;;;;;;;;;;;;;;;;;ACpRD,MAAa,UAAU,CAACC,UAA0C;CAChE,IAAIC,QAAM;CACV,IAAI,UAAU;AACd,QAAO,MAAM;AACX,MAAIA,MAAK,QAAO;EAChBA,QAAM;EACN,UAAU,OAAO;AACjB,SAAO;CACR;AACF;;;;;;;;;;;;;;;;;;;;;;;;;ACFD,IAAa,WAAb,MAAsB;CACpB;CACA;CACA;CAEA,SAAS;AACP,MAAI,KAAKC,UAAU;GACjB,KAAKA,UAAU;GACf,KAAKA,WAAW;EACjB;EACD,KAAKC,WAAW,QAAQ,SAAS;CAClC;;;;;CAMD,QAAQ;AACN,MAAI,KAAKC,SAAS;GAChB,KAAKA,QAAQ,CAAC,OAAO,CAAC,CAAC;GACvB,KAAKA,UAAU;EAChB;EACD,KAAKF,WAAW;EAChB,KAAKC,WAAW;CACjB;CAED,eAAe;EACb,MAAM,IAAI,IAAI,QAAQ,CAACE,WAAS,WAAW;GACzC,KAAKH,WAAWG;GAChB,KAAKD,UAAU;EAChB;EACD,KAAKD,WAAW;AAChB,SAAO;CACR;;;;;;CAOD,MAAM,UAAUG,eAAwB;EACtC,IAAI,IAAI,KAAKH;EACb,MAAM,KAAKI,cAAc;AACzB,MAAI,eAAe;GACjB,MAAM,SAAS,KAAKH;GACpB,WAAW,MAAM;AACf,QAAI,QACF,OAAO,CAAC,gBAAgB,EAAG,cAAc,UAAU,EAAG,CAAC;GAE1D,GAAE,cAAc;EAClB;EACD,MAAM;EACN,KAAKD,WAAW;EAChB,KAAKD,WAAW;EAChB,KAAKE,UAAU;CAChB;;;;;;;;;;;CAYD,MAAM,UAAUI,eAAyC;AACvD,MAAI;GACF,MAAM,KAAK,UAAU,cAAc;AACnC,UAAO;EACR,QAAO;AACN,UAAO;EACR;CACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CD,IAAa,mBAAb,MAAa,yBAAyB,mBAAoC;CACxE,OAAgB,SAAS,IAAI;CAC7B,AAAQ;CACR,AAAQ;CAER,AAAQ,cAAc;EACpB,OAAO;EACP,KAAK,kBAAoC;EACzC,KAAK,QAAQ,aAAa,MAAM;AAC9B,UAAO,KAAK,cAAc;EAC3B,GAAE,IAAI;CACR;;;;;;;;;;;CAYD,QAAQC,MAA2B;EACjC,MAAM,SAAS,KAAK,OAAO,QAAQ,KAAK;AACxC,MAAI,KAAK,MAAM,aAAa,CAAC,IAAI,CAAC,EAAE;GAClC,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE,CAAE,EAAC;GAC7B,KAAK,MAAM,OAAO;EACnB;AACD,SAAO;CACR;CAED,UAAU;AACR,SAAO,KAAK,OAAO,SAAS;CAC7B;CAED,MAAc,eAAe;EAC3B,MAAM,OAAO,KAAK,OAAO,SAAS;AAClC,MAAI,SAAS,QAAW;GACtB,KAAK,UAAU,CAAC,KAAK,CAAC,EAAE,CAAE,EAAC;AAC3B,UAAO;EAER;AAED,MAAI;GACF,MAAM,MAAM;EACb,SAAQ,OAAO;GACd,QAAQ,MAAM,MAAM;EACrB;CAEF;;;;;;CAOD,QAAQ;AACN,MAAI,KAAK,OAAO,WAAW,EAAG;EAC9B,KAAK,OAAO,OAAO;EACnB,KAAK,MAAM,QAAQ;EACnB,KAAK,UAAU,CAAC,KAAK,CAAC,EAAE,CAAE,EAAC;CAC5B;;;;CAKD,IAAI,UAAU;AACZ,SAAO,KAAK,OAAO;CACpB;;;;CAMD,IAAI,SAAS;AACX,SAAO,KAAK,OAAO;CACpB;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtGD,MAAa,WAAW,CACtBC,UAIAC,kBACG;CACH,IAAI,UAAU;AACd,QAAO,OAAO,GAAG,SAAoB;EACnC,MAAM,UAAU,YAAY,KAAK,GAAG;AACpC,MAAI,WAAW,eAAe;GAC5B,MAAM,IAAI,SAAS,SAAS,GAAG,KAAK;AACpC,OAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,MAAM;GACjC,UAAU,YAAY,KAAK;EAC5B;CACF;AACF;;;;;;;;;;;;;;;;;;ACyBD,SAAgB,WAAWC,SAAkC;CAC3D,MAAM,IAAI,SAAS,aAAa,SAAS,EAAE,EAAE;EAAE,OAAO,6BAA6B;EAAE,YAAY;CAAM,EAAC;AACxG,QAAO,MAAM,EAAE;AAChB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCD,SAAgB,QACdC,UACAC,OAAwE,CAAE,GAC5D;CACd,MAAM,UAAU,aAAa,SAAS;AACtC,KAAI,CAAC,QAAS,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;CAC1D,MAAM,YAAY;EAChB,GAAG;EACH,OAAO,6BAA6B;CACrC;CACD,IAAIC;AACJ,QAAO,MAAM;EACX,MAAM,SAAS,SAAS,UAAU;AAClC,SAAO,EAAE;CACV;AACF;;;;;;;;;;;;;;;;;;;;;AAsBD,SAAgB,aAAaC,YAAoBF,OAAwE,CAAE,GAC3G;CACd,MAAM,YAAY;EAChB,GAAG;EACH,OAAO,sBAAsB;CAC9B;CACD,IAAIC;AACJ,QAAO,MAAM;EACX,MAAM,SAAS,YAAY,UAAU;AACrC,SAAO,EAAE;CACV;AACF;;;;;;AAOD,MAAa,kBAAkB,OAAwB;CACrD,SAAS;CACT,QAAQ;CACR,QAAc,CAEb;CACD,IAAI,KAAK,CAER;AACF;;;;;;AAOD,MAAa,iBAAiB,OAC5B;CACE,SAAS;CACT,QAAQ;CACR,QAAQ,CAEP;CACD,MAAM,CAEL;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CH,MAAa,WAAW,CACtBE,OACAC,UAAsC,CAAE,MACpB;AAEpB,KAAI,CAAC,OAAO,SAAS,MAAM,CACzB,QAAO,iBAAiB;UACf,OAAO,MAAM,MAAM,CAC5B,QAAO,gBAAgB;CAGzB,MAAM,aAAa,QAAQ,cAAc;CACzC,MAAM,YAAY,QAAQ,aAAa;AACvC,KAAI,cAAc,UAAW,OAAM,IAAI,MAAM,CAAC,+CAA+C,CAAC;CAE9F,IAAI,mBAAmB;CAGvB,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;CAE5D,IAAI,YAAY;CAChB,MAAM,iBAAiB,CAACC,UAAkB;EACxC,YAAY;EACZ,IAAI,IAAI,SAAS,QAAQ;AACzB,MAAI,YAAY,IAAI,MAAM,EAAE;WACnB,aAAa,KAAK,GAAG,IAAI,IAAI;AACtC,SAAO;CACR;AAED,QAAO;EACL,IAAIC,KAAa;GACf,mBAAmB;EACpB;EACD,IAAI,SAAS;AAGX,UAAO,eAAe,UAAU,IAAI;EACrC;EACD,IAAI,UAAU;AACZ,UAAO,eAAe,MAAM,QAAQ;EACrC;EACD,OAAO,MAAM;GACX,MAAM,OAAO;EACd;CACF;AACF;;;;;;;;;;;;;;;;;;;;;;;AAyBD,MAAa,iBAAiB,CAC5BC,WACAC,UAA8B,CAAE,MACZ;CACpB,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;CAC5D,MAAM,kBAAkB,YAAY;CACpC,IAAI,mBAAmB;CAEvB,MAAM,iBAAiB,MAAM;EAE3B,MAAM,IAAI,MAAM,WAAW,kBAAkB;EAG7C,MAAM,IAAI,IAAI,KAAK,MAAM,EAAE;AAC3B,MAAI,IAAI,EACN,OAAM,IAAI,MACR,CAAC,gDAAgD,EAAG,EAAG,IAAI,EAAG,GAAI;AAGtE,MAAI,IAAI,EACN,OAAM,IAAI,MACR,CAAC,gDAAgD,EAAG,EAAG,IAAI,EAAG,GAAI;AAGtE,SAAO;CACR;AACD,QAAO;EACL,KAAK,CAACF,QAAgB;GACpB,mBAAmB;EACpB;EACD,OAAO,MAAM;GACX,MAAM,OAAO;EACd;EACD,IAAI,SAAS;AACX,UAAO,gBAAgB,IAAI;EAC5B;EACD,IAAI,UAAU;AACZ,UAAO,gBAAgB;EACxB;CACF;AACF;;;;;;;;;;;;AAaD,MAAa,8BAA8B,MAAa;CACtD,IAAI,QAAQ,YAAY,KAAK;AAC7B,QAAO;EAIL,OAAO,MAAM;GACX,QAAQ,YAAY,KAAK;EAC1B;EAID,IAAI,UAAU;AACZ,UAAO,YAAY,KAAK,GAAG;EAC5B;CACF;AACF;;;;;;;;;;;;;;;;;;AAmBD,MAAa,uBAAuB,MAAgC;CAClE,IAAI,QAAQ;AACZ,QAAO;EAIL,OAAO,MAAM;GACX,QAAQ;EACT;EAID,IAAI,OAAO;AACT,UAAO;EACR;EASD,IAAI,UAAU;AACZ,UAAO,EAAE;EACV;CACF;AACF;;;;;;;;;;;;;;;;;;AAoBD,MAAa,oBAAoB,CAC/BG,IACAC,UACgE;AAChE,KAAI,OAAO,OAAO,CAAC,QAAQ,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,sCAAsC,EAAG,OAAO,IAAK;CACpG,IAAI,aAAa;AACjB,QAAO;EACL,IAAI,UAAU;AACZ,UAAO,MAAM;EACd;EACD,IAAI,SAAS;AACX,UAAO,MAAM;EACd;EACD,IAAI,WAAW;AACb,OAAI,MAAM,OAAQ,QAAO,CAAC,IAAI,CAAC;AAC/B,UAAO,CAAC,SAAS,CAAC;EACnB;EAID,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,kBAAkB;AACpB,UAAO;EACR;EACD,SAAS,MAAM;GACb,MAAM,UAAU,MAAM;AACtB,UAAO,GAAG,QAAQ;EACnB;EACD,OAAO,MAAM;GACX,MAAM,OAAO;GACb;EACD;CACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnbD,MAAa,iBAAiB,CAC5BC,IACAC,UACAC,aAA+B,CAAC,IAAI,CAAC,KACd;CACvB,IAAI,UAAU;CACd,IAAIC;CACJ,IAAI,oBAAoB,aAAa,UAAU,IAAK;AAEpD,QAAO,MAEL,IAAI,QAAQ,OAAOC,WAAS,WAAW;EACrC,MAAM,UAAU,YAAY,KAAK,GAAG;AACpC,MAAI,cAAc,UAAa,UAAU,kBACvC,KAAI;GACF,UAAU,YAAY,KAAK;GAC3B,YAAY,MAAM,GAAG,QAAQ;GAC7B,oBAAoB,aAAa,UAAU,IAAK;EACjD,SAAQ,OAAO;AACd,OAAI,eAAe,CAAC,IAAI,CAAC,EAAE;IACzB,YAAY;IACZ,UAAU;GACX,WAAU,eAAe,CAAC,OAAO,CAAC,EACjC,oBAAoB,KAAK,MAAM,oBAAoB,IAAI;GAGzD,OAAO,MAAM;AACb;EACD;EAEHA,UAAQ,UAAU;CACnB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CD,IAAa,eAAb,MAA6B;CAC3B;CACA;CACA,WAAW;CACX,cAAc;EACZ,MAAM,EAAE,SAAS,oBAAS,GAAG,sBAAyB;EACtD,KAAKC,WAAW;EAChB,KAAKC,WAAWC;CACjB;;;;;;;;;;CAWD,MAAkB;AAChB,SAAO,KAAKF;CACb;;;;;;;CAQD,IAAIG,OAAU;AACZ,MAAI,KAAKC,SAAU,OAAM,IAAI,MAAM,CAAC,oCAAoC,CAAC;EACzE,KAAKA,WAAW;EAChB,KAAKH,SAAS,MAAM;CACrB;;;;;CAMD,IAAI,SAAS;AACX,SAAO,KAAKG;CACb;AACF;;;;AAKD,MAAa,aAAa,MAAS,IAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACMvC,MAAa,UAAU,CACrBC,WACAC,WACAC,eACG;CACH,IAAIC;CAEJ,IAAI,UAAU;CACd,MAAM,OAAO,CAACC,UAAmB;AAC/B,MAAI,MAAM,QAAW;GACnB,OAAO,aAAa,EAAE;GACtB,IAAI;EACL;AACD,MAAI,OACF,UAAU,MAAM;OAEhB,UAAU;AAEZ,MAAI,eAAe,QAAW,WAAW,QAAQ;CAClD;CAED,IAAI,WAAW,WAAW,MAAM;EAC9B,IAAI;AACJ,MAAI;GACF,UAAU,CAAC,cAAc,EAAG,UAAW,EAAE,CAAC,CAAC;EAC5C,UAAS;AACR,OAAI,eAAe,QAAW,WAAW,QAAQ;EAClD;CACF,GAAE,UAAU;AAEb,QAAO;AACR;;;;;;;;;ACrGD,MAAa,aAAa,CACxBC,YACoB;AACpB,QAAO,OAAO,OAAO;EACnB,OAAO,QAAQ;EACf,SAAS,CAAE,GAAG,QAAQ,OAAS;EAC/B,SAAS,QAAQ;CAClB,EAAC;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BD,MAAa,OAAO,CAClBC,cACAC,iBACoB;CACpB,MAAM,CAAE,SAAS,uBAAwB,GAAG,gBAAgB,aAAa;AACzE,KAAI,CAAC,QAAS,OAAM,IAAI,MAAM;CAE9B,MAAMC,QAEH,gBAAkB,OAAO,KAAK,QAAQ,OAAO,CAAE;AAClD,KAAI,OAAO,QAAQ,OAAQ,WAAY,CAAC,SAAS,CAAC,CAChD,OAAM,IAAI,UAAU,CAAC,gBAAgB,EAAG,MAAO,YAAY,CAAC;CAI9D,MAAM,cAAc,gCAAgC,QAAQ,OAAO;AACnE,KAAI,gBAAgB,OAClB,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AAEnD,QAAO,OAAO,OAAO;EACnB,OAAO;EACP,SAAS,CAAE;EACX,SAAS,OAAO,OAAO,OAAO,YAAY,YAAY,CAAC;CACxD,EAAC;AACH;AAED,MAAa,QAAQ,CACnBC,OACoB;AACpB,QAAO,KAAQ,GAAG,QAAe;AAClC;AAED,MAAa,kBAAkB,CAC7BC,oBACqD;AACrD,KAAI,OAAO,oBAAoB,CAAC,SAAS,CAAC,CACxC,QAAO,CAAE,QAAW,CAAC,mBAAmB,CAAC,AAAE;AAE7C,KAAK,oBAAgC,KACnC,QAAO,CAAE,QAAW,CAAC,cAAc,CAAC,AAAE;AAExC,KAAI,CAAC,MAAM,CAAC,IAAI,gBAEd,QAAO,CAAE,iBAA+B,EAAE,AAAE;AAE9C,KAAI,OAAO,oBAAoB,CAAC,MAAM,CAAC,CACrC,QAAO,CACL,EACE,QAAQ,gBACT,GACD,EAAE,AACH;AAEH,QAAO,CACL,QACA,CAAC,iBAAiB,EAAG,OAAO,gBAAiB,iBAAiB,CAAC,AAChE;AACF;;;;;;AAgCD,MAAa,SAAS,CAAwBD,OAAiC;AAC7E,QAAO,SAAS,GAAG,CAAC,WAAW;AAChC;;;;;;;AAQD,MAAa,kBAAkB,CAC7BA,OACoC;CAEpC,qBAAqB,GAAG;CAExB,MAAM,QAAQ,GAAG,QAAS,GAAG;AAE7B,KAAI,MAAM,WAAW,KAAK,MAAO,GAAI,UAAU,KAAM,QAAO,CAAE;AAC9D,QAAO;AACR;;;;;;;;AASD,MAAa,WAAW,CACtBA,OAC6B;CAC7B,MAAM,UAAU,gBAAgB,GAAG;AACnC,QAAO,QAAQ,IAAI,CAAC,MAAM,EAAE,MAAM;AACnC;AAED,MAAa,mBAAmB,CAC9BE,YAI8C;CAC9C,MAAM,wBAAwB,CAC5BC,WACqC;AAErC,MAAI,WAAW,KAAM,QAAO,EAAE,OAAO,KAAM;AAE3C,MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAC5B,QAAO,EACL,OAAO,OACR;WACQ,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,QAAQ;GAC1D,MAAM,cAAc,OAAO;AAC3B,OAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,OAAM,IAAI,UACR,CAAC,2CAA2C,EAAG,OAAO,aAAc;AAGxE,OAAI,CAAC,aAAa,CAAC,IAAI,OACrB,QAAO;IACL,OAAO;IACP,eAAe,OAAO;GACvB;AAEH,UAAO,EAAE,OAAO,YAAa;EAC9B,MACC,OAAM,IAAI,MACR,CAAC,iBAAiB,EAAG,OAAO,OAAQ,+CAA+C,CAAC;CAGzF;AAGD,KAAI,MAAM,QAAQ,QAAQ,EAAE;EAC1B,IAAI,eAAe;EACnB,MAAM,aAAa,QAAQ,IAAI,CAAC,MAAM;GACpC,MAAM,IAAI,sBAAsB,EAAE;AAClC,OAAI,CAAC,EAAG,OAAM,IAAI,MAAM,CAAC,cAAc,CAAC;GACxC,eAAe,gBAAgB,EAAE,UAAU;AAC3C,UAAO;EACR,EAAC;AACF,MAAI,gBAAgB,WAAW,SAAS,EACtC,OAAM,IAAI,MAAM,CAAC,qCAAqC,CAAC;AAEzD,SAAO;CACR,OAAM;EACL,MAAM,SAAS,sBAAsB,QAAQ;AAC7C,MAAI,CAAC,OAAQ;AACb,SAAO,CAAE,MAAQ;CAClB;AACF;AAED,MAAM,kCAAkC,CACtCC,MAC2D;CAC3D,MAAM,4BAAY,IAAI;AAGtB,MAAK,MAAM,CAAE,eAAe,gBAAiB,IAAI,OAAO,QAAQ,EAAE,EAAE;AAClE,MAAI,OAAO,kBAAkB,CAAC,SAAS,CAAC,CACtC,OAAM,IAAI,UAAU,CAAC,yBAAyB,CAAC;AAEjD,MAAI,OAAO,oBAAoB,CAAC,SAAS,CAAC,CACxC,OAAM,IAAI,UAAU,CAAC,2BAA2B,EAAG,eAAgB;AAErE,MAAI,UAAU,IAAI,cAAc,CAC9B,OAAM,IAAI,MAAM,CAAC,qBAAqB,EAAG,eAAgB;AAE3D,MAAI,cAAc,SAAS,CAAC,CAAC,CAAC,CAAC,CAC7B,OAAM,IAAI,MAAM,CAAC,iCAAiC,CAAC;EAErD,UAAU,IAAI,eAAe,CAAE,EAAC;CACjC;AAGD,MAAK,MAAM,CAAE,eAAe,gBAAiB,IAAI,OAAO,QAAQ,EAAE,EAAE;EAClE,MAAM,UAAU,iBAAiB,gBAAgB;AACjD,MAAI,YAAY,OAAW,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AACvE,MAAI,YAAY,MAAM;GAEpB,MAAM,6BAAa,IAAI;AACvB,QAAK,MAAM,UAAU,SAAS;AAC5B,QAAI,WAAW,IAAI,OAAO,MAAM,CAC9B,OAAM,IAAI,MAER,CAAC,cAAc,EAAG,OAAO,MAAO,sBAAsB,EAAG,cAAe,CAAC,CAAC;IAG9E,WAAW,IAAI,OAAO,MAAM;AAC5B,QAAI,OAAO,UAAU,KAAM;AAC3B,QAAI,CAAC,UAAU,IAAI,OAAO,MAAM,CAC9B,OAAM,IAAI,MACR,CAAC,cAAc,EAAG,OAAO,MAAO,uDAAuD,EAAG,cAAe,CAAC,CAAC;GAGhH;GACD,UAAU,IAAI,eAAe,QAAQ;EACtC;CACF;AACD,QAAO;AACR;;;;;;;AAQD,MAAM,uBAAuB,CAC3BC,UACS;AACT,KAAI,OAAO,UAAU,CAAC,SAAS,CAAC,CAC9B,OAAM,IAAI,UAAU,CAAC,0BAA0B,CAAC;AAElD,KAAI,OAAO,MAAM,UAAU,CAAC,MAAM,CAAC,CACjC,OAAM,IAAI,UAAU,CAAC,8BAA8B,CAAC;AAEvD;;;;;;;;;;;;;;;;AAiBD,MAAa,KAAK,CAChBL,IACAM,YACoB;CACpB,qBAAqB,GAAG;CACxB,mBAAmB,IAAI,QAAQ;AAC/B,QAAO,OAAO,OAAO;EACnB,OAAO;EACP,SAAS,GAAG;EACZ,SAAS,OAAe,CAAE,GAAG,SAAqB,CAAE,GAAG,KAAO,CAAc,EAAC;CAC9E,EAAC;AACH;AAED,MAAa,OAAO,CAClBN,OACoB;CAEpB,MAAM,QAAQ,gBAAgB,GAAG,CAAC,GAAG,EAAE;AAEvC,KAAI,CAAC,SAAS,MAAM,UAAU,KAC5B,OAAM,IAAI,MACR,CAAC,2CAA2C,EAAG,GAAG,OAAQ;AAG9D,QAAO,GAAG,IAAI,MAAM,MAAM;AAC3B;;;;;;;AAQD,MAAa,oBAAoB,CAC/BA,IACAM,YACY;AACZ,KAAI;EACF,mBAAmB,IAAI,QAAQ;AAC/B,SAAO;CACR,QAAO;AACN,SAAO;CACR;AACF;AAED,MAAa,qBAAqB,CAChCN,IACAM,YACS;AACT,KAAK,YAAwB,KAAM,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AACpF,KAAI,OAAO,YAAY,CAAC,SAAS,CAAC,CAChC,OAAM,IAAI,MAAM,CAAC,oCAAoC,CAAC;AAExD,KAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC7B,OAAM,IAAI,UACR,CAAC,6CAA6C,EAAG,OAAO,SAAU;CAOtE,MAAM,IAAI,SAAS,GAAG;AACtB,KAAI,EAAE,WAAW,EAAG,OAAM,IAAI,MAAM,CAAC,4BAA4B,CAAC;AAClE,KAAI,CAAC,EAAE,SAAS,QAAQ,CACtB,OAAM,IAAI,MACR,CAAC,cAAc,EAAG,QAAS,kCAAkC,EAAG,GAAG,MAClE,oBAAoB,EAAG,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,EAAG;AAG5C;;;;;;;;;;;;;;;;;;AAmBD,MAAa,WAAW,CAAC,GAAG,WAA2C;CACrE,MAAM,IAAI,CAAE;AACZ,KAAI,CAAC,MAAM,QAAQ,OAAO,CAAE,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AACvE,KAAI,OAAO,UAAU,EAAG,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACrE,MAAK,IAAI,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;EAClD,MAAM,IAAI,OAAQ;AAClB,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACvB,OAAM,IAAI,UACR,CAAC,qCAAqC,EAAG,OAAO,EAAG,WAAW,EAAG,MAAM,UAAU,EAAG;EAGxF,EAAG,KAAO,UAAU,OAAO,SAAS,IAAK,OAAO,OAAQ,QAAQ;CACjE;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;AAmBD,MAAa,wBAAwB,CACnC,GAAG,WACa;CAChB,MAAM,IAAI,CAAE;AACZ,KAAI,CAAC,MAAM,QAAQ,OAAO,CAAE,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AACvE,KAAI,OAAO,SAAS,EAAG,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AAEpE,MAAK,MAAM,CAAE,OAAO,EAAG,IAAI,OAAO,SAAS,EAAE;AAC3C,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACvB,OAAM,IAAI,UACR,CAAC,qCAAqC,EAAG,OAAO,EAAG,WAAW,EAAG,MAAM,UAAU,EAAG;EAGxF,EAAG,KAAM,CAAE;CACZ;AAED,MAAK,IAAI,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SAAS;EAClD,MAAM,IAAI,EAAG,OAAQ;AACrB,MAAI,UAAU,OAAO,SAAS,EAC5B,KAAI,OAAO,SAAS,GAClB,EAAE,KAAK,OAAQ,QAAQ,GAAc;OAErC,EAAG,OAAQ,UAAsB;OAE9B;GACL,EAAE,KAAK,OAAQ,QAAQ,GAAc;AACrC,OAAI,QAAQ,GAAG,EAAE,KAAK,OAAQ,QAAQ,GAAc;EACrD;CACF;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvXD,eAAsB,OACpBC,SACAC,gBAC0B;CAC1B,MAAMC,OAAyB,MAAM,QAAQ,eAAe,GACxD,EACA,UAAU,eACX,IACE;CAEL,MAAM,yBAA+B,KAAK,OAAO,EAC/C,UAAU,CAAC,kBAAkB,CAAC,CAC/B,EAAC;CAIF,MAAM,0BAAU,IAAI;AACpB,MAAK,MAAM,KAAK,KAAK,UAAU;EAC7B,MAAM,UAAU,MAAM,QAAQ,EAAE,GAAG,GAAG,EAAE,KAAK,CAAE,EAAE,EAAI;AACrD,OAAK,MAAM,SAAS,SAAS;AAC3B,OAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAC3B,OAAM,IAAI,UACR,CAAC,8DAA8D,EAAG,OAAO,MAAO,EAAE,CAAC;AAIvF,OAAI,QAAQ,IAAI,MAAM,CACpB,OAAM,IAAI,MACR,CAAC,qCAAqC,EAAG,MACxC,+BAA+B,CAAC;GAGrC,QAAQ,IAAI,OAAO,EAAE;EACtB;CACF;CAED,MAAMC,UAA4C;EAEhD,MAAM,CAAC,GAAG,MAAM;AACd,UAAO,gBAAgB,EAAE,SAAS,GAAG,EAAE,SAAS,EAAE;EACnD;EACD,SAAS,KAAK,mBAAmB;CAClC;CAED,IAAI,KAAKC,KAAY,QAAQ;AAG7B,MAAK,MAAM,CAAE,QAAS,IAAI,QAExB,KACE,OAAO,GAAG,QAAS,aAAc,CAAC,SAAS,CAAC,IAC5C,YAAY,CAAC,UAAU,CAAC,CAExB,OAAM,IAAI,MACR,CAAC,gDAAgD,EAAG,QAAS,+EAA+E,CAAC;CAKnJ,MAAMC,QAAM,YAAkD;EAC5D,MAAM,CAAC,YAAY,EAAG,GAAG,OAAQ,CAAC;EAClC,MAAM,QAAQ,GAAG;EACjB,IAAI,UAAU,QAAQ,IAAI,MAAM;AAChC,MAAI,YAAY,QAAW;GACzB,MAAM,CAAC,wBAAwB,EAAG,MAAO,oBAAoB,CAAC,CAAC;GAG/D,UAAU,QAAQ,IAAI,CAAC,UAAU,CAAC,CAAC;EACpC;AACD,MAAI,YAAY,QAAW;GACzB,MAAM,CAAC,uBAAuB,CAAC,CAAC;AAChC;EACD;EAID,MAAM,uBACJ,QAAQ,iBAAiB,CAAC,KAAK,CAAC,GAC5B;GACA,GAAG;GACH,MAAM,CAACC,WAAwC;AAC7C,QAAI,CAAC,OAAQ,QAAO;AACpB,QAAI,CAAC,KAAK,CAAC,IAAI,OAAQ,QAAO;AAC9B,QAAI,CAAC,IAAI,CAAC,IAAI,UAAU,OAAO,SAAS,OAAW,QAAO;AAC1D,WAAO;GACR;EACF,IACC;EAEN,MAAM,UAAU,UACd,QAAQ,MACR,sBACA,GACD;EACD,MACE,CAAC,YAAY,EAAG,GAAG,MAAO,WAAW,EAAG,QAAQ,OAAQ,UAAU,EAAG,QAAQ,cAC3E,CACH;EAID,IAAIC;AACJ,UAAQ,QAAQ,gBAAgB,CAAC,OAAO,CAAC,EAAzC;GACE,KAAK,CAAC,OAAO,CAAC,EAAE;IACd,IAAI,QAAQ,GAAG,GAAG;AAClB;GACD;GACD,KAAK,CAAC,KAAK,CAAC,EAAE;IACZ,IAAI,QAAS;AACb;GACD;GACD,KAAK,CAAC,MAAM,CAAC,EAAE;IACb,IAAI,QAAQ,GAAG,EAAE;AACjB;GACD;GACD,KAAK,CAAC,MAAM,CAAC,EAAE;IACb,IAAI,cAAc,QAAQ;AAC1B;GACD;GACD,QACE,OAAM,IAAI,MACR,CAAC,+BAA+B,EAAG,QAAQ,aAAc,2CAA2C,CAAC;EAG1G;EAED,MAAM,CAAC,iBAAiB,EAAG,KAAK,UAAU,EAAE,EAAG,CAAC;AAEhD,MAAI,GAAG,OACL,KAAKC,MAAa,GAAG;WACZ,KAAK,EAAE,KAChB,KAAI,OAAO,EAAE,SAAS,CAAC,OAAO,CAAC,EAC7B,KAAKC,KAAY,GAAG;OACf;GACL,MAAM,KAAK,UAAU,QAAQ,CAAC;GAC9B,KAAKC,GAAU,IAAI,EAAE,KAAK;EAC3B;AAEH,SAAO;CACR;AAED,QAAO;EACL,OAAO,MAAM;GACX,KAAKF,MAAa,GAAG;EACtB;EACD,UAAU,MAAM,GAAG;EACnB;EACA,IAAI,CAACG,UAAyB;GAC5B,KAAKD,GAAU,IAAI,MAAM;AACzB,UAAO;EACR;CACF;AACF;;;;;;;;;;;;;;;;;;ACtMD,IAAa,yBAAb,cAEU,mBAA4C;CACpD;CACA;CAEA;CACA,qBAAqB;CACrB,UAAU;CACV,aAAa,iBAAiB;;;;;;CAO9B,YAAYE,GAAMC,OAAyC,CAAE,GAAE;EAC7D,OAAO;EAEP,KAAKC,SAAS,KAAK,SAAS;EAC5B,KAAKC,WAAwB,GAAG,KAAK,QAAQ;EAC7C,KAAKC,wBAAqC,KAAKD,IAAI;CACpD;CAID,WAAWE,GAAY;AACrB,MAAI,KAAKC,YAAY,EAAG;EACxB,KAAKA,UAAU;AACf,MAAI,GAAG;GACL,KAAKC,qBAAqB;GAC1B,WAAW,MAAM;AACf,QAAI,CAAC,KAAKA,mBAAoB;IAC9B,KAAKA,qBAAqB;IAE1B,KAAK,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,OAAO,KAAKJ,IAAI,MAAO,EAAC;GAClD,GAAE,EAAE;EACN,OACC,KAAKI,qBAAqB;CAE7B;;;;;;;CAQD,IAAI,iBAAoD;AACtD,kBAA6B,KAAKJ,IAAI;CACvC;;;;CAKD,IAAI,gBAA0C;AAC5C,SAAO,OAAO,KAAK,KAAKA,IAAI,QAAQ;CACrC;;;;;;;CAQD,OAAsB;EACpB,MAAM,aAA0B,KAAKA,IAAI;AACzC,MAAI,EAAE,WAAW,EAAG,QAAO;EAC3B,KAAK,QAAQ,EAAG;AAChB,SAAO,EAAG;CACX;;;;;;CAOD,IAAI,SAAkB;AACpB,gBAA2B,KAAKA,IAAI;CACrC;;;;CAKD,QAAQ;EACN,KAAKK,WAAW,MAAM;EACtB,KAAKL,iBAA8B,KAAKC,WAAW;EACnD,KAAKK,aAAa,cAAc;CACjC;;;;;;CAOD,mBAAmBC,UAA+B;qBAChB,KAAKP,KAAK,SAAS;CACpD;;;;;;;CAQD,QAAQO,UAAkC;AACxC,2BAAsC,KAAKP,KAAK,SAAS;CAC1D;;;;;;;CAQD,IAAI,MAAMO,UAAyB;EACjC,MAAM,aAAa,KAAKP,IAAI;AAC5B,MAAI,aAAa,KAAKA,IAAI,MAAO;EAGjC,KAAKA,SAAsB,KAAKA,KAAK,SAAS;AAC9C,MAAI,KAAKD,QACP,QAAQ,IAAI,CAAC,cAAc,EAAG,WAAY,IAAI,EAAG,UAAW,CAAC;EAE/D,KAAKO,aAAa,cAAc;EAChC,WAAW,MAAM;GACf,KAAK,UAAU,CAAC,MAAM,CAAC,EAAE;IAAY;IAAsB;GAAY,EAAC;EACzE,GAAE,EAAE;AAEL,aAAwB,KAAKN,IAAI,EAAE,KAAKK,WAAW,KAAK;CACzD;CAED,IAAI,QAAgB;AAClB,SAAO,KAAKL,IAAI;CACjB;;;;;CAMD,IAAI,YAAoB;AACtB,SAAO,KAAKM,YAAY;CACzB;;;;;CAMD,IAAI,UAAkB;AACpB,SAAO,KAAKA,YAAY;CACzB;AACF"}