{"version":3,"file":"rx-DYUuIWf2.js","names":["data: readonly V[] | V[]","index: number","data: readonly V[] | V[]","index: number","map: ReadonlyMap<K, V>","data: ArrayKeys<K, V>","data: ObjectKeys<K, V>","key: K","value: V","dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>","key: K","value: V","id: string","g: DirectedGraph","graph: DirectedGraph","vertex: string | Vertex","outIdOrVertex: string | Vertex","graph","vertex: Vertex","from: string","to: string","weight?: number","to","edge: Edge","options: ConnectOptions","edges: Edge[]","idOrVertex: string | Vertex","manual","run","iterator","property: string","selectors: QueryOrElements","value?: any","elements: Array<HTMLElement>","set","v: any","field","event","set","field","value","event","field","debounce","elapsed","elapsed","pow","t: number","x: number","easingsMap: Map<string, ((v: number) => number)> | undefined","easingName: EasingName","Named","interpolate","pos1: number","pos2?: number | Partial<InterpolateOptions>","pos3?: number | Partial<InterpolateOptions>","pos4?: Partial<InterpolateOptions>","amountProcess: undefined | ((v: number) => number)","limits: InterpolateOptions[ 'limits' ]","amount: number","_amt: number","_a: number","_b: number","o: Partial<InterpolateOptions>","a: number","b: number","aValue: number","bValue: number","max","value: number | number[]","min","sum","average","tally","countArrayItems: boolean","rank","r: RankFunction<In>","options: Partial<RankOptions>","best: In | undefined","value: In","rank","annotate","event","init","event","elapsed","process","source","array","set","filter","count","insertAt","set","remove","add","count","elapsed","set","target","init","set","rank","to","transform"],"sources":["../../packages/arrays/src/insert-at.ts","../../packages/arrays/src/remove.ts","../../packages/collections/src/map/map-immutable-fns.ts","../../packages/collections/src/map/map.ts","../../packages/collections/src/graph/directed-graph.ts","../../packages/rx/dist/src/util.js","../../packages/rx/dist/src/from/function.js","../../packages/rx/dist/src/from/iterator.js","../../packages/rx/dist/src/resolve-source.js","../../packages/rx/dist/src/cache.js","../../packages/rx/dist/src/init-stream.js","../../packages/dom/src/set-property.ts","../../packages/rx/dist/src/sinks/dom.js","../../packages/rx/dist/src/to-readable.js","../../packages/rx/dist/src/ops/annotate.js","../../packages/rx/dist/src/ops/chunk.js","../../packages/rx/dist/src/ops/transform.js","../../packages/rx/dist/src/ops/clone-from-fields.js","../../packages/rx/dist/src/ops/combine-latest-to-array.js","../../packages/rx/dist/src/from/object.js","../../packages/rx/dist/src/ops/combine-latest-to-object.js","../../packages/rx/dist/src/ops/compute-with-previous.js","../../packages/rx/dist/src/reactives/debounce.js","../../packages/rx/dist/src/ops/debounce.js","../../packages/rx/dist/src/ops/elapsed.js","../../packages/rx/dist/src/ops/field.js","../../packages/rx/dist/src/ops/filter.js","../../packages/modulation/src/gaussian.ts","../../packages/modulation/src/easing/easings-named.ts","../../packages/modulation/src/easing/index.ts","../../packages/modulation/src/interpolate.ts","../../packages/rx/dist/src/ops/interpolate.js","../../packages/process/src/basic.ts","../../packages/rx/dist/src/ops/math.js","../../packages/rx/dist/src/ops/pipe.js","../../packages/rx/dist/src/ops/single-from-array.js","../../packages/rx/dist/src/ops/split.js","../../packages/rx/dist/src/ops/switcher.js","../../packages/rx/dist/src/ops/sync-to-array.js","../../packages/rx/dist/src/ops/sync-to-object.js","../../packages/rx/dist/src/ops/tap.js","../../packages/rx/dist/src/ops/throttle.js","../../packages/rx/dist/src/ops/timeout-value.js","../../packages/rx/dist/src/ops/timeout-ping.js","../../packages/rx/dist/src/ops/value-to-ping.js","../../packages/rx/dist/src/ops/with-value.js","../../packages/rx/dist/src/graph.js","../../packages/rx/dist/src/types.js","../../packages/rx/dist/src/to-array.js","../../packages/rx/dist/src/to-generator.js","../../packages/rx/dist/src/wrap.js","../../packages/rx/dist/src/from/array.js","../../packages/rx/dist/src/from/array-object.js","../../packages/rx/dist/src/from/boolean.js","../../packages/rx/dist/src/from/count.js","../../packages/rx/dist/src/from/derived.js","../../packages/rx/dist/src/from/event.js","../../packages/rx/dist/src/from/merged.js","../../packages/rx/dist/src/from/number.js","../../packages/rx/dist/src/from/object-proxy.js","../../packages/rx/dist/src/from/observable.js","../../packages/rx/dist/src/from/string.js","../../packages/rx/dist/src/from/index.js","../../packages/rx/dist/src/index.js","../src/rx.ts"],"sourcesContent":["/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down.\n * @param data \n * @param index \n * @param values \n * @returns \n */\nexport const insertAt = <V>(\n  data: readonly V[] | V[],\n  index: number,\n  ...values: V[]\n): V[] => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`Param 'data' is not an arry`);\n  }\n  return [ ...data.slice(0, index), ...values, ...data.slice(index + 1) ];\n};","import { arrayIndexTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = <V>(\n  data: readonly V[] | V[],\n  index: number\n): V[] => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`'data' parameter should be an array`);\n  }\n  resultThrow(arrayIndexTest(data, index, `index`));\n\n  return [ ...data.slice(0, index), ...data.slice(index + 1) ];\n};","import type { ArrayKeys, EitherKey, ObjectKeys } from '../types.js';\n\n/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ArrayKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d[ 0 ] === undefined) throw new Error(`key cannot be undefined`);\n    if (d[ 1 ] === undefined) throw new Error(`value cannot be undefined`);\n    x.set(d[ 0 ], d[ 1 ]);\n  }\n  return x;\n};\n\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ObjectKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\n\n    x.set(d.key, d.value);\n  }\n  return x;\n};\n\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = <K, V>(map: ReadonlyMap<K, V>, key: K): boolean =>\n  map.has(key);\n\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = <K, V>(\n  map: ReadonlyMap<K, V>,\n  ...data: EitherKey<K, V>\n): ReadonlyMap<K, V> => {\n  if (map === undefined) throw new Error(`map parameter is undefined`);\n  if (data === undefined) throw new Error(`data parameter i.s undefined`);\n  if (data.length === 0) return map;\n\n  const firstRecord = data[ 0 ];\n  const isObject =\n    typeof (firstRecord as { readonly key: K; readonly value: V }).key !==\n    `undefined` &&\n    typeof (firstRecord as { readonly key: K; readonly value: V }).value !==\n    `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n  return isObject\n    ? addObjects(map, data as ObjectKeys<K, V>)\n    : addArray(map, data as ArrayKeys<K, V>);\n};\n\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key: K, value: V) => {\n  const x = new Map<K, V>(map.entries());\n  x.set(key, value);\n  return x;\n};\n\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  x.delete(key);\n  return x;\n};\n","import { type EitherKey } from '../types.js';\nimport type { IMapBase } from './imap-base.js';\nimport { add, del, set } from './map-immutable-fns.js';\n\n/**\n * An immutable map. Rather than changing the map, functions like `add` and `delete`\n * return a new map reference which must be captured.\n *\n * Immutable data is useful because as it gets passed around your code, it never\n * changes from underneath you. You have what you have.\n *\n * @example\n * ```js\n * let m = map(); // Create\n * let m2 = m.set(`hello`, `samantha`);\n * // m is still empty, only m2 contains a value.\n * ```\n *\n * @typeParam K - Type of map keys. Typically `string`\n * @typeParam V - Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapImmutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items, returning the changed map.\n   *\n   * Can add items in the form of `[key,value]` or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): IMapImmutable<K, V>;\n  /**\n   * Deletes an item by key, returning the changed map\n   * @param key\n   */\n  delete(key: K): IMapImmutable<K, V>;\n  /**\n   * Returns an empty map\n   */\n  clear(): IMapImmutable<K, V>;\n\n\n  /**\n   * Sets `key` to be `value`, overwriting anything existing.\n   * Returns a new map with added key.\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): IMapImmutable<K, V>;\n\n}\n\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = <K, V>(\n  dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>\n): IMapImmutable<K, V> => {\n  if (dataOrMap === undefined) return immutable([]);\n  if (Array.isArray(dataOrMap)) return immutable<K, V>(add(new Map(), ...dataOrMap));\n\n  const data = dataOrMap as ReadonlyMap<K, V>;\n  return {\n    add: (...itemsToAdd: EitherKey<K, V>) => {\n      const s = add(data, ...itemsToAdd);\n      return immutable(s);\n    },\n    set: (key: K, value: V) => {\n      const s = set(data, key, value);\n      return immutable(s);\n    },\n    get: (key: K) => data.get(key),\n    delete: (key: K) => immutable(del(data, key)),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    clear: () => immutable(),\n    has: (key: K) => data.has(key),\n    entries: () => data.entries(),\n    values: () => data.values(),\n    isEmpty: () => data.size === 0,\n  };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { QueueMutable } from \"../queue/queue-mutable.js\"\nimport { PriorityMutable } from \"../queue/priority-mutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../map/map.js\"\nimport { NumberMap } from \"../map/number-map.js\"\nimport * as Sync from \"@ixfx/iterables/sync\"\nimport { Table } from \"../table.js\"\nimport { resultThrow, stringTest, type Result } from \"@ixfx/guards\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: readonly Edge[]\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | string[]\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable.\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n/**\n * Returns _true_ if graph contains `key`.\n * \n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key \n * @returns \n */\nexport function hasKey(graph: DirectedGraph, key: string): boolean {\n  resultThrow(graphTest(graph));\n  return graph.vertices.has(key);\n}\n\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n * \n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph \n * @param key \n * @returns \n */\nexport function get(graph: DirectedGraph, key: string): Vertex | undefined {\n  resultThrow(graphTest(graph));\n\n  resultThrow(stringTest(key, `non-empty`, `key`));\n  return graph.vertices.get(key);\n\n}\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  resultThrow(graphTest(graph));\n\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): string[] => {\n\n  const r: string[] = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  resultThrow(graphTest(graph));\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  resultThrow(graphTest(graph));\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\nfunction graphTest(g: DirectedGraph, parameterName = `graph`): Result<DirectedGraph, string> {\n  if (g === undefined) return { success: false, error: `Param '${ parameterName }' is undefined. Expected Graph` };\n  if (g === null) return { success: false, error: `Param '${ parameterName }' is null. Expected Graph` };\n  if (typeof g === `object`) {\n    if (!(`vertices` in g)) return {\n      success: false, error: `Param '${ parameterName }.vertices' does not exist. Is it a Graph type?`\n    };\n  } else {\n    return { success: false, error: `Param '${ parameterName } is type '${ typeof g }'. Expected an object Graph` };\n  }\n  return { success: true, value: g };\n}\n\n// function throwGraphTest(g: DirectedGraph, parameterName = `graph`) {\n//   const r = testGraph(g, parameterName);\n//   if (r[ 0 ]) return;\n//   throw new Error(r[ 1 ] as string)\n// }\n\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  resultThrow(graphTest(graph));\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  resultThrow(graphTest(graph));\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: (string | Vertex)[]): boolean => {\n  resultThrow(graphTest(graph));\n\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  resultThrow(graphTest(graph));\n\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  resultThrow(graphTest(graph));\n\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  resultThrow(graphTest(graph));\n\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  resultThrow(graphTest(graph));\n\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  resultThrow(graphTest(graph));\n\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  resultThrow(graphTest(graph));\n\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  if (typeof graph !== `object`) throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${ typeof graph }`);\n  if (typeof options !== `object`) throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${ typeof options }`);\n\n  const result = connectWithEdges(graph, options);\n  return result.graph;\n}\n\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well. \n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connectWithEdges(graph: DirectedGraph, options: ConnectOptions): { graph: DirectedGraph, edges: Edge[] } {\n  resultThrow(graphTest(graph));\n\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  const edges: Edge[] = []\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n\n  if (!bidi) return { graph, edges };\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n  return { graph, edges };\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): string[] => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  resultThrow(graphTest(graph));\n\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  resultThrow(graphTest(graph));\n\n  if (idOrVertex === undefined) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  resultThrow(graphTest(graph));\n\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  resultThrow(graphTest(graph));\n\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  resultThrow(graphTest(graph));\n\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Edge[] => {\n    const path: Edge[] = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  resultThrow(graphTest(graph));\n\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n * \n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: ConnectOptions[]): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  resultThrow(graphTest(graph));\n\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  resultThrow(graphTest(graph));\n\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Vertex[] = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Vertex[][] {\n  resultThrow(graphTest(graph));\n\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Vertex[][] = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Vertex[] = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  resultThrow(graphTest(graph));\n\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","import { isIterable } from \"@ixfx/iterables\";\nexport function messageIsSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal !== undefined)\n        return true;\n    return false;\n}\nexport function messageIsDoneSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal === `done`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v\n * @returns\n */\nexport function messageHasValue(v) {\n    if (v.value !== undefined)\n        return true;\n    return false;\n}\nexport const isPingable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`ping` in rx) {\n        return true;\n    }\n    return false;\n};\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx\n * @returns\n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx\n * @returns\n */\nexport const isWritable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`set` in rx)\n        return true;\n    return false;\n};\nexport const isWrapped = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (!(`source` in v))\n        return false;\n    if (!(`annotate` in v))\n        return false;\n    return true;\n};\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\nexport const opify = (fn, ...args) => {\n    return (source) => {\n        return fn(source, ...args);\n    };\n};\nexport const isTriggerValue = (t) => (`value` in t);\nexport const isTriggerFunction = (t) => (`fn` in t);\nexport const isTriggerGenerator = (t) => isIterable(t);\nexport const isTrigger = (t) => {\n    if (typeof t !== `object`)\n        return false;\n    if (isTriggerValue(t))\n        return true;\n    if (isTriggerFunction(t))\n        return true;\n    if (isTriggerGenerator(t))\n        return true;\n    return false;\n};\n/**\n * Resolves a trigger value.\n *\n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t\n * @returns\n */\nexport function resolveTriggerValue(t) {\n    if (isTriggerValue(t))\n        return [t.value, false];\n    if (isTriggerFunction(t)) {\n        const v = t.fn();\n        if (v === undefined)\n            return [undefined, true];\n        return [v, false];\n    }\n    if (isTriggerGenerator(t)) {\n        const v = t.gen.next();\n        if (v.done)\n            return [undefined, true];\n        return [v.value, false];\n    }\n    throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}\n","import { continuously, intervalToMs } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport { sleep } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n *\n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n *\n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it.\n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n *\n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n *\n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber\n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback\n * @param options\n * @returns\n */\nexport function func(callback, options = {}) {\n    const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n    const closeOnError = options.closeOnError ?? true;\n    const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n    let manual = options.manual ?? false;\n    // If niether interval or manual is set, assume manual\n    if (options.interval === undefined && options.manual === undefined)\n        manual = true;\n    if (manual && options.interval)\n        throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n    const predelay = intervalToMs(options.predelay, 0);\n    const lazy = options.lazy ?? `very`;\n    const signal = options.signal;\n    const internalAbort = new AbortController();\n    const internalAbortCallback = (reason) => { internalAbort.abort(reason); };\n    let sentResults = 0;\n    let enabled = false;\n    const done = (reason) => {\n        events.dispose(reason);\n        enabled = false;\n        if (run)\n            run.cancel();\n    };\n    const ping = async () => {\n        if (!enabled)\n            return false;\n        if (predelay)\n            await sleep(predelay);\n        if (sentResults >= maximumRepeats) {\n            done(`Maximum repeats reached ${maximumRepeats.toString()}`);\n            return false;\n        }\n        //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n        try {\n            if (signal?.aborted) {\n                done(`Signal (${signal.aborted})`);\n                return false;\n            }\n            const value = await callback(internalAbortCallback);\n            sentResults++;\n            events.set(value);\n            return true;\n        }\n        catch (error) {\n            if (closeOnError) {\n                done(`Function error: ${getErrorMessage(error)}`);\n                return false;\n            }\n            else {\n                events.signal(`warn`, getErrorMessage(error));\n                return true;\n            }\n        }\n    };\n    const run = manual ? undefined : continuously(async () => {\n        const pingResult = await ping();\n        if (!pingResult)\n            return false;\n        // if (!loop) {\n        //   done(`fromFunction done`);\n        //   return false; // Stop loop\n        // }\n        if (internalAbort.signal.aborted) {\n            done(`callback function aborted (${internalAbort.signal.reason})`);\n            return false;\n        }\n    }, intervalMs);\n    const events = initLazyStream({\n        lazy,\n        onStart() {\n            enabled = true;\n            if (run)\n                run.start();\n        },\n        onStop() {\n            enabled = false;\n            if (run)\n                run.cancel();\n        },\n    });\n    if (lazy === `never` && run)\n        run.start();\n    return { ...events, ping };\n}\n","import { nextWithTimeout } from \"@ixfx/iterables/async\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { isAsyncIterable } from \"@ixfx/iterables\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen\n * @returns\n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n *\n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source\n */\nexport function iterator(source, options = {}) {\n    const lazy = options.lazy ?? `very`;\n    const log = options.traceLifecycle ? (message) => { console.log(`Rx.From.iterator ${message}`); } : (_) => { };\n    const readIntervalMs = intervalToMs(options.readInterval, 5);\n    const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n    const whenStopped = options.whenStopped ?? `continue`;\n    let iterator;\n    //let reading = false;\n    let ourAc;\n    let sm = StateMachine.init({\n        idle: [`wait_for_next`],\n        wait_for_next: [`processing_result`, `stopping`, `disposed`],\n        processing_result: [`queued`, `disposed`, `stopping`],\n        queued: [`wait_for_next`, `disposed`, `stopping`],\n        stopping: `idle`,\n        disposed: null\n    }, `idle`);\n    const onExternalSignal = () => {\n        log(`onExternalSignal`);\n        ourAc?.abort(options.signal?.reason);\n    };\n    if (options.signal) {\n        options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n    }\n    ;\n    const read = async () => {\n        log(`read. State: ${sm.value}`);\n        ourAc = new AbortController();\n        try {\n            sm = StateMachine.to(sm, `wait_for_next`);\n            const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n            sm = StateMachine.to(sm, `processing_result`);\n            ourAc.abort(`nextWithTimeout completed`);\n            if (v.done) {\n                log(`read v.done true`);\n                events.dispose(`Generator complete`);\n                //reading = false;\n                sm = StateMachine.to(sm, `disposed`);\n            }\n            //if (!reading) return;\n            if (sm.value === `stopping`) {\n                log(`read. sm.value = stopping`);\n                sm = StateMachine.to(sm, `idle`);\n                return;\n            }\n            if (sm.value === `disposed`) {\n                log(`read. sm.value = disposed`);\n                return;\n            }\n            events.set(v.value);\n        }\n        catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            events.dispose(`Generator error: ${error.toString()}`);\n            return;\n        }\n        //if (events.isDisposed()) return;\n        //if (!reading) return;\n        if (sm.value === `processing_result`) {\n            sm = StateMachine.to(sm, `queued`);\n            log(`scheduling read. State: ${sm.value}`);\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            setTimeout(read, readIntervalMs);\n        }\n        else {\n            sm = StateMachine.to(sm, `idle`);\n        }\n    };\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            log(`onStart state: ${sm.value} whenStopped: ${whenStopped}`);\n            if (sm.value !== `idle`)\n                return;\n            if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n            //reading = true;\n            void read();\n        },\n        onStop() {\n            log(`onStop state: ${sm.value} whenStopped: ${whenStopped}`);\n            //reading = false;\n            sm = StateMachine.to(sm, `stopping`);\n            if (whenStopped === `reset`) {\n                log(`onStop reiniting iterator`);\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n        },\n        onDispose(reason) {\n            log(`onDispose (${reason})`);\n            ourAc?.abort(`Rx.From.iterator disposed (${reason})`);\n            if (options.signal)\n                options.signal.removeEventListener(`abort`, onExternalSignal);\n        },\n    });\n    // const readingStart = () => {\n    // }\n    //if (!lazy) readingStart();\n    // return {\n    //   on: events.on,\n    //   value: events.value,\n    //   dispose: events.dispose,\n    //   isDisposed: events.isDisposed\n    // }\n    return events;\n}\n","import { isAsyncIterable, isIterable } from \"@ixfx/iterables\";\nimport { func } from \"./from/function.js\";\nimport { iterator } from \"./from/iterator.js\";\nimport { isReactive, isWrapped } from \"./util.js\";\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n *\n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source\n * @returns\n */\nexport const resolveSource = (source, options = {}) => {\n    if (isReactive(source))\n        return source;\n    const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 };\n    const functionOptions = options.function ?? { lazy: `very` };\n    if (Array.isArray(source)) {\n        return iterator(source.values(), generatorOptions);\n    }\n    else if (typeof source === `function`) {\n        return func(source, functionOptions);\n    }\n    else if (typeof source === `object`) {\n        //console.log(`resolveSource is object`);\n        if (isWrapped(source)) {\n            //console.log(`resolveSource is object - wrapped`);\n            return source.source;\n        }\n        if (isIterable(source) || isAsyncIterable(source)) {\n            //console.log(`resolveSource is object - iterable`);\n            return iterator(source, generatorOptions);\n        }\n    }\n    throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof source}`);\n};\n","/**\n * Wrapes an input stream to cache values, optionally providing an initial value\n * @param r\n * @param initialValue\n * @returns\n */\nexport function cache(r, initialValue) {\n    let lastValue = initialValue;\n    r.onValue(value => {\n        lastValue = value;\n    });\n    return {\n        ...r,\n        last() {\n            return lastValue;\n        },\n        resetCachedValue() {\n            lastValue = undefined;\n        }\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsSignal } from \"./util.js\";\nimport { cache } from \"./cache.js\";\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n *\n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource\n * @param options\n * @returns\n */\nexport function initUpstream(upstreamSource, options) {\n    const lazy = options.lazy ?? `initial`;\n    const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n    const onValue = options.onValue ?? ((_v) => { });\n    const source = resolveSource(upstreamSource);\n    let unsub;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    //console.log(`initUpstream${ debugLabel } creating`);\n    const onStop = () => {\n        //console.log(`Rx.initStream${ debugLabel } stop`);\n        if (unsub === undefined)\n            return;\n        unsub();\n        unsub = undefined;\n        if (options.onStop)\n            options.onStop();\n    };\n    const onStart = () => {\n        //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n        if (unsub !== undefined)\n            return;\n        if (options.onStart)\n            options.onStart();\n        unsub = source.on(value => {\n            //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n            if (messageIsSignal(value)) {\n                if (value.signal === `done`) {\n                    onStop();\n                    events.signal(value.signal, value.context);\n                    if (disposeIfSourceDone)\n                        events.dispose(`Upstream source ${debugLabel} has completed (${value.context ?? ``})`);\n                }\n                else {\n                    //events.through_(value);\n                    events.signal(value.signal, value.context);\n                }\n            }\n            else if (messageHasValue(value)) {\n                //lastValue = value.value;\n                onValue(value.value);\n            }\n        });\n    };\n    //const initOpts = \n    // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n    //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n    //   initLazyStream<Out>(initOpts);\n    //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart,\n        onStop\n    });\n    return events;\n}\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options\n * @returns\n */\nexport function initLazyStreamWithInitial(options) {\n    const r = initLazyStream(options);\n    const c = cache(r, options.initialValue);\n    return c;\n}\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n *\n * Uses {@link lazyStream} internally.\n * @param options\n * @returns\n */\nexport function initLazyStream(options) {\n    const lazy = options.lazy ?? `initial`;\n    const onStop = options.onStop ?? (() => { });\n    const onStart = options.onStart ?? (() => { });\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const events = initStream({\n        ...options,\n        onFirstSubscribe() {\n            if (lazy !== `never`) {\n                //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n                onStart();\n            }\n        },\n        onNoSubscribers() {\n            if (lazy === `very`) {\n                //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n                onStop();\n            }\n        },\n    });\n    if (lazy === `never`)\n        onStart();\n    return events;\n}\n/**\n * Initialises a new stream.\n *\n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n *\n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options\n * @returns\n */\nexport function initStream(options = {}) {\n    let dispatcher;\n    let disposed = false;\n    let firstSubscribe = false;\n    let emptySubscriptions = true;\n    const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n    const onNoSubscribers = options.onNoSubscribers ?? undefined;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const isEmpty = () => {\n        if (dispatcher === undefined)\n            return;\n        if (!dispatcher.isEmpty)\n            return;\n        if (!emptySubscriptions) {\n            emptySubscriptions = true;\n            firstSubscribe = false;\n            if (onNoSubscribers)\n                onNoSubscribers();\n        }\n    };\n    const subscribe = (handler) => {\n        if (disposed)\n            throw new Error(`Disposed, cannot subscribe ${debugLabel}`);\n        if (dispatcher === undefined)\n            dispatcher = new DispatchList();\n        //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n        const id = dispatcher.add(handler);\n        emptySubscriptions = false;\n        if (!firstSubscribe) {\n            firstSubscribe = true;\n            //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n            if (onFirstSubscribe)\n                onFirstSubscribe();\n        }\n        return () => {\n            dispatcher?.remove(id);\n            isEmpty();\n        };\n    };\n    return {\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${reason}` });\n            disposed = true;\n            if (options.onDispose)\n                options.onDispose(reason);\n        },\n        isDisposed: () => {\n            return disposed;\n        },\n        removeAllSubscribers: () => {\n            dispatcher?.clear();\n            isEmpty();\n        },\n        set: (v) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot set`);\n            dispatcher?.notify({ value: v });\n        },\n        // through: (pass: Passed<V>) => {\n        //   if (disposed) throw new Error(`Disposed, cannot through`);\n        //   dispatcher?.notify(pass)\n        // },\n        signal: (signal, context) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot signal`);\n            dispatcher?.notify({ signal, value: undefined, context });\n        },\n        on: (handler) => subscribe(handler),\n        onValue: (handler) => {\n            const unsub = subscribe(message => {\n                //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n                if (messageHasValue(message)) {\n                    handler(message.value);\n                }\n            });\n            return unsub;\n        }\n    };\n}\n","import { resolveEls, type QueryOrElements } from \"./resolve-el.js\";\n\nexport function setText(selectors: QueryOrElements): (value: any) => string;\nexport function setText(selectors: QueryOrElements, value?: any): string;\nexport function setText(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`textContent`, selectors, value)\n};\n\nexport function setHtml(selectors: QueryOrElements): (value: any) => string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`innerHTML`, selectors, value)\n};\n\nexport function setProperty(property: string, selectors: QueryOrElements): (value: any) => string;\nexport function setProperty(property: string, selectors: QueryOrElements, value: any): string;\n\nexport function setProperty(property: string, selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  let elements: Array<HTMLElement> = [];\n  const set = (v: any) => {\n    const typ = typeof v;\n    const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v as string :\n      JSON.stringify(v);\n\n    if (elements.length === 0) {\n      elements = resolveEls(selectors);\n    }\n    for (const element of elements) {\n      (element as any)[ property ] = vv;\n    }\n    return vv;\n  }\n  return value === undefined ? set : set(value);\n};","import { setProperty } from \"@ixfx/dom\";\nimport { resolveSource } from \"../resolve-source.js\";\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource\n * @param optionsOrElementOrQuery\n */\nexport const setHtmlText = (rxOrSource, optionsOrElementOrQuery) => {\n    let el;\n    let options;\n    if (typeof optionsOrElementOrQuery === `string`) {\n        options = { query: optionsOrElementOrQuery };\n    }\n    if (typeof optionsOrElementOrQuery === `object`) {\n        if (`nodeName` in optionsOrElementOrQuery) {\n            options = { el: optionsOrElementOrQuery };\n        }\n        else {\n            options = optionsOrElementOrQuery;\n        }\n    }\n    if (options === undefined)\n        throw new TypeError(`Missing element as second parameter or option`);\n    if (`el` in options) {\n        el = options.el;\n    }\n    else if (`query` in options) {\n        el = document.querySelector(options.query);\n    }\n    else {\n        throw new TypeError(`Options does not include 'el' or 'query' fields`);\n    }\n    if (el === null || el === undefined)\n        throw new Error(`Element could not be resolved.`);\n    const stream = resolveSource(rxOrSource);\n    const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n    const off = stream.onValue(value => {\n        setter(value);\n    });\n    return off;\n};\n","/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = (stream) => ({\n    on: stream.on,\n    dispose: stream.dispose,\n    isDisposed: stream.isDisposed,\n    onValue: stream.onValue\n});\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n *\n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n *\n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate(input, annotator, options = {}) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            const annotation = annotator(value);\n            upstream.set({ value, annotation });\n        },\n    });\n    return toReadable(upstream);\n}\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n *\n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns\n */\nexport function annotateWithOp(input, annotatorOp) {\n    const inputStream = resolveSource(input);\n    // Create annotations from input\n    const stream = annotatorOp(inputStream);\n    const synced = syncToObject({\n        value: inputStream,\n        annotation: stream\n    });\n    return synced;\n}\n","import { QueueMutable } from \"@ixfx/collections\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Queue from `source`, emitting when thresholds are reached.\n * The resulting Reactive produces arrays.\n *\n * Can use a combination of elapsed time or number of data items.\n *\n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport function chunk(source, options = {}) {\n    const queue = new QueueMutable();\n    const quantity = options.quantity ?? 0;\n    const returnRemainder = options.returnRemainder ?? true;\n    const upstreamOpts = {\n        ...options,\n        onStop() {\n            if (returnRemainder && !queue.isEmpty) {\n                const data = queue.toArray();\n                queue.clear();\n                upstream.set(data);\n            }\n        },\n        onValue(value) {\n            queue.enqueue(value);\n            if (quantity > 0 && queue.length >= quantity) {\n                // Reached quantity limit\n                send();\n            }\n            // Start timer\n            if (timer !== undefined && timer.runState === `idle`) {\n                timer.start();\n            }\n        },\n    };\n    const upstream = initUpstream(source, upstreamOpts);\n    //let testElapsed = performance.now();\n    const send = () => {\n        //console.log(`Elapsed: ${ performance.now() - testElapsed }`);\n        //testElapsed = performance.now();\n        if (queue.isEmpty)\n            return;\n        // Reset timer\n        if (timer !== undefined)\n            timer.start();\n        // Fire queued data\n        const data = queue.toArray();\n        queue.clear();\n        setTimeout(() => { upstream.set(data); });\n    };\n    const timer = options.elapsed ? timeout(send, options.elapsed) : undefined;\n    // const trigger = () => {\n    //   const now = performance.now();\n    //   let byElapsed = false;\n    //   let byLimit = false;\n    //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n    //     lastFire = now;\n    //     byElapsed = true;\n    //   }\n    //   if (limit > 0 && queue.length >= limit) {\n    //     byLimit = true;\n    //   }\n    //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n    //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n    //   send();\n    // }\n    return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer\n * @returns\n */\nexport function transform(input, transformer, options = {}) {\n    const traceInput = options.traceInput ?? false;\n    const traceOutput = options.traceOutput ?? false;\n    const upstream = initUpstream(input, {\n        lazy: `initial`,\n        ...options,\n        onValue(value) {\n            const t = transformer(value);\n            if (traceInput && traceOutput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)} output: ${JSON.stringify(t)}`);\n            }\n            else if (traceInput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)}`);\n            }\n            else if (traceOutput) {\n                console.log(`Rx.Ops.transform output: ${JSON.stringify(t)}`);\n            }\n            upstream.set(t);\n        },\n    });\n    return toReadable(upstream);\n}\n","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\nimport { transform } from \"./transform.js\";\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source\n * @returns\n */\nexport const cloneFromFields = (source) => {\n    return transform(source, (v) => {\n        const entries = [];\n        for (const field in v) {\n            const value = (v)[field];\n            if (testPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return Object.fromEntries(entries);\n    });\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../util.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n *\n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n *\n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport function combineLatestToArray(reactiveSources, options = {}) {\n    const event = initStream();\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const data = [];\n    const sources = reactiveSources.map(source => resolveSource(source));\n    const noop = () => { };\n    const sourceOff = sources.map(_ => noop);\n    const doneSources = sources.map(_ => false);\n    const unsub = () => {\n        for (const v of sourceOff) {\n            v();\n        }\n    };\n    for (const [index, v] of sources.entries()) {\n        data[index] = undefined;\n        sourceOff[index] = v.on(message => {\n            if (messageIsDoneSignal(message)) {\n                doneSources[index] = true;\n                sourceOff[index]();\n                sourceOff[index] = noop;\n                if (onSourceDone === `break`) {\n                    unsub();\n                    event.dispose(`Source has completed and 'break' is set`);\n                    return;\n                }\n                if (!doneSources.includes(false)) {\n                    // All sources are done\n                    unsub();\n                    event.dispose(`All sources completed`);\n                }\n            }\n            else if (messageHasValue(message)) {\n                data[index] = message.value;\n                event.set([...data]);\n            }\n        });\n    }\n    return {\n        dispose: event.dispose,\n        isDisposed: event.isDisposed,\n        on: event.on,\n        onValue: event.onValue\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport * as Pathed from \"@ixfx/core/records\";\nimport { initStream } from \"../init-stream.js\";\nimport { isEqualContextString } from \"@ixfx/core\";\nimport { wildcard } from \"@ixfx/core/text\";\nimport { resultIsError, resultThrow, resultThrowSingle, resultToError } from \"@ixfx/guards\";\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n *\n * Changing the wrapped object directly does not update the Reactive.\n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n *\n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n *\n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n *\n * Use `last()` to get the most recently set value.\n *\n * `onDiff` subscribes to a rough diff of the object.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n *\n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n *\n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns\n */\nexport function object(initialValue, options = {}) {\n    const eq = options.eq ?? isEqualContextString;\n    const setEvent = initStream();\n    const diffEvent = initStream();\n    //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n    const fieldChangeEvents = [];\n    let value = initialValue;\n    let disposed = false;\n    const set = (v) => {\n        const diff = [...Pathed.compareData(value ?? {}, v, { ...options, includeMissingFromA: true })];\n        if (diff.length === 0)\n            return;\n        value = v;\n        setEvent.set(v);\n        diffEvent.set(diff);\n    };\n    const fireFieldUpdate = (field, value) => {\n        for (const [matcher, pattern, list] of fieldChangeEvents) {\n            if (matcher(field)) {\n                list.notify({ fieldName: field, pattern, value });\n            }\n        }\n        //const l = fieldChangeEvents.get(field.toLowerCase());\n        //if (l === undefined) return;\n        //l.notify(value);\n    };\n    const updateCompareOptions = {\n        asPartial: true,\n        includeParents: true\n    };\n    const update = (toMerge) => {\n        //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n        if (value === undefined) {\n            value = toMerge;\n            setEvent.set(value);\n            for (const [k, v] of Object.entries(toMerge)) {\n                fireFieldUpdate(k, v);\n            }\n            return value;\n        }\n        else {\n            const diff = [...Pathed.compareData(value, toMerge, updateCompareOptions)];\n            //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n            if (diff.length === 0)\n                return value; // No changes\n            value = {\n                ...value,\n                ...toMerge\n            };\n            setEvent.set(value);\n            diffEvent.set(diff);\n            //console.log(`diff`, diff);\n            for (const d of diff) {\n                fireFieldUpdate(d.path, d.value);\n            }\n            return value;\n        }\n    };\n    const updateField = (path, valueForField) => {\n        if (value === undefined)\n            throw new Error(`Cannot update value when it has not already been set`);\n        //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n        const existing = Pathed.getField(value, path);\n        //resultThrowSingle(existing);\n        if (resultIsError(existing)) {\n            throw resultToError(existing);\n        }\n        //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n        if (eq(existing.value, valueForField, path)) {\n            //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n            return;\n        }\n        let diff = [...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true })];\n        diff = diff.map(d => {\n            if (d.path.length > 0)\n                return { ...d, path: path + `.` + d.path };\n            return { ...d, path };\n        });\n        //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n        const o = Pathed.updateByPath(value, path, valueForField, true);\n        value = o;\n        //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n        setEvent.set(o);\n        diffEvent.set(diff);\n        fireFieldUpdate(path, valueForField);\n        //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n    };\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    return {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        /**\n         * Update a field.\n         * Exception is thrown if field does not exist\n         */\n        updateField,\n        last: () => value,\n        on: setEvent.on,\n        onValue: setEvent.onValue,\n        onDiff: diffEvent.onValue,\n        onField(fieldPattern, handler) {\n            const matcher = wildcard(fieldPattern);\n            const listeners = new DispatchList();\n            fieldChangeEvents.push([matcher, fieldPattern, listeners]);\n            const id = listeners.add(handler);\n            return () => listeners.remove(id);\n            // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n            // if (listeners === undefined) {\n            //   listeners = new DispatchList();\n            //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n            // }\n            // const id = listeners.add((value) => {\n            //   setTimeout(() => { handler(value, fieldName) }, 1);\n            // });\n            // return () => listeners.remove(id);\n        },\n        /**\n         * Set the whole object\n         */\n        set,\n        /**\n         * Update the object with a partial set of fields and values\n         */\n        update\n    };\n}\n","import * as MapFns from \"@ixfx/core/maps\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../util.js\";\nimport { object } from \"../from/object.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n *\n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n *\n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport function combineLatestToObject(reactiveSources, options = {}) {\n    const disposeSources = options.disposeSources ?? true;\n    const event = object(undefined);\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const emitInitial = options.emitInitial ?? true;\n    let emitInitialDone = false;\n    const states = new Map();\n    for (const [key, source] of Object.entries(reactiveSources)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const initialData = (`last` in source) ? source.last() : undefined;\n        //console.log(`initialData: ${ initialData } src: ${ (source as any).last() }`);\n        const s = {\n            source: resolveSource(source),\n            done: false,\n            data: initialData,\n            off: () => { }\n        };\n        states.set(key, s);\n    }\n    const sources = Object.fromEntries(Object.entries(states).map(entry => [entry[0], entry[1].source]));\n    const someUnfinished = () => MapFns.some(states, v => !v.done);\n    const unsub = () => {\n        //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n        for (const state of states.values())\n            state.off();\n    };\n    const getData = () => {\n        const r = {};\n        for (const [key, state] of states) {\n            const d = state.data;\n            if (d !== undefined) {\n                r[key] = state.data;\n            }\n        }\n        //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n        return r;\n    };\n    const trigger = () => {\n        emitInitialDone = true;\n        const d = getData();\n        //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n        event.set(d);\n    };\n    const wireUpState = (state) => {\n        state.off = state.source.on(message => {\n            if (messageIsDoneSignal(message)) {\n                state.done = true;\n                state.off();\n                state.off = () => { };\n                if (onSourceDone === `break`) {\n                    unsub();\n                    event.dispose(`Source has completed and 'break' is behaviour`);\n                    return;\n                }\n                if (!someUnfinished()) {\n                    // All sources are done\n                    unsub();\n                    event.dispose(`All sources completed`);\n                }\n            }\n            else if (messageHasValue(message)) {\n                state.data = message.value;\n                trigger();\n            }\n        });\n    };\n    for (const state of states.values()) {\n        wireUpState(state);\n    }\n    if (!emitInitialDone && emitInitial) {\n        //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n        trigger();\n    }\n    return {\n        ...event,\n        hasSource(field) {\n            return states.has(field);\n        },\n        replaceSource(field, source) {\n            const state = states.get(field);\n            if (state === undefined)\n                throw new Error(`Field does not exist: '${field}'`);\n            state.off();\n            const s = resolveSource(source);\n            state.source = s;\n            wireUpState(state);\n        },\n        setWith(data) {\n            const written = {};\n            for (const [key, value] of Object.entries(data)) {\n                const state = states.get(key);\n                if (state !== undefined) {\n                    if (isWritable(state.source)) {\n                        state.source.set(value);\n                        written[key] = value;\n                    }\n                    state.data = value;\n                }\n            }\n            return written;\n        },\n        sources,\n        last() {\n            return getData();\n        },\n        dispose(reason) {\n            unsub();\n            event.dispose(reason);\n            if (disposeSources) {\n                for (const v of states.values()) {\n                    v.source.dispose(`Part of disposed mergeToObject`);\n                }\n            }\n        }\n    };\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport { hasLast } from \"../util.js\";\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n *\n * `fn` is provided the previous value as well as the most recent value.\n *\n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input\n * @param fn\n * @returns\n */\nexport function computeWithPrevious(input, fn) {\n    let previousValue;\n    let currentValue;\n    if (hasLast(input)) {\n        currentValue = previousValue = input.last();\n    }\n    const trigger = () => {\n        if (previousValue === undefined && currentValue !== undefined) {\n            previousValue = currentValue;\n            upstream.set(previousValue);\n        }\n        else if (previousValue !== undefined && currentValue !== undefined) {\n            const vv = fn(previousValue, currentValue);\n            //console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n            previousValue = vv;\n            upstream.set(vv);\n        }\n    };\n    const upstream = initUpstream(input, {\n        lazy: \"very\",\n        debugLabel: `computeWithPrevious`,\n        onValue(value) {\n            //console.log(`onValue ${ value }`);\n            currentValue = value;\n            trigger();\n        },\n    });\n    if (currentValue)\n        trigger();\n    return {\n        ...toReadable(upstream),\n        ping: () => {\n            if (currentValue !== undefined)\n                trigger();\n        }\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n *\n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n *\n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n *\n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source\n * @param options\n * @returns\n */\nexport function debounce(source, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 50);\n    let lastValue;\n    const timer = timeout(() => {\n        const v = lastValue;\n        if (v) {\n            upstream.set(v);\n            lastValue = undefined;\n        }\n    }, elapsed);\n    const upstream = initUpstream(source, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            timer.start();\n        }\n    });\n    return toReadable(upstream);\n}\n","import { debounce as debounceReactive } from \"../reactives/debounce.js\";\nexport function debounce(options) {\n    return (source) => {\n        return debounceReactive(source, options);\n    };\n}\n","import { transform } from \"./transform.js\";\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input\n * @returns\n */\nexport const elapsed = (input) => {\n    let last = 0;\n    return transform(input, (_ignored) => {\n        const elapsed = last === 0 ? 0 : Date.now() - last;\n        last = Date.now();\n        return elapsed;\n    });\n};\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n *\n * If a source value doesn't have that field, it is skipped.\n *\n * @returns\n */\nexport function field(fieldSource, fieldName, options = {}) {\n    const fallbackFieldValue = options.fallbackFieldValue;\n    const fallbackObject = options.fallbackObject;\n    const upstream = initUpstream(fieldSource, {\n        disposeIfSourceDone: true,\n        ...options,\n        onValue(value) {\n            let v;\n            // 1. Try to read from value\n            if (fieldName in value) {\n                v = value[fieldName];\n            }\n            else if (fallbackObject && fieldName in fallbackObject) {\n                // 2. Read from fallback object\n                v = fallbackObject[fieldName];\n            }\n            // 3. Use fallback value\n            if (v === undefined) {\n                v = fallbackFieldValue;\n            }\n            if (v !== undefined) {\n                upstream.set(v);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter(input, predicate, options) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            if (predicate(value)) {\n                upstream.set(value);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop(input, predicate, options) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            if (!predicate(value)) {\n                upstream.set(value);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n  //const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = gaussianA / standardDeviation;\n    // p:-8 pinched\n    let p = -2.5; // -1/1.25;\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n    return v;\n  };\n};","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\nexport const bounceOut = (x: number) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nexport const quintIn = (x: number) => x * x * x * x * x;\nexport const quintOut = (x: number) => 1 - pow(1 - x, 5);\nexport const arch = (x: number) => x * (1 - x) * 4;\n\nexport const smoothstep = (x: number) => x * x * (3 - 2 * x);\nexport const smootherstep = (x: number) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x: number) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x: number) => sin((x * pi) / 2);\nexport const quadIn = (x: number) => x * x;\nexport const quadOut = (x: number) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x: number) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x: number) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x: number) => x * x * x;\nexport const cubicOut = (x: number) => 1 - pow(1 - x, 3);\nexport const quartIn = (x: number) => x * x * x * x;\nexport const quartOut = (x: number) => 1 - pow(1 - x, 4);\nexport const expoIn = (x: number) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x: number) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x: number) =>\n  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x: number) =>\n  x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? pow(2, 20 * x - 10) / 2\n        : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x: number) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x: number) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x: number) =>\n  x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n\nexport const backInOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c2 = c1 * 1.525;\n\n  return x < 0.5\n    ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n    : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\n\nexport const bounceIn = (x: number) => 1 - bounceOut(1 - x);\n\nexport const bell = gaussian();\n\nexport const elasticInOut = (x: number) => {\n  const c5 = (2 * pi) / 4.5;\n\n  return x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x: number) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import * as Named from './easings-named.js';\nimport { stringTest, resultThrow } from '@ixfx/guards';\nimport { type Interval } from '@ixfx/core';\nimport type { ModulationFunction, ModulatorTimed } from '../types.js';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nexport type * from './types.js';\nimport * as ModuleTimed from '../modulator-timed.js';\nimport type { EasingName, EasingOptions } from './types.js';\n\n\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({ \n *  duration: 1000, \n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options \n * @returns \n */\nexport const create = (options: EasingOptions): () => number => {\n  const name = resolveEasingName(options.name ?? `quintIn`);\n  const fn = name ?? options.fn;\n  if (typeof fn === `undefined`) throw new Error(`Either 'name' or 'fn' must be set`);\n\n  if (`duration` in options) {\n    return time(fn, options.duration);\n  } else if (`ticks` in options) {\n    return ticks(fn, options.ticks);\n  } else {\n    throw new Error(`Expected 'duration' or 'ticks' in options`);\n  }\n}\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * \n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * \n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * \n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.timeModulator(fn, duration);\n  // const timer = Timer.elapsedMillisecondsAbsolute();\n  // const durationMs = intervalToMs(duration);\n  // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  // const relativeTimer = Timer.relative(\n  //   durationMs,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.time(fn, duration);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n\n\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  totalTicks: number\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.ticks(fn, totalTicks);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n/**\n * Creates an easing based on ticks. \n * \n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  durationTicks: number\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.tickModulator(fn, durationTicks);\n  // const timer = Timer.elapsedTicksAbsolute();\n  // const relativeTimer = Timer.relative(\n  //   durationTicks,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\nconst resolveEasingName = (nameOrFunction: EasingName | ((v: number) => number)): ModulationFunction => {\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (typeof fn === `undefined`) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n    throw error;\n  }\n  return fn;\n}\n\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\n\n\nlet easingsMap: Map<string, ((v: number) => number)> | undefined;\n\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): ModulationFunction {\n  resultThrow(stringTest(easingName, `non-empty`, `easingName`));\n\n  const found = cacheEasings().get(easingName.toLowerCase());\n  if (found === undefined) throw new Error(`Easing not found: '${ easingName }'`);\n  return found;\n};\n\n// Cache named easings\nfunction cacheEasings() {\n  if (easingsMap === undefined) {\n    easingsMap = new Map();\n    for (const [ k, v ] of Object.entries(Named)) {\n      easingsMap.set(k.toLowerCase(), v);\n    }\n    return easingsMap\n  } else return easingsMap;\n}\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames(): Iterable<string> {\n  const map = cacheEasings();\n  yield* map.keys();\n};\n\n","import { clamp, wrap, type BasicInterpolateOptions } from \"@ixfx/numbers\";\nimport { ofTotal } from \"@ixfx/flow\";\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { get as getEasing, type EasingName } from './easing/index.js';\nimport type { Interval } from \"@ixfx/core\";\nimport { piPi } from \"./util/pi-pi.js\";\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type InterpolateOptions = BasicInterpolateOptions & {\n  easing: EasingName,\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n * \n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    resultThrow(\n      numberTest(_a, ``, `a`),\n      numberTest(_b, ``, `b`),\n      numberTest(_amt, ``, `amount`)\n    );\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easer = getEasing(o.easing);\n      if (!easer) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easer;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    resultThrow(numberTest(amount, ``, `amount`));\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}","import { interpolate as interpolateFunction } from \"@ixfx/modulation\";\nimport { computeWithPrevious } from \"./compute-with-previous.js\";\n/**\n * Interpolates to the source value.\n *\n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n *\n * Options can specify an easing name or custom transform of easing progress.\n * @param input\n * @param options\n * @returns\n */\nexport function interpolate(input, options = {}) {\n    const amount = options.amount ?? 0.1;\n    const snapAt = options.snapAt ?? 0.99;\n    const index = interpolateFunction(amount, options);\n    return computeWithPrevious(input, (previous, target) => {\n        const v = index(previous, target);\n        if (target > previous) {\n            if (v / target >= snapAt)\n                return target;\n        }\n        return v;\n    });\n}\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n// export function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n//   let previousValue: TIn | undefined;\n//   let target: TIn | undefined;\n//   if (hasLast(input)) {\n//     target = previousValue = input.last();\n//   }\n//   const ping = () => {\n//     if (previousValue === undefined && target !== undefined) {\n//       previousValue = target;\n//     } else if (previousValue !== undefined && target !== undefined) {\n//       previousValue = fn(previousValue, target);\n//     }\n//     upstream.set(previousValue!);\n//   }\n//   const upstream = initUpstream<TIn, TIn>(input, {\n//     lazy: \"very\",\n//     debugLabel: `computeWithPrevious`,\n//     onValue(value) {\n//       target = value;\n//       ping();\n//     },\n//   })\n//   if (target) ping();\n//   return {\n//     ...toReadable(upstream),\n//     ping: () => {\n//       if (target !== undefined) ping()\n//     }\n//   }\n// }\n","import type { Process, RankFunction, RankOptions } from \"./types.js\";\nexport type { Process } from \"./types.js\";\n/**\n * Outputs the current largest-seen value\n * @returns \n */\nexport const max = (): Process<number | number[], number> => {\n  let max = Number.MIN_SAFE_INTEGER;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      max = Math.max(subValue, max);\n    }\n    return max;\n  }\n  return compute;\n}\n\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = (): Process<number | number[], number> => {\n  let min = Number.MAX_SAFE_INTEGER;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      min = Math.min(subValue, min);\n    }\n    return min;\n  }\n  return compute;\n}\n\n/**\n * Returns a sum of values\n * @returns \n */\nexport const sum = (): Process<number | number[], number> => {\n  let t = 0;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      t += subValue;\n    }\n    return t;\n  }\n  return compute;\n}\n\n/**\n * Returns the current average of input values\n * @returns \n */\nexport const average = (): Process<number | number[], number> => {\n  let total = 0;\n  let tally = 0;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      tally++;\n      total += subValue;\n    }\n    return total / tally;\n  }\n  return compute;\n}\n\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems \n * @returns \n */\nexport const tally = (countArrayItems: boolean): Process<any, number> => {\n  let t = 0;\n  const compute = (value: number | number[]) => {\n    if (countArrayItems) {\n      if (Array.isArray(value)) t += value.length;\n      else t++;\n    } else {\n      t++;\n    }\n    return t;\n  }\n  return compute;\n}\n\n\n\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r \n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}) {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  let best: In | undefined;\n  return (value: In) => {\n    if (includeType && typeof value !== includeType) return;\n    if (best === undefined) {\n      best = value;\n      return best;\n    } else {\n      const result = r(value, best);\n      //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n      if (result == `a`) {\n        // New value is the current best\n        best = value;\n        return best;\n      } else if (result === `eq` && emitEqualRanked) {\n        // New value is same rank as previous, but we have flag on\n        return best;\n      } else if (emitRepeatHighest) {\n        // Emit current highest due to flag\n        return best;\n      }\n    }\n  }\n}\n\n\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport * as Proc from '@ixfx/process';\nexport function max(input, options) {\n    const p = Proc.max();\n    return process(p, `max`, input, options);\n}\nexport function min(input, options) {\n    const p = Proc.min();\n    return process(p, `min`, input, options);\n}\nexport function average(input, options) {\n    const p = Proc.average();\n    return process(p, `average`, input, options);\n}\nexport function sum(input, options) {\n    const p = Proc.sum();\n    return process(p, `sum`, input, options);\n}\nexport function tally(input, options = {}) {\n    const countArrayItems = options.countArrayItems ?? true;\n    const p = Proc.tally(countArrayItems);\n    return process(p, `tally`, input, options);\n}\nexport function rank(input, rank, options) {\n    const p = Proc.rank(rank, options);\n    return process(p, `rank`, input, options);\n}\nfunction process(processor, annotationField, input, options = {}) {\n    const annotate = options.annotate;\n    let previous;\n    const skipUndefined = options.skipUndefined ?? true;\n    const skipIdentical = options.skipIdentical ?? true;\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            const x = processor(value);\n            if (x === undefined && skipUndefined)\n                return;\n            if (skipIdentical && x === previous)\n                return;\n            previous = x;\n            if (annotate) {\n                // eslint-disable-next-line unicorn/prevent-abbreviations\n                const ret = { value };\n                ret[annotationField] = x;\n                upstream.set(ret);\n            }\n            else {\n                upstream.set(x);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n//todo testing for annotation and non - annotated\n// rankArray\n// chunk, reduce\n// debounce, delay\n// duration, take\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n *\n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams\n * @returns\n */\nexport const pipe = (...streams) => {\n    const event = initStream();\n    const unsubs = [];\n    const performDispose = (reason) => {\n        for (const s of streams) {\n            if (!s.isDisposed)\n                s.dispose(reason);\n        }\n        for (const s of unsubs) {\n            s();\n        }\n        event.dispose(reason);\n    };\n    for (let index = 0; index < streams.length; index++) {\n        unsubs.push(streams[index].on((message) => {\n            const isLast = index === streams.length - 1;\n            if (messageHasValue(message)) {\n                if (isLast) {\n                    // Last stream, send to output\n                    event.set(message.value);\n                }\n                else {\n                    // @ts-expect-error\n                    streams[index + 1].set(message.value);\n                }\n            }\n            else if (messageIsDoneSignal(message)) {\n                performDispose(`Upstream disposed`);\n            }\n        }));\n    }\n    return {\n        on: event.on,\n        onValue: event.onValue,\n        dispose(reason) {\n            performDispose(reason);\n        },\n        isDisposed() {\n            return event.isDisposed();\n        },\n    };\n};\n","import { shuffle } from \"@ixfx/arrays\";\nimport { initUpstream } from \"../init-stream.js\";\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n *\n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n *\n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, {\n *  predicate: v => v % 2 === 0\n * });\n *\n * // Selects a random value from source\n * singleFromArray(source, {\n *  order: `random`,\n *  at: 0\n * });\n * ```\n *\n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns\n */\nexport function singleFromArray(source, options = {}) {\n    const order = options.order ?? `default`;\n    if (!options.at && !options.predicate)\n        throw new Error(`Options must have 'predicate' or 'at' fields`);\n    let preprocess = (values) => values;\n    if (order === `random`)\n        preprocess = shuffle;\n    else if (typeof order === `function`)\n        preprocess = (values) => values.toSorted(order);\n    const upstream = initUpstream(source, {\n        onValue(values) {\n            values = preprocess(values);\n            if (options.predicate) {\n                for (const v of values) {\n                    if (options.predicate(v)) {\n                        upstream.set(v);\n                    }\n                }\n            }\n            else if (options.at) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                upstream.set(values.at(options.at));\n            }\n        },\n    });\n    return upstream;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n *\n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource\n * @param options\n * @returns\n */\nexport const split = (rxOrSource, options = {}) => {\n    const quantity = options.quantity ?? 2;\n    const outputs = [];\n    const source = resolveSource(rxOrSource);\n    for (let index = 0; index < quantity; index++) {\n        outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n    }\n    return outputs;\n};\n/**\n * Splits `source` into several duplicated streams.\n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n *\n * See also {@link split} to get an unlabelled split\n * @param rxOrSource\n * @param labels\n * @returns\n */\nexport const splitLabelled = (rxOrSource, labels) => {\n    const source = resolveSource(rxOrSource);\n    const t = {};\n    for (const label of labels) {\n        t[label] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n    }\n    return t;\n};\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n *\n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n *\n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n *\n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n *\n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource\n * @param cases\n * @param options\n * @returns\n */\nexport const switcher = (reactiveOrSource, cases, options = {}) => {\n    // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n    const match = options.match ?? `first`;\n    const source = resolveSource(reactiveOrSource);\n    let disposed = false;\n    // Setup output streams\n    const t = {};\n    for (const label of Object.keys(cases)) {\n        t[label] = initStream();\n    }\n    const performDispose = () => {\n        if (disposed)\n            return;\n        unsub();\n        disposed = true;\n        for (const stream of Object.values(t)) {\n            stream.dispose(`switcher source dispose`);\n        }\n    };\n    // Listen to source\n    const unsub = source.on(message => {\n        // Got a value\n        if (messageHasValue(message)) {\n            for (const [lbl, pred] of Object.entries(cases)) {\n                if (pred(message.value)) {\n                    t[lbl].set(message.value);\n                    if (match === `first`)\n                        break;\n                }\n            }\n        }\n        else if (messageIsDoneSignal(message)) {\n            performDispose();\n        }\n    });\n    return t;\n    // }\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsSignal } from \"../util.js\";\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n *\n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n *\n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n *\n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray(reactiveSources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const maximumWait = intervalToMs(options.maximumWait, 2000);\n    let watchdog;\n    const data = [];\n    //const finalData: Array<RxValueTypes<T> | undefined> = [];\n    // Resolve sources\n    //const sources = reactiveSources.map(source => resolveSource(source));\n    //const noop = () => {/*no-op*/ }\n    //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n    const states = reactiveSources.map(source => ({\n        finalData: undefined,\n        done: false,\n        source: resolveSource(source),\n        unsub: () => { }\n    }));\n    const unsubscribe = () => {\n        for (const s of states) {\n            s.unsub();\n            s.unsub = () => { };\n        }\n    };\n    const isDataSetComplete = () => {\n        for (let index = 0; index < data.length; index++) {\n            if (onSourceDone === `allow` && states[index].done)\n                continue;\n            if (data[index] === undefined)\n                return false;\n        }\n        return true;\n    };\n    const hasIncompleteSource = () => states.some(s => !s.done);\n    const resetDataSet = () => {\n        for (let index = 0; index < data.length; index++) {\n            if (finalValue === `last` && states[index].done)\n                continue; // Don't overwrite\n            data[index] = undefined;\n        }\n    };\n    const onWatchdog = () => {\n        done(`Sync timeout exceeded (${maximumWait.toString()})`);\n    };\n    const done = (reason) => {\n        if (watchdog)\n            clearTimeout(watchdog);\n        unsubscribe();\n        event.dispose(reason);\n    };\n    const init = () => {\n        watchdog = setTimeout(onWatchdog, maximumWait);\n        for (const [index, state] of states.entries()) {\n            data[index] = undefined; // init array positions to be undefined\n            state.unsub = state.source.on(valueChanged => {\n                if (messageIsSignal(valueChanged)) {\n                    if (valueChanged.signal === `done`) {\n                        state.finalData = data[index];\n                        state.unsub();\n                        state.done = true;\n                        state.unsub = () => { };\n                        if (finalValue === `undefined`)\n                            data[index] = undefined;\n                        if (onSourceDone === `break`) {\n                            done(`Source '${index.toString()}' done, and onSourceDone:'break' is set`);\n                            return;\n                        }\n                        if (!hasIncompleteSource()) {\n                            done(`All sources done`);\n                            return;\n                        }\n                    }\n                    return;\n                }\n                data[index] = valueChanged.value;\n                if (isDataSetComplete()) {\n                    // All array elements contain values\n                    // Emit data and reset\n                    event.set([...data]);\n                    resetDataSet();\n                    if (watchdog)\n                        clearTimeout(watchdog);\n                    watchdog = setTimeout(onWatchdog, maximumWait);\n                }\n            });\n        }\n    };\n    const event = initStream({\n        onFirstSubscribe() {\n            unsubscribe();\n            init();\n        },\n        onNoSubscribers() {\n            if (watchdog)\n                clearTimeout(watchdog);\n            unsubscribe();\n        },\n    });\n    return {\n        dispose: event.dispose,\n        isDisposed: event.isDisposed,\n        on: event.on,\n        onValue: event.onValue\n    };\n}\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { syncToArray } from \"./sync-to-array.js\";\nimport { transform } from \"./transform.js\";\nexport function syncToObject(reactiveSources, options = {}) {\n    const keys = Object.keys(reactiveSources);\n    const values = Object.values(reactiveSources);\n    const s = syncToArray(values, options);\n    const st = transform(s, (streamValues) => {\n        return zipKeyValue(keys, streamValues);\n    });\n    return st;\n}\n","import { resolveSource } from \"../resolve-source.js\";\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns\n */\nexport function tapProcess(input, ...processors) {\n    const inputStream = resolveSource(input);\n    // @ts-expect-error\n    const chain = Process.flow(...processors);\n    inputStream.onValue(value => {\n        chain(value);\n    });\n    return inputStream;\n}\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to\n * @returns\n */\nexport function tapStream(input, diverged) {\n    const inputStream = resolveSource(input);\n    inputStream.onValue(value => {\n        diverged.set(value);\n    });\n    return inputStream;\n}\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns\n */\nexport const tapOps = (input, ...ops) => {\n    for (const op of ops) {\n        // @ts-expect-error\n        input = op(input);\n    }\n    return input;\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n *\n * Throttle will fire on the first value received.\n *\n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n *\n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration,\n * even if the source stops sending.\n * @param options\n * @returns\n */\nexport function throttle(throttleSource, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 0);\n    let lastFire = performance.now();\n    let lastValue;\n    const upstream = initUpstream(throttleSource, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            trigger();\n        },\n    });\n    const trigger = () => {\n        const now = performance.now();\n        if (elapsed > 0 && (now - lastFire > elapsed)) {\n            lastFire = now;\n            if (lastValue !== undefined) {\n                upstream.set(lastValue);\n            }\n        }\n    };\n    return toReadable(upstream);\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { isTrigger, resolveTriggerValue } from \"../util.js\";\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n *\n * If `source` emits faster than the `interval`, it won't get triggered.\n *\n * Default for 'timeout': 1000s.\n *\n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n *\n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n *\n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source\n * @param options\n */\nexport function timeoutValue(source, options) {\n    let timer;\n    const immediate = options.immediate ?? true;\n    const repeat = options.repeat ?? false;\n    const timeoutMs = intervalToMs(options.interval, 1000);\n    if (!isTrigger(options)) {\n        throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n    }\n    // Send value from trigger\n    const sendFallback = () => {\n        const [value, done] = resolveTriggerValue(options);\n        if (done) {\n            events.dispose(`Trigger completed`);\n        }\n        else {\n            if (events.isDisposed())\n                return;\n            events.set(value);\n            if (repeat) {\n                timer = setTimeout(sendFallback, timeoutMs);\n            }\n        }\n    };\n    const events = initUpstream(source, {\n        disposeIfSourceDone: true,\n        // Received a value from upstream source\n        onValue(v) {\n            // Reset timeout\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(sendFallback, timeoutMs);\n            // Emit value\n            events.set(v);\n        },\n        onDispose() {\n            if (timer)\n                clearTimeout(timer);\n        },\n    });\n    if (immediate && !timer) {\n        timer = setTimeout(sendFallback, timeoutMs);\n    }\n    return events;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { isPingable, isTrigger, messageHasValue, messageIsDoneSignal, resolveTriggerValue } from \"../util.js\";\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n *\n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n *\n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source\n * @param options\n */\nexport function timeoutPing(source, options) {\n    let timer;\n    const rx = resolveSource(source);\n    const abort = options.abort;\n    const timeoutMs = intervalToMs(options, 1000);\n    // Send ping\n    const sendPing = () => {\n        if (abort?.aborted || rx.isDisposed()) {\n            off();\n            return;\n        }\n        if (isPingable(rx))\n            rx.ping(); // ignore if not pingable\n        timer = setTimeout(sendPing, timeoutMs);\n    };\n    const cancel = () => {\n        if (timer)\n            clearTimeout(timer);\n    };\n    const off = rx.on(message => {\n        if (messageHasValue(message)) {\n            // Reset timeout\n            cancel();\n            timer = setTimeout(sendPing, timeoutMs);\n        }\n        else if (messageIsDoneSignal(message)) {\n            off();\n            cancel();\n        }\n    });\n    timer = setTimeout(sendPing, timeoutMs);\n    return rx;\n}\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../util.js\";\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n *\n * Returns a new stream capturing the output of `target`.\n *\n * It `source` or `target` closes, output stream closes too.\n *\n * @returns\n */\nexport function valueToPing(source, target, options = {}) {\n    const lazy = options.lazy ?? `initial`;\n    const signal = options.signal;\n    const sourceRx = resolveSource(source);\n    const gate = options.gate ?? ((value) => true);\n    let upstreamOff;\n    let downstreamOff;\n    if (signal) {\n        signal.addEventListener(`abort`, () => {\n            done(`Abort signal ${signal.reason}`);\n        }, { once: true });\n    }\n    const events = initStream({\n        onFirstSubscribe() {\n            if (lazy !== `never` && upstreamOff === undefined)\n                start();\n        },\n        onNoSubscribers() {\n            // Unsubscribe from source if we're very lazy\n            // Stay subscribed if we're only initially lazy or not lazy at all\n            if (lazy === `very` && upstreamOff !== undefined) {\n                upstreamOff();\n                upstreamOff = undefined;\n            }\n        },\n    });\n    const start = () => {\n        //console.log(`Rx.valueToPing  start`);\n        upstreamOff = sourceRx.on(message => {\n            if (messageIsDoneSignal(message)) {\n                done(`Upstream closed`);\n            }\n            else if (messageIsSignal(message)) {\n                events.signal(message.signal);\n            }\n            else if (messageHasValue(message)) {\n                //console.log(`Rx.valueToPing got value: ${ message.value }`);\n                if (gate(message.value)) {\n                    target.ping();\n                }\n            }\n        });\n        downstreamOff = target.on(message => {\n            if (messageIsDoneSignal(message)) {\n                done(`Downstream closed`);\n            }\n            else if (messageIsSignal(message)) {\n                events.signal(message.signal, message.context);\n            }\n            else if (messageHasValue(message)) {\n                events.set(message.value);\n            }\n        });\n    };\n    const done = (reason) => {\n        events.dispose(reason);\n        if (upstreamOff)\n            upstreamOff();\n        if (downstreamOff)\n            downstreamOff();\n    };\n    if (lazy === `never`)\n        start();\n    return events;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n *\n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input\n * @param options\n * @returns\n */\nexport function withValue(input, options) {\n    let lastValue = options.initial;\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            //console.log(`Rx.Ops.WithValue onValue: ${ value }`);\n            lastValue = value;\n            upstream.set(value);\n        },\n    });\n    const readable = toReadable(upstream);\n    return {\n        ...readable,\n        last() {\n            return lastValue;\n        },\n    };\n}\n","import { Directed } from \"@ixfx/collections/graph\";\nimport { initStream } from \"./init-stream.js\";\nimport { isReactive } from \"./util.js\";\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx\n */\nexport function prepare(_rx) {\n    let g = Directed.graph();\n    const nodes = new Map();\n    const events = initStream();\n    const process = (o, path) => {\n        for (const [key, value] of Object.entries(o)) {\n            const subPath = path + `.` + key;\n            g = Directed.connect(g, {\n                from: path,\n                to: subPath\n            });\n            if (isReactive(value)) {\n                nodes.set(subPath, { value, type: `rx` });\n                value.on(v => {\n                    console.log(`Rx.prepare value: ${JSON.stringify(v)} path: ${subPath}`);\n                });\n            }\n            else {\n                const valueType = typeof value;\n                if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n                    nodes.set(subPath, { type: `primitive`, value });\n                }\n                else if (valueType === `object`) {\n                    process(value, subPath);\n                }\n                else if (valueType === `function`) {\n                    console.log(`Rx.process - not handling functions`);\n                }\n            }\n        }\n    };\n    // const produce = () => {\n    //   Object.fromEntries(entries);\n    // }\n    // process(rx, `_root`);\n    // console.log(DiGraph.dumpGraph(g));\n    // console.log(`--- Map ---`);\n    // for (const entries of nodes.entries()) {\n    //   console.log(entries[ 0 ]);\n    //   console.log(entries[ 1 ]);\n    //   console.log(``)\n    // }\n    const returnValue = {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        dispose: events.dispose,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        isDisposed: events.isDisposed,\n        graph: g,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        on: events.on,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onValue: events.onValue\n    };\n    return returnValue;\n}\n","export const symbol = Symbol(`Rx`);\n","import { intervalToMs } from \"@ixfx/core\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n *\n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n *\n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n *\n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport async function toArray(source, options = {}) {\n    const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n    const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n    const underThreshold = options.underThreshold ?? `partial`;\n    const read = [];\n    const rx = resolveSource(source);\n    const promise = new Promise((resolve, reject) => {\n        const done = () => {\n            clearTimeout(maxWait);\n            unsub();\n            if (read.length < limit && underThreshold === `throw`) {\n                reject(new Error(`Threshold not reached. Wanted: ${limit} got: ${read.length}. Maximum wait: ${maximumWait}`));\n                return;\n            }\n            if (read.length < limit && underThreshold === `fill`) {\n                for (let index = 0; index < limit; index++) {\n                    if (read[index] === undefined) {\n                        //console.log(`Rx.toArray filling at index: ${ index }`);\n                        read[index] = options.fillValue;\n                    }\n                }\n            }\n            resolve(read);\n        };\n        const maxWait = setTimeout(() => {\n            done();\n        }, maximumWait);\n        const unsub = rx.on(message => {\n            //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n            if (messageIsDoneSignal(message)) {\n                done();\n            }\n            else if (messageHasValue(message)) {\n                read.push(message.value);\n                //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n                if (read.length === limit) {\n                    done();\n                }\n            }\n        });\n    });\n    return promise;\n}\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n *\n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport async function toArrayOrThrow(source, options = {}) {\n    const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n    const maximumWait = options.maximumWait ?? 5 * 1000;\n    const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n    // There was a limit, but it wasn't reached\n    if (options.limit && v.length < options.limit)\n        throw new Error(`Threshold not reached. Wanted: ${options.limit}, got ${v.length}`);\n    // Otherwise, we may have been reading for a specified duration\n    return v;\n}\n","import { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n *\n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n *\n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ```\n *\n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n *\n * // Execution continues here immediately\n * ```\n * @param source\n */\nexport async function* toGenerator(source) {\n    const s = resolveSource(source);\n    let promiseResolve = (_) => { };\n    let promiseReject = (_) => { };\n    const promiseInit = () => (new Promise((resolve, reject) => {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    }));\n    let promise = promiseInit();\n    let keepRunning = true;\n    s.on(message => {\n        if (messageHasValue(message)) {\n            promiseResolve(message.value);\n            promise = promiseInit();\n        }\n        else if (messageIsDoneSignal(message)) {\n            keepRunning = false;\n            promiseReject(`Source has completed`);\n        }\n    });\n    while (keepRunning) {\n        yield await promise;\n    }\n}\n","import * as Ops from \"./ops/index.js\";\nimport * as Reactives from './reactives/index.js';\nimport { resolveSource } from \"./resolve-source.js\";\nimport { toArray, toArrayOrThrow } from \"./to-array.js\";\nimport { messageHasValue } from \"./util.js\";\nimport { mapObjectShallow } from '@ixfx/core/records';\nimport * as Enacts from './sinks/index.js';\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n *\n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n *\n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source\n * @returns\n */\nexport function wrap(source) {\n    return {\n        source: resolveSource(source),\n        enacts: {\n            setHtmlText: (options) => {\n                return Enacts.setHtmlText(source, options);\n            },\n        },\n        annotate: (transformer) => {\n            const a = Ops.annotate(source, transformer);\n            return wrap(a);\n        },\n        annotateWithOp: (op) => {\n            const a = Ops.annotateWithOp(source, op);\n            return wrap(a);\n        },\n        chunk: (options) => {\n            const w = wrap(Ops.chunk(source, options));\n            return w;\n        },\n        // debounce: (options: Partial<DebounceOptions> = {}) => {\n        //   return wrap(Ops.debounce<TIn>(source, options));\n        // },\n        debounce: (options = {}) => {\n            return wrap(Reactives.debounce(source, options));\n        },\n        field: (fieldName, options = {}) => {\n            // Ops.field requires TIn extends object\n            // Would be good if `wrap` returns different versions depending on TIn, so .field\n            // would not be present at all if we had Reactive<number>, for example\n            // @ts-expect-error\n            const f = Ops.field(source, fieldName, options);\n            return wrap(f);\n        },\n        filter: (predicate, options) => {\n            return wrap(Ops.filter(source, predicate, options));\n        },\n        combineLatestToArray: (sources, options = {}) => {\n            const srcs = [source, ...sources];\n            return wrap(Ops.combineLatestToArray(srcs, options));\n        },\n        combineLatestToObject: (sources, options) => {\n            const name = options.name ?? `source`;\n            const o = { ...sources };\n            o[name] = source;\n            return wrap(Ops.combineLatestToObject(o, options));\n        },\n        min: (options = {}) => {\n            return wrap(Ops.min(source, options));\n        },\n        max: (options = {}) => {\n            return wrap(Ops.max(source, options));\n        },\n        average: (options = {}) => {\n            return wrap(Ops.average(source, options));\n        },\n        sum: (options = {}) => {\n            return wrap(Ops.sum(source, options));\n        },\n        tally: (options = {}) => {\n            return wrap(Ops.tally(source, options));\n        },\n        split: (options = {}) => {\n            const streams = Ops.split(source, options).map(v => wrap(v));\n            return streams;\n        },\n        splitLabelled: (...labels) => {\n            const l = Ops.splitLabelled(source, labels);\n            const m = mapObjectShallow(l, args => wrap(args.value));\n            return m;\n        },\n        switcher: (cases, options = {}) => {\n            const s = Ops.switcher(source, cases, options);\n            const m = mapObjectShallow(s, args => wrap(args.value));\n            return m;\n        },\n        syncToArray: (additionalSources, options = {}) => {\n            const unwrapped = [source, ...additionalSources].map(v => resolveSource(v));\n            const x = Ops.syncToArray(unwrapped, options);\n            return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n        },\n        syncToObject: (sources, options = {}) => {\n            const name = options.name ?? `source`;\n            const o = { ...sources };\n            o[name] = source;\n            return wrap(Ops.syncToObject(o, options));\n        },\n        tapProcess: (...processors) => {\n            Ops.tapProcess(source, ...processors);\n            return wrap(source);\n        },\n        tapStream: (divergedStream) => {\n            Ops.tapStream(source, divergedStream);\n            return wrap(source);\n        },\n        tapOps: (source, ...ops) => {\n            Ops.tapOps(source, ...ops);\n            return wrap(source);\n        },\n        throttle: (options = {}) => {\n            return wrap(Ops.throttle(source, options));\n        },\n        transform: (transformer, options = {}) => {\n            return wrap(Ops.transform(source, transformer, options));\n        },\n        timeoutValue: (options) => {\n            return wrap(Ops.timeoutValue(source, options));\n        },\n        timeoutPing: (options) => {\n            return wrap(Ops.timeoutPing(source, options));\n        },\n        toArray: (options) => {\n            return toArray(source, options);\n        },\n        toArrayOrThrow: (options) => {\n            return toArrayOrThrow(source, options);\n        },\n        onValue: (callback) => {\n            const s = resolveSource(source);\n            s.on(message => {\n                if (messageHasValue(message))\n                    callback(message.value);\n            });\n        }\n    };\n}\n","import { continuously } from \"@ixfx/core\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nexport const of = (source, options = {}) => {\n    if (Array.isArray(source)) {\n        return array(source, options);\n    }\n    else { }\n};\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n *\n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n *\n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n *\n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray\n * @param options\n * @returns\n */\nexport const array = (sourceArray, options = {}) => {\n    const lazy = options.lazy ?? `initial`;\n    const signal = options.signal;\n    const whenStopped = options.whenStopped ?? `continue`;\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const array = [...sourceArray];\n    if (lazy !== `very` && whenStopped === `reset`)\n        throw new Error(`whenStopped:'reset' has no effect with 'lazy:${lazy}'. Use lazy:'very' instead.`);\n    const intervalMs = intervalToMs(options.interval, 5);\n    let index = 0;\n    let lastValue = array[0];\n    const s = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            if (debugLifecycle)\n                console.log(`Rx.readFromArray:onStart`);\n            c.start();\n        },\n        onStop() {\n            if (debugLifecycle)\n                console.log(`Rx.readFromArray:onStop. whenStopped: ${whenStopped} index: ${index}`);\n            c.cancel();\n            if (whenStopped === `reset`)\n                index = 0;\n        },\n        // onFirstSubscribe() {\n        //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n        //   // Start if in lazy mode and not running\n        //   if (lazy !== `never` && c.runState === `idle`) c.start();\n        // },\n        // onNoSubscribers() {\n        //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n        //   if (lazy === `very`) {\n        //     c.cancel();\n        //     if (whenStopped === `reset`) {\n        //       index = 0;\n        //     }\n        //   }\n        // }\n    });\n    const c = continuously(() => {\n        if (signal?.aborted) {\n            s.dispose(`Signalled (${signal.reason})`);\n            return false; // stop looping\n        }\n        lastValue = array[index];\n        index++;\n        s.set(lastValue);\n        if (index === array.length) {\n            s.dispose(`Source array complete`);\n            return false; // stop loop\n        }\n    }, intervalMs);\n    if (!lazy)\n        c.start();\n    return {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        dispose: s.dispose,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        isDisposed: s.isDisposed,\n        isDone() {\n            return index === array.length;\n        },\n        last() {\n            return lastValue;\n        },\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        on: s.on,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onValue: s.onValue\n    };\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { compareArrays } from \"@ixfx/core/records\";\nimport { remove as ArraysRemove, insertAt as ArraysInsertAt } from '@ixfx/arrays';\n/**\n * Wraps an array object.\n *\n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue\n * @param options\n * @returns\n */\nexport function arrayObject(initialValue = [], options = {}) {\n    const eq = options.eq ?? isEqualValueDefault;\n    const setEvent = initStream();\n    //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n    const arrayEvent = initStream();\n    let value = initialValue;\n    let disposed = false;\n    const set = (replacement) => {\n        const diff = compareArrays(value, replacement, eq);\n        //console.log(`Rx.fromArray.set diff`, diff);\n        //if (diff.length === 0) return;\n        //diffEvent.set(diff);\n        value = replacement;\n        setEvent.set([...replacement]);\n    };\n    const setAt = (index, v) => {\n        value[index] = v;\n        setEvent.set([...value]);\n    };\n    const push = (v) => {\n        value = [...value, v];\n        setEvent.set([...value]);\n        const cr = [`add`, value.length - 1, v];\n        arrayEvent.set([cr]);\n    };\n    const deleteAt = (index) => {\n        const valueChanged = ArraysRemove(value, index);\n        if (valueChanged.length === value.length)\n            return; // no change\n        const diff = compareArrays(value, valueChanged, eq);\n        //console.log(diff.summary);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n    };\n    const deleteWhere = (filter) => {\n        const valueChanged = value.filter(v => !filter(v));\n        const count = value.length - valueChanged.length;\n        const diff = compareArrays(value, valueChanged, eq);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n        return count;\n    };\n    const insertAt = (index, v) => {\n        const valueChanged = ArraysInsertAt(value, index, v);\n        const diff = compareArrays(value, valueChanged, eq);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n    };\n    // const update = (toMerge: Partial<V>) => {\n    //   // eslint-disable-next-line unicorn/prefer-ternary\n    //   if (value === undefined) {\n    //     value = toMerge as V;\n    //   } else {\n    //     const diff = Immutable.compareData(toMerge, value);\n    //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n    //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n    //     if (diff.length === 0) return; // No changes\n    //     value = {\n    //       ...value,\n    //       ...toMerge\n    //     }\n    //     diffEvent.set(diff);\n    //   }\n    //   setEvent.set(value);\n    // }\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        //diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    const r = {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        last: () => value,\n        on: setEvent.on,\n        onArray: arrayEvent.on,\n        onValue: setEvent.onValue,\n        setAt,\n        push,\n        deleteAt,\n        deleteWhere,\n        insertAt,\n        /**\n         * Set the whole object\n         */\n        set\n    };\n    return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function boolean(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { continuously } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n *\n * ```js\n * const r = Rx.From.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n *\n * The `limit` is exclusive\n * ```js\n * const r = Rx.From.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n *\n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n *\n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.From.count({ start: 10, amount: 2, interval: 500 });\n * ```\n *\n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.From.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options\n */\nexport function count(options = {}) {\n    const lazy = options.lazy ?? `initial`;\n    const interval = intervalToMs(options.interval, 1000);\n    const amount = options.amount ?? 1;\n    const offset = options.offset ?? 0;\n    let produced = 0;\n    let value = offset;\n    const done = (reason) => {\n        events.dispose(reason);\n    };\n    const timer = continuously(() => {\n        if (options.signal?.aborted) {\n            done(`Aborted (${options.signal.reason})`);\n            return false;\n        }\n        events.set(value);\n        value += 1;\n        produced++;\n        if (produced >= amount) {\n            done(`Limit reached`);\n            return false;\n        }\n    }, interval);\n    const events = initLazyStream({\n        onStart() {\n            timer.start();\n        },\n        onStop() {\n            timer.cancel();\n        },\n        onDispose() {\n            timer.cancel();\n        },\n        lazy\n    });\n    return events;\n}\n","import { isEqualValueDefault } from \"@ixfx/core\";\nimport { cache } from \"../cache.js\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { combineLatestToObject } from \"../ops/combine-latest-to-object.js\";\nexport function derived(fn, reactiveSources, options = {}) {\n    const ignoreIdentical = options.ignoreIdentical ?? true;\n    const eq = options.eq ?? (isEqualValueDefault);\n    const sources = combineLatestToObject(reactiveSources);\n    const handle = (v) => {\n        const last = output.last();\n        const vv = fn(v);\n        if (vv !== undefined) {\n            if (ignoreIdentical && last !== undefined) {\n                if (eq(vv, last))\n                    return vv;\n            }\n            output.set(vv);\n        }\n        return vv;\n    };\n    // When the combined stream emits a value, output it\n    const s = initUpstream(sources, {\n        ...options,\n        onValue(v) {\n            handle(v);\n        },\n    });\n    const output = cache(s, fn(sources.last()));\n    return output;\n}\n","import { field } from \"../ops/field.js\";\nimport { object } from \"./object.js\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { elapsedInterval } from \"@ixfx/core/elapsed\";\n/**\n * Fired when `eventName` fires on `target`.\n *\n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n *\n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId')\n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField(targetOrQuery, eventName, fieldName, initialValue, options = {}) {\n    const initial = {};\n    initial[fieldName] = initialValue;\n    const rxField = field(event(targetOrQuery, eventName, initial, options), fieldName, options);\n    return rxField;\n}\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n/**\n * Subscribes to an event, emitting data\n *\n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n *\n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n *\n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns\n */\nexport function event(targetOrQuery, name, initialValue, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const lazy = options.lazy ?? false;\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    if (initialValue === undefined)\n        initialValue = {};\n    const rxObject = object(initialValue, { deepEntries: true });\n    let eventAdded = false;\n    let disposed = false;\n    const callback = (args) => {\n        if (debugFiring)\n            console.log(`Reactive.event '${name}' firing '${JSON.stringify(args)}`);\n        rxObject.set(args);\n    };\n    const remove = () => {\n        if (!eventAdded)\n            return;\n        eventAdded = false;\n        target.removeEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event remove '${name}'`);\n        }\n    };\n    const add = () => {\n        if (eventAdded)\n            return;\n        eventAdded = true;\n        target.addEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event add '${name}'`);\n        }\n    };\n    if (!lazy)\n        add();\n    return {\n        last: () => {\n            if (lazy)\n                add();\n            return rxObject.last();\n        },\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            disposed = true;\n            remove();\n            rxObject.dispose(reason);\n        },\n        isDisposed() {\n            return disposed;\n        },\n        on: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.on(handler);\n        },\n        onValue: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.onValue(handler);\n        }\n    };\n}\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of\n * times event has been fired.\n * @param targetOrQuery\n * @param name\n * @param options\n * @returns\n */\nexport function eventTrigger(targetOrQuery, name, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const fireInitial = options.fireInitial ?? false;\n    let count = 0;\n    const elapsed = elapsedInterval();\n    const stream = initLazyStream({\n        lazy: options.lazy ?? `very`,\n        onStart() {\n            target.addEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger add '${name}'`);\n            }\n            if (fireInitial && count === 0) {\n                if (debugLifecycle || debugFiring)\n                    console.log(`Rx.From.eventTrigger: firing initial`);\n                callback();\n            }\n        },\n        onStop() {\n            target.removeEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger remove '${name}'`);\n            }\n        },\n    });\n    const callback = (_args) => {\n        if (debugFiring)\n            console.log(`Rx.From.eventTrigger '${name}' triggered'`);\n        stream.set({\n            sinceLast: elapsed(),\n            total: ++count\n        });\n    };\n    return stream;\n}\n","import { initLazyStream } from \"../init-stream.js\";\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources\n * @returns\n */\nexport function merged(...sources) {\n    return mergedWithOptions(sources);\n}\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n *\n * @param sources\n * @param options\n * @returns\n */\nexport function mergedWithOptions(sources, options = {}) {\n    let unsubs = [];\n    const stream = initLazyStream({\n        ...options,\n        onStart() {\n            for (const s of sources) {\n                unsubs.push(s.onValue(v => {\n                    stream.set(v);\n                }));\n            }\n        },\n        onStop() {\n            for (const un of unsubs) {\n                un();\n            }\n            unsubs = [];\n        },\n    });\n    return stream;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function number(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","import { object } from \"./object.js\";\nimport { symbol } from \"../types.js\";\nimport { array } from \"./array.js\";\nimport { arrayObject } from \"./array-object.js\";\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n *\n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n *\n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n *\n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n *\n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n *\n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n *\n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n *\n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n *\n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target\n * @returns\n */\nexport const objectProxy = (target) => {\n    const rx = object(target);\n    const proxy = new Proxy(target, {\n        set(target, p, newValue, _receiver) {\n            const isArray = Array.isArray(target);\n            //console.log(`Rx.Sources.object set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n            // Ignore length if target is array\n            if (isArray && p === `length`)\n                return true;\n            if (typeof p === `string`) {\n                rx.updateField(p, newValue);\n            }\n            // If target is array and field looks like an array index...\n            if (isArray && typeof p === `string`) {\n                const pAsNumber = Number.parseInt(p);\n                if (!Number.isNaN(pAsNumber)) {\n                    target[pAsNumber] = newValue;\n                    return true;\n                }\n            }\n            target[p] = newValue;\n            return true;\n        }\n    });\n    return { proxy, rx };\n};\nexport const arrayProxy = (target) => {\n    const rx = arrayObject(target);\n    const proxy = new Proxy(target, {\n        set(target, p, newValue, _receiver) {\n            //console.log(`Rx.Sources.arrayProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n            // Ignore length if target is array\n            if (p === `length`)\n                return true;\n            if (typeof p !== `string`)\n                throw new Error(`Expected numeric index, got type: ${typeof p} value: ${JSON.stringify(p)}`);\n            const pAsNumber = Number.parseInt(p);\n            if (!Number.isNaN(pAsNumber)) {\n                rx.setAt(pAsNumber, newValue);\n                target[pAsNumber] = newValue;\n                return true;\n            }\n            else {\n                throw new Error(`Expected numeric index, got: '${p}'`);\n            }\n        }\n    });\n    return { proxy, rx };\n};\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with\n * the Reactive wrapped as symbol property.\n *\n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n *\n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two.\n * @param target\n * @returns\n */\nexport const objectProxySymbol = (target) => {\n    const { proxy, rx } = objectProxy(target);\n    const p = proxy;\n    p[symbol] = rx;\n    return p;\n};\n","import { messageHasValue } from \"../util.js\";\nimport { manual } from \"../index.js\";\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n *\n *  // To send a value:\n *  stream.set(someValue);\n *\n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n *\n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n *\n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init\n * @returns\n */\nexport function observable(init) {\n    const ow = observableWritable(init);\n    return {\n        dispose: ow.dispose,\n        isDisposed: ow.isDisposed,\n        on: ow.on,\n        onValue: ow.onValue\n    };\n}\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init\n * @returns\n */\nexport function observableWritable(init) {\n    let onCleanup = () => { };\n    const ow = manual({\n        onFirstSubscribe() {\n            onCleanup = init(ow);\n        },\n        onNoSubscribers() {\n            if (onCleanup)\n                onCleanup();\n        },\n    });\n    return {\n        ...ow,\n        onValue: (callback) => {\n            return ow.on(message => {\n                if (messageHasValue(message)) {\n                    callback(message.value);\n                }\n            });\n        }\n    };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function string(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","export * from './array.js';\nexport * from './array-object.js';\nexport * from './boolean.js';\nexport * from './count.js';\nexport * from './derived.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterator.js';\nexport * from './merged.js';\nexport * from './number.js';\nexport * from './object.js';\nexport * from './object-proxy.js';\nexport * from './observable.js';\nexport * from './string.js';\nexport * from './types.js';\n","import { intervalToMs } from '@ixfx/core';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./util.js\";\nimport { initStream } from \"./init-stream.js\";\nimport { resolveSource } from './resolve-source.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * as From from './from/index.js';\nexport * from './init-stream.js';\nexport function run(source, ...ops) {\n    let s = resolveSource(source);\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    return s;\n}\nexport function writable(source, ...ops) {\n    let s = resolveSource(source);\n    const head = s;\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    const ss = s;\n    return {\n        ...ss,\n        set(value) {\n            if (isWritable(head)) {\n                head.set(value);\n            }\n            else\n                throw new Error(`Original source is not writable`);\n        }\n    };\n    //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n    //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n    //return raw(source);\n}\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns\n */\nexport function manual(options = {}) {\n    const events = initStream(options);\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        set(value) {\n            events.set(value);\n        },\n        on: events.on,\n        onValue: events.onValue\n    };\n}\nexport const Sinks = {\n    setHtmlText: (options) => {\n        return (source) => {\n            SinkFns.setHtmlText(source, options);\n        };\n    }\n};\nexport const Ops = {\n    /**\n   * Annotates values with the result of a function.\n   * The input value needs to be an object.\n   *\n   * For every value `input` emits, run it through `annotator`, which should\n   * return the original value with additional fields.\n   *\n   * Conceptually the same as `transform`, just with typing to enforce result\n   * values are V & TAnnotation\n   * @param annotator\n   * @returns\n   */\n    annotate: (annotator) => opify(OpFns.annotate, annotator),\n    /**\n     * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n     * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n     * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n     *\n     * ```js\n     * // Emit values from an array\n     * const r1 = Rx.run(\n     *  Rx.From.array([ 1, 2, 3 ]),\n     *  Rx.Ops.annotateWithOp(\n     *    // Add the 'max' operator to emit the largest-seen value\n     *    Rx.Ops.sum()\n     *  )\n     * );\n     * const data = await Rx.toArray(r1);\n     * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n     * ```\n     * @param annotatorOp\n     * @returns\n     */\n    annotateWithOp: (annotatorOp) => opify(OpFns.annotateWithOp, annotatorOp),\n    /**\n     * Takes a stream of values and chunks them up (by quantity or time elapsed),\n     * emitting them as an array.\n     * @param options\n     * @returns\n     */\n    chunk: (options) => {\n        return (source) => {\n            return OpFns.chunk(source, options);\n        };\n    },\n    cloneFromFields: () => {\n        return (source) => {\n            return OpFns.cloneFromFields(source);\n        };\n    },\n    /**\n   * Merges values from several sources into a single source that emits values as an array.\n   * @param options\n   * @returns\n   */\n    combineLatestToArray: (options = {}) => {\n        return (sources) => {\n            return OpFns.combineLatestToArray(sources, options);\n        };\n    },\n    /**\n     * Merges values from several sources into a single source that emits values as an object.\n     * @param options\n     * @returns\n     */\n    combineLatestToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.combineLatestToObject(reactiveSources, options);\n        };\n    },\n    /**\n   * Debounce values from the stream. It will wait until a certain time\n   * has elapsed before emitting latest value.\n   *\n   * Effect is that no values are emitted if input emits faster than the provided\n   * timeout.\n   *\n   * See also: throttle\n   * @param options\n   * @returns\n   */\n    // debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    //   return (source: ReactiveOrSource<V>) => {\n    //     return OpFns.debounce(source, options);\n    //   }\n    // },\n    /**\n     * Drops values from the input stream that match `predicate`\n     * @param predicate If it returns _true_ value is ignored\n     * @returns\n     */\n    drop: (predicate) => opify(OpFns.drop, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @returns\n     */\n    elapsed: () => opify(OpFns.elapsed),\n    /**\n     * Yields the value of a field from an input stream of values.\n     * Eg if the source reactive emits `{ colour: string, size: number }`,\n     * we might use `field` to pluck out the `colour` field, thus returning\n     * a stream of string values.\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    field: (fieldName, options) => {\n        return (source) => {\n            return OpFns.field(source, fieldName, options);\n        };\n    },\n    /**\n     * Filters the input stream, only re-emitting values that pass the predicate\n     * @param predicate If it returns _true_ value is allowed through\n     * @returns\n     */\n    filter: (predicate) => opify(OpFns.filter, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @param options\n     * @returns\n     */\n    interpolate: (options) => opify(OpFns.interpolate, options),\n    /**\n   * Outputs the minimum numerical value of the stream.\n   * A value is only emitted when minimum decreases.\n   * @returns\n   */\n    min: (options) => opify(OpFns.min, options),\n    /**\n     * Outputs the maxium numerical value of the stream.\n     * A value is only emitted when maximum increases.\n     * @returns\n     */\n    max: (options) => opify(OpFns.max, options),\n    sum: (options) => opify(OpFns.sum, options),\n    average: (options) => opify(OpFns.average, options),\n    tally: (options) => opify(OpFns.tally, options),\n    rank: (rank, options) => opify(OpFns.rank, rank, options),\n    pipe: (...streams) => {\n        return (source) => {\n            const resolved = resolveSource(source);\n            const s = [resolved, ...streams];\n            return OpFns.pipe(...s);\n        };\n    },\n    singleFromArray: (options = {}) => {\n        return (source) => {\n            return OpFns.singleFromArray(source, options);\n        };\n    },\n    split: (options = {}) => {\n        return (source) => {\n            return OpFns.split(source, options);\n        };\n    },\n    splitLabelled: (labels) => {\n        return (source) => {\n            return OpFns.splitLabelled(source, labels);\n        };\n    },\n    switcher: (cases, options = {}) => {\n        return (source) => {\n            return OpFns.switcher(source, cases, options);\n        };\n    },\n    syncToArray: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToArray(reactiveSources, options);\n        };\n    },\n    syncToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToObject(reactiveSources, options);\n        };\n    },\n    tapProcess: (processor) => {\n        return (source) => {\n            return OpFns.tapProcess(source, processor);\n        };\n    },\n    tapStream: (divergedStream) => {\n        return (source) => {\n            return OpFns.tapStream(source, divergedStream);\n        };\n    },\n    tapOps: (...ops) => {\n        return (source) => {\n            return OpFns.tapOps(source, ...ops);\n        };\n    },\n    /**\n   * Throttle values from the stream.\n   * Only emits a value if some minimum time has elapsed.\n   * @param options\n   * @returns\n   */\n    throttle: (options) => opify(OpFns.throttle, options),\n    /**\n     * Trigger a value if 'source' does not emit a value within an interval.\n     * Trigger value can be a fixed value, result of function, or step through an iterator.\n     * @param options\n     * @returns\n     */\n    timeoutValue: (options) => {\n        return (source) => {\n            return OpFns.timeoutValue(source, options);\n        };\n    },\n    timeoutPing: (options) => {\n        return (source) => {\n            return OpFns.timeoutPing(source, options);\n        };\n    },\n    transform: (transformer, options = {}) => {\n        return (source) => {\n            return OpFns.transform(source, transformer, options);\n        };\n    },\n    /**\n    * Reactive where last (or a given initial) value is available to read\n    * @param opts\n    * @returns\n    */\n    withValue: (opts) => {\n        return opify(OpFns.withValue, opts);\n    },\n};\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n *\n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n *\n * Throws an error if the source closes without\n * a value or the timeout is reached.\n *\n * @param source\n * @param maximumWait\n * @returns\n */\nexport async function takeNextValue(source, maximumWait = 1000) {\n    const rx = resolveSource(source);\n    let off = () => { };\n    let watchdog;\n    const p = new Promise((resolve, reject) => {\n        off = rx.on(message => {\n            if (watchdog)\n                clearTimeout(watchdog);\n            if (messageHasValue(message)) {\n                off();\n                resolve(message.value);\n            }\n            else {\n                if (messageIsDoneSignal(message)) {\n                    reject(new Error(`Source closed. ${message.context ?? ``}`));\n                    off();\n                }\n            }\n        });\n        watchdog = setTimeout(() => {\n            watchdog = undefined;\n            off();\n            reject(new Error(`Timeout waiting for value (${JSON.stringify(maximumWait)})`));\n        }, intervalToMs(maximumWait));\n    });\n    return p;\n}\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n *\n * Returns a function to unsubcribe A->B\n * @param a\n * @param b\n * @param transform\n */\nexport const to = (a, b, transform, closeBonA = false) => {\n    const unsub = a.on(message => {\n        if (messageHasValue(message)) {\n            const value = transform ? transform(message.value) : message.value;\n            b.set(value);\n        }\n        else if (messageIsDoneSignal(message)) {\n            unsub();\n            if (closeBonA) {\n                b.dispose(`Source closed (${message.context ?? ``})`);\n            }\n        }\n        else {\n            // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n        }\n    });\n    return unsub;\n};\n","export * from '@ixfx/rx';"],"mappings":"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"}