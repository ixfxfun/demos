{"version":3,"file":"modulation-CvyUdv28.js","names":["value: unknown","p: unknown","toCartesian: ToCartesian","a: Coord | number","b?: Point | number","c?: Point","EmptyPoint","distance: number","angleRadians: number","origin: Point","distance","pt: Point","a: Point","b: Point","interpolate","amount: number","a: Point","b: Point","pt: Point | Point3d","what: `both` | `x` | `y` | `z`","point: Point","pipeline","pt: Point","maxOrOptions: (number | RandomOptions)","origin: Point","width: number","height: number","rect: RectPositioned | Rect","edge: `right` | `bottom` | `left` | `top`","start: Point","end: Point","q: QuadraticBezier | CubicBezier","BezierLibrary","amount: number","handle: Point","cubicOrQuadratic: CubicBezier | QuadraticBezier","cubic1: Point","cubic2: Point","cubic: CubicBezier","cubic","t: number","_: Point","_point: Point","_intersectionThreshold: number","quadraticBezier: QuadraticBezier","quadratic","produce: ResolveToValue<T> | ArrayLike<T>","opts: RepeatDelayOpts","elapsed","duration: Interval","opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean }","t: ModulationTimer | undefined","totalTicks: number","total: number","options: Partial<RelativeTimerOpts>","value: number","amt: number","frequency: number","options: Partial<TimerOpts>","fn: ((v: number) => number)","timer: CompletionTimer","elapsed","m: V","opts: StateMachineWithEventsOptions<V>","#debug","#sm","#smInitial","v: boolean","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt","newState: StateNames<V>","#sm","#holdingInitial","#timer","#timeSource","#holding","#disposed","elapsed","relative","#triggered","adsr","ticks","bpm","clamp","elapsed","elapsed","pow","time","relative","ticks","Named","guard","mass","pipeline","distance","piPi","interpolate","interpolateAngle","piPi","abs","relative","distance","to","invert"],"sources":["../../packages/guards/src/function.ts","../../packages/geometry/src/polar/guard.ts","../../packages/geometry/src/polar/conversions.ts","../../packages/geometry/src/point/abs.ts","../../packages/geometry/src/point/compare.ts","../../packages/geometry/src/point/interpolate.ts","../../packages/geometry/src/point/invert.ts","../../packages/geometry/src/point/pipeline.ts","../../packages/random/src/float-source.ts","../../packages/geometry/src/rect/from-top-left.ts","../../packages/geometry/src/rect/edges.ts","../../packages/geometry/src/bezier/index.ts","../../packages/flow/src/repeat.ts","../../packages/flow/src/timer.ts","../../packages/modulation/dist/src/envelope/Types.js","../../packages/flow/src/state-machine/with-events.ts","../../packages/modulation/dist/src/envelope/AdsrBase.js","../../packages/modulation/dist/src/envelope/Adsr.js","../../packages/modulation/dist/src/envelope/index.js","../../packages/modulation/dist/src/source/ticks.js","../../packages/modulation/dist/src/source/time.js","../../packages/modulation/dist/src/source/per-second.js","../../packages/modulation/dist/src/source/index.js","../../packages/modulation/dist/src/cubic-bezier.js","../../packages/modulation/dist/src/drift.js","../../packages/modulation/dist/src/gaussian.js","../../packages/modulation/dist/src/easing/easings-named.js","../../packages/modulation/dist/src/easing/line.js","../../packages/modulation/dist/src/modulator-timed.js","../../packages/modulation/dist/src/easing/index.js","../../packages/modulation/dist/src/forces.js","../../packages/modulation/dist/src/util/pi-pi.js","../../packages/modulation/dist/src/interpolate.js","../../packages/modulation/dist/src/jitter.js","../../packages/modulation/dist/src/mix.js","../../packages/modulation/dist/src/no-op.js","../../packages/modulation/dist/src/oscillator.js","../../packages/modulation/dist/src/ping-pong.js","../../packages/modulation/dist/src/spring.js","../../packages/modulation/dist/src/timing-source-factory.js","../../packages/modulation/dist/src/waveforms.js","../../packages/modulation/dist/src/weighted-average.js","../../packages/modulation/dist/src/weighted-random.js","../src/modulation.ts"],"sourcesContent":["import type { Result } from \"./types.js\";\n\nexport const isFunction = (object: unknown): object is (...args: any[]) => any => object instanceof Function;\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport const functionTest = (value: unknown, parameterName = `?`): Result<Function, string> => {\n  if (value === undefined) return { success: false, error: `Param '${ parameterName }' is undefined. Expected: function.` };\n  if (value === null) return { success: false, error: `Param '${ parameterName }' is null. Expected: function.` };\n  if (typeof value !== `function`) return { success: false, error: `Param '${ parameterName }' is type '${ typeof value }'. Expected: function` };\n  return { success: true, value };\n}\n\n// export const throwFunctionTest = (value: unknown, parameterName = `?`) => {\n//   const [ ok, message ] = functionTest(value, parameterName);\n//   if (ok) return;\n//   throw new TypeError(message);\n// }","import type { Coord } from \"./types.js\";\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};","import type { Point } from \"../point/point-type.js\";\nimport { guard, isPolarCoord } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = EmptyPoint;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = EmptyPoint;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtractPoint(point, origin);\n\n  const angle = Math.atan2(point.y, point.x);\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = EmptyPoint\n): Point => {\n  guardPoint(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyPoint): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function abs(pt: Point3d): Point3d;\nexport function abs(pt: Point): Point;\n\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt: Point): Point {\n  if (isPoint3d(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y),\n      z: Math.abs(pt.z)\n    });\n  } else if (isPoint(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y)\n    });\n  } else throw new TypeError(`Param 'pt' is not a point`);\n};","import type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}\n\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a: Point3d, b: Point3d): number => {\n  if (a.z === b.z) return 0;\n  if (a.z < b.z) return -1;\n  return 1;\n}","import type { Point } from \"./point-type.js\";\nimport { interpolate as lineInterpolate } from '../line/interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { type RandomOptions, type RandomSource } from \"./types.js\";\n\n/**\n * Source for random bipolar values\n * ```js\n * const r = bipolarSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n * \n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * bipolarSource({ max: 0.5 });\n * ```\n * \n * \n * @param maxOrOptions Maximum value (number) or options for random generation\n * @returns \n */\nexport const bipolarSource = (maxOrOptions?: number | RandomOptions): RandomSource => {\n  const source = floatSource(maxOrOptions);\n  return () => (source() * 2) - 1;\n}\n\n/**\n * Returns a random bipolar value\n * ```js\n * const r = bipolar(); // -1...1 random\n * ```\n * \n * Options can be provided, eg.\n * ```js\n * bipolar({ max: 0.5 }); // -0.5..0.5 random\n * ```\n * \n * Use {@link bipolarSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions \n * @returns \n */\nexport const bipolar = (maxOrOptions?: number | RandomOptions): number => {\n  const source = bipolarSource(maxOrOptions);\n  return source();\n}\n\n/**\n * Returns a function that produces random float values.\n * Use {@link float} to produce a valued directly.\n *\n * Random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n *\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const r = floatSource();\n * r(); // Execute to produce random value\n *\n * // Random float between 0..100 (but not including 100)\n * const v = floatSource(100)();\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const r = floatSource({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const floatSource = (maxOrOptions: (number | RandomOptions) = 1): RandomSource => {\n  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n  let max = options.max ?? 1;\n  let min = options.min ?? 0;\n  const source = options.source ?? Math.random;\n\n  resultThrow(\n    numberTest(min, ``, `min`),\n    numberTest(max, ``, `max`)\n  );\n\n  if (!options.min && max < 0) {\n    min = max;\n    max = 0;\n  }\n  if (min > max) {\n    throw new Error(`Min is greater than max. Min: ${ min.toString() } max: ${ max.toString() }`);\n  }\n\n  return () => source() * (max - min) + min;\n};\n\n/**\n * Returns a random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n * Use {@link floatSource} to get a function that produces values. This is used internally.\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const v = float();\n * // Random float between 0..100 (but not including 100)\n * const v = float(100);\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const v = float({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const float = (maxOrOptions: (number | RandomOptions) = 1): number =>\n  floatSource(maxOrOptions)();","import type { Point } from \"../point/point-type.js\";\nimport { guardDim } from \"./guard.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { guard } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/join-points-to-lines.js';\n\nimport type { Point } from '../point/point-type.js';\nimport { corners } from \"./corners.js\";\nimport type { Line } from \"../line/line-type.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Line> => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import type { BasicType } from '@ixfx/core';\nimport { resolve, resolveSync, type ResolveToValue, type ResolveToValueSync } from '@ixfx/core';\nimport { intervalToMs, type Interval } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n\nexport type RepeatDelayOpts = RepeatOpts & Readonly<Partial<{\n  /**\n * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n */\n  delay: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  delayMinimum: Interval;\n\n  /**\n * When to perform delay. Default is before 'produce' is invoked.\n * Default: 'before'\n */\n  delayWhen: `before` | `after` | `both`;\n}>>\n\n\n/**\n * Options for repeat\n */\nexport type RepeatOpts = Partial<Readonly<{\n  /**\n   * If specified, repeating stops if this function returns false\n   * @param count\n   * @returns \n   */\n  while: (count: number) => boolean\n  /**\n   * By default, if the callback returns\n   * _undefined_ the repeating exits. Set this to _true_ to\n   * ignore undefined values\n   * @default false\n   */\n  allowUndefined: boolean\n  /**\n   * Optional signal to abort\n   */\n  signal: AbortSignal;\n\n  /**\n   * Maximum times to repeat (default: no limit)\n   */\n  count: number\n  /**\n   * Function to call when initialising\n   * @returns \n   */\n  onStart: () => void\n\n  /**\n   * Function to call when done (or an error occurs)\n   * @returns \n   */\n  onComplete: (withError: boolean) => void\n}>>;\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat<T extends BasicType>(\n  produce: ResolveToValue<T> | ArrayLike<T>,\n  opts: RepeatDelayOpts\n): AsyncGenerator<T> {\n  const signal = opts.signal ?? undefined;\n  const delayWhen = opts.delayWhen ?? `before`;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n  const whileFunction = opts.while;\n\n  let cancelled = false;\n  let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n  let started = performance.now();\n\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      if (delayWhen === `before` || delayWhen === `both`) await doDelay();\n      const result = await resolve<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (delayWhen === `after` || delayWhen === `both`) await doDelay();\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n      }\n      if (whileFunction) {\n        if (!whileFunction(loopedTimes)) {\n          cancelled = true;\n        }\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks. \n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync<T extends BasicType>(\n  produce: ResolveToValueSync<T> | ArrayLike<T>,\n  opts: RepeatOpts\n) {\n  const signal = opts.signal ?? undefined;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  let cancelled = false;\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      const result = resolveSync<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n        if (signal?.aborted) cancelled = true;\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n\n\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n\n\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs, type HasCompletion, type Interval } from '@ixfx/core';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * Implementations: {@link elapsedMillisecondsAbsolute}, {@link elapsedTicksAbsolute}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relative}\n */\nexport type CompletionTimer = Timer & {\n  /**\n   * Returns _true_ if this timer has completed.\n   */\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link elapsedMillisecondsAbsolute}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * import { hasElapsed } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const oneSecond = hasElapsed(1000);\n * \n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n * \n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n  return () => t.isDone;\n}\n\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotal(1000);\n * \n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n * \n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`Param 'duration' not valid`);\n  const timerOpts = {\n    ...opts,\n    timer: elapsedMillisecondsAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalMs, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks: number, opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const timerOpts = {\n    ...opts,\n    timer: elapsedTicksAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalTicks, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns \n */\nexport const timerAlwaysDone = (): ModulationTimer => ({\n  elapsed: 1,\n  isDone: true,\n  reset(): void {\n\n  },\n  mod(amt) {\n\n  },\n})\n\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns \n */\nexport const timerNeverDone = (): ModulationTimer => (\n  {\n    elapsed: 0,\n    isDone: false,\n    reset() {\n\n    },\n    mod() {\n\n    }\n  }\n);\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (\n  total: number,\n  options: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  if (!Number.isFinite(total)) {\n    return timerAlwaysDone()\n  } else if (Number.isNaN(total)) {\n    return timerNeverDone();\n  }\n\n  const clampValue = options.clampValue ?? false;\n  const wrapValue = options.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  // Keep track of value to avoid over-advancing the tick counter\n  let lastValue = 0;\n  const computeElapsed = (value: number) => {\n    lastValue = value;\n    let v = value / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      //const tmp = computeElapsed();\n      //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n      return computeElapsed(lastValue) >= 1;\n    },\n    get elapsed() {\n      return computeElapsed(timer.elapsed);\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  options: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = (): Timer & { peek: number } => {\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Get current ticks without incrementing.\n     */\n    get peek() {\n      return start;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     * \n     * Use {@link peek} to get the current ticks without incrementing.\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n\n\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n * \n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n * \n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n * \n * @param fn \n * @param timer \n * @returns \n */\nexport const timerWithFunction = (\n  fn: ((v: number) => number),\n  timer: CompletionTimer\n): HasCompletion & CompletionTimer & { compute: () => number } => {\n  if (typeof fn !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${ typeof fn }`);\n  let startCount = 1;\n  return {\n    get elapsed() {\n      return timer.elapsed;\n    },\n    get isDone() {\n      return timer.isDone;\n    },\n    get runState() {\n      if (timer.isDone) return `idle`;\n      return `scheduled`;\n    },\n    /**\n     * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n     */\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCount;\n    },\n    compute: () => {\n      const elapsed = timer.elapsed;\n      return fn(elapsed);\n    },\n    reset: () => {\n      timer.reset();\n      startCount++;\n    },\n  };\n};","export const adsrStateTransitions = Object.freeze({\n    attack: [`decay`, `release`],\n    decay: [`sustain`, `release`],\n    sustain: [`release`],\n    release: [`complete`],\n    complete: null,\n});\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport type { StateNames, Transitions, MachineState } from './types.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type StateMachineWithEventsOptions<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\n/**\n * A state machine that fires events when state changes.\n * \n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = elapsedInfinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param m Machine description\n   * @param opts Options for machine (defaults to `{debug:false}`)\n   */\n  constructor(m: V, opts: StateMachineWithEventsOptions<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): readonly (StateNames<V> | null)[] {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): readonly StateNames<V>[] {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[ 0 ]!;\n    return p[ 0 ]!;\n  }\n\n  /**\n   * Returns _true_ if state machine is in its final state\n   *\n   * @returns\n   */\n  get isDone(): boolean {\n    return StateMachine.isDone(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n    this.#changedAt = elapsedSince();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `isValid()` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${ priorState } -> ${ newState }`);\n    }\n    this.#changedAt = elapsedSince();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.isDone(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { elapsedMillisecondsAbsolute } from '@ixfx/flow';\nimport { adsrStateTransitions } from './Types.js';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\nexport const defaultAdsrTimingOpts = Object.freeze({\n    attackDuration: 600,\n    decayDuration: 200,\n    releaseDuration: 800,\n    shouldLoop: false\n});\n/**\n * Base class for an ADSR envelope.\n *\n * It outputs values on a scale of 0..1 corresponding to each phase.\n */\nexport class AdsrBase extends SimpleEventEmitter {\n    #sm;\n    #timeSource;\n    #timer;\n    #holding;\n    #holdingInitial;\n    #disposed = false;\n    #triggered = false;\n    attackDuration;\n    decayDuration;\n    releaseDuration;\n    decayDurationTotal;\n    /**\n     * If _true_ envelope will loop\n     */\n    shouldLoop;\n    constructor(opts = {}) {\n        super();\n        this.attackDuration = opts.attackDuration ?? defaultAdsrTimingOpts.attackDuration;\n        this.decayDuration = opts.decayDuration ?? defaultAdsrTimingOpts.decayDuration;\n        this.releaseDuration = opts.releaseDuration ?? defaultAdsrTimingOpts.releaseDuration;\n        this.shouldLoop = opts.shouldLoop ?? defaultAdsrTimingOpts.shouldLoop;\n        this.#sm = new StateMachineWithEvents(adsrStateTransitions, { initial: `attack` });\n        this.#sm.addEventListener(`change`, (event) => {\n            // Reset timer on release\n            if (event.newState === `release` && this.#holdingInitial) {\n                this.#timer?.reset();\n            }\n            super.fireEvent(`change`, event);\n        });\n        this.#sm.addEventListener(`stop`, (event) => {\n            super.fireEvent(`complete`, event);\n        });\n        this.#timeSource = () => elapsedMillisecondsAbsolute();\n        this.#holding = this.#holdingInitial = false;\n        this.decayDurationTotal = this.attackDuration + this.decayDuration;\n    }\n    dispose() {\n        if (this.#disposed)\n            return;\n        this.#sm.dispose();\n    }\n    get isDisposed() {\n        return this.#disposed;\n    }\n    /**\n     * Changes state based on timer status\n     * @returns _True_ if state was changed\n     */\n    switchStateIfNeeded(allowLooping) {\n        if (this.#timer === undefined)\n            return false;\n        let elapsed = this.#timer.elapsed;\n        const wasHeld = this.#holdingInitial && !this.#holding;\n        // Change through states for as long as needed\n        let hasChanged = false;\n        //console.log(`AdsrBase.switchStateIfNeeded elapsed: ${ elapsed } wasHeld: ${ wasHeld }`);\n        let state = this.#sm.state;\n        do {\n            hasChanged = false;\n            state = this.#sm.state;\n            //console.log(`  AdsrBase.switchStateIfNeeded: ${ state }`);\n            switch (state) {\n                case `attack`: {\n                    if (elapsed > this.attackDuration || wasHeld) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `decay`: {\n                    if (elapsed > this.decayDurationTotal || wasHeld) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `sustain`: {\n                    if (!this.#holding || wasHeld) {\n                        elapsed = 0;\n                        this.#sm.next();\n                        this.#timer.reset();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `release`: {\n                    if (elapsed > this.releaseDuration) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `complete`: {\n                    if (this.shouldLoop && allowLooping) {\n                        this.trigger(this.#holdingInitial);\n                    }\n                }\n            }\n        } while (hasChanged && state !== `complete`);\n        return hasChanged;\n    }\n    /**\n     * Computes a stage's progress from 0-1\n     * @param allowStateChange\n     * @returns\n     */\n    computeRaw(allowStateChange = true, allowLooping = true) {\n        if (this.#timer === undefined) {\n            return [undefined, 0, this.#sm.state];\n        }\n        // Change state if necessary based on elapsed time\n        if (allowStateChange)\n            this.switchStateIfNeeded(allowLooping);\n        const previousStage = this.#sm.state;\n        const elapsed = this.#timer.elapsed;\n        let relative = 0;\n        const state = this.#sm.state;\n        switch (state) {\n            case `attack`: {\n                relative = elapsed / this.attackDuration;\n                break;\n            }\n            case `decay`: {\n                relative = (elapsed - this.attackDuration) / this.decayDuration;\n                break;\n            }\n            case `sustain`: {\n                relative = 1;\n                break;\n            }\n            case `release`: {\n                relative = Math.min(elapsed / this.releaseDuration, 1);\n                break;\n            }\n            case `complete`: {\n                return [`complete`, 1, previousStage];\n            }\n            default: {\n                throw new Error(`State machine in unknown state: ${state}`);\n            }\n        }\n        return [state, relative, previousStage];\n    }\n    /**\n     * Returns _true_ if envelope has finished\n     */\n    get isDone() {\n        return this.#sm.isDone;\n    }\n    onTrigger() {\n        /* no op */\n    }\n    /**\n     * Triggers envelope, optionally _holding_ it.\n     *\n     * If `hold` is _false_ (default), envelope will run through all stages,\n     * but sustain stage won't have an affect.\n     *\n     * If `hold` is _true_, it will run to, and stay at the sustain stage.\n     * Use {@link release} to later release the envelope.\n     *\n     * If event is already trigged it will be _retriggered_.\n     * Initial value depends on `opts.retrigger`\n     * * _false_ (default): envelope continues at current value.\n     * * _true_: envelope value resets to `opts.initialValue`.\n     *\n     * @param hold If _true_ envelope will hold at sustain stage\n     */\n    trigger(hold = false) {\n        this.onTrigger();\n        this.#triggered = true;\n        this.#sm.reset();\n        this.#timer = this.#timeSource();\n        this.#holding = hold;\n        this.#holdingInitial = hold;\n    }\n    get hasTriggered() {\n        return this.#triggered;\n    }\n    compute() {\n        /* no-op */\n    }\n    /**\n     * Release if 'trigger(true)' was previouslly called.\n     * Has no effect if not triggered or held.\n     * @returns\n     */\n    release() {\n        if (this.isDone || !this.#holdingInitial)\n            return; // Was never holding or done\n        // Setting holding flag to false, computeRaw will change state\n        this.#holding = false;\n        this.compute();\n    }\n}\n","import { Paths, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\nimport { AdsrBase } from './AdsrBase.js';\nexport const defaultAdsrOpts = Object.freeze({\n    attackBend: -1,\n    decayBend: -0.3,\n    releaseBend: -0.3,\n    peakLevel: 1,\n    initialLevel: 0,\n    sustainLevel: 0.6,\n    releaseLevel: 0,\n    retrigger: false\n});\nexport class AdsrIterator {\n    adsr;\n    constructor(adsr) {\n        this.adsr = adsr;\n    }\n    next(...args) {\n        if (!this.adsr.hasTriggered) {\n            this.adsr.trigger();\n        }\n        const c = this.adsr.compute();\n        return {\n            value: c[1],\n            done: c[0] === `complete`\n        };\n    }\n    get [Symbol.toStringTag]() {\n        return `Generator`;\n    }\n}\n/**\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\n * usually in response to an intial trigger.\n *\n * [See the ixfx Guide on Envelopes](https://ixfx.fun/modulation/envelopes/introduction/).\n *\n * @example Setup\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * const env = new Envelopes.Adsr({\n *  attackDuration: 1000,\n *  decayDuration: 200,\n *  sustainDuration: 100\n * });\n * ```\n *\n * Options for envelope are as follows:\n *\n * ```js\n * initialLevel?: number\n * attackBend: number\n * attackDuration: number\n * decayBend: number\n * decayDuration:number\n * sustainLevel: number\n * releaseBend: number\n * releaseDuration: number\n * releaseLevel?: number\n * peakLevel: number\n * retrigger?: boolean\n * shouldLoop: boolean\n * ```\n *\n * If `retrigger` is _false_ (default), a re-triggered envelope continues at current value\n * rather than resetting to `initialLevel`.\n *\n * If `shouldLoop` is true, envelope loops until `release()` is called.\n *\n * @example Using\n * ```js\n * env.trigger(); // Start envelope\n * ...\n * // Get current value of envelope\n * const [state, scaled, raw] = env.compute();\n * ```\n *\n * * `state` is a string, one of the following: 'attack', 'decay', 'sustain', 'release', 'complete'\n * * `scaled` is a value scaled according to the stage's _levels_\n * * `raw` is the progress from 0 to 1 within a stage. ie. 0.5 means we're halfway through a stage.\n *\n * Instead of `compute()`, most usage of the envelope is just fetching the `value` property, which returns the same scaled value of `compute()`:\n *\n * ```js\n * const value = env.value; // Get scaled number\n * ```\n *\n * @example Hold & release\n * ```js\n * env.trigger(true);   // Pass in true to hold\n * ...envelope will stop at sustain stage...\n * env.release();      // Release into decay\n * ```\n *\n * Check if it's done:\n *\n * ```js\n * env.isDone; // True if envelope is completed\n * ```\n *\n * Envelope has events to track activity: 'change' and 'complete':\n *\n * ```\n * env.addEventListener(`change`, ev => {\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\n * })\n * ```\n *\n * It's also possible to iterate over the values of the envelope:\n * ```js\n * const env = new Envelopes.Adsr();\n * for await (const v of env) {\n *  // v is the numeric value\n *  await Flow.sleep(100); // Want to pause a little to give envelope time to run\n * }\n * // Envelope has finished\n * ```\n */\nexport class Adsr extends AdsrBase {\n    attackPath;\n    decayPath;\n    releasePath;\n    initialLevel;\n    peakLevel;\n    releaseLevel;\n    sustainLevel;\n    attackBend;\n    decayBend;\n    releaseBend;\n    initialLevelOverride;\n    retrigger;\n    releasedAt;\n    constructor(opts = {}) {\n        super(opts);\n        this.retrigger = opts.retrigger ?? defaultAdsrOpts.retrigger;\n        this.initialLevel = opts.initialLevel ?? defaultAdsrOpts.initialLevel;\n        this.peakLevel = opts.peakLevel ?? defaultAdsrOpts.peakLevel;\n        this.releaseLevel = opts.releaseLevel ?? defaultAdsrOpts.releaseLevel;\n        this.sustainLevel = opts.sustainLevel ?? defaultAdsrOpts.sustainLevel;\n        this.attackBend = opts.attackBend ?? defaultAdsrOpts.attackBend;\n        this.releaseBend = opts.releaseBend ?? defaultAdsrOpts.releaseBend;\n        this.decayBend = opts.decayBend ?? defaultAdsrOpts.decayBend;\n        const max = 1;\n        this.attackPath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.initialLevel }, { x: max, y: this.peakLevel }, -this.attackBend));\n        this.decayPath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.peakLevel }, { x: max, y: this.sustainLevel }, -this.decayBend));\n        this.releasePath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.sustainLevel }, { x: max, y: this.releaseLevel }, -this.releaseBend));\n    }\n    onTrigger() {\n        this.initialLevelOverride = undefined;\n        if (!this.retrigger) {\n            const [_stage, scaled, _raw] = this.compute(true, false);\n            //console.log(`Adsr stage: ${ _stage } scaled: ${ scaled } raw: ${ _raw }`);\n            if (!Number.isNaN(scaled) && scaled > 0) {\n                this.initialLevelOverride = scaled;\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return new AdsrIterator(this);\n    }\n    /**\n     * Returns the scaled value\n     * Same as .compute()[1]\n     */\n    get value() {\n        return this.compute(true)[1];\n    }\n    /**\n     * Compute value of envelope at this point in time.\n     *\n     * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\n     * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\n     */\n    compute(allowStateChange = true, allowLooping = true) {\n        const [stage, amt] = super.computeRaw(allowStateChange, allowLooping);\n        //console.log(`Adsr.compute: stage: ${ stage } amt: ${ amt }!`);\n        // Stage is undefined when envelope is complete or underlying timer is undefined\n        if (stage === undefined)\n            return [undefined, Number.NaN, Number.NaN];\n        let v;\n        switch (stage) {\n            case `attack`: {\n                v = this.attackPath.interpolate(amt).y;\n                if (this.initialLevelOverride !== undefined) {\n                    v = scale(v, 0, 1, this.initialLevelOverride, 1);\n                }\n                this.releasedAt = v;\n                break;\n            }\n            case `decay`: {\n                v = this.decayPath.interpolate(amt).y;\n                this.releasedAt = v;\n                break;\n            }\n            case `sustain`: {\n                v = this.sustainLevel;\n                this.releasedAt = v;\n                break;\n            }\n            case `release`: {\n                v = this.releasePath.interpolate(amt).y;\n                // Bound release level to the amp level that we released at.\n                // ie. when release happens before a stage completes\n                if (this.releasedAt !== undefined) {\n                    v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\n                }\n                break;\n            }\n            case `complete`: {\n                v = this.releaseLevel;\n                this.releasedAt = undefined;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown state: ${stage}`);\n            }\n        }\n        return [stage, v, amt];\n    }\n}\n","import { Adsr } from './Adsr.js';\nimport { resolveWithFallbackSync } from '@ixfx/core';\nimport { repeat } from '@ixfx/flow';\nexport * from './Types.js';\nexport * from './Adsr.js';\nexport * from './AdsrBase.js';\n/**\n * Returns a function that iterates over an envelope\n * ```js\n * const e = Envelopes.adsr();\n *\n * e(); // Yields current value\n * ```\n *\n * Starts the envelope the first time the return function is called.\n * When the envelope finishes, it continues to return the `releaseLevel` of the envelope.\n *\n * Options can be provided to set the shape of the envelope as usual, eg:\n * ```js\n * const e = Envelopes.adsr({\n *  attackDuration: 1000,\n *  releaseDuration: 500\n * });\n * ```\n * @param opts\n * @returns\n */\nexport const adsr = (opts = {}) => {\n    const envelope = new Adsr(opts);\n    const finalValue = envelope.releaseLevel;\n    const iterator = envelope[Symbol.iterator]();\n    return () => resolveWithFallbackSync(iterator, { overrideWithLast: true, value: finalValue });\n};\n/**\n * Creates and runs an envelope, sampling its values at `sampleRateMs`.\n * Note that if the envelope loops, iterator never returns.\n *\n * @example Init\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * import { IterableAsync } from  'https://unpkg.com/ixfx/dist/util.js';\n *\n * const opts = {\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * ```\n *\n * ```js\n * //  Add data to array\n * // Sample an envelope every 20ms into an array\n * const data = await IterableAsync.toArray(Envelopes.adsrIterable(opts, 20));\n * ```\n *\n * ```js\n * // Iterate with `for await`\n * // Work with values as sampled\n * for await (const v of Envelopes.adsrIterable(opts, 5)) {\n *  // Work with envelope value `v`...\n * }\n * ```\n * @param opts Envelope options\n * @returns\n */\nexport async function* adsrIterable(opts) {\n    const envelope = new Adsr(opts.env);\n    const sampleRateMs = opts.sampleRateMs ?? 100;\n    envelope.trigger();\n    const r = repeat(() => envelope.value, {\n        while: () => !envelope.isDone,\n        delay: sampleRateMs,\n        signal: opts.signal,\n    });\n    for await (const v of r) {\n        yield v;\n    }\n}\n","import { resultThrow, integerTest } from \"@ixfx/guards\";\n/**\n * Returns a function which cycles between 0..1 (inclusive of 0 and 1).\n * `totalTicks` is how many ticks it takes to get to 1. Since we want an inclusive 0 & 1,\n * the total ticks is actually +1.\n *\n * Ie. if totalTicks = 10, we get: 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\n *\n * Use 'exclusiveStart' and 'exclusiveEnd' flags to shift range. Eg, with `totalTicks` of 10:\n * * 'exclusiveStart:true': first value is 0.1, last value is 1.0 (10 values total)\n * * 'exclusiveEnd:true': first value is 0, last value is 0.9 (10 values total)\n * * If both are true, first value is 0.1, last value is 0.9 (9 values total)\n * * If both are false (or not set), we get the case described earlier, first value is 0, last value is 1 (11 values total)\n *\n * Other examples:\n * * totalTicks: 20, value goes up by 0.05\n * * totalTicks: 1, value goes up by 1\n * @param totalTicks Positive, integer value. How many ticks to complete a cycle\n * @param options\n * @returns\n */\nexport function ticks(totalTicks, options = {}) {\n    resultThrow(integerTest(totalTicks, `aboveZero`, `totalTicks`));\n    const exclusiveStart = options.exclusiveStart ?? false;\n    const exclusiveEnd = options.exclusiveEnd ?? false;\n    const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n    const startPoint = exclusiveStart ? 1 : 0;\n    const endPoint = exclusiveEnd ? totalTicks - 1 : totalTicks;\n    let cycleCount = 0;\n    let v = options.startAt ?? startPoint;\n    if (options.startAtRelative) {\n        let totalTicksForReal = totalTicks;\n        if (exclusiveStart)\n            totalTicksForReal--;\n        if (exclusiveEnd)\n            totalTicksForReal--;\n        v = Math.round(options.startAtRelative * totalTicksForReal);\n    }\n    return (feedback) => {\n        if (feedback) {\n            if (feedback.resetAt !== undefined) {\n                v = feedback.resetAt;\n            }\n            if (feedback.resetAtRelative !== undefined) {\n                v = Math.floor(feedback.resetAtRelative * totalTicks);\n            }\n        }\n        if (cycleCount >= cycleLimit)\n            return 1;\n        const current = v / totalTicks;\n        v++;\n        if (v > endPoint) {\n            cycleCount++;\n            v = startPoint;\n        }\n        return current;\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns the percentage of time toward `interval`. See also: {@link bpm}, {@link hertz} which are the same but\n * using different units for time.\n *\n * By default, it continues forever, cycling from 0..1 repeatedly for each interval. Use\n * `cycleLimit` to restrict this. A value of 1 means it won't loop.\n *\n * The starting 'position' is `performance.now()`. If `startAt` option is provided, this will be used instead.\n * It probably should be an offset of `performance.now()`, eg: `{ startAt: performance.now() - 500 }` to shift\n * the cycle by 500ms.\n *\n * When using `startAtRelative`, the starting position will be set backward by the relative amount. A value\n * of 0.5, for example, will set the timer back 50% of the interval, meaning the cycle will start half way through.\n *\n * @param interval\n * @param options\n * @returns\n */\nexport function elapsed(interval, options = {}) {\n    const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n    const limitValue = 1;\n    let start = options.startAt ?? performance.now();\n    let cycleCount = 0;\n    const intervalMs = intervalToMs(interval, 1000);\n    if (options.startAtRelative) {\n        resultThrow(numberTest(options.startAtRelative, `percentage`, `startAtRelative`));\n        start = performance.now() - (intervalMs * options.startAtRelative);\n    }\n    //let stopAt = cycleLimit > 0 ? (intervalMs + start) : Number.MAX_SAFE_INTEGER;\n    return (feedback) => {\n        if (feedback) {\n            if (feedback.resetAt !== undefined) {\n                start = feedback.resetAt;\n                if (start === 0)\n                    start = performance.now();\n            }\n            if (feedback.resetAtRelative !== undefined) {\n                resultThrow(numberTest(feedback.resetAtRelative, `percentage`, `resetAtRelative`));\n                start = performance.now() - (intervalMs * feedback.resetAtRelative);\n            }\n        }\n        if (cycleCount >= cycleLimit)\n            return limitValue;\n        const now = performance.now();\n        const elapsedCycle = now - start;\n        if (elapsedCycle >= intervalMs) {\n            cycleCount += Math.floor(elapsedCycle / intervalMs);\n            start = now;\n            if (cycleCount >= cycleLimit)\n                return limitValue;\n        }\n        return (elapsedCycle % intervalMs) / intervalMs;\n    };\n    // } else {\n    //   return () => ((performance.now() - start) % intervalMs) / intervalMs;\n    // }\n}\n/**\n * Counts beats based on a BPM.\n * Uses {@link elapsed} internally.\n * @param bpm\n * @param options\n * @returns\n */\nexport function bpm(bpm, options = {}) {\n    const interval = (60 * 1000) / bpm; // milliseconds between beats.\n    return elapsed(interval, options);\n}\n/**\n * Counts based on hertz (oscillations per second).\n * Uses {@link elapsed} internally.\n * @param hz\n * @param options\n * @returns\n */\nexport function hertz(hz, options = {}) {\n    const interval = 1000 / hz;\n    return elapsed(interval, options);\n}\n","/**\n * Returns a proportion of `amount` depending on elapsed time.\n * Cumulatively, `amount` is yielded every second.\n *\n * ```js\n * // Calculate a proportion of 0.1 every second\n * const x = perSecond(0.1);\n * x();\n * ```\n *\n * The faster `x()` is called, the smaller the chunks of `amount` are returned.\n * Values accumulate. For example, `x()` isn't called for two seconds, 2*amount is returned.\n *\n * @example Usage\n * ```js\n * const settings = {\n *  ageMod: perSecond(0.1);\n * };\n *\n * let state = {\n *  age: 1\n * };\n *\n * // Update\n * setInterval(() => {\n *  let { age } = state;\n *  // Add 0.1 per second, regardless of\n *  // loop speed\n *  age += settings.ageMod();\n *  state = {\n *    ...state,\n *    age: clamp(age)\n *  }\n * });\n * ```\n *\n * Use the `clamp` option so the returned value never exceeds `amount`.\n * Alternatively, `min`/`max` options allow you to set arbitrary limits.\n * @param amount\n * @returns\n */\nexport const perSecond = (amount, options = {}) => {\n    const perMilli = amount / 1000;\n    let min = options.min ?? Number.MIN_SAFE_INTEGER;\n    let max = options.max ?? Number.MAX_SAFE_INTEGER;\n    const clamp = options.clamp ?? false;\n    if (clamp && options.max)\n        throw new Error(`Use either 'max' or 'clamp', not both.`);\n    if (clamp)\n        max = amount;\n    let called = performance.now();\n    return () => {\n        const now = performance.now();\n        const elapsed = now - called;\n        called = now;\n        const x = perMilli * elapsed;\n        if (x > max)\n            return max;\n        if (x < min)\n            return min;\n        return x;\n    };\n};\n/**\n * As {@link perSecond}, but per minute.\n * @param amount\n * @param options\n * @returns\n */\nexport const perMinute = (amount, options = {}) => {\n    return perSecond(amount / 60, options);\n};\n","export * from './ticks.js';\nexport * from './time.js';\nexport * from './per-second.js';\n","/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @returns Value\n */\nexport const cubicBezierShape = (b, d) => (t) => {\n    const s = 1 - t;\n    const s2 = s * s;\n    const t2 = t * t;\n    const t3 = t2 * t;\n    return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n};\n","/**\n * WIP\n * Returns a {@link Drifter} that moves a value over time.\n *\n * It keeps track of how much time has elapsed, accumulating `driftAmtPerMs`.\n * The accumulated drift is wrapped on a 0..1 scale.\n * ```js\n * // Set up the drifer\n * const d = drif(0.001);\n *\n * d.update(1.0);\n * // Returns 1.0 + accumulated drift\n * ```\n * @param driftAmtPerMs\n * @returns\n */\nexport const drift = (driftAmtPerMs) => {\n    //eslint-disable-next-line functional/no-let\n    let lastChange = performance.now();\n    const update = (v = 1) => {\n        const elapsed = performance.now() - lastChange;\n        const amt = (driftAmtPerMs * elapsed) % 1;\n        lastChange = performance.now();\n        const calc = (v + amt) % 1;\n        return calc;\n    };\n    const reset = () => {\n        lastChange = performance.now();\n    };\n    return { update, reset };\n};\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n    //const a = 1 / sqrt(2 * pi);\n    const mean = 0.5;\n    return (t) => {\n        const f = gaussianA / standardDeviation;\n        // p:-8 pinched\n        let p = -2.5; // -1/1.25;\n        let c = (t - mean) / standardDeviation;\n        c *= c;\n        p *= c;\n        const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n        if (v > 1)\n            return 1;\n        if (v < 0)\n            return 0;\n        return v;\n    };\n};\n","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\nexport const bounceOut = (x) => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (x < 1 / d1) {\n        return n1 * x * x;\n    }\n    else if (x < 2 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    }\n    else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    }\n    else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n    }\n};\nexport const quintIn = (x) => x * x * x * x * x;\nexport const quintOut = (x) => 1 - pow(1 - x, 5);\nexport const arch = (x) => x * (1 - x) * 4;\nexport const smoothstep = (x) => x * x * (3 - 2 * x);\nexport const smootherstep = (x) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x) => sin((x * pi) / 2);\nexport const quadIn = (x) => x * x;\nexport const quadOut = (x) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x) => x * x * x;\nexport const cubicOut = (x) => 1 - pow(1 - x, 3);\nexport const quartIn = (x) => x * x * x * x;\nexport const quartOut = (x) => 1 - pow(1 - x, 4);\nexport const expoIn = (x) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x) => x === 0\n    ? 0\n    : x === 1\n        ? 1\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : x < 0.5\n            ? pow(2, 20 * x - 10) / 2\n            : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x) => x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\nexport const backInOut = (x) => {\n    const c1 = 1.701_58;\n    const c2 = c1 * 1.525;\n    return x < 0.5\n        ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n        : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\nexport const bounceIn = (x) => 1 - bounceOut(1 - x);\nexport const bell = gaussian();\nexport const elasticInOut = (x) => {\n    const c5 = (2 * pi) / 4.5;\n    return x === 0\n        ? 0\n        : x === 1\n            ? 1\n            // eslint-disable-next-line unicorn/no-nested-ternary\n            : x < 0.5\n                ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n                : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import { Points, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns\n */\nexport const line = (bend = 0, warp = 0) => {\n    const max = 1;\n    const cubicB = {\n        x: scale(bend, -1, 1, 0, max),\n        y: scale(bend, -1, 1, max, 0),\n    };\n    // Add in bend as 'drive'\n    let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n    // Warp\n    if (bend !== 0 && warp > 0) {\n        if (bend > 0) {\n            cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n        }\n        else {\n            cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n        }\n    }\n    const bzr = Beziers.cubic(Points.Empty, Points.Unit, cubicA, cubicB);\n    const inter = Beziers.interpolator(bzr);\n    return (value) => inter(value);\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport * as Flow from '@ixfx/flow';\nimport { functionTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns\n */\nexport const time = (fn, duration) => {\n    resultThrow(functionTest(fn, `fn`));\n    let relative;\n    return () => {\n        if (typeof relative === `undefined`)\n            relative = Flow.ofTotal(duration, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n *\n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (fn, duration) => {\n    resultThrow(functionTest(fn, `fn`));\n    const timer = Flow.elapsedMillisecondsAbsolute();\n    const durationMs = intervalToMs(duration);\n    if (durationMs === undefined)\n        throw new Error(`Param 'duration' not provided`);\n    const relativeTimer = Flow.relative(durationMs, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (fn, totalTicks) => {\n    resultThrow(functionTest(fn, `fn`));\n    let relative;\n    return () => {\n        if (typeof relative === `undefined`)\n            relative = Flow.ofTotalTicks(totalTicks, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on ticks.\n *\n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (fn, durationTicks) => {\n    resultThrow(functionTest(fn, `fn`));\n    const timer = Flow.elapsedTicksAbsolute();\n    const relativeTimer = Flow.relative(durationTicks, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n","import * as Named from './easings-named.js';\nimport { stringTest, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nimport * as ModuleTimed from '../modulator-timed.js';\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({\n *  duration: 1000,\n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options\n * @returns\n */\nexport const create = (options) => {\n    const name = resolveEasingName(options.name ?? `quintIn`);\n    const fn = name ?? options.fn;\n    if (typeof fn === `undefined`)\n        throw new Error(`Either 'name' or 'fn' must be set`);\n    if (`duration` in options) {\n        return time(fn, options.duration);\n    }\n    else if (`ticks` in options) {\n        return ticks(fn, options.ticks);\n    }\n    else {\n        throw new Error(`Expected 'duration' or 'ticks' in options`);\n    }\n};\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n *\n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n *\n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n *\n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.timeModulator(fn, duration);\n    // const timer = Timer.elapsedMillisecondsAbsolute();\n    // const durationMs = intervalToMs(duration);\n    // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n    // const relativeTimer = Timer.relative(\n    //   durationMs,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns\n */\nexport const time = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.time(fn, duration);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (nameOrFunction, totalTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.ticks(fn, totalTicks);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Creates an easing based on ticks.\n *\n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (nameOrFunction, durationTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.tickModulator(fn, durationTicks);\n    // const timer = Timer.elapsedTicksAbsolute();\n    // const relativeTimer = Timer.relative(\n    //   durationTicks,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\nconst resolveEasingName = (nameOrFunction) => {\n    const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n    if (typeof fn === `undefined`) {\n        const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${nameOrFunction}'`) : new Error(`Easing function not found`);\n        throw error;\n    }\n    return fn;\n};\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\nlet easingsMap;\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName) {\n    resultThrow(stringTest(easingName, `non-empty`, `easingName`));\n    const found = cacheEasings().get(easingName.toLowerCase());\n    if (found === undefined)\n        throw new Error(`Easing not found: '${easingName}'`);\n    return found;\n};\n// Cache named easings\nfunction cacheEasings() {\n    if (easingsMap === undefined) {\n        easingsMap = new Map();\n        for (const [k, v] of Object.entries(Named)) {\n            easingsMap.set(k.toLowerCase(), v);\n        }\n        return easingsMap;\n    }\n    else\n        return easingsMap;\n}\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames() {\n    const map = cacheEasings();\n    yield* map.keys();\n}\n;\n","/**\n * Acknowledgements: much of the work here is an adapation from Daniel Shiffman's excellent _The Nature of Code_ website.\n */\nimport { Points, Polar, Rects } from '@ixfx/geometry';\nimport { clamp } from '@ixfx/numbers';\nimport { interpolateAngle } from '@ixfx/numbers';\n/**\n * Throws an error if `t` is not of the `ForceAffected` shape.\n * @param t\n * @param name\n */\nexport const guard = (t, name = `t`) => {\n    if (t === undefined) {\n        throw new Error(`Parameter ${name} is undefined. Expected ForceAffected`);\n    }\n    if (t === null) {\n        throw new Error(`Parameter ${name} is null. Expected ForceAffected`);\n    }\n    if (typeof t !== `object`) {\n        throw new TypeError(`Parameter ${name} is type ${typeof t}. Expected object of shape ForceAffected`);\n    }\n};\n/**\n * `constrainBounce` yields a function that affects `t`'s position and velocity such that it\n * bounces within bounds.\n *\n * ```js\n * // Setup bounce with area constraints\n * // Reduce velocity by 10% with each impact\n * const b = constrainBounce({ width:200, height:500 }, 0.9);\n *\n * // Thing\n * const t = {\n *  position: { x: 50,  y: 50 },\n *  velocity: { x: 0.3, y: 0.01 }\n * };\n *\n * // `b` returns an altereted version of `t`, with the\n * // bounce logic applied.\n * const bounced = b(t);\n * ```\n *\n * `dampen` parameter allows velocity to be dampened with each bounce. A value\n * of 0.9 for example reduces velocity by 10%. A value of 1.1 will increase velocity by\n * 10% with each bounce.\n * @param bounds Constraints of area\n * @param dampen How much to dampen velocity by. Defaults to 1 meaning there is no damping.\n * @returns A function that can perform bounce logic\n */\nexport const constrainBounce = (bounds, dampen = 1) => {\n    if (!bounds)\n        bounds = { width: 1, height: 1 };\n    const minX = Rects.getEdgeX(bounds, `left`);\n    const maxX = Rects.getEdgeX(bounds, `right`);\n    const minY = Rects.getEdgeY(bounds, `top`);\n    const maxY = Rects.getEdgeY(bounds, `bottom`);\n    return (t) => {\n        const position = computePositionFromVelocity(t.position ?? Points.Empty, t.velocity ?? Points.Empty);\n        let velocity = t.velocity ?? Points.Empty;\n        let { x, y } = position;\n        if (x > maxX) {\n            x = maxX;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n        }\n        else if (x < minX) {\n            x = minX;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n        }\n        if (y > maxY) {\n            y = maxY;\n            velocity = Points.multiplyScalar(Points.invert(velocity, `y`), dampen);\n        }\n        else if (position.y < minY) {\n            y = minY;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `y`);\n        }\n        return Object.freeze({\n            ...t,\n            position: { x, y },\n            velocity,\n        });\n    };\n};\n/**\n * For a given set of attractors, returns a function that a sets acceleration of attractee.\n * Keep note though that this bakes-in the values of the attractor, it won't reflect changes to their state. For dynamic\n * attractors, it might be easier to use `computeAttractionForce`.\n *\n * @example Force\n * ```js\n * const f = Forces.attractionForce(sun, gravity);\n * earth = Forces.apply(earth, f);\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n * @param attractors\n * @param gravity\n * @param distanceRange\n * @returns\n */\nexport const attractionForce = (attractors, gravity, distanceRange = {}) => (attractee) => {\n    let accel = attractee.acceleration ?? Points.Empty;\n    for (const a of attractors) {\n        if (a === attractee)\n            continue;\n        const f = computeAttractionForce(a, attractee, gravity, distanceRange);\n        accel = Points.sum(accel, f);\n    }\n    return {\n        ...attractee,\n        acceleration: accel,\n    };\n};\n/**\n * Computes the attraction force between two things.\n * Value for `gravity` will depend on what range is used for `mass`. It's probably a good idea\n * to keep mass to mean something relative - ie 1 is 'full' mass, and adjust the `gravity`\n * value until it behaves as you like. Keeping mass in 0..1 range makes it easier to apply to\n * visual properties later.\n *\n * @example Attractee and attractor, gravity 0.005\n * ```js\n * const attractor = { position: { x:0.5, y:0.5 }, mass: 1 };\n * const attractee = { position: Points.random(), mass: 0.01 };\n * attractee = Forces.apply(attractee, Forces.computeAttractionForce(attractor, attractee, 0.005));\n * ```\n *\n * @example Many attractees for one attractor, gravity 0.005\n * ```js\n * attractor =  { position: { x:0.5, y:0.5 }, mass: 1 };\n * attractees = attractees.map(a => Forces.apply(a, Forces.computeAttractionForce(attractor, a, 0.005)));\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n *\n * `attractor` thing attracting (eg, earth)\n * `attractee` thing being attracted (eg. satellite)\n *\n *\n * `gravity` will have to be tweaked to taste.\n * `distanceRange` clamps the computed distance. This affects how tightly the particles will orbit and can also determine speed. By default it is 0.001-0.7\n * @param attractor Attractor (eg earth)\n * @param attractee Attractee (eg satellite)\n * @param gravity Gravity constant\n * @param distanceRange Min/max that distance is clamped to.\n * @returns\n */\nexport const computeAttractionForce = (attractor, attractee, gravity, distanceRange = {}) => {\n    if (attractor.position === undefined) {\n        throw new Error(`attractor.position not set`);\n    }\n    if (attractee.position === undefined) {\n        throw new Error(`attractee.position not set`);\n    }\n    const distributionRangeMin = distanceRange.min ?? 0.01;\n    const distributionRangeMax = distanceRange.max ?? 0.7;\n    // Vector between objects\n    const f = Points.normalise(Points.subtract(attractor.position, attractee.position));\n    // Distance\n    const d = clamp(Points.distance(f), distributionRangeMin, distributionRangeMax);\n    // Multiply vector by gravity, scaled by mass of things and distance\n    return Points.multiplyScalar(f, (gravity * (attractor.mass ?? 1) * (attractee.mass ?? 1)) / (d * d));\n};\n/**\n * A force that moves a thing toward `targetPos`.\n *\n * ```js\n * const t = Forces.apply(t, Forces.targetForce(targetPos));\n * ```\n * @param targetPos\n * @param opts\n * @returns\n */\nexport const targetForce = (targetPos, opts = {}) => {\n    const fn = (t) => {\n        const accel = computeAccelerationToTarget(targetPos, t.position ?? { x: 0.5, y: 0.5 }, opts);\n        return {\n            ...t,\n            acceleration: Points.sum(t.acceleration ?? Points.Empty, accel),\n        };\n    };\n    return fn;\n};\n/**\n * Returns `pt` with x and y set to `setpoint` if either's absolute value is below `v`\n * @param pt\n * @param v\n * @returns\n */\n// const roundTo = (pt: Point, v: number, setpoint: number): Point => {\n//   const x = Math.abs(pt.x);\n//   const y = Math.abs(pt.y);\n//   if (x < v && y < v) return { x: setpoint, y: setpoint };\n//   if (x < v) return { x: setpoint, y: pt.y };\n//   if (y < v) return { x: pt.x, y: setpoint };\n//   return pt;\n// };\n/**\n * Apply a series of force functions or forces to `t`. Null/undefined entries are skipped silently.\n * It also updates the velocity and position of the returned version of `t`.\n *\n * ```js\n * // Wind adds acceleration. Force is dampened by mass\n * const wind = Forces.accelerationForce({ x: 0.00001, y: 0 }, `dampen`);\n *\n * // Gravity adds acceleration. Force is magnified by mass\n * const gravity = Forces.accelerationForce({ x: 0, y: 0.0001 }, `multiply`);\n *\n * // Friction is calculated based on velocity. Force is magnified by mass\n * const friction = Forces.velocityForce(0.00001, `multiply`);\n *\n *  // Flip movement velocity if we hit a wall. And dampen it by 10%\n * const bouncer = Forces.constrainBounce({ width: 1, height: 1 }, 0.9);\n *\n * let t = {\n *  position: Points.random(),\n *  mass: 0.1\n * };\n *\n * // Apply list of forces, returning a new version of the thing\n * t = Forces.apply(t,\n *   gravity,\n *   wind,\n *   friction,\n *   bouncer\n * );\n * ```\n */\nexport const apply = (t, ...accelForces) => {\n    if (t === undefined)\n        throw new Error(`t parameter is undefined`);\n    for (const f of accelForces) {\n        if (f === null || f === undefined)\n            continue;\n        t = typeof f === `function` ? f(t) : {\n            ...t,\n            acceleration: Points.sum(t.acceleration ?? Points.Empty, f),\n        };\n    }\n    // Integate velocity from acceleration\n    const velo = computeVelocity(t.acceleration ?? Points.Empty, t.velocity ?? Points.Empty);\n    // Compute position\n    const pos = computePositionFromVelocity(t.position ?? Points.Empty, velo);\n    const ff = {\n        ...t,\n        position: pos,\n        velocity: velo,\n        // Clear accel, because it has been integrated into velocity\n        acceleration: Points.Empty,\n    };\n    return ff;\n};\n/**\n * Apples `vector` to acceleration, scaling according to mass, based on the `mass` option.\n * It returns a function which can later be applied to a thing.\n *\n * ```js\n * import { Forces } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * // Acceleration vector of (0.1, 0), ie moving straight on horizontal axis\n * const f = Forces.accelerationForce({ x:0.1, y:0 }, `dampen`);\n *\n * // Thing to move\n * let t = { position: ..., acceleration: ... }\n *\n * // Apply force\n * t = f(t);\n * ```\n * @param vector\n * @returns Force function\n */\nexport const accelerationForce = (vector, mass = `ignored`) => (t) => Object.freeze({\n    ...t,\n    acceleration: massApplyAccel(vector, t, mass), //Points.sum(t.acceleration ?? Points.Empty, op(t.mass ?? 1))\n});\n/**\n * Returns an acceleration vector with mass either dampening or multiplying it.\n * The passed-in `thing` is not modified.\n *\n * ```js\n * // Initial acceleration vector\n * const accel = { x: 0.1, y: 0};\n *\n * // Thing being moved\n * const thing = { mass: 0.5, position: ..., acceleration: ... }\n *\n * // New acceleration vector, affected by mass of `thing`\n * const accelWithMass = massApplyAccel(accel, thing, `dampen`);\n * ```\n * Mass of thing can be factored in, according to `mass` setting. Use `dampen`\n * to reduce acceleration with greater mass of thing. Use `multiply` to increase\n * the effect of acceleration with a greater mass of thing. `ignored` means\n * mass is not taken into account.\n *\n * If `t` has no mass, the `mass` setting is ignored.\n *\n * This function is used internally by the predefined forces.\n *\n * @param vector Vector force\n * @param thing Thing being affected\n * @param mass How to factor in mass of thing (default ignored)\n * @returns Acceleration vector\n */\nconst massApplyAccel = (vector, thing, mass = `ignored`) => {\n    let op;\n    switch (mass) {\n        case `dampen`: {\n            op = (mass) => Points.divide(vector, mass, mass);\n            break;\n        }\n        case `multiply`: {\n            op = (mass) => Points.multiply(vector, mass, mass);\n            break;\n        }\n        case `ignored`: {\n            op = (_mass) => vector;\n            break;\n        }\n        default: {\n            throw new Error(`Unknown 'mass' parameter '${mass}. Expected 'dampen', 'multiply' or 'ignored'`);\n        }\n    }\n    return Points.sum(thing.acceleration ?? Points.Empty, op(thing.mass ?? 1));\n    // if (t.mass) {\n    //   if (dampen) return Points.sum(t.acceleration ?? Points.Empty, Points.divide(v, t.mass ?? 1));\n    //   else return Points.sum(t.acceleration ?? Points.Empty, Points.multiply(v, t.mass ?? 1));\n    // }\n    // return v;\n};\n/**\n * A force based on the square of the thing's velocity.\n * It's like {@link velocityForce}, but here the velocity has a bigger impact.\n *\n * ```js\n * const thing = {\n *  position: { x: 0.5, y:0.5 },\n *  velocity: { x: 0.001, y:0 }\n * };\n * const drag = magnitudeForce(0.1);\n *\n * // Apply drag force to thing, returning result\n * const t = Forces.apply(thing, drag);\n * ```\n * @param force Force value\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const magnitudeForce = (force, mass = `ignored`) => (t) => {\n    if (t.velocity === undefined)\n        return t;\n    const mag = Points.distance(Points.normalise(t.velocity));\n    const magSq = force * mag * mag;\n    const vv = Points.multiplyScalar(Points.invert(t.velocity), magSq);\n    return Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vv, t, mass),\n    });\n};\n/**\n * Null force does nothing\n * @returns A force that does nothing\n */\nexport const nullForce = (t) => t;\n/**\n * Force calculated from velocity of object. Reads velocity and influences acceleration.\n *\n * ```js\n * let t = { position: Points.random(), mass: 0.1 };\n * const friction = velocityForce(0.1, `dampen`);\n *\n * // Apply force, updating position and velocity\n * t = Forces.apply(t, friction);\n * ```\n * @param force Force\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const velocityForce = (force, mass) => {\n    // Invert velocity and then multiply by force\n    const pipeline = Points.pipeline(\n    // Points.normalise,\n    Points.invert, (v) => Points.multiplyScalar(v, force));\n    return (t) => {\n        if (t.velocity === undefined)\n            return t;\n        // Apply pipeline\n        const v = pipeline(t.velocity);\n        return Object.freeze({\n            ...t,\n            acceleration: massApplyAccel(v, t, mass),\n        });\n    };\n};\n/**\n * Sets angle, angularVelocity and angularAcceleration based on\n *  angularAcceleration, angularVelocity, angle\n * @returns\n */\nexport const angularForce = () => (t) => {\n    const accumulator = t.angularAcceleration ?? 0;\n    const vel = t.angularVelocity ?? 0;\n    const angle = t.angle ?? 0;\n    const v = vel + accumulator;\n    const a = angle + v;\n    return Object.freeze({\n        ...t,\n        angle: a,\n        angularVelocity: v,\n        angularAcceleration: 0,\n    });\n};\n// export const positionFromAngleForce = () => (t:ForceAffected) => {\n//   return Object.freeze({\n//     ...t,\n//     position: computePositionFromAngle()\n//   });\n// };\n/**\n * Yields a force function that applies the thing's acceleration.x to its angular acceleration.\n * @param scaling Use this to scale the accel.x value. Defaults to 20 (ie accel.x*20). Adjust if rotation is too much or too little\n * @returns\n */\nexport const angleFromAccelerationForce = (scaling = 20) => (t) => {\n    const accel = t.acceleration ?? Points.Empty;\n    return Object.freeze({\n        ...t,\n        angularAcceleration: accel.x * scaling,\n    });\n};\n/**\n * Yields a force function that applies the thing's velocity to its angle.\n * This will mean it points in the direction of travel.\n * @param interpolateAmt If provided, the angle will be interpolated toward by this amount. Defaults to 1, no interpolation\n * @returns\n */\nexport const angleFromVelocityForce = (interpolateAmt = 1) => (t) => {\n    const a = Points.angleRadian(t.velocity ?? Points.Empty);\n    return Object.freeze({\n        ...t,\n        angle: interpolateAmt < 1\n            ? interpolateAngle(interpolateAmt, t.angle ?? 0, a)\n            : a,\n    });\n};\n/**\n * Spring force\n *\n *  * ```js\n * // End of spring that moves\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Anchored other end of spring\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const springForce = Forces.springForce(pinnedAt, 0.4);\n *\n * continuously(() => {\n *  // Apply force\n *  thing = Forces.apply(thing, springForce);\n * }).start();\n * ```\n * [Read more](https://www.joshwcomeau.com/animation/a-friendly-introduction-to-spring-physics/)\n *\n * @param pinnedAt Anchored end of the spring\n * @param restingLength Length of spring-at-rest (default: 0.5)\n * @param k Spring stiffness (default: 0.0002)\n * @param damping Damping factor to apply, so spring slows over time. (default: 0.995)\n * @returns\n */\nexport const springForce = (pinnedAt, restingLength = 0.5, k = 0.0002, damping = 0.999) => (t) => {\n    const direction = Points.subtract(t.position ?? Points.Empty, pinnedAt);\n    const mag = Points.distance(direction);\n    const stretch = Math.abs(restingLength - mag);\n    const f = Points.pipelineApply(direction, Points.normalise, (p) => Points.multiplyScalar(p, -k * stretch));\n    const accel = massApplyAccel(f, t, `dampen`);\n    const velo = computeVelocity(accel ?? Points.Empty, t.velocity ?? Points.Empty);\n    const veloDamped = Points.multiply(velo, damping, damping);\n    return {\n        ...t,\n        velocity: veloDamped,\n        acceleration: Points.Empty,\n    };\n};\n/**\n * The pendulum force swings something back and forth.\n *\n * ```js\n * // Swinger\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Position thing swings from (middle of screen)\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const pendulumForce = Forces.pendulumForce(pinnedAt, { length: 0.4 });\n *\n * continuously(() => {\n *  // Apply force\n *  // Returns a new thing with recalculated angularVelocity, angle and position.\n *  thing = Forces.apply(thing, pendulumForce);\n * }).start();\n * ```\n *\n * [Read more](https://natureofcode.com/book/chapter-3-oscillation/)\n *\n * @param pinnedAt Location to swing from (x:0.5, y:0.5 default)\n * @param opts Options\n * @returns\n */\nexport const pendulumForce = (pinnedAt, opts = {}) => (t) => {\n    if (!pinnedAt)\n        pinnedAt = { x: 0, y: 0 };\n    const length = opts.length ?? Points.distance(pinnedAt, t.position ?? Points.Empty);\n    const speed = opts.speed ?? 0.001;\n    const damping = opts.damping ?? 0.995;\n    let angle = t.angle;\n    if (angle === undefined) {\n        if (t.position) {\n            angle = Points.angleRadian(pinnedAt, t.position) - Math.PI / 2;\n        }\n        else {\n            angle = 0; // Position wherever\n        }\n    }\n    const accel = ((-1 * speed) / length) * Math.sin(angle);\n    const v = (t.angularVelocity ?? 0) + accel;\n    angle += v;\n    return Object.freeze({\n        angularVelocity: v * damping,\n        angle,\n        position: computePositionFromAngle(length, angle + Math.PI / 2, pinnedAt),\n    });\n};\n/**\n * Compute velocity based on acceleration and current velocity\n * @param acceleration Acceleration\n * @param velocity Velocity\n * @param velocityMax If specified, velocity will be capped at this value\n * @returns\n */\nexport const computeVelocity = (acceleration, velocity, velocityMax) => {\n    const p = Points.sum(velocity, acceleration);\n    return velocityMax === undefined ? p : Points.clampMagnitude(p, velocityMax);\n};\n/**\n * Returns the acceleration to get from `currentPos` to `targetPos`.\n *\n * @example Barebones usage:\n * ```js\n * const accel = Forces.computeAccelerationToTarget(targetPos, currentPos);\n * const vel = Forces.computeVelocity(accel, currentVelocity);\n *\n * // New position:\n * const pos = Points.sum(currentPos, vel);\n * ```\n *\n * @example Implementation:\n * ```js\n * const direction = Points.subtract(targetPos, currentPos);\n * const accel = Points.multiply(direction, diminishBy);\n * ```\n * @param currentPos Current position\n * @param targetPos Target position\n * @param opts Options\n * @returns\n */\nexport const computeAccelerationToTarget = (targetPos, currentPos, opts = {}) => {\n    const diminishBy = opts.diminishBy ?? 0.001;\n    // Compare to current position of thing to get vector direction\n    const direction = Points.subtract(targetPos, currentPos);\n    if (opts.range && // If direction is less than range, return { x: 0, y: 0}\n        Points.compare(Points.abs(direction), opts.range) === -2) {\n        return Points.Empty;\n    }\n    // Diminish vector to make a meaningful acceleration\n    return Points.multiplyScalar(direction, diminishBy);\n};\n/**\n * Compute a new position based on existing position and velocity vector\n * @param position Position Current position\n * @param velocity Velocity vector\n * @returns Point\n */\nexport const computePositionFromVelocity = (position, velocity) => Points.sum(position, velocity);\n/**\n * Compute a position based on distance and angle from origin\n * @param distance Distance from origin\n * @param angleRadians Angle, in radians from origin\n * @param origin Origin point\n * @returns Point\n */\nexport const computePositionFromAngle = (distance, angleRadians, origin) => Polar.toCartesian(distance, angleRadians, origin);\nconst _angularForce = angularForce();\nconst _angleFromAccelerationForce = angleFromAccelerationForce();\n/**\n * A force that orients things according to direction of travel.\n *\n * Under the hood, it applies:\n * * angularForce,\n * * angleFromAccelerationForce, and\n * * angleFromVelocityForce\n * @param interpolationAmt\n * @returns\n */\nexport const orientationForce = (interpolationAmt = 0.5) => {\n    const angleFromVel = angleFromVelocityForce(interpolationAmt);\n    return (t) => {\n        t = _angularForce(t);\n        t = _angleFromAccelerationForce(t);\n        t = angleFromVel(t);\n        return t;\n    };\n};\n","export const piPi = Math.PI * 2;\n","import { clamp, wrap } from \"@ixfx/numbers\";\nimport { ofTotal } from \"@ixfx/flow\";\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { get as getEasing } from './easing/index.js';\nimport { piPi } from \"./util/pi-pi.js\";\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n *\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        resultThrow(numberTest(_a, ``, `a`), numberTest(_b, ``, `b`), numberTest(_amt, ``, `amount`));\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.easing) {\n            const easer = getEasing(o.easing);\n            if (!easer)\n                throw new Error(`Easing function '${o.easing}' not found`);\n            amountProcess = easer;\n        }\n        else if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        resultThrow(numberTest(amount, ``, `amount`));\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n *\n * A function is returned, which when invoked yields a value between A..B.\n *\n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n *\n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n *\n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorInterval = (duration, a = 0, b = 1, options) => {\n    const durationProgression = ofTotal(duration, { clampValue: true });\n    return (retargetB, retargetA) => {\n        const amount = durationProgression();\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        return value;\n    };\n};\n","import { resultThrow, numberTest } from '@ixfx/guards';\nimport { clamp } from '@ixfx/numbers';\nimport { floatSource as randomFloatFunction, float as randomFloat } from '@ixfx/random';\n/**\n * Returns a {@link Jitterer} that works with absolute values,\n * ie. values outside of 0..1 range.\n *\n * Jitter amount is _absolute_, meaning a fixed value regardless of input value,\n * or _relative_, meaning it is scaled according to input value.\n *\n * ```js\n * // Jitter by -10 to +10 (absolute value: 10)\n * const j1 = jitterAbsolute({ absolute: 10 });\n * j1(100); // Produces range of 90...110\n *\n * // Jitter by -20 to +20 (relative value 20%)\n * const j2 = jitterAbsolute({ relative: 0.20 });\n * j2(100); // Produces a range of -80...120\n * ```\n *\n * The expected used case is calling `jitterAbsolute` to set up a jitterer\n * and then reusing it with different input values, as above with the `j1` and `j2`.\n *\n * However to use it 'one-off', just call the returned function immediately:\n * ```js\n * const v = jitterAbsolute({ absolute: 10 })(100); // v is in range of 90-110\n * ```\n *\n * When `clamped` is true, return value is clamped to 0...value.\n * That is, rather than the usual bipolar jittering, the jittering only goes below.\n * ```js\n * const j = jitterAbsolute({ absolute: 10, clamped: true })\n * j(100); // Produces range of 90-100\n * ```\n * @param options\n * @returns\n */\nexport const jitterAbsolute = (options) => {\n    const { relative, absolute } = options;\n    const clamped = options.clamped ?? false;\n    const source = options.source ?? Math.random;\n    if (absolute !== undefined) {\n        return (value) => {\n            const abs = (source() * absolute * 2) - absolute;\n            const valueNew = value + abs;\n            if (clamped)\n                return clamp(valueNew, 0, value);\n            return valueNew;\n        };\n    }\n    if (relative !== undefined) {\n        return (value) => {\n            const rel = value * relative;\n            const abs = (source() * rel * 2) - rel;\n            const valueNew = value + abs;\n            if (clamped)\n                return clamp(valueNew, 0, value);\n            return valueNew;\n        };\n    }\n    throw new Error(`Either absolute or relative fields expected`);\n};\n/**\n * Jitters `value` by the absolute `jitter` amount. Returns a function.\n *\n * All values should be on a 0..1 scale, and the return value is by default clamped to 0..1.\n * Pass `clamped:false` as an option to allow for arbitary ranges.\n *\n * `jitter` returns a function that calculates jitter. If you only need a one-off\n * jitter, you can immediately execute the returned function:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Compute 10% jitter of input 0.5\n * const value = jitter({ relative: 0.1 })(0.5);\n * ```\n *\n * However, if the returned jitter function is to be used again,\n * assign it to a variable:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * const myJitter = jitter({ absolute: 0.5 });\n *\n * // Jitter an input value 1.0\n * const value = myJitter(1);\n * ```\n *\n * A custom source for random numbers can be provided. Eg, use a weighted\n * random number generator:\n *\n * ```js\n * import { weighted } from 'https://unpkg.com/ixfx/dist/random.js';\n * jitter({ relative: 0.1, source: weighted });\n * ```\n *\n * Options\n * * clamped: If false, `value`s out of percentage range can be used and return value may be beyond percentage range. True by default\n * * random: Random source (default is Math.random)\n * @param options Options\n * @returns Function that performs jitter\n */\nexport const jitter = (options = {}) => {\n    const clamped = options.clamped ?? true;\n    let r = (_) => 0;\n    if (options.absolute !== undefined) {\n        resultThrow(numberTest(options.absolute, clamped ? `percentage` : `bipolar`, `opts.absolute`));\n        const absRand = randomFloatFunction({\n            min: -options.absolute,\n            max: options.absolute,\n            source: options.source,\n        });\n        r = (v) => v + absRand();\n    }\n    else if (options.relative === undefined) {\n        throw new TypeError(`Either absolute or relative jitter amount is required.`);\n    }\n    else {\n        const rel = options.relative ?? 0.1;\n        resultThrow(numberTest(rel, clamped ? `percentage` : `bipolar`, `opts.relative`));\n        r = (v) => v +\n            randomFloat({\n                min: -Math.abs(rel * v),\n                max: Math.abs(rel * v),\n                source: options.source,\n            });\n    }\n    const compute = (value) => {\n        resultThrow(numberTest(value, clamped ? `percentage` : `bipolar`, `value`));\n        let v = r(value);\n        if (clamped)\n            v = clamp(v);\n        return v;\n    };\n    return compute;\n};\n","import { interpolate } from \"@ixfx/numbers\";\n/**\n * Mixes in modulation. This is used when you want to\n * fold in a controllable amount of modulation.\n *\n * For example, we have a base value of 0.5 (50%) that we want to modulate\n * by 0.9 (90%). That is, reduce its value by 10%. `mix` allows us\n * to slowly ramp up to the fully modulated value.\n *\n * ```js\n * import { mix } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * // When 'amt' is 0, modulation doesn't affect value at all,\n * // original is returned\n * mix(0, 0.5, 0.9); // 0.5\n * // Mixing in 50% of modulation\n * mix(0.5, 0.5, 0.9); // 0.475\n * // All modulation applied, so now we get 90% of 0.5\n * mix(1, 0.5, 0.9); // 0.45 (ie. 90% of 0.5)\n * ```\n * @param amount Amount of modulation (0..1). 0 means modulation value has no effect\n * @param original Original value to modulate\n * @param modulation Modulation amount (0..1)\n * @returns\n */\nexport const mix = (amount, original, modulation) => {\n    const m = modulation * amount;\n    const base = (1 - amount) * original;\n    return base + (original * m);\n};\n/**\n * Returns a modulator that mixes between two modulation functions.\n * Both modulators are given the same input value.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Get a 50/50 mix of two easing functions\n * const mix = Easings.mix(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param balance Mix between a and b\n * @param a\n * @param b\n * @returns Numeric value\n */\nexport const mixModulators = (balance, a, b) => (amt) => interpolate(balance, a(amt), b(amt));\n/**\n * Returns a 'crossfader` function of two easing functions, synchronised with the progress through the easing.\n *\n * Example `amt` values:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of easingA, 20% of easingB, both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of easingA, 80% of easingB, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower values.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * Easings.crossFade(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param a Easing A\n * @param b Easing B\n * @returns Numeric value\n */\nexport const crossfade = (a, b) => {\n    return (amt) => {\n        const mixer = mixModulators(amt, a, b);\n        return mixer(amt);\n    };\n};\n","/**\n * A 'no-op' function. Returns the input value without modification.\n * Useful for when some default is needed\n * @param v\n * @returns\n */\nexport const noop = (v) => v;\n","import * as Flow from '@ixfx/flow';\nconst piPi = Math.PI * 2;\n/**\n * Sine oscillator.\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.sine(frequencyTimer(10));\n * const osc = Oscillators.sine(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n *\n * @example Saw/tri pinch\n * ```js\n * const v = Math.pow(osc.value, 2);\n * ```\n *\n * @example Saw/tri bulge\n * ```js\n * const v = Math.pow(osc.value, 0.5);\n * ```\n *\n */\nexport function* sine(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        // Rather than -1 to 1, we want 0 to 1\n        yield (Math.sin(timerOrFreq.elapsed * piPi) + 1) / 2;\n    }\n}\n/**\n * Bipolar sine (-1 to 1)\n * @param timerOrFreq\n */\nexport function* sineBipolar(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield Math.sin(timerOrFreq.elapsed * piPi);\n    }\n}\n/**\n * Triangle oscillator\n *\n * ```js\n * // Setup\n * const osc = triangle(Timers.frequencyTimer(0.1));\n * const osc = triangle(0.1);\n *\n * // Call whenver a value is needed\n * const v = osc.next().value;\n * ```\n */\nexport function* triangle(timerOrFreq) {\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        // elapsed is repeatedly 0->1\n        //eslint-disable-next-line functional/no-let\n        let v = timerOrFreq.elapsed;\n        // /2 = 0->0.5\n        if (v < 0.5) {\n            // Upward\n            v *= 2;\n        }\n        else {\n            // Downward\n            v = 2 - v * 2;\n        }\n        yield v;\n    }\n}\n/**\n * Saw oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.saw(Timers.frequencyTimer(0.1));\n *\n * // Or\n * const osc = Oscillators.saw(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n */\nexport function* saw(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield timerOrFreq.elapsed;\n    }\n}\n/**\n * Square oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n *\n * // Setup\n * const osc = Oscillators.square(Timers.frequencyTimer(0.1));\n * const osc = Oscillators.square(0.1);\n *\n * // Call whenever a value is needed\n * osc.next().value;\n * ```\n */\nexport function* square(timerOrFreq) {\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield timerOrFreq.elapsed < 0.5 ? 0 : 1;\n    }\n}\n","import { resultThrow, numberTest } from '@ixfx/guards';\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (interval = 0.1, lower, upper, start, rounding) {\n    if (typeof lower === `undefined`)\n        lower = 0;\n    if (typeof upper === `undefined`)\n        upper = 1;\n    if (typeof start === `undefined`)\n        start = lower;\n    resultThrow(numberTest(interval, `bipolar`, `interval`), numberTest(upper, `bipolar`, `end`), numberTest(start, `bipolar`, `offset`), numberTest(lower, `bipolar`, `start`));\n    return pingPong(interval, lower, upper, start, rounding);\n};\n/**\n * Ping-pongs continually back and forth a `lower` and `upper` value (both inclusive) by a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (interval, lower, upper, start, rounding) {\n    if (lower === undefined)\n        throw new Error(`Parameter 'lower' is undefined`);\n    if (interval === undefined) {\n        throw new Error(`Parameter 'interval' is undefined`);\n    }\n    if (upper === undefined)\n        throw new Error(`Parameter 'upper' is undefined`);\n    if (rounding === undefined && interval <= 1 && interval >= 0) {\n        rounding = 10 / interval;\n    }\n    else if (typeof rounding === `undefined`)\n        rounding = 1234;\n    if (Number.isNaN(interval))\n        throw new Error(`interval parameter is NaN`);\n    if (Number.isNaN(lower))\n        throw new Error(`lower parameter is NaN`);\n    if (Number.isNaN(upper))\n        throw new Error(`upper parameter is NaN`);\n    if (Number.isNaN(start))\n        throw new Error(`upper parameter is NaN`);\n    if (lower >= upper)\n        throw new Error(`lower must be less than upper`);\n    if (interval === 0)\n        throw new Error(`Interval cannot be zero`);\n    const distance = upper - lower;\n    if (Math.abs(interval) >= distance) {\n        throw new Error(`Interval should be between -${distance} and ${distance}`);\n    }\n    let incrementing = interval > 0;\n    // Scale up values by rounding factor\n    upper = Math.floor(upper * rounding);\n    lower = Math.floor(lower * rounding);\n    interval = Math.floor(Math.abs(interval * rounding));\n    if (interval === 0) {\n        throw new Error(`Interval is zero (rounding: ${rounding})`);\n    }\n    start = start === undefined ? lower : Math.floor(start * rounding);\n    if (start > upper || start < lower) {\n        throw new Error(`Start (${start / rounding}) must be within lower (${lower / rounding}) and upper (${upper / rounding})`);\n    }\n    let v = start;\n    yield v / rounding;\n    let firstLoop = true;\n    while (true) {\n        v = v + (incrementing ? interval : -interval);\n        if (incrementing && v >= upper) {\n            incrementing = false;\n            v = upper;\n            if (v === upper && firstLoop) {\n                // Edge case where we start at upper bound and increment\n                v = lower;\n                incrementing = true;\n            }\n        }\n        else if (!incrementing && v <= lower) {\n            incrementing = true;\n            v = lower;\n            if (v === lower && firstLoop) {\n                // Edge case where we start at lower bound and decrement\n                v = upper;\n                incrementing = false;\n            }\n        }\n        yield v / rounding;\n        firstLoop = false;\n    }\n};\n","import * as Flow from '@ixfx/flow';\n/**\n * Produces values according to rough spring physics.\n * ```js\n * import { continuously } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n *\n * const s = spring();\n *\n * continuously(() => {\n *  const result = s.next();\n *  if (result.done) return false; // Exit loop\n *  const value = result.value;\n *  // Value is mostly within 0..1 range but will exceed these limits\n * }, 10).start();\n * ```\n *\n * Parameters to the spring can be provided.\n * ```js\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = spring({\n *  mass: 5,\n *  damping: 10\n *  stiffness: 100\n * });\n * ```\n *\n * If you don't want to use a generator: {@link springValue}.\n *\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n *\n * @param opts Options for spring\n * @param timerOrFreq Timer to use, or frequency\n */\nexport function* spring(opts = {}, timerOrFreq) {\n    if (timerOrFreq === undefined)\n        timerOrFreq = Flow.elapsedMillisecondsAbsolute();\n    else if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    const fn = springShape(opts);\n    // Give it some iterations to settle\n    let doneCountdown = opts.countdown ?? 10;\n    while (doneCountdown > 0) {\n        const s = fn(timerOrFreq.elapsed / 1000);\n        yield s;\n        if (s === 1) {\n            doneCountdown--;\n        }\n        else {\n            doneCountdown = 100;\n        }\n    }\n}\n/**\n * The same as {@link spring} but instead of a generator we get\n * a value. When the spring is done, 1 is returned instead of undefined.\n *\n * ```js\n * import { springValue } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = springValue();\n * s(); // 0..1 (roughly - exceeding 1 is possible)\n * ```\n *\n * Options can be provided:\n * ```js\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = springValue({\n *  stiffness: 100,\n *  damping: 10\n * })\n * ```\n * @example Applied\n * ```js\n * import { Modulation, Data } from  \"https://unpkg.com/ixfx/dist/bundle.js\"\n * let state = {\n *  spring: Modulation.springValue()\n * }\n *\n * function loop() {\n *  const d = Data.resolveFields(state);\n *\n *  // Apply calculated spring value to compute x value\n *  const x = window.innerWidth * d.spring;\n *\n *\n *  window.requestAnimationFrame(loop);\n * }\n * loop();\n * ```\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n *\n * @param opts\n * @param timerOrFreq\n * @returns\n */\nexport function springValue(opts = {}, timerOrFreq) {\n    const s = spring(opts, timerOrFreq);\n    return () => {\n        const v = s.next();\n        if (v.done)\n            return 1;\n        return v.value;\n    };\n}\n/**\n * Spring-dynamics modulator.\n * To have spring driven by time or ticks, use {@link spring} or {@link springValue}.\n * This is a lower-level function.\n * @param opts\n * @returns\n */\nexport const springShape = (opts = {}) => {\n    /** MIT License github.com/pushkine/ */\n    const from = 0;\n    const to = 1;\n    const mass = opts.mass ?? 1;\n    const stiffness = opts.stiffness ?? 100;\n    const soft = opts.soft ?? false;\n    const damping = opts.damping ?? 10;\n    const velocity = opts.velocity ?? 0.1;\n    const delta = to - from;\n    if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n        const angularFrequency = -Math.sqrt(stiffness / mass);\n        const leftover = -angularFrequency * delta - velocity;\n        return (t) => to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n    }\n    else {\n        const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n        const leftover = (damping * delta - 2 * mass * velocity) / dampingFrequency;\n        const dfm = (0.5 * dampingFrequency) / mass;\n        const dm = -(0.5 * damping) / mass;\n        return (t) => to -\n            (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n                Math.E ** (t * dm);\n    }\n};\n","import * as TimeSources from './source/time.js';\n/**\n * A factory function for creating a timing source. It returns\n * a function which creates a designated timer.\n *\n * This is useful in times where you need to recreate timers, eg for reset\n * type of behaviours because the options for the timer to be\n * consolidated in one place.\n *\n * ```js\n * // Get a factory for an elapsed timer\n * const factory = sources(`elapsed`, 1000);\n *\n * // Create the timer\n * let t = factory();\n *\n * // Get a value from the timer\n * const value = t();\n *\n * // Recreate the timer, note we don't need any options\n * t = factory();\n * ```\n *\n * @param source Kind of timer to make\n * @param duration Duration depends on the timer used. Will be milliseconds, hertz or bpm.\n * @param options Options to pass to timer.\n * @returns\n */\nexport const timingSourceFactory = (source, duration, options = {}) => {\n    switch (source) {\n        case `elapsed`:\n            return () => TimeSources.elapsed(duration, options);\n        case `bpm`:\n            return () => TimeSources.bpm(duration, options);\n        case `hertz`:\n            return () => TimeSources.hertz(duration, options);\n        default:\n            throw new Error(`Unknown source '${source}'. Expected: 'elapsed', 'hertz' or 'bpm'`);\n    }\n};\n","import { resultThrow, integerTest } from \"@ixfx/guards\";\nimport * as Sources from './source/index.js';\n/**\n * Returns a function that shapes a 0..1 value as a\n * triangle waveform.\n *\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function triangleShape(period = 1) {\n    period = 1 / period;\n    const halfPeriod = period / 2;\n    return (t) => {\n        const v = Math.abs((t % period) - halfPeriod);\n        //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n        return v;\n    };\n}\n/**\n * Returns a function that shapes a 0..1 value as a square waveform.\n * `period` sets the number of cycles in the 0..1 range.\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function squareShape(period = 1) {\n    period = 1 / period;\n    const halfPeriod = period / 2;\n    return (t) => {\n        return (t % period) < halfPeriod ? 1 : 0;\n        //console.log(`square: ${ t } v: ${ v }`);\n        //return v;\n    };\n}\n/**\n * Returns a function that shapes a 0..1 value as a sine waveform.\n * ```js\n * const s = sineShape();\n * // Calculate value of sine wave at 50%\n * // By default there is one oscillation, thus\n * // it will be the middle of the cycle.\n * s(0.5);\n * ```\n *\n * The `period` determines number of cycles for\n * an input value of 1.\n * ```js\n * // Oscillate twice in 0..1 range\n * const s = sineShape(2);\n * ```\n *\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function sineShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => {\n        const v = (Math.sin(t * period) + 1) / 2;\n        //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n        return v;\n    };\n}\n/**\n * A series of arcs, sort of like a bouncing ball.\n * @param period\n * @returns\n */\nexport function arcShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => Math.abs(Math.sin(t * period));\n}\nexport function sineBipolarShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => Math.sin(t * period);\n}\n/**\n * Creates a wave modulator. Defaults to 5-second sine wave.\n * ```js\n * import { wave } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Triangle wave that has a single cycle over two seconds\n * const m = wave({ secs: 2, shape: `triangle`});\n *\n * // Call m() to get current value of wave, eg in\n * // an animation loop\n * const v = m();\n * ```\n *\n * @example\n * ```js\n * import { wave } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * import { resolveFields } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const state = {\n *  intensity: wave({secs: 2, shape: `sine` }),\n *  someOtherState: 10\n * }\n *\n * const use = async () {\n *  const { intensity } = await resolveFields(state);\n *  // Do something with intensity value...\n * }\n * ```\n * @param options\n * @returns\n */\nexport function wave(options) {\n    const shape = options.shape ?? `sine`;\n    const invert = options.invert ?? false;\n    const period = options.period ?? 1;\n    let sourceFunction;\n    resultThrow(integerTest(period, `aboveZero`, `period`));\n    const sourceOptions = {\n        ...options\n    };\n    if (options.ticks) {\n        sourceFunction = Sources.ticks(options.ticks, sourceOptions);\n    }\n    else if (options.hertz) {\n        sourceFunction = Sources.hertz(options.hertz, sourceOptions);\n    }\n    else if (options.millis) {\n        sourceFunction = Sources.elapsed(options.millis, sourceOptions);\n    }\n    else if (options.source) {\n        sourceFunction = options.source;\n    }\n    else {\n        const secs = options.secs ?? 5;\n        sourceFunction = Sources.elapsed(secs * 1000, sourceOptions);\n    }\n    let shaperFunction;\n    switch (shape) {\n        case `saw`:\n            shaperFunction = (v) => v;\n            break;\n        case `sine`:\n            shaperFunction = sineShape(period);\n            break;\n        case `sine-bipolar`:\n            shaperFunction = sineBipolarShape(period);\n            break;\n        case `square`:\n            shaperFunction = squareShape(period);\n            break;\n        case `triangle`:\n            shaperFunction = triangleShape(period);\n            break;\n        case `arc`:\n            shaperFunction = arcShape(period);\n            break;\n        default:\n            throw new Error(`Unknown wave shape '${shape}'. Expected: sine, sine-bipolar, saw, triangle, arc or square`);\n    }\n    return waveFromSource(sourceFunction, shaperFunction, invert);\n}\n/**\n * Returns a wave-shaping modulator from a source and shaper\n * @param sourceFn\n * @param shaperFn\n * @returns\n */\nexport function waveFromSource(sourceFunction, shaperFunction, invert = false) {\n    return (feedback) => {\n        let v = sourceFunction(feedback?.clock);\n        if (feedback?.override)\n            v = feedback.override;\n        v = shaperFunction(v);\n        if (invert)\n            v = 1 - v;\n        return v;\n    };\n}\n","/**\n * Weighted average\n *\n * @param currentValue\n * @param targetValue\n * @param slowDownFactor\n * @returns\n */\nexport const weightedAverage = (currentValue, targetValue, slowDownFactor) => {\n    return ((currentValue * (slowDownFactor - 1)) + targetValue) / slowDownFactor;\n};\n","import { get } from \"./easing/index.js\";\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n *\n * Use {@link weightedSource} to return a function instead.\n *\n * ```js\n * import * as Random from 'https://unpkg.com/ixfx/dist/random.js';\n * Random.weighted();          // quadIn easing by default, which skews toward low values\n * Random.weighted(`quadOut`); // quadOut favours high values\n * ```\n * @param easingNameOrOptions Options. Uses 'quadIn' by default.\n * @see {@link weightedSource} Returns a function rather than value\n * @returns Random number (0-1)\n */\nexport const weighted = (easingNameOrOptions = `quadIn`) => weightedSource(easingNameOrOptions)();\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n * Use {@link weighted} to get a value directly.\n *\n * ```js\n * import * as Random from 'https://unpkg.com/ixfx/dist/random.js';\n * const r1 = Random.weightedSource();          // quadIn easing by default, which skews toward low values\n * r1(); // Produce a value\n *\n * const r2 = Random.weightedSource(`quadOut`); // quadOut favours high values\n * r2(); // Produce a value\n * ```\n * @param easingNameOrOptions Easing name or options `quadIn` by default.\n * @see {@link weighted} Returns value instead of function\n * @returns Function which returns a weighted random value\n */\nexport const weightedSource = (easingNameOrOptions = `quadIn`) => {\n    const options = typeof easingNameOrOptions === `string`\n        ? { easing: easingNameOrOptions }\n        : easingNameOrOptions;\n    const source = options.source ?? Math.random;\n    const easingName = options.easing ?? `quadIn`;\n    const easingFunction = get(easingName);\n    if (typeof easingFunction === `undefined`) {\n        throw new Error(`Easing function '${easingName}' not found.`);\n    }\n    const compute = () => {\n        const r = source();\n        return easingFunction(r);\n    };\n    return compute;\n};\n","export * from '@ixfx/modulation';"],"mappings":";;;;;;;;;;;;;;;;;AAKA,MAAa,eAAe,CAACA,OAAgB,iBAAiB,OAAiC;AAC7F,KAAI,iBAAqB,QAAO;EAAE,SAAS;EAAO,QAAQ,SAAU,cAAe;CAAsC;AACzH,KAAI,UAAU,KAAM,QAAO;EAAE,SAAS;EAAO,QAAQ,SAAU,cAAe;CAAiC;AAC/G,YAAW,WAAW,UAAW,QAAO;EAAE,SAAS;EAAO,QAAQ,SAAU,cAAe,oBAAqB,MAAO;CAAwB;AAC/I,QAAO;EAAE,SAAS;EAAM;CAAO;AAChC;;;;;;;;;ACHD,MAAa,eAAe,CAACC,MAA2B;AACtD,KAAK,EAAY,oBAAwB,QAAO;AAChD,KAAK,EAAY,uBAA2B,QAAO;AACnD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;AC2BD,MAAaC,cAA2B,CACtCC,GACAC,GACAC,MACU;AACV,KAAI,aAAa,EAAE,EAAE;AACnB,MAAI,aAAiB,KAAIC;AACzB,MAAI,QAAQ,EAAE,CACZ,QAAO,iBAAiB,EAAE,UAAU,EAAE,aAAa,EAAE;AAEvD,QAAM,IAAI,OACP;CAEJ,kBAAiB,OAAO,QACvB,OAAM,IAAI,WACP,6CAA8C,KAAK,UAAU,EAAE,CAAE;iBAGzD,OAAO,kBAAkB,OAAO,SAAS;AAClD,MAAI,aAAiB,KAAIA;AACzB,OAAK,QAAQ,EAAE,CACb,OAAM,IAAI,OACP;AAGL,SAAO,iBAAiB,GAAG,GAAG,EAAE;CACjC,MACC,OAAM,IAAI,WACP,yDAA0D,EAAG,WAAY,EAAG,WAAY,EAAG,QAAS,KAAK,UACxG,EACD,CAAE;AAIV;;;;;;;;AAsCD,MAAM,mBAAmB,CACvBC,YACAC,cACAC,SAAgBH,UACN;AACV,OAAW,OAAO;AAClB,QAAO,OAAO,OAAO;EACnB,GAAG,OAAO,IAAII,aAAW,KAAK,IAAI,aAAa;EAC/C,GAAG,OAAO,IAAIA,aAAW,KAAK,IAAI,aAAa;CAChD,EAAC;AACH;;;;;;;;;;;;;;ACxGD,SAAgB,IAAIC,IAAkB;AACpC,KAAI,UAAU,GAAG,CACf,QAAO,OAAO,OAAO;EACnB,GAAG;EACH,GAAG,KAAK,IAAI,GAAG,EAAE;EACjB,GAAG,KAAK,IAAI,GAAG,EAAE;EACjB,GAAG,KAAK,IAAI,GAAG,EAAE;CAClB,EAAC;UACO,QAAQ,GAAG,CACpB,QAAO,OAAO,OAAO;EACnB,GAAG;EACH,GAAG,KAAK,IAAI,GAAG,EAAE;EACjB,GAAG,KAAK,IAAI,GAAG,EAAE;CAClB,EAAC;KACG,OAAM,IAAI,WAAW;AAC7B;;;;;;;;;;;;;;;;ACjBD,MAAa,UAAU,CAACC,GAAUC,MAAqB;AACrD,KAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,EAAG,QAAO;AACnC,KAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,EAAG,QAAO;AACnC,KAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,EAAG,QAAO;AACnC,KAAI,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,EAAG,QAAO;AACnC,KAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,EAAG,QAAO;AACvC,QAAO,OAAO;AACf;;;;;;;;;;;;;;;;;;ACJD,MAAaC,gBAAc,CACzBC,QACAC,GACAC,GACA,gBAAgB,UACN,cAAgB,QAAQ,GAAG,GAAG,cAAc;;;;;;;;;;;;;;ACTxD,MAAa,SAAS,CACpBC,IACAC,QAAkC,UACxB;AACV,SAAQ,MAAR;EACE,MAAM,MACJ,QAAO,UAAU,GAAG,GAAG,OAAO,OAAO;GACnC,GAAG;GACH,GAAG,GAAG,IAAI;GACV,GAAG,GAAG,IAAI;GACV,GAAG,GAAG,IAAI;EACX,EAAC,GAAG,OAAO,OAAO;GACjB,GAAG;GACH,GAAG,GAAG,IAAI;GACV,GAAG,GAAG,IAAI;EACX,EAAC;EAEJ,MAAM,GACJ,QAAO,OAAO,OAAO;GACnB,GAAG;GACH,GAAG,GAAG,IAAI;EACX,EAAC;EAEJ,MAAM,GACJ,QAAO,OAAO,OAAO;GACnB,GAAG;GACH,GAAG,GAAG,IAAI;EACX,EAAC;EAEJ,MAAM,GACJ,KAAI,UAAU,GAAG,CACf,QAAO,OAAO,OAAO;GACnB,GAAG;GACH,GAAG,GAAG,IAAI;EACX,EAAC;MACG,OAAM,IAAI,OAAO;EAE1B,QACE,OAAM,IAAI,OAAO;CAEpB;AACF;;;;;;;;;;;;;;;ACzCD,MAAa,gBAAgB,CAC3BC,OACA,GAAG,gBACO,SAAS,GAAG,YAAY,CAAC,MAAM;;;;;;;;;;;;;;;;AAiB3C,MAAa,WACX,CAAC,GAAGC,eACF,CAACC,OAEC,WAAS,OAAO,CAAC,UAAU,YAAY,QAAQ,SAAS,EAAE,GAAG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkCnE,MAAa,cAAc,CAACC,eAAyC,MAAoB;CACvF,MAAM,iBAAiB,kBAAkB,UAAU,EAAE,KAAK,aAAc,IAAG;CAC3E,IAAI,MAAM,QAAQ,OAAO;CACzB,IAAI,MAAM,QAAQ,OAAO;CACzB,MAAM,SAAS,QAAQ,UAAU,KAAK;AAEtC,aACE,WAAW,MAAM,IAAI,KAAK,EAC1B,WAAW,MAAM,IAAI,KAAK,CAC3B;AAED,MAAK,QAAQ,OAAO,MAAM,GAAG;AAC3B,QAAM;AACN,QAAM;CACP;AACD,KAAI,MAAM,IACR,OAAM,IAAI,OAAO,gCAAiC,IAAI,UAAU,CAAE,QAAS,IAAI,UAAU,CAAE;AAG7F,QAAO,MAAM,QAAQ,IAAI,MAAM,OAAO;AACvC;;;;;;;;;;;;;;;;;;;;;AAsBD,MAAa,QAAQ,CAACA,eAAyC,MAC7D,YAAY,aAAa,EAAE;;;;;;;;;;;;;;;;;;AC/F7B,MAAa,cAAc,CACzBC,QACAC,OACAC,WACmB;AACnB,UAAS,QAAQ,OAAO;AACxB,UAAS,SAAS,QAAQ;AAC1B,OAAY,SAAS,QAAQ;AAE7B,QAAO;EAAE,GAAG,OAAO;EAAG,GAAG,OAAO;EAAU;EAAe;CAAQ;AAClE;;;;;;;;;;;;;;;;;;;;;ACsBD,MAAa,WAAW,CACtBC,MACAC,SACW;AACX,SAAM,KAAK;AACX,SAAQ,MAAR;EACE,MAAM,KACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI;EAElC,MAAM,QACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI;EAElC,MAAM,MACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI;EAElC,MAAM,OACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI,KAAK,QAAQ,KAAK;CAErD;AACF;;;;;;;;;;;;;;;;;;;AAoBD,MAAa,WAAW,CACtBD,MACAC,SACW;AACX,SAAM,KAAK;AACX,SAAQ,MAAR;EACE,MAAM,KACJ,QAAQ,QAAQ,KAAK,GAAG,KAAK,IAAI;EAEnC,MAAM,QACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI,KAAK,SAAS,KAAK;EAErD,MAAM,MACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI;EAElC,MAAM,OACJ,QAAO,QAAQ,KAAK,GAAG,KAAK,IAAI;CAEnC;AACF;;;;;;;;;;;;;;;;;;;;;ACjFD,MAAa,kBAAkB,CAACC,OAAcC,KAAY,OAAO,MAAuB;AACtF,KAAI,OAAO,MAAM,KAAK,CAAE,OAAM,IAAI,OAAO;AACzC,KAAI,OAAO,MAAM,OAAO,EAAG,OAAM,IAAI,OAAO;CAE5C,MAAM,SAAS,cAAiB,IAAK,OAAO,IAAI;CAChD,IAAI,SAAS;AACb,KAAI,IAAI,IAAI,MAAM,EAEhB,UAAS,OAAO,IAAI;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;CAAE,IAC9E;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;CAAE;KAG9D,UAAS,OAAO,IAAI;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;CAAE,IAC9E;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;EAAE,GAAG,KAAK,IAAI,MAAM,GAAG,IAAI,EAAE;CAAE;CAGhE,MAAM,SAAS,cAAiB,KAAK,IAAI,KAAK,EAAE,QAAQ,OAAQ;AAChE,QAAO,UAAU,OAAO,KAAK,OAAO;AACrC;;;;;;;;;;;;;;;;;;;;AA2BD,MAAa,eAAe,CAACC,MAAgE;CAI3F,MAAM,MAAM,cAAc,EAAE,GAC1B,IAAIC,OAAc,EAAE,EAAE,GAAG,EAAE,EAAE,GAAG,EAAE,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE,EAAE,GAAG,EAAE,EAAE,KAC3F,IAAIA,OAAc,EAAE,GAAG,EAAE,WAAW,EAAE;AAExC,QAAO,CAACC,WAAmB,IAAI,QAAQ,OAAO;AAC/C;AAGD,MAAa,uBAAuB,CAACJ,OAAcC,KAAYI,WAAyC,EAAG,IAAK,MAAM,EAAG,GAAI,MAAM,EAAG,KAAM,OAAO,EAAG,GAAI,OAAO,EAAG,GAAI,IAAI,EAAG,GAAI,IAAI,EAAG,CAAG;AAE7L,MAAa,SAAS,CAACC,qBAA2F;AAChH,KAAI,cAAc,iBAAiB,CACjC,QAAO,YAAY,iBAAiB;UAC3B,kBAAkB,iBAAiB,CAC5C,QAAO,gBAAgB,iBAAiB;KAExC,OAAM,IAAI,OAAO;AAEpB;AAED,MAAa,QAAQ,CAACN,OAAcC,KAAYM,QAAeC,YAC7D;CACE,GAAG,OAAO,OAAO,MAAM;CACvB,GAAG,OAAO,OAAO,IAAI;CACrB,QAAQ,OAAO,OAAO,OAAO;CAC7B,QAAQ,OAAO,OAAO,OAAO;AAC9B;AAEH,MAAM,cAAc,CAACC,YAAwC;CAC3D,MAAM,EAAE,GAAG,QAAQ,QAAQ,GAAG,GAAGC;CAEjC,MAAM,MAAM,IAAIP,OAAc,GAAG,QAAQ,QAAQ;AACjD,QAAO,OAAO,OAAO;EACnB,GAAGO;EACH,QAAQ,MAAM,IAAI,QAAQ;EAC1B,aAAa,CAACC,MAAc,IAAI,QAAQ,EAAE;EAC1C,SAAS,CAACC,MAAa;AAAE,SAAM,IAAI,OAAO;EAAoB;EAC9D,MAAM,MAAM;GACV,MAAM,EAAE,GAAG,GAAG,GAAG,IAAI,MAAM;GAC3B,MAAM,QAAQ,EAAE;GAChB,MAAM,QAAQ,EAAE;AAChB,OAAI,iBAAqB,OAAM,IAAI,OAAO;AAC1C,OAAI,iBAAqB,OAAM,IAAI,OAAO;AAE1C,UAAO,YAAiB;IAAE,GAAG,EAAE;IAAK,GAAG,EAAE;GAAK,GAAE,OAAO,MAAM;EAC9D;EACD,kBAAkB,CAACC,QAAeC,2BAAmC;AACnE,SAAM,IAAI,OAAO;EAClB;EACD,iBAAiB,CAACD,WAA0B;AAC1C,SAAM,IAAI,OAAO;EAClB;EACD,aAAa,MAAM,EAAG,MAAQ;EAC9B,OAAO;CACR,EAAC;AACH;AAED,MAAa,YAAY,CAACb,OAAcC,KAAYI,YAAoC;CACtF,GAAG,OAAO,OAAO,MAAM;CACvB,GAAG,OAAO,OAAO,IAAI;CACrB,WAAW,OAAO,OAAO,OAAO;AACjC;AAGD,MAAM,kBAAkB,CAACU,oBAA0D;CACjF,MAAM,EAAE,GAAG,GAAG,wBAAW,GAAG;CAC5B,MAAM,MAAM,IAAIZ,OAAc,GAAGa,aAAW;AAC5C,QAAO,OAAO,OAAO;EACnB,GAAG;EACH,QAAQ,MAAM,IAAI,QAAQ;EAC1B,aAAa,CAACL,MAAc,IAAI,QAAQ,EAAE;EAC1C,SAAS,CAACC,MAAa;AAAE,SAAM,IAAI,OAAO;EAAoB;EAC9D,MAAM,MAAM;GACV,MAAM,EAAE,GAAG,GAAG,GAAG,IAAI,MAAM;GAC3B,MAAM,QAAQ,EAAE;GAChB,MAAM,QAAQ,EAAE;AAChB,OAAI,iBAAqB,OAAM,IAAI,OAAO;AAC1C,OAAI,iBAAqB,OAAM,IAAI,OAAO;AAC1C,UAAO,YAAiB;IAAE,GAAG,EAAE;IAAK,GAAG,EAAE;GAAK,GAAE,OAAO,MAAM;EAC9D;EACD,iBAAiB,CAACC,WAA0B;AAC1C,SAAM,IAAI,OAAO;EAElB;EACD,kBAAkB,CAACA,QAAeC,2BAA2C;AAC3E,SAAM,IAAI,OAAO;EAElB;EACD,UAAU,MAAM,IAAI,UAAU;EAC9B,aAAa,MAAM,qBAAqB,GAAG,GAAGE,YAAU;EACxD,OAAO;CACR,EAAC;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpED,gBAAuB,OACrBC,SACAC,MACmB;CACnB,MAAM,SAAS,KAAK;CACpB,MAAM,YAAY,KAAK,cAAc;CACrC,MAAM,QAAQ,KAAK;CACnB,MAAM,iBAAiB,KAAK,kBAAkB;CAC9C,MAAM,gBAAgB,KAAK,eAAe,aAAa,KAAK,aAAa;CACzE,MAAM,gBAAgB,KAAK;CAE3B,IAAI,YAAY;CAChB,IAAI,UAAU,aAAa,KAAK,OAAO,aAAa,KAAK,cAAc,EAAE,CAAC;CAC1E,IAAI,UAAU,YAAY,KAAK;CAE/B,MAAM,UAAU,YAAY;EAC1B,MAAMC,YAAU,YAAY,KAAK,GAAG;AACpC,aAAW,mBAAmB,WAC5B,WAAU,KAAK,IAAI,GAAG,gBAAgBA,UAAQ;AAEhD,MAAI,QACF,OAAM,MAAM;GAAE,QAAQ;GAAS;EAAQ,EAAC;AAE1C,YAAU,YAAY,KAAK;AAC3B,MAAI,QAAQ,QAAS,OAAM,IAAI,OAAO,iBAAkB,OAAO,OAAQ;CACxE;AAED,KAAI,MAAM,QAAQ,QAAQ,CAAE,WAAU,QAAQ,QAAQ;AAEtD,KAAI,KAAK,QAAS,MAAK,SAAS;CAEhC,IAAI,UAAU;CACd,IAAI,cAAc;AAClB,KAAI;AACF,UAAQ,WAAW;AACjB;AACA,OAAI,eAAe,WAAW,eAAe,MAAO,OAAM,SAAS;GACnE,MAAM,SAAS,MAAM,QAAW,QAAQ;AACxC,cAAW,YAAY,eAAe,eACpC,aAAY;QACP;AACL,UAAM;AACN,QAAI,eAAe,UAAU,eAAe,MAAO,OAAM,SAAS;AAClE,QAAI,oBAAuB,eAAe,MAAO,aAAY;GAC9D;AACD,OAAI,eACF;SAAK,cAAc,YAAY,CAC7B,aAAY;GACb;EAEJ;AACD,YAAU;CACX,UAAS;AACR,cAAY;AACZ,MAAI,KAAK,WAAY,MAAK,WAAW,QAAQ;CAC9C;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDD,SAAgB,QACdC,UACAC,OAAwE,CAAE,GAC5D;CACd,MAAM,UAAU,aAAa,SAAS;AACtC,MAAK,QAAS,OAAM,IAAI,OAAO;CAC/B,MAAM,YAAY;EAChB,GAAG;EACH,OAAO,6BAA6B;CACrC;CACD,IAAIC;AACJ,QAAO,MAAM;AACX,QAAM,SAAS,SAAS,UAAU;AAClC,SAAO,EAAE;CACV;AACF;;;;;;;;;;;;;;;;;;;;;;AAuBD,SAAgB,aAAaC,YAAoBF,OAAwE,CAAE,GAC3G;CACd,MAAM,YAAY;EAChB,GAAG;EACH,OAAO,sBAAsB;CAC9B;CACD,IAAIC;AACJ,QAAO,MAAM;AACX,QAAM,SAAS,YAAY,UAAU;AACrC,SAAO,EAAE;CACV;AACF;;;;;;AAOD,MAAa,kBAAkB,OAAwB;CACrD,SAAS;CACT,QAAQ;CACR,QAAc,CAEb;CACD,IAAI,KAAK,CAER;AACF;;;;;;AAOD,MAAa,iBAAiB,OAC5B;CACE,SAAS;CACT,QAAQ;CACR,QAAQ,CAEP;CACD,MAAM,CAEL;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CH,MAAa,WAAW,CACtBE,OACAC,UAAsC,CAAE,MACpB;AAEpB,MAAK,OAAO,SAAS,MAAM,CACzB,QAAO,iBAAiB;UACf,OAAO,MAAM,MAAM,CAC5B,QAAO,gBAAgB;CAGzB,MAAM,aAAa,QAAQ,cAAc;CACzC,MAAM,YAAY,QAAQ,aAAa;AACvC,KAAI,cAAc,UAAW,OAAM,IAAI,OAAO;CAE9C,IAAI,mBAAmB;CAGvB,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;CAE5D,IAAI,YAAY;CAChB,MAAM,iBAAiB,CAACC,UAAkB;AACxC,cAAY;EACZ,IAAI,IAAI,SAAS,QAAQ;AACzB,MAAI,WAAY,KAAI,MAAM,EAAE;WACnB,aAAa,KAAK,EAAG,KAAI,IAAI;AACtC,SAAO;CACR;AAED,QAAO;EACL,IAAIC,KAAa;AACf,sBAAmB;EACpB;EACD,IAAI,SAAS;AAGX,UAAO,eAAe,UAAU,IAAI;EACrC;EACD,IAAI,UAAU;AACZ,UAAO,eAAe,MAAM,QAAQ;EACrC;EACD,OAAO,MAAM;AACX,SAAM,OAAO;EACd;CACF;AACF;;;;;;;;;;;;;;;;;;;;;;;;AA0BD,MAAa,iBAAiB,CAC5BC,WACAC,UAA8B,CAAE,MACZ;CACpB,MAAM,QAAQ,QAAQ,SAAS,6BAA6B;CAC5D,MAAM,kBAAkB,YAAY;CACpC,IAAI,mBAAmB;CAEvB,MAAM,iBAAiB,MAAM;EAE3B,MAAM,IAAI,MAAM,WAAW,kBAAkB;EAG7C,MAAM,IAAI,IAAI,KAAK,MAAM,EAAE;AAC3B,MAAI,IAAI,EACN,OAAM,IAAI,OACP,kDAAmD,EAAG,MAAO,EAAG;AAGrE,MAAI,IAAI,EACN,OAAM,IAAI,OACP,kDAAmD,EAAG,MAAO,EAAG;AAGrE,SAAO;CACR;AACD,QAAO;EACL,KAAK,CAACF,QAAgB;AACpB,sBAAmB;EACpB;EACD,OAAO,MAAM;AACX,SAAM,OAAO;EACd;EACD,IAAI,SAAS;AACX,UAAO,gBAAgB,IAAI;EAC5B;EACD,IAAI,UAAU;AACZ,UAAO,gBAAgB;EACxB;CACF;AACF;;;;;;;;;;;;AAaD,MAAa,8BAA8B,MAAa;CACtD,IAAI,QAAQ,YAAY,KAAK;AAC7B,QAAO;EAIL,OAAO,MAAM;AACX,WAAQ,YAAY,KAAK;EAC1B;EAID,IAAI,UAAU;AACZ,UAAO,YAAY,KAAK,GAAG;EAC5B;CACF;AACF;;;;;;;;;;;;;;;;;;AAmBD,MAAa,uBAAuB,MAAgC;CAClE,IAAI,QAAQ;AACZ,QAAO;EAIL,OAAO,MAAM;AACX,WAAQ;EACT;EAID,IAAI,OAAO;AACT,UAAO;EACR;EASD,IAAI,UAAU;AACZ,UAAO,EAAE;EACV;CACF;AACF;;;;;;;;;;;;;;;;;;AAoBD,MAAa,oBAAoB,CAC/BG,IACAC,UACgE;AAChE,YAAW,QAAQ,UAAW,OAAM,IAAI,OAAO,+CAAgD,GAAI;CACnG,IAAI,aAAa;AACjB,QAAO;EACL,IAAI,UAAU;AACZ,UAAO,MAAM;EACd;EACD,IAAI,SAAS;AACX,UAAO,MAAM;EACd;EACD,IAAI,WAAW;AACb,OAAI,MAAM,OAAQ,SAAQ;AAC1B,WAAQ;EACT;EAID,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,kBAAkB;AACpB,UAAO;EACR;EACD,SAAS,MAAM;GACb,MAAMC,YAAU,MAAM;AACtB,UAAO,GAAGA,UAAQ;EACnB;EACD,OAAO,MAAM;AACX,SAAM,OAAO;AACb;EACD;CACF;AACF;;;;AC5dD,MAAa,uBAAuB,OAAO,OAAO;CAC9C,QAAQ,EAAE,SAAS,QAAS;CAC5B,OAAO,EAAE,WAAW,QAAS;CAC7B,SAAS,EAAE,QAAS;CACpB,SAAS,EAAE,SAAU;CACrB,UAAU;AACb,EAAC;;;;;;;;;;;;;;;;;;ACgCF,IAAa,yBAAb,cAEU,mBAA4C;CACpD;CACA;CAEA;CACA,qBAAqB;CACrB,UAAU;CACV,aAAa,iBAAiB;;;;;;CAO9B,YAAYC,GAAMC,OAAyC,CAAE,GAAE;AAC7D,SAAO;AAEP,OAAKC,SAAS,KAAK,SAAS;AAC5B,OAAKC,MAAM,KAAkB,GAAG,KAAK,QAAQ;AAC7C,OAAKC,aAAa,WAAwB,KAAKD,IAAI;CACpD;CAID,WAAWE,GAAY;AACrB,MAAI,KAAKC,YAAY,EAAG;AACxB,OAAKA,UAAU;AACf,MAAI,GAAG;AACL,QAAKC,qBAAqB;AAC1B,cAAW,MAAM;AACf,SAAK,KAAKA,mBAAoB;AAC9B,SAAKA,qBAAqB;AAE1B,SAAK,WAAW,OAAO,EAAE,OAAO,KAAKJ,IAAI,MAAO,EAAC;GAClD,GAAE,EAAE;EACN,MACC,MAAKI,qBAAqB;CAE7B;;;;;;;CAQD,IAAI,iBAAoD;AACtD,SAAO,SAAsB,KAAKJ,IAAI;CACvC;;;;CAKD,IAAI,gBAA0C;AAC5C,SAAO,OAAO,KAAK,KAAKA,IAAI,QAAQ;CACrC;;;;;;;CAQD,OAAsB;EACpB,MAAM,IAAI,SAAsB,KAAKA,IAAI;AACzC,MAAI,EAAE,WAAW,EAAG,QAAO;AAC3B,OAAK,QAAQ,EAAG;AAChB,SAAO,EAAG;CACX;;;;;;CAOD,IAAI,SAAkB;AACpB,SAAO,OAAoB,KAAKA,IAAI;CACrC;;;;CAKD,QAAQ;AACN,OAAKK,WAAW,MAAM;AACtB,OAAKL,MAAM,WAAwB,KAAKC,WAAW;AACnD,OAAKK,aAAa,cAAc;CACjC;;;;;;CAOD,mBAAmBC,UAA+B;AAChD,qBAAgC,KAAKP,KAAK,SAAS;CACpD;;;;;;;CAQD,QAAQO,UAAkC;AACxC,SAAO,kBAA+B,KAAKP,KAAK,SAAS;CAC1D;;;;;;;CAQD,IAAI,MAAMO,UAAyB;EACjC,MAAM,aAAa,KAAKP,IAAI;AAC5B,MAAI,aAAa,KAAKA,IAAI,MAAO;AAGjC,OAAKA,MAAM,GAAgB,KAAKA,KAAK,SAAS;AAC9C,MAAI,KAAKD,OACP,SAAQ,KAAK,gBAAiB,WAAY,MAAO,SAAU,EAAE;AAE/D,OAAKO,aAAa,cAAc;AAChC,aAAW,MAAM;AACf,QAAK,WAAW,SAAS;IAAY;IAAsB;GAAY,EAAC;EACzE,GAAE,EAAE;AAEL,MAAI,OAAoB,KAAKN,IAAI,CAAE,MAAKK,WAAW,KAAK;CACzD;CAED,IAAI,QAAgB;AAClB,SAAO,KAAKL,IAAI;CACjB;;;;;CAMD,IAAI,YAAoB;AACtB,SAAO,KAAKM,YAAY;CACzB;;;;;CAMD,IAAI,UAAkB;AACpB,SAAO,KAAKA,YAAY;CACzB;AACF;;;;ACzLD,MAAa,wBAAwB,OAAO,OAAO;CAC/C,gBAAgB;CAChB,eAAe;CACf,iBAAiB;CACjB,YAAY;AACf,EAAC;;;;;;AAMF,IAAa,WAAb,cAA8B,mBAAmB;CAC7C;CACA;CACA;CACA;CACA;CACA,YAAY;CACZ,aAAa;CACb;CACA;CACA;CACA;;;;CAIA;CACA,YAAY,OAAO,CAAE,GAAE;AACnB,SAAO;AACP,OAAK,iBAAiB,KAAK,kBAAkB,sBAAsB;AACnE,OAAK,gBAAgB,KAAK,iBAAiB,sBAAsB;AACjE,OAAK,kBAAkB,KAAK,mBAAmB,sBAAsB;AACrE,OAAK,aAAa,KAAK,cAAc,sBAAsB;AAC3D,OAAKE,MAAM,IAAI,uBAAuB,sBAAsB,EAAE,UAAU,QAAS;AACjF,OAAKA,IAAI,kBAAkB,SAAS,CAAC,UAAU;AAE3C,OAAI,MAAM,cAAc,YAAY,KAAKC,gBACrC,MAAKC,QAAQ,OAAO;AAExB,SAAM,WAAW,SAAS,MAAM;EACnC,EAAC;AACF,OAAKF,IAAI,kBAAkB,OAAO,CAAC,UAAU;AACzC,SAAM,WAAW,WAAW,MAAM;EACrC,EAAC;AACF,OAAKG,cAAc,MAAM,6BAA6B;AACtD,OAAKC,WAAW,KAAKH,kBAAkB;AACvC,OAAK,qBAAqB,KAAK,iBAAiB,KAAK;CACxD;CACD,UAAU;AACN,MAAI,KAAKI,UACL;AACJ,OAAKL,IAAI,SAAS;CACrB;CACD,IAAI,aAAa;AACb,SAAO,KAAKK;CACf;;;;;CAKD,oBAAoB,cAAc;AAC9B,MAAI,KAAKH,kBACL,QAAO;EACX,IAAII,YAAU,KAAKJ,OAAO;EAC1B,MAAM,UAAU,KAAKD,oBAAoB,KAAKG;EAE9C,IAAI,aAAa;EAEjB,IAAI,QAAQ,KAAKJ,IAAI;AACrB,KAAG;AACC,gBAAa;AACb,WAAQ,KAAKA,IAAI;AAEjB,WAAQ,OAAR;IACI,MAAM,SAAS;AACX,SAAIM,YAAU,KAAK,kBAAkB,SAAS;AAC1C,WAAKN,IAAI,MAAM;AACf,mBAAa;KAChB;AACD;IACH;IACD,MAAM,QAAQ;AACV,SAAIM,YAAU,KAAK,sBAAsB,SAAS;AAC9C,WAAKN,IAAI,MAAM;AACf,mBAAa;KAChB;AACD;IACH;IACD,MAAM,UAAU;AACZ,UAAK,KAAKI,YAAY,SAAS;AAC3B,kBAAU;AACV,WAAKJ,IAAI,MAAM;AACf,WAAKE,OAAO,OAAO;AACnB,mBAAa;KAChB;AACD;IACH;IACD,MAAM,UAAU;AACZ,SAAII,YAAU,KAAK,iBAAiB;AAChC,WAAKN,IAAI,MAAM;AACf,mBAAa;KAChB;AACD;IACH;IACD,MAAM,UACF,KAAI,KAAK,cAAc,aACnB,MAAK,QAAQ,KAAKC,gBAAgB;GAG7C;EACJ,SAAQ,cAAc,WAAW;AAClC,SAAO;CACV;;;;;;CAMD,WAAW,mBAAmB,MAAM,eAAe,MAAM;AACrD,MAAI,KAAKC,kBACL,QAAO;;GAAY;GAAG,KAAKF,IAAI;EAAM;AAGzC,MAAI,iBACA,MAAK,oBAAoB,aAAa;EAC1C,MAAM,gBAAgB,KAAKA,IAAI;EAC/B,MAAMM,YAAU,KAAKJ,OAAO;EAC5B,IAAIK,aAAW;EACf,MAAM,QAAQ,KAAKP,IAAI;AACvB,UAAQ,OAAR;GACI,MAAM,SAAS;AACX,iBAAWM,YAAU,KAAK;AAC1B;GACH;GACD,MAAM,QAAQ;AACV,kBAAYA,YAAU,KAAK,kBAAkB,KAAK;AAClD;GACH;GACD,MAAM,UAAU;AACZ,iBAAW;AACX;GACH;GACD,MAAM,UAAU;AACZ,iBAAW,KAAK,IAAIA,YAAU,KAAK,iBAAiB,EAAE;AACtD;GACH;GACD,MAAM,UACF,QAAO;KAAE;IAAW;IAAG;GAAc;GAEzC,QACI,OAAM,IAAI,OAAO,kCAAkC,MAAM;EAEhE;AACD,SAAO;GAAC;GAAOC;GAAU;EAAc;CAC1C;;;;CAID,IAAI,SAAS;AACT,SAAO,KAAKP,IAAI;CACnB;CACD,YAAY,CAEX;;;;;;;;;;;;;;;;;CAiBD,QAAQ,OAAO,OAAO;AAClB,OAAK,WAAW;AAChB,OAAKQ,aAAa;AAClB,OAAKR,IAAI,OAAO;AAChB,OAAKE,SAAS,KAAKC,aAAa;AAChC,OAAKC,WAAW;AAChB,OAAKH,kBAAkB;CAC1B;CACD,IAAI,eAAe;AACf,SAAO,KAAKO;CACf;CACD,UAAU,CAET;;;;;;CAMD,UAAU;AACN,MAAI,KAAK,WAAW,KAAKP,gBACrB;AAEJ,OAAKG,WAAW;AAChB,OAAK,SAAS;CACjB;AACJ;;;;AC/MD,MAAa,kBAAkB,OAAO,OAAO;CACzC,YAAY;CACZ,WAAW;CACX,aAAa;CACb,WAAW;CACX,cAAc;CACd,cAAc;CACd,cAAc;CACd,WAAW;AACd,EAAC;AACF,IAAa,eAAb,MAA0B;CACtB;CACA,YAAYK,QAAM;AACd,OAAK,OAAOA;CACf;CACD,KAAK,GAAG,MAAM;AACV,OAAK,KAAK,KAAK,aACX,MAAK,KAAK,SAAS;EAEvB,MAAM,IAAI,KAAK,KAAK,SAAS;AAC7B,SAAO;GACH,OAAO,EAAE;GACT,MAAM,EAAE,QAAQ;EACnB;CACJ;CACD,KAAK,OAAO,eAAe;AACvB,UAAQ;CACX;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwFD,IAAa,OAAb,cAA0B,SAAS;CAC/B;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,YAAY,OAAO,CAAE,GAAE;AACnB,QAAM,KAAK;AACX,OAAK,YAAY,KAAK,aAAa,gBAAgB;AACnD,OAAK,eAAe,KAAK,gBAAgB,gBAAgB;AACzD,OAAK,YAAY,KAAK,aAAa,gBAAgB;AACnD,OAAK,eAAe,KAAK,gBAAgB,gBAAgB;AACzD,OAAK,eAAe,KAAK,gBAAgB,gBAAgB;AACzD,OAAK,aAAa,KAAK,cAAc,gBAAgB;AACrD,OAAK,cAAc,KAAK,eAAe,gBAAgB;AACvD,OAAK,YAAY,KAAK,aAAa,gBAAgB;EACnD,MAAM,MAAM;AACZ,OAAK,aAAa,OAAe,gBAAwB;GAAE,GAAG;GAAG,GAAG,KAAK;EAAc,GAAE;GAAE,GAAG;GAAK,GAAG,KAAK;EAAW,IAAG,KAAK,WAAW,CAAC;AAC1I,OAAK,YAAY,OAAe,gBAAwB;GAAE,GAAG;GAAG,GAAG,KAAK;EAAW,GAAE;GAAE,GAAG;GAAK,GAAG,KAAK;EAAc,IAAG,KAAK,UAAU,CAAC;AACxI,OAAK,cAAc,OAAe,gBAAwB;GAAE,GAAG;GAAG,GAAG,KAAK;EAAc,GAAE;GAAE,GAAG;GAAK,GAAG,KAAK;EAAc,IAAG,KAAK,YAAY,CAAC;CAClJ;CACD,YAAY;AACR,OAAK;AACL,OAAK,KAAK,WAAW;GACjB,MAAM,CAAC,QAAQ,QAAQ,KAAK,GAAG,KAAK,QAAQ,MAAM,MAAM;AAExD,QAAK,OAAO,MAAM,OAAO,IAAI,SAAS,EAClC,MAAK,uBAAuB;EAEnC;CACJ;CACD,CAAC,OAAO,YAAY;AAChB,SAAO,IAAI,aAAa;CAC3B;;;;;CAKD,IAAI,QAAQ;AACR,SAAO,KAAK,QAAQ,KAAK,CAAC;CAC7B;;;;;;;CAOD,QAAQ,mBAAmB,MAAM,eAAe,MAAM;EAClD,MAAM,CAAC,OAAO,IAAI,GAAG,MAAM,WAAW,kBAAkB,aAAa;AAGrE,MAAI,iBACA,QAAO;;GAAY,OAAO;GAAK,OAAO;EAAI;EAC9C,IAAI;AACJ,UAAQ,OAAR;GACI,MAAM,SAAS;AACX,QAAI,KAAK,WAAW,YAAY,IAAI,CAAC;AACrC,QAAI,KAAK,gCACL,KAAI,MAAM,GAAG,GAAG,GAAG,KAAK,sBAAsB,EAAE;AAEpD,SAAK,aAAa;AAClB;GACH;GACD,MAAM,QAAQ;AACV,QAAI,KAAK,UAAU,YAAY,IAAI,CAAC;AACpC,SAAK,aAAa;AAClB;GACH;GACD,MAAM,UAAU;AACZ,QAAI,KAAK;AACT,SAAK,aAAa;AAClB;GACH;GACD,MAAM,UAAU;AACZ,QAAI,KAAK,YAAY,YAAY,IAAI,CAAC;AAGtC,QAAI,KAAK,sBACL,KAAI,MAAM,GAAG,GAAG,KAAK,cAAc,GAAG,KAAK,WAAW;AAE1D;GACH;GACD,MAAM,WAAW;AACb,QAAI,KAAK;AACT,SAAK;AACL;GACH;GACD,QACI,OAAM,IAAI,OAAO,iBAAiB,MAAM;EAE/C;AACD,SAAO;GAAC;GAAO;GAAG;EAAI;CACzB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjMD,MAAa,OAAO,CAAC,OAAO,CAAE,MAAK;CAC/B,MAAM,WAAW,IAAI,KAAK;CAC1B,MAAM,aAAa,SAAS;CAC5B,MAAM,WAAW,SAAS,OAAO,WAAW;AAC5C,QAAO,MAAM,wBAAwB,UAAU;EAAE,kBAAkB;EAAM,OAAO;CAAY,EAAC;AAChG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCD,gBAAuB,aAAa,MAAM;CACtC,MAAM,WAAW,IAAI,KAAK,KAAK;CAC/B,MAAM,eAAe,KAAK,gBAAgB;AAC1C,UAAS,SAAS;CAClB,MAAM,IAAI,OAAO,MAAM,SAAS,OAAO;EACnC,OAAO,OAAO,SAAS;EACvB,OAAO;EACP,QAAQ,KAAK;CAChB,EAAC;AACF,YAAW,MAAM,KAAK,EAClB,OAAM;AAEb;;;;;;;;;;;;;;;;;;;;;;;;AC1DD,SAAgBC,QAAM,YAAY,UAAU,CAAE,GAAE;AAC5C,aAAY,YAAY,aAAa,aAAa,YAAY,CAAC;CAC/D,MAAM,iBAAiB,QAAQ,kBAAkB;CACjD,MAAM,eAAe,QAAQ,gBAAgB;CAC7C,MAAM,aAAa,QAAQ,cAAc,OAAO;CAChD,MAAM,aAAa,iBAAiB,IAAI;CACxC,MAAM,WAAW,eAAe,aAAa,IAAI;CACjD,IAAI,aAAa;CACjB,IAAI,IAAI,QAAQ,WAAW;AAC3B,KAAI,QAAQ,iBAAiB;EACzB,IAAI,oBAAoB;AACxB,MAAI,eACA;AACJ,MAAI,aACA;AACJ,MAAI,KAAK,MAAM,QAAQ,kBAAkB,kBAAkB;CAC9D;AACD,QAAO,CAAC,aAAa;AACjB,MAAI,UAAU;AACV,OAAI,SAAS,mBACT,KAAI,SAAS;AAEjB,OAAI,SAAS,2BACT,KAAI,KAAK,MAAM,SAAS,kBAAkB,WAAW;EAE5D;AACD,MAAI,cAAc,WACd,QAAO;EACX,MAAM,UAAU,IAAI;AACpB;AACA,MAAI,IAAI,UAAU;AACd;AACA,OAAI;EACP;AACD,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;ACrCD,SAAgB,QAAQ,UAAU,UAAU,CAAE,GAAE;CAC5C,MAAM,aAAa,QAAQ,cAAc,OAAO;CAChD,MAAM,aAAa;CACnB,IAAI,QAAQ,QAAQ,WAAW,YAAY,KAAK;CAChD,IAAI,aAAa;CACjB,MAAM,aAAa,aAAa,UAAU,IAAK;AAC/C,KAAI,QAAQ,iBAAiB;AACzB,cAAY,WAAW,QAAQ,kBAAkB,cAAc,iBAAiB,CAAC;AACjF,UAAQ,YAAY,KAAK,GAAI,aAAa,QAAQ;CACrD;AAED,QAAO,CAAC,aAAa;AACjB,MAAI,UAAU;AACV,OAAI,SAAS,oBAAuB;AAChC,YAAQ,SAAS;AACjB,QAAI,UAAU,EACV,SAAQ,YAAY,KAAK;GAChC;AACD,OAAI,SAAS,4BAA+B;AACxC,gBAAY,WAAW,SAAS,kBAAkB,cAAc,iBAAiB,CAAC;AAClF,YAAQ,YAAY,KAAK,GAAI,aAAa,SAAS;GACtD;EACJ;AACD,MAAI,cAAc,WACd,QAAO;EACX,MAAM,MAAM,YAAY,KAAK;EAC7B,MAAM,eAAe,MAAM;AAC3B,MAAI,gBAAgB,YAAY;AAC5B,iBAAc,KAAK,MAAM,eAAe,WAAW;AACnD,WAAQ;AACR,OAAI,cAAc,WACd,QAAO;EACd;AACD,SAAQ,eAAe,aAAc;CACxC;AAIJ;;;;;;;;AAQD,SAAgB,IAAIC,OAAK,UAAU,CAAE,GAAE;CACnC,MAAM,WAAY,KAAK,MAAQA;AAC/B,QAAO,QAAQ,UAAU,QAAQ;AACpC;;;;;;;;AAQD,SAAgB,MAAM,IAAI,UAAU,CAAE,GAAE;CACpC,MAAM,WAAW,MAAO;AACxB,QAAO,QAAQ,UAAU,QAAQ;AACpC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvCD,MAAa,YAAY,CAAC,QAAQ,UAAU,CAAE,MAAK;CAC/C,MAAM,WAAW,SAAS;CAC1B,IAAI,MAAM,QAAQ,OAAO,OAAO;CAChC,IAAI,MAAM,QAAQ,OAAO,OAAO;CAChC,MAAMC,UAAQ,QAAQ,SAAS;AAC/B,KAAIA,WAAS,QAAQ,IACjB,OAAM,IAAI,OAAO;AACrB,KAAIA,QACA,OAAM;CACV,IAAI,SAAS,YAAY,KAAK;AAC9B,QAAO,MAAM;EACT,MAAM,MAAM,YAAY,KAAK;EAC7B,MAAMC,YAAU,MAAM;AACtB,WAAS;EACT,MAAM,IAAI,WAAWA;AACrB,MAAI,IAAI,IACJ,QAAO;AACX,MAAI,IAAI,IACJ,QAAO;AACX,SAAO;CACV;AACJ;;;;;;;AAOD,MAAa,YAAY,CAAC,QAAQ,UAAU,CAAE,MAAK;AAC/C,QAAO,UAAU,SAAS,IAAI,QAAQ;AACzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEvDD,MAAa,mBAAmB,CAAC,GAAG,MAAM,CAAC,MAAM;CAC7C,MAAM,IAAI,IAAI;CACd,MAAM,KAAK,IAAI;CACf,MAAM,KAAK,IAAI;CACf,MAAM,KAAK,KAAK;AAChB,QAAO,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,KAAK;AAC5C;;;;;;;;;;;;;;;;;;;;ACND,MAAa,QAAQ,CAAC,kBAAkB;CAEpC,IAAI,aAAa,YAAY,KAAK;CAClC,MAAM,SAAS,CAAC,IAAI,MAAM;EACtB,MAAMC,YAAU,YAAY,KAAK,GAAG;EACpC,MAAM,MAAO,gBAAgBA,YAAW;AACxC,eAAa,YAAY,KAAK;EAC9B,MAAM,QAAQ,IAAI,OAAO;AACzB,SAAO;CACV;CACD,MAAM,QAAQ,MAAM;AAChB,eAAa,YAAY,KAAK;CACjC;AACD,QAAO;EAAE;EAAQ;CAAO;AAC3B;;;;AC7BD,MAAMC,QAAM,KAAK;AAGjB,MAAM,YAAY,IAAI,KAAK,KAAK,IAAI,KAAK,GAAG;;;;;;;;;;;;;AAa5C,MAAa,WAAW,CAAC,oBAAoB,OAAQ;CAEjD,MAAM,OAAO;AACb,QAAO,CAAC,MAAM;EACV,MAAM,IAAI,YAAY;EAEtB,IAAI,IAAI;EACR,IAAI,KAAK,IAAI,QAAQ;AACrB,OAAK;AACL,OAAK;EACL,MAAM,IAAI,IAAI,MAAI,KAAK,GAAG,EAAE;AAC5B,MAAI,IAAI,EACJ,QAAO;AACX,MAAI,IAAI,EACJ,QAAO;AACX,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCD,MAAM,OAAO,KAAK;AAClB,MAAM,MAAM,KAAK;AACjB,MAAM,MAAM,KAAK;AACjB,MAAM,KAAK,KAAK;AAChB,MAAM,MAAM,KAAK;AACjB,MAAa,YAAY,CAAC,MAAM;CAC5B,MAAM,KAAK;CACX,MAAM,KAAK;AACX,KAAI,IAAI,IAAI,GACR,QAAO,KAAK,IAAI;UAEX,IAAI,IAAI,GACb,QAAO,MAAM,KAAK,MAAM,MAAM,IAAI;UAE7B,IAAI,MAAM,GACf,QAAO,MAAM,KAAK,OAAO,MAAM,IAAI;KAGnC,QAAO,MAAM,KAAK,QAAQ,MAAM,IAAI;AAE3C;AACD,MAAa,UAAU,CAAC,MAAM,IAAI,IAAI,IAAI,IAAI;AAC9C,MAAa,WAAW,CAAC,MAAM,IAAI,IAAI,IAAI,GAAG,EAAE;AAChD,MAAa,OAAO,CAAC,MAAM,KAAK,IAAI,KAAK;AACzC,MAAa,aAAa,CAAC,MAAM,IAAI,KAAK,IAAI,IAAI;AAClD,MAAa,eAAe,CAAC,OAAO,KAAK,IAAI,IAAI,MAAM,MAAM,IAAI,IAAI;AACrE,MAAa,SAAS,CAAC,MAAM,IAAI,IAAK,IAAI,KAAM,EAAE;AAClD,MAAa,UAAU,CAAC,MAAM,IAAK,IAAI,KAAM,EAAE;AAC/C,MAAa,SAAS,CAAC,MAAM,IAAI;AACjC,MAAa,UAAU,CAAC,MAAM,KAAK,IAAI,MAAM,IAAI;AACjD,MAAa,YAAY,CAAC,QAAQ,IAAI,KAAK,EAAE,GAAG,KAAK;AACrD,MAAa,YAAY,CAAC,MAAM,IAAI,KAAM,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,EAAE,GAAG;AAC/E,MAAa,UAAU,CAAC,MAAM,IAAI,IAAI;AACtC,MAAa,WAAW,CAAC,MAAM,IAAI,IAAI,IAAI,GAAG,EAAE;AAChD,MAAa,UAAU,CAAC,MAAM,IAAI,IAAI,IAAI;AAC1C,MAAa,WAAW,CAAC,MAAM,IAAI,IAAI,IAAI,GAAG,EAAE;AAChD,MAAa,SAAS,CAAC,MAAO,MAAM,IAAI,IAAI,IAAI,GAAG,KAAK,IAAI,GAAG;AAC/D,MAAa,UAAU,CAAC,MAAO,MAAM,IAAI,IAAI,IAAI,IAAI,GAAG,MAAM,EAAE;AAChE,MAAa,aAAa,CAAC,MAAM,IAAI,KAAM,KAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,EAAE,GAAG;AAC7F,MAAa,YAAY,CAAC,MAAM,MAAM,IAChC,IACA,MAAM,IACF,IAEA,IAAI,KACA,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,KACrB,IAAI,IAAI,GAAG,MAAM,IAAI,GAAG,IAAI;AAC3C,MAAa,SAAS,CAAC,MAAM,IAAI,KAAK,IAAI,IAAI,GAAG,EAAE,CAAC;AACpD,MAAa,UAAU,CAAC,MAAM,KAAK,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC;AACrD,MAAa,SAAS,CAAC,MAAM;CACzB,MAAM,KAAK;CACX,MAAM,KAAK,KAAK;AAChB,QAAO,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI;AACpC;AACD,MAAa,UAAU,CAAC,MAAM;CAC1B,MAAM,KAAK;CACX,MAAM,KAAK,KAAK;AAChB,QAAO,IAAI,KAAK,IAAI,IAAI,GAAG,EAAE,GAAG,KAAK,IAAI,IAAI,GAAG,EAAE;AACrD;AACD,MAAa,YAAY,CAAC,MAAM,IAAI,MAC7B,IAAI,KAAK,IAAI,IAAI,IAAI,GAAG,EAAE,CAAC,IAAI,KAC/B,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,EAAE,CAAC,GAAG,KAAK;AAC3C,MAAa,YAAY,CAAC,MAAM;CAC5B,MAAM,KAAK;CACX,MAAM,KAAK,KAAK;AAChB,QAAO,IAAI,KACJ,IAAI,IAAI,GAAG,EAAE,KAAK,KAAK,KAAK,IAAI,IAAI,MAAO,KAC3C,IAAI,IAAI,IAAI,GAAG,EAAE,KAAK,KAAK,MAAM,IAAI,IAAI,KAAK,MAAM,KAAK;AACnE;AACD,MAAa,YAAY,CAAC,MAAM;CAC5B,MAAM,KAAM,IAAI,KAAM;AACtB,QAAO,MAAM,IACP,IACC,MAAM,IACH,KACC,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,KAAK,IAAI,KAAK,SAAS,GAAG;AAC9D;AACD,MAAa,aAAa,CAAC,MAAM;CAC7B,MAAM,KAAM,IAAI,KAAM;AACtB,QAAO,MAAM,IACP,IACC,MAAM,IACH,IACA,IAAI,GAAG,MAAM,EAAE,GAAG,KAAK,IAAI,KAAK,OAAQ,GAAG,GAAG;AAC3D;AACD,MAAa,WAAW,CAAC,MAAM,IAAI,UAAU,IAAI,EAAE;AACnD,MAAa,OAAO,UAAU;AAC9B,MAAa,eAAe,CAAC,MAAM;CAC/B,MAAM,KAAM,IAAI,KAAM;AACtB,QAAO,MAAM,IACP,IACA,MAAM,IACF,IAEA,IAAI,OACE,IAAI,GAAG,KAAK,IAAI,GAAG,GAAG,KAAK,KAAK,IAAI,UAAU,GAAG,IAAI,IACtD,IAAI,GAAG,MAAM,IAAI,GAAG,GAAG,KAAK,KAAK,IAAI,UAAU,GAAG,GAAI,IAAI;AAC5E;AACD,MAAa,cAAc,CAAC,MAAM,IAAI,MAAO,IAAI,UAAU,IAAI,IAAI,EAAE,IAAI,KAAK,IAAI,UAAU,IAAI,IAAI,EAAE,IAAI;;;;;;;;;;AC5F1G,MAAa,OAAO,CAAC,OAAO,GAAG,OAAO,MAAM;CACxC,MAAM,MAAM;CACZ,MAAM,SAAS;EACX,GAAG,MAAM,MAAM,IAAI,GAAG,GAAG,IAAI;EAC7B,GAAG,MAAM,MAAM,IAAI,GAAG,KAAK,EAAE;CAChC;CAED,IAAI,SAAS,cAAmB,KAAK,IAAI,KAAK,SAAgB,OAAO;AAErE,KAAI,SAAS,KAAK,OAAO,EACrB,KAAI,OAAO,EACP,UAAS,cAAmB,MAAM,QAAQ;EAAE,GAAG;EAAG,GAAG,OAAO,IAAI;CAAG,EAAC;KAGpE,UAAS,cAAmB,MAAM,QAAQ;EAAE,GAAG,OAAO,IAAI;EAAG,GAAG;CAAG,EAAC;CAG5E,MAAM,MAAM,mBAAyC,QAAQ,OAAO;CACpE,MAAM,QAAQ,aAAqB,IAAI;AACvC,QAAO,CAAC,UAAU,MAAM,MAAM;AACjC;;;;;;;;;;;;;;;;;;;;;;;ACND,MAAaC,SAAO,CAAC,IAAI,aAAa;AAClC,aAAY,aAAa,KAAK,IAAI,CAAC;CACnC,IAAIC;AACJ,QAAO,MAAM;AACT,aAAWA,gBAAc,WACrB,cAAW,QAAa,UAAU,EAAE,YAAY,KAAM,EAAC;AAC3D,SAAO,GAAG,YAAU,CAAC;CACxB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;AAyBD,MAAa,gBAAgB,CAAC,IAAI,aAAa;AAC3C,aAAY,aAAa,KAAK,IAAI,CAAC;CACnC,MAAM,QAAQ,6BAAkC;CAChD,MAAM,aAAa,aAAa,SAAS;AACzC,KAAI,sBACA,OAAM,IAAI,OAAO;CACrB,MAAM,gBAAgB,SAAc,YAAY;EAC5C;EACA,YAAY;CACf,EAAC;AACF,QAAO,kBAAuB,IAAI,cAAc;AACnD;;;;;;;;;;;;;;;;;;;;AAoBD,MAAaC,UAAQ,CAAC,IAAI,eAAe;AACrC,aAAY,aAAa,KAAK,IAAI,CAAC;CACnC,IAAID;AACJ,QAAO,MAAM;AACT,aAAWA,gBAAc,WACrB,cAAW,aAAkB,YAAY,EAAE,YAAY,KAAM,EAAC;AAClE,SAAO,GAAG,YAAU,CAAC;CACxB;AACJ;;;;;;;;;;;;;;;;;;;;;;;AAuBD,MAAa,gBAAgB,CAAC,IAAI,kBAAkB;AAChD,aAAY,aAAa,KAAK,IAAI,CAAC;CACnC,MAAM,QAAQ,sBAA2B;CACzC,MAAM,gBAAgB,SAAc,eAAe;EAC/C;EACA,YAAY;CACf,EAAC;AACF,QAAO,kBAAuB,IAAI,cAAc;AACnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtGD,MAAa,SAAS,CAAC,YAAY;CAC/B,MAAM,OAAO,kBAAkB,QAAQ,SAAS,SAAS;CACzD,MAAM,KAAK,QAAQ,QAAQ;AAC3B,YAAW,QAAQ,WACf,OAAM,IAAI,OAAO;AACrB,MAAK,aAAa,QACd,QAAO,KAAK,IAAI,QAAQ,SAAS;WAE3B,UAAU,QAChB,QAAO,MAAM,IAAI,QAAQ,MAAM;KAG/B,OAAM,IAAI,OAAO;AAExB;;;;;;;;;;;;;;;;;;;;;;;;AAwBD,MAAa,aAAa,CAAC,gBAAgB,aAAa;CACpD,MAAM,KAAK,kBAAkB,eAAe;AAC5C,QAAO,cAA0B,IAAI,SAAS;AAWjD;;;;;;;;;;;;;;;;;;;;;AAqBD,MAAa,OAAO,CAAC,gBAAgB,aAAa;CAC9C,MAAM,KAAK,kBAAkB,eAAe;AAC5C,QAAO,OAAiB,IAAI,SAAS;AAMxC;;;;;;;;;;;;;;;;;;;;;AAqBD,MAAa,QAAQ,CAAC,gBAAgB,eAAe;CACjD,MAAM,KAAK,kBAAkB,eAAe;AAC5C,QAAO,QAAkB,IAAI,WAAW;AAM3C;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,aAAa,CAAC,gBAAgB,kBAAkB;CACzD,MAAM,KAAK,kBAAkB,eAAe;AAC5C,QAAO,cAA0B,IAAI,cAAc;AAStD;AACD,MAAM,oBAAoB,CAAC,mBAAmB;CAC1C,MAAM,YAAY,oBAAoB,YAAY,iBAAiB,IAAI,eAAe;AACtF,YAAW,QAAQ,YAAY;EAC3B,MAAM,eAAe,oBAAoB,UAAU,IAAI,OAAO,8BAA8B,eAAe,MAAM,IAAI,OAAO;AAC5H,QAAM;CACT;AACD,QAAO;AACV;;;;;;;;;;;;;AAwDD,IAAI;;;;;;;;;;;;;;AAcJ,MAAa,MAAM,SAAU,YAAY;AACrC,aAAY,WAAW,aAAa,aAAa,YAAY,CAAC;CAC9D,MAAM,QAAQ,cAAc,CAAC,IAAI,WAAW,aAAa,CAAC;AAC1D,KAAI,iBACA,OAAM,IAAI,OAAO,qBAAqB,WAAW;AACrD,QAAO;AACV;AAED,SAAS,eAAe;AACpB,KAAI,uBAA0B;AAC1B,eAAa,IAAI;AACjB,OAAK,MAAM,CAAC,GAAG,EAAE,IAAI,OAAO,QAAQE,sBAAM,CACtC,YAAW,IAAI,EAAE,aAAa,EAAE,EAAE;AAEtC,SAAO;CACV,MAEG,QAAO;AACd;;;;;;AAMD,UAAiB,iBAAiB;CAC9B,MAAM,MAAM,cAAc;AAC1B,QAAO,IAAI,MAAM;AACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChQD,MAAaC,UAAQ,CAAC,GAAG,QAAQ,OAAO;AACpC,KAAI,aACA,OAAM,IAAI,OAAO,YAAY,KAAK;AAEtC,KAAI,MAAM,KACN,OAAM,IAAI,OAAO,YAAY,KAAK;AAEtC,YAAW,OAAO,QACd,OAAM,IAAI,WAAW,YAAY,KAAK,kBAAkB,EAAE;AAEjE;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BD,MAAa,kBAAkB,CAAC,QAAQ,SAAS,MAAM;AACnD,MAAK,OACD,UAAS;EAAE,OAAO;EAAG,QAAQ;CAAG;CACpC,MAAM,OAAO,SAAe,SAAS,MAAM;CAC3C,MAAM,OAAO,SAAe,SAAS,OAAO;CAC5C,MAAM,OAAO,SAAe,SAAS,KAAK;CAC1C,MAAM,OAAO,SAAe,SAAS,QAAQ;AAC7C,QAAO,CAAC,MAAM;EACV,MAAM,WAAW,4BAA4B,EAAE,mBAA0B,EAAE,kBAAyB;EACpG,IAAI,WAAW,EAAE;EACjB,IAAI,EAAE,GAAG,GAAG,GAAG;AACf,MAAI,IAAI,MAAM;AACV,OAAI;AACJ,cAAW,OAAc,eAAsB,UAAU,OAAO,GAAG,GAAG;EACzE,WACQ,IAAI,MAAM;AACf,OAAI;AACJ,cAAW,OAAc,eAAsB,UAAU,OAAO,GAAG,GAAG;EACzE;AACD,MAAI,IAAI,MAAM;AACV,OAAI;AACJ,cAAW,eAAsB,OAAc,WAAW,GAAG,EAAE,OAAO;EACzE,WACQ,SAAS,IAAI,MAAM;AACxB,OAAI;AACJ,cAAW,OAAc,eAAsB,UAAU,OAAO,GAAG,GAAG;EACzE;AACD,SAAO,OAAO,OAAO;GACjB,GAAG;GACH,UAAU;IAAE;IAAG;GAAG;GAClB;EACH,EAAC;CACL;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;AAyBD,MAAa,kBAAkB,CAAC,YAAY,SAAS,gBAAgB,CAAE,MAAK,CAAC,cAAc;CACvF,IAAI,QAAQ,UAAU;AACtB,MAAK,MAAM,KAAK,YAAY;AACxB,MAAI,MAAM,UACN;EACJ,MAAM,IAAI,uBAAuB,GAAG,WAAW,SAAS,cAAc;AACtE,UAAQ,IAAW,OAAO,EAAE;CAC/B;AACD,QAAO;EACH,GAAG;EACH,cAAc;CACjB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0CD,MAAa,yBAAyB,CAAC,WAAW,WAAW,SAAS,gBAAgB,CAAE,MAAK;AACzF,KAAI,UAAU,oBACV,OAAM,IAAI,OAAO;AAErB,KAAI,UAAU,oBACV,OAAM,IAAI,OAAO;CAErB,MAAM,uBAAuB,cAAc,OAAO;CAClD,MAAM,uBAAuB,cAAc,OAAO;CAElD,MAAM,IAAI,UAAiB,SAAgB,UAAU,UAAU,UAAU,SAAS,CAAC;CAEnF,MAAM,IAAI,MAAM,SAAgB,EAAE,EAAE,sBAAsB,qBAAqB;AAE/E,QAAO,eAAsB,GAAI,WAAW,UAAU,QAAQ,MAAM,UAAU,QAAQ,MAAO,IAAI,GAAG;AACvG;;;;;;;;;;;AAWD,MAAa,cAAc,CAAC,WAAW,OAAO,CAAE,MAAK;CACjD,MAAM,KAAK,CAAC,MAAM;EACd,MAAM,QAAQ,4BAA4B,WAAW,EAAE,YAAY;GAAE,GAAG;GAAK,GAAG;EAAK,GAAE,KAAK;AAC5F,SAAO;GACH,GAAG;GACH,cAAc,IAAW,EAAE,uBAA8B,MAAM;EAClE;CACJ;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CD,MAAa,QAAQ,CAAC,GAAG,GAAG,gBAAgB;AACxC,KAAI,aACA,OAAM,IAAI,OAAO;AACrB,MAAK,MAAM,KAAK,aAAa;AACzB,MAAI,MAAM,QAAQ,aACd;AACJ,aAAW,OAAO,YAAY,EAAE,EAAE,GAAG;GACjC,GAAG;GACH,cAAc,IAAW,EAAE,uBAA8B,EAAE;EAC9D;CACJ;CAED,MAAM,OAAO,gBAAgB,EAAE,uBAA8B,EAAE,kBAAyB;CAExF,MAAM,MAAM,4BAA4B,EAAE,mBAA0B,KAAK;CACzE,MAAM,KAAK;EACP,GAAG;EACH,UAAU;EACV,UAAU;EAEV;CACH;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,oBAAoB,CAAC,QAAQ,QAAQ,aAAa,CAAC,MAAM,OAAO,OAAO;CAChF,GAAG;CACH,cAAc,eAAe,QAAQ,GAAG,KAAK;AAChD,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BF,MAAM,iBAAiB,CAAC,QAAQ,OAAO,QAAQ,aAAa;CACxD,IAAI;AACJ,SAAQ,MAAR;EACI,MAAM,SAAS;AACX,QAAK,CAACC,WAAS,OAAc,QAAQA,QAAMA,OAAK;AAChD;EACH;EACD,MAAM,WAAW;AACb,QAAK,CAACA,WAAS,SAAgB,QAAQA,QAAMA,OAAK;AAClD;EACH;EACD,MAAM,UAAU;AACZ,QAAK,CAAC,UAAU;AAChB;EACH;EACD,QACI,OAAM,IAAI,OAAO,4BAA4B,KAAK;CAEzD;AACD,QAAO,IAAW,MAAM,uBAA8B,GAAG,MAAM,QAAQ,EAAE,CAAC;AAM7E;;;;;;;;;;;;;;;;;;;AAmBD,MAAa,iBAAiB,CAAC,OAAO,QAAQ,aAAa,CAAC,MAAM;AAC9D,KAAI,EAAE,oBACF,QAAO;CACX,MAAM,MAAM,SAAgB,UAAiB,EAAE,SAAS,CAAC;CACzD,MAAM,QAAQ,QAAQ,MAAM;CAC5B,MAAM,KAAK,eAAsB,OAAc,EAAE,SAAS,EAAE,MAAM;AAClE,QAAO,OAAO,OAAO;EACjB,GAAG;EACH,cAAc,eAAe,IAAI,GAAG,KAAK;CAC5C,EAAC;AACL;;;;;AAKD,MAAa,YAAY,CAAC,MAAM;;;;;;;;;;;;;;;AAehC,MAAa,gBAAgB,CAAC,OAAO,SAAS;CAE1C,MAAMC,aAAW,iBAEF,CAAC,MAAM,eAAsB,GAAG,MAAM,CAAC;AACtD,QAAO,CAAC,MAAM;AACV,MAAI,EAAE,oBACF,QAAO;EAEX,MAAM,IAAI,WAAS,EAAE,SAAS;AAC9B,SAAO,OAAO,OAAO;GACjB,GAAG;GACH,cAAc,eAAe,GAAG,GAAG,KAAK;EAC3C,EAAC;CACL;AACJ;;;;;;AAMD,MAAa,eAAe,MAAM,CAAC,MAAM;CACrC,MAAM,cAAc,EAAE,uBAAuB;CAC7C,MAAM,MAAM,EAAE,mBAAmB;CACjC,MAAM,QAAQ,EAAE,SAAS;CACzB,MAAM,IAAI,MAAM;CAChB,MAAM,IAAI,QAAQ;AAClB,QAAO,OAAO,OAAO;EACjB,GAAG;EACH,OAAO;EACP,iBAAiB;EACjB,qBAAqB;CACxB,EAAC;AACL;;;;;;AAYD,MAAa,6BAA6B,CAAC,UAAU,OAAO,CAAC,MAAM;CAC/D,MAAM,QAAQ,EAAE;AAChB,QAAO,OAAO,OAAO;EACjB,GAAG;EACH,qBAAqB,MAAM,IAAI;CAClC,EAAC;AACL;;;;;;;AAOD,MAAa,yBAAyB,CAAC,iBAAiB,MAAM,CAAC,MAAM;CACjE,MAAM,IAAI,YAAmB,EAAE,kBAAyB;AACxD,QAAO,OAAO,OAAO;EACjB,GAAG;EACH,OAAO,iBAAiB,IAClB,iBAAiB,gBAAgB,EAAE,SAAS,GAAG,EAAE,GACjD;CACT,EAAC;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BD,MAAa,cAAc,CAAC,UAAU,gBAAgB,IAAK,IAAI,MAAQ,UAAU,SAAU,CAAC,MAAM;CAC9F,MAAM,YAAY,SAAgB,EAAE,mBAA0B,SAAS;CACvE,MAAM,MAAM,SAAgB,UAAU;CACtC,MAAM,UAAU,KAAK,IAAI,gBAAgB,IAAI;CAC7C,MAAM,IAAI,cAAqB,sBAA6B,CAAC,MAAM,eAAsB,IAAI,IAAI,QAAQ,CAAC;CAC1G,MAAM,QAAQ,eAAe,GAAG,IAAI,QAAQ;CAC5C,MAAM,OAAO,gBAAgB,gBAAuB,EAAE,kBAAyB;CAC/E,MAAM,aAAa,SAAgB,MAAM,SAAS,QAAQ;AAC1D,QAAO;EACH,GAAG;EACH,UAAU;EACV;CACH;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BD,MAAa,gBAAgB,CAAC,UAAU,OAAO,CAAE,MAAK,CAAC,MAAM;AACzD,MAAK,SACD,YAAW;EAAE,GAAG;EAAG,GAAG;CAAG;CAC7B,MAAM,SAAS,KAAK,UAAU,SAAgB,UAAU,EAAE,kBAAyB;CACnF,MAAM,QAAQ,KAAK,SAAS;CAC5B,MAAM,UAAU,KAAK,WAAW;CAChC,IAAI,QAAQ,EAAE;AACd,KAAI,iBACA,KAAI,EAAE,SACF,SAAQ,YAAmB,UAAU,EAAE,SAAS,GAAG,KAAK,KAAK;KAG7D,SAAQ;CAGhB,MAAM,QAAU,KAAK,QAAS,SAAU,KAAK,IAAI,MAAM;CACvD,MAAM,KAAK,EAAE,mBAAmB,KAAK;AACrC,UAAS;AACT,QAAO,OAAO,OAAO;EACjB,iBAAiB,IAAI;EACrB;EACA,UAAU,yBAAyB,QAAQ,QAAQ,KAAK,KAAK,GAAG,SAAS;CAC5E,EAAC;AACL;;;;;;;;AAQD,MAAa,kBAAkB,CAAC,cAAc,UAAU,gBAAgB;CACpE,MAAM,IAAI,IAAW,UAAU,aAAa;AAC5C,QAAO,yBAA4B,IAAI,eAAsB,GAAG,YAAY;AAC/E;;;;;;;;;;;;;;;;;;;;;;;AAuBD,MAAa,8BAA8B,CAAC,WAAW,YAAY,OAAO,CAAE,MAAK;CAC7E,MAAM,aAAa,KAAK,cAAc;CAEtC,MAAM,YAAY,SAAgB,WAAW,WAAW;AACxD,KAAI,KAAK,SACL,QAAe,IAAW,UAAU,EAAE,KAAK,MAAM,KAAK,GACtD;AAGJ,QAAO,eAAsB,WAAW,WAAW;AACtD;;;;;;;AAOD,MAAa,8BAA8B,CAAC,UAAU,aAAa,IAAW,UAAU,SAAS;;;;;;;;AAQjG,MAAa,2BAA2B,CAACC,YAAU,cAAc,WAAW,YAAkBA,YAAU,cAAc,OAAO;AAC7H,MAAM,gBAAgB,cAAc;AACpC,MAAM,8BAA8B,4BAA4B;;;;;;;;;;;AAWhE,MAAa,mBAAmB,CAAC,mBAAmB,OAAQ;CACxD,MAAM,eAAe,uBAAuB,iBAAiB;AAC7D,QAAO,CAAC,MAAM;AACV,MAAI,cAAc,EAAE;AACpB,MAAI,4BAA4B,EAAE;AAClC,MAAI,aAAa,EAAE;AACnB,SAAO;CACV;AACJ;;;;ACxnBD,MAAaC,SAAO,KAAK,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqC9B,SAAgBC,cAAY,MAAM,MAAM,MAAM,MAAM;CAChD,IAAI;CACJ,IAAI,UAAU;CACd,MAAM,eAAe,CAAC,WAAW;AAC7B,MAAI,cACA,UAAS,cAAc,OAAO;AAClC,MAAI,qBAAwB,YAAY,OACpC,UAAS,MAAM,OAAO;WAEjB,YAAY,OACjB;OAAI,SAAS,EACT,UAAS,SAAS;YACb,SAAS,EACd,UAAS,IAAK,SAAS;EAC1B;AAEL,SAAO;CACV;CACD,MAAM,YAAY,CAAC,MAAM,IAAI,OAAO;AAChC,cAAY,WAAW,KAAK,IAAI,GAAG,EAAE,WAAW,KAAK,IAAI,GAAG,EAAE,WAAW,OAAO,IAAI,QAAQ,CAAC;AAC7F,SAAO,aAAa,KAAK;AACzB,UAAQ,IAAI,QAAQ,KAAK,OAAO;CACnC;CACD,MAAM,WAAW,CAAC,IAAI,CAAE,MAAK;AACzB,MAAI,EAAE,QAAQ;GACV,MAAM,QAAQ,IAAU,EAAE,OAAO;AACjC,QAAK,MACD,OAAM,IAAI,OAAO,mBAAmB,EAAE,OAAO;AACjD,mBAAgB;EACnB,WACQ,EAAE,WAAW;AAClB,cAAW,EAAE,eAAe,UACxB,OAAM,IAAI,OAAO,8DAA8D,EAAE,UAAU;AAC/F,mBAAgB,EAAE;EACrB;AACD,WAAS,EAAE,WAAW;CACzB;CACD,MAAM,UAAU,CAAC,MAAM,IAAI,QAAQ,IAAI,QAAQ,KAAK,OAAO;AAC3D,YAAW,UAAU,QACjB,OAAM,IAAI,WAAW,sDAAsD,KAAK;AACpF,YAAW,UAAU,SAAS;EAC1B,IAAI;EACJ,IAAI;AACJ,MAAI,0BAA6B,UAAU,SAAS;AAEhD,OAAI;AACJ,OAAI;AACJ,YAAS,KAAK;AACd,UAAO,CAAC,WAAW,UAAU,QAAQ,GAAG,EAAE;EAC7C,kBACe,UAAU,SAAS;AAE/B,OAAI;AACJ,OAAI;AACJ,YAAS,KAAK;AACd,UAAO,UAAU,MAAM,GAAG,EAAE;EAC/B,MAEG,OAAM,IAAI,OAAO;CAExB,WACQ,0BAA6B,UAAU,SAAS;EAErD,MAAM,SAAS,aAAa,KAAK;AACjC,WAAS,KAAK;AACd,cAAY,WAAW,SAAS,IAAI,QAAQ,CAAC;AAC7C,SAAO,CAAC,QAAQ,WAAW,QAAQ,QAAQ,QAAQ,OAAO;CAC7D;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCD,MAAa,sBAAsB,CAAC,iBAAiB,IAAI,GAAG,IAAI,GAAG,uBAAuB,GAAG,YAAY;CACrG,IAAI,SAAS;AACb,QAAO,CAAC,WAAW,cAAc;AAC7B,MAAI,qBACA,KAAI;AACR,MAAI,qBACA,KAAI;AACR,MAAI,UAAU,EACV,QAAO;EACX,MAAM,QAAQ,cAAY,QAAQ,GAAG,GAAG,QAAQ;AAChD,YAAU;AACV,SAAO;CACV;AACJ;;;;;;;;;;;;;AAaD,MAAaC,qBAAmB,CAAC,QAAQ,UAAU,UAAU,YAAY;CACrE,MAAM,IAAI,KAAK,WAAW,UAAU,GAAGC,OAAK;AAC5C,QAAO,cAAY,QAAQ,UAAU,YAAY,IAAI,KAAK,KAAK,IAAIA,SAAO,IAAI,QAAQ;AACzF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BD,MAAa,uBAAuB,CAAC,UAAU,IAAI,GAAG,IAAI,GAAG,YAAY;CACrE,MAAM,sBAAsB,QAAQ,UAAU,EAAE,YAAY,KAAM,EAAC;AACnE,QAAO,CAAC,WAAW,cAAc;EAC7B,MAAM,SAAS,qBAAqB;AACpC,MAAI,qBACA,KAAI;AACR,MAAI,qBACA,KAAI;AACR,MAAI,UAAU,EACV,QAAO;EACX,MAAM,QAAQ,cAAY,QAAQ,GAAG,GAAG,QAAQ;AAChD,SAAO;CACV;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChLD,MAAa,iBAAiB,CAAC,YAAY;CACvC,MAAM,EAAE,sBAAU,UAAU,GAAG;CAC/B,MAAM,UAAU,QAAQ,WAAW;CACnC,MAAM,SAAS,QAAQ,UAAU,KAAK;AACtC,KAAI,oBACA,QAAO,CAAC,UAAU;EACd,MAAMC,QAAO,QAAQ,GAAG,WAAW,IAAK;EACxC,MAAM,WAAW,QAAQA;AACzB,MAAI,QACA,QAAO,MAAM,UAAU,GAAG,MAAM;AACpC,SAAO;CACV;AAEL,KAAIC,sBACA,QAAO,CAAC,UAAU;EACd,MAAM,MAAM,QAAQA;EACpB,MAAMD,QAAO,QAAQ,GAAG,MAAM,IAAK;EACnC,MAAM,WAAW,QAAQA;AACzB,MAAI,QACA,QAAO,MAAM,UAAU,GAAG,MAAM;AACpC,SAAO;CACV;AAEL,OAAM,IAAI,OAAO;AACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCD,MAAa,SAAS,CAAC,UAAU,CAAE,MAAK;CACpC,MAAM,UAAU,QAAQ,WAAW;CACnC,IAAI,IAAI,CAAC,MAAM;AACf,KAAI,QAAQ,qBAAwB;AAChC,cAAY,WAAW,QAAQ,UAAU,WAAW,eAAe,WAAW,eAAe,CAAC;EAC9F,MAAM,UAAU,YAAoB;GAChC,MAAM,QAAQ;GACd,KAAK,QAAQ;GACb,QAAQ,QAAQ;EACnB,EAAC;AACF,MAAI,CAAC,MAAM,IAAI,SAAS;CAC3B,WACQ,QAAQ,oBACb,OAAM,IAAI,WAAW;MAEpB;EACD,MAAM,MAAM,QAAQ,YAAY;AAChC,cAAY,WAAW,KAAK,WAAW,eAAe,WAAW,eAAe,CAAC;AACjF,MAAI,CAAC,MAAM,IACP,MAAY;GACR,MAAM,KAAK,IAAI,MAAM,EAAE;GACvB,KAAK,KAAK,IAAI,MAAM,EAAE;GACtB,QAAQ,QAAQ;EACnB,EAAC;CACT;CACD,MAAM,UAAU,CAAC,UAAU;AACvB,cAAY,WAAW,OAAO,WAAW,eAAe,WAAW,OAAO,CAAC;EAC3E,IAAI,IAAI,EAAE,MAAM;AAChB,MAAI,QACA,KAAI,MAAM,EAAE;AAChB,SAAO;CACV;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7GD,MAAa,MAAM,CAAC,QAAQ,UAAU,eAAe;CACjD,MAAM,IAAI,aAAa;CACvB,MAAM,QAAQ,IAAI,UAAU;AAC5B,QAAO,OAAQ,WAAW;AAC7B;;;;;;;;;;;;;;;;;;AAkBD,MAAa,gBAAgB,CAAC,SAAS,GAAG,MAAM,CAAC,QAAQ,YAAY,SAAS,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC;;;;;;;;;;;;;;;;;;;;;AAqB7F,MAAa,YAAY,CAAC,GAAG,MAAM;AAC/B,QAAO,CAAC,QAAQ;EACZ,MAAM,QAAQ,cAAc,KAAK,GAAG,EAAE;AACtC,SAAO,MAAM,IAAI;CACpB;AACJ;;;;;;;;;;AClED,MAAa,OAAO,CAAC,MAAM;;;;;;;;;;;;ACL3B,MAAM,OAAO,KAAK,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BvB,UAAiB,KAAK,aAAa;AAC/B,KAAI,uBACA,OAAM,IAAI,WAAW;AACzB,YAAW,iBAAiB,QACxB,eAAc,eAAoB,YAAY;AAElD,QAAO,KAEH,QAAO,KAAK,IAAI,YAAY,UAAU,KAAK,GAAG,KAAK;AAE1D;;;;;AAKD,UAAiB,YAAY,aAAa;AACtC,KAAI,uBACA,OAAM,IAAI,WAAW;AACzB,YAAW,iBAAiB,QACxB,eAAc,eAAoB,YAAY;AAElD,QAAO,KACH,OAAM,KAAK,IAAI,YAAY,UAAU,KAAK;AAEjD;;;;;;;;;;;;;AAaD,UAAiB,SAAS,aAAa;AACnC,YAAW,iBAAiB,QACxB,eAAc,eAAoB,YAAY;AAElD,QAAO,MAAM;EAGT,IAAI,IAAI,YAAY;AAEpB,MAAI,IAAI,GAEJ,MAAK;MAIL,KAAI,IAAI,IAAI;AAEhB,QAAM;CACT;AACJ;;;;;;;;;;;;;;;;;AAiBD,UAAiB,IAAI,aAAa;AAC9B,KAAI,uBACA,OAAM,IAAI,WAAW;AACzB,YAAW,iBAAiB,QACxB,eAAc,eAAoB,YAAY;AAElD,QAAO,KACH,OAAM,YAAY;AAEzB;;;;;;;;;;;;;;;AAeD,UAAiB,OAAO,aAAa;AACjC,YAAW,iBAAiB,QACxB,eAAc,eAAoB,YAAY;AAElD,QAAO,KACH,OAAM,YAAY,UAAU,KAAM,IAAI;AAE7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtGD,MAAa,kBAAkB,SAAU,WAAW,IAAK,OAAO,OAAO,OAAO,UAAU;AACpF,YAAW,WAAW,WAClB,SAAQ;AACZ,YAAW,WAAW,WAClB,SAAQ;AACZ,YAAW,WAAW,WAClB,SAAQ;AACZ,aAAY,WAAW,WAAW,WAAW,UAAU,EAAE,WAAW,QAAQ,WAAW,KAAK,EAAE,WAAW,QAAQ,WAAW,QAAQ,EAAE,WAAW,QAAQ,WAAW,OAAO,CAAC;AAC5K,QAAO,SAAS,UAAU,OAAO,OAAO,OAAO,SAAS;AAC3D;;;;;;;;;;;;;;;;;;;;;;AAsBD,MAAa,WAAW,WAAW,UAAU,OAAO,OAAO,OAAO,UAAU;AACxE,KAAI,iBACA,OAAM,IAAI,OAAO;AACrB,KAAI,oBACA,OAAM,IAAI,OAAO;AAErB,KAAI,iBACA,OAAM,IAAI,OAAO;AACrB,KAAI,uBAA0B,YAAY,KAAK,YAAY,EACvD,YAAW,KAAK;iBAEJ,cAAc,WAC1B,YAAW;AACf,KAAI,OAAO,MAAM,SAAS,CACtB,OAAM,IAAI,OAAO;AACrB,KAAI,OAAO,MAAM,MAAM,CACnB,OAAM,IAAI,OAAO;AACrB,KAAI,OAAO,MAAM,MAAM,CACnB,OAAM,IAAI,OAAO;AACrB,KAAI,OAAO,MAAM,MAAM,CACnB,OAAM,IAAI,OAAO;AACrB,KAAI,SAAS,MACT,OAAM,IAAI,OAAO;AACrB,KAAI,aAAa,EACb,OAAM,IAAI,OAAO;CACrB,MAAME,aAAW,QAAQ;AACzB,KAAI,KAAK,IAAI,SAAS,IAAIA,WACtB,OAAM,IAAI,OAAO,8BAA8BA,WAAS,OAAOA,WAAS;CAE5E,IAAI,eAAe,WAAW;AAE9B,SAAQ,KAAK,MAAM,QAAQ,SAAS;AACpC,SAAQ,KAAK,MAAM,QAAQ,SAAS;AACpC,YAAW,KAAK,MAAM,KAAK,IAAI,WAAW,SAAS,CAAC;AACpD,KAAI,aAAa,EACb,OAAM,IAAI,OAAO,8BAA8B,SAAS;AAE5D,SAAQ,mBAAsB,QAAQ,KAAK,MAAM,QAAQ,SAAS;AAClE,KAAI,QAAQ,SAAS,QAAQ,MACzB,OAAM,IAAI,OAAO,SAAS,QAAQ,SAAS,0BAA0B,QAAQ,SAAS,eAAe,QAAQ,SAAS;CAE1H,IAAI,IAAI;AACR,OAAM,IAAI;CACV,IAAI,YAAY;AAChB,QAAO,MAAM;AACT,MAAI,KAAK,eAAe,YAAY;AACpC,MAAI,gBAAgB,KAAK,OAAO;AAC5B,kBAAe;AACf,OAAI;AACJ,OAAI,MAAM,SAAS,WAAW;AAE1B,QAAI;AACJ,mBAAe;GAClB;EACJ,YACS,gBAAgB,KAAK,OAAO;AAClC,kBAAe;AACf,OAAI;AACJ,OAAI,MAAM,SAAS,WAAW;AAE1B,QAAI;AACJ,mBAAe;GAClB;EACJ;AACD,QAAM,IAAI;AACV,cAAY;CACf;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5FD,UAAiB,OAAO,OAAO,CAAE,GAAE,aAAa;AAC5C,KAAI,uBACA,eAAc,6BAAkC;iBACpC,iBAAiB,QAC7B,eAAc,eAAoB,YAAY;CAElD,MAAM,KAAK,YAAY,KAAK;CAE5B,IAAI,gBAAgB,KAAK,aAAa;AACtC,QAAO,gBAAgB,GAAG;EACtB,MAAM,IAAI,GAAG,YAAY,UAAU,IAAK;AACxC,QAAM;AACN,MAAI,MAAM,EACN;MAGA,iBAAgB;CAEvB;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CD,SAAgB,YAAY,OAAO,CAAE,GAAE,aAAa;CAChD,MAAM,IAAI,OAAO,MAAM,YAAY;AACnC,QAAO,MAAM;EACT,MAAM,IAAI,EAAE,MAAM;AAClB,MAAI,EAAE,KACF,QAAO;AACX,SAAO,EAAE;CACZ;AACJ;;;;;;;;AAQD,MAAa,cAAc,CAAC,OAAO,CAAE,MAAK;;CAEtC,MAAM,OAAO;CACb,MAAMC,OAAK;CACX,MAAM,OAAO,KAAK,QAAQ;CAC1B,MAAM,YAAY,KAAK,aAAa;CACpC,MAAM,OAAO,KAAK,QAAQ;CAC1B,MAAM,UAAU,KAAK,WAAW;CAChC,MAAM,WAAW,KAAK,YAAY;CAClC,MAAM,QAAQA,OAAK;AACnB,KAAI,QAAQ,KAAK,WAAW,IAAI,KAAK,KAAK,YAAY,KAAK,GAAG;EAC1D,MAAM,oBAAoB,KAAK,KAAK,YAAY,KAAK;EACrD,MAAM,YAAY,mBAAmB,QAAQ;AAC7C,SAAO,CAAC,MAAMA,QAAM,QAAQ,IAAI,YAAY,KAAK,MAAM,IAAI;CAC9D,OACI;EACD,MAAM,mBAAmB,KAAK,KAAK,IAAI,OAAO,YAAY,WAAW,EAAE;EACvE,MAAM,YAAY,UAAU,QAAQ,IAAI,OAAO,YAAY;EAC3D,MAAM,MAAO,KAAM,mBAAoB;EACvC,MAAM,OAAO,KAAM,WAAW;AAC9B,SAAO,CAAC,MAAMA,QACT,KAAK,IAAI,IAAI,IAAI,GAAG,QAAQ,KAAK,IAAI,IAAI,IAAI,GAAG,YAC7C,KAAK,MAAM,IAAI;CAC1B;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GD,MAAa,sBAAsB,CAAC,QAAQ,UAAU,UAAU,CAAE,MAAK;AACnE,SAAQ,QAAR;EACI,MAAM,SACF,QAAO,MAAM,QAAoB,UAAU,QAAQ;EACvD,MAAM,KACF,QAAO,MAAM,IAAgB,UAAU,QAAQ;EACnD,MAAM,OACF,QAAO,MAAM,MAAkB,UAAU,QAAQ;EACrD,QACI,OAAM,IAAI,OAAO,kBAAkB,OAAO;CACjD;AACJ;;;;;;;;;;;;;AC5BD,SAAgB,cAAc,SAAS,GAAG;AACtC,UAAS,IAAI;CACb,MAAM,aAAa,SAAS;AAC5B,QAAO,CAAC,MAAM;EACV,MAAM,IAAI,KAAK,IAAK,IAAI,SAAU,WAAW;AAE7C,SAAO;CACV;AACJ;;;;;;;;;AASD,SAAgB,YAAY,SAAS,GAAG;AACpC,UAAS,IAAI;CACb,MAAM,aAAa,SAAS;AAC5B,QAAO,CAAC,MAAM;AACV,SAAQ,IAAI,SAAU,aAAa,IAAI;CAG1C;AACJ;;;;;;;;;;;;;;;;;;;;;;;AAuBD,SAAgB,UAAU,SAAS,GAAG;AAClC,UAAS,UAAU,KAAK,KAAK;AAC7B,QAAO,CAAC,MAAM;EACV,MAAM,KAAK,KAAK,IAAI,IAAI,OAAO,GAAG,KAAK;AAEvC,SAAO;CACV;AACJ;;;;;;AAMD,SAAgB,SAAS,SAAS,GAAG;AACjC,UAAS,UAAU,KAAK,KAAK;AAC7B,QAAO,CAAC,MAAM,KAAK,IAAI,KAAK,IAAI,IAAI,OAAO,CAAC;AAC/C;AACD,SAAgB,iBAAiB,SAAS,GAAG;AACzC,UAAS,UAAU,KAAK,KAAK;AAC7B,QAAO,CAAC,MAAM,KAAK,IAAI,IAAI,OAAO;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BD,SAAgB,KAAK,SAAS;CAC1B,MAAM,QAAQ,QAAQ,UAAU;CAChC,MAAMC,WAAS,QAAQ,UAAU;CACjC,MAAM,SAAS,QAAQ,UAAU;CACjC,IAAI;AACJ,aAAY,YAAY,SAAS,aAAa,QAAQ,CAAC;CACvD,MAAM,gBAAgB,EAClB,GAAG,QACN;AACD,KAAI,QAAQ,MACR,kBAAiB,QAAc,QAAQ,OAAO,cAAc;UAEvD,QAAQ,MACb,kBAAiB,MAAc,QAAQ,OAAO,cAAc;UAEvD,QAAQ,OACb,kBAAiB,QAAgB,QAAQ,QAAQ,cAAc;UAE1D,QAAQ,OACb,kBAAiB,QAAQ;MAExB;EACD,MAAM,OAAO,QAAQ,QAAQ;AAC7B,mBAAiB,QAAgB,OAAO,KAAM,cAAc;CAC/D;CACD,IAAI;AACJ,SAAQ,OAAR;EACI,MAAM;AACF,oBAAiB,CAAC,MAAM;AACxB;EACJ,MAAM;AACF,oBAAiB,UAAU,OAAO;AAClC;EACJ,MAAM;AACF,oBAAiB,iBAAiB,OAAO;AACzC;EACJ,MAAM;AACF,oBAAiB,YAAY,OAAO;AACpC;EACJ,MAAM;AACF,oBAAiB,cAAc,OAAO;AACtC;EACJ,MAAM;AACF,oBAAiB,SAAS,OAAO;AACjC;EACJ,QACI,OAAM,IAAI,OAAO,sBAAsB,MAAM;CACpD;AACD,QAAO,eAAe,gBAAgB,gBAAgBA,SAAO;AAChE;;;;;;;AAOD,SAAgB,eAAe,gBAAgB,gBAAgBA,WAAS,OAAO;AAC3E,QAAO,CAAC,aAAa;EACjB,IAAI,IAAI,eAAe,UAAU,MAAM;AACvC,MAAI,UAAU,SACV,KAAI,SAAS;AACjB,MAAI,eAAe,EAAE;AACrB,MAAIA,SACA,KAAI,IAAI;AACZ,SAAO;CACV;AACJ;;;;;;;;;;;;ACxKD,MAAa,kBAAkB,CAAC,cAAc,aAAa,mBAAmB;AAC1E,SAAS,gBAAgB,iBAAiB,KAAM,eAAe;AAClE;;;;;;;;;;;;;;;;;;;ACMD,MAAa,WAAW,CAAC,uBAAuB,YAAY,eAAe,oBAAoB,EAAE;;;;;;;;;;;;;;;;;;AAkBjG,MAAa,iBAAiB,CAAC,uBAAuB,YAAY;CAC9D,MAAM,iBAAiB,yBAAyB,UAC1C,EAAE,QAAQ,oBAAqB,IAC/B;CACN,MAAM,SAAS,QAAQ,UAAU,KAAK;CACtC,MAAM,aAAa,QAAQ,WAAW;CACtC,MAAM,iBAAiB,IAAI,WAAW;AACtC,YAAW,oBAAoB,WAC3B,OAAM,IAAI,OAAO,mBAAmB,WAAW;CAEnD,MAAM,UAAU,MAAM;EAClB,MAAM,IAAI,QAAQ;AAClB,SAAO,eAAe,EAAE;CAC3B;AACD,QAAO;AACV"}