{"version":3,"file":"src-CHxoOwyb.js","names":["chunk","chunks","slice","reduce","uniqueByValue","asCallback","last","chunks","concat","dropWhile","until","equals","every","fill","forEach","filter","find","flatten","map","max","min","some","repeat","unique","iterable","zip","fromIterable","toArray","fromArray","array","#store","#disposed","#listeners","fromArray","array","fromIterable","iterable","chunks","concat","dropWhile","until","equals","every","fill","filter","find","flatten","forEach","last","map","max","min","reduce","asCallback","slice","delay","some","toArray","unique","uniqueByValue","zip","map","key","perValue","query","transform","take","reduce","duration","elapsed","delay","debounce","tally","min","max","rank","rankArray","average","sum","chunk","filter","drop","delay","fromArray","event","fromFunction","fromIterable","array","AsyncToArray","asCallback","asPromise","asValue","fromFunction","#store","iterable","min","max","min","max","array","some","iterable"],"sources":["../../core/dist/src/default-keyer.js","../../core/dist/src/text.js","../../iterables/dist/src/guard.js","../../iterables/dist/src/sync/slice.js","../../iterables/dist/src/sync/reduce.js","../../iterables/dist/src/sync.js","../../events/dist/src/map-of.js","../../events/dist/src/simple-event-emitter.js","../../events/dist/src/index.js","../../iterables/dist/src/async.js","../../iterables/dist/src/chain/utility.js","../../iterables/dist/src/util/dom.js","../../iterables/dist/src/chain/dom.js","../../iterables/dist/src/chain/links.js","../../iterables/dist/src/chain/from/array.js","../../iterables/dist/src/chain/from/event.js","../../iterables/dist/src/chain/from/function.js","../../iterables/dist/src/chain/from/iterable.js","../../iterables/dist/src/chain/from/ticks.js","../../iterables/dist/src/chain/from/index.js","../../iterables/dist/src/chain/add-to-array.js","../../iterables/dist/src/chain/as-array.js","../../iterables/dist/src/chain/as-callback.js","../../iterables/dist/src/chain/as-promise.js","../../iterables/dist/src/chain/as-value.js","../../iterables/dist/src/chain/combine-latest-to-array.js","../../iterables/dist/src/chain/combine-latest-to-object.js","../../iterables/dist/src/chain/lazy.js","../../iterables/dist/src/util/queueMutable.js","../../iterables/dist/src/chain/merge-flat.js","../../iterables/dist/src/chain/run.js","../../iterables/dist/src/chain/prepare.js","../../iterables/dist/src/chain/single.js","../../iterables/dist/src/chain/sync.js","../../iterables/dist/src/chain/index.js","../../iterables/dist/src/compare-values.js","../../iterables/dist/src/controller.js","../../iterables/dist/src/from-event.js","../../iterables/dist/src/numbers-compute.js","../../iterables/dist/src/index.js"],"sourcesContent":["/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = (a) => {\n    return typeof a === `string` ? a : JSON.stringify(a);\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Whittles down from whole string to last token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToEnd(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const trimmed = afterMatch(source, delimiter);\n        if (trimmed === source) {\n            // Delimiter not found\n            break;\n        }\n        source = trimmed;\n    }\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Starts with last token, builds to whole.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsLastToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n        if (ba[0] === ba[1] && ba[1] === source) {\n            // Delimiter not found\n            break;\n        }\n        const v = ba[1] + accumulator;\n        yield v;\n        accumulator = delimiter + v;\n        source = ba[0];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with the first token and build up until end.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsFirstToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n        if (ba[0] === source && ba[1] === source)\n            break;\n        accumulator += ba[0];\n        yield accumulator;\n        accumulator += delimiter;\n        source = ba[1];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with whole string and whittle down to starting token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToFirst(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n        if (b === source)\n            break;\n        source = b;\n    }\n}\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n *\n * If `source` is under `maxLength` the original is returned.\n * @param source\n * @param maxLength Maximum length. Defaults to 20\n * @returns\n */\nexport const abbreviate = (source, maxLength = 15) => {\n    resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (source.length > maxLength && source.length > 3) {\n        if (maxLength > 15) {\n            const chunk = Math.round((maxLength - 2) / 2);\n            return source.slice(0, chunk) + `...` + source.slice(-chunk);\n        }\n        return source.slice(0, maxLength) + `...`;\n    }\n    return source;\n};\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns\n */\nexport const toStringAbbreviate = (source, maxLength = 20) => {\n    if (source === undefined)\n        return `(undefined)`;\n    if (source === null)\n        return `(null)`;\n    return abbreviate(JSON.stringify(source), maxLength);\n};\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return;\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return;\n    return source.slice(startPos + 1, endPos);\n};\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (typeof start !== `string`)\n        throw new Error(`Parameter 'start' is not a string`);\n    if (end !== undefined && typeof end !== `string`)\n        throw new Error(`Parameter 'end' is not a string`);\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return [source, undefined];\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return [source, undefined];\n    const between = source.slice(startPos + 1, endPos);\n    const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n    return [sourceResult, between];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {\n    for (let index = start; index <= end; index++) {\n        if (source.codePointAt(index) === code)\n            return index;\n    }\n    return -1;\n};\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) +\n    source.slice(removeStart + removeLength);\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (source, length) => {\n    resultThrow(integerTest(length, `aboveZero`, `length`));\n    if (source === null)\n        throw new Error(`source parameter null`);\n    if (typeof source !== `string`) {\n        throw new TypeError(`source parameter not a string`);\n    }\n    // ✔ Unit tested\n    const chunks = Math.ceil(source.length / length);\n    const returnValue = [];\n    let start = 0;\n    for (let c = 0; c < chunks; c++) {\n        returnValue.push(source.slice(start, start + length));\n        start += length;\n    }\n    return returnValue;\n};\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[0];\n};\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[1];\n};\n/**\n * Returns the text that is before and after `match`.\n *\n * See also: {@link beforeMatch}, {@link afterMatch}.\n *\n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeAfterMatch = (source, match, options = {}) => {\n    if (source === undefined)\n        throw new Error(`Param 'source' is undefined`);\n    let fallback = options.fallback;\n    const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n    if (ifNoMatch === `original`)\n        fallback = source;\n    if (ifNoMatch === `fallback` && fallback === undefined)\n        throw new Error(`Fallback must be provided`);\n    const startPos = options.startPos ?? undefined;\n    const fromEnd = options.fromEnd ?? false;\n    const m = fromEnd\n        ? source.lastIndexOf(match, startPos)\n        : source.indexOf(match, startPos);\n    if (m < 0 && ifNoMatch === `throw`)\n        throw new Error(`Match '${match}' not found in source.`);\n    if (m < 0 && ifNoMatch === `original`)\n        return [source, source];\n    if (m < 0 && ifNoMatch === `fallback`) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return [fallback, fallback];\n    }\n    return [\n        source.slice(0, m),\n        source.slice(Math.max(0, m + match.length))\n    ];\n};\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (source, ...wrappers) => {\n    let matched = false;\n    do {\n        matched = false;\n        for (const w of wrappers) {\n            if (source.startsWith(w) && source.endsWith(w)) {\n                source = source.slice(w.length, source.length - w.length * 2 + 1);\n                matched = true;\n            }\n        }\n    } while (matched);\n    return source;\n};\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges, start, end) => {\n    let s = -1;\n    let endPos = -1;\n    for (const [index, r] of ranges.entries()) {\n        s = index;\n        if (r.text.length === 0)\n            continue;\n        if (start < r.end) {\n            break;\n        }\n    }\n    for (let index = s; index < ranges.length; index++) {\n        const r = ranges[index];\n        endPos = index;\n        if (end === r.end) {\n            endPos = index + 1;\n            break;\n        }\n        if (end < r.end) {\n            break;\n        }\n    }\n    return { length: endPos - s, start: s, end: endPos };\n};\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (source, split) => {\n    let start = 0;\n    let text = ``;\n    const ranges = [];\n    let index = 0;\n    for (let index_ = 0; index_ < source.length; index_++) {\n        if (source.indexOf(split, index_) === index_) {\n            const end = index_;\n            ranges.push({\n                text,\n                start,\n                end,\n                index,\n            });\n            start = end + 1;\n            text = ``;\n            index++;\n        }\n        else {\n            text += source.charAt(index_);\n        }\n    }\n    if (start < source.length) {\n        ranges.push({ text, start, index, end: source.length });\n    }\n    return ranges;\n};\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (source, ...chars) => {\n    let counted = 0;\n    for (let index = 0; index < source.length; index++) {\n        if (chars.includes(source.charAt(index))) {\n            counted++;\n        }\n        else {\n            break;\n        }\n    }\n    return counted;\n};\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);\nexport const htmlEntities = (source) => source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${index.codePointAt(0)};`);\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern\n * @returns\n */\nexport const wildcard = (pattern) => {\n    // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n    // for this solution to work on any string, no matter what characters it has\n    const escapeRegex = (value) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n    // \".\"  => Find a single character, except newline or line terminator\n    // \".*\" => Matches any string that contains zero or more characters\n    pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n    // \"^\"  => Matches any string with the following at the beginning of it\n    // \"$\"  => Matches any string with that in front at the end of it\n    pattern = `^` + pattern + `$`;\n    // Create a regular expression object for matching string\n    const regex = new RegExp(pattern);\n    return (value) => {\n        // Returns true if it finds a match, otherwse it returns false\n        return regex.test(value);\n    };\n};\n","export const isAsyncIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.asyncIterator in v;\n};\nexport const isIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.iterator in v;\n};\n","export function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    if (start < 0)\n        throw new Error(`Param 'start' should be at least 0`);\n    let index = 0;\n    for (const v of it) {\n        if (index < start) {\n            index++;\n            continue;\n        }\n        if (index > end) {\n            break;\n        }\n        yield v;\n        index++;\n    }\n}\n","export function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for (const v of it)\n        start = f(start, v);\n    return start;\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { isIterable } from './guard.js';\nexport { slice } from './sync/slice.js';\nexport { reduce } from './sync/reduce.js';\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    for (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(generator, defaultValue) {\n    return () => {\n        const v = generator.next().value;\n        if (v === undefined)\n            return defaultValue;\n        return v;\n    };\n}\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first(it) {\n    for (const value of it) {\n        return value;\n    }\n}\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last(it) {\n    let returnValue;\n    for (const value of it) {\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping(it, size) {\n    if (size <= 1)\n        throw new Error(`Size should be at least 2`);\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer = [buffer.at(-1)];\n        }\n    }\n    if (buffer.length <= 1)\n        return;\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* chunks(it, size) {\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* concat(...its) {\n    for (const it of its)\n        yield* it;\n}\nexport function* dropWhile(it, f) {\n    for (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it, callback) => {\n    for (const _ of it) {\n        const value = callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\nexport const next = (it) => {\n    return () => {\n        const r = it.next();\n        if (r.done)\n            return;\n        return r.value;\n    };\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    //it1 = it1[Symbol.iterator]();\n    //it2 = it2[Symbol.iterator]();\n    while (true) {\n        const index1 = it1.next(), index2 = it2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport function every(it, f) {\n    for (const v of it) {\n        const result = f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for (const _ of it)\n        yield v;\n}\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * import { Sync } from \"@ixfx/iterables.js\"\n * Sync.forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * Sync.forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * Sync.forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEach} if you want to use an async `iterator` and async `fn`.\n *\n * Alternatives:\n * * {@link https://api.ixfx.fun/_ixfx/flow/repeat/ @ixfx/flow.repeat}/{@link https://api.ixfx.fun/_ixfx/flow/repeatSync/ @ixfx/flow.repeatSync}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam T Type of iterable's values\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport function forEach(iterator, fn) {\n    for (const v of iterator) {\n        const result = fn(v);\n        if (typeof result === `boolean` && !result)\n            break;\n    }\n}\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (!f(v))\n            continue;\n        yield v;\n    }\n}\nexport function find(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return v;\n    }\n}\nexport function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\nexport function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        yield f(v);\n    }\n}\nexport function* max(it, gt = (a, b) => a > b) {\n    let max;\n    for (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield max;\n            continue;\n        }\n        if (gt(v, max)) {\n            max = v;\n            yield max;\n        }\n    }\n    return max;\n}\nexport function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n        }\n        if (gt(min, v)) {\n            min = v;\n            yield min;\n        }\n    }\n}\nexport function some(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return true;\n    }\n    return false;\n}\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\nexport function* repeat(genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n}\nexport function* unique(iterable) {\n    // Adapted from https://surma.github.io/underdash/\n    const buffer = [];\n    let itera = [];\n    itera = Array.isArray(iterable) ? iterable : [iterable];\n    for (const it of itera) {\n        for (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.iterator]());\n    while (true) {\n        const vs = iits.map((it) => it.next());\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\nexport function* fromIterable(iterable) {\n    for (const v of iterable) {\n        yield v;\n    }\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    const result = [];\n    const started = Date.now();\n    const whileFunction = options.while;\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    for (const v of it) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        if (result.length >= maxItems)\n            break;\n        if (Date.now() - started > maxElapsed)\n            break;\n        result.push(v);\n    }\n    return result;\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray(array) {\n    for (const v of array) {\n        yield v;\n    }\n}\n","export class MapOfSimple {\n    #store = new Map();\n    /**\n     * Gets a copy of the underlying array storing values at `key`, or an empty array if\n     * key does not exist\n     * @param key\n     * @returns\n     */\n    get(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return [];\n        return [...arr];\n    }\n    /**\n     * Returns the number of values stored under `key`\n     * @param key\n     * @returns\n     */\n    size(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return 0;\n        return arr.length;\n    }\n    /**\n     * Iterate over all values contained under `key`\n     * @param key\n     * @returns\n     */\n    *iterateKey(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return;\n        yield* arr.values();\n    }\n    /**\n     * Iterate all values, regardless of key\n     */\n    *iterateValues() {\n        for (const key of this.#store.keys()) {\n            yield* this.iterateKey(key);\n        }\n    }\n    /**\n     * Iterate all keys\n     */\n    *iterateKeys() {\n        yield* this.#store.keys();\n    }\n    addKeyedValues(key, ...values) {\n        let arr = this.#store.get(key);\n        if (!arr) {\n            arr = [];\n            this.#store.set(key, arr);\n        }\n        arr.push(...values);\n    }\n    deleteKeyValue(key, value) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return false;\n        const arrCopy = arr.filter(v => v !== value);\n        if (arrCopy.length === arr.length)\n            return false;\n        this.#store.set(key, arrCopy);\n        return true;\n    }\n    clear() {\n        this.#store.clear();\n    }\n}\n","import { MapOfSimple } from \"./map-of.js\";\nexport class SimpleEventEmitter {\n    #listeners = new MapOfSimple();\n    #disposed = false;\n    dispose() {\n        if (this.#disposed)\n            return;\n        this.clearEventListeners();\n    }\n    get isDisposed() {\n        return this.#disposed;\n    }\n    /**\n     * Fire event\n     * @param type Type of event\n     * @param args Arguments for event\n     * @returns\n     */\n    fireEvent(type, args) {\n        if (this.#disposed)\n            throw new Error(`Disposed`);\n        //console.log(`Firing ${ type as string }. Listeners: ${ this.#listeners.size(type as string) }`);\n        for (const l of this.#listeners.iterateKey(type)) {\n            l(args, this);\n        }\n    }\n    /**\n     * Adds event listener.\n     *\n     * @throws Error if emitter is disposed\n     * @typeParam K - Events\n     * @param name Event name\n     * @param listener Event handler\n     */\n    addEventListener(name, listener) {\n        if (this.#disposed)\n            throw new Error(`Disposed`);\n        this.#listeners.addKeyedValues(name, listener);\n    }\n    /**\n     * Remove event listener\n     *\n     * @param listener\n     */\n    removeEventListener(type, listener) {\n        if (this.#disposed)\n            return;\n        // listener: Listener<Events>): void {\n        this.#listeners.deleteKeyValue(type, listener);\n    }\n    /**\n     * Clear all event listeners\n     * @private\n     */\n    clearEventListeners() {\n        if (this.#disposed)\n            return;\n        this.#listeners.clear();\n    }\n}\n","export { SimpleEventEmitter } from './simple-event-emitter.js';\nexport * from './types.js';\n","import { intervalToMs, toStringDefault } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\nimport { isAsyncIterable, isIterable } from './guard.js';\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray(array, interval = 1) {\n    for (const v of array) {\n        yield v;\n        await sleep(interval);\n    }\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable(iterable, interval = 1) {\n    for await (const v of iterable) {\n        yield v;\n        await sleep(interval);\n    }\n}\nexport async function* chunks(it, size) {\n    // Source: https://surma.github.io/underdash/\n    let buffer = [];\n    for await (const v of it) {\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport async function* concat(...its) {\n    // Source: https://surma.github.io/underdash/\n    for await (const it of its)\n        yield* it;\n}\nexport async function* dropWhile(it, f) {\n    for await (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n *\n * In this version, we do a `for await of` over `gen`, and also `await callback()`.\n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n *\n * If you want the value from the generator, use a `for of` loop as usual.\n *\n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it, callback) => {\n    for await (const _ of it) {\n        const value = await callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n *\n * For example, {@link https://api.ixfx.fun/_ixfx/numbers/count/ @ixfx/numbers.count} will count from 0..number and then finish:\n * ```js\n * import { count } from '@ixfx/numbers'\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n *\n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n *\n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n *\n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator\n * @param repeatsOrSignal\n */\nexport const repeat = async function* (genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for await (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals(it1, it2, equality) {\n    // https://surma.github.io/underdash/\n    const iit1 = it1[Symbol.asyncIterator](); // it1[ Symbol.iterator ]();\n    const iit2 = it2[Symbol.asyncIterator]();\n    while (true) {\n        const index1 = await iit1.next();\n        const index2 = await iit2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport async function every(it, f) {\n    for await (const v of it) {\n        const result = await f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport async function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for await (const _ of it)\n        yield v;\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (!await f(v))\n            continue;\n        yield v;\n    }\n}\nexport async function find(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return v;\n    }\n}\nexport async function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isAsyncIterable(v)) {\n                for await (const vv of v) {\n                    yield vv;\n                }\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"@ixfx/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function (iterator, fn, options = {}) {\n    const interval = options.interval;\n    if (Array.isArray(iterator)) {\n        // Handle array\n        for (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n    else {\n        // Handle an async iterator\n        for await (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n};\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last(it, opts = {}) {\n    const abort = opts.abort;\n    let returnValue;\n    for await (const value of it) {\n        if (abort?.aborted)\n            return undefined;\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport async function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        yield f(v);\n    }\n}\nexport async function* max(it, gt = ((a, b) => a > b)) {\n    let max;\n    for await (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield (max);\n            continue;\n        }\n        // If V is bigger than max, we have a new max\n        if (gt(v, max)) {\n            max = v;\n            yield v;\n        }\n    }\n}\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n *\n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for await (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n            continue;\n        }\n        // If min is bigger than V, V is the new min\n        if (gt(min, v)) {\n            min = v;\n            yield v;\n        }\n    }\n    return min;\n}\nexport async function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for await (const v of it)\n        start = f(start, v);\n    return start;\n}\n/**\n * Calls `callback` whenever the async generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport async function asCallback(input, callback, onDone) {\n    for await (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\nexport async function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    console.log(`Async slice start: ${start}`);\n    // https://surma.github.io/underdash/\n    const iit = it[Symbol.asyncIterator]();\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    for (; start > 0; start--, end--)\n        await iit.next();\n    for await (const v of it) {\n        if (end-- > 0) {\n            yield v;\n        }\n        else {\n            break;\n        }\n    }\n}\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it\n * @param delay\n */\nexport async function* withDelay(it, delay) {\n    for (const v of it) {\n        await sleep(delay);\n        yield v;\n    }\n}\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout(it, options) {\n    const ms = intervalToMs(options, 1000);\n    const value = await Promise.race([\n        (async () => {\n            await sleep({ millis: ms, signal: options.signal });\n            return undefined;\n        })(),\n        (async () => {\n            return await it.next();\n        })()\n    ]);\n    if (value === undefined)\n        throw new Error(`Timeout`);\n    return value;\n}\nexport async function some(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return true;\n    }\n    return false;\n}\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray(it, options = {}) {\n    // https://2ality.com/2016/10/asynchronous-iteration.html\n    const result = [];\n    const iterator = it[Symbol.asyncIterator]();\n    const started = Date.now();\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const whileFunction = options.while;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        const r = await iterator.next();\n        if (r.done)\n            break;\n        //eslint-disable-next-line functional/immutable-data\n        result.push(r.value);\n    }\n    return result;\n}\nexport async function* unique(iterable) {\n    const buffer = [];\n    const itera = Array.isArray(iterable) ? iterable : [iterable];\n    for await (const it of itera) {\n        for await (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\nexport async function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for await (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.asyncIterator]());\n    while (true) {\n        const vs = await Promise.all(iits.map((it) => it.next()));\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\n","import * as Async from \"../async.js\";\nimport { isAsyncIterable } from \"../index.js\";\nimport { sleep } from \"@ixfx/core\";\nexport function isGenFactoryNoInput(c) {\n    if (!(`_type` in c))\n        return false;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (c._type === `GenFactoryNoInput`)\n        return true;\n    return false;\n}\n/**\n * Wrap the primitive value as generator\n * @param value\n */\nfunction* primitiveToGenerator(value) {\n    yield value;\n}\n/**\n * Wrap the primitive value as an async generator\n * @param value\n */\nasync function* primitiveToAsyncGenerator(value) {\n    yield value;\n    await sleep(1);\n}\n/**\n * Resolve the array, data or function to a Generator\n * @param input\n * @returns\n */\nexport function resolveToGen(input) {\n    if (Array.isArray(input)) {\n        const a = input.values();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        a._name = `arrayInput`;\n        return a;\n    }\n    else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n        // Assumes V is primitive\n        return primitiveToGenerator(input);\n    }\n    else if (typeof input === `function`) {\n        return input();\n    }\n    return input;\n}\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input\n * @returns\n */\nexport function resolveToAsyncGen(input) {\n    if (input === undefined)\n        return;\n    if (Array.isArray(input)) {\n        return Async.fromArray(input);\n    }\n    else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n        // Assumes V is primitive\n        return primitiveToAsyncGenerator(input);\n    }\n    else if (typeof input === `function`) {\n        return input();\n    }\n    else if (isAsyncIterable(input)) {\n        return input;\n    }\n    return Async.fromIterable(input);\n}\n","export function resolveEl(elOrQuery) {\n    if (typeof elOrQuery === `string`) {\n        const el = document.querySelector(elOrQuery);\n        if (!el)\n            throw new Error(`Element not found '${elOrQuery}'`);\n        return el;\n    }\n    return elOrQuery;\n}\n","import { toStringDefault } from \"@ixfx/core\";\nimport { resolveToGen } from \"./utility.js\";\nimport { resolveEl } from \"../util/dom.js\";\nconst createMap = (key) => {\n    const keyFunction = key ?? ((value) => value);\n    const map = new Map();\n    return {\n        has(key) {\n            return map.has(keyFunction(key));\n        },\n        get(key) {\n            return map.get(keyFunction(key));\n        },\n        set(key, value) {\n            //console.log(`Chains.Dom.createMap: key: ${ keyFunction(key) } value: ${ value }`);\n            map.set(keyFunction(key), value);\n        },\n        entries() {\n            return map.entries();\n        },\n        delete(key) {\n            map.delete(key);\n        }\n    };\n};\n/**\n * Creates a HTML element per value. By default compares\n * values by `JSON.stringify`. Set `byReference:true` to\n * compare values based on reference. Or provide a toString\n * function via `key`.\n *\n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n *\n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n * ```\n */\nexport function perValue(options = {}) {\n    const byReference = options.byReference;\n    const tagName = options.tagName ?? `div`;\n    if (byReference && options.key)\n        throw new Error(`byReference and key options are mutually exclusive`);\n    const keyFunction = byReference ? undefined : options.key ?? toStringDefault;\n    const map = createMap(keyFunction);\n    const parentElementOrQuery = options.parentEl ?? document.body;\n    const parentEl = resolveEl(parentElementOrQuery);\n    const usedElements = new Set();\n    async function* perValue(input) {\n        for await (const value of resolveToGen(input)) {\n            let el = map.get(value);\n            if (!el) {\n                el = document.createElement(tagName);\n                map.set(value, el);\n                if (options.beforeInsert)\n                    options.beforeInsert(el);\n                parentEl.append(el);\n                if (options.afterInsert)\n                    options.afterInsert(el);\n            }\n            usedElements.add(el);\n            yield { el, value };\n        }\n        // Remove unused elements\n        for (const [id, el] of map.entries()) {\n            if (usedElements.has(el))\n                continue;\n            if (options.beforeRemove)\n                options.beforeRemove(el);\n            el.remove();\n            map.delete(id);\n        }\n    }\n    perValue._name = `dom.perValue`;\n    return perValue;\n}\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options\n * @returns\n */\nexport function query(options = {}) {\n    const baseElement = options.baseElement ?? document;\n    async function* query(input) {\n        const gen = resolveToGen(input);\n        for await (const value of gen) {\n            for (const element of baseElement.querySelectorAll(value)) {\n                yield element;\n            }\n        }\n    }\n    query._name = `dom.query`;\n    return query;\n}\n","import { intervalToMs, sleep, elapsedSince } from \"@ixfx/core\";\nimport { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { resolveToGen } from \"./utility.js\";\nimport * as BasicProcessors from \"@ixfx/process/basic\";\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer\n * @returns\n */\nexport function transform(transformer) {\n    async function* transform(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            yield transformer(value);\n        }\n    }\n    transform._name = `transform`;\n    return transform;\n}\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit\n * @returns\n */\nexport function take(limit) {\n    async function* take(input) {\n        input = resolveToGen(input);\n        let yielded = 0;\n        for await (const value of input) {\n            if (++yielded > limit)\n                break;\n            yield value;\n        }\n    }\n    take._name = `take`;\n    return take;\n}\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `reducer` function.\n *\n * ```js\n * // Create a chain that flattens values\n * const reduce = Chains.reduce(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(reduce, [ 1, 2, 3]); // 3\n * ```\n * @param reducer Function to reduce array of values to a single value\n * @returns\n */\nexport function reduce(reducer) {\n    async function* reduce(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            yield reducer(value);\n        }\n    }\n    reduce._name = `reduce`;\n    return reduce;\n}\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed\n * @returns\n */\nexport function duration(elapsed) {\n    const durationMs = intervalToMs(elapsed, 0);\n    async function* duration(input) {\n        input = resolveToGen(input);\n        const elapsed = elapsedSince();\n        for await (const value of input) {\n            if (elapsed() > durationMs)\n                break;\n            yield value;\n        }\n    }\n    duration._name = `duration`;\n    return duration;\n}\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options\n * @returns\n */\nexport function delay(options) {\n    const before = intervalToMs(options.before, 0);\n    const after = intervalToMs(options.after, 0);\n    async function* delay(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            if (before > 0) {\n                await sleep(before);\n            }\n            yield value;\n            if (after > 0) {\n                await sleep(after);\n            }\n        }\n    }\n    delay._name = `delay`;\n    return delay;\n}\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n *\n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.run(\n *  // Produce values every 10ms for 350ms\n *  Chains.From.timestamp({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.Links.debounce(100)\n * );\n * ```\n * @param rate\n * @returns\n */\nexport function debounce(rate) {\n    const rateMs = intervalToMs(rate, 0);\n    async function* debounce(input) {\n        input = resolveToGen(input);\n        let elapsed = elapsedSince();\n        for await (const value of input) {\n            if (elapsed() < rateMs)\n                continue;\n            yield value;\n            elapsed = elapsedSince();\n        }\n    }\n    debounce._name = `debounce`;\n    return debounce;\n}\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * ```js\n * const ch = Chains.run(\n *  Chains.From.timestamp({ interval: 100 }),\n *  Chains.Links.tally()\n * );\n *\n * for await (const v of ch) {\n *   // Produces: 1, 2, 3 ... every 100ms\n * }\n * ```\n * This is different than {@link sum} which adds up numeric values.\n * By default it adds up individual array items\n * @returns\n */\nexport function tally(countArrayItems = true) {\n    async function* tally(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.tally(countArrayItems);\n        for await (const v of input) {\n            yield p(v);\n        }\n    }\n    tally._name = `tally`;\n    return tally;\n}\n/**\n * Returns the smallest value from the input.\n * Can work with numbers or number[] as input.\n * Non-numeric data is filtered out.\n * @returns\n */\nexport function min() {\n    async function* min(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.min();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    min._name = `min`;\n    return min;\n}\n/**\n * Returns the largest value from the input.\n * - Non-numeric data is filtered out.\n * - Looks inside of numeric arrays.\n * @returns\n */\nexport function max() {\n    async function* max(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.max();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    max._name = `max`;\n    return max;\n}\n// export function max(): Link<number | Array<number>, number> {\n//   async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n//     input = resolveToGen(input);\n//     let max = Number.MIN_SAFE_INTEGER;\n//     for await (const value of input) {\n//       const valueArray = Array.isArray(value) ? value : [ value ];\n//       for (const subValue of valueArray) {\n//         if (typeof subValue !== `number`) break;\n//         max = Math.max(subValue, max);\n//         yield max;\n//       }\n//     }\n//   }\n//   max._name = `max`;\n//   return max;\n// }\n/**\n * Emits the currently ranked 'highest' value from a stream. Only\n * values exceeding the current highest are emitted.\n *\n * eg, if we are ranking on numerical value, an input stream of:\n * ```\n * 4, 1, 6, 10, 2, 4\n * ```\n *\n * Results in the output stream of:\n * ```\n * 4, 6, 10\n * ```\n *\n * @example\n * ```js\n * // Rank based on a field\n * Chains.Links.rank((a,b) => {\n *  if (a.size > b.size) return `a`; // Signals the first param is highest\n *  if (a.size < b.size) return `b`; // Signals the second param is highest\n *  return `eq`;\n * });\n * ```\n * @param options\n * @returns\n */\nexport function rank(r, options = {}) {\n    async function* rank(input) {\n        input = resolveToGen(input);\n        //let best: In | undefined;\n        const p = BasicProcessors.rank(r, options);\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    rank._name = `rank`;\n    return rank;\n}\n/**\n * Emits the highest-ranked value from amongst an array of values.\n *\n * By default, it tracks the highest-ranked _between_ arrays.\n *\n * For example:\n * ```js\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Outputs:\n * [ 6 ]\n * ```\n *\n * This behaviour can be modified with an option to only compare _within_ arrays.\n * ```\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Output:\n * [ 6, 3 ]\n * ```\n *\n * Uses the `rank` option to determine which is more highly ranked.\n * ```js\n * Chains.Links.rankArray(\n *  (a, b) => {\n *    if (a > b) return `a`; // a is higher\n *    else if (b > a) return `b`; // b is higher\n *    return `eq`; // same\n *  }\n * )\n * ```\n * @param options\n * @returns\n */\nexport function rankArray(r, options = {}) {\n    const includeType = options.includeType;\n    const emitEqualRanked = options.emitEqualRanked ?? false;\n    const emitRepeatHighest = options.emitRepeatHighest ?? false;\n    const withinArrays = options.withinArrays ?? false;\n    async function* rankArray(input) {\n        input = resolveToGen(input);\n        let best;\n        for await (const value of input) {\n            let emit = false;\n            if (withinArrays)\n                best = undefined; // Reset\n            for (const subValue of value) {\n                if (includeType && typeof subValue !== includeType)\n                    continue;\n                if (best === undefined) {\n                    best = subValue;\n                    emit = true;\n                }\n                else {\n                    const result = r(subValue, best);\n                    if (result == `a`) {\n                        // New value is the current best\n                        best = subValue;\n                        emit = true;\n                    }\n                    else if (result === `eq` && emitEqualRanked) {\n                        // New value is same rank as previous, but we have flag on\n                        emit = true;\n                    }\n                    else if (emitRepeatHighest) {\n                        // Emit current highest due to flag\n                        emit = true;\n                    }\n                }\n            }\n            if (emit && best)\n                yield best;\n        }\n    }\n    rankArray._name = `rankArray`;\n    return rankArray;\n}\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns\n */\nexport function average() {\n    async function* average(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.average();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    average._name = `average`;\n    return average;\n}\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns\n */\nexport function sum() {\n    async function* total(input) {\n        input = resolveToGen(input);\n        const p = BasicProcessors.sum();\n        for await (const value of input) {\n            const x = p(value);\n            if (x === undefined)\n                continue;\n            yield x;\n        }\n    }\n    total._name = `total`;\n    return total;\n}\n/**\n * Chunks an input stream into `size` chunks.\n *\n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n *\n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size\n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns\n */\nexport function chunk(size, returnRemainders = true) {\n    resultThrow(integerTest(size, `aboveZero`, `size`));\n    async function* chunk(input) {\n        input = resolveToGen(input);\n        let buffer = [];\n        for await (const value of input) {\n            buffer.push(value);\n            if (buffer.length >= size) {\n                yield buffer;\n                buffer = [];\n            }\n        }\n        if (returnRemainders && buffer.length > 0)\n            yield buffer;\n    }\n    chunk._name = `chunk`;\n    return chunk;\n}\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n *\n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate\n * @returns\n */\nexport function filter(predicate) {\n    async function* filter(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            if (predicate(value)) {\n                yield value;\n            }\n        }\n    }\n    filter._name = `filter`;\n    return filter;\n}\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n *\n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate\n * @returns\n */\nexport function drop(predicate) {\n    async function* drop(input) {\n        input = resolveToGen(input);\n        for await (const value of input) {\n            if (!predicate(value)) {\n                yield value;\n            }\n        }\n    }\n    drop._name = `drop`;\n    return drop;\n}\n","import { sleep } from \"@ixfx/core\";\n/**\n * Creates a chain from an array, reading values at a given interval\n * @param it\n * @param delay\n * @returns\n */\nexport function array(it, delay = 5) {\n    async function* fromArray() {\n        for (const v of it) {\n            await sleep(delay);\n            yield v;\n        }\n    }\n    fromArray._name = `fromArray`;\n    fromArray._type = `GenFactoryNoInput`;\n    return fromArray;\n}\n","import { promiseFromEvent } from \"@ixfx/core\";\n/**\n * Create an iterable from an event\n * @param target Event source (eg HTML element)\n * @param name Name of event (eg. 'pointermove')\n * @returns\n */\nexport function event(target, name) {\n    async function* event() {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while (true) {\n            yield await promiseFromEvent(target, name);\n        }\n    }\n    event._name = `event`;\n    event._type = `GenFactoryNoInput`;\n    return event;\n}\n//https://stackoverflow.com/questions/51045136/how-can-i-use-a-event-emitter-as-an-async-generator\n","/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n *\n * ```js\n * const callback = () => Math.random();\n *\n * const f = Chains.From.func(callback);\n * for await (const v of f) {\n *  // v is a new random number\n * }\n * ```\n *\n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.From.func(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback\n * @returns\n */\nexport function func(callback) {\n    async function* fromFunction() {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while (true) {\n            const v = await callback();\n            if (typeof v === `undefined`)\n                break;\n            yield v;\n        }\n    }\n    fromFunction._name = `fromFunction`;\n    fromFunction._type = `GenFactoryNoInput`;\n    return fromFunction;\n}\n","/**\n * Creates a chain from an interable\n * @param it\n * @returns\n */\nexport function iterable(it) {\n    async function* fromIterable() {\n        for await (const v of it) {\n            yield v;\n        }\n    }\n    fromIterable._name = `fromIterable`;\n    fromIterable._type = `GenFactoryNoInput`;\n    return fromIterable;\n}\n","import { elapsedSince, intervalToMs, sleep } from \"@ixfx/core\";\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever.\n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n *\n * ```js\n * const c = Chains.From.timestamp({ interval: 1000 });\n * ```\n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options\n * @returns\n */\nexport function timestamp(options) {\n    const intervalMs = intervalToMs(options.interval, 0);\n    const asClockTime = options.asClockTime ?? false;\n    const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n    let looped = 0;\n    const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n    async function* ts() {\n        const elapsed = elapsedSince();\n        while (looped < loops && elapsed() < durationTime) {\n            yield asClockTime ? Date.now() : elapsed();\n            // Adjust sleep period so timing errors don't accumulate\n            const expectedTimeDiff = (looped * intervalMs) - elapsed();\n            await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n            looped++;\n        }\n    }\n    ts._name = `timestamp`;\n    ts._type = `GenFactoryNoInput`;\n    return ts;\n}\n","export * from './array.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterable.js';\nexport * from './ticks.js';\n","/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n *\n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap\n * @param array\n */\nexport async function addToArray(array, valueToWrap) {\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    for await (const value of outputType) {\n        array.push(value);\n    }\n}\n","import { toArray as AsyncToArray } from \"../async.js\";\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n *\n * If the chain is infinite, be sure to specify limits:\n * ```js\n * // Stop after we have five items\n * const values = await asArray(chain, { limit: 5 });\n * // Stop after 5 seconds has elapsed\n * const values = await asArray(chain, { elapsed: 5000 });\n * ```\n * @param valueToWrap\n * @returns\n */\nexport async function asArray(valueToWrap, options = {}) {\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    return AsyncToArray(outputType, options);\n}\n","/**\n * Calls `callback` whenever the chain/generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap\n * @param callback\n */\nexport async function asCallback(valueToWrap, callback, onDone) {\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    for await (const value of outputType) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\n","/**\n * Treats the chain/generator as a promise\n *\n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n *\n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap\n * @returns\n */\nexport function asPromise(valueToWrap) {\n    let lastValue;\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    async function asPromise() {\n        const v = await outputType.next();\n        if (v.done)\n            return;\n        lastValue = v.value;\n        return lastValue;\n    }\n    return asPromise;\n}\n","/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n *\n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n *\n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n *\n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns\n */\nexport function asValue(valueToWrap, initialValue) {\n    let lastValue = initialValue;\n    let awaiting = false;\n    const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n    function asValue() {\n        if (!awaiting) {\n            awaiting = true;\n            outputType.next().then(v => {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                lastValue = v.value;\n                awaiting = false;\n            }).catch((error) => {\n                awaiting = false;\n                throw error;\n            });\n        }\n        return lastValue;\n    }\n    return asValue;\n}\n","import { isEqual } from \"@ixfx/arrays\";\nimport { resolveToGen } from \"./utility.js\";\n/**\n * Monitors sources, storing as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. The default is\n * 'break', meaning the whole combined stream stops.\n *\n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToArray(sources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const afterEmit = options.afterEmit ?? `last`;\n    const inputs = sources.map((source, index) => ({ waiting: undefined, index, gen: resolveToGen(source), done: false, lastValue: undefined }));\n    const isDone = () => !inputs.some(v => !v.done);\n    const isWaiting = () => inputs.some(v => v.waiting !== undefined);\n    const allEmpty = (d) => !d.some(v => v !== undefined);\n    let lastEmitted = [];\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n        const promises = [];\n        for (const input of inputs) {\n            //console.log(`  ${ input.index } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n            if (input.done)\n                continue;\n            if (input.waiting !== undefined) {\n                promises.push(input.waiting);\n                continue;\n            }\n            const p = Promise.resolve((async () => {\n                if (input.done)\n                    return input;\n                const v = await input.gen.next();\n                input.waiting = undefined;\n                if (v.done) {\n                    input.done = true;\n                    if (finalValue === `undefined`)\n                        input.lastValue = undefined;\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    input.lastValue = v.value;\n                }\n                return input;\n            })());\n            input.waiting = p;\n            promises.push(p);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const won = await Promise.race(promises);\n        if (`done` in won) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (won.done && onSourceDone === `break`)\n                break;\n        }\n        else {\n            throw new Error(`Missing 'done' property`);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        const d = inputs.map(v => v.lastValue);\n        if (d.length === 0) {\n            return;\n        }\n        const dataEmpty = allEmpty(d);\n        if (dataEmpty && !isWaiting()) {\n            return;\n        }\n        if (!isEqual(lastEmitted, d) && !dataEmpty) {\n            lastEmitted = d;\n            yield d;\n        }\n        if (afterEmit === `undefined`) {\n            for (const input of inputs) {\n                if (input.waiting !== undefined)\n                    continue;\n                input.lastValue = undefined;\n            }\n        }\n        if (isDone()) {\n            break;\n        }\n    }\n}\n","import { isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport { resolveToGen } from \"./utility.js\";\nimport * as MapFns from \"@ixfx/core/maps\";\n/**\n * Monitors sources, storing as they happen to an object.\n * Whenever a new value is emitted, the object is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n *\n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToObject(sources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const afterEmit = options.afterEmit ?? `last`;\n    const states = new Map();\n    for (const [key, value] of Object.entries(sources)) {\n        states.set(key, {\n            gen: resolveToGen(value),\n            done: false,\n            lastValue: undefined,\n            waiting: undefined,\n            key\n        });\n    }\n    const isDone = () => !MapFns.some(states, v => !v.done);\n    const isWaiting = () => MapFns.some(states, v => v.waiting !== undefined);\n    const allEmpty = (d) => {\n        for (const v of Object.values(d)) {\n            if (v !== undefined)\n                return false;\n        }\n        return true;\n    };\n    const getData = () => {\n        const r = {};\n        for (const [key, state] of states) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            r[key] = state.lastValue;\n        }\n        return r;\n    };\n    let lastEmitted;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n        const promises = [];\n        for (const input of states.values()) {\n            //console.log(`  ${ input.key } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n            if (input.done)\n                continue;\n            if (input.waiting !== undefined) {\n                promises.push(input.waiting);\n                continue;\n            }\n            const p = Promise.resolve((async () => {\n                if (input.done)\n                    return input;\n                const v = await input.gen.next();\n                input.waiting = undefined;\n                if (v.done) {\n                    input.done = true;\n                    if (finalValue === `undefined`)\n                        input.lastValue = undefined;\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    input.lastValue = v.value;\n                }\n                return input;\n            })());\n            input.waiting = p;\n            promises.push(p);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const won = await Promise.race(promises);\n        if (`done` in won) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (won.done && onSourceDone === `break`)\n                break;\n        }\n        else {\n            throw new Error(`Result missing 'done' property`);\n        }\n        const d = getData();\n        //console.log(`d`, d);\n        // if (isEqualValueIgnoreOrder(d, {} as any)) {\n        //   console.log(`keys is empty`);\n        //   return;\n        // }\n        const dataEmpty = allEmpty(d);\n        if (dataEmpty && !isWaiting()) {\n            //console.log(`dataEmpty and not waiting`);\n            return;\n        }\n        if (!isEqualValueIgnoreOrder(lastEmitted, d) && !dataEmpty) {\n            //console.log(` -- emitting!`);\n            lastEmitted = d;\n            yield d;\n        }\n        if (afterEmit === `undefined`) {\n            for (const input of states.values()) {\n                if (input.waiting !== undefined)\n                    continue;\n                input.lastValue = undefined;\n            }\n        }\n        if (isDone()) {\n            break;\n        }\n    }\n}\n","import { func as fromFunction } from \"./from/function.js\";\nimport { isGenFactoryNoInput, resolveToAsyncGen } from \"./utility.js\";\nimport * as L from './links.js';\nimport { Async } from \"../index.js\";\nconst getLinkName = (c) => {\n    //return c._name;\n    return c._name ?? c.name;\n};\nexport function lazy() {\n    const chained = [];\n    let dataToUse;\n    const asGenerator = (data) => {\n        if (data === undefined)\n            data = dataToUse;\n        let d = resolveToAsyncGen(data);\n        for (const c of chained) {\n            if (d === undefined) {\n                if (isGenFactoryNoInput(c)) {\n                    d = c();\n                }\n                else {\n                    throw new Error(`Function '${getLinkName(c)}' requires input. Provide it to the function, or call 'input' earlier.`);\n                }\n            }\n            else {\n                d = c(d);\n            }\n        }\n        return d;\n    };\n    const w = {\n        rankArray: (r, options) => {\n            chained.push(L.rankArray(r, options));\n            return w;\n        },\n        rank: (r, options) => {\n            chained.push(L.rank(r, options));\n            return w;\n        },\n        transform: (transformer) => {\n            chained.push(L.transform(transformer));\n            return w;\n        },\n        reduce: (reducer) => {\n            chained.push(L.reduce(reducer));\n            return w;\n        },\n        drop: (predicate) => {\n            chained.push(L.drop(predicate));\n            return w;\n        },\n        delay: (options) => {\n            chained.push(L.delay(options));\n            return w;\n        },\n        duration: (elapsed) => {\n            chained.push(L.duration(elapsed));\n            return w;\n        },\n        debounce: (rate) => {\n            chained.push(L.debounce(rate));\n            return w;\n        },\n        fromFunction: (callback) => {\n            chained.push(fromFunction(callback));\n            return w;\n        },\n        take: (limit) => {\n            chained.push(L.take(limit));\n            return w;\n        },\n        chunk: (size, returnRemainders = true) => {\n            chained.push(L.chunk(size, returnRemainders));\n            return w;\n        },\n        filter: (predicate) => {\n            chained.push(L.filter(v => predicate(v)));\n            return w;\n        },\n        min: () => {\n            chained.push(L.min());\n            return w;\n        },\n        max: () => {\n            chained.push(L.max());\n            return w;\n        },\n        average: () => {\n            chained.push(L.average());\n            return w;\n        },\n        sum: () => {\n            chained.push(L.sum());\n            return w;\n        },\n        tally: (countArrayItems) => {\n            chained.push(L.tally(countArrayItems));\n            return w;\n        },\n        input(data) {\n            dataToUse = data;\n            return w;\n        },\n        asGenerator,\n        asAsync(data) {\n            let d = data ?? dataToUse;\n            for (const c of chained) {\n                if (d === undefined && isGenFactoryNoInput(c)) {\n                    d = c();\n                }\n                else if (d === undefined) {\n                    throw new Error(`Function '${getLinkName(c)}' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n                }\n                else {\n                    d = c(d);\n                }\n            }\n            return w;\n        },\n        asArray: async (data) => {\n            const g = asGenerator(data);\n            return await Async.toArray(g);\n        },\n        firstOutput: async (data) => {\n            const g = asGenerator(data);\n            const v = await g.next();\n            return v.value;\n        },\n        lastOutput: async (data) => {\n            const g = asGenerator(data);\n            let lastValue;\n            for await (const v of g) {\n                lastValue = v;\n            }\n            return lastValue;\n        },\n    };\n    return w;\n}\n","export class QueueMutable {\n    #store = [];\n    enqueue(data) {\n        this.#store.push(data);\n    }\n    dequeue() {\n        return this.#store.shift();\n    }\n}\n","import { sleep } from \"@ixfx/core\";\nimport { QueueMutable } from \"../util/queueMutable.js\";\nimport { resolveToAsyncGen } from \"./utility.js\";\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n *\n * Alternatively:\n * - {@link combineLatestToArray}/{@link combineLatestToObject} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link syncToArray}/{@link syncToObject} which releases a set of results when all inputs have emitted a value\n * @param sources\n */\nexport async function* mergeFlat(...sources) {\n    const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n    const buffer = new QueueMutable();\n    let completed = 0;\n    const schedule = async (source) => {\n        if (source === undefined) {\n            completed++;\n            return;\n        }\n        const x = await source.next();\n        if (x.done) {\n            completed++;\n        }\n        else {\n            buffer.enqueue(x.value);\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            setTimeout(() => schedule(source), 1);\n        }\n    };\n    for (const source of sourcesInput) {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        setTimeout(() => schedule(source), 1);\n    }\n    const loopSpeed = 10;\n    let loopFactor = 1;\n    while (completed < sourcesInput.length) {\n        const d = buffer.dequeue();\n        if (d === undefined) {\n            // Grow loop factor up to 10\n            loopFactor = Math.min(loopFactor + 1, 10);\n        }\n        else {\n            yield d;\n            // Reset loop factor\n            loopFactor = 1;\n        }\n        await sleep(loopSpeed * loopFactor);\n    }\n}\n","import { resolveToGen } from \"./utility.js\";\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n *\n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n *\n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n *\n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param functions\n * @returns\n */\nexport async function* runN(...functions) {\n    let input;\n    for (const fnOrData of functions) {\n        input = typeof fnOrData === `function` ? fnOrData(input ?? []) : resolveToGen(fnOrData);\n    }\n    if (input === undefined)\n        return;\n    for await (const v of input) {\n        yield v;\n    }\n}\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n *\n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n *\n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n *\n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param gen\n * @param l0\n * @param l1\n * @param l2\n * @param l3\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run(gen, l0, l1, l2, l3, l4, l5) {\n    let input;\n    // eslint-disable-next-line prefer-rest-params\n    const functions = arguments;\n    for (const fnOrData of functions) {\n        if (typeof fnOrData === `function`) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment\n            input = fnOrData(input ?? []);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            input = resolveToGen(fnOrData);\n        }\n    }\n    if (input === undefined)\n        return;\n    for await (const v of input) {\n        yield v;\n    }\n}\n","import { runN } from \"./run.js\";\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => Number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\nexport function prepare(...functions) {\n    const r = (source) => {\n        return runN(source, ...functions);\n    };\n    return r;\n}\n// const chain = combine(\n//   Chains.Links.transform(v => Number.parseInt(v)),\n//   Chains.Links.filter(v => v % 2 === 0)\n// );\n// const read = chain(Chains.From.array([ 1, 2, 3 ], 100));\n","/**\n * Input a single value to the chain, return a single result\n *\n *\n * ```js\n * // Create chain link\n * const f = Chains.Links.flatten<string, string>(data => data.join(`-`));\n * // Input a single value (an array)\n * const r1 = await Chains.single(f, [ `a`, `b`, `c` ]);\n * // r1 = `a-b-c`\n * ```\n * @param f\n * @param input\n * @returns\n */\nexport async function single(f, input) {\n    const iterator = await f([input]).next();\n    return iterator.value;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport * as Async from \"../async.js\";\nimport { resolveToGen } from \"./utility.js\";\n// export function syncToObject<const T extends Record<string, GenOrData<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): AsyncGenerator<GenValueTypeObject<T>> {\n//   const keys = Object.keys(reactiveSources)\n//   const values = Object.values(reactiveSources);\n//   const s = syncToArray(values, options);\n//   const st = transform(s, (streamValues) => {\n//     return zipKeyValue(keys, streamValues);\n//   });\n//   return st as AsyncGenerator<GenValueTypeObject<T>>;\n// }\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n *\n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n *\n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n *\n * Only complete results are sent. For example if source A & B finish and\n * source C is still producing values, synchronisation is not possible\n * because A & B stopped producing values. Thus the stream will terminate\n * after `maximumWait` (2 seconds). Newer values from C are lost.\n */\nexport async function* syncToArray(sources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    //const ac = new AbortController();\n    const maximumWaitMs = intervalToMs(options.maximumWait, 2000);\n    const finalValue = options.finalValue ?? `undefined`;\n    const inputs = sources.map(source => ({ seq: 0, lastValue: undefined, gen: resolveToGen(source), done: false }));\n    const nextWithTimeoutOpts = {\n        millis: maximumWaitMs\n    };\n    let seq = 0;\n    const isAllDone = () => !inputs.some(v => !v.done);\n    let go = true;\n    while (go) {\n        seq++;\n        for (const input of inputs) {\n            if (input.done) {\n                input.seq = seq;\n                continue;\n            }\n            // Read source, with a timeout\n            const v = await Async.nextWithTimeout(input.gen, nextWithTimeoutOpts);\n            // Input has finished\n            if (v.done) {\n                input.done = true;\n                input.seq = seq;\n                if (finalValue === `undefined`) {\n                    input.lastValue = undefined;\n                }\n                if (onSourceDone === `break`) {\n                    return;\n                }\n            }\n            else {\n                // Stash away value\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                input.lastValue = v.value;\n                input.seq = seq;\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (go) {\n            // Return the set of data\n            const d = inputs.filter(v => v.seq === seq).map(v => v.lastValue);\n            if (d.length === 0)\n                return;\n            if (!d.some(v => typeof v !== `undefined`))\n                return;\n            yield d;\n        }\n        if (isAllDone())\n            go = false;\n    }\n    // let somethingProduced = true;\n    // while (somethingProduced) {\n    //   let data = [];\n    //   for (let index = 0; index < sourcesInput.length; index++) {\n    //     // eslint-disable-next-line unicorn/no-null\n    //     data[ index ] = null;\n    //   }\n    //   somethingProduced = false;\n    //   // Request the next value from each source\n    //   for (const [ index, source ] of sourcesInput.entries()) {\n    //     const v = await source.next();\n    //     if (!v.done) {\n    //       data[ index ] = v.value;\n    //       somethingProduced = true;\n    //     }\n    //   }\n    //   if (somethingProduced) {\n    //     // Send data\n    //     yield data;\n    //     data = [];\n    //   }\n    // }\n}\n","export * as Dom from './dom.js';\nexport * as Links from './links.js';\nexport * as From from './from/index.js';\nexport * from './add-to-array.js';\nexport * from './as-array.js';\nexport * from './as-callback.js';\nexport * from './as-promise.js';\nexport * from './as-value.js';\nexport * from './combine-latest-to-array.js';\nexport * from './combine-latest-to-object.js';\nexport * from './lazy.js';\nexport * from './merge-flat.js';\nexport * from './prepare.js';\nexport * from './run.js';\nexport * from './single.js';\nexport * from './sync.js';\nexport * from './types.js';\nexport * from './utility.js';\n","import { compareIterableValuesShallow, isEqualDefault } from \"@ixfx/core\";\n/**\n * Returns the 'max' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const maxScore = (iterable, scorer) => {\n    let highestValue;\n    let highestScore = Number.MIN_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score >= highestScore) {\n            highestScore = score;\n            highestValue = value;\n        }\n    }\n    return highestValue;\n};\n/**\n * Returns the 'min' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const minScore = (iterable, scorer) => {\n    let lowestValue;\n    let lowestScore = Number.MAX_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score <= lowestScore) {\n            lowestScore = score;\n            lowestValue = value;\n        }\n    }\n    return lowestValue;\n};\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n *\n * Is NOT recursive.\n *\n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * hasEqualValuesShallow(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * hasEqualValuesShallow(a, b);\n * // True, since now we're comparing by value\n * hasEqualValuesShallow(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param iterableA First iterable to check\n * @param iterableB Iterable to compare against\n * @param eq Equality function, uses === by default\n */\nexport const hasEqualValuesShallow = (iterableA, iterableB, eq) => {\n    const returnValue = compareIterableValuesShallow(iterableA, iterableB, eq);\n    return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport { continuously } from \"@ixfx/core/continuously\";\n/**\n * Retrieve values from an iterator, passing them to a callback.\n * Allows iterator to be started, paused, or restarted and an optional delay between reading items from iterator.\n * @param options\n * @returns\n */\nexport const iteratorController = (options) => {\n    const delayMs = intervalToMs(options.delay, 10);\n    let gen;\n    const onValue = options.onValue;\n    let state = `stopped`;\n    const loop = continuously(async () => {\n        if (gen) {\n            const r = await gen.next();\n            if (r.done) {\n                state = `stopped`;\n                return false;\n            }\n            const r2 = onValue(r.value);\n            if (typeof r2 === `boolean`) {\n                if (!r2) {\n                    state = `stopped`;\n                }\n                return r2;\n            }\n            return true;\n        }\n        else {\n            state = `stopped`;\n            return false;\n        }\n    }, delayMs);\n    const cancel = () => {\n        if (state === `stopped`)\n            return;\n        gen = undefined;\n        loop.cancel();\n        state = `stopped`;\n    };\n    const pause = () => {\n        if (state === `paused`)\n            return;\n        loop.cancel();\n        state = `paused`;\n    };\n    const start = () => {\n        if (state === `running`)\n            return;\n        if (!gen) {\n            remake();\n        }\n        state = `running`;\n        loop.start();\n    };\n    const remake = () => {\n        if (options.iterator) {\n            gen = options.iterator();\n        }\n        else {\n            throw new Error(`No source iterator`);\n        }\n    };\n    const restart = () => {\n        remake();\n        start();\n    };\n    return {\n        start, cancel, restart, pause,\n        get state() {\n            return state;\n        }\n    };\n};\n","export const fromEvent = (eventSource, eventType) => {\n    const pullQueue = [];\n    const pushQueue = [];\n    let done = false;\n    const pushValue = (args) => {\n        if (pullQueue.length > 0) {\n            //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const resolver = pullQueue.shift();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            resolver(...args);\n        }\n        else {\n            pushQueue.push(args);\n        }\n    };\n    const pullValue = () => new Promise((resolve) => {\n        if (pushQueue.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arguments_ = pushQueue.shift();\n            // @ts-expect-error\n            resolve(...arguments_);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const handler = (...arguments_) => {\n        pushValue(arguments_);\n    };\n    eventSource.addEventListener(eventType, handler);\n    const r = {\n        next: async () => {\n            if (done)\n                return { done: true, value: undefined };\n            return {\n                done: false,\n                value: await pullValue(),\n            };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        return: async () => {\n            done = true;\n            eventSource.removeEventListener(eventType, handler);\n            return { done: true, value: undefined };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        throw: async (error) => {\n            done = true;\n            return {\n                done: true,\n                value: Promise.reject(new Error(error)),\n            };\n        },\n    };\n    return r;\n};\n","import { numberArrayCompute } from \"@ixfx/numbers\";\nimport { isIterable } from \"./guard.js\";\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * const v = [ 10, 2, 4.2, 99 ];\n * const mma = numbersCompute(v);\n * // Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link https://api.ixfx.fun/_ixfx/numbers/average/ @ixfx/numbers.average}, {@link https://api.ixfx.fun/_ixfx/numbers/max/ @ixfx/numbers.max}, {@link https://api.ixfx.fun/_ixfx/numbers/min/ @ixfx/numbers.min} or {@link https://api.ixfx.fun/_ixfx/numbers/total/ @ixfx/numers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * import { count } from '@ixfx/numbers';\n * numbersCompute(count(5,1)); // Averages 1,2,3,4,5\n * ```\n *\n * Returns `NaN` if the input data is empty.\n * @param data\n * @param options Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const numbersCompute = (data, options = {}) => {\n    if (typeof data === `undefined`)\n        throw new Error(`Param 'data' is undefined`);\n    if (Array.isArray(data)) {\n        return numberArrayCompute(data, options);\n    }\n    if (isIterable(data)) {\n        return numbersComputeIterable(data, options);\n    }\n    throw new Error(`Param 'data' is neither an array nor iterable`);\n};\nfunction numbersComputeIterable(data, options = {}) {\n    // if (typeof options.startIndex !== `undefined` || typeof options.endIndex !== `undefined`) {\n    //   data = slice(data, options.startIndex, options.endIndex);\n    // }\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let v of data) {\n        if (typeof v !== `number` || Number.isNaN(v)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof v}'`);\n            if (nonNumbers === `nan`)\n                v = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += v;\n        count++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n    }\n    return {\n        avg: total / count,\n        total, max, min, count\n    };\n}\nexport function computeAverage(data, options = {}) {\n    let count = 0;\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    for (let d of data) {\n        if (typeof d !== `number` || Number.isNaN(d)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof d}'`);\n            if (nonNumbers === `nan`)\n                d = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += d;\n        count++;\n    }\n    return total / count;\n}\n","import * as Async from './async.js';\nimport * as Sync from './sync.js';\nexport * as Async from './async.js';\nexport * as Sync from './sync.js';\nexport * as Chains from './chain/index.js';\nexport { combineLatestToArray } from './chain/combine-latest-to-array.js';\nexport { combineLatestToObject } from './chain/combine-latest-to-object.js';\nexport * from './compare-values.js';\nexport * from './controller.js';\nexport * from './from-event.js';\nexport * from './guard.js';\nexport * from './types.js';\nimport { isAsyncIterable } from './guard.js';\n//import * as Chains from './chain/index.js';\n// import type { Interval } from '../flow/IntervalType.js';\nimport { toStringDefault } from '@ixfx/core';\nexport * from './numbers-compute.js';\n/**\n * Returns a stream of minimum values.\n *\n * Streaming result: works with endless iterables.\n *\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n *\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile(it, f) {\n    return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n*\n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it, callback) {\n    if (isAsyncIterable(it)) {\n        return Async.until(it, callback);\n    }\n    else {\n        Sync.until(it, callback);\n    }\n}\n/**\n * Breaks an iterable into array chunks\n *\n * Streaming: works with infinite iterables.\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks(it, size) {\n    return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter(it, f) {\n    return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f);\n}\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n *\n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill(it, v) {\n    return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n/**\n * Return concatenation of iterators.\n *\n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat(...its) {\n    return isAsyncIterable(its[0]) ? Async.concat(...its) : Sync.concat(...its);\n}\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find(it, f) {\n    return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f);\n}\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n *\n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach(it, fn, options = {}) {\n    if (isAsyncIterable(it)) {\n        return Async.forEach(it, fn, options);\n    }\n    else {\n        Sync.forEach(it, fn);\n    }\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map(it, f) {\n    return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray(array, interval) {\n    return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten(it) {\n    return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some(it, f) {\n    return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f);\n}\n/**\n * Returns the last item of an iterable, or _undefined_ if it yields no results.\n * @param it\n * @returns\n */\nexport function last(it) {\n    return isAsyncIterable(it) ? Async.last(it) : Sync.last(it);\n}\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce(it, f, start) {\n    return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n/**\n * Returns a section from an iterable.\n *\n * 'end' is the end index, not the number of items.\n *\n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, start, end);\n}\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique(iterable) {\n    if (Array.isArray(iterable)) {\n        if (iterable.length === 0)\n            return Sync.fromArray([]);\n        return isAsyncIterable(iterable[0]) ? Async.unique(iterable) : Sync.unique(iterable);\n    }\n    else if (isAsyncIterable(iterable)) {\n        return Async.unique(iterable);\n    }\n    else {\n        return Sync.unique(iterable);\n    }\n}\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n *\n * Streaming: Works with unbounded iterables.\n *\n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n *\n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n *\n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n *\n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n *\n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n *\n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input\n * @param seen\n * @param toString\n */\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    yield* isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n *\n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every(it, f) {\n    return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f);\n}\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n    return as ? Async.equals(it1, it2, equality) : Sync.equals(it1, it2, equality);\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip(...its) {\n    if (its.length === 0)\n        return Sync.fromArray([]);\n    return isAsyncIterable(its[0]) ? Async.zip(...its) : Sync.zip(...its);\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport function fromIterable(iterable, interval) {\n    if (isAsyncIterable(iterable) || interval !== undefined)\n        return Async.fromIterable(iterable, interval);\n    return Sync.fromIterable(iterable);\n}\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction(callback) {\n    while (true) {\n        const v = callback();\n        yield v;\n    }\n}\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback\n */\nexport async function* fromFunctionAwaited(callback) {\n    while (true) {\n        const v = await callback();\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    if (isAsyncIterable(input)) {\n        return Async.asCallback(input, callback);\n    }\n    else {\n        Sync.asCallback(input, callback);\n        return;\n    }\n}\n"],"mappings":"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"}