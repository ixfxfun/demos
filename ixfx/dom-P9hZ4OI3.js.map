{"version":3,"file":"dom-P9hZ4OI3.js","names":["source: string","match: string","options: Partial<MatchOptions>","pattern: string","value: string","#el","#containerEl","#stretch","#onSetSize","#size","#naturalRatio","#naturalSize","#viewport","#byViewport","#byContainer","#disposed","#resizeObservable","el","#onParentResize","#computeSizeBasedOnParent","#onViewportResize"],"sources":["../../packages/core/src/text.ts","../../packages/dom/dist/src/resolve-el.js","../../packages/dom/dist/src/css.js","../../packages/dom/dist/src/element-sizing.js","../../packages/dom/dist/src/css-angle.js","../../packages/dom/dist/src/ts-util.js","../../packages/dom/dist/src/css-variables.js","../../packages/dom/dist/src/set-property.js","../src/dom.ts"],"sourcesContent":["import { integerTest, throwFromResult } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n\n\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n * \n * If `source` is under `maxLength` the original is returned.\n * @param source \n * @param maxLength Maximum length. Defaults to 20\n * @returns \n */\nexport const abbreviate = (source: string, maxLength = 15) => {\n  // ✔️ Unit tested\n  throwFromResult(integerTest(maxLength, `aboveZero`, `maxLength`));\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n\n  if (source.length > maxLength && source.length > 3) {\n    if (maxLength > 15) {\n      const chunk = Math.round((maxLength - 2) / 2);\n      return source.slice(0, chunk) + `...` + source.slice(-chunk);\n    }\n    return source.slice(0, maxLength) + `...`;\n  }\n  return source;\n}\n\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns \n */\nexport const toStringAbbreviate = (source: any, maxLength = 20) => {\n  if (source === undefined) return `(undefined)`;\n  if (source === null) return `(null)`;\n  return abbreviate(JSON.stringify(source), maxLength);\n}\n\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): string | undefined => {\n  // ✔ Unit tested\n\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return;\n\n  return source.slice(startPos + 1, endPos);\n};\n\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): [ source: string, between: string | undefined ] => {\n  // ✔ Unit tested\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);\n  if (end !== undefined && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return [ source, undefined ];\n\n  if (end === undefined) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return [ source, undefined ];\n\n  const between = source.slice(startPos + 1, endPos);\n  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n  return [ sourceResult, between ];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (\n  source: string,\n  code: number,\n  start = 0,\n  end = source.length - 1\n): number => {\n  //eslint-disable-next-line functional/no-let\n  for (let index = start; index <= end; index++) {\n    if (source.codePointAt(index) === code) return index;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (\n  source: string,\n  removeStart: number,\n  removeLength: number\n) =>\n  source.slice(0, removeStart) +\n  source.slice(removeStart + removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (\n  source: string | null,\n  length: number\n): readonly string[] => {\n  throwFromResult(integerTest(length, `aboveZero`, `length`));\n  if (source === null) throw new Error(`source parameter null`);\n  if (typeof source !== `string`) {\n    throw new TypeError(`source parameter not a string`);\n  }\n\n  // ✔ Unit tested\n  const chunks = Math.ceil(source.length / length);\n  const returnValue: string[] = [];\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n\n  //eslint-disable-next-line functional/no-let\n  for (let c = 0; c < chunks; c++) {\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push(source.slice(start, start + length));\n    start += length;\n  }\n  return returnValue;\n};\n\n\n\n/**\n * Returns the `source` string up until (and excluding) `match`. \n * \n * By default, if match is not found, all of `source` is returned.\n *\n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * \n * If match is not found, fallback can be returned instead:\n * ```js\n * // Yields 'lemon'\n * untilMatch(`apple orange mellon`, `kiwi`, { fallback: `lemon` });\n * ```\n * \n * Or an exception thrown\n * ```js\n * // Throws\n * untilMatch(`apple orange mellon`, `kiwi`, { ifNoMatch: `throw` });\n * ```\n * @param source\n * @param match\n * @param startPos If provided, gives the starting offset. Default 0\n */\n// export const untilMatch = (\n//   source: string,\n//   match: string,\n//   options: Partial<UntilMatchOptions> = {}\n// ): string => {\n//   //  ✔️ Unit tested\n//   let fallback = options.fallback;\n//   const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n//   if (ifNoMatch === `original`) fallback = source;\n//   if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) {\n//     if (ifNoMatch === `throw`) throw new Error(`Match string not found in source`);\n//     // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n//     return fallback!;\n//   }\n//   return source.slice(startPos ?? 0, m);\n// };\n\n\n// export type UntilMatchOptions = MatchOptions & {\n//   ifNoMatch: `throw` | `original` | `fallback`,\n//   fallback?: string\n// }\n\nexport type MatchOptions = {\n  startPos: number;\n  fromEnd: boolean;\n  ifNoMatch: `throw` | `original` | `fallback`,\n  fallback: string\n}\n\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 0 ];\n}\n\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 1 ];\n}\n\n/**\n * Returns the text that is before and after `match`.\n * \n * See also: {@link beforeMatch}, {@link afterMatch}.\n * \n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source \n * @param match \n * @param options \n * @returns \n */\nexport const beforeAfterMatch = (source: string, match: string, options: Partial<MatchOptions> = {}): [ before: string, after: string ] => {\n  if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n  let fallback = options.fallback;\n  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n  if (ifNoMatch === `original`) fallback = source;\n  if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0 && ifNoMatch === `throw`) throw new Error(`Match '${ match }' not found in source.`);\n  if (m < 0 && ifNoMatch === `original`) return [ source, source ];\n  if (m < 0 && ifNoMatch === `fallback`) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [ fallback!, fallback! ];\n  }\n  return [\n    source.slice(0, m),\n    source.slice(Math.max(0, m + match.length))\n  ]\n}\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (\n  source: string,\n  ...wrappers: readonly string[]\n): string => {\n  //eslint-disable-next-line functional/no-let\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.slice(w.length, source.length - w.length * 2 + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string;\n  /**\n   * Start position, with respect to source text\n   */\n  readonly start: number;\n  /**\n   * End position, with respect to source text\n   */\n  readonly end: number;\n  /**\n   * Index of range. First range is 0\n   */\n  readonly index: number;\n}\n\nexport type LineSpan = {\n  readonly start: number;\n  readonly end: number;\n  readonly length: number;\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (\n  ranges: readonly Range[],\n  start: number,\n  end: number\n): LineSpan => {\n  //eslint-disable-next-line functional/no-let\n  let s = -1;\n  //eslint-disable-next-line functional/no-let\n  let endPos = -1;\n  //eslint-disable-next-line functional/no-let\n  for (const [ index, r ] of ranges.entries()) {\n    s = index;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  //eslint-disable-next-line functional/no-let\n  for (let index = s; index < ranges.length; index++) {\n    const r = ranges[ index ];\n    endPos = index;\n    if (end === r.end) {\n      endPos = index + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return { length: endPos - s, start: s, end: endPos };\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (\n  source: string,\n  split: string\n): readonly Range[] => {\n  //eslint-disable-next-line functional/no-let\n  let start = 0;\n  //eslint-disable-next-line functional/no-let\n  let text = ``;\n  const ranges: Range[] = [];\n  //eslint-disable-next-line functional/no-let\n  let index = 0;\n  //eslint-disable-next-line functional/no-let,unicorn/prevent-abbreviations\n  for (let i = 0; i < source.length; i++) {\n    if (source.indexOf(split, i) === i) {\n      //eslint-disable-next-line functional/no-let\n      const end = i;\n      //eslint-disable-next-line functional/immutable-data\n      ranges.push({\n        text,\n        start,\n        end,\n        index,\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(i);\n    }\n  }\n  if (start < source.length) {\n    //eslint-disable-next-line functional/immutable-data\n    ranges.push({ text, start, index, end: source.length });\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (\n  source: string,\n  ...chars: readonly string[]\n): number => {\n  //eslint-disable-next-line functional/no-let\n  let counted = 0;\n  //eslint-disable-next-line functional/no-let\n  for (let index = 0; index < source.length; index++) {\n    if (chars.includes(source.charAt(index))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (\n  source: string,\n  start: string,\n  end: string = start\n): boolean => source.startsWith(start) && source.endsWith(end);\n\n\nexport const htmlEntities = (source: string): string =>\n  source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${ index.codePointAt(0) };`);\n\n\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern \n * @returns \n */\nexport const wildcard = (pattern: string) => {\n  // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n  // for this solution to work on any string, no matter what characters it has\n  const escapeRegex = (value: string) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n\n  // \".\"  => Find a single character, except newline or line terminator\n  // \".*\" => Matches any string that contains zero or more characters\n  pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n\n  // \"^\"  => Matches any string with the following at the beginning of it\n  // \"$\"  => Matches any string with that in front at the end of it\n  pattern = `^` + pattern + `$`\n\n  // Create a regular expression object for matching string\n  const regex = new RegExp(pattern);\n\n  return (value: string) => {\n    // Returns true if it finds a match, otherwse it returns false\n    return regex.test(value);\n  }\n}","import { resultToError } from \"@ixfx/core\";\n/**\n * Resolves either a string or HTML element to an element.\n * Useful when an argument is either an HTML element or query.\n *\n * ```js\n * resolveEl(`#someId`);\n * resolveEl(someElement);\n * ```\n * @param domQueryOrEl\n * @returns\n */\nexport const resolveEl = (domQueryOrEl) => {\n    const r = resolveElementTry(domQueryOrEl);\n    if (r.success)\n        return r.value;\n    throw resultToError(r);\n};\nexport const resolveElementTry = (domQueryOrEl) => {\n    if (typeof domQueryOrEl === `string`) {\n        const d = document.querySelector(domQueryOrEl);\n        if (d === null) {\n            const error = domQueryOrEl.startsWith(`#`) ? `Query '${domQueryOrEl}' did not match anything. Try '#id', 'div', or '.class'`\n                : `Query '${domQueryOrEl}' did not match anything. Did you mean '#${domQueryOrEl}?`;\n            return { success: false, error };\n        }\n        domQueryOrEl = d;\n    }\n    else if (domQueryOrEl === null) {\n        return { success: false, error: `Param 'domQueryOrEl' is null` };\n    }\n    else if (domQueryOrEl === undefined) {\n        return { success: false, error: `Param 'domQueryOrEl' is undefined` };\n    }\n    const el = domQueryOrEl;\n    return { success: true, value: el };\n};\nexport const resolveEls = (selectors) => {\n    if (selectors === undefined)\n        return [];\n    if (selectors === null)\n        return [];\n    if (Array.isArray(selectors))\n        return selectors;\n    if (typeof selectors === `string`) {\n        const elements = [...document.querySelectorAll(selectors)];\n        return elements;\n    }\n    return [selectors];\n};\n","import { resolveEl, resolveEls } from \"./resolve-el.js\";\n/**\n * Returns the value of `getBoundingClientRect` plus the width of all the borders\n * @param elOrQuery\n * @returns\n */\nexport const getBoundingClientRectWithBorder = (elOrQuery) => {\n    let el = resolveEl(elOrQuery);\n    const size = el.getBoundingClientRect();\n    if (el instanceof SVGElement) {\n        el = el.parentElement;\n    }\n    const border = getComputedPixels(el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);\n    return {\n        x: size.x,\n        y: size.y,\n        width: size.width + border.borderLeftWidth + border.borderRightWidth,\n        height: size.height + border.borderTopWidth + border.borderBottomWidth\n    };\n};\n/**\n * Returns the computed measurements of CSS properties via [getComputedStyle](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle).\n * ```js\n * const v = getComputedPixels(`#some-el`, `borderTopWidth`, `borderLeftWidth`);\n * v.borderTopWidth;  // number\n * b.borderLeftWidth; // number\n * ```\n *\n * Throws an error if value from `getComputedStyle` is not a string or does not end in 'px'.\n * @param elOrQuery\n * @param properties\n * @returns\n */\nexport const getComputedPixels = (elOrQuery, ...properties) => {\n    const s = getComputedStyle(resolveEl(elOrQuery));\n    const returnValue = {};\n    for (const property of properties) {\n        const v = s[property];\n        if (typeof v === `string`) {\n            if (v.endsWith(`px`)) {\n                returnValue[property] = Number.parseFloat(v.substring(0, v.length - 2));\n            }\n            else {\n                throw new Error(`Property '${String(property)}' does not end in 'px'. Value: ${v}`);\n            }\n        }\n        else {\n            throw new Error(`Property '${String(property)}' is not type string. Got: ${typeof v} Value: ${v}`);\n        }\n    }\n    return returnValue;\n};\n/**\n * Adds `cssClass` to element(s) if `value` is true.\n * ```js\n * setClass(`#someId`, true, `activated`);\n * ```\n * @param selectors\n * @param value\n * @param cssClass\n * @returns\n */\nexport const setCssClass = (selectors, value, cssClass) => {\n    const elements = resolveEls(selectors);\n    if (elements.length === 0)\n        return;\n    for (const element of elements) {\n        if (value)\n            element.classList.add(cssClass);\n        else\n            element.classList.remove(cssClass);\n    }\n};\n/**\n * Toggles a CSS class on all elements that match selector\n * @param selectors\n * @param cssClass\n * @returns\n */\nexport const setCssToggle = (selectors, cssClass) => {\n    const elements = resolveEls(selectors);\n    if (elements.length === 0)\n        return;\n    for (const element of elements) {\n        element.classList.toggle(cssClass);\n    }\n};\nexport const setCssDisplay = (selectors, value) => {\n    const elements = resolveEls(selectors);\n    if (elements.length === 0)\n        return;\n    for (const element of elements) {\n        (element).style.display = value;\n    }\n};\n","import { resolveEl } from \"./resolve-el.js\";\nimport { getComputedPixels } from \"./css.js\";\nimport { Rects } from \"@ixfx/geometry\";\n/**\n * Consider using static methods:\n *\n * ```js\n * // Resize an <SVG> element to match viewport\n * Dom.ElementSizer.svgViewport(svg);\n *\n * // Resize canvas to match its parent\n * Dom.ElementSizer.canvasParent(canvas);\n *\n * // Resize canvas to match viewport\n * Dom.ElementSizer.canvasViewport(canvas);\n * ```\n */\nexport class ElementSizer {\n    #stretch;\n    #size;\n    #naturalSize;\n    #naturalRatio;\n    #viewport;\n    #onSetSize;\n    #el;\n    #containerEl;\n    #disposed = false;\n    #resizeObservable;\n    constructor(elOrQuery, options) {\n        this.#el = resolveEl(elOrQuery);\n        this.#containerEl = options.containerEl ? resolveEl(options.containerEl) : this.#el.parentElement;\n        this.#stretch = options.stretch ?? `none`;\n        this.#onSetSize = options.onSetSize;\n        this.#size = Rects.Empty;\n        let naturalSize = options.naturalSize;\n        if (naturalSize === undefined) {\n            naturalSize = this.#el.getBoundingClientRect();\n        }\n        this.#naturalRatio = 1;\n        this.#naturalSize = naturalSize;\n        this.setNaturalSize(naturalSize);\n        this.#viewport = Rects.EmptyPositioned;\n        if (this.#containerEl === document.body) {\n            this.#byViewport();\n        }\n        else {\n            this.#byContainer();\n        }\n    }\n    dispose(reason) {\n        if (this.#disposed)\n            return;\n        this.#disposed = true;\n        if (this.#resizeObservable) {\n            this.#resizeObservable.disconnect();\n            this.#resizeObservable = undefined;\n        }\n    }\n    static canvasParent(canvasElementOrQuery, options) {\n        const el = resolveEl(canvasElementOrQuery);\n        const er = new ElementSizer(el, {\n            ...options,\n            onSetSize(size, el) {\n                el.width = size.width;\n                el.height = size.height;\n                if (options.onSetSize)\n                    options.onSetSize(size, el);\n            },\n        });\n        return er;\n    }\n    static canvasViewport(canvasElementOrQuery, options) {\n        const el = resolveEl(canvasElementOrQuery);\n        el.style.position = `absolute`;\n        el.style.zIndex = (options.zIndex ?? 0).toString();\n        el.style.left = `0px`;\n        el.style.top = `0px`;\n        const opts = { ...options, containerEl: document.body };\n        return this.canvasParent(canvasElementOrQuery, opts);\n    }\n    /**\n     * Size an SVG element to match viewport\n     * @param svg\n     * @returns\n     */\n    static svgViewport(svg, onSizeSet) {\n        const er = new ElementSizer(svg, {\n            containerEl: document.body,\n            stretch: `both`,\n            onSetSize(size) {\n                svg.setAttribute(`width`, size.width.toString());\n                svg.setAttribute(`height`, size.height.toString());\n                if (onSizeSet)\n                    onSizeSet(size);\n            },\n        });\n        return er;\n    }\n    #byContainer() {\n        const c = this.#containerEl;\n        if (!c)\n            throw new Error(`No container element`);\n        // Listen for resize\n        const r = new ResizeObserver((entries) => {\n            this.#onParentResize(entries);\n        });\n        r.observe(c);\n        // Get current value\n        const current = this.#computeSizeBasedOnParent(c.getBoundingClientRect());\n        this.size = current;\n        this.#resizeObservable = r;\n    }\n    #byViewport() {\n        const r = new ResizeObserver((entries) => {\n            this.#onViewportResize();\n        });\n        r.observe(document.documentElement);\n        this.#resizeObservable = r;\n        this.#onViewportResize();\n    }\n    #onViewportResize() {\n        this.size = { width: window.innerWidth, height: window.innerHeight };\n        this.#viewport = {\n            x: 0, y: 0,\n            ...this.size\n        };\n    }\n    /**\n     * Sets the 'natural' size of an element.\n     * This can also be specified when creating ElementSizer.\n     * @param size\n     */\n    setNaturalSize(size) {\n        this.#naturalSize = size;\n        this.#naturalRatio = size.width / size.height;\n    }\n    get naturalSize() {\n        return this.#naturalSize;\n    }\n    get viewport() {\n        return this.#viewport;\n    }\n    #computeSizeBasedOnParent(parentSize) {\n        let { width, height } = parentSize;\n        let stretch = this.#stretch;\n        if (stretch === `min`) {\n            stretch = width < height ? `width` : `height`;\n        }\n        else if (stretch === `max`) {\n            stretch = width > height ? `width` : `height`;\n        }\n        if (stretch === `width`) {\n            height = width / this.#naturalRatio;\n        }\n        else if (stretch === `height`) {\n            width = height * this.#naturalRatio;\n        }\n        // If we have a border, take that into account\n        if (this.#el instanceof HTMLElement) {\n            const b = getComputedPixels(this.#el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);\n            width -= (b.borderLeftWidth + b.borderRightWidth);\n            height -= (b.borderTopWidth + b.borderBottomWidth);\n        }\n        return { width, height };\n    }\n    #onParentResize(args) {\n        const box = args[0].contentBoxSize[0];\n        const parentSize = { width: box.inlineSize, height: box.blockSize };\n        this.size = this.#computeSizeBasedOnParent(parentSize);\n        this.#viewport = {\n            x: 0, y: 0,\n            width: parentSize.width,\n            height: parentSize.height\n        };\n    }\n    set size(size) {\n        Rects.guard(size, `size`);\n        this.#size = size;\n        this.#onSetSize(size, this.#el);\n    }\n    get size() {\n        return this.#size;\n    }\n}\n","export const cssAngleParse = (value) => {\n    if (typeof value === `number`) {\n        return {\n            value, unit: `deg`\n        };\n    }\n    value = value.toLowerCase();\n    if (value.endsWith(`rad`)) {\n        return {\n            value: Number.parseFloat(value.substring(0, value.length - 3)),\n            unit: `rad`\n        };\n    }\n    if (value.endsWith(`turn`)) {\n        return {\n            value: Number.parseFloat(value.substring(0, value.length - 4)),\n            unit: `turn`\n        };\n    }\n    if (value.endsWith(`deg`)) {\n        return {\n            value: Number.parseFloat(value.substring(0, value.length - 3)),\n            unit: `deg`\n        };\n    }\n    return {\n        value: Number.parseFloat(value),\n        unit: `deg`\n    };\n};\n","/* eslint-disable unicorn/prevent-abbreviations */\nexport function isHtmlElement(o) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return (typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n        o && typeof o === \"object\" && o !== null && o.nodeType === 1 && typeof o.nodeName === \"string\");\n}\n","import * as Text from \"@ixfx/core/text\";\nimport { resolveEl } from \"./resolve-el.js\";\nimport { isHtmlElement } from \"./ts-util.js\";\n/**\n * Parses input in the form of: `['elementid-attribute', 'default-value']`.\n * Eg, `['indicator-fill', 'gray']` will yield:\n * ```\n * { variable: `indicator-fill`, attribute: `fill`, id: `indicator`, defaultValue: `gray` }\n * ```\n *\n * Once parsed, use {@link setFromVariables} to apply data.\n *\n * ```js\n * // Array of arrays is treated as a set of key-value pairs\n * const options = [ [`indicator-fill`, `gray`], [`backdrop-fill`, `whitesmoke`] ]\n * const attrs = parseAsAttributes(options);\n * Yields:\n * [\n *  { variable: `indicator-fill`, attribute: `fill`, id: `indicator`, defaultValue: `gray` }\n *  { variable: `backdrop-fill`, attribute: `fill`, id: `backdrop`, defaultValue: `whitesmoke` }\n * ]\n *\n * // Assign\n * setFromCssVariables(document.body, attrs);\n * ```\n * @param options\n * @returns\n */\nexport const parseAsAttributes = (options) => {\n    return options.map(opt => {\n        let defaultValue;\n        // Nested array, treat second element as default value, name as first\n        if (Array.isArray(opt)) {\n            defaultValue = opt[1];\n            opt = opt[0];\n        }\n        const dash = opt.indexOf(`-`);\n        if (dash < 0)\n            throw new Error(`Simple expression expects form of: 'elementid-attribute'`);\n        return {\n            variable: opt,\n            attribute: opt.slice(dash + 1),\n            id: opt.slice(0, dash),\n            defaultValue\n        };\n    });\n};\n/**\n * Reads the value of a CSS variable and assign it to HTML attributes or object field.\n *\n * ```js\n * const options = [\n *  // Set the 'width' attribute to the value of --some-css-variable to all elements with class 'blah'\n *  { query: `.blah`, variable: `some-css-variable`, attribute: `width` }\n *\n *  // Set #blah's 'size' attribute to the value of css variable '--size'\n *  { id: 'blah', variable: 'size', attribute: 'size' }\n *\n *  // Sets someEL.blah = css variable '--hue'\n *  { element: someEl, variable: `hue`, field: `blah` }\n * ]\n *\n * setFromVariables(document.body, ...options);\n * ```\n *\n * The first parameter is the context for which CSS variable values are fetched\n * as well as for resolving query selectors. This can usually be `document.body`.\n * @param context Context element which is needed for relative querying. Otherwise use document.body\n * @param options Details of what to do\n */\nexport const setFromVariables = (context, ...options) => {\n    const contextEl = resolveEl(context);\n    const style = window.getComputedStyle(contextEl);\n    for (const opt of options) {\n        const variable = Text.afterMatch(opt.variable, `--`);\n        let v = style.getPropertyValue(`--${variable}`);\n        if (v === null || v.length === 0) {\n            if (opt.defaultValue === undefined) {\n                continue;\n            }\n            else {\n                v = opt.defaultValue;\n            }\n        }\n        let query;\n        let els; //: SVGElement | HTMLElement | null | undefined;\n        if (`query` in opt && opt.query !== undefined) {\n            query = opt.query;\n        }\n        else if (`id` in opt && opt.id !== undefined) {\n            query = `#${opt.id}`;\n        }\n        else if (`object` in opt && opt.object !== undefined) {\n            els = Array.isArray(opt.object) ? opt.object : [opt.object];\n        }\n        if (query === undefined) {\n            // No query\n            if (els === undefined) {\n                // If there's no query or objects, there's nothing to do\n                throw new Error(`Missing 'query', 'id' or 'object' fields`);\n            }\n        }\n        else {\n            // Run query\n            els = [...contextEl.querySelectorAll(query)]; // as SVGElement | HTMLElement | null | undefined;\n        }\n        if (els === null)\n            continue;\n        if (els === undefined)\n            continue;\n        if (opt.attribute) {\n            for (const el of els) {\n                if (isHtmlElement(el)) {\n                    el.setAttribute(opt.attribute, v);\n                }\n                else {\n                    throw new Error(`Trying to set an attribute on something not a HTML element`, el);\n                }\n            }\n        }\n        else if (opt.field) {\n            for (const el of els) {\n                if (typeof el === `object`) {\n                    (el)[opt.field] = v;\n                }\n                else {\n                    throw new Error(`Trying to set field on something that is not an object (${typeof el})`, el);\n                }\n            }\n        }\n        else {\n            throw new Error(`Neither 'attribute' or 'field' to set is defined in option (${JSON.stringify(opt)})`);\n        }\n    }\n};\n/**\n * Computes the styles for `elt` (or defaults to document.body) using `fallback`\n * as a set of default values.\n *\n * ```js\n * // Fetch styles\n * const styles = getWithFallback({\n *  my_var: `red`\n * }, element);\n *\n * // Access --my-var, or if it doesn't exist returns 'red'\n * styles.my_var;\n * ```\n *\n * Hyphen case (eg 'my-var') is a common way of delimiting words in CSS variables, but\n * can't be (elegantly) used in object properties. Instead, use '_' in the\n * object key, which is replaced with '-'.\n *\n * The leading '--' is not needed either.\n * @param fallback\n * @param elt\n * @returns\n */\nexport function getWithFallback(fallback, elt) {\n    const styles = getComputedStyle(elt ?? document.body);\n    const entries = Object.entries(fallback);\n    const filledEntries = entries.map(entry => {\n        return [entry[0], getFromStyles(styles, entry[0], entry[1])];\n    });\n    return Object.fromEntries(filledEntries);\n}\n/**\n * Sets CSS variables.\n * ```js\n * const vars = {\n *  my_var: `red`,\n *  my_size: 10\n * }\n *\n * // Set to document.body\n * setVariables(vars);\n *\n * // Set to an element\n * setVariables(vars, elem);\n *\n * // Or to a CSSStyleDeclaration\n * setVariables(vars, styles);\n * ```\n * @param vars\n * @param stylesOrEl\n */\nexport function setVariables(variables, stylesOrEl) {\n    const styles = stylesOrEl === undefined ? document.body.style :\n        isHtmlElement(stylesOrEl) ? stylesOrEl.style : stylesOrEl;\n    for (const [key, value] of Object.entries(variables)) {\n        let variableName = key.replaceAll('_', '-');\n        if (!variableName.startsWith(`--`))\n            variableName = `--` + variableName;\n        styles.setProperty(variableName, value.toString());\n    }\n}\n/**\n * Returns a CSS variable from a CSS style declaration, or returning `fallback`.\n * ```js\n * // These will all access --my-var\n * getFromStyles(getComputedStyle(element), `--my-var`, `red`);\n * getFromStyles(getComputedStyle(element), `my-var`, `red`);\n * getFromStyles(getComputedStyle(element), `my_var`, `red`);\n * ```\n * @param styles\n * @param name\n * @param fallback\n * @returns\n */\nexport function getFromStyles(styles, name, fallback) {\n    if (!name.startsWith(`--`))\n        name = `--` + name;\n    name = name.replaceAll(`_`, `-`);\n    const v = styles.getPropertyValue(name);\n    if (v.length === 0) {\n        return fallback;\n    }\n    if (typeof fallback === `number`)\n        return parseFloat(v);\n    if (typeof fallback === `boolean`) {\n        if (v === `true`)\n            return true;\n        else if (v === `false`)\n            return false;\n    }\n    return v;\n}\n","import { resolveEls } from \"./resolve-el.js\";\nexport function setText(selectors, value) {\n    return setProperty(`textContent`, selectors, value);\n}\n;\nexport function setHtml(selectors, value) {\n    return setProperty(`innerHTML`, selectors, value);\n}\n;\nexport function setProperty(property, selectors, value) {\n    let elements = [];\n    const set = (v) => {\n        const typ = typeof v;\n        const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v :\n            JSON.stringify(v);\n        if (elements.length === 0) {\n            elements = resolveEls(selectors);\n        }\n        for (const element of elements) {\n            element[property] = vv;\n        }\n        return vv;\n    };\n    return value === undefined ? set : set(value);\n}\n;\n","export * from '@ixfx/dom';"],"mappings":"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"}