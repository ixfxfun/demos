{"version":3,"file":"src-Cjy4Jx5o.js","names":["value: unknown","itemToMakeStringFor: V","value: null | boolean | string | object","x: number","y: number","x: any","y: any","comparer: Comparer<V>","x: V","y: V","callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback","interval?: Interval","options: Partial<ContinuouslyOpts>","runState: HasCompletionRunStates","currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined","scheduledCallback: () => void","interval: Interval","interval","a: Scored","b: Scored","similarityFunction: Similarity<V>","lastData: readonly DataWithId<V>[] | undefined","newData: readonly DataWithId<V>[]","options: AlignOpts","newThings: DataWithId<V>[]","fn: Similarity<V>","lastData: readonly DataWithId<V>[]","newData: DataWithId<V>[]","a: V","v: V","predicate: (v: V) => boolean","skipValue: V | undefined","source: string","source: any","eq: IsEqual<T>","itemToMakeStringFor: unknown","key: string","value: unknown","a: T","b: T","a: Record<string, unknown>","b: Record<string, unknown>","fieldComparer?: IsEqual<unknown>","value: object","isEqualContextString: IsEqualContext<unknown>","a: unknown","b: unknown","_path: string","value: string | number","value: any","a: Iterable<V>","b: Iterable<V>","shared:V[]","aUnique:V[]","bUnique:V[]","index: number","values: KeyValue[]","sortStyle: KeyValueSortSyles","a: number","b?: number | boolean","roundUp?: boolean","v: number","interval: Interval | undefined","defaultNumber?: number","interval: number | Interval | undefined","millisOrFunction: number | (() => number) | Interval","interval: number | undefined","toString: ToString<T>","value: T","target: EventTarget","name: string","resolve","rx: object","r: ResolveToValue<V>","r: ResolveToValueSync<V>","p: ResolveToValue<T>","fallback: ResolveFallbackOpts<T>","p: ResolveToValueSync<T>","returnValue: any[]","object: T","resolvers: any[]","keys: string[]","entries: [ key: string, value: any ][]","optsOrMillis: SleepOpts<V>","resolve","predicate: () => boolean","checkInterval: Interval","compareObjectKeys","compareArrays","compareObjectData","mapObjectKeys","cloneFromFields","mapObjectShallow","isPrimitive","recordChildren","isPrimitive","getEntries","compareData","updateByPath","updateByPathImpl","compareObjectKeys","getField","getFieldImpl","getPathsAndData","getPathsAndDataImpl","mapObjectKeys","a: object","b: object","r: CompareChangeSet<TKey>","a: TValue[]","b: TValue[]","eq: IsEqual<TValue>","key: string","cc: CompareChangeSet<number>","mapObjectKeys","a: object | null","b: object | null","eq: IsEqual<T>","removed: string[]","source: T","entries: [ key: string, value: any ][]","object: TSource","mapFunction: (args: MapObjectArgs) => TFieldValue","data: object","mapper: Record<string, (value: any, context: any) => any>","entries: readonly RecordEntry[]","node: object","options: Partial<RecordChildrenOptions>","node: T","v: any","recordEntriesDepthFirst","ancestors: string[]","name: string","path: string","options: PathOpts","object: Record<string | number | symbol, T>","onInvalidKey: `throw` | `ignore` | `keep`","returnObject: Record<number, T>","target: V","deepProbe: boolean","entries: [ key: string, value: any ][]","a: V","b: Partial<V>","options: Partial<CompareDataOptions<V>>","source: V","changes: PathDataChange<any>[]","path: string","value: any","o: any","split: string[]","allowShapeChange: boolean","object: Record<string, any>","object: object | null","o: object","prefix: string","maxDepth: number","object: Record<TKeySource, unknown>","mapFunction: (key: TKeySource) => TKeyDestination"],"sources":["../packages/core/src/to-string.ts","../packages/core/src/comparers.ts","../packages/core/src/continuously.ts","../packages/core/src/correlate.ts","../packages/core/src/default-keyer.ts","../packages/core/src/elapsed.ts","../packages/core/src/filters.ts","../packages/core/src/text.ts","../packages/core/src/is-equal-test.ts","../packages/core/src/is-equal.ts","../packages/core/src/is-integer.ts","../packages/core/src/is-primitive.ts","../packages/core/src/iterable-compare-values-shallow.ts","../packages/core/src/key-value.ts","../packages/core/src/util/round.ts","../packages/core/src/interval-type.ts","../packages/core/src/track-unique.ts","../packages/core/src/platform.ts","../packages/core/src/promise-from-event.ts","../packages/core/src/reactive-core.ts","../packages/debug/dist/src/util.js","../packages/debug/dist/src/logger.js","../packages/debug/dist/src/fps-counter.js","../packages/debug/dist/src/error-message.js","../packages/debug/dist/src/index.js","../packages/core/src/resolve-core.ts","../packages/core/src/util/zip.ts","../packages/core/src/resolve-fields.ts","../packages/core/src/sleep.ts","../packages/core/dist/src/records/compare.js","../packages/core/dist/src/records/clone-from-fields.js","../packages/core/dist/src/records/map-object.js","../packages/core/dist/src/is-primitive.js","../packages/core/dist/src/records/traverse.js","../packages/core/dist/src/records/pathed.js","../packages/core/dist/src/records/index.js","../packages/core/src/records/compare.ts","../packages/core/src/records/clone-from-fields.ts","../packages/core/src/records/map-object.ts","../packages/core/src/records/traverse.ts","../packages/core/src/records/merge.ts","../packages/core/src/records/keys-to-numbers.ts","../packages/core/src/records/pathed.ts","../packages/core/src/records/index.ts","../packages/core/src/trackers/index.ts"],"sourcesContent":["\n// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString\nconst toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\n/**\n * Returns _true_ if `value` is a Map type\n * @param value\n * @returns \n */\nexport const isMap = (value: unknown): value is Map<any, any> =>\n  toTypeString(value) === `[object Map]`\n\n/**\n * Returns _true_ if `value` is a Set type\n * @param value \n * @returns \n */\nexport const isSet = (value: unknown): value is Set<any> =>\n  toTypeString(value) === `[object Set]`\n\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n\n\n/**\n * Converts a value to string form.\n * For simple objects, .toString() is used, other JSON.stringify is used.\n * It is meant for creating debugging output or 'hash' versions of objects, and does\n * not necessarily maintain full fidelity of the input\n * @param value \n * @returns \n */\nexport const defaultToString = (value: null | boolean | string | object): string => {\n  //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n  if (value === null) return `null`;\n  if (typeof value === `boolean` || typeof value === `number`) {\n    return value.toString();\n  }\n\n  if (typeof value === `string`) return value;\n  if (typeof value === `symbol`) throw new TypeError(`Symbol cannot be converted to string`);\n  return JSON.stringify(value);\n};","import { defaultToString } from \"./to-string.js\";\n\nexport type CompareResult = number; // 0 | 1 | -1;\nexport type Comparer<V> = (a: V, b: V) => CompareResult;\n\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * @param x\n * @param y\n * @returns\n */\nexport const numericComparer = (x: number, y: number): CompareResult => {\n  // ✔️ Unit tested\n  if (x === y) return 0;\n  if (x > y) return 1;\n  return -1;\n};\n\n\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n * \n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\n\nexport const jsComparer = (x: any, y: any): CompareResult => {\n  // ✔️ Unit tested\n\n  // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n  if (x === undefined && y === undefined) return 0;\n  if (x === undefined) return 1;\n  if (y === undefined) return -1;\n\n  const xString = defaultToString(x);\n  const yString = defaultToString(y);\n\n  if (xString < yString) return -1;\n  if (xString > yString) return 1;\n  return 0;\n};\n\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = <V>(comparer: Comparer<V>): Comparer<V> => {\n  return (x: V, y: V) => {\n    const v = comparer(x, y);\n    return v * -1;\n  };\n};\n\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n * \n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x: any, y: any): CompareResult => {\n  if (typeof x === `number` && typeof y === `number`) {\n    return numericComparer(x, y);\n  }\n  return jsComparer(x, y);\n};","import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs, type Interval } from '@ixfx/core';\n\nexport type HasCompletionRunStates = `idle` | `scheduled` | `running`;\nexport type HasCompletion = {\n  /**\n   * Gets the current run state\n   * idle: not yet started or completed with no future run scheduled\n   * scheduled: waiting to run\n   * running: currently executing its callback\n   */\n  get runState(): HasCompletionRunStates\n  /**\n   * Returns the number of times the scheduled function\n   * has been executed.\n   * \n   * This number will be reset in some conditions.\n   * For example `continuously` resets it when the loop stops.\n   * \n   * Use {@link startCountTotal} to track total number.\n   */\n  get startCount(): number\n\n  /**\n   * Total number of times scheduled function has been\n   * executed.\n   */\n  get startCountTotal(): number\n};\n\n/**\n * Runs a function continuously, returned by {@link continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, does nothing\n   */\n  start(): void;\n\n  /**\n   * (Re-)starts the loop. If an existing iteration has been\n   * scheduled, this is cancelled and started again.\n   *\n   * This can be useful when adjusting the interval\n   */\n  reset(): void;\n  /**\n   * How many milliseconds since loop was started after being stopped.\n   */\n  get elapsedMs(): number;\n  /**\n   * If disposed, the continuously instance won't be re-startable\n   */\n  get isDisposed(): boolean;\n  /**\n   * Stops loop. It can be restarted using .start()\n   */\n  cancel(): void;\n  /**\n   * Sets the interval speed of loop. Change will take effect on next loop. For it to kick\n   * in earlier, call .reset() after changing the value.\n   */\n  set interval(interval: Interval);\n  /**\n   * Gets the current interval, ie. speed of loop.\n   */\n  get interval(): Interval;\n};\n\nexport type ContinuouslySyncCallback = (\n  /**\n   * Number of times loop\n   * Ticks is reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => boolean | void;\n\nexport type ContinuouslyAsyncCallback = (\n  /**\n   * Number of times loop has run\n   * Reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits.\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => Promise<boolean | void>;\n\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n\n/**\n * Options for {@link continuously}\n */\nexport type ContinuouslyOpts = Readonly<{\n  /**\n   * Abort signal to exit loop\n   */\n  signal: AbortSignal;\n  /**\n   * If _true_, callback runs before waiting period.\n   * @defaultValue false\n   */\n  fireBeforeWait: boolean;\n  /**\n   * Called whenever .start() is invoked.\n   * If this function returns:\n   *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n   *  - `cancel`: loop stops, but can be re-started if .start() is called again\n   *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n   *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n   *\n   */\n  onStartCalled: (\n    /**\n     * Number of times loop has run\n     * Reset when loop is exits.\n     */\n    ticks?: number,\n    /**\n     * Elapsed milliseconds.\n     * Reset when loop is exits.\n     */\n    elapsedMs?: number\n  ) => OnStartCalled;\n}>;\n\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n * \n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n * \n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n * \n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n * \n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport const continuously = (\n  callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback,\n  interval?: Interval,\n  options: Partial<ContinuouslyOpts> = {}\n): Continuously => {\n  let intervalMs = intervalToMs(interval, 0);\n  resultThrow(integerTest(intervalMs, `positive`, `interval`));\n  const fireBeforeWait = options.fireBeforeWait ?? false;\n  const onStartCalled = options.onStartCalled;\n  const signal = options.signal;\n\n  let disposed = false;\n  let runState: HasCompletionRunStates = `idle`;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let startedAt = performance.now();\n  let intervalUsed = interval ?? 0;\n  let cancelled = false;\n  let currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const deschedule = () => {\n    if (currentTimer === undefined) return;\n    globalThis.clearTimeout(currentTimer);\n    currentTimer = undefined;\n    startCount = 0;\n    startedAt = Number.NaN;\n  }\n\n  const schedule = (scheduledCallback: () => void) => {\n    if (intervalMs === 0) {\n      if (typeof requestAnimationFrame === `undefined`) {\n        currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n      } else {\n        currentTimer = undefined;\n        requestAnimationFrame(scheduledCallback);\n      }\n    } else {\n      currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n    }\n  }\n\n  const cancel = () => {\n    if (cancelled) return;\n    cancelled = true;\n\n    if (runState === `idle`) return; // No need to cancel\n    runState = `idle`;\n    deschedule();\n  };\n\n  const loop = async () => {\n    if (signal?.aborted) {\n      runState = `idle`;\n    }\n    if (runState === `idle`) return;\n\n    runState = `running`\n    startCount++;\n    startCountTotal++;\n    const valueOrPromise = callback(startCount, performance.now() - startedAt);\n    const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n    if (cancelled) {\n      return;\n    }\n    runState = `scheduled`;\n\n    // Didn't get a value, exit out\n    if (value !== undefined && !value) {\n      cancel();\n      return;\n    }\n\n    if (cancelled) return; // has been cancelled\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    schedule(loop);\n  };\n\n  const start = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n\n    if (onStartCalled !== undefined) {\n      // A function governs whether to allow .start() to go ahead\n      const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n      switch (doWhat) {\n        case `cancel`: {\n          cancel();\n          return;\n        }\n        case `reset`: {\n          reset();\n          return;\n        }\n        case `dispose`: {\n          disposed = true;\n          cancel();\n          return;\n        }\n        // No default\n      }\n    }\n\n    if (runState === `idle`) {\n      // Start running\n      startCount = 0;\n      startedAt = performance.now();\n      runState = `scheduled`;\n      if (fireBeforeWait) {\n        void loop(); // Exec first, then wait\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop); // Wait first, then exec\n      }\n    } // else: already running, ignore\n  };\n\n  const reset = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n    startCount = 0;\n    startedAt = Number.NaN;\n\n    // Cancel scheduled iteration\n    if (runState !== `idle`) {\n      cancel();\n    }\n    start();\n  };\n\n  return {\n    start,\n    reset,\n    cancel,\n    get interval() {\n      return intervalUsed;\n    },\n    get runState() {\n      return runState;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    },\n    get startCount() {\n      return startCount;\n    },\n    set interval(interval: Interval) {\n      const ms = intervalToMs(interval, 0);\n      resultThrow(integerTest(ms, `positive`, `interval`));\n      intervalMs = ms;\n      intervalUsed = interval;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n  };\n};\n","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFunction Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\nexport const align = <V>(\n  similarityFunction: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  options: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = options.matchThreshold ?? 0;\n  const debug = options.debug ?? false;\n  const results = new Map<string, DataWithId<V>>();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map<string, DataWithId<V>>();\n  lastData?.forEach((d, index) => {\n    if (typeof d === `undefined`) {\n      throw new Error(`'lastData' contains undefined (index: ${ index.toString() })`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  for (const newD of newData) { //let index = 0; index < newData.length; index++) {\n    //const newD = newData[ index ];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${ newD.id }`);\n\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: (last).id,\n      score: (last as unknown) === null ? -1 : similarityFunction(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${ newD.id }`);\n      }\n      newThings.push(newD);\n      continue;\n    }\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[ 0 ];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${ top.score.toString() } id: ${ newD.id }`\n        );\n      }\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${ newD.id } -> ${ top.id } (score: ${ top.score.toString() })`\n      );\n    }\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    lastMap.delete(top.id);\n  }\n\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, options: AlignOpts = {}) => {\n  let lastData: readonly DataWithId<V>[] = [];\n\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, options);\n    return [ ...lastData ];\n  };\n  return compute;\n};\n","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = <V>(a: V) => {\n  return typeof a === `string` ? a : JSON.stringify(a);\n};","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since the initial call.\n * \n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns the interval between the start and each subsequent call.\n * \n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n * \n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns \n */\nexport const elapsedInterval = (): Since => {\n  let start = performance.now();\n  return (): number => {\n    const now = performance.now();\n    const x = now - start;\n    start = now;\n    return x;\n  }\n}\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n * \n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = (): Since => {\n  const start = Date.now();\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n","\n/**\n * Returns `v` if `predicate` returns _true_,\n * alternatively returning `skipValue`.\n * \n * ```js\n * // Return true if value is less than 10\n * const p = v => v < 10;\n * \n * filterValue(5, p, 0);   // 5\n * filterValue(20, p, 0);  // 0\n * ```\n * @param v Value to test\n * @param predicate Predicate\n * @param skipValue Value to return if predicate returns false\n * @returns Input value if predicate is _true_, or `skipValue` if not.\n */\nexport const filterValue = <V>(v: V, predicate: (v: V) => boolean, skipValue: V | undefined): V | undefined => {\n  if (predicate(v)) return v;\n  return skipValue;\n};\n","import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n\n\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n * \n * If `source` is under `maxLength` the original is returned.\n * @param source \n * @param maxLength Maximum length. Defaults to 20\n * @returns \n */\nexport const abbreviate = (source: string, maxLength = 15) => {\n  resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n\n  if (source.length > maxLength && source.length > 3) {\n    if (maxLength > 15) {\n      const chunk = Math.round((maxLength - 2) / 2);\n      return source.slice(0, chunk) + `...` + source.slice(-chunk);\n    }\n    return source.slice(0, maxLength) + `...`;\n  }\n  return source;\n}\n\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns \n */\nexport const toStringAbbreviate = (source: any, maxLength = 20) => {\n  if (source === undefined) return `(undefined)`;\n  if (source === null) return `(null)`;\n  return abbreviate(JSON.stringify(source), maxLength);\n}\n\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): string | undefined => {\n  // ✔ Unit tested\n\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return;\n\n  if (typeof end === `undefined`) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return;\n\n  return source.slice(startPos + 1, endPos);\n};\n\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (\n  source: string,\n  start: string,\n  end?: string,\n  lastEndMatch = true\n): [ source: string, between: string | undefined ] => {\n  // ✔ Unit tested\n  if (typeof source !== `string`) throw new Error(`Parameter 'source' is not a string`);\n  if (typeof start !== `string`) throw new Error(`Parameter 'start' is not a string`);\n  if (end !== undefined && typeof end !== `string`) throw new Error(`Parameter 'end' is not a string`);\n  const startPos = source.indexOf(start);\n  if (startPos < 0) return [ source, undefined ];\n\n  if (typeof end === `undefined`) end = start;\n\n  const endPos = lastEndMatch\n    ? source.lastIndexOf(end)\n    : source.indexOf(end, startPos + 1);\n  if (endPos < 0) return [ source, undefined ];\n\n  const between = source.slice(startPos + 1, endPos);\n  const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n  return [ sourceResult, between ];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (\n  source: string,\n  code: number,\n  start = 0,\n  end = source.length - 1\n): number => {\n  for (let index = start; index <= end; index++) {\n    if (source.codePointAt(index) === code) return index;\n  }\n  return -1;\n};\n\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (\n  source: string,\n  removeStart: number,\n  removeLength: number\n) =>\n  source.slice(0, removeStart) +\n  source.slice(removeStart + removeLength);\n\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (\n  source: string | null,\n  length: number\n): readonly string[] => {\n  resultThrow(integerTest(length, `aboveZero`, `length`));\n  if (source === null) throw new Error(`source parameter null`);\n  if (typeof source !== `string`) {\n    throw new TypeError(`source parameter not a string`);\n  }\n\n  // ✔ Unit tested\n  const chunks = Math.ceil(source.length / length);\n  const returnValue: string[] = [];\n  let start = 0;\n\n  for (let c = 0; c < chunks; c++) {\n    returnValue.push(source.slice(start, start + length));\n    start += length;\n  }\n  return returnValue;\n};\n\n\n\n/**\n * Returns the `source` string up until (and excluding) `match`. \n * \n * By default, if match is not found, all of `source` is returned.\n *\n * ```js\n * // Yields `apple `\n * untilMarch(`apple orange melon`, `orange`);\n * ```\n * \n * If match is not found, fallback can be returned instead:\n * ```js\n * // Yields 'lemon'\n * untilMatch(`apple orange mellon`, `kiwi`, { fallback: `lemon` });\n * ```\n * \n * Or an exception thrown\n * ```js\n * // Throws\n * untilMatch(`apple orange mellon`, `kiwi`, { ifNoMatch: `throw` });\n * ```\n * @param source\n * @param match\n * @param startPos If provided, gives the starting offset. Default 0\n */\n// export const untilMatch = (\n//   source: string,\n//   match: string,\n//   options: Partial<UntilMatchOptions> = {}\n// ): string => {\n//   //  ✔️ Unit tested\n//   let fallback = options.fallback;\n//   const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n//   if (ifNoMatch === `original`) fallback = source;\n//   if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) {\n//     if (ifNoMatch === `throw`) throw new Error(`Match string not found in source`);\n//     // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n//     return fallback!;\n//   }\n//   return source.slice(startPos ?? 0, m);\n// };\n\n\n// export type UntilMatchOptions = MatchOptions & {\n//   ifNoMatch: `throw` | `original` | `fallback`,\n//   fallback?: string\n// }\n\nexport type MatchOptions = {\n  startPos: number;\n  fromEnd: boolean;\n  ifNoMatch: `throw` | `original` | `fallback`,\n  fallback: string\n}\n\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 0 ];\n}\n\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n * \n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n * \n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n * \n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (\n  source: string,\n  match: string,\n  options: Partial<MatchOptions> = {}\n): string => {\n  const ba = beforeAfterMatch(source, match, options);\n  return ba[ 1 ];\n}\n\n/**\n * Returns the text that is before and after `match`.\n * \n * See also: {@link beforeMatch}, {@link afterMatch}.\n * \n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source \n * @param match \n * @param options \n * @returns \n */\nexport const beforeAfterMatch = (source: string, match: string, options: Partial<MatchOptions> = {}): [ before: string, after: string ] => {\n  if (source === undefined) throw new Error(`Param 'source' is undefined`);\n\n  let fallback = options.fallback;\n  const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n  if (ifNoMatch === `original`) fallback = source;\n  if (ifNoMatch === `fallback` && fallback === undefined) throw new Error(`Fallback must be provided`);\n\n  const startPos = options.startPos ?? undefined;\n  const fromEnd = options.fromEnd ?? false;\n\n  const m = fromEnd\n    ? source.lastIndexOf(match, startPos)\n    : source.indexOf(match, startPos);\n\n  if (m < 0 && ifNoMatch === `throw`) throw new Error(`Match '${ match }' not found in source.`);\n  if (m < 0 && ifNoMatch === `original`) return [ source, source ];\n  if (m < 0 && ifNoMatch === `fallback`) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [ fallback!, fallback! ];\n  }\n  return [\n    source.slice(0, m),\n    source.slice(Math.max(0, m + match.length))\n  ]\n}\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (\n  source: string,\n  ...wrappers: readonly string[]\n): string => {\n  let matched = false;\n  do {\n    matched = false;\n    for (const w of wrappers) {\n      if (source.startsWith(w) && source.endsWith(w)) {\n        source = source.slice(w.length, source.length - w.length * 2 + 1);\n        matched = true;\n      }\n    }\n  } while (matched);\n\n  return source;\n};\n\n/**\n * A range\n */\nexport type Range = {\n  /**\n   * Text of range\n   */\n  readonly text: string;\n  /**\n   * Start position, with respect to source text\n   */\n  readonly start: number;\n  /**\n   * End position, with respect to source text\n   */\n  readonly end: number;\n  /**\n   * Index of range. First range is 0\n   */\n  readonly index: number;\n}\n\nexport type LineSpan = {\n  readonly start: number;\n  readonly end: number;\n  readonly length: number;\n}\n\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (\n  ranges: readonly Range[],\n  start: number,\n  end: number\n): LineSpan => {\n  let s = -1;\n  let endPos = -1;\n  for (const [ index, r ] of ranges.entries()) {\n    s = index;\n    if (r.text.length === 0) continue;\n    if (start < r.end) {\n      break;\n    }\n  }\n\n  for (let index = s; index < ranges.length; index++) {\n    const r = ranges[ index ];\n    endPos = index;\n    if (end === r.end) {\n      endPos = index + 1;\n      break;\n    }\n    if (end < r.end) {\n      break;\n    }\n  }\n  return { length: endPos - s, start: s, end: endPos };\n};\n\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (\n  source: string,\n  split: string\n): readonly Range[] => {\n  let start = 0;\n  let text = ``;\n  const ranges: Range[] = [];\n  let index = 0;\n  for (let index_ = 0; index_ < source.length; index_++) {\n    if (source.indexOf(split, index_) === index_) {\n      const end = index_;\n      ranges.push({\n        text,\n        start,\n        end,\n        index,\n      });\n      start = end + 1;\n      text = ``;\n      index++;\n    } else {\n      text += source.charAt(index_);\n    }\n  }\n  if (start < source.length) {\n    ranges.push({ text, start, index, end: source.length });\n  }\n  return ranges;\n};\n\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (\n  source: string,\n  ...chars: readonly string[]\n): number => {\n  let counted = 0;\n  for (let index = 0; index < source.length; index++) {\n    if (chars.includes(source.charAt(index))) {\n      counted++;\n    } else {\n      break;\n    }\n  }\n  return counted;\n};\n\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (\n  source: string,\n  start: string,\n  end: string = start\n): boolean => source.startsWith(start) && source.endsWith(end);\n\n\nexport const htmlEntities = (source: string): string =>\n  source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${ index.codePointAt(0) };`);\n\n\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern \n * @returns \n */\nexport const wildcard = (pattern: string) => {\n  // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n  // for this solution to work on any string, no matter what characters it has\n  const escapeRegex = (value: string) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n\n  // \".\"  => Find a single character, except newline or line terminator\n  // \".*\" => Matches any string that contains zero or more characters\n  pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n\n  // \"^\"  => Matches any string with the following at the beginning of it\n  // \"$\"  => Matches any string with that in front at the end of it\n  pattern = `^` + pattern + `$`\n\n  // Create a regular expression object for matching string\n  const regex = new RegExp(pattern);\n\n  return (value: string) => {\n    // Returns true if it finds a match, otherwse it returns false\n    return regex.test(value);\n  }\n}","import { toStringAbbreviate } from \"./text.js\";\nimport type { IsEqual } from \"./is-equal.js\";\n\n\n/**\n * Wraps the `eq` function, tracing the input data result\n * ```js\n * // Init trace\n * const traceEq = isEqualTrace(isEqualValueDefault); \n * // Use it in some function that takes IsEqual<T>\n * compare(a, b, eq);\n * ```\n * @param eq \n * @returns \n */\nexport const isEqualTrace = <T>(eq: IsEqual<T>): IsEqual<T> => {\n  return (a, b) => {\n    const result = eq(a, b);\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    console.log(`isEqualTrace eq: ${ result } a: ${ toStringAbbreviate(a) } b: ${ toStringAbbreviate(b) }`);\n    return result;\n  }\n}","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\nexport const toStringOrdered = (itemToMakeStringFor: unknown) => {\n  if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n  const allKeys = new Set<string>();\n\n  JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n  return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n}\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string, unknown>, b: Record<string, unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string, unknown>, valueB as Record<string, unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b` are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n * \n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n * \n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value \n * @returns \n */\nexport const isInteger = (value: string | number) => {\n  if (value === undefined) return false;\n  if (typeof value === `string`) {\n    const v = Number.parseInt(value);\n    if (Number.isNaN(v)) return false;\n    if (v.toString() === value.toString()) return true;\n    return false;\n  }\n  if (typeof value === `number`) {\n    if (Number.isNaN(value)) return false;\n    if (!Number.isFinite(value)) return false;\n    if (Math.round(value) === value) return true;\n    return false;\n  }\n  return false;\n}","import type { Primitive, PrimitiveOrObject } from \"./types.js\";\n\n/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n * \n * Use {@link isPrimitiveOrObject} to also return true if `value` is an object.\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value: any): value is Primitive {\n  if (typeof value === `number`) return true;\n  if (typeof value === `string`) return true;\n  if (typeof value === `bigint`) return true;\n  if (typeof value === `boolean`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `value` is number, string, bigint, boolean or an object\n * \n * Use {@link isPrimitive} to not include objects.\n * @param value\n * @returns \n */\nexport function isPrimitiveOrObject(value: any): value is PrimitiveOrObject {\n  if (isPrimitive(value)) return true;\n  if (typeof value === `object`) return true;\n  return false;\n}","import { isEqualDefault } from \"./is-equal.js\";\n\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common and those unique in `a` or `b`.\n * Ignores ordering of values, and is NOT recursive.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValuesShallow(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n * \n * By default uses === semantics for comparison.\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareIterableValuesShallow = <V>(\n  a: Iterable<V>,\n  b: Iterable<V>,\n  eq = isEqualDefault<V>\n) => {\n  const shared:V[] = [];\n  const aUnique:V[] = [];\n  const bUnique:V[] = [];\n\n  for (const elementOfA of a) {\n    let seenInB = false;\n    // Does B contain this thing from A?\n    for (const elementOfB of b) {\n      if (eq(elementOfA, elementOfB)) {\n        seenInB = true;\n        break;\n      }\n    }\n\n    if (seenInB) {\n      // Common in A & B\n      shared.push(elementOfA);\n    } else {\n      // No, it's only found in A\n      aUnique.push(elementOfA);\n    }\n  }\n\n  for (const elementOfB of b) {\n    let seenInA = false;\n    // Does A contain this thing from B?\n    for (const elementOfA of a) {\n      if (eq(elementOfB, elementOfA)) {\n        seenInA = true;\n      }\n    }\n    if (!seenInA) {\n      // No, something unique to B\n      bUnique.push(elementOfB);\n    }\n  }\n\n  // Are the two iterables the same?\n  const isSame = aUnique.length === 0 && bUnique.length === 0;\n\n  return {\n    shared,\n    isSame,\n    a: aUnique,\n    b: bUnique\n  };\n};\n","\nimport type { KeyValue } from './types.js'\n//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\n\nimport { defaultComparer } from './comparers.js';\n\n// const byKey = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 0 ])\n// );\n\n// export const byValueString = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as string)\n// );\n\n// const byValueNumber = (reverse = false) => pipe(\n//   reverse ? reverseOrd(N.Ord) : N.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as number)\n// );\n\n// export const sortByKey = (reverse = false) => sort<KeyValue>(byKey(reverse));\n// export const sortByValueString = (reverse = false) => sort<KeyValue>(byValueString(reverse));\n// export const sortByValueNumber = (reverse = false) => sort<KeyValue>(byValueNumber(reverse));\n\nexport type KeyValueSorter = (data: KeyValue[]) => KeyValue[];\n\nconst sorterByValueIndex = (index: number, reverse = false) => {\n  return (values: KeyValue[]) => {\n    const s = values.toSorted((a, b) => {\n      return defaultComparer(a[ index ], b[ index ]);\n    });\n    if (reverse) return s.reverse();\n    return s;\n  }\n}\n\nexport type KeyValueSortSyles = `value` | `value-reverse` | `key` | `key-reverse`;\nexport const keyValueSorter = (sortStyle: KeyValueSortSyles): KeyValueSorter => {\n  switch (sortStyle) {\n    case `value`: {\n      return sorterByValueIndex(1, false);\n    }\n    case `value-reverse`: {\n      return sorterByValueIndex(1, true);\n    }\n    case `key`: {\n      return sorterByValueIndex(0, false);\n    }\n    case `key-reverse`: {\n      return sorterByValueIndex(0, true);\n    }\n    default: {\n      throw new Error(`Unknown sorting value '${ (sortStyle as string) }'. Expecting: value, value-reverse, key or key-reverse`);\n    }\n  }\n};\n\n\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };","import { integerTest, resultThrow } from \"@ixfx/guards\";\n\nexport function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number | boolean, roundUp?: boolean) {\n  resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n\n  const up = (typeof b === `boolean`) ? b : (roundUp ?? false)\n  let rounder;\n  if (a === 0) {\n    rounder = Math.round;\n  } else {\n    const p = Math.pow(10, a);\n    if (up) {\n      rounder = (v: number) => Math.ceil(v * p) / p;\n    } else {\n      rounder = (v: number) => Math.floor(v * p) / p;\n    }\n  }\n  if (typeof b === `number`) return rounder(b);\n  return rounder;\n}\n\n","import { numberTest } from '@ixfx/guards';\nimport { round } from './util/round.js';\nimport type { Interval } from './types.js';\n\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n\n\n/**\n * Return the millisecond value of an Interval.\n * \n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(\n  interval: Interval | undefined,\n  defaultNumber?: number\n): number {\n  if (isInterval(interval)) {\n    // Number given, must be millis?\n    if (typeof interval === `number`) return interval;\n\n    let ms = interval.millis ?? 0;\n    ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n    ms += (interval.mins ?? 0) * 60 * 1000;\n    ms += (interval.secs ?? 0) * 1000;\n    return ms;\n  } else {\n    if (typeof defaultNumber !== `undefined`) return defaultNumber;\n    throw new Error(`Not a valid interval: ${ JSON.stringify(interval) }`);\n  }\n}\n\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval \n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval: number | Interval | undefined): interval is Interval {\n  if (typeof interval === `undefined`) return false;\n  if (interval === null) return false;\n  if (typeof interval === `number`) {\n    if (Number.isNaN(interval)) return false;\n    if (!Number.isFinite(interval)) return false;\n    return true;\n  }\n  if (typeof interval !== `object`) return false;\n  const hasMillis = `millis` in interval;\n  const hasSecs = `secs` in interval;\n  const hasMins = `mins` in interval;\n  const hasHours = `hours` in interval;\n  if (hasMillis && !numberTest(interval.millis).success) return false;\n  if (hasSecs && !numberTest(interval.secs).success) return false;\n  if (hasMins && !numberTest(interval.mins).success) return false;\n  if (hasHours && !numberTest(interval.hours).success) return false;\n  if (hasMillis || hasSecs || hasHours || hasMins) return true;\n  return false;\n}\n\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n * \n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns \n */\nexport const elapsedToHumanString = (millisOrFunction: number | (() => number) | Interval, rounding = 2): string => {\n  let interval: number | undefined = 0;\n  if (typeof millisOrFunction === `function`) {\n    const intervalResult = millisOrFunction();\n    return elapsedToHumanString(intervalResult);\n  } else if (typeof millisOrFunction === `number`) {\n    interval = millisOrFunction;\n  } else if (typeof millisOrFunction === `object`) {\n    interval = intervalToMs(interval);\n  }\n\n  let ms = intervalToMs(interval);\n  if (typeof ms === `undefined`) return `(undefined)`;\n  if (ms < 1000) return `${ round(rounding, ms) }ms`;\n  ms /= 1000;\n  if (ms < 120) return `${ ms.toFixed(1) }secs`;\n  ms /= 60;\n  if (ms < 60) return `${ ms.toFixed(2) }mins`;\n  ms /= 60;\n  return `${ ms.toFixed(2) }hrs`;\n};","import { toStringDefault, type ToString } from \"@ixfx/core\";\n\nexport type TrackUnique<T> = (value: T) => boolean\n\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link uniqueInstances}\n * \n * ```js\n * const t = unique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n * \n * Uses JSON.stringify to compare anything which is not a string.\n * \n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n * \n * ```js\n * const t = unique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n * \n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n * \n * Return function throws an error if `value` is null or undefined.\n * @returns \n */\nexport const unique = <T>(toString: ToString<T> = toStringDefault): TrackUnique<T> => {\n  const set = new Set<string>();\n\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    const asString = (typeof value === `string`) ? value : toString(value);\n    if (set.has(asString)) return false;\n    set.add(asString);\n    return true;\n  }\n}\n\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link unique} to track by value.\n */\nexport const uniqueInstances = <T>(): TrackUnique<T> => {\n\n  const set = new Set<T>();\n  return (value: T) => {\n    if (value === null) throw new TypeError(`Param 'value' cannot be null`);\n    if (value === undefined) throw new TypeError(`Param 'value' cannot be undefined`);\n\n    if (set.has(value)) return false;\n    set.add(value);\n    return true;\n  }\n}","/**\n * Returns _true_ if it seems like the code is running on iOS (iPad/iPhone)\n * @returns \n */\nexport const runningiOS = () =>\n  [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n  ].includes(navigator.platform) ||\n  // iPad on iOS 13 detection\n  (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);","export const promiseFromEvent = (target: EventTarget, name: string): Promise<any> => {\n  return new Promise(resolve => {\n    const handler = (...args: Array<any>) => {\n      target.removeEventListener(name, handler);\n      if (Array.isArray(args) && args.length === 1) resolve(args[ 0 ]);\n      else resolve(args);\n    };\n    target.addEventListener(name, handler);\n  });\n};","import type { Reactive, ReactiveInitial } from \"./types-reactive.js\";\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns _true_ if `rx` has a last value\n * \n * Judged seeing if `.last()` exists on `rx`.\n * @param rx Reactive\n * @returns \n */\nexport const hasLast = <V>(rx: object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}","export const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n","import { getOrGenerateSync } from \"./util.js\";\n/**\n * Returns a console logging function which prefixes messages. This is\n * useful for tracing messages from different components. Each prefix\n * is assigned a colour, further helping to distinguish messages.\n *\n * Use {@link logSet} to get a bundled set.\n *\n * ```\n * // Initialise once\n * const log = logger(`a`);\n * const error = logger(`a`, `error`);\n * const warn = logger(`a`, `warn);\n *\n * // And then use\n * log(`Hello`);    // console.log(`a Hello`);\n * error(`Uh-oh`);  // console.error(`a Uh-oh`);\n * warn(`Eek!`);    // console.warn(`a Eeek!`);\n * ```\n *\n * Provide the `colourKey` parameter to make log messages\n * be coloured the same, even though the prefix is different.\n * ```js\n * // Both loggers will use the same colour because they\n * // share the colour key `system`\n * const log = logger(`a`,`log`,`system`);\n * const log2 = logger(`b`, `log`, `system`);\n * ```\n * @param prefix\n * @param kind\n * @param colourKey Optional key to colour log lines by instead of prefix\n * @returns\n */\nexport const logger = (prefix, kind = `log`, colourKey) => (m) => {\n    if (m === undefined) {\n        m = `(undefined)`;\n    }\n    else if (typeof m === `object`) {\n        m = JSON.stringify(m);\n    }\n    const colour = colourKey ?? prefix;\n    switch (kind) {\n        case `log`: {\n            console.log(`%c${prefix} ${m}`, `color: ${logColours(colour)}`);\n            break;\n        }\n        case `warn`: {\n            console.warn(prefix, m);\n            break;\n        }\n        case `error`: {\n            console.error(prefix, m);\n            break;\n        }\n    }\n};\n/**\n* Returns a bundled collection of {@link logger}s\n*\n* ```js\n* const con = logSet(`a`);\n* con.log(`Hello`);  // console.log(`a Hello`);\n* con.warn(`Uh-oh`); // console.warn(`a Uh-oh`);\n* con.error(`Eek!`); // console.error(`a Eek!`);\n* ```\n*\n* By default each prefix is assigned a colour. To use\n* another logic, provide the `colourKey` parameter.\n*\n* ```js\n* // Both set of loggers will use same colour\n* const con = logSet(`a`, true, `system`);\n* const con2 = logSet(`b`, true, `system`);\n* ```\n* @param prefix Prefix for log messages\n* @param verbose True by default. If false, log() messages are a no-op\n* @param colourKey If specified, log messages will be coloured by this key instead of prefix (default)\n* @returns\n*/\nexport const logSet = (prefix, verbose = true, colourKey) => {\n    if (verbose) {\n        return {\n            log: logger(prefix, `log`, colourKey),\n            warn: logger(prefix, `warn`, colourKey),\n            error: logger(prefix, `error`, colourKey),\n        };\n    }\n    return {\n        log: (_) => {\n            /** no-op */\n        },\n        warn: logger(prefix, `warn`, colourKey),\n        error: logger(prefix, `error`, colourKey),\n    };\n};\n/**\n * Resolve a LogOption to a function\n * @param l\n * @returns\n */\nexport const resolveLogOption = (l, defaults = {}) => {\n    if (l === undefined || (typeof l === `boolean` && !l)) {\n        return (_) => {\n            /** no-op */\n        };\n    }\n    const defaultCat = defaults.category ?? ``;\n    const defaultKind = defaults.kind ?? undefined;\n    if (typeof l === `boolean`) {\n        return (messageOrString) => {\n            const m = typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;\n            const kind = m.kind ?? defaultKind;\n            const category = m.category ?? defaultCat;\n            let message = m.msg;\n            if (category)\n                message = `[${category}] ${message}`;\n            switch (kind) {\n                case `error`: {\n                    console.error(message);\n                    break;\n                }\n                case `warn`: {\n                    console.warn(message);\n                    break;\n                }\n                case `info`: {\n                    console.info(message);\n                    break;\n                }\n                default: {\n                    console.log(message);\n                }\n            }\n        };\n    }\n    return l;\n};\nlet logColourCount = 0;\nexport const logColours = getOrGenerateSync(new Map(), () => {\n    const hue = ++logColourCount * 137.508; // use golden angle approximation\n    return `hsl(${hue},50%,75%)`;\n});\n","/**\n * Calculates frames per second.\n *\n * Returns a function which needs to be called at the end of each frame.\n *\n * ```js\n * const fps = fpsCounter();\n *\n * function loop() {\n *  fps(); // Calculate fps\n *  window.requestAnimationFrame(loop);\n * }\n *\n * loop();\n * ```\n * @param autoDisplay If true (default), prints out the FPS to the console\n * @param computeAfterFrames Calculates after this many frames. Higher numbers smoothes the value somewhat\n * @returns\n */\nexport const fpsCounter = (autoDisplay = true, computeAfterFrames = 500) => {\n    let count = 0;\n    let lastFps = 0;\n    let countStart = performance.now();\n    return () => {\n        if (count++ >= computeAfterFrames) {\n            const elapsed = performance.now() - countStart;\n            countStart = performance.now();\n            count = 0;\n            lastFps = Math.floor((computeAfterFrames / elapsed) * 1000);\n            if (autoDisplay)\n                console.log(`fps: ${lastFps}`);\n        }\n        return lastFps;\n    };\n};\n","/**\n * Returns a string representation of an error\n * @param ex\n * @returns\n */\nexport const getErrorMessage = (ex) => {\n    if (typeof ex === `string`)\n        return ex;\n    if (ex instanceof Error) {\n        return ex.message;\n    }\n    return ex;\n};\n","export * from './types.js';\nexport * from './logger.js';\nexport * from './fps-counter.js';\nexport * from './error-message.js';\n","//import { hasLast, isReactive } from \"@ixfx/rx\";\n//import type { ReactiveNonInitial } from \"@ixfx/rx\";\nimport type { BasicType } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport type { ReactiveNonInitial } from \"./types-reactive.js\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n\n\n/**\n * Something that can resolve to a value\n */\nexport type ResolveToValueSync<V> = BasicType | ReactiveNonInitial<V> | Generator<V> | IterableIterator<V> | ((args: any) => V)\nexport type ResolveToValueAsync<V> = AsyncGenerator<V> | AsyncIterableIterator<V> | Promise<V> | ((args: any) => Promise<V>);\nexport type ResolveToValue<V> = ResolveToValueAsync<V> | ResolveToValueSync<V>;\n\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n * \n * To resolve an object's properties, use {@link resolveFields}.\n * \n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r \n * @param args \n * @returns \n */\nexport async function resolve<V extends BasicType>(r: ResolveToValue<V>, ...args: any): Promise<V> {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        const v = await r.next();\n        //console.log(`  hasDone: ${ `done` in v } value:`, v);\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last()!;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    const v = await r(args) as V;\n    return v;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * For a given input `r`, attempts to 'resolve' it. See {@link resolve} for details.\n * @param r \n * @param args \n * @returns \n */\nexport function resolveSync<V extends BasicType>(r: ResolveToValueSync<V>, ...args: any): V {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        throw new Error(`resolveSync cannot work with an async generator`);\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last()!;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    return r(args);\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_ \n * or NaN, `fallbackValue` is returned instead.\n * \n * `null` is an allowed return value.\n * \n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args \n * @returns \n */\nexport async function resolveWithFallback<T extends BasicType>(p: ResolveToValue<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = await resolve(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport function resolveWithFallbackSync<T extends BasicType>(p: ResolveToValueSync<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = resolveSync(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport type ResolveFallbackOpts<T> = { value: T, overrideWithLast?: boolean }","export const zip = (\n  ...arrays: any[][] | readonly any[][] | readonly (readonly any[])[]\n): any[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => (a as any[]).length);\n\n  const returnValue: any[] = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","import { resolve, resolveSync, type ReactiveNonInitial, type ResolveToValue } from \"@ixfx/core\";\nimport { zip } from \"./util/zip.js\";\n// import { zip } from \"./arrays/Zip.js\";\n\n/**\n * An object that can be 'resolved'.\n * @see {@link resolveFields}\n */\nexport type ResolvedObject<T extends Record<string, ResolveToValue<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number :\n    T[ K ] extends string ? string :\n    T[ K ] extends boolean ? boolean :\n    T[ K ] extends bigint ? bigint :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends ReactiveNonInitial<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends (infer V)[] ? V : // array needed?\n    T[ K ] extends object ? T[ K ] : never\n  };\n\n\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n * \n * Use {@link resolveFieldsSync} for a synchronous version.\n * \n * Not recursive.\n * \n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n * \n * It also works with generators. Probably best with those that are infinite.\n * \n * ```js\n * import { count } from './numbers.js';\n * \n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object \n * @returns \n */\nexport async function resolveFields<T extends Record<string, ResolveToValue<any>>>(object: T): Promise<ResolvedObject<T>> {\n  const resolvers: any[] = [];\n  const keys: string[] = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    resolvers.push(resolve(resolvable));\n    keys.push(entry[ 0 ]);\n  }\n  const results = await Promise.all(resolvers);\n  const entries = zip(keys, results);\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\n/**\n * 'Resolves' all the fields of `object` in a synchronous manner.\n * Uses {@link resolveSync} under-the-hood\n * @param object \n * @returns \n */\nexport function resolveFieldsSync<T extends Record<string, ResolveToValue<any>>>(object: T): ResolvedObject<T> {\n  const entries: [ key: string, value: any ][] = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    const value = resolveSync(resolvable);\n    entries.push([ entry[ 0 ], value ]);\n  }\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\n\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nimport type { Interval } from './types.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n\n  if (typeof window === `undefined`) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * `Flow.delay()` and {@link sleep} are similar. `Flow.delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  resultThrow(numberTest(timeoutMs, `positive`, `timeoutMs`));\n\n\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        clearTimeout(t);\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      const t = setTimeout(() => {\n        signal?.removeEventListener(`abort`, onAbortSignal);\n        if (signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate \n * @param checkInterval \n */\nexport const sleepWhile = async (predicate: () => boolean, checkInterval: Interval = 100) => {\n  while (predicate()) {\n    await sleep(checkInterval);\n  }\n}","import { mapObjectKeys } from '@ixfx/core/records';\nimport { compareIterableValuesShallow, isEqualDefault } from '@ixfx/core';\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareObjectKeys = (a, b) => {\n    const c = compareIterableValuesShallow(Object.keys(a), Object.keys(b));\n    return c;\n};\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n *\n * ```js\n * const a = { msg: `hi`, v: 10 };\n *\n * changedDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n *\n * Under the hood, we use {@link compareResultToObject}(a, b, true). If B has additional or removed fields,\n * this is considered an error.\n *\n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a\n * @param b\n */\nexport const changedObjectDataFields = (a, b) => {\n    const r = compareObjectData(a, b, true);\n    if (Object.entries(r.added).length > 0)\n        throw new Error(`Shape of data has changed`);\n    if (Object.entries(r.removed).length > 0)\n        throw new Error(`Shape of data has changed`);\n    const output = compareResultToObject(r, b);\n    return output;\n};\nconst compareResultToObject = (r, b) => {\n    const output = {};\n    if (r.isArray) {\n        return b;\n    }\n    for (const entry of Object.entries(r.changed)) {\n        output[entry[0]] = entry[1];\n    }\n    for (const entry of Object.entries(r.added)) {\n        output[entry[0]] = entry[1];\n    }\n    for (const childEntry of Object.entries(r.children)) {\n        const childResult = childEntry[1];\n        if (childResult.hasChanged) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            output[childEntry[0]] = compareResultToObject(childResult, b[childEntry[0]]);\n        }\n    }\n    return output;\n};\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n *\n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport const compareArrays = (a, b, eq = (isEqualDefault)) => {\n    if (!Array.isArray(a))\n        throw new Error(`Param 'a' is not an array`);\n    if (!Array.isArray(b))\n        throw new Error(`Param 'b' is not an array`);\n    const c = compareObjectData(a, b, false, eq);\n    if (!c.isArray)\n        throw new Error(`Change set does not have arrays as parameters`);\n    const convert = (key) => {\n        if (key.startsWith(`_`)) {\n            return Number.parseInt(key.slice(1));\n        }\n        else\n            throw new Error(`Unexpected key '${key}'`);\n    };\n    const cc = {\n        ...c,\n        added: mapObjectKeys(c.added, convert),\n        changed: mapObjectKeys(c.changed, convert),\n        removed: c.removed.map(v => convert(v)),\n        summary: c.summary.map(value => {\n            return [value[0], convert(value[1]), value[2]];\n        })\n    };\n    return cc;\n};\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the\n * values are primitive values or other simple objects. It also works with arrays.\n *\n * Uses === equality semantics by default.\n * @param a\n * @param b\n */\nexport const compareObjectData = (a, b, assumeSameShape = false, eq = isEqualDefault) => {\n    a ??= {};\n    b ??= {};\n    const entriesA = Object.entries(a);\n    const entriesB = Object.entries(b);\n    const scannedKeys = new Set();\n    const changed = {};\n    const added = {};\n    const children = {};\n    const removed = [];\n    const isArray = Array.isArray(a);\n    const summary = new Array();\n    let hasChanged = false;\n    // Look for existing entries of A that are modified\n    for (const entry of entriesA) {\n        const outputKey = isArray ? `_${entry[0]}` : entry[0];\n        const aValue = entry[1];\n        const bValue = b[entry[0]];\n        scannedKeys.add(entry[0]);\n        if (bValue === undefined) {\n            // B does not have a key from A\n            hasChanged = true;\n            if (assumeSameShape && !isArray) {\n                // If we're assuming it's the same shape, then _undefined_ is actually the value\n                changed[outputKey] = bValue;\n                summary.push([`mutate`, outputKey, bValue]);\n            }\n            else {\n                // Key removed\n                removed.push(outputKey);\n                summary.push([`del`, outputKey, aValue]);\n            }\n            continue;\n        }\n        if (typeof aValue === `object`) {\n            const r = compareObjectData(aValue, bValue, assumeSameShape, eq);\n            if (r.hasChanged)\n                hasChanged = true;\n            children[outputKey] = r;\n            const childSummary = r.summary.map(sum => { return [sum[0], outputKey + `.` + sum[1], sum[2]]; });\n            summary.push(...childSummary);\n        }\n        else {\n            if (!eq(aValue, bValue)) {\n                changed[outputKey] = bValue;\n                hasChanged = true;\n                summary.push([`mutate`, outputKey, bValue]);\n            }\n        }\n    }\n    // Look for entries in B that weren't in A\n    if (!assumeSameShape || isArray) {\n        for (const entry of entriesB) {\n            const key = isArray ? `_${entry[0]}` : entry[0];\n            if (scannedKeys.has(entry[0]))\n                continue;\n            added[key] = entry[1];\n            hasChanged = true;\n            summary.push([`add`, key, entry[1]]);\n        }\n    }\n    return {\n        changed, added, removed, children, hasChanged, isArray, summary\n    };\n};\n","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\nexport const cloneFromFields = (source) => {\n    const entries = [];\n    for (const field in source) {\n        const value = (source)[field];\n        if (testPlainObjectOrPrimitive(value)) {\n            entries.push([field, value]);\n        }\n    }\n    return Object.fromEntries(entries);\n};\n","/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n *\n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = (object, mapFunction) => {\n    const entries = Object.entries(object);\n    const mapped = entries.map(([sourceField, sourceFieldValue], index) => [\n        sourceField,\n        mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n    ]);\n    return Object.fromEntries(mapped);\n};\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data\n * @param mapper\n * @returns\n */\nexport function mapObjectByObject(data, mapper) {\n    const entries = Object.entries(data);\n    for (const entry of entries) {\n        if (entry[0] in mapper) {\n            const m = mapper[entry[0]];\n            entry[1] = (typeof m === `object`) ?\n                mapObjectByObject(entry[1], m) :\n                m(entry[1], data);\n        }\n    }\n    return Object.fromEntries(entries);\n}\n","/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n *\n * Use {@link isPrimitiveOrObject} to also return true if `value` is an object.\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value) {\n    if (typeof value === `number`)\n        return true;\n    if (typeof value === `string`)\n        return true;\n    if (typeof value === `bigint`)\n        return true;\n    if (typeof value === `boolean`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `value` is number, string, bigint, boolean or an object\n *\n * Use {@link isPrimitive} to not include objects.\n * @param value\n * @returns\n */\nexport function isPrimitiveOrObject(value) {\n    if (isPrimitive(value))\n        return true;\n    if (typeof value === `object`)\n        return true;\n    return false;\n}\n","import { resultThrow, nullUndefTest } from '@ixfx/guards';\nimport { isPrimitive } from '../is-primitive.js';\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link RecordEntry}.\n * @param entries\n * @returns\n */\nexport function prettyPrintEntries(entries) {\n    if (entries.length === 0)\n        return `(empty)`;\n    let t = ``;\n    for (const [index, entry] of entries.entries()) {\n        t += `  `.repeat(index);\n        t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n    }\n    return t;\n}\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const recordEntryPrettyPrint = (node, indent = 0, options = {}) => {\n    resultThrow(nullUndefTest(node, `node`));\n    const defaultName = options.name ?? `node`;\n    const entry = getNamedRecordEntry(node, defaultName);\n    const t = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.nodeValue)}`;\n    const childrenAsArray = [...recordChildren(node, options)];\n    return childrenAsArray.length > 0 ? (t +\n        `\\n` +\n        childrenAsArray.map((d) => recordEntryPrettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)) : t;\n};\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * Sub-children are included as an object blob.\n *\n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n *\n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport function* recordChildren(node, options = {}) {\n    resultThrow(nullUndefTest(node, `node`));\n    const filter = options.filter ?? `none`;\n    const filterByValue = (v) => {\n        if (filter === `none`)\n            return [true, isPrimitive(v)];\n        else if (filter === `leaves` && isPrimitive(v))\n            return [true, true];\n        else if (filter === `branches` && !isPrimitive(v))\n            return [true, false];\n        return [false, isPrimitive(v)];\n    };\n    if (Array.isArray(node)) {\n        //if (options.name === undefined) defaultName = `array`;\n        for (const [index, element] of node.entries()) {\n            const f = filterByValue(element);\n            if (f[0]) {\n                yield { name: index.toString(), sourceValue: element, nodeValue: f[1] ? element : undefined };\n                //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n            }\n        }\n    }\n    else if (typeof node === `object`) {\n        const entriesIter = (`entries` in node) ? node.entries() : Object.entries(node);\n        for (const [name, value] of entriesIter) {\n            //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n            const f = filterByValue(value);\n            if (f[0]) {\n                yield { name: name, sourceValue: value, nodeValue: f[1] ? value : undefined };\n            }\n        }\n    }\n}\nexport function* recordEntriesDepthFirst(node, options = {}, ancestors = []) {\n    for (const c of recordChildren(node, options)) {\n        //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n        yield { ...c, ancestors: [...ancestors] };\n        yield* recordEntriesDepthFirst(c.sourceValue, options, [...ancestors, c.name]);\n    }\n}\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction recordEntryChildByName(name, node) {\n    for (const d of recordChildren(node)) {\n        if (d.name === name)\n            return d;\n    }\n}\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceRecordEntryByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getRecordEntryByPath(path, node, options = {}) {\n    const paths = [...traceRecordEntryByPath(path, node, options)];\n    if (paths.length === 0)\n        throw new Error(`Could not trace path: ${path} `);\n    return paths.at(-1);\n}\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getRecordEntryByPath} if you don't care about interim steps.\n *\n * ```js\n * const people = {\n *  jane: {\n *   address: {\n *    postcode: 1000,\n *    street: 'West St',\n *    city: 'Blahville'\n *   },\n * colour: 'red'\n *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceRecordEntryByPath(path, node, options = {}) {\n    resultThrow(nullUndefTest(path, `path`), nullUndefTest(node, `node`));\n    const separator = options.separator ?? `.`;\n    const pathSplit = path.split(separator);\n    const ancestors = [];\n    for (const p of pathSplit) {\n        const entry = recordEntryChildByName(p, node);\n        if (!entry) {\n            yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n            return;\n        }\n        node = entry.sourceValue;\n        yield { ...entry, ancestors: [...ancestors] };\n        ancestors.push(p);\n    }\n}\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedRecordEntry(node, defaultName = ``) {\n    if (`name` in node && `nodeValue` in node && `sourceValue` in node)\n        return node;\n    if (`name` in node) {\n        return { name: node.name, nodeValue: node, sourceValue: node };\n    }\n    return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n","import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport { compareObjectKeys } from './compare.js';\nconst getEntries = (target, deepProbe) => {\n    if (target === undefined)\n        throw new Error(`Param 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Param 'target' is null`);\n    if (typeof target !== `object`)\n        throw new Error(`Param 'target' is not an object (got: ${typeof target})`);\n    if (deepProbe) {\n        const entries = [];\n        for (const field in target) {\n            const value = target[field];\n            if (testPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return entries;\n    }\n    else {\n        return Object.entries(target);\n    }\n};\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n *\n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns\n */\nexport function* compareData(a, b, options = {}) {\n    if (typeof a === `undefined`) {\n        yield {\n            path: options.pathPrefix ?? ``,\n            value: b,\n            state: `added`\n        };\n        return;\n    }\n    if (typeof b === `undefined`) {\n        yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` };\n        return;\n    }\n    const asPartial = options.asPartial ?? false;\n    const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n    const pathPrefix = options.pathPrefix ?? ``;\n    const deepEntries = options.deepEntries ?? false;\n    const eq = options.eq ?? isEqualContextString;\n    const includeMissingFromA = options.includeMissingFromA ?? false;\n    const includeParents = options.includeParents ?? false;\n    //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n    if (isPrimitive(a) && isPrimitive(b)) {\n        if (a !== b)\n            yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    if (isPrimitive(b)) {\n        yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    const entriesA = getEntries(a, deepEntries);\n    const entriesAKeys = new Set();\n    for (const [key, valueA] of entriesA) {\n        entriesAKeys.add(key);\n        const keyOfAInB = key in b;\n        const valueOfKeyInB = b[key];\n        //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n        if (typeof valueA === `object` && valueA !== null) {\n            if (keyOfAInB) {\n                //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n                if (valueOfKeyInB === undefined) {\n                    throw new Error(`Pathed.compareData Value for key ${key} is undefined`);\n                }\n                else {\n                    const sub = [...compareData(valueA, valueOfKeyInB, {\n                            ...options,\n                            pathPrefix: pathPrefix + key + `.`\n                        })];\n                    if (sub.length > 0) {\n                        for (const s of sub)\n                            yield s;\n                        if (includeParents) {\n                            yield { path: pathPrefix + key, value: b[key], previous: valueA, state: `change` };\n                        }\n                    }\n                }\n            }\n            else {\n                if (asPartial)\n                    continue;\n                //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n                yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` };\n            }\n        }\n        else {\n            const subPath = pathPrefix + key;\n            if (keyOfAInB) {\n                // B contains key from A\n                if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n                    //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n                    yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n                }\n                else {\n                    if (!eq(valueA, valueOfKeyInB, subPath)) {\n                        //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n                        yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n                    }\n                }\n            }\n            else {\n                // B does not contain key from A\n                if (asPartial)\n                    continue; // Ignore\n                yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n            }\n        }\n    }\n    if (includeMissingFromA) {\n        const entriesB = getEntries(b, deepEntries);\n        for (const [key, valueB] of entriesB) {\n            if (entriesAKeys.has(key))\n                continue;\n            // Key in B that's not in A\n            //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n            yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n        }\n    }\n}\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source\n * @param changes\n */\nexport const applyChanges = (source, changes) => {\n    for (const change of changes) {\n        source = updateByPath(source, change.path, change.value);\n    }\n    return source;\n};\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n *\n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n *\n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n *\n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n *\n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter\n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n *\n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n *\n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns\n */\nexport const updateByPath = (target, path, value, allowShapeChange = false) => {\n    if (path === undefined)\n        throw new Error(`Parameter 'path' is undefined`);\n    if (typeof path !== `string`)\n        throw new Error(`Parameter 'path' should be a string. Got: ${typeof path}`);\n    if (target === undefined)\n        throw new Error(`Parameter 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Parameter 'target' is null`);\n    const split = path.split(`.`);\n    const r = updateByPathImpl(target, split, value, allowShapeChange);\n    return r;\n};\nconst updateByPathImpl = (o, split, value, allowShapeChange) => {\n    if (split.length === 0) {\n        //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n        if (allowShapeChange)\n            return value; // yolo\n        if (Array.isArray(o) && !Array.isArray(value))\n            throw new Error(`Expected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (!Array.isArray(o) && Array.isArray(value))\n            throw new Error(`Unexpected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (typeof o !== typeof value)\n            throw new Error(`Cannot reassign object type. (${typeof o} -> ${typeof value}). Set allowShapeChange=true to ignore.`);\n        // Make sure new value has the same set of keys\n        if (typeof o === `object` && !Array.isArray(o)) {\n            const c = compareObjectKeys(o, value);\n            if (c.a.length > 0) {\n                throw new Error(`New value is missing key(s): ${c.a.join(`,`)}`);\n            }\n            if (c.b.length > 0) {\n                throw new Error(`New value cannot add new key(s): ${c.b.join(`,`)}`);\n            }\n        }\n        return value;\n    }\n    const start = split.shift();\n    if (!start)\n        return value;\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(o)) {\n        const index = Number.parseInt(start);\n        if (index >= o.length && !allowShapeChange)\n            throw new Error(`Array index ${index.toString()} is outside of the existing length of ${o.length.toString()}. Use allowShapeChange=true to permit this.`);\n        const copy = [...o];\n        copy[index] = updateByPathImpl(copy[index], split, value, allowShapeChange);\n        return copy;\n    }\n    else if (start in o) {\n        const copy = { ...o };\n        copy[start] = updateByPathImpl(copy[start], split, value, allowShapeChange);\n        return copy;\n    }\n    else {\n        throw new Error(`Path ${start} not found in data`);\n    }\n};\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n *\n * Returns _undefined_ if path could not be resolved.\n *\n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object\n * @param path\n * @returns\n */\nexport const getField = (object, path) => {\n    if (typeof path !== `string`)\n        throw new Error(`Param 'path' ought to be a string. Got: '${typeof path}'`);\n    if (path.length === 0)\n        throw new Error(`Param string 'path' is empty`);\n    if (object === undefined)\n        throw new Error(`Param 'object' is undefined`);\n    if (object === null)\n        throw new Error(`Param 'object' is null`);\n    const split = path.split(`.`);\n    const v = getFieldImpl(object, split);\n    return v;\n};\nconst getFieldImpl = (object, split) => {\n    if (object === undefined)\n        throw new Error(`Param 'object' is undefined`);\n    if (split.length === 0)\n        throw new Error(`Path has run out`);\n    const start = split.shift();\n    if (!start)\n        throw new Error(`Unexpected empty split path`);\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n        const index = Number.parseInt(start); //start.slice(1, -1));\n        //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n        if (typeof object[index] === `undefined`) {\n            return { success: false, error: `Index '${index}' does not exist. Length: ${object.length}` };\n        }\n        if (split.length === 0) {\n            return { value: object[index], success: true };\n        }\n        else {\n            return getFieldImpl(object[index], split);\n        }\n    }\n    else if (typeof object === `object` && start in object) {\n        //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n        if (split.length === 0) {\n            return { value: object[start], success: true };\n        }\n        else {\n            return getFieldImpl(object[start], split);\n        }\n    }\n    else {\n        return { success: false, error: `Path '${start}' not found` };\n    }\n};\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n *\n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included.\n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object, onlyLeaves = false) {\n    if (object === undefined || object === null)\n        return;\n    const iter = recordEntriesDepthFirst(object);\n    for (const c of iter) {\n        if (c.nodeValue === undefined && onlyLeaves)\n            continue;\n        let path = c.name;\n        if (c.ancestors.length > 0)\n            path = c.ancestors.join(`.`) + `.` + path;\n        yield path;\n    }\n}\n;\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [\n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns\n */\nexport function* getPathsAndData(o, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``) {\n    if (o === null)\n        return;\n    if (o === undefined)\n        return;\n    yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\nfunction* getPathsAndDataImpl(o, prefix, onlyLeaves = false, maxDepth) {\n    if (maxDepth <= 0)\n        return;\n    if (typeof o !== `object`)\n        return;\n    for (const entries of Object.entries(o)) {\n        const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[0];\n        const value = entries[1];\n        const leaf = (typeof value !== `object`);\n        if (onlyLeaves && leaf || !onlyLeaves) {\n            yield { path: sub, value };\n        }\n        yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n    }\n}\n","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\nexport * from './pathed.js';\n/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n *\n * mapObjectKeys(input, key => key.toUppercase());\n *\n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object\n * @param mapFunction\n * @returns\n */\nexport const mapObjectKeys = (object, mapFunction) => {\n    const destinationObject = {};\n    for (const entries of Object.entries(object)) {\n        const key = mapFunction(entries[0]);\n        destinationObject[key] = entries[1];\n    }\n    return destinationObject;\n};\n","import { mapObjectKeys } from '@ixfx/core/records';\nimport { compareIterableValuesShallow, isEqualDefault, type IsEqual } from '@ixfx/core';\nimport type { ChangeRecord, CompareChangeSet } from '../types-compare.js';\n\n\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const compareObjectKeys = (a: object, b: object) => {\n  const c = compareIterableValuesShallow(Object.keys(a), Object.keys(b));\n  return c;\n}\n\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n * \n * ```js\n * const a = { msg: `hi`, v: 10 };\n * \n * changedDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n * \n * Under the hood, we use {@link compareResultToObject}(a, b, true). If B has additional or removed fields,\n * this is considered an error.\n * \n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a \n * @param b \n */\nexport const changedObjectDataFields = (a: object, b: object) => {\n  const r = compareObjectData(a, b, true);\n  if (Object.entries(r.added).length > 0) throw new Error(`Shape of data has changed`);\n  if (Object.entries(r.removed).length > 0) throw new Error(`Shape of data has changed`);\n\n  const output = compareResultToObject(r, b);\n  return output;\n}\n\nconst compareResultToObject = <TKey extends string | number>(r: CompareChangeSet<TKey>, b: object): Record<string, unknown> | object[] => {\n  const output = {}\n\n  if (r.isArray) {\n    return b as object[];\n  }\n\n  for (const entry of Object.entries(r.changed)) {\n    (output as object)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n  for (const entry of Object.entries(r.added)) {\n    (output as object)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n\n  for (const childEntry of Object.entries(r.children)) {\n    const childResult = childEntry[ 1 ] as CompareChangeSet<TKey>;\n    if (childResult.hasChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      (output as object)[ childEntry[ 0 ] ] = compareResultToObject(childResult, b[ childEntry[ 0 ] ]);\n    }\n  }\n  return output;\n}\n\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n * \n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport const compareArrays = <TValue>(a: TValue[], b: TValue[], eq: IsEqual<TValue> = isEqualDefault<TValue>): CompareChangeSet<number> => {\n  if (!Array.isArray(a)) throw new Error(`Param 'a' is not an array`);\n  if (!Array.isArray(b)) throw new Error(`Param 'b' is not an array`);\n  const c = compareObjectData(a, b, false, eq);\n  if (!c.isArray) throw new Error(`Change set does not have arrays as parameters`);\n\n  const convert = (key: string): number => {\n    if (key.startsWith(`_`)) {\n      return Number.parseInt(key.slice(1));\n    } else throw new Error(`Unexpected key '${ key }'`);\n  }\n  const cc: CompareChangeSet<number> = {\n    ...c,\n    added: mapObjectKeys(c.added, convert),\n    changed: mapObjectKeys(c.changed, convert),\n    removed: c.removed.map(v => convert(v)),\n    summary: c.summary.map(value => {\n      return [ value[ 0 ], convert(value[ 1 ]), value[ 2 ] ];\n    })\n  }\n  return cc;\n}\n\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the \n * values are primitive values or other simple objects. It also works with arrays.\n * \n * Uses === equality semantics by default.\n * @param a \n * @param b \n */\nexport const compareObjectData = <T>(a: object | null, b: object | null, assumeSameShape = false, eq: IsEqual<T> = isEqualDefault): CompareChangeSet<string> => {\n  a ??= {};\n  b ??= {};\n  const entriesA = Object.entries(a);\n  const entriesB = Object.entries(b);\n\n  const scannedKeys = new Set<string>();\n  const changed = {}\n  const added = {}\n  const children = {}\n  const removed: string[] = [];\n  const isArray = Array.isArray(a);\n\n  const summary = new Array<ChangeRecord<string>>();\n  let hasChanged = false;\n\n  // Look for existing entries of A that are modified\n  for (const entry of entriesA) {\n    const outputKey = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n    const aValue = entry[ 1 ] as unknown;\n    const bValue = b[ entry[ 0 ] ] as unknown;\n    scannedKeys.add(entry[ 0 ]);\n\n    if (bValue === undefined) {\n      // B does not have a key from A\n      hasChanged = true;\n      if (assumeSameShape && !isArray) {\n        // If we're assuming it's the same shape, then _undefined_ is actually the value\n        changed[ outputKey ] = bValue;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      } else {\n        // Key removed\n        removed.push(outputKey);\n        summary.push([ `del`, outputKey, aValue ]);\n      }\n      continue;\n    }\n\n    if (typeof aValue === `object`) {\n      const r = compareObjectData(aValue, bValue as object, assumeSameShape, eq);\n      if (r.hasChanged) hasChanged = true;\n      children[ outputKey ] = r;\n      const childSummary = r.summary.map(sum => { return [ sum[ 0 ], outputKey + `.` + sum[ 1 ], sum[ 2 ] ] }) as ChangeRecord<string>[];\n      summary.push(...childSummary);\n    } else {\n      if (!eq(aValue as T, bValue as T)) {\n        changed[ outputKey ] = bValue;\n        hasChanged = true;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      }\n    }\n  }\n\n  // Look for entries in B that weren't in A\n  if (!assumeSameShape || isArray) {\n    for (const entry of entriesB) {\n      const key = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n\n      if (scannedKeys.has(entry[ 0 ])) continue;\n      added[ key ] = entry[ 1 ] as unknown;\n      hasChanged = true;\n      summary.push([ `add`, key, entry[ 1 ] ])\n    }\n  }\n  return {\n    changed, added, removed, children, hasChanged, isArray, summary\n  }\n}","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\n\nexport const cloneFromFields = <T extends object>(source: T) => {\n\n  const entries: [ key: string, value: any ][] = [];\n  for (const field in source) {\n    const value = (source)[ field ];\n    if (testPlainObjectOrPrimitive(value as unknown)) {\n      entries.push([ field, value ]);\n    }\n  }\n  return Object.fromEntries(entries) as T;\n}","import type { RemapObjectPropertyType } from \"../ts-utility.js\";\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  object: TSource,\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n  ]) as MapResult[];\n  return Object.fromEntries(mapped) as RemapObjectPropertyType<TSource, TFieldValue>;\n};\n\nexport type MapObjectArgs = {\n  field: string\n  path: string\n  value: any\n  index: number\n}\n\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data \n * @param mapper \n * @returns \n */\nexport function mapObjectByObject(data: object, mapper: Record<string, (value: any, context: any) => any>) {\n  const entries = Object.entries(data);\n  for (const entry of entries) {\n    if (entry[ 0 ] in mapper) {\n      const m = mapper[ entry[ 0 ] ];\n      entry[ 1 ] = (typeof m === `object`) ?\n        mapObjectByObject(entry[ 1 ] as object, m) :\n        m(entry[ 1 ], data);\n    }\n  }\n  return Object.fromEntries(entries);\n}","import { resultThrow, nullUndefTest } from '@ixfx/guards';\nimport { isPrimitive } from '../is-primitive.js';\n\nexport type RecordEntry = Readonly<{ name: string, sourceValue: any, nodeValue: any }>;\nexport type RecordEntryWithAncestors = Readonly<{ name: string, sourceValue: any, nodeValue: any, ancestors: string[] }>;\nexport type RecordEntryStatic = Readonly<{ name: string, value: any, ancestors: string[] }>\n\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n  /**\n   * Separator for path, eg '.'\n   */\n  readonly separator?: string;\n};\n\nexport type RecordChildrenOptions = Readonly<{\n  /**\n   * If set, only uses leaves or branches. 'none' means there is no filter.\n   */\n  filter: `none` | `leaves` | `branches`\n  /**\n   * Default name to use. This is necessary in some cases, eg a root object.\n   */\n  name: string\n}>;\n\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link RecordEntry}.\n * @param entries \n * @returns \n */\nexport function prettyPrintEntries(entries: readonly RecordEntry[]) {\n  if (entries.length === 0) return `(empty)`;\n  let t = ``;\n  for (const [ index, entry ] of entries.entries()) {\n    t += `  `.repeat(index);\n    t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n  }\n  return t;\n}\n\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const recordEntryPrettyPrint = (\n  node: object,\n  indent = 0,\n  options: Partial<RecordChildrenOptions> = {}\n): string => {\n  resultThrow(nullUndefTest(node, `node`));\n  const defaultName = options.name ?? `node`;\n  const entry = getNamedRecordEntry(node, defaultName);\n  const t = `${ `  `.repeat(indent) } + name: ${ entry.name } value: ${ JSON.stringify(entry.nodeValue) }`;\n  const childrenAsArray = [ ...recordChildren(node, options) ];\n  return childrenAsArray.length > 0 ? (\n    t +\n    `\\n` +\n    childrenAsArray.map((d) => recordEntryPrettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)\n  ) : t;\n};\n\n\n\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays. \n * \n * Sub-children are included as an object blob.\n * \n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n * \n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n * \n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children: \n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n * \n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node \n * @param options  \n */\nexport function* recordChildren<T extends object>(\n  node: T,\n  options: Partial<RecordChildrenOptions> = {}\n): IterableIterator<RecordEntry> {\n  resultThrow(nullUndefTest(node, `node`));\n\n  const filter = options.filter ?? `none`;\n\n  const filterByValue = (v: any): [ filter: boolean, isPrimitive: boolean ] => {\n    if (filter === `none`) return [ true, isPrimitive(v) ];\n    else if (filter === `leaves` && isPrimitive(v)) return [ true, true ];\n    else if (filter === `branches` && !isPrimitive(v)) return [ true, false ];\n    return [ false, isPrimitive(v) ];\n  }\n\n  if (Array.isArray(node)) {\n    //if (options.name === undefined) defaultName = `array`;\n    for (const [ index, element ] of node.entries()) {\n      const f = filterByValue(element);\n      if (f[ 0 ]) {\n        yield { name: index.toString(), sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n        //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n      }\n    }\n  } else if (typeof node === `object`) {\n    const entriesIter = (`entries` in node) ? (node as any as Map<any, any>).entries() : Object.entries(node);\n    for (const [ name, value ] of entriesIter) {\n      //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n      const f = filterByValue(value);\n      if (f[ 0 ]) {\n        yield { name: name, sourceValue: value, nodeValue: f[ 1 ] ? value : undefined };\n      }\n    }\n  }\n}\n\nexport function* recordEntriesDepthFirst<T extends object>(node: T, options: Partial<RecordChildrenOptions> = {}, ancestors: string[] = []): IterableIterator<RecordEntryWithAncestors> {\n  for (const c of recordChildren(node, options)) {\n    //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n    yield { ...c, ancestors: [ ...ancestors ] };\n    yield* recordEntriesDepthFirst(c.sourceValue, options, [ ...ancestors, c.name ]);\n  }\n}\n\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction recordEntryChildByName<T extends object>(\n  name: string,\n  node: T\n): RecordEntry | undefined {\n  for (const d of recordChildren(node)) {\n    if (d.name === name) return d;\n  }\n}\n\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceRecordEntryByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getRecordEntryByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): RecordEntry {\n  const paths = [ ...traceRecordEntryByPath(path, node, options) ];\n  if (paths.length === 0) throw new Error(`Could not trace path: ${ path } `);\n  return paths.at(-1) as RecordEntry;\n}\n\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n * \n * Use {@link getRecordEntryByPath} if you don't care about interim steps.\n *\n * ```js\n * const people = {\n *  jane: {\n *   address: {\n *    postcode: 1000,\n *    street: 'West St',\n *    city: 'Blahville'\n *   },\n * colour: 'red'\n *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n * \n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceRecordEntryByPath<T extends object>(\n  path: string,\n  node: T,\n  options: PathOpts = {}\n): Iterable<RecordEntryWithAncestors> {\n  resultThrow(\n    nullUndefTest(path, `path`),\n    nullUndefTest(node, `node`)\n  );\n  const separator = options.separator ?? `.`;\n  const pathSplit = path.split(separator);\n\n  const ancestors: string[] = [];\n  for (const p of pathSplit) {\n    const entry = recordEntryChildByName(p, node);\n    if (!entry) {\n      yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n      return;\n    }\n    node = entry.sourceValue;\n    yield { ...entry, ancestors: [ ...ancestors ] };\n    ancestors.push(p);\n  }\n}\n\n\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedRecordEntry<T extends object>(node: T, defaultName = ``): RecordEntry {\n  if (`name` in node && `nodeValue` in node && `sourceValue` in node) return node as RecordEntry;\n  if (`name` in node) {\n    return { name: node.name as string, nodeValue: node, sourceValue: node };\n  }\n  return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n","// Source: https://stackoverflow.com/questions/49682569/typescript-merge-object-types\n// jcalz 2021-09-09\n\ntype OptionalPropertyNames<T> =\n  // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  { [ K in keyof T ]-?: ({} extends Record<K, T[ K ]> ? K : never) }[ keyof T ];\n\ntype SpreadProperties<L, R, K extends keyof L & keyof R> =\n  { [ P in K ]: L[ P ] | Exclude<R[ P ], undefined> };\n\ntype Id<T> = T extends infer U ? { [ K in keyof U ]: U[ K ] } : never\n\ntype SpreadTwo<L, R> = Id<\n  & Pick<L, Exclude<keyof L, keyof R>>\n  & Pick<R, Exclude<keyof R, OptionalPropertyNames<R>>>\n  & Pick<R, Exclude<OptionalPropertyNames<R>, keyof L>>\n  & SpreadProperties<L, R, OptionalPropertyNames<R> & keyof L>\n>;\n\nexport type Spread<A extends readonly [ ...any ]> = A extends [ infer L, ...infer R ] ?\n  SpreadTwo<L, Spread<R>> : unknown\n\nexport function mergeObjects<A extends object[]>(...a: [ ...A ]) {\n  return Object.assign({}, ...a) as Spread<A>;\n}","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n * \n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n * \n * \n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n * \n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object \n * @param onInvalidKey \n * @returns \n */\nexport const keysToNumbers = <T>(object: Record<string | number | symbol, T>, onInvalidKey: `throw` | `ignore` | `keep` = `throw`): Record<number, T> => {\n  const returnObject: Record<number, T> = {};\n  for (const entry of Object.entries(object)) {\n    const asNumber = Number.parseInt(entry[ 0 ]);\n    if (Number.isNaN(asNumber)) {\n      switch (onInvalidKey) {\n        case `throw`: {\n          throw new TypeError(`Cannot convert key '${ entry[ 0 ] }' to an integer`);\n        }\n        case `ignore`: {\n          continue;\n        }\n        case `keep`: {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n          (returnObject as any)[ entry[ 0 ] ] = entry[ 1 ];\n          continue;\n        }\n        default: {\n          throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n        }\n      }\n    }\n    returnObject[ asNumber ] = entry[ 1 ];\n  }\n  return returnObject;\n}\n","import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport type { IsEqualContext } from '@ixfx/core';\nimport { compareObjectKeys } from './compare.js';\nimport type { Result } from '@ixfx/guards';\n\nexport type PathData<V> = {\n  path: string\n  value: V\n}\n\nexport type PathDataChange<V> = PathData<V> & {\n  previous?: V\n  state: `change` | `added` | `removed`\n}\n\nexport type CompareDataOptions<V> = {\n  /**\n   * If _true_, it treats the B value as a partial\n   * version of B. Only the things present in B are compared.\n   * Omissions from B are not treated as removed keys.\n   */\n  asPartial: boolean\n  /**\n   * If _true_ (default), if a value is undefined,\n   * it signals that the key itself is removed.\n   */\n  undefinedValueMeansRemoved: boolean\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n}\n\nconst getEntries = <V extends Record<string, any>>(target: V, deepProbe: boolean) => {\n  if (target === undefined) throw new Error(`Param 'target' is undefined`);\n  if (target === null) throw new Error(`Param 'target' is null`);\n  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${ typeof target })`);\n  if (deepProbe) {\n    const entries: [ key: string, value: any ][] = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (testPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  if (typeof a === `undefined`) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (typeof b === `undefined`) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const asPartial = options.asPartial ?? false;\n  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n\n  //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  if (isPrimitive(b)) {\n    yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n\n    const keyOfAInB = key in b;\n    const valueOfKeyInB = b[ key ];\n    //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n\n    if (typeof valueA === `object` && valueA !== null) {\n      if (keyOfAInB) {\n        //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n        if (valueOfKeyInB === undefined) {\n          throw new Error(`Pathed.compareData Value for key ${ key } is undefined`);\n        } else {\n          const sub = [ ...compareData(valueA, valueOfKeyInB, {\n            ...options,\n            pathPrefix: pathPrefix + key + `.`\n          }) ];\n          if (sub.length > 0) {\n            for (const s of sub) yield s;\n            if (includeParents) {\n              yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n            }\n          }\n        }\n      } else {\n        if (asPartial) continue;\n        //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n        yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (keyOfAInB) {\n        // B contains key from A\n        if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n          //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n          yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n        } else {\n          if (!eq(valueA, valueOfKeyInB, subPath)) {\n            //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n          }\n        }\n      } else {\n        // B does not contain key from A\n        if (asPartial) continue; // Ignore\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: PathDataChange<any>[]): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: string[], value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareObjectKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): Result<V, any> => {\n  if (typeof path !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Param string 'path' is empty`);\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (object === null) throw new Error(`Param 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: string[]): Result<V, any> => {\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path has run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n    if (typeof object[ index ] === `undefined`) {\n      return { success: false, error: `Index '${ index }' does not exist. Length: ${ object.length }` };\n    }\n\n    if (split.length === 0) {\n      return { value: object[ index ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (typeof object === `object` && start in object) {\n    //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n\n    if (split.length === 0) {\n      return { value: object[ start ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    return { success: false, error: `Path '${ start }' not found` };\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = recordEntriesDepthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, onlyLeaves = false, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    const value = entries[ 1 ];\n    const leaf = (typeof value !== `object`);\n\n    if (onlyLeaves && leaf || !onlyLeaves) {\n      yield { path: sub, value };\n    }\n    yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n  }\n}","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\nexport type * from '../types-compare.js';\nexport * from './pathed.js';\n\n/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n * \n * mapObjectKeys(input, key => key.toUppercase());\n * \n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object \n * @param mapFunction \n * @returns \n */\nexport const mapObjectKeys = <TKeySource extends string | number | symbol, TKeyDestination extends string | number | symbol>(object: Record<TKeySource, unknown>, mapFunction: (key: TKeySource) => TKeyDestination) => {\n  const destinationObject = {};\n  for (const entries of Object.entries(object)) {\n    const key = mapFunction(entries[ 0 ] as TKeySource);\n    (destinationObject as Record<TKeyDestination, unknown>)[ key ] = entries[ 1 ];\n  }\n  return destinationObject as Record<TKeyDestination, unknown>;\n}\n",""],"mappings":";;;;AAGA,MAAM,iBAAiB,OAAO,UAAU;AACxC,MAAM,eAAe,CAACA,UACpB,eAAe,KAAK,MAAM;;;;;;AAO5B,MAAa,QAAQ,CAACA,UACpB,aAAa,MAAM,KAAK,CAAC,YAAY,CAAC;;;;;;AAOxC,MAAa,QAAQ,CAACA,UACpB,aAAa,MAAM,KAAK,CAAC,YAAY,CAAC;;;;AAKxC,MAAa,kBAAkB,CAAIC,wBACjC,OAAO,wBAAwB,CAAC,MAAM,CAAC,GACnC,sBACA,KAAK,UAAU,oBAAoB;;;;;;;;;AAWzC,MAAa,kBAAkB,CAACC,UAAoD;AAElF,KAAI,UAAU,KAAM,QAAO,CAAC,IAAI,CAAC;AACjC,KAAI,OAAO,UAAU,CAAC,OAAO,CAAC,IAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzD,QAAO,MAAM,UAAU;AAGzB,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAAE,QAAO;AACtC,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,UAAU,CAAC,oCAAoC,CAAC;AACzF,QAAO,KAAK,UAAU,MAAM;AAC7B;;;;;;;;;;;;;;;;;AChCD,MAAa,kBAAkB,CAACC,GAAWC,MAA6B;AAEtE,KAAI,MAAM,EAAG,QAAO;AACpB,KAAI,IAAI,EAAG,QAAO;AAClB,QAAO;AACR;;;;;;;;;;;;;;;;;;AAqBD,MAAa,aAAa,CAACC,GAAQC,MAA0B;AAI3D,KAAI,MAAM,UAAa,MAAM,OAAW,QAAO;AAC/C,KAAI,MAAM,OAAW,QAAO;AAC5B,KAAI,MAAM,OAAW,QAAO;CAE5B,MAAM,UAAU,gBAAgB,EAAE;CAClC,MAAM,UAAU,gBAAgB,EAAE;AAElC,KAAI,UAAU,QAAS,QAAO;AAC9B,KAAI,UAAU,QAAS,QAAO;AAC9B,QAAO;AACR;;;;;;AAOD,MAAa,kBAAkB,CAAIC,aAAuC;AACxE,QAAO,CAACC,GAAMC,MAAS;EACrB,MAAM,IAAI,SAAS,GAAG,EAAE;AACxB,SAAO,IAAI;CACZ;AACF;;;;;;;;;;;;;;;;;AAkBD,MAAa,kBAAkB,CAACJ,GAAQC,MAA0B;AAChE,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAChD,QAAO,gBAAgB,GAAG,EAAE;AAE9B,QAAO,WAAW,GAAG,EAAE;AACxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC8HD,MAAa,eAAe,CAC1BI,UACAC,UACAC,UAAqC,CAAE,MACtB;CACjB,IAAI,aAAa,aAAa,UAAU,EAAE;CAC1C,YAAY,YAAY,YAAY,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;CAC5D,MAAM,iBAAiB,QAAQ,kBAAkB;CACjD,MAAM,gBAAgB,QAAQ;CAC9B,MAAM,SAAS,QAAQ;CAEvB,IAAI,WAAW;CACf,IAAIC,WAAmC,CAAC,IAAI,CAAC;CAC7C,IAAI,aAAa;CACjB,IAAI,kBAAkB;CACtB,IAAI,YAAY,YAAY,KAAK;CACjC,IAAI,eAAe,YAAY;CAC/B,IAAI,YAAY;CAChB,IAAIC;CAEJ,MAAM,aAAa,MAAM;AACvB,MAAI,iBAAiB,OAAW;EAChC,WAAW,aAAa,aAAa;EACrC,eAAe;EACf,aAAa;EACb,YAAY;CACb;CAED,MAAM,WAAW,CAACC,sBAAkC;AAClD,MAAI,eAAe,EACjB,KAAI,OAAO,0BAA0B,CAAC,SAAS,CAAC,EAC9C,eAAe,WAAW,WAAW,mBAAmB,EAAE;OACrD;GACL,eAAe;GACf,sBAAsB,kBAAkB;EACzC;OAED,eAAe,WAAW,WAAW,mBAAmB,WAAW;CAEtE;CAED,MAAM,SAAS,MAAM;AACnB,MAAI,UAAW;EACf,YAAY;AAEZ,MAAI,aAAa,CAAC,IAAI,CAAC,CAAE;EACzB,WAAW,CAAC,IAAI,CAAC;EACjB,YAAY;CACb;CAED,MAAM,OAAO,YAAY;AACvB,MAAI,QAAQ,SACV,WAAW,CAAC,IAAI,CAAC;AAEnB,MAAI,aAAa,CAAC,IAAI,CAAC,CAAE;EAEzB,WAAW,CAAC,OAAO,CAAC;EACpB;EACA;EACA,MAAM,iBAAiB,SAAS,YAAY,YAAY,KAAK,GAAG,UAAU;EAC1E,MAAM,QAAQ,OAAO,mBAAmB,CAAC,MAAM,CAAC,GAAI,MAAM,iBAAkB;AAC5E,MAAI,UACF;EAEF,WAAW,CAAC,SAAS,CAAC;AAGtB,MAAI,UAAU,UAAa,CAAC,OAAO;GACjC,QAAQ;AACR;EACD;AAED,MAAI,UAAW;EAEf,SAAS,KAAK;CACf;CAED,MAAM,QAAQ,MAAM;AAClB,MAAI,SAAU,OAAM,IAAI,MAAM,CAAC,QAAQ,CAAC;EACxC,YAAY;AAEZ,MAAI,kBAAkB,QAAW;GAE/B,MAAM,SAAS,cAAc,YAAY,YAAY,KAAK,GAAG,UAAU;AACvE,WAAQ,QAAR;IACE,KAAK,CAAC,MAAM,CAAC,EAAE;KACb,QAAQ;AACR;IACD;IACD,KAAK,CAAC,KAAK,CAAC,EAAE;KACZ,OAAO;AACP;IACD;IACD,KAAK,CAAC,OAAO,CAAC,EAAE;KACd,WAAW;KACX,QAAQ;AACR;IACD;GAEF;EACF;AAED,MAAI,aAAa,CAAC,IAAI,CAAC,EAAE;GAEvB,aAAa;GACb,YAAY,YAAY,KAAK;GAC7B,WAAW,CAAC,SAAS,CAAC;AACtB,OAAI,gBACG,MAAM;QAGX,SAAS,KAAK;EAEjB;CACF;CAED,MAAM,QAAQ,MAAM;AAClB,MAAI,SAAU,OAAM,IAAI,MAAM,CAAC,QAAQ,CAAC;EACxC,YAAY;EACZ,aAAa;EACb,YAAY;AAGZ,MAAI,aAAa,CAAC,IAAI,CAAC,EACrB,QAAQ;EAEV,OAAO;CACR;AAED,QAAO;EACL;EACA;EACA;EACA,IAAI,WAAW;AACb,UAAO;EACR;EACD,IAAI,WAAW;AACb,UAAO;EACR;EACD,IAAI,kBAAkB;AACpB,UAAO;EACR;EACD,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,SAASC,YAAoB;GAC/B,MAAM,KAAK,aAAaC,YAAU,EAAE;GACpC,YAAY,YAAY,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;GACpD,aAAa;GACb,eAAeA;EAChB;EACD,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,YAAY;AACd,UAAO,YAAY,KAAK,GAAG;EAC5B;CACF;AACF;;;;AC7WD,MAAM,aAAa,CAACC,GAAWC,MAAc;AAC3C,KAAI,EAAE,QAAQ,EAAE,MAAO,QAAO;UACrB,EAAE,QAAQ,EAAE,MAAO,QAAO;AACnC,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDD,MAAa,QAAQ,CACnBC,oBACAC,UACAC,SACAC,UAAqB,CAAE,MACM;CAC7B,MAAM,iBAAiB,QAAQ,kBAAkB;CACjD,MAAM,QAAQ,QAAQ,SAAS;CAC/B,MAAM,0BAAU,IAAI;CACpB,MAAMC,YAA6B,CAAE;CAErC,MAAM,0BAAU,IAAI;CACpB,UAAU,QAAQ,CAAC,GAAG,UAAU;AAC9B,MAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CAC1B,OAAM,IAAI,MAAM,CAAC,sCAAsC,EAAG,MAAM,UAAU,CAAE,CAAC,CAAC;EAEhF,QAAQ,IAAI,EAAE,IAAI,EAAE;CACrB,EAAC;AAEF,MAAK,MAAM,QAAQ,SAAS;AAG1B,MAAI,CAAC,YAAY,SAAS,WAAW,GAAG;AAEtC,OAAI,OAAO,QAAQ,MAAM,CAAC,0BAA0B,EAAG,KAAK,IAAK,CAAC;GAElE,UAAU,KAAK,KAAK;AACpB;EACD;EAGD,MAAM,mBAAmB,MAAM,KAAK,QAAQ,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAU;GACnE,IAAK,KAAM;GACX,OAAQ,SAAqB,OAAO,KAAK,mBAAmB,MAAM,KAAK;GACvE;EACD,GAAE;AAEH,MAAI,iBAAiB,WAAW,GAAG;AACjC,OAAI,OACF,QAAQ,MAAM,CAAC,2CAA2C,EAAG,KAAK,IAAK,CAAC;GAE1E,UAAU,KAAK,KAAK;AACpB;EACD;EACD,iBAAiB,KAAK,WAAW;EAGjC,MAAM,MAAM,iBAAkB;AAC9B,MAAI,IAAI,QAAQ,gBAAgB;AAC9B,OAAI,OACF,QAAQ,MACN,CAAC,gEAAgE,EAAG,IAAI,MAAM,UAAU,CAAE,KAAK,EAAG,KAAK,IAAK,CAC7G;GAEH,UAAU,KAAK,KAAK;AACpB;EACD;AAQD,MAAI,SAAS,IAAI,OAAO,KAAK,IAC3B,QAAQ,IACN,CAAC,2BAA2B,EAAG,KAAK,GAAI,IAAI,EAAG,IAAI,GAAI,SAAS,EAAG,IAAI,MAAM,UAAU,CAAE,CAAC,CAAC,CAC5F;EAEH,QAAQ,IAAI,IAAI,IAAI;GAAE,GAAG;GAAM,IAAI,IAAI;EAAI,EAAC;EAG5C,QAAQ,OAAO,IAAI,GAAG;CACvB;CAED,UAAU,QAAQ,CAAC,MAAM,QAAQ,IAAI,EAAE,IAAI,EAAE,CAAC;AAC9C,QAAO,MAAM,KAAK,QAAQ,QAAQ,CAAC;AACpC;;;;;;;;;;;;;;;;;;;;;;;AAwBD,MAAa,YAAY,CAAIC,IAAmBF,UAAqB,CAAE,MAAK;CAC1E,IAAIG,WAAqC,CAAE;CAE3C,MAAM,UAAU,CAACC,YAA6B;EAC5C,WAAW,MAAM,IAAI,UAAU,SAAS,QAAQ;AAChD,SAAO,CAAE,GAAG,QAAU;CACvB;AACD,QAAO;AACR;;;;;;;;;;AC9KD,MAAa,eAAe,CAAIC,MAAS;AACvC,QAAO,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,KAAK,UAAU,EAAE;AACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC2BD,MAAa,eAAe,MAAa;CACvC,MAAM,QAAQ,YAAY,KAAK;AAC/B,QAAO,MAAc;AACnB,SAAO,YAAY,KAAK,GAAG;CAC5B;AACF;;;;;;;;;;;;;;;AAgBD,MAAa,kBAAkB,MAAa;CAC1C,IAAI,QAAQ,YAAY,KAAK;AAC7B,QAAO,MAAc;EACnB,MAAM,MAAM,YAAY,KAAK;EAC7B,MAAM,IAAI,MAAM;EAChB,QAAQ;AACR,SAAO;CACR;AACF;;;;;;;;;;;;;;;;;;AAkBD,MAAa,cAAc,MAAa;CACtC,MAAM,QAAQ,KAAK,KAAK;CACxB,IAAI,YAAY;AAChB,QAAO,MAAc;AACnB,MAAI,cAAc,GAChB,YAAY,KAAK,KAAK,GAAG;AAE3B,SAAO;CACR;AACF;;;;;;;;;;;;;;;;AAgBD,MAAa,kBAAkB,MAAa;AAC1C,QAAO,MAAc;AACnB,SAAO,OAAO;CACf;AACF;;;;;;;;;;;;;;;;;;;;AC9FD,MAAa,cAAc,CAAIC,GAAMC,WAA8BC,cAA4C;AAC7G,KAAI,UAAU,EAAE,CAAE,QAAO;AACzB,QAAO;AACR;;;;;;;;;;;;;;;AC4HD,MAAa,aAAa,CAACC,QAAgB,YAAY,OAAO;CAC5D,YAAY,YAAY,WAAW,CAAC,SAAS,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;AAC7D,KAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,kCAAkC,CAAC;AAEpF,KAAI,OAAO,SAAS,aAAa,OAAO,SAAS,GAAG;AAClD,MAAI,YAAY,IAAI;GAClB,MAAM,QAAQ,KAAK,OAAO,YAAY,KAAK,EAAE;AAC7C,UAAO,OAAO,MAAM,GAAG,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,OAAO,MAAM,CAAC,MAAM;EAC7D;AACD,SAAO,OAAO,MAAM,GAAG,UAAU,GAAG,CAAC,GAAG,CAAC;CAC1C;AACD,QAAO;AACR;;;;;;;AAQD,MAAa,qBAAqB,CAACC,QAAa,YAAY,OAAO;AACjE,KAAI,WAAW,OAAW,QAAO,CAAC,WAAW,CAAC;AAC9C,KAAI,WAAW,KAAM,QAAO,CAAC,MAAM,CAAC;AACpC,QAAO,WAAW,KAAK,UAAU,OAAO,EAAE,UAAU;AACrD;;;;;;;;;;;;;;;ACzJD,MAAa,eAAe,CAAIC,OAA+B;AAC7D,QAAO,CAAC,GAAG,MAAM;EACf,MAAM,SAAS,GAAG,GAAG,EAAE;EAEvB,QAAQ,IAAI,CAAC,iBAAiB,EAAG,OAAQ,IAAI,EAAG,mBAAmB,EAAE,CAAE,IAAI,EAAG,mBAAmB,EAAE,EAAG,CAAC;AACvG,SAAO;CACR;AACF;;;;;;;;;;;;ACPD,MAAa,kBAAkB,CAACC,wBAAiC;AAC/D,KAAI,OAAO,wBAAwB,CAAC,MAAM,CAAC,CAAE,QAAO;CACpD,MAAM,0BAAU,IAAI;CAEpB,KAAK,UAAU,qBAAqB,CAACC,KAAaC,WAAoB,QAAQ,IAAI,IAAI,EAAE,OAAO;AAC/F,QAAO,KAAK,UAAU,qBAAqB,CAAE,GAAG,OAAS,EAAC,MAAM,CAAC;AAClE;;;;;AAOD,MAAa,iBAAiB,CAAIC,GAAMC,MAAkB,MAAM;;;;;;;;;;;;;;;;;;;AAoBhE,MAAa,sBAAsB,CAAID,GAAMC,MAAkB;AAE7D,KAAI,MAAM,EAAG,QAAO;AACpB,QAAO,gBAAgB,EAAE,KAAK,gBAAgB,EAAE;AACjD;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BD,MAAa,sBAAsB,CAACC,GAA4BC,GAA4BC,kBAA8C;AACxI,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AAC5E,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AAE5E,KAAI,OAAO,GAAG,GAAG,EAAE,CAAE,QAAO;CAC5B,MAAM,WAAW,iBAAiB;AAClC,MAAK,MAAM,UAAU,OAAO,QAAQ,EAAE,EAAE;EACtC,MAAM,mBAAmB,EAAG,OAAQ;EACpC,MAAM,SAAS,OAAQ;AACvB,MAAI,OAAO,qBAAqB,CAAC,MAAM,CAAC,IAAI,OAAO,WAAW,CAAC,MAAM,CAAC,EACpE;OAAI,CAAC,SAAS,kBAA6C,OAAkC,CAC3F,QAAO;EACR,WAEG,qBAAqB,OACvB,QAAO;CAGZ;AACD,QAAO;AACR;;;;;;;;;;;;;;AAgBD,MAAa,0BAA0B,CAAIJ,GAAMC,MAAkB;AAEjE,KAAI,MAAM,EAAG,QAAO;AACpB,QAAO,gBAAgB,EAAE,KAAK,gBAAgB,EAAE;AACjD;;;;;;AAOD,MAAa,iBAAiB,CAACI,UAAkB,CAAE,GAAG,OAAO,QAAQ,MAAM,AAAE,EAAC,WAAW;;;;;;;;;AAgBzF,MAAaC,uBAAgD,CAACC,GAAYC,GAAYC,UAA2B;AAC/G,QAAO,KAAK,UAAU,EAAE,KAAK,KAAK,UAAU,EAAE;AAC/C;;;;;;;;;;;;;;;;;;;;;AChID,MAAa,YAAY,CAACC,UAA2B;AACnD,KAAI,UAAU,OAAW,QAAO;AAChC,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,EAAE;EAC7B,MAAM,IAAI,OAAO,SAAS,MAAM;AAChC,MAAI,OAAO,MAAM,EAAE,CAAE,QAAO;AAC5B,MAAI,EAAE,UAAU,KAAK,MAAM,UAAU,CAAE,QAAO;AAC9C,SAAO;CACR;AACD,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,EAAE;AAC7B,MAAI,OAAO,MAAM,MAAM,CAAE,QAAO;AAChC,MAAI,CAAC,OAAO,SAAS,MAAM,CAAE,QAAO;AACpC,MAAI,KAAK,MAAM,MAAM,KAAK,MAAO,QAAO;AACxC,SAAO;CACR;AACD,QAAO;AACR;;;;;;;;;;;;ACtBD,SAAgB,YAAYC,OAAgC;AAC1D,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAAE,QAAO;AACtC,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAAE,QAAO;AACtC,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAAE,QAAO;AACtC,KAAI,OAAO,UAAU,CAAC,OAAO,CAAC,CAAE,QAAO;AACvC,QAAO;AACR;;;;;;;;AASD,SAAgB,oBAAoBA,OAAwC;AAC1E,KAAI,YAAY,MAAM,CAAE,QAAO;AAC/B,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CAAE,QAAO;AACtC,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;ACND,MAAa,+BAA+B,CAC1CC,GACAC,GACA,KAAK,mBACF;CACH,MAAMC,SAAa,CAAE;CACrB,MAAMC,UAAc,CAAE;CACtB,MAAMC,UAAc,CAAE;AAEtB,MAAK,MAAM,cAAc,GAAG;EAC1B,IAAI,UAAU;AAEd,OAAK,MAAM,cAAc,EACvB,KAAI,GAAG,YAAY,WAAW,EAAE;GAC9B,UAAU;AACV;EACD;AAGH,MAAI,SAEF,OAAO,KAAK,WAAW;OAGvB,QAAQ,KAAK,WAAW;CAE3B;AAED,MAAK,MAAM,cAAc,GAAG;EAC1B,IAAI,UAAU;AAEd,OAAK,MAAM,cAAc,EACvB,KAAI,GAAG,YAAY,WAAW,EAC5B,UAAU;AAGd,MAAI,CAAC,SAEH,QAAQ,KAAK,WAAW;CAE3B;CAGD,MAAM,SAAS,QAAQ,WAAW,KAAK,QAAQ,WAAW;AAE1D,QAAO;EACL;EACA;EACA,GAAG;EACH,GAAG;CACJ;AACF;;;;AC/CD,MAAM,qBAAqB,CAACC,OAAe,UAAU,UAAU;AAC7D,QAAO,CAACC,WAAuB;EAC7B,MAAM,IAAI,OAAO,SAAS,CAAC,GAAG,MAAM;AAClC,UAAO,gBAAgB,EAAG,QAAS,EAAG,OAAQ;EAC/C,EAAC;AACF,MAAI,QAAS,QAAO,EAAE,SAAS;AAC/B,SAAO;CACR;AACF;AAGD,MAAa,iBAAiB,CAACC,cAAiD;AAC9E,SAAQ,WAAR;EACE,KAAK,CAAC,KAAK,CAAC,CACV,QAAO,mBAAmB,GAAG,MAAM;EAErC,KAAK,CAAC,aAAa,CAAC,CAClB,QAAO,mBAAmB,GAAG,KAAK;EAEpC,KAAK,CAAC,GAAG,CAAC,CACR,QAAO,mBAAmB,GAAG,MAAM;EAErC,KAAK,CAAC,WAAW,CAAC,CAChB,QAAO,mBAAmB,GAAG,KAAK;EAEpC,QACE,OAAM,IAAI,MAAM,CAAC,uBAAuB,EAAI,UAAsB,sDAAsD,CAAC;CAE5H;AACF;;;;;;;;;;;;;;;;;;;;;;;AChCD,SAAgB,MAAMC,GAAWC,GAAsBC,SAAmB;CACxE,YAAY,YAAY,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC;CAExD,MAAM,KAAM,OAAO,MAAM,CAAC,OAAO,CAAC,GAAI,IAAK,WAAW;CACtD,IAAI;AACJ,KAAI,MAAM,GACR,UAAU,KAAK;MACV;EACL,MAAM,IAAI,KAAK,IAAI,IAAI,EAAE;AACzB,MAAI,IACF,UAAU,CAACC,MAAc,KAAK,KAAK,IAAI,EAAE,GAAG;OAE5C,UAAU,CAACA,MAAc,KAAK,MAAM,IAAI,EAAE,GAAG;CAEhD;AACD,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,QAAO,QAAQ,EAAE;AAC5C,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;ACTD,SAAgB,aACdC,UACAC,eACQ;AACR,KAAI,WAAW,SAAS,EAAE;AAExB,MAAI,OAAO,aAAa,CAAC,MAAM,CAAC,CAAE,QAAO;EAEzC,IAAI,KAAK,SAAS,UAAU;EAC5B,OAAO,SAAS,SAAS,KAAK,KAAK,KAAK;EACxC,OAAO,SAAS,QAAQ,KAAK,KAAK;EAClC,OAAO,SAAS,QAAQ,KAAK;AAC7B,SAAO;CACR,OAAM;AACL,MAAI,OAAO,kBAAkB,CAAC,SAAS,CAAC,CAAE,QAAO;AACjD,QAAM,IAAI,MAAM,CAAC,sBAAsB,EAAG,KAAK,UAAU,SAAS,EAAG;CACtE;AACF;;;;;;AAOD,SAAgB,WAAWC,UAA+D;AACxF,KAAI,OAAO,aAAa,CAAC,SAAS,CAAC,CAAE,QAAO;AAC5C,KAAI,aAAa,KAAM,QAAO;AAC9B,KAAI,OAAO,aAAa,CAAC,MAAM,CAAC,EAAE;AAChC,MAAI,OAAO,MAAM,SAAS,CAAE,QAAO;AACnC,MAAI,CAAC,OAAO,SAAS,SAAS,CAAE,QAAO;AACvC,SAAO;CACR;AACD,KAAI,OAAO,aAAa,CAAC,MAAM,CAAC,CAAE,QAAO;CACzC,MAAM,YAAY,CAAC,MAAM,CAAC,IAAI;CAC9B,MAAM,UAAU,CAAC,IAAI,CAAC,IAAI;CAC1B,MAAM,UAAU,CAAC,IAAI,CAAC,IAAI;CAC1B,MAAM,WAAW,CAAC,KAAK,CAAC,IAAI;AAC5B,KAAI,aAAa,CAAC,WAAW,SAAS,OAAO,CAAC,QAAS,QAAO;AAC9D,KAAI,WAAW,CAAC,WAAW,SAAS,KAAK,CAAC,QAAS,QAAO;AAC1D,KAAI,WAAW,CAAC,WAAW,SAAS,KAAK,CAAC,QAAS,QAAO;AAC1D,KAAI,YAAY,CAAC,WAAW,SAAS,MAAM,CAAC,QAAS,QAAO;AAC5D,KAAI,aAAa,WAAW,YAAY,QAAS,QAAO;AACxD,QAAO;AACR;;;;;;;;;;;;;;;AAgBD,MAAa,uBAAuB,CAACC,kBAAsD,WAAW,MAAc;CAClH,IAAIC,WAA+B;AACnC,KAAI,OAAO,qBAAqB,CAAC,QAAQ,CAAC,EAAE;EAC1C,MAAM,iBAAiB,kBAAkB;AACzC,SAAO,qBAAqB,eAAe;CAC5C,WAAU,OAAO,qBAAqB,CAAC,MAAM,CAAC,EAC7C,WAAW;UACF,OAAO,qBAAqB,CAAC,MAAM,CAAC,EAC7C,WAAW,aAAa,SAAS;CAGnC,IAAI,KAAK,aAAa,SAAS;AAC/B,KAAI,OAAO,OAAO,CAAC,SAAS,CAAC,CAAE,QAAO,CAAC,WAAW,CAAC;AACnD,KAAI,KAAK,IAAM,QAAO,GAAI,MAAM,UAAU,GAAG,CAAE,EAAE,CAAC;CAClD,MAAM;AACN,KAAI,KAAK,IAAK,QAAO,GAAI,GAAG,QAAQ,EAAE,CAAE,IAAI,CAAC;CAC7C,MAAM;AACN,KAAI,KAAK,GAAI,QAAO,GAAI,GAAG,QAAQ,EAAE,CAAE,IAAI,CAAC;CAC5C,MAAM;AACN,QAAO,GAAI,GAAG,QAAQ,EAAE,CAAE,GAAG,CAAC;AAC/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFD,MAAa,SAAS,CAAIC,WAAwB,oBAAoC;CACpF,MAAM,sBAAM,IAAI;AAEhB,QAAO,CAACC,UAAa;AACnB,MAAI,UAAU,KAAM,OAAM,IAAI,UAAU,CAAC,4BAA4B,CAAC;AACtE,MAAI,UAAU,OAAW,OAAM,IAAI,UAAU,CAAC,iCAAiC,CAAC;EAEhF,MAAM,WAAY,OAAO,UAAU,CAAC,MAAM,CAAC,GAAI,QAAQ,SAAS,MAAM;AACtE,MAAI,IAAI,IAAI,SAAS,CAAE,QAAO;EAC9B,IAAI,IAAI,SAAS;AACjB,SAAO;CACR;AACF;;;;;AAMD,MAAa,kBAAkB,MAAyB;CAEtD,MAAM,sBAAM,IAAI;AAChB,QAAO,CAACA,UAAa;AACnB,MAAI,UAAU,KAAM,OAAM,IAAI,UAAU,CAAC,4BAA4B,CAAC;AACtE,MAAI,UAAU,OAAW,OAAM,IAAI,UAAU,CAAC,iCAAiC,CAAC;AAEhF,MAAI,IAAI,IAAI,MAAM,CAAE,QAAO;EAC3B,IAAI,IAAI,MAAM;AACd,SAAO;CACR;AACF;;;;;;;;ACvDD,MAAa,aAAa,MACxB;CACE,CAAC,cAAc,CAAC;CAChB,CAAC,gBAAgB,CAAC;CAClB,CAAC,cAAc,CAAC;CAChB,CAAC,IAAI,CAAC;CACN,CAAC,MAAM,CAAC;CACR,CAAC,IAAI,CAAC;AACP,EAAC,SAAS,UAAU,SAAS,IAE7B,UAAU,UAAU,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI;;;;ACd1D,MAAa,mBAAmB,CAACC,QAAqBC,SAA+B;AACnF,QAAO,IAAI,QAAQ,eAAW;EAC5B,MAAM,UAAU,CAAC,GAAG,SAAqB;GACvC,OAAO,oBAAoB,MAAM,QAAQ;AACzC,OAAI,MAAM,QAAQ,KAAK,IAAI,KAAK,WAAW,GAAGC,UAAQ,KAAM,GAAI;QAC3DA,UAAQ,KAAK;EACnB;EACD,OAAO,iBAAiB,MAAM,QAAQ;CACvC;AACF;;;;;;;;;ACFD,MAAa,aAAa,CAAIC,OAAkC;AAC9D,KAAI,OAAO,OAAO,CAAC,MAAM,CAAC,CAAE,QAAO;AACnC,KAAI,OAAO,KAAM,QAAO;AACxB,QAAQ,CAAC,EAAE,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI;AACpC;;;;;;;;AASD,MAAa,UAAU,CAAIA,OAAyC;AAClE,KAAI,CAAC,WAAW,GAAG,CAAE,QAAO;AAC5B,KAAI,CAAC,IAAI,CAAC,IAAI,IAAI;EAEhB,MAAM,IAAK,GAAW,MAAM;AAC5B,MAAI,MAAM,OAAW,QAAO;CAC7B;AACD,QAAO;AACR;;;;AC5BD,MAAa,oBAAoB,CAAC,KAAK,OAAO,CAAC,KAAK,SAAS;CACzD,IAAI,QAAQ,IAAI,IAAI,IAAI;AACxB,KAAI,UAAU,OACV,QAAO;CACX,QAAQ,GAAG,KAAK,KAAK;CACrB,IAAI,IAAI,KAAK,MAAM;AACnB,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC0BD,MAAa,SAAS,CAAC,QAAQ,OAAO,CAAC,GAAG,CAAC,EAAE,cAAc,CAAC,MAAM;AAC9D,KAAI,MAAM,QACN,IAAI,CAAC,WAAW,CAAC;UAEZ,OAAO,MAAM,CAAC,MAAM,CAAC,EAC1B,IAAI,KAAK,UAAU,EAAE;CAEzB,MAAM,SAAS,aAAa;AAC5B,SAAQ,MAAR;EACI,KAAK,CAAC,GAAG,CAAC,EAAE;GACR,QAAQ,IAAI,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,GAAG,EAAE,CAAC,OAAO,EAAE,WAAW,OAAO,EAAE,CAAC;AAC/D;EACH;EACD,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,QAAQ,KAAK,QAAQ,EAAE;AACvB;EACH;EACD,KAAK,CAAC,KAAK,CAAC,EAAE;GACV,QAAQ,MAAM,QAAQ,EAAE;AACxB;EACH;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;AAwBD,MAAa,SAAS,CAAC,QAAQ,UAAU,MAAM,cAAc;AACzD,KAAI,QACA,QAAO;EACH,KAAK,OAAO,QAAQ,CAAC,GAAG,CAAC,EAAE,UAAU;EACrC,MAAM,OAAO,QAAQ,CAAC,IAAI,CAAC,EAAE,UAAU;EACvC,OAAO,OAAO,QAAQ,CAAC,KAAK,CAAC,EAAE,UAAU;CAC5C;AAEL,QAAO;EACH,KAAK,CAAC,MAAM;;EAEX;EACD,MAAM,OAAO,QAAQ,CAAC,IAAI,CAAC,EAAE,UAAU;EACvC,OAAO,OAAO,QAAQ,CAAC,KAAK,CAAC,EAAE,UAAU;CAC5C;AACJ;;;;;;AAMD,MAAa,mBAAmB,CAAC,GAAG,WAAW,CAAE,MAAK;AAClD,KAAI,MAAM,UAAc,OAAO,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,EAC/C,QAAO,CAAC,MAAM;;CAEb;CAEL,MAAM,aAAa,SAAS,YAAY,EAAE;CAC1C,MAAM,cAAc,SAAS,QAAQ;AACrC,KAAI,OAAO,MAAM,CAAC,OAAO,CAAC,CACtB,QAAO,CAAC,oBAAoB;EACxB,MAAM,IAAI,OAAO,oBAAoB,CAAC,MAAM,CAAC,GAAG,EAAE,KAAK,gBAAiB,IAAG;EAC3E,MAAM,OAAO,EAAE,QAAQ;EACvB,MAAM,WAAW,EAAE,YAAY;EAC/B,IAAI,UAAU,EAAE;AAChB,MAAI,UACA,UAAU,CAAC,CAAC,EAAE,SAAS,EAAE,EAAE,SAAS;AACxC,UAAQ,MAAR;GACI,KAAK,CAAC,KAAK,CAAC,EAAE;IACV,QAAQ,MAAM,QAAQ;AACtB;GACH;GACD,KAAK,CAAC,IAAI,CAAC,EAAE;IACT,QAAQ,KAAK,QAAQ;AACrB;GACH;GACD,KAAK,CAAC,IAAI,CAAC,EAAE;IACT,QAAQ,KAAK,QAAQ;AACrB;GACH;GACD,SACI,QAAQ,IAAI,QAAQ;EAE3B;CACJ;AAEL,QAAO;AACV;AACD,IAAI,iBAAiB;AACrB,MAAa,aAAa,kCAAkB,IAAI,OAAO,MAAM;CACzD,MAAM,MAAM,EAAE,iBAAiB;AAC/B,QAAO,CAAC,IAAI,EAAE,IAAI,SAAS,CAAC;AAC/B,EAAC;;;;;;;;;;;;;;;;;;;;;;;AC1HF,MAAa,aAAa,CAAC,cAAc,MAAM,qBAAqB,QAAQ;CACxE,IAAI,QAAQ;CACZ,IAAI,UAAU;CACd,IAAI,aAAa,YAAY,KAAK;AAClC,QAAO,MAAM;AACT,MAAI,WAAW,oBAAoB;GAC/B,MAAM,UAAU,YAAY,KAAK,GAAG;GACpC,aAAa,YAAY,KAAK;GAC9B,QAAQ;GACR,UAAU,KAAK,MAAO,qBAAqB,UAAW,IAAK;AAC3D,OAAI,aACA,QAAQ,IAAI,CAAC,KAAK,EAAE,SAAS,CAAC;EACrC;AACD,SAAO;CACV;AACJ;;;;;;;;;AC7BD,MAAa,kBAAkB,CAAC,OAAO;AACnC,KAAI,OAAO,OAAO,CAAC,MAAM,CAAC,CACtB,QAAO;AACX,KAAI,cAAc,MACd,QAAO,GAAG;AAEd,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE0BD,eAAsB,QAA6BC,GAAsB,GAAG,MAAuB;AACjG,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACvB,KAAI,CAAC,IAAI,CAAC,IAAI,GAAG;EACf,MAAM,MAAO,EAAW,OAAO;AAC/B,MAAI,QAAQ,CAAC,SAAS,CAAC,IAAI,OAAO,CAAC,cAAc,CAAC,EAAE;GAClD,MAAM,IAAI,EAAE,MAAM;AAClB,OAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,EAAG,QAAO,EAAE;AAC1C,UAAO;EACR,WAAU,QAAQ,CAAC,cAAc,CAAC,EAAE;GACnC,MAAM,IAAI,MAAM,EAAE,MAAM;AAExB,OAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,EAAG,QAAO,EAAE;AAC1C,UAAO;EACR,MACC,OAAM,IAAI,MAAM,CAAC,qHAAqH,EAAG,IAAK,CAAC,CAAC;CAEnJ,WAAU,WAAc,EAAE,EAAE;AAC3B,MAAI,QAAQ,EAAE,CAAE,QAAO,EAAE,MAAM;AAC/B,QAAM,IAAI,MAAM,CAAC,iCAAiC,CAAC;CACpD,MAEC,QAAO;UAEA,OAAO,MAAM,CAAC,QAAQ,CAAC,EAAE;EAClC,MAAM,IAAI,MAAM,EAAE,KAAK;AACvB,SAAO;CACR,MAEC,QAAO;AAEV;;;;;;;AAQD,SAAgB,YAAiCC,GAA0B,GAAG,MAAc;AAC1F,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACvB,KAAI,CAAC,IAAI,CAAC,IAAI,GAAG;EACf,MAAM,MAAO,EAAW,OAAO;AAC/B,MAAI,QAAQ,CAAC,SAAS,CAAC,IAAI,OAAO,CAAC,cAAc,CAAC,EAAE;GAClD,MAAM,IAAI,EAAE,MAAM;AAClB,OAAI,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,EAAG,QAAO,EAAE;AAC1C,UAAO;EACR,WAAU,QAAQ,CAAC,cAAc,CAAC,CACjC,OAAM,IAAI,MAAM,CAAC,+CAA+C,CAAC;MAEjE,OAAM,IAAI,MAAM,CAAC,mGAAmG,EAAG,IAAK,CAAC,CAAC;CAEjI,WAAU,WAAc,EAAE,EAAE;AAC3B,MAAI,QAAQ,EAAE,CAAE,QAAO,EAAE,MAAM;AAC/B,QAAM,IAAI,MAAM,CAAC,iCAAiC,CAAC;CACpD,MAEC,QAAO;UAEA,OAAO,MAAM,CAAC,QAAQ,CAAC,CAChC,QAAO,EAAE,KAAK;KAGd,QAAO;AAEV;;;;;;;;;;;;;;;;;;;;;;AAuBD,eAAsB,oBAAyCC,GAAsBC,UAAkC,GAAG,MAAW;CACnI,IAAI,UAAU;CACd,IAAI,gBAAgB,SAAS;CAC7B,MAAM,mBAAmB,SAAS,oBAAoB;AACtD,KAAI,kBAAkB,OAAW,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;AAEzE,KAAI;EACF,MAAM,IAAI,MAAM,QAAQ,GAAG,GAAG,KAAK;AACnC,MAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CAAE,QAAO;AACrC,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,OAAO,MAAM,EAAE,CAAE,QAAO;AACrD,MAAI,kBAAkB,gBAAgB;AACtC,SAAO;CACR,SAAQ,OAAO;AACd,MAAI,CAAC,SAAS;GACZ,UAAU;GACV,QAAQ,KAAK,CAAC,uEAAuE,CAAC,EAAE,gBAAgB,MAAM,CAAC;EAChH;AACD,SAAO;CACR;AACF;AAED,SAAgB,wBAA6CC,GAA0BD,UAAkC,GAAG,MAAW;CACrI,IAAI,UAAU;CACd,IAAI,gBAAgB,SAAS;CAC7B,MAAM,mBAAmB,SAAS,oBAAoB;AACtD,KAAI,kBAAkB,OAAW,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;AAEzE,KAAI;EACF,MAAM,IAAI,YAAY,GAAG,GAAG,KAAK;AACjC,MAAI,OAAO,MAAM,CAAC,SAAS,CAAC,CAAE,QAAO;AACrC,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,OAAO,MAAM,EAAE,CAAE,QAAO;AACrD,MAAI,kBAAkB,gBAAgB;AACtC,SAAO;CACR,SAAQ,OAAO;AACd,MAAI,CAAC,SAAS;GACZ,UAAU;GACV,QAAQ,KAAK,CAAC,2EAA2E,CAAC,EAAE,gBAAgB,MAAM,CAAC;EACpH;AACD,SAAO;CACR;AACF;;;;ACrKD,MAAa,MAAM,CACjB,GAAG,WACO;AACV,KAAI,OAAO,KAAK,CAAC,MAAM,CAAC,MAAM,QAAQ,EAAE,CAAC,CACvC,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;CAEnD,MAAM,UAAU,OAAO,IAAI,CAAC,MAAO,EAAY,OAAO;CAEtD,MAAME,cAAqB,CAAE;CAC7B,MAAM,SAAS,QAAS;AAExB,MAAK,IAAI,QAAQ,GAAG,QAAQ,QAAQ,SAElC,YAAY,KAAK,OAAO,IAAI,CAAC,MAAM,EAAG,OAAQ,CAAC;AAEjD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC+CD,eAAsB,cAA6DC,QAAuC;CACxH,MAAMC,YAAmB,CAAE;CAC3B,MAAMC,OAAiB,CAAE;AACzB,MAAK,MAAM,SAAS,OAAO,QAAQ,OAAO,EAAE;EAC1C,MAAM,aAAa,MAAO;EAC1B,UAAU,KAAK,QAAQ,WAAW,CAAC;EACnC,KAAK,KAAK,MAAO,GAAI;CACtB;CACD,MAAM,UAAU,MAAM,QAAQ,IAAI,UAAU;CAC5C,MAAM,UAAU,IAAI,MAAM,QAAQ;AAClC,QAAO,OAAO,YAAY,QAAQ;AACnC;;;;;;;AAQD,SAAgB,kBAAiEF,QAA8B;CAC7G,MAAMG,UAAyC,CAAE;AACjD,MAAK,MAAM,SAAS,OAAO,QAAQ,OAAO,EAAE;EAC1C,MAAM,aAAa,MAAO;EAC1B,MAAM,QAAQ,YAAY,WAAW;EACrC,QAAQ,KAAK,CAAE,MAAO,IAAK,KAAO,EAAC;CACpC;AACD,QAAO,OAAO,YAAY,QAAQ;AACnC;;;;;;;;;;;ACjFD,IAAI,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,qBAAqB,CAAC,IAAI,SAEhE;KAAI,OAAO,WAAW,CAAC,SAAS,CAAC,EAG/B,WAAW,wBAAwB,CAAC,aAAa;EAC/C,WAAW,UAAU,EAAE;CACxB;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CH,MAAa,QAAQ,CACnBC,iBAC2B;CAC3B,MAAM,YAAY,aAAa,cAAc,EAAE;CAC/C,MAAM,SAAS,aAAa;CAC5B,MAAM,QAAQ,aAAa;CAC3B,YAAY,WAAW,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC;AAG3D,KAAI,cAAc,EAChB,QAAO,IAAI,QAAuB,CAACC,cACjC,sBAAsB,CAAC,MAAM;EAC3BA,UAAQ,MAAM;CACf,EAAC;KAGJ,QAAO,IAAI,QAAuB,CAACA,WAAS,WAAW;EACrD,MAAM,gBAAgB,MAAM;GAC1B,aAAa,EAAE;AACf,OAAI,QAAQ;IACV,OAAO,oBAAoB,CAAC,KAAK,CAAC,EAAE,cAAc;IAClD,OAAO,IAAI,MAAM,OAAO,QAAQ;GACjC,OACC,uBAAO,IAAI,MAAM,CAAC,SAAS,CAAC,EAAE;EAEjC;AAED,MAAI,QACF,OAAO,iBAAiB,CAAC,KAAK,CAAC,EAAE,cAAc;EAEjD,MAAM,IAAI,WAAW,MAAM;GACzB,QAAQ,oBAAoB,CAAC,KAAK,CAAC,EAAE,cAAc;AACnD,OAAI,QAAQ,SAAS;IACnB,OAAO,IAAI,MAAM,OAAO,QAAQ;AAChC;GACD;GACDA,UAAQ,MAAM;EACf,GAAE,UAAU;CACd;AAEJ;;;;;;;;;;;AAYD,MAAa,aAAa,OAAOC,WAA0BC,gBAA0B,QAAQ;AAC3F,QAAO,WAAW,EAChB,MAAM,MAAM,cAAc;AAE7B;;;;;;;;;;;;;;;;;;;ACpGD,MAAaC,sBAAoB,CAAC,GAAG,MAAM;CACvC,MAAM,IAAI,6BAA6B,OAAO,KAAK,EAAE,EAAE,OAAO,KAAK,EAAE,CAAC;AACtE,QAAO;AACV;;;;;;;;;AAyDD,MAAaC,kBAAgB,CAAC,GAAG,GAAG,KAAM,mBAAoB;AAC1D,KAAI,CAAC,MAAM,QAAQ,EAAE,CACjB,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAC/C,KAAI,CAAC,MAAM,QAAQ,EAAE,CACjB,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;CAC/C,MAAM,IAAIC,oBAAkB,GAAG,GAAG,OAAO,GAAG;AAC5C,KAAI,CAAC,EAAE,QACH,OAAM,IAAI,MAAM,CAAC,6CAA6C,CAAC;CACnE,MAAM,UAAU,CAAC,QAAQ;AACrB,MAAI,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,CACnB,QAAO,OAAO,SAAS,IAAI,MAAM,EAAE,CAAC;MAGpC,OAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;CAChD;CACD,MAAM,KAAK;EACP,GAAG;EACH,OAAOC,gBAAc,EAAE,OAAO,QAAQ;EACtC,SAASA,gBAAc,EAAE,SAAS,QAAQ;EAC1C,SAAS,EAAE,QAAQ,IAAI,OAAK,QAAQ,EAAE,CAAC;EACvC,SAAS,EAAE,QAAQ,IAAI,WAAS;AAC5B,UAAO;IAAC,MAAM;IAAI,QAAQ,MAAM,GAAG;IAAE,MAAM;GAAG;EACjD,EAAC;CACL;AACD,QAAO;AACV;;;;;;;;;AASD,MAAaD,sBAAoB,CAAC,GAAG,GAAG,kBAAkB,OAAO,KAAK,mBAAmB;CACrF,MAAM,CAAE;CACR,MAAM,CAAE;CACR,MAAM,WAAW,OAAO,QAAQ,EAAE;CAClC,MAAM,WAAW,OAAO,QAAQ,EAAE;CAClC,MAAM,8BAAc,IAAI;CACxB,MAAM,UAAU,CAAE;CAClB,MAAM,QAAQ,CAAE;CAChB,MAAM,WAAW,CAAE;CACnB,MAAM,UAAU,CAAE;CAClB,MAAM,UAAU,MAAM,QAAQ,EAAE;CAChC,MAAM,UAAU,IAAI;CACpB,IAAI,aAAa;AAEjB,MAAK,MAAM,SAAS,UAAU;EAC1B,MAAM,YAAY,UAAU,CAAC,CAAC,EAAE,MAAM,IAAI,GAAG,MAAM;EACnD,MAAM,SAAS,MAAM;EACrB,MAAM,SAAS,EAAE,MAAM;EACvB,YAAY,IAAI,MAAM,GAAG;AACzB,MAAI,WAAW,QAAW;GAEtB,aAAa;AACb,OAAI,mBAAmB,CAAC,SAAS;IAE7B,QAAQ,aAAa;IACrB,QAAQ,KAAK;KAAC,CAAC,MAAM,CAAC;KAAE;KAAW;IAAO,EAAC;GAC9C,OACI;IAED,QAAQ,KAAK,UAAU;IACvB,QAAQ,KAAK;KAAC,CAAC,GAAG,CAAC;KAAE;KAAW;IAAO,EAAC;GAC3C;AACD;EACH;AACD,MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,EAAE;GAC5B,MAAM,IAAIA,oBAAkB,QAAQ,QAAQ,iBAAiB,GAAG;AAChE,OAAI,EAAE,YACF,aAAa;GACjB,SAAS,aAAa;GACtB,MAAM,eAAe,EAAE,QAAQ,IAAI,SAAO;AAAE,WAAO;KAAC,IAAI;KAAI,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI;KAAI,IAAI;IAAG;GAAG,EAAC;GACjG,QAAQ,KAAK,GAAG,aAAa;EAChC,WAEO,CAAC,GAAG,QAAQ,OAAO,EAAE;GACrB,QAAQ,aAAa;GACrB,aAAa;GACb,QAAQ,KAAK;IAAC,CAAC,MAAM,CAAC;IAAE;IAAW;GAAO,EAAC;EAC9C;CAER;AAED,KAAI,CAAC,mBAAmB,QACpB,MAAK,MAAM,SAAS,UAAU;EAC1B,MAAM,MAAM,UAAU,CAAC,CAAC,EAAE,MAAM,IAAI,GAAG,MAAM;AAC7C,MAAI,YAAY,IAAI,MAAM,GAAG,CACzB;EACJ,MAAM,OAAO,MAAM;EACnB,aAAa;EACb,QAAQ,KAAK;GAAC,CAAC,GAAG,CAAC;GAAE;GAAK,MAAM;EAAG,EAAC;CACvC;AAEL,QAAO;EACH;EAAS;EAAO;EAAS;EAAU;EAAY;EAAS;CAC3D;AACJ;;;;AC9KD,MAAaE,oBAAkB,CAAC,WAAW;CACvC,MAAM,UAAU,CAAE;AAClB,MAAK,MAAM,SAAS,QAAQ;EACxB,MAAM,QAAS,OAAQ;AACvB,MAAI,2BAA2B,MAAM,EACjC,QAAQ,KAAK,CAAC,OAAO,KAAM,EAAC;CAEnC;AACD,QAAO,OAAO,YAAY,QAAQ;AACrC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACyCD,MAAaC,qBAAmB,CAAC,QAAQ,gBAAgB;CACrD,MAAM,UAAU,OAAO,QAAQ,OAAO;CACtC,MAAM,SAAS,QAAQ,IAAI,CAAC,CAAC,aAAa,iBAAiB,EAAE,UAAU,CACnE,aACA,YAAY;EAAE,OAAO;EAAkB,OAAO;EAAa;EAAO,MAAM;CAAa,EAAC,AACzF,EAAC;AACF,QAAO,OAAO,YAAY,OAAO;AACpC;;;;;;;;;;;;AClDD,SAAgBC,cAAY,OAAO;AAC/B,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzB,QAAO;AACX,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzB,QAAO;AACX,KAAI,OAAO,UAAU,CAAC,MAAM,CAAC,CACzB,QAAO;AACX,KAAI,OAAO,UAAU,CAAC,OAAO,CAAC,CAC1B,QAAO;AACX,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC2DD,UAAiBC,iBAAe,MAAM,UAAU,CAAE,GAAE;CAChD,YAAY,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;CACxC,MAAM,SAAS,QAAQ,UAAU,CAAC,IAAI,CAAC;CACvC,MAAM,gBAAgB,CAAC,MAAM;AACzB,MAAI,WAAW,CAAC,IAAI,CAAC,CACjB,QAAO,CAAC,MAAMC,cAAY,EAAE,AAAC;WACxB,WAAW,CAAC,MAAM,CAAC,IAAIA,cAAY,EAAE,CAC1C,QAAO,CAAC,MAAM,IAAK;WACd,WAAW,CAAC,QAAQ,CAAC,IAAI,CAACA,cAAY,EAAE,CAC7C,QAAO,CAAC,MAAM,KAAM;AACxB,SAAO,CAAC,OAAOA,cAAY,EAAE,AAAC;CACjC;AACD,KAAI,MAAM,QAAQ,KAAK,CAEnB,MAAK,MAAM,CAAC,OAAO,QAAQ,IAAI,KAAK,SAAS,EAAE;EAC3C,MAAM,IAAI,cAAc,QAAQ;AAChC,MAAI,EAAE,IACF,MAAM;GAAE,MAAM,MAAM,UAAU;GAAE,aAAa;GAAS,WAAW,EAAE,KAAK,UAAU;EAAW;CAGpG;UAEI,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;EAC/B,MAAM,cAAe,CAAC,OAAO,CAAC,IAAI,OAAQ,KAAK,SAAS,GAAG,OAAO,QAAQ,KAAK;AAC/E,OAAK,MAAM,CAAC,MAAM,MAAM,IAAI,aAAa;GAErC,MAAM,IAAI,cAAc,MAAM;AAC9B,OAAI,EAAE,IACF,MAAM;IAAQ;IAAM,aAAa;IAAO,WAAW,EAAE,KAAK,QAAQ;GAAW;EAEpF;CACJ;AACJ;AACD,UAAiB,wBAAwB,MAAM,UAAU,CAAE,GAAE,YAAY,CAAE,GAAE;AACzE,MAAK,MAAM,KAAKD,iBAAe,MAAM,QAAQ,EAAE;EAE3C,MAAM;GAAE,GAAG;GAAG,WAAW,CAAC,GAAG,SAAU;EAAE;EACzC,OAAO,wBAAwB,EAAE,aAAa,SAAS,CAAC,GAAG,WAAW,EAAE,IAAK,EAAC;CACjF;AACJ;;;;AChHD,MAAME,eAAa,CAAC,QAAQ,cAAc;AACtC,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACjD,KAAI,WAAW,KACX,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;AAC5C,KAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAC1B,OAAM,IAAI,MAAM,CAAC,sCAAsC,EAAE,OAAO,OAAO,CAAC,CAAC;AAC7E,KAAI,WAAW;EACX,MAAM,UAAU,CAAE;AAClB,OAAK,MAAM,SAAS,QAAQ;GACxB,MAAM,QAAQ,OAAO;AACrB,OAAI,2BAA2B,MAAM,EACjC,QAAQ,KAAK,CAAC,OAAO,KAAM,EAAC;EAEnC;AACD,SAAO;CACV,MAEG,QAAO,OAAO,QAAQ,OAAO;AAEpC;;;;;;;;;;;;;;AAcD,UAAiBC,cAAY,GAAG,GAAG,UAAU,CAAE,GAAE;AAC7C,KAAI,OAAO,MAAM,CAAC,SAAS,CAAC,EAAE;EAC1B,MAAM;GACF,MAAM,QAAQ,cAAc,EAAE;GAC9B,OAAO;GACP,OAAO,CAAC,KAAK,CAAC;EACjB;AACD;CACH;AACD,KAAI,OAAO,MAAM,CAAC,SAAS,CAAC,EAAE;EAC1B,MAAM;GAAE,MAAM,QAAQ,cAAc,EAAE;GAAE,UAAU;GAAG,OAAO;GAAW,OAAO,CAAC,OAAO,CAAC;EAAE;AACzF;CACH;CACD,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAM,6BAA6B,QAAQ,8BAA8B;CACzE,MAAM,aAAa,QAAQ,cAAc,EAAE;CAC3C,MAAM,cAAc,QAAQ,eAAe;CAC3C,MAAM,KAAK,QAAQ,MAAM;CACzB,MAAM,sBAAsB,QAAQ,uBAAuB;CAC3D,MAAM,iBAAiB,QAAQ,kBAAkB;AAEjD,KAAI,YAAY,EAAE,IAAI,YAAY,EAAE,EAAE;AAClC,MAAI,MAAM,GACN,MAAM;GAAE,MAAM;GAAY,OAAO;GAAG,UAAU;GAAG,OAAO,CAAC,MAAM,CAAC;EAAE;AACtE;CACH;AACD,KAAI,YAAY,EAAE,EAAE;EAChB,MAAM;GAAE,MAAM;GAAY,OAAO;GAAG,UAAU;GAAG,OAAO,CAAC,MAAM,CAAC;EAAE;AAClE;CACH;CACD,MAAM,WAAWD,aAAW,GAAG,YAAY;CAC3C,MAAM,+BAAe,IAAI;AACzB,MAAK,MAAM,CAAC,KAAK,OAAO,IAAI,UAAU;EAClC,aAAa,IAAI,IAAI;EACrB,MAAM,YAAY,OAAO;EACzB,MAAM,gBAAgB,EAAE;AAExB,MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,WAAW,KACzC,KAAI,UAEA,KAAI,kBAAkB,OAClB,OAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,IAAI,aAAa,CAAC;OAErE;GACD,MAAM,MAAM,CAAC,GAAGC,cAAY,QAAQ,eAAe;IAC3C,GAAG;IACH,YAAY,aAAa,MAAM,CAAC,CAAC,CAAC;GACrC,EAAC,AAAC;AACP,OAAI,IAAI,SAAS,GAAG;AAChB,SAAK,MAAM,KAAK,KACZ,MAAM;AACV,QAAI,gBACA,MAAM;KAAE,MAAM,aAAa;KAAK,OAAO,EAAE;KAAM,UAAU;KAAQ,OAAO,CAAC,MAAM,CAAC;IAAE;GAEzF;EACJ;OAEA;AACD,OAAI,UACA;GAEJ,MAAM;IAAE,MAAM,aAAa;IAAK,OAAO;IAAW,UAAU;IAAQ,OAAO,CAAC,OAAO,CAAC;GAAE;EACzF;OAEA;GACD,MAAM,UAAU,aAAa;AAC7B,OAAI,WAEA;QAAI,kBAAkB,UAAa,4BAE/B,MAAM;KAAE,MAAM;KAAS,UAAU;KAAQ,OAAO;KAAW,OAAO,CAAC,OAAO,CAAC;IAAE;aAGzE,CAAC,GAAG,QAAQ,eAAe,QAAQ,EAEnC,MAAM;KAAE,MAAM;KAAS,UAAU;KAAQ,OAAO;KAAe,OAAO,CAAC,MAAM,CAAC;IAAE;GAEvF,OAEA;AAED,QAAI,UACA;IACJ,MAAM;KAAE,MAAM;KAAS,UAAU;KAAQ,OAAO;KAAW,OAAO,CAAC,OAAO,CAAC;IAAE;GAChF;EACJ;CACJ;AACD,KAAI,qBAAqB;EACrB,MAAM,WAAWD,aAAW,GAAG,YAAY;AAC3C,OAAK,MAAM,CAAC,KAAK,OAAO,IAAI,UAAU;AAClC,OAAI,aAAa,IAAI,IAAI,CACrB;GAGJ,MAAM;IAAE,MAAM,aAAa;IAAK,UAAU;IAAW,OAAO;IAAQ,OAAO,CAAC,KAAK,CAAC;GAAE;EACvF;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwDD,MAAaE,iBAAe,CAAC,QAAQ,MAAM,OAAO,mBAAmB,UAAU;AAC3E,KAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;AACnD,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CACxB,OAAM,IAAI,MAAM,CAAC,0CAA0C,EAAE,OAAO,MAAM;AAC9E,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AACrD,KAAI,WAAW,KACX,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;CAChD,MAAM,QAAQ,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;CAC7B,MAAM,IAAIC,mBAAiB,QAAQ,OAAO,OAAO,iBAAiB;AAClE,QAAO;AACV;AACD,MAAMA,qBAAmB,CAAC,GAAG,OAAO,OAAO,qBAAqB;AAC5D,KAAI,MAAM,WAAW,GAAG;AAEpB,MAAI,iBACA,QAAO;AACX,MAAI,MAAM,QAAQ,EAAE,IAAI,CAAC,MAAM,QAAQ,MAAM,CACzC,OAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,KAAK,UAAU,MAAM,CAAC,uCAAuC,CAAC;AACjH,MAAI,CAAC,MAAM,QAAQ,EAAE,IAAI,MAAM,QAAQ,MAAM,CACzC,OAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,KAAK,UAAU,MAAM,CAAC,uCAAuC,CAAC;AACnH,MAAI,OAAO,MAAM,OAAO,MACpB,OAAM,IAAI,MAAM,CAAC,8BAA8B,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,MAAM,uCAAuC,CAAC;AAEzH,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,QAAQ,EAAE,EAAE;GAC5C,MAAM,IAAIC,oBAAkB,GAAG,MAAM;AACrC,OAAI,EAAE,EAAE,SAAS,EACb,OAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;AAEnE,OAAI,EAAE,EAAE,SAAS,EACb,OAAM,IAAI,MAAM,CAAC,iCAAiC,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE;EAE1E;AACD,SAAO;CACV;CACD,MAAM,QAAQ,MAAM,OAAO;AAC3B,KAAI,CAAC,MACD,QAAO;CACX,MAAM,QAAQ,UAAU,MAAM;AAC9B,KAAI,SAAS,MAAM,QAAQ,EAAE,EAAE;EAC3B,MAAM,QAAQ,OAAO,SAAS,MAAM;AACpC,MAAI,SAAS,EAAE,UAAU,CAAC,iBACtB,OAAM,IAAI,MAAM,CAAC,YAAY,EAAE,MAAM,UAAU,CAAC,sCAAsC,EAAE,EAAE,OAAO,UAAU,CAAC,2CAA2C,CAAC;EAC5J,MAAM,OAAO,CAAC,GAAG,CAAE;EACnB,KAAK,SAASD,mBAAiB,KAAK,QAAQ,OAAO,OAAO,iBAAiB;AAC3E,SAAO;CACV,WACQ,SAAS,GAAG;EACjB,MAAM,OAAO,EAAE,GAAG,EAAG;EACrB,KAAK,SAASA,mBAAiB,KAAK,QAAQ,OAAO,OAAO,iBAAiB;AAC3E,SAAO;CACV,MAEG,OAAM,IAAI,MAAM,CAAC,KAAK,EAAE,MAAM,kBAAkB,CAAC;AAExD;;;;;;;;;;;;;;;;;AAiBD,MAAaE,aAAW,CAAC,QAAQ,SAAS;AACtC,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CACxB,OAAM,IAAI,MAAM,CAAC,yCAAyC,EAAE,OAAO,KAAK,CAAC,CAAC;AAC9E,KAAI,KAAK,WAAW,EAChB,OAAM,IAAI,MAAM,CAAC,4BAA4B,CAAC;AAClD,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACjD,KAAI,WAAW,KACX,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;CAC5C,MAAM,QAAQ,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;CAC7B,MAAM,IAAIC,eAAa,QAAQ,MAAM;AACrC,QAAO;AACV;AACD,MAAMA,iBAAe,CAAC,QAAQ,UAAU;AACpC,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACjD,KAAI,MAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,gBAAgB,CAAC;CACtC,MAAM,QAAQ,MAAM,OAAO;AAC3B,KAAI,CAAC,MACD,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;CACjD,MAAM,QAAQ,UAAU,MAAM;AAC9B,KAAI,SAAS,MAAM,QAAQ,OAAO,EAAE;EAChC,MAAM,QAAQ,OAAO,SAAS,MAAM;AAEpC,MAAI,OAAO,OAAO,WAAW,CAAC,SAAS,CAAC,CACpC,QAAO;GAAE,SAAS;GAAO,OAAO,CAAC,OAAO,EAAE,MAAM,0BAA0B,EAAE,OAAO,QAAQ;EAAE;AAEjG,MAAI,MAAM,WAAW,EACjB,QAAO;GAAE,OAAO,OAAO;GAAQ,SAAS;EAAM;MAG9C,QAAOA,eAAa,OAAO,QAAQ,MAAM;CAEhD,WACQ,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,SAAS,OAE5C,KAAI,MAAM,WAAW,EACjB,QAAO;EAAE,OAAO,OAAO;EAAQ,SAAS;CAAM;KAG9C,QAAOA,eAAa,OAAO,QAAQ,MAAM;KAI7C,QAAO;EAAE,SAAS;EAAO,OAAO,CAAC,MAAM,EAAE,MAAM,WAAW,CAAC;CAAE;AAEpE;;;;;;;;;;;;;;;;;;;;AA4DD,UAAiBC,kBAAgB,GAAG,aAAa,OAAO,WAAW,OAAO,kBAAkB,SAAS,EAAE,EAAE;AACrG,KAAI,MAAM,KACN;AACJ,KAAI,MAAM,OACN;CACJ,OAAOC,sBAAoB,GAAG,QAAQ,YAAY,SAAS;AAC9D;AACD,UAAUA,sBAAoB,GAAG,QAAQ,aAAa,OAAO,UAAU;AACnE,KAAI,YAAY,EACZ;AACJ,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACrB;AACJ,MAAK,MAAM,WAAW,OAAO,QAAQ,EAAE,EAAE;EACrC,MAAM,OAAO,OAAO,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,QAAQ;EAC9D,MAAM,QAAQ,QAAQ;EACtB,MAAM,OAAQ,OAAO,UAAU,CAAC,MAAM,CAAC;AACvC,MAAI,cAAc,QAAQ,CAAC,YACvB,MAAM;GAAE,MAAM;GAAK;EAAO;EAE9B,OAAOA,sBAAoB,OAAO,KAAK,YAAY,WAAW,EAAE;CACnE;AACJ;;;;;;;;;;;;;;;;;;;;ACjXD,MAAaC,kBAAgB,CAAC,QAAQ,gBAAgB;CAClD,MAAM,oBAAoB,CAAE;AAC5B,MAAK,MAAM,WAAW,OAAO,QAAQ,OAAO,EAAE;EAC1C,MAAM,MAAM,YAAY,QAAQ,GAAG;EACnC,kBAAkB,OAAO,QAAQ;CACpC;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;ACVD,MAAa,oBAAoB,CAACC,GAAWC,MAAc;CACzD,MAAM,IAAI,6BAA6B,OAAO,KAAK,EAAE,EAAE,OAAO,KAAK,EAAE,CAAC;AACtE,QAAO;AACR;;;;;;;;;;;;;;;;;;;;AAqBD,MAAa,0BAA0B,CAACD,GAAWC,MAAc;CAC/D,MAAM,IAAI,kBAAkB,GAAG,GAAG,KAAK;AACvC,KAAI,OAAO,QAAQ,EAAE,MAAM,CAAC,SAAS,EAAG,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AACnF,KAAI,OAAO,QAAQ,EAAE,QAAQ,CAAC,SAAS,EAAG,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;CAErF,MAAM,SAAS,sBAAsB,GAAG,EAAE;AAC1C,QAAO;AACR;AAED,MAAM,wBAAwB,CAA+BC,GAA2BD,MAAkD;CACxI,MAAM,SAAS,CAAE;AAEjB,KAAI,EAAE,QACJ,QAAO;AAGT,MAAK,MAAM,SAAS,OAAO,QAAQ,EAAE,QAAQ,EAC1C,OAAmB,MAAO,MAAQ,MAAO;AAG5C,MAAK,MAAM,SAAS,OAAO,QAAQ,EAAE,MAAM,EACxC,OAAmB,MAAO,MAAQ,MAAO;AAI5C,MAAK,MAAM,cAAc,OAAO,QAAQ,EAAE,SAAS,EAAE;EACnD,MAAM,cAAc,WAAY;AAChC,MAAI,YAAY,YAEb,OAAmB,WAAY,MAAQ,sBAAsB,aAAa,EAAG,WAAY,IAAM;CAEnG;AACD,QAAO;AACR;;;;;;;;;AAUD,MAAa,gBAAgB,CAASE,GAAaC,GAAaC,KAAsB,mBAAqD;AACzI,KAAI,CAAC,MAAM,QAAQ,EAAE,CAAE,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAClE,KAAI,CAAC,MAAM,QAAQ,EAAE,CAAE,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;CAClE,MAAM,IAAI,kBAAkB,GAAG,GAAG,OAAO,GAAG;AAC5C,KAAI,CAAC,EAAE,QAAS,OAAM,IAAI,MAAM,CAAC,6CAA6C,CAAC;CAE/E,MAAM,UAAU,CAACC,QAAwB;AACvC,MAAI,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,CACrB,QAAO,OAAO,SAAS,IAAI,MAAM,EAAE,CAAC;MAC/B,OAAM,IAAI,MAAM,CAAC,gBAAgB,EAAG,IAAK,CAAC,CAAC;CACnD;CACD,MAAMC,KAA+B;EACnC,GAAG;EACH,OAAOC,gBAAc,EAAE,OAAO,QAAQ;EACtC,SAASA,gBAAc,EAAE,SAAS,QAAQ;EAC1C,SAAS,EAAE,QAAQ,IAAI,OAAK,QAAQ,EAAE,CAAC;EACvC,SAAS,EAAE,QAAQ,IAAI,WAAS;AAC9B,UAAO;IAAE,MAAO;IAAK,QAAQ,MAAO,GAAI;IAAE,MAAO;GAAK;EACvD,EAAC;CACH;AACD,QAAO;AACR;;;;;;;;;AAUD,MAAa,oBAAoB,CAAIC,GAAkBC,GAAkB,kBAAkB,OAAOC,KAAiB,mBAA6C;CAC9J,MAAM,CAAE;CACR,MAAM,CAAE;CACR,MAAM,WAAW,OAAO,QAAQ,EAAE;CAClC,MAAM,WAAW,OAAO,QAAQ,EAAE;CAElC,MAAM,8BAAc,IAAI;CACxB,MAAM,UAAU,CAAE;CAClB,MAAM,QAAQ,CAAE;CAChB,MAAM,WAAW,CAAE;CACnB,MAAMC,UAAoB,CAAE;CAC5B,MAAM,UAAU,MAAM,QAAQ,EAAE;CAEhC,MAAM,UAAU,IAAI;CACpB,IAAI,aAAa;AAGjB,MAAK,MAAM,SAAS,UAAU;EAC5B,MAAM,YAAY,UAAU,CAAC,CAAC,EAAG,MAAO,IAAM,GAAG,MAAO;EACxD,MAAM,SAAS,MAAO;EACtB,MAAM,SAAS,EAAG,MAAO;EACzB,YAAY,IAAI,MAAO,GAAI;AAE3B,MAAI,WAAW,QAAW;GAExB,aAAa;AACb,OAAI,mBAAmB,CAAC,SAAS;IAE/B,QAAS,aAAc;IACvB,QAAQ,KAAK;KAAE,CAAC,MAAM,CAAC;KAAE;KAAW;IAAQ,EAAC;GAC9C,OAAM;IAEL,QAAQ,KAAK,UAAU;IACvB,QAAQ,KAAK;KAAE,CAAC,GAAG,CAAC;KAAE;KAAW;IAAQ,EAAC;GAC3C;AACD;EACD;AAED,MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,EAAE;GAC9B,MAAM,IAAI,kBAAkB,QAAQ,QAAkB,iBAAiB,GAAG;AAC1E,OAAI,EAAE,YAAY,aAAa;GAC/B,SAAU,aAAc;GACxB,MAAM,eAAe,EAAE,QAAQ,IAAI,SAAO;AAAE,WAAO;KAAE,IAAK;KAAK,YAAY,CAAC,CAAC,CAAC,GAAG,IAAK;KAAK,IAAK;IAAK;GAAE,EAAC;GACxG,QAAQ,KAAK,GAAG,aAAa;EAC9B,WACK,CAAC,GAAG,QAAa,OAAY,EAAE;GACjC,QAAS,aAAc;GACvB,aAAa;GACb,QAAQ,KAAK;IAAE,CAAC,MAAM,CAAC;IAAE;IAAW;GAAQ,EAAC;EAC9C;CAEJ;AAGD,KAAI,CAAC,mBAAmB,QACtB,MAAK,MAAM,SAAS,UAAU;EAC5B,MAAM,MAAM,UAAU,CAAC,CAAC,EAAG,MAAO,IAAM,GAAG,MAAO;AAElD,MAAI,YAAY,IAAI,MAAO,GAAI,CAAE;EACjC,MAAO,OAAQ,MAAO;EACtB,aAAa;EACb,QAAQ,KAAK;GAAE,CAAC,GAAG,CAAC;GAAE;GAAK,MAAO;EAAK,EAAC;CACzC;AAEH,QAAO;EACL;EAAS;EAAO;EAAS;EAAU;EAAY;EAAS;CACzD;AACF;;;;ACvLD,MAAa,kBAAkB,CAAmBC,WAAc;CAE9D,MAAMC,UAAyC,CAAE;AACjD,MAAK,MAAM,SAAS,QAAQ;EAC1B,MAAM,QAAS,OAAS;AACxB,MAAI,2BAA2B,MAAiB,EAC9C,QAAQ,KAAK,CAAE,OAAO,KAAO,EAAC;CAEjC;AACD,QAAO,OAAO,YAAY,QAAQ;AACnC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACyCD,MAAa,mBAAmB,CAI9BC,QACAC,gBAEkD;CAElD,MAAM,UAAU,OAAO,QAAQ,OAAO;CACtC,MAAM,SAAS,QAAQ,IAAI,CAAC,CAAE,aAAa,iBAAkB,EAAE,UAAU,CACvE,aACA,YAAY;EAAE,OAAO;EAAkB,OAAO;EAAa;EAAO,MAAM;CAAa,EAAC,AACvF,EAAC;AACF,QAAO,OAAO,YAAY,OAAO;AAClC;;;;;;;;;;;;;;;;;;;;;;;AA+BD,SAAgB,kBAAkBC,MAAcC,QAA2D;CACzG,MAAM,UAAU,OAAO,QAAQ,KAAK;AACpC,MAAK,MAAM,SAAS,QAClB,KAAI,MAAO,MAAO,QAAQ;EACxB,MAAM,IAAI,OAAQ,MAAO;EACzB,MAAO,KAAO,OAAO,MAAM,CAAC,MAAM,CAAC,GACjC,kBAAkB,MAAO,IAAe,EAAE,GAC1C,EAAE,MAAO,IAAK,KAAK;CACtB;AAEH,QAAO,OAAO,YAAY,QAAQ;AACnC;;;;;;;;;AC7ED,SAAgB,mBAAmBC,SAAiC;AAClE,KAAI,QAAQ,WAAW,EAAG,QAAO,CAAC,OAAO,CAAC;CAC1C,IAAI,IAAI,EAAE;AACV,MAAK,MAAM,CAAE,OAAO,MAAO,IAAI,QAAQ,SAAS,EAAE;EAChD,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,MAAM;EACvB,KAAK,MAAM,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,UAAU,MAAM,UAAU,GAAG,CAAC,EAAE,CAAC;CACjE;AACD,QAAO;AACR;;;;;;;;;;;AAYD,MAAa,yBAAyB,CACpCC,MACA,SAAS,GACTC,UAA0C,CAAE,MACjC;CACX,YAAY,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;CACxC,MAAM,cAAc,QAAQ,QAAQ,CAAC,IAAI,CAAC;CAC1C,MAAM,QAAQ,oBAAoB,MAAM,YAAY;CACpD,MAAM,IAAI,GAAI,CAAC,EAAE,CAAC,CAAC,OAAO,OAAO,CAAE,SAAS,EAAG,MAAM,KAAM,QAAQ,EAAG,KAAK,UAAU,MAAM,UAAU,EAAG;CACxG,MAAM,kBAAkB,CAAE,GAAG,eAAe,MAAM,QAAQ,AAAE;AAC5D,QAAO,gBAAgB,SAAS,IAC9B,IACA,CAAC,EAAE,CAAC,GACJ,gBAAgB,IAAI,CAAC,MAAM,uBAAuB,EAAE,WAAW,SAAS,GAAG;EAAE,GAAG;EAAS,MAAM,EAAE;CAAM,EAAC,CAAC,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,GAClH;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CD,UAAiB,eACfC,MACAD,UAA0C,CAAE,GACb;CAC/B,YAAY,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC;CAExC,MAAM,SAAS,QAAQ,UAAU,CAAC,IAAI,CAAC;CAEvC,MAAM,gBAAgB,CAACE,MAAsD;AAC3E,MAAI,WAAW,CAAC,IAAI,CAAC,CAAE,QAAO,CAAE,MAAM,YAAY,EAAE,AAAE;WAC7C,WAAW,CAAC,MAAM,CAAC,IAAI,YAAY,EAAE,CAAE,QAAO,CAAE,MAAM,IAAM;WAC5D,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,EAAE,CAAE,QAAO,CAAE,MAAM,KAAO;AACzE,SAAO,CAAE,OAAO,YAAY,EAAE,AAAE;CACjC;AAED,KAAI,MAAM,QAAQ,KAAK,CAErB,MAAK,MAAM,CAAE,OAAO,QAAS,IAAI,KAAK,SAAS,EAAE;EAC/C,MAAM,IAAI,cAAc,QAAQ;AAChC,MAAI,EAAG,IACL,MAAM;GAAE,MAAM,MAAM,UAAU;GAAE,aAAa;GAAS,WAAW,EAAG,KAAM,UAAU;EAAW;CAGlG;UACQ,OAAO,SAAS,CAAC,MAAM,CAAC,EAAE;EACnC,MAAM,cAAe,CAAC,OAAO,CAAC,IAAI,OAAS,KAA8B,SAAS,GAAG,OAAO,QAAQ,KAAK;AACzG,OAAK,MAAM,CAAE,MAAM,MAAO,IAAI,aAAa;GAEzC,MAAM,IAAI,cAAc,MAAM;AAC9B,OAAI,EAAG,IACL,MAAM;IAAQ;IAAM,aAAa;IAAO,WAAW,EAAG,KAAM,QAAQ;GAAW;EAElF;CACF;AACF;AAED,UAAiBC,0BAA0CF,MAASD,UAA0C,CAAE,GAAEI,YAAsB,CAAE,GAA8C;AACtL,MAAK,MAAM,KAAK,eAAe,MAAM,QAAQ,EAAE;EAE7C,MAAM;GAAE,GAAG;GAAG,WAAW,CAAE,GAAG,SAAW;EAAE;EAC3C,OAAOD,0BAAwB,EAAE,aAAa,SAAS,CAAE,GAAG,WAAW,EAAE,IAAM,EAAC;CACjF;AACF;;;;;;;AAQD,SAAS,uBACPE,MACAJ,MACyB;AACzB,MAAK,MAAM,KAAK,eAAe,KAAK,CAClC,KAAI,EAAE,SAAS,KAAM,QAAO;AAE/B;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BD,SAAgB,qBACdK,MACAL,MACAM,UAAoB,CAAE,GACT;CACb,MAAM,QAAQ,CAAE,GAAG,uBAAuB,MAAM,MAAM,QAAQ,AAAE;AAChE,KAAI,MAAM,WAAW,EAAG,OAAM,IAAI,MAAM,CAAC,sBAAsB,EAAG,KAAM,CAAC,CAAC;AAC1E,QAAO,MAAM,GAAG,GAAG;AACpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCD,UAAiB,uBACfD,MACAL,MACAM,UAAoB,CAAE,GACc;CACpC,YACE,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,EAC3B,cAAc,MAAM,CAAC,IAAI,CAAC,CAAC,CAC5B;CACD,MAAM,YAAY,QAAQ,aAAa,CAAC,CAAC,CAAC;CAC1C,MAAM,YAAY,KAAK,MAAM,UAAU;CAEvC,MAAMH,YAAsB,CAAE;AAC9B,MAAK,MAAM,KAAK,WAAW;EACzB,MAAM,QAAQ,uBAAuB,GAAG,KAAK;AAC7C,MAAI,CAAC,OAAO;GACV,MAAM;IAAE,MAAM;IAAG,aAAa;IAAW,WAAW;IAAW;GAAW;AAC1E;EACD;EACD,OAAO,MAAM;EACb,MAAM;GAAE,GAAG;GAAO,WAAW,CAAE,GAAG,SAAW;EAAE;EAC/C,UAAU,KAAK,EAAE;CAClB;AACF;;;;;;;;AAUD,SAAS,oBAAsCH,MAAS,cAAc,EAAE,EAAe;AACrF,KAAI,CAAC,IAAI,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,CAAC,WAAW,CAAC,IAAI,KAAM,QAAO;AAC3E,KAAI,CAAC,IAAI,CAAC,IAAI,KACZ,QAAO;EAAE,MAAM,KAAK;EAAgB,WAAW;EAAM,aAAa;CAAM;AAE1E,QAAO;EAAE,MAAM;EAAa,WAAW;EAAM,aAAa;CAAM;AACjE;;;;AChQD,SAAgB,aAAiC,GAAG,GAAa;AAC/D,QAAO,OAAO,OAAO,CAAE,GAAE,GAAG,EAAE;AAC/B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACED,MAAa,gBAAgB,CAAIO,QAA6CC,eAA4C,CAAC,KAAK,CAAC,KAAwB;CACvJ,MAAMC,eAAkC,CAAE;AAC1C,MAAK,MAAM,SAAS,OAAO,QAAQ,OAAO,EAAE;EAC1C,MAAM,WAAW,OAAO,SAAS,MAAO,GAAI;AAC5C,MAAI,OAAO,MAAM,SAAS,CACxB,SAAQ,cAAR;GACE,KAAK,CAAC,KAAK,CAAC,CACV,OAAM,IAAI,UAAU,CAAC,oBAAoB,EAAG,MAAO,GAAK,eAAe,CAAC;GAE1E,KAAK,CAAC,MAAM,CAAC,CACX;GAEF,KAAK,CAAC,IAAI,CAAC,EAAE;IAEV,aAAsB,MAAO,MAAQ,MAAO;AAC7C;GACD;GACD,QACE,OAAM,IAAI,MAAM,CAAC,4DAA4D,CAAC;EAEjF;EAEH,aAAc,YAAa,MAAO;CACnC;AACD,QAAO;AACR;;;;ACYD,MAAM,aAAa,CAAgCC,QAAWC,cAAuB;AACnF,KAAI,WAAW,OAAW,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACvE,KAAI,WAAW,KAAM,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;AAC7D,KAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,sCAAsC,EAAG,OAAO,OAAQ,CAAC,CAAC;AAC3G,KAAI,WAAW;EACb,MAAMC,UAAyC,CAAE;AACjD,OAAK,MAAM,SAAS,QAAQ;GAC1B,MAAM,QAAS,OAAgB;AAC/B,OAAI,2BAA2B,MAAiB,EAC9C,QAAQ,KAAK,CAAE,OAAO,KAAO,EAAC;EAEjC;AACD,SAAO;CACR,MACC,QAAO,OAAO,QAAQ,OAAO;AAEhC;;;;;;;;;;;;;;AAeD,UAAiB,YAA2CC,GAAMC,GAAeC,UAA0C,CAAE,GAAkC;AAC7J,KAAI,OAAO,MAAM,CAAC,SAAS,CAAC,EAAE;EAC5B,MAAM;GACJ,MAAM,QAAQ,cAAc,EAAE;GAC9B,OAAO;GACP,OAAO,CAAC,KAAK,CAAC;EACf;AACD;CACD;AACD,KAAI,OAAO,MAAM,CAAC,SAAS,CAAC,EAAE;EAC5B,MAAM;GAAE,MAAM,QAAQ,cAAc,EAAE;GAAE,UAAU;GAAG,OAAO;GAAW,OAAO,CAAC,OAAO,CAAC;EAAE;AACzF;CACD;CACD,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAM,6BAA6B,QAAQ,8BAA8B;CACzE,MAAM,aAAa,QAAQ,cAAc,EAAE;CAC3C,MAAM,cAAc,QAAQ,eAAe;CAC3C,MAAM,KAAK,QAAQ,MAAM;CACzB,MAAM,sBAAsB,QAAQ,uBAAuB;CAC3D,MAAM,iBAAiB,QAAQ,kBAAkB;AAIjD,KAAI,YAAY,EAAE,IAAI,YAAY,EAAE,EAAE;AACpC,MAAI,MAAM,GAAG,MAAM;GAAE,MAAM;GAAY,OAAO;GAAG,UAAU;GAAG,OAAO,CAAC,MAAM,CAAC;EAAE;AAC/E;CACD;AACD,KAAI,YAAY,EAAE,EAAE;EAClB,MAAM;GAAE,MAAM;GAAY,OAAO;GAAG,UAAU;GAAG,OAAO,CAAC,MAAM,CAAC;EAAE;AAClE;CACD;CACD,MAAM,WAAW,WAAW,GAAG,YAAY;CAC3C,MAAM,+BAAe,IAAI;AACzB,MAAK,MAAM,CAAE,KAAK,OAAQ,IAAI,UAAU;EACtC,aAAa,IAAI,IAAI;EAErB,MAAM,YAAY,OAAO;EACzB,MAAM,gBAAgB,EAAG;AAGzB,MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,WAAW,KAC3C,KAAI,UAEF,KAAI,kBAAkB,OACpB,OAAM,IAAI,MAAM,CAAC,iCAAiC,EAAG,IAAK,aAAa,CAAC;OACnE;GACL,MAAM,MAAM,CAAE,GAAG,YAAY,QAAQ,eAAe;IAClD,GAAG;IACH,YAAY,aAAa,MAAM,CAAC,CAAC,CAAC;GACnC,EAAC,AAAE;AACJ,OAAI,IAAI,SAAS,GAAG;AAClB,SAAK,MAAM,KAAK,KAAK,MAAM;AAC3B,QAAI,gBACF,MAAM;KAAE,MAAM,aAAa;KAAK,OAAO,EAAG;KAAO,UAAU;KAAQ,OAAO,CAAC,MAAM,CAAC;IAAE;GAEvF;EACF;OACI;AACL,OAAI,UAAW;GAEf,MAAM;IAAE,MAAM,aAAa;IAAK,OAAO;IAAW,UAAU;IAAQ,OAAO,CAAC,OAAO,CAAC;GAAE;EACvF;OACI;GACL,MAAM,UAAU,aAAa;AAC7B,OAAI,WAEF;QAAI,kBAAkB,UAAa,4BAEjC,MAAM;KAAE,MAAM;KAAS,UAAU;KAAQ,OAAO;KAAW,OAAO,CAAC,OAAO,CAAC;IAAE;aAEzE,CAAC,GAAG,QAAQ,eAAe,QAAQ,EAErC,MAAM;KAAE,MAAM;KAAS,UAAU;KAAQ,OAAO;KAAe,OAAO,CAAC,MAAM,CAAC;IAAE;GAEnF,OACI;AAEL,QAAI,UAAW;IACf,MAAM;KAAE,MAAM;KAAS,UAAU;KAAQ,OAAO;KAAW,OAAO,CAAC,OAAO,CAAC;IAAE;GAC9E;EACF;CACF;AAED,KAAI,qBAAqB;EACvB,MAAM,WAAW,WAAW,GAAG,YAAY;AAC3C,OAAK,MAAM,CAAE,KAAK,OAAQ,IAAI,UAAU;AACtC,OAAI,aAAa,IAAI,IAAI,CAAE;GAG3B,MAAM;IAAE,MAAM,aAAa;IAAK,UAAU;IAAW,OAAO;IAAQ,OAAO,CAAC,KAAK,CAAC;GAAE;EACrF;CACF;AACF;;;;;;AAOD,MAAa,eAAe,CAAgCC,QAAWC,YAAsC;AAC3G,MAAK,MAAM,UAAU,SACnB,SAAS,aAAa,QAAQ,OAAO,MAAM,OAAO,MAAM;AAE1D,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CD,MAAa,eAAe,CAAgCP,QAAWQ,MAAcC,OAAY,mBAAmB,UAAa;AAC/H,KAAI,SAAS,OAAW,OAAM,IAAI,MAAM,CAAC,6BAA6B,CAAC;AACvE,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,0CAA0C,EAAG,OAAO,MAAO;AAC1G,KAAI,WAAW,OAAW,OAAM,IAAI,MAAM,CAAC,+BAA+B,CAAC;AAC3E,KAAI,WAAW,KAAM,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;CAEjE,MAAM,QAAQ,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;CAC7B,MAAM,IAAI,iBAAiB,QAAQ,OAAO,OAAO,iBAAiB;AAClE,QAAO;AACR;AAED,MAAM,mBAAmB,CAACC,GAAQC,OAAiBF,OAAYG,qBAAmC;AAChG,KAAI,MAAM,WAAW,GAAG;AAGtB,MAAI,iBAAkB,QAAO;AAE7B,MAAI,MAAM,QAAQ,EAAE,IAAI,CAAC,MAAM,QAAQ,MAAM,CAAE,OAAM,IAAI,MAAM,CAAC,4BAA4B,EAAG,KAAK,UAAU,MAAM,CAAE,uCAAuC,CAAC;AAC9J,MAAI,CAAC,MAAM,QAAQ,EAAE,IAAI,MAAM,QAAQ,MAAM,CAAE,OAAM,IAAI,MAAM,CAAC,8BAA8B,EAAG,KAAK,UAAU,MAAM,CAAE,uCAAuC,CAAC;AAEhK,MAAI,OAAO,MAAM,OAAO,MAAO,OAAM,IAAI,MAAM,CAAC,8BAA8B,EAAG,OAAO,EAAG,IAAI,EAAG,OAAO,MAAO,uCAAuC,CAAC;AAGxJ,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,QAAQ,EAAE,EAAE;GAC9C,MAAM,IAAI,kBAAkB,GAAG,MAAM;AACrC,OAAI,EAAE,EAAE,SAAS,EACf,OAAM,IAAI,MAAM,CAAC,6BAA6B,EAAG,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAG;AAEnE,OAAI,EAAE,EAAE,SAAS,EACf,OAAM,IAAI,MAAM,CAAC,iCAAiC,EAAG,EAAE,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,EAAG;EAExE;AACD,SAAO;CACR;CACD,MAAM,QAAQ,MAAM,OAAO;AAC3B,KAAI,CAAC,MAAO,QAAO;CAEnB,MAAM,QAAQ,UAAU,MAAM;AAC9B,KAAI,SAAS,MAAM,QAAQ,EAAE,EAAE;EAC7B,MAAM,QAAQ,OAAO,SAAS,MAAM;AACpC,MAAI,SAAS,EAAE,UAAU,CAAC,iBAAkB,OAAM,IAAI,MAAM,CAAC,YAAY,EAAG,MAAM,UAAU,CAAE,sCAAsC,EAAG,EAAE,OAAO,UAAU,CAAE,2CAA2C,CAAC;EACxM,MAAM,OAAO,CAAE,GAAG,CAAG;EACrB,KAAM,SAAU,iBAAiB,KAAM,QAAS,OAAO,OAAO,iBAAiB;AAE/E,SAAO;CACR,WAAU,SAAS,GAAG;EACrB,MAAM,OAAO,EAAE,GAAG,EAAG;EACrB,KAAM,SAAU,iBAAiB,KAAM,QAAS,OAAO,OAAO,iBAAiB;AAC/E,SAAO;CACR,MACC,OAAM,IAAI,MAAM,CAAC,KAAK,EAAG,MAAO,kBAAkB,CAAC;AAEtD;;;;;;;;;;;;;;;;;AAkBD,MAAa,WAAW,CAAIC,QAA6BL,SAAiC;AACxF,KAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,yCAAyC,EAAG,OAAO,KAAM,CAAC,CAAC;AAC1G,KAAI,KAAK,WAAW,EAAG,OAAM,IAAI,MAAM,CAAC,4BAA4B,CAAC;AACrE,KAAI,WAAW,OAAW,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACvE,KAAI,WAAW,KAAM,OAAM,IAAI,MAAM,CAAC,sBAAsB,CAAC;CAE7D,MAAM,QAAQ,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;CAC7B,MAAM,IAAI,aAAgB,QAAQ,MAAM;AACxC,QAAO;AACR;AAED,MAAM,eAAe,CAAIK,QAA6BF,UAAoC;AACxF,KAAI,WAAW,OAAW,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACvE,KAAI,MAAM,WAAW,EAAG,OAAM,IAAI,MAAM,CAAC,gBAAgB,CAAC;CAC1D,MAAM,QAAQ,MAAM,OAAO;AAC3B,KAAI,CAAC,MAAO,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;CAEzD,MAAM,QAAQ,UAAU,MAAM;AAC9B,KAAI,SAAS,MAAM,QAAQ,OAAO,EAAE;EAClC,MAAM,QAAQ,OAAO,SAAS,MAAM;AAEpC,MAAI,OAAO,OAAQ,WAAY,CAAC,SAAS,CAAC,CACxC,QAAO;GAAE,SAAS;GAAO,OAAO,CAAC,OAAO,EAAG,MAAO,0BAA0B,EAAG,OAAO,QAAS;EAAE;AAGnG,MAAI,MAAM,WAAW,EACnB,QAAO;GAAE,OAAO,OAAQ;GAAc,SAAS;EAAM;MAErD,QAAO,aAAa,OAAQ,QAAS,MAAM;CAE9C,WAAU,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,SAAS,OAGhD,KAAI,MAAM,WAAW,EACnB,QAAO;EAAE,OAAO,OAAQ;EAAc,SAAS;CAAM;KAErD,QAAO,aAAa,OAAQ,QAAS,MAAM;KAG7C,QAAO;EAAE,SAAS;EAAO,OAAO,CAAC,MAAM,EAAG,MAAO,WAAW,CAAC;CAAE;AAElE;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BD,UAAiB,SAASG,QAAuB,aAAa,OAA0B;AACtF,KAAI,WAAW,UAAa,WAAW,KAAM;CAC7C,MAAM,OAAO,wBAAwB,OAAO;AAC5C,MAAK,MAAM,KAAK,MAAM;AACpB,MAAI,EAAE,cAAc,UAAa,WAAY;EAC7C,IAAI,OAAO,EAAE;AACb,MAAI,EAAE,UAAU,SAAS,GAAG,OAAO,EAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG;EACjE,MAAM;CACP;AACF;;;;;;;;;;;;;;;;;;;;AAqBD,UAAiB,gBAAgBC,GAAW,aAAa,OAAO,WAAW,OAAO,kBAAkB,SAAS,EAAE,EAA4B;AACzI,KAAI,MAAM,KAAM;AAChB,KAAI,MAAM,OAAW;CACrB,OAAO,oBAAoB,GAAG,QAAQ,YAAY,SAAS;AAC5D;AAED,UAAU,oBAAoBA,GAAWC,QAAgB,aAAa,OAAOC,UAA4C;AACvH,KAAI,YAAY,EAAG;AACnB,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE;AAC3B,MAAK,MAAM,WAAW,OAAO,QAAQ,EAAE,EAAE;EACvC,MAAM,OAAO,OAAO,SAAS,IAAI,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,QAAS;EAC/D,MAAM,QAAQ,QAAS;EACvB,MAAM,OAAQ,OAAO,UAAU,CAAC,MAAM,CAAC;AAEvC,MAAI,cAAc,QAAQ,CAAC,YACzB,MAAM;GAAE,MAAM;GAAK;EAAO;EAE5B,OAAO,oBAAoB,OAAO,KAAK,YAAY,WAAW,EAAE;CACjE;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxZD,MAAa,gBAAgB,CAAgGC,QAAqCC,gBAAsD;CACtN,MAAM,oBAAoB,CAAE;AAC5B,MAAK,MAAM,WAAW,OAAO,QAAQ,OAAO,EAAE;EAC5C,MAAM,MAAM,YAAY,QAAS,GAAkB;EAClD,kBAAwD,OAAQ,QAAS;CAC3E;AACD,QAAO;AACR"}