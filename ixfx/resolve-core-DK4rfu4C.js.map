{"version":3,"file":"resolve-core-DK4rfu4C.js","names":["rx: object","rx:  object","r: ResolveToValue<V>","r: ResolveToValueSync<V>","p: ResolveToValueSync<T>","fallback: ResolveFallbackOpts<T>"],"sources":["../../../ixfx/packages/core/src/reactive-core.ts","../../../ixfx/packages/core/src/resolve-core.ts"],"sourcesContent":["import type { Reactive, ReactiveInitial } from \"./types-reactive.js\";\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\nexport const hasLast = <V>(rx:  object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}","//import { hasLast, isReactive } from \"@ixfx/rx\";\n//import type { ReactiveNonInitial } from \"@ixfx/rx\";\nimport type { BasicType } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport type { ReactiveNonInitial } from \"./types-reactive.js\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n\n\n/**\n * Something that can resolve to a value\n */\nexport type ResolveToValueSync<V> = BasicType | ReactiveNonInitial<V> | Generator<V> | IterableIterator<V> | ((args: any) => V)\nexport type ResolveToValueAsync<V> = AsyncGenerator<V> | AsyncIterableIterator<V> | Promise<V> | ((args: any) => Promise<V>);\nexport type ResolveToValue<V> = ResolveToValueAsync<V> | ResolveToValueSync<V>;\n\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n * \n * To resolve an object's properties, use {@link resolveFields}.\n * \n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r \n * @param args \n * @returns \n */\nexport async function resolve<V extends BasicType>(r: ResolveToValue<V>, ...args: any): Promise<V> {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        const v = await r.next();\n        //console.log(`  hasDone: ${ `done` in v } value:`, v);\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last() as V;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    const v = await r(args) as V;\n    return v;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\nexport function resolveSync<V extends BasicType>(r: ResolveToValueSync<V>, ...args: any): V {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        throw new Error(`resolveSync cannot work with an async generator`);\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last() as V;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    return r(args);\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_ \n * or NaN, `fallbackValue` is returned instead.\n * \n * `null` is an allowed return value.\n * \n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args \n * @returns \n */\nexport async function resolveWithFallback<T extends BasicType>(p: ResolveToValue<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = await resolve(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport function resolveWithFallbackSync<T extends BasicType>(p: ResolveToValueSync<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = resolveSync(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport type ResolveFallbackOpts<T> = { value: T, overrideWithLast?: boolean }"],"mappings":";;;;;;;;AAOA,MAAa,aAAa,CAAIA,OAAkC;AAC9D,YAAW,QAAQ,QAAS,QAAO;AACnC,KAAI,OAAO,KAAM,QAAO;AACxB,SAAS,OAAO,OAAO,YAAY;AACpC;AAED,MAAa,UAAU,CAAIC,OAA0C;AACnE,MAAK,WAAW,GAAG,CAAE,QAAO;AAC5B,MAAK,SAAS,IAAI;EAChB,MAAM,IAAI,AAAC,GAAW,MAAM;AAC5B,MAAI,aAAiB,QAAO;CAC7B;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkBD,eAAsB,QAA6BC,GAAsB,GAAG,MAAuB;AACjG,YAAW,OAAO,QAChB,MAAK,SAAS,GAAG;EACf,MAAM,MAAO,EAAW,OAAO;AAC/B,MAAI,SAAS,cAAc,QAAQ,iBAAiB;GAClD,MAAM,IAAI,EAAE,MAAM;AAClB,QAAK,SAAS,MAAM,UAAU,EAAG,QAAO,EAAE;AAC1C,UAAO;EACR,WAAU,SAAS,iBAAiB;GACnC,MAAM,IAAI,MAAM,EAAE,MAAM;AAExB,QAAK,SAAS,MAAM,UAAU,EAAG,QAAO,EAAE;AAC1C,UAAO;EACR,MACC,OAAM,IAAI,OAAO,uHAAwH,IAAK;CAEjJ,WAAU,WAAc,EAAE,EAAE;AAC3B,MAAI,QAAQ,EAAE,CAAE,QAAO,EAAE,MAAM;AAC/B,QAAM,IAAI,OAAO;CAClB,MAEC,QAAO;iBAEO,OAAO,WAAW;EAClC,MAAM,IAAI,MAAM,EAAE,KAAK;AACvB,SAAO;CACR,MAEC,QAAO;AAEV;AAED,SAAgB,YAAiCC,GAA0B,GAAG,MAAc;AAC1F,YAAW,OAAO,QAChB,MAAK,SAAS,GAAG;EACf,MAAM,MAAO,EAAW,OAAO;AAC/B,MAAI,SAAS,cAAc,QAAQ,iBAAiB;GAClD,MAAM,IAAI,EAAE,MAAM;AAClB,QAAK,SAAS,MAAM,UAAU,EAAG,QAAO,EAAE;AAC1C,UAAO;EACR,WAAU,SAAS,gBAClB,OAAM,IAAI,OAAO;MAEjB,OAAM,IAAI,OAAO,qGAAsG,IAAK;CAE/H,WAAU,WAAc,EAAE,EAAE;AAC3B,MAAI,QAAQ,EAAE,CAAE,QAAO,EAAE,MAAM;AAC/B,QAAM,IAAI,OAAO;CAClB,MAEC,QAAO;iBAEO,OAAO,UACvB,QAAO,EAAE,KAAK;KAGd,QAAO;AAEV;AA4CD,SAAgB,wBAA6CC,GAA0BC,UAAkC,GAAG,MAAW;CACrI,IAAI,UAAU;CACd,IAAI,gBAAgB,SAAS;CAC7B,MAAM,mBAAmB,SAAS,oBAAoB;AACtD,KAAI,yBAA6B,OAAM,IAAI,OAAO;AAElD,KAAI;EACF,MAAM,IAAI,YAAY,GAAG,GAAG,KAAK;AACjC,aAAW,OAAO,WAAY,QAAO;AACrC,aAAW,OAAO,WAAW,OAAO,MAAM,EAAE,CAAE,QAAO;AACrD,MAAI,iBAAkB,iBAAgB;AACtC,SAAO;CACR,SAAQ,OAAO;AACd,OAAK,SAAS;AACZ,aAAU;AACV,WAAQ,MAAM,8EAA8E,gBAAgB,MAAM,CAAC;EACpH;AACD,SAAO;CACR;AACF"}