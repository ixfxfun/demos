{"version":3,"file":"iterables.js","names":["v: any","fromArray","array: V[]","interval: Interval","array","fromIterable","iterable: Iterable<V> | AsyncIterable<V>","iterable","chunks","it: AsyncIterable<V>","size: number","buffer: V[]","concat","dropWhile","f: (v: V) => boolean","until","it: AsyncIterable<any> | Iterable<any>","callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)","repeat","genCreator: () => Iterable<T> | AsyncIterable<T>","repeatsOrSignal: number | AbortSignal","equals","it1: AsyncIterable<V>","it2: AsyncIterable<V>","equality?: IsEqual<V>","every","f: (v: V) => boolean | Promise<boolean>","fill","v: V","filter","find","flatten","forEach","iterator: AsyncIterable<T> | T[]","fn: (v?: T) => Promise<boolean> | Promise<void> | boolean | void","options: Partial<ForEachOptions>","last","opts: Partial<{ abort: AbortSignal }>","returnValue: V | undefined","map","f: (v: V) => X","max","a: V","b: V","max: V | undefined","min","min: V | undefined","reduce","f: (accumulator: V, current: V) => V","start: V","asCallback","input: AsyncIterable<V>","callback: (v: V) => unknown","onDone?: () => void","slice","it: Iterable<V>","delay: Interval","delay","it: AsyncIterableIterator<V> | IterableIterator<V>","options: SleepOpts<any>","value: IteratorResult<V> | undefined","some","toArray","options: Partial<ToArrayOptions>","result: V[]","unique","iterable: AsyncIterable<V> | AsyncIterable<V>[]","buffer: any[]","itera: AsyncIterable<V>[]","uniqueByValue","input: AsyncIterable<T>","toString: (value: T) => string","seen: Set<string>","zip","slice","it: Iterable<V>","reduce","it: Iterable<V>","f: (accumulator: V, current: V) => V","start: V","uniqueByValue","input: Iterable<T>","toString: ToString<T>","seen: Set<string>","asCallback","input: Iterable<V>","callback: (v: V) => unknown","onDone?: () => void","generator: Generator<number>","defaultValue?: number","v: number | undefined","it: Iterable<V>","last","returnValue: V | undefined","size: number","buffer: V[]","chunks","concat","dropWhile","f: (v: V) => boolean","until","it: Iterable<any>","callback: () => (void | boolean | never)","it: Generator<T>","equals","it1: IterableIterator<V>","it2: IterableIterator<V>","equality?: IsEqual<V>","every","fill","v: V","forEach","iterator: Iterable<T> | T[]","fn: (v: T) => boolean | void","filter","find","flatten","map","f: (v: V) => X","max","a: V","b: V","max: V | undefined","min","min: V | undefined","some","genCreator: () => Iterable<T>","repeatsOrSignal: number | AbortSignal","unique","iterable: Iterable<V> | Iterable<V>[]","buffer: any[]","itera: Iterable<V>[]","iterable","zip","fromIterable","iterable: Iterable<T>","toArray","options: Partial<ToArrayOptions>","result: V[]","fromArray","array: V[]","array","c: any","value: number | boolean | string","input: GenOrData<V> | GenFactoryNoInput<V>","input: GenOrData<V> | GenFactoryNoInput<V> | undefined","elOrQuery: string | HTMLElement","key?: (value: T) => string","value: T","map","key: T","key","value: TValue","key: T | string","options: Partial<CreateOptions<In>>","perValue","input: GenOrData<In>","options: Partial<QueryOptions>","query","input: GenOrData<string>","transformer: (v: In) => Out","transform","input: GenOrData<In>","limit: number","take","reduce","reducer: (v: In[]) => Out","input: GenOrData<In[]>","elapsed: Interval","duration","elapsed","options: DelayOptions","delay","rate: Interval","debounce","tally","min","input: GenOrData<number | number[]>","max","rank","r: RankFunction<In>","options: Partial<RankOptions>","options: Partial<RankArrayOptions>","rankArray","best: In | undefined","average","input: GenOrData<number>","sum","size: number","chunk","buffer: In[]","filter","predicate: (v: In) => boolean","drop","it: Out[]","delay: Interval","fromArray","delay","target: EventTarget","name: string","event","callback: () => Promise<Out> | Out","fromFunction","it: Iterable<Out> | AsyncIterable<Out>","fromIterable","options: TickOptions","array: Out[]","valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>","array","valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>","options: Partial<ToArrayOptions>","AsyncToArray","asCallback","valueToWrap: GenOrData<V> | GenFactoryNoInput<V>","callback: (v: V) => unknown","onDone?: () => void","valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>","lastValue: V | undefined","asPromise","valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>","initialValue?: V","lastValue: V | undefined","asValue","error: unknown","sources: (GenOrData<any> | GenFactoryNoInput<any>)[]","options: Partial<CombineLatestOptions>","d: any[]","lastEmitted: any[]","promises: Promise<any>[]","sources: T","options: Partial<CombineLatestOptions>","d: object","lastEmitted: GenValueTypeObject<T> | undefined","promises: Promise<any>[]","c: Link<any, any>","chained: Link<any, any>[]","dataToUse: GenOrData<In> | undefined","data?: GenOrData<In>","w: LazyChain<In, Out>","r: RankFunction<In>","options: Partial<RankArrayOptions>","options: Partial<RankOptions>","transformer: (v: any) => any","reducer: (values: any[]) => any","predicate: (v: In) => boolean","options: DelayOptions","elapsed: Interval","rate: Interval","callback: () => any","fromFunction","limit: number","size: number","predicate: (input: any) => boolean","countArrayItems: boolean","data: GenOrData<In>","lastValue: Out | undefined","data: V","#store","source: AsyncGenerator<any> | undefined","input: Gen<In> | undefined","gen: GenOrData<T1> | GenFactoryNoInput<T1>","l0?: Link<T1, T2>","l1?: Link<T2, T3>","l2?: Link<T3, T4>","l3?: Link<T4, T5>","l4?: Link<T5, T6>","l5?: Link<T6, T7>","input: Gen<any> | undefined","source: GenOrData<In> | GenFactoryNoInput<In>","f: Link<In, Out>","input: In","sources: (GenOrData<any> | GenFactoryNoInput<any>)[]","options: Partial<SyncOptions>","nextWithTimeoutOpts: SleepOpts<any>","iterable: Iterable<V>","scorer: (v: V) => number","highestValue: V | undefined","iterable","lowestValue: V | undefined","iterableA: Iterable<V>","iterableB: Iterable<V>","eq?: IsEqual<V>","options: IteratorControllerOptions<T>","gen: AsyncGenerator<T> | IterableIterator<T> | undefined","state: IteratorControllerState","eventSource: WithEvents","eventType: string","pullQueue: Array<any>","pushQueue: Array<any>","args: any","r: AsyncIterator<V>","error: any","data: readonly number[] | number[] | Iterable<number>","options: NumbersComputeOptions","data: Iterable<number>","min","max","min","it: AsyncIterable<V> | Iterable<V>","a: V","b: V","max","f: (v: V) => boolean","it: AsyncIterable<any> | Iterable<any>","callback: () => Promise<boolean> | never | boolean | Promise<undefined>","size: number","f: (v: V) => boolean | Promise<boolean>","v: V","it: V[] | Iterable<V> | AsyncIterable<V>","it: T[] | AsyncIterable<T> | Iterable<T>","fn: (v: T | undefined) => boolean | Promise<boolean> | void | Promise<void>","options: Partial<ForEachOptions>","it: V[] | AsyncIterable<V> | Iterable<V>","f: (v: V) => X | Promise<X>","array: V[]","interval?: Interval","array","it: V[] | AsyncIterable<V | V[]> | Iterable<V | V[]>","some","it: AsyncIterable<V> | Iterable<V> | V[]","f: (accumulator: V, current: V) => V","start: V","it: Iterable<V> | AsyncIterable<V> | V[]","iterable: V[] | AsyncIterable<V> | Iterable<V> | Iterable<V>[] | AsyncIterable<V>[]","iterable","input: AsyncIterable<T> | Iterable<T> | T[]","toString: (v: T) => string","seen: Set<string>","it: Iterable<V> | AsyncIterable<V>","options: Partial<ToArrayOptions>","it: Iterable<V> | V[] | AsyncIterable<V>","it1: AsyncIterable<V> | IterableIterator<V>","it2: AsyncIterable<V> | IterableIterator<V>","equality?: (a: V, b: V) => boolean","iterable: Iterable<V> | AsyncIterable<V>","callback: () => T","callback: () => Promise<T> | T","input: AsyncIterable<V> | Iterable<V>","callback: (v: V) => unknown","onDone?: () => void"],"sources":["../../iterables/src/guard.ts","../../iterables/src/async.ts","../../iterables/src/sync/slice.ts","../../iterables/src/sync/reduce.ts","../../iterables/src/sync.ts","../../iterables/src/chain/utility.ts","../../iterables/src/util/dom.ts","../../iterables/src/chain/dom.ts","../../iterables/src/chain/links.ts","../../iterables/src/chain/from/array.ts","../../iterables/src/chain/from/event.ts","../../iterables/src/chain/from/function.ts","../../iterables/src/chain/from/iterable.ts","../../iterables/src/chain/from/ticks.ts","../../iterables/src/chain/from/index.ts","../../iterables/src/chain/add-to-array.ts","../../iterables/src/chain/as-array.ts","../../iterables/src/chain/as-callback.ts","../../iterables/src/chain/as-promise.ts","../../iterables/src/chain/as-value.ts","../../iterables/src/chain/combine-latest-to-array.ts","../../iterables/src/chain/combine-latest-to-object.ts","../../iterables/src/chain/lazy.ts","../../iterables/src/util/queueMutable.ts","../../iterables/src/chain/merge-flat.ts","../../iterables/src/chain/run.ts","../../iterables/src/chain/prepare.ts","../../iterables/src/chain/single.ts","../../iterables/src/chain/sync.ts","../../iterables/src/chain/index.ts","../../iterables/src/compare-values.ts","../../iterables/src/controller.ts","../../iterables/src/from-event.ts","../../iterables/src/numbers-compute.ts","../../iterables/src/index.ts"],"sourcesContent":["\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> => {\n  if (typeof v !== `object`) return false;\n  if (v === null) return false;\n  return Symbol.asyncIterator in v;\n\n}\n\nexport const isIterable = (v: any): v is Iterable<any> => {\n  if (typeof v !== `object`) return false;\n  if (v === null) return false;\n  return Symbol.iterator in v;\n\n}\n\n","import { intervalToMs, type Interval, type IsEqual, toStringDefault } from '@ixfx/core';\nimport { sleep, type SleepOpts } from '@ixfx/core';\nimport type { ForEachOptions, ToArrayOptions } from './types.js';\nimport { isAsyncIterable, isIterable } from './guard.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: V[], interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer: V[] = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: readonly AsyncIterable<V>[]) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link @ixfx/numbers.count} will count from 0..number and then finish:\n * ```js\n * import { count } from '@ixfx/numbers'\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator \n * @param repeatsOrSignal \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"@ixfx/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function <T>(\n  iterator: AsyncIterable<T> | T[],\n  fn: (v?: T) => Promise<boolean> | Promise<void> | boolean | void,\n  options: Partial<ForEachOptions> = {}\n) {\n  const interval = options.interval;\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  }\n};\n\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last<V>(it: AsyncIterable<V>, opts: Partial<{ abort: AbortSignal }> = {}): Promise<V | undefined> {\n  const abort = opts.abort;\n  let returnValue: V | undefined;\n\n  for await (const value of it) {\n    if (abort?.aborted) return undefined;\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Calls `callback` whenever the async generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport async function asCallback<V>(input: AsyncIterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for await (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  console.log(`Async slice start: ${ start }`);\n\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it \n * @param delay \n */\nexport async function* withDelay<V>(it: Iterable<V>, delay: Interval) {\n  for (const v of it) {\n    await sleep(delay);\n    yield v;\n  }\n}\n\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout<V>(it: AsyncIterableIterator<V> | IterableIterator<V>, options: SleepOpts<any>) {\n  const ms = intervalToMs(options, 1000);\n\n  const value: IteratorResult<V> | undefined = await Promise.race([\n    (async () => {\n      await sleep({ millis: ms, signal: options.signal });\n\n      return undefined;\n    })(),\n    (async () => {\n      return await it.next();\n    })()\n  ]);\n  if (value === undefined) throw new Error(`Timeout`);\n  return value;\n}\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n * \n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Promise<V[]> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result: V[] = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const whileFunction = options.while;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n\n  while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n    if (whileFunction) {\n      if (!whileFunction(result.length)) break;\n    }\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | AsyncIterable<V>[]\n) {\n  const buffer: any[] = [];\n  const itera: AsyncIterable<V>[] = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: (value: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: readonly AsyncIterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","export function* slice<V>(\n  it: Iterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n  if (start < 0) throw new Error(`Param 'start' should be at least 0`);\n  let index = 0;\n  for (const v of it) {\n    if (index < start) {\n      index++;\n      continue;\n    }\n    if (index > end) {\n      break;\n    }\n    yield v;\n    index++;\n  }\n}","export function reduce<V>(\n  it: Iterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) start = f(start, v);\n  return start;\n}\n","import { type ToString, toStringDefault } from '@ixfx/core';\nimport { type IsEqual, intervalToMs } from '@ixfx/core';\nimport { isIterable } from './guard.js';\n//import { intervalToMs } from '../flow/IntervalType.js';\nimport type { ToArrayOptions } from './types.js';\nexport { slice } from './sync/slice.js';\nexport { reduce } from './sync/reduce.js';\n\nexport function* uniqueByValue<T>(input: Iterable<T>, toString: ToString<T> = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> {\n  for (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Calls `callback` whenever the generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport function asCallback<V>(input: Iterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(\n  generator: Generator<number>,\n  defaultValue?: number\n) {\n\n  return (): number | undefined => {\n    const v: number | undefined = generator.next().value as number | undefined;\n    if (v === undefined) return defaultValue;\n    return v;\n  };\n}\n\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first<V>(it: Iterable<V>): V | undefined {\n  for (const value of it) {\n    return value;\n  }\n}\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last<V>(it: Iterable<V>): V | undefined {\n  let returnValue: V | undefined;\n  for (const value of it) {\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping<V>(it: Iterable<V>, size: number) {\n  if (size <= 1) throw new Error(`Size should be at least 2`);\n\n  //eslint-disable-next-line functional/no-let\n  let buffer: V[] = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      buffer = [ buffer.at(-1)! ];\n    }\n  }\n  if (buffer.length <= 1) return;\n\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport function* chunks<V>(it: Iterable<V>, size: number) {\n  //eslint-disable-next-line functional/no-let\n  let buffer: V[] = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\nexport function* concat<V>(...its: readonly Iterable<V>[]) {\n  for (const it of its) yield* it;\n}\n\nexport function* dropWhile<V>(\n  it: Iterable<V>,\n  f: (v: V) => boolean\n) {\n  for (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it: Iterable<any>, callback: () => (void | boolean | never)) => {\n  for (const _ of it) {\n    const value = callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\nexport const next = <T>(it: Generator<T>) => {\n  return () => {\n    const r = it.next();\n    if (r.done) return;\n    return r.value;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(\n  it1: IterableIterator<V>,\n  it2: IterableIterator<V>,\n  equality?: IsEqual<V>\n) {\n  //it1 = it1[Symbol.iterator]();\n  //it2 = it2[Symbol.iterator]();\n\n  while (true) {\n    const index1 = it1.next(),\n      index2 = it2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport function every<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  for (const v of it) {\n    const result = f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\n\nexport function* fill<V>(it: Iterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n\n\n  for (const _ of it) yield v;\n}\n\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * import { Sync } from \"@ixfx/iterables.js\"\n * Sync.forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * Sync.forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * Sync.forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEach} if you want to use an async `iterator` and async `fn`.\n * \n * Alternatives:\n * * {@link @ixfx/flow.repeat}/{@link @ixfx/flow.repeatSync}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam T Type of iterable's values\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport function forEach<T>(iterator: Iterable<T> | T[], fn: (v: T) => boolean | void) {\n  for (const v of iterator) {\n    const result = fn(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\nexport function find<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return v;\n  }\n}\n\nexport function* flatten<V>(it: Iterable<V>) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\n\nexport function* map<V, X>(it: Iterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    yield f(v);\n  }\n}\n\nexport function* max<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b): Generator<V> {\n  let max: V | undefined;\n  for (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield max;\n      continue;\n    }\n    if (gt(v, max)) {\n      max = v;\n      yield max;\n    }\n  }\n  return max;\n}\n\nexport function* min<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n    }\n    if (gt(min, v)) {\n      min = v;\n      yield min;\n    }\n  }\n}\n\n\n\nexport function some<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return true;\n  }\n  return false;\n}\n\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\nexport function* repeat<T>(genCreator: () => Iterable<T>, repeatsOrSignal: number | AbortSignal): Generator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n\nexport function* unique<V>(\n  iterable: Iterable<V> | Iterable<V>[]\n) {\n  // Adapted from https://surma.github.io/underdash/\n  const buffer: any[] = [];\n  let itera: Iterable<V>[] = [];\n  itera = Array.isArray(iterable) ? iterable : [ iterable ];\n  for (const it of itera) {\n    for (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\n\nexport function* zip<V>(...its: readonly Iterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.iterator ]());\n\n  while (true) {\n    const vs = iits.map((it) => it.next());\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n\nexport function* fromIterable<T>(iterable: Iterable<T>) {\n  for (const v of iterable) {\n    yield v;\n  }\n}\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\n\nexport function toArray<V>(\n  it: Iterable<V>,\n  options: Partial<ToArrayOptions> = {}\n): V[] {\n  const result: V[] = [];\n  const started = Date.now();\n  const whileFunction = options.while;\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n  for (const v of it) {\n    if (whileFunction) {\n      if (!whileFunction(result.length)) break;\n    }\n    if (result.length >= maxItems) break;\n    if (Date.now() - started > maxElapsed) break;\n    result.push(v);\n  }\n  return result;\n}\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray<V>(array: V[]): Generator<V> {\n  for (const v of array) {\n    yield v;\n  }\n}","import * as Async from \"../async.js\";\nimport type { GenOrData, GenFactoryNoInput, Gen } from \"./types.js\";\nimport { isAsyncIterable } from \"../index.js\";\nimport { sleep } from \"@ixfx/core\";\n\nexport function isGenFactoryNoInput<Out>(c: any): c is GenFactoryNoInput<Out> {\n  if (!(`_type` in c)) return false;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  if (c._type === `GenFactoryNoInput`) return true;\n  return false;\n}\n\n/**\n * Wrap the primitive value as generator\n * @param value \n */\nfunction* primitiveToGenerator(value: number | boolean | string) {\n  yield value;\n}\n\n/**\n * Wrap the primitive value as an async generator\n * @param value \n */\nasync function* primitiveToAsyncGenerator(value: number | boolean | string) {\n  yield value;\n  await sleep(1);\n}\n\n/**\n * Resolve the array, data or function to a Generator\n * @param input \n * @returns \n */\nexport function resolveToGen<V>(input: GenOrData<V> | GenFactoryNoInput<V>): Gen<V> {\n  if (Array.isArray(input)) {\n    const a = input.values();\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    (a as any)._name = `arrayInput`;\n    return a;\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToGenerator(input) as Gen<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  }\n  return input;\n}\n\n/**\n * Resolve the data, primitive or function to an AsyncGenerator\n * @param input \n * @returns \n */\nexport function resolveToAsyncGen<V>(input: GenOrData<V> | GenFactoryNoInput<V> | undefined): AsyncGenerator<V> | undefined {\n  if (input === undefined) return;\n  if (Array.isArray(input)) {\n    return Async.fromArray(input);\n  } else if (typeof input === `number` || typeof input === `boolean` || typeof input === `string`) {\n    // Assumes V is primitive\n    return primitiveToAsyncGenerator(input) as AsyncGenerator<V>;\n  } else if (typeof input === `function`) {\n    return input();\n  } else if (isAsyncIterable(input)) {\n    return input;\n  }\n  return Async.fromIterable(input);\n}\n","export function resolveEl(elOrQuery: string | HTMLElement): HTMLElement {\n  if (typeof elOrQuery === `string`) {\n    const el = document.querySelector(elOrQuery);\n    if (!el) throw new Error(`Element not found '${ elOrQuery }'`);\n    return el as HTMLElement;\n  }\n  return elOrQuery;\n}","import { toStringDefault } from \"@ixfx/core\";\nimport type { GenOrData, Link } from \"./types.js\";\nimport { resolveToGen } from \"./utility.js\";\nimport { resolveEl } from \"../util/dom.js\";\n\nexport type QueryOptions = {\n  baseElement: HTMLElement;\n}\n\nexport type CreateOptions<In> = {\n  /**\n   * Parent element to create elements in. Defaults to `document.body`.\n   */\n  parentEl: string | HTMLElement\n  /**\n   * When set, provide a custom function to return a unique key for a value.\n   * This is used for matching values with elements when using immutable data.\n   * \n   * By default uses the\n   * JSON.stringify() representation.\n   * \n   * To match elements with values by reference, set `byReference` instead.\n   * \n   * @param value \n   * @returns \n   */\n  key: (value: In) => string\n  /**\n   * Default: _false_. When _true_, associate created elements\n   * to values by reference rather than value. This can be useful with mutable values.\n   * \n   * Use this _or_ the `key` option.\n   */\n  byReference: boolean\n  /**\n   * What kind of HTML element to make, defaults to DIV\n   */\n  tagName: string\n  /**\n   * Called whenever an element is created but not yet added to parent element\n   * @param element \n   * @returns \n   */\n  beforeInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element is inserted to the parent element\n   */\n  afterInsert: (element: HTMLElement) => void\n  /**\n   * Called after an element has been removed\n   * @param element \n   * @returns \n   */\n  beforeRemove: (element: HTMLElement) => void\n}\n\nconst createMap = <T, TValue>(key?: (value: T) => string) => {\n  const keyFunction = key ?? ((value: T) => value);\n\n  const map = new Map<ReturnType<typeof keyFunction>, TValue>();\n  return {\n    has(key: T) {\n      return map.has(keyFunction(key));\n    },\n    get(key: T) {\n      return map.get(keyFunction(key));\n    },\n    set(key: T, value: TValue) {\n\n      //console.log(`Chains.Dom.createMap: key: ${ keyFunction(key) } value: ${ value }`);\n      map.set(keyFunction(key), value);\n    },\n    entries() {\n      return map.entries();\n    },\n    delete(key: T | string) {\n      map.delete(key);\n    }\n  }\n\n}\n\nexport type ElementWithValue<T> = {\n  el: HTMLElement\n  value: T\n}\n\n/**\n * Creates a HTML element per value. By default compares\n * values by `JSON.stringify`. Set `byReference:true` to\n * compare values based on reference. Or provide a toString\n * function via `key`.\n * \n * ```js\n * // Generate a random number between 0...4 every second\n * const looper = Generators.interval(() => Math.floor(Math.random()*5), 1000);\n * \n * // Make a chain\n * const ch = Chains.run(\n *  looper,\n *  Chains.Links.delay({before:1000}),\n *  Chains.Dom.perValue()\n * );\n *\n * setTimeout(async () => {\n *    for await (const v of ch) {\n *      const {el,value} = v;\n *      el.textContent = `${value} - ${Date.now().toString()}`;\n *    }\n *    console.log(`ch iteration done`);\n *  });\n * ```\n */\nexport function perValue<In>(options: Partial<CreateOptions<In>> = {}): Link<In, ElementWithValue<In>> {\n  const byReference = options.byReference;\n  const tagName = options.tagName ?? `div`;\n  if (byReference && options.key) throw new Error(`byReference and key options are mutually exclusive`);\n  const keyFunction = byReference ? undefined : options.key ?? toStringDefault;\n  const map = createMap<In, HTMLElement>(keyFunction);\n  const parentElementOrQuery = options.parentEl ?? document.body;\n  const parentEl = resolveEl(parentElementOrQuery);\n\n  const usedElements = new Set<HTMLElement>();\n\n  async function* perValue(input: GenOrData<In>): AsyncGenerator<ElementWithValue<In>> {\n    for await (const value of resolveToGen(input)) {\n      let el = map.get(value);\n      if (!el) {\n        el = document.createElement(tagName);\n        map.set(value, el);\n        if (options.beforeInsert) options.beforeInsert(el);\n        parentEl.append(el);\n        if (options.afterInsert) options.afterInsert(el);\n      }\n      usedElements.add(el);\n      yield { el, value };\n    }\n\n    // Remove unused elements\n    for (const [ id, el ] of map.entries()) {\n      if (usedElements.has(el)) continue;\n      if (options.beforeRemove) options.beforeRemove(el);\n      el.remove();\n      map.delete(id);\n    }\n  }\n  perValue._name = `dom.perValue`;\n  return perValue;\n}\n\n//export type Link<In, Out> = (input: GenOrData<In>) => AsyncGenerator<Out>;\n\n/**\n * From an input stream of strings, yields an output of HTMLElememnts\n * @param options \n * @returns \n */\nexport function query(options: Partial<QueryOptions> = {}): Link<string, HTMLElement> {\n  const baseElement = options.baseElement ?? document;\n\n  async function* query(input: GenOrData<string>): AsyncGenerator<HTMLElement> {\n    const gen = resolveToGen(input);\n    for await (const value of gen) {\n      for (const element of baseElement.querySelectorAll(value)) {\n        yield element as HTMLElement;\n      }\n    }\n  }\n  query._name = `dom.query`;\n  return query;\n}\n\n","\nimport { type Interval, intervalToMs, sleep, type RankFunction, type RankOptions, type RankArrayOptions, elapsedSince } from \"@ixfx/core\";\nimport { integerTest, resultThrow } from \"@ixfx/guards\";\nimport type { Link, GenOrData, DelayOptions } from \"./types.js\";\nimport { resolveToGen } from \"./utility.js\";\nimport * as BasicProcessors from \"@ixfx/process/basic\";\n\n/**\n * Transform values from one type to another. Just like a map function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(transformer: (v: In) => Out): Link<In, Out> {\n  async function* transform(input: GenOrData<In>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield transformer(value);\n    }\n  }\n  transform._name = `transform`;\n  return transform;\n}\n\n/**\n * Take `limit` number of results from the stream, before closing\n * @param limit \n * @returns \n */\nexport function take<In>(limit: number): Link<In, In> {\n  async function* take(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let yielded = 0;\n    for await (const value of input) {\n      if (++yielded > limit) break;\n      yield value;\n    }\n  }\n  take._name = `take`;\n  return take;\n}\n\n/**\n * Takes an array of values, flattening to a single one\n * using the provided `reducer` function.\n * \n * ```js\n * // Create a chain that flattens values\n * const reduce = Chains.reduce(values => Math.max(...values));\n * // Feed it a single input (an array), get a single output back:\n * const result = await Chains.single(reduce, [ 1, 2, 3]); // 3\n * ```\n * @param reducer Function to reduce array of values to a single value\n * @returns \n */\nexport function reduce<In, Out>(reducer: (v: In[]) => Out): Link<In[], Out> {\n  async function* reduce(input: GenOrData<In[]>): AsyncGenerator<Out> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      yield reducer(value);\n    }\n  }\n  reduce._name = `reduce`;\n  return reduce;\n}\n\n/**\n * Allow values through until a duration has elapsed. After\n * that, the chain stops.\n * @param elapsed \n * @returns \n */\nexport function duration<In>(elapsed: Interval): Link<In, In> {\n  const durationMs = intervalToMs(elapsed, 0);\n\n  async function* duration(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    const elapsed = elapsedSince();\n    for await (const value of input) {\n      if (elapsed() > durationMs) break;\n      yield value;\n    }\n  }\n  duration._name = `duration`;\n  return duration;\n}\n\n/**\n * Add delay before/after values are emitted from the input stream.\n * @param options \n * @returns \n */\nexport function delay<In>(options: DelayOptions): Link<In, In> {\n  const before = intervalToMs(options.before, 0);\n  const after = intervalToMs(options.after, 0);\n\n  async function* delay(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (before > 0) {\n        await sleep(before);\n      }\n      yield value;\n      if (after > 0) {\n        await sleep(after);\n      }\n    }\n  }\n  delay._name = `delay`;\n  return delay;\n}\n\n/**\n * Ensure a minimum length of time between values.\n * Values being produced too quickly are dropped.\n * \n * In the following example, only three values will be let through.\n * ```js\n * const chain = Chains.run(\n *  // Produce values every 10ms for 350ms\n *  Chains.From.timestamp({ interval: 10, elapsed: 350 }),\n *  // Only let a value through every 100ms\n *  Chains.Links.debounce(100)\n * );\n * ```\n * @param rate \n * @returns \n */\nexport function debounce<In>(rate: Interval): Link<In, In> {\n  const rateMs = intervalToMs(rate, 0);\n\n  async function* debounce(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let elapsed = elapsedSince();\n    for await (const value of input) {\n      if (elapsed() < rateMs) continue;\n      yield value;\n      elapsed = elapsedSince();\n    }\n  }\n  debounce._name = `debounce`;\n  return debounce;\n}\n\n\n/**\n * Returns a running tally of how many items have been\n * emitted from the input source.\n * ```js\n * const ch = Chains.run(\n *  Chains.From.timestamp({ interval: 100 }),\n *  Chains.Links.tally()\n * );\n * \n * for await (const v of ch) {\n *   // Produces: 1, 2, 3 ... every 100ms\n * }\n * ```\n * This is different than {@link sum} which adds up numeric values.\n * By default it adds up individual array items\n * @returns \n */\nexport function tally<In>(countArrayItems = true): Link<In, number> {\n  async function* tally(input: GenOrData<In>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.tally(countArrayItems);\n    for await (const v of input) {\n      yield p(v);\n    }\n  }\n  tally._name = `tally`;\n  return tally;\n}\n\n/**\n * Returns the smallest value from the input.\n * Can work with numbers or number[] as input.\n * Non-numeric data is filtered out.\n * @returns \n */\nexport function min(): Link<number | number[], number> {\n  async function* min(input: GenOrData<number | number[]>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.min();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  min._name = `min`;\n  return min;\n}\n\n/**\n * Returns the largest value from the input.\n * - Non-numeric data is filtered out.\n * - Looks inside of numeric arrays.\n * @returns \n */\nexport function max(): Link<number | number[], number> {\n  async function* max(input: GenOrData<number | number[]>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.max();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  max._name = `max`;\n  return max;\n}\n// export function max(): Link<number | Array<number>, number> {\n//   async function* max(input: GenOrData<number | Array<number>>): AsyncGenerator<number> {\n//     input = resolveToGen(input);\n//     let max = Number.MIN_SAFE_INTEGER;\n//     for await (const value of input) {\n//       const valueArray = Array.isArray(value) ? value : [ value ];\n//       for (const subValue of valueArray) {\n//         if (typeof subValue !== `number`) break;\n//         max = Math.max(subValue, max);\n//         yield max;\n//       }\n//     }\n//   }\n//   max._name = `max`;\n//   return max;\n// }\n\n\n\n/**\n * Emits the currently ranked 'highest' value from a stream. Only\n * values exceeding the current highest are emitted.\n * \n * eg, if we are ranking on numerical value, an input stream of:\n * ```\n * 4, 1, 6, 10, 2, 4\n * ```\n * \n * Results in the output stream of:\n * ```\n * 4, 6, 10\n * ```\n * \n * @example \n * ```js\n * // Rank based on a field\n * Chains.Links.rank((a,b) => {\n *  if (a.size > b.size) return `a`; // Signals the first param is highest\n *  if (a.size < b.size) return `b`; // Signals the second param is highest\n *  return `eq`;\n * });\n * ```\n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}): Link<In, In> {\n  async function* rank(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    //let best: In | undefined;\n    const p = BasicProcessors.rank(r, options);\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  rank._name = `rank`;\n  return rank;\n}\n\n/**\n * Emits the highest-ranked value from amongst an array of values.\n * \n * By default, it tracks the highest-ranked _between_ arrays.\n * \n * For example:\n * ```js\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Outputs:\n * [ 6 ]\n * ```\n * \n * This behaviour can be modified with an option to only compare _within_ arrays.\n * ```\n * // Input\n * [ [4,5,6], [1,2,3] ]\n * // Output:\n * [ 6, 3 ]\n * ```\n * \n * Uses the `rank` option to determine which is more highly ranked.\n * ```js\n * Chains.Links.rankArray(\n *  (a, b) => {\n *    if (a > b) return `a`; // a is higher\n *    else if (b > a) return `b`; // b is higher\n *    return `eq`; // same\n *  }\n * )\n * ```\n * @param options \n * @returns \n */\nexport function rankArray<In>(r: RankFunction<In>, options: Partial<RankArrayOptions> = {}): Link<In[], In> {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  const withinArrays = options.withinArrays ?? false;\n\n  async function* rankArray(input: GenOrData<In[]>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    let best: In | undefined;\n    for await (const value of input) {\n      let emit = false;\n      if (withinArrays) best = undefined; // Reset\n      for (const subValue of value) {\n        if (includeType && typeof subValue !== includeType) continue;\n        if (best === undefined) {\n          best = subValue;\n          emit = true;\n        } else {\n          const result = r(subValue, best);\n          if (result == `a`) {\n            // New value is the current best\n            best = subValue;\n            emit = true;\n          } else if (result === `eq` && emitEqualRanked) {\n            // New value is same rank as previous, but we have flag on\n            emit = true;\n          } else if (emitRepeatHighest) {\n            // Emit current highest due to flag\n            emit = true;\n          }\n        }\n      }\n\n      if (emit && best) yield best;\n    }\n  }\n  rankArray._name = `rankArray`;\n  return rankArray;\n}\n\n/**\n * Returns the average from the input.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function average(): Link<number, number> {\n  async function* average(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.average();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  average._name = `average`;\n  return average;\n}\n\n/**\n * Returns the total of the numeric values.\n * Non-numeric values are filtered out.\n * @returns \n */\nexport function sum(): Link<number, number> {\n  async function* total(input: GenOrData<number>): AsyncGenerator<number> {\n    input = resolveToGen(input);\n    const p = BasicProcessors.sum();\n    for await (const value of input) {\n      const x = p(value);\n      if (x === undefined) continue;\n      yield x;\n    }\n  }\n  total._name = `total`;\n  return total;\n}\n\n/**\n * Chunks an input stream into `size` chunks.\n * \n * Eg, with a chunk size of 3, the input stream of:\n *  1, 2, 3, 4, 5, 6\n * Yields:\n *  [ 1, 2, 3 ], [ 4, 5, 6 ]\n * \n * If `returnRemainders` is _true_ (default), any left over values are returned even if\n * it's less than `size`.\n * @param size \n * @param returnRemainders If true (default) left over data that didn't make a full chunk is also returned\n * @returns \n */\nexport function chunk<In>(size: number, returnRemainders = true): Link<In, In[]> {\n  resultThrow(integerTest(size, `aboveZero`, `size`));\n  async function* chunk(input: GenOrData<In>): AsyncGenerator<In[]> {\n    input = resolveToGen(input);\n    let buffer: In[] = [];\n    for await (const value of input) {\n      buffer.push(value);\n      if (buffer.length >= size) {\n        yield buffer;\n        buffer = []\n      }\n    }\n    if (returnRemainders && buffer.length > 0) yield buffer;\n  }\n  chunk._name = `chunk`;\n  return chunk;\n}\n\n/**\n * Filters the input source, only allowing through\n * data for which `predicate` returns _true_\n * \n * {@link drop}, on the other hand excludes values for which predicate is _true_\n * @param predicate \n * @returns \n */\nexport function filter<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* filter(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  filter._name = `filter`;\n  return filter;\n}\n\n\n\n/**\n * Drops all values from input stream for which `predicate` returns _true_\n * \n * {@link filter}, on the other hand includes values where the predicate is _true_\n * @param predicate \n * @returns \n */\nexport function drop<In>(predicate: (v: In) => boolean): Link<In, In> {\n  async function* drop(input: GenOrData<In>): AsyncGenerator<In> {\n    input = resolveToGen(input);\n    for await (const value of input) {\n      if (!predicate(value)) {\n        yield value;\n      }\n    }\n  }\n  drop._name = `drop`;\n  return drop;\n}\n","import { type Interval, sleep } from \"@ixfx/core\";\nimport type { GenFactoryNoInput } from \"../types.js\";\n\n/**\n * Creates a chain from an array, reading values at a given interval\n * @param it \n * @param delay \n * @returns \n */\nexport function array<Out>(it: Out[], delay: Interval = 5): GenFactoryNoInput<Out> {\n  async function* fromArray(): AsyncGenerator<Out> {\n    for (const v of it) {\n      await sleep(delay);\n      yield v;\n    }\n  }\n  fromArray._name = `fromArray`;\n\n  fromArray._type = `GenFactoryNoInput` as const;\n  return fromArray;\n}\n\n","import { promiseFromEvent } from \"@ixfx/core\";\nimport type { GenFactoryNoInput } from \"../types.js\";\n\n/**\n * Create an iterable from an event\n * @param target Event source (eg HTML element)\n * @param name Name of event (eg. 'pointermove')\n * @returns \n */\nexport function event<Out>(target: EventTarget, name: string): GenFactoryNoInput<Out> {\n  async function* event(): AsyncGenerator<Out> {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n      yield await promiseFromEvent(target, name) as Out;\n    }\n  }\n  event._name = `event`;\n\n  event._type = `GenFactoryNoInput` as const;\n  return event;\n}\n\n\n//https://stackoverflow.com/questions/51045136/how-can-i-use-a-event-emitter-as-an-async-generator","import type { GenFactoryNoInput } from \"../types.js\";\n\n/**\n * Produce a value from a callback. When\n * the callback returns _undefined_ it is considered done.\n * \n * ```js\n * const callback = () => Math.random();\n * \n * const f = Chains.From.func(callback);\n * for await (const v of f) {\n *  // v is a new random number\n * }\n * ```\n * \n * In the context of a chain:\n * ```js\n * let produced = 0;\n * const chain = Chains.chain<number, string>(\n *  // Produce incrementing numbers\n *  Chains.From.func(() => produced++),\n *  // Convert to `x:0`, `x:1` ...\n *  Chains.transform(v => `x:${ v }`),\n *  // Take first 5 results\n *  Chains.cap(5)\n * );\n * const data = await Chains.asArray(chain);\n * ```\n * @param callback \n * @returns \n */\n\nexport function func<Out>(callback: () => Promise<Out> | Out): GenFactoryNoInput<Out> {\n  async function* fromFunction(): AsyncGenerator<Out> {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n      const v = await callback();\n      if (typeof v === `undefined`) break;\n      yield v;\n    }\n  }\n\n  fromFunction._name = `fromFunction`;\n\n  fromFunction._type = `GenFactoryNoInput` as const;\n  return fromFunction;\n}\n","import type { GenFactoryNoInput } from \"../types.js\";\n\n/**\n * Creates a chain from an interable\n * @param it \n * @returns \n */\nexport function iterable<Out>(it: Iterable<Out> | AsyncIterable<Out>): GenFactoryNoInput<Out> {\n  async function* fromIterable(): AsyncGenerator<Out> {\n    for await (const v of it) {\n      yield v;\n    }\n  }\n  fromIterable._name = `fromIterable`;\n\n  fromIterable._type = `GenFactoryNoInput` as const;\n  return fromIterable;\n}","import { elapsedSince, intervalToMs, sleep } from \"@ixfx/core\";\nimport type { GenFactoryNoInput, TickOptions } from \"../types.js\";\n\n/**\n * Generate timestamp values at `interval` rate. By default it runs forever. \n * Use `loops` or `elapsed` to set upper limit on how long it should run.\n * \n * ```js\n * const c = Chains.From.timestamp({ interval: 1000 });\n * ```\n * Options:\n * - `asClockTime`: If _true_, yielded value will be clock time rather than elapsed milliseconds\n * @param options \n * @returns \n */\nexport function timestamp(options: TickOptions): GenFactoryNoInput<number> {\n  const intervalMs = intervalToMs(options.interval, 0);\n  const asClockTime = options.asClockTime ?? false;\n  const loops = options.loops ?? Number.MAX_SAFE_INTEGER;\n  let looped = 0;\n  const durationTime = intervalToMs(options.elapsed, Number.MAX_SAFE_INTEGER);\n\n  async function* ts(): AsyncGenerator<number> {\n    const elapsed = elapsedSince();\n    while (looped < loops && elapsed() < durationTime) {\n      yield asClockTime ? Date.now() : elapsed();\n\n      // Adjust sleep period so timing errors don't accumulate\n      const expectedTimeDiff = (looped * intervalMs) - elapsed();\n      await sleep(Math.max(0, intervalMs + expectedTimeDiff));\n      looped++;\n    }\n  }\n  ts._name = `timestamp`;\n\n  ts._type = `GenFactoryNoInput` as const;\n  return ts;\n}","export * from './array.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterable.js';\nexport * from './ticks.js';","import type { GenFactoryNoInput } from \"./types.js\";\n\n/**\n * Adds values to the provided array as they are produced,\n * mutating array.\n * \n * ```js\n * const data = [];\n * addToArray(data, tick({ interval: 1000, loops: 5 }));\n * // Execution continues immediately, with `data` mutated over time\n * ```\n * @param valueToWrap \n * @param array \n */\nexport async function addToArray<Out>(array: Out[], valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    array.push(value);\n  }\n}","import type { GenFactoryNoInput } from \"./types.js\"\n\nimport { toArray as AsyncToArray } from \"../async.js\";\nimport type { ToArrayOptions } from \"../types.js\";\n\n/**\n * Async function that returns the chain as an array of values\n * ```js\n * const values = await asArray(tick( { interval: 1000, loops: 5 }));\n * // After 5 seconds, values will be a set of timestamps.\n * ```\n * \n * If the chain is infinite, be sure to specify limits:\n * ```js\n * // Stop after we have five items\n * const values = await asArray(chain, { limit: 5 });\n * // Stop after 5 seconds has elapsed\n * const values = await asArray(chain, { elapsed: 5000 });\n * ```\n * @param valueToWrap \n * @returns \n */\nexport async function asArray<Out>(valueToWrap: AsyncGenerator<Out> | GenFactoryNoInput<Out>, options: Partial<ToArrayOptions> = {}): Promise<Out[]> {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  return AsyncToArray(outputType, options);\n}","import type { GenFactoryNoInput, GenOrData } from \"./types.js\";\n\n/**\n * Calls `callback` whenever the chain/generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param valueToWrap \n * @param callback \n */\nexport async function asCallback<V>(valueToWrap: GenOrData<V> | GenFactoryNoInput<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n  for await (const value of outputType) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}","import type { GenFactoryNoInput } from \"./types.js\";\n\n/**\n * Treats the chain/generator as a promise\n * \n * ```js\n * const ticker = asPromise(tick({ interval: 1000 }));\n * const x = await ticker(); //  Waits for 1000ms before giving a value\n * ```\n * \n * This will only ever return one value. To return multiple values, it's necessary\n * to call `asPromise` and `await` the result in a loop.\n * @param valueToWrap \n * @returns \n */\nexport function asPromise<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>) {\n  let lastValue: V | undefined;\n\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  async function asPromise(): Promise<V | undefined> {\n    const v = await outputType.next();\n    if (v.done) return;\n    lastValue = v.value;\n    return lastValue;\n  }\n  return asPromise;\n}","import type { GenFactoryNoInput } from \"./types.js\";\n\n/**\n * Returns the most recent value from the chain/generator, or\n * `initialValue` (defaulting to _undefined_) if no value\n * has been emitted yet.\n * \n * ```js\n * const ticker = asValue(tick({ interval: 1000 }));\n * x = ticker(); // Get the most recent value\n * ```\n * \n * Every time it's called, it fetches a new value from the generator, assuming\n * it isn't already awaiting a result.\n * \n * In the meantime, the last value (or `initialValue`) is returned.\n * @param valueToWrap Value to wrap\n * @param initialValue Initial value\n * @returns \n */\nexport function asValue<V>(valueToWrap: AsyncGenerator<V> | GenFactoryNoInput<V>, initialValue?: V) {\n  let lastValue: V | undefined = initialValue;\n  let awaiting = false;\n  const outputType = (typeof valueToWrap === `function`) ? valueToWrap() : valueToWrap;\n\n  function asValue(): V | undefined {\n    if (!awaiting) {\n      awaiting = true;\n      outputType.next().then(v => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        lastValue = v.value;\n        awaiting = false;\n      }).catch((error: unknown) => {\n        awaiting = false;\n        throw error;\n      });\n    }\n    return lastValue;\n  }\n  return asValue;\n}","import { isEqual } from \"@ixfx/arrays\";\nimport type { GenOrData, GenFactoryNoInput, CombineLatestOptions, Gen } from \"./types.js\";\nimport { resolveToGen } from \"./utility.js\";\n\n/**\n * Monitors sources, storing as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. The default is\n * 'break', meaning the whole combined stream stops.\n * \n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToArray(sources: (GenOrData<any> | GenFactoryNoInput<any>)[], options: Partial<CombineLatestOptions> = {}): AsyncGenerator<any[]> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const afterEmit = options.afterEmit ?? `last`;\n  type InputState = {\n    waiting: Promise<any> | undefined,\n    index: number\n    gen: Gen<any>\n    done: boolean\n    lastValue: any\n  }\n  const inputs = sources.map<InputState>((source, index) => ({ waiting: undefined, index, gen: resolveToGen(source), done: false, lastValue: undefined }));\n\n  const isDone = () => !inputs.some(v => !v.done);\n  const isWaiting = () => inputs.some(v => v.waiting !== undefined);\n  const allEmpty = (d: any[]) => !d.some(v => v !== undefined);\n\n  let lastEmitted: any[] = [];\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while (true) {\n    const promises: Promise<any>[] = [];\n    for (const input of inputs) {\n      //console.log(`  ${ input.index } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n      if (input.done) continue;\n      if (input.waiting !== undefined) {\n        promises.push(input.waiting);\n        continue;\n      }\n      const p = Promise.resolve((async () => {\n        if (input.done) return input;\n        const v = await input.gen.next();\n        input.waiting = undefined;\n        if (v.done) {\n          input.done = true;\n          if (finalValue === `undefined`) input.lastValue = undefined;\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          input.lastValue = v.value;\n        }\n        return input;\n      })());\n      input.waiting = p;\n      promises.push(p);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const won = await Promise.race(promises);\n    if (`done` in won) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (won.done && onSourceDone === `break`) break;\n    } else {\n      throw new Error(`Missing 'done' property`);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    const d = inputs.map(v => v.lastValue);\n    if (d.length === 0) {\n      return;\n    }\n\n    const dataEmpty = allEmpty(d);\n\n    if (dataEmpty && !isWaiting()) {\n      return;\n    }\n\n    if (!isEqual(lastEmitted, d) && !dataEmpty) {\n      lastEmitted = d;\n      yield d;\n    }\n    if (afterEmit === `undefined`) {\n      for (const input of inputs) {\n        if (input.waiting !== undefined) continue;\n        input.lastValue = undefined;\n      }\n    }\n    if (isDone()) {\n      break;\n    }\n  }\n}\n","import { isEqualValueIgnoreOrder } from \"@ixfx/core\";\nimport type { GenOrData, GenFactoryNoInput, CombineLatestOptions, Gen, GenValueTypeObject } from \"./types.js\";\nimport { resolveToGen } from \"./utility.js\";\nimport * as MapFns from \"@ixfx/core/maps\";\n\n/**\n * Monitors sources, storing as they happen to an object.\n * Whenever a new value is emitted, the object is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * If a source completes and onSourceDone = 'allow', the option\n * 'finalValue' sets the logic for what values get returned for the source.\n * By default the setting is 'undefined', thus _undefined_ results. 'last' will be the last (old) value\n * from that source.\n */\nexport async function* combineLatestToObject<const T extends Record<string, GenOrData<any> | GenFactoryNoInput<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}): AsyncGenerator<GenValueTypeObject<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const afterEmit = options.afterEmit ?? `last`;\n  type InputState = {\n    waiting: Promise<any> | undefined\n    gen: Gen<any>\n    done: boolean\n    lastValue: any\n    key: string\n  }\n\n  const states = new Map<string, InputState>();\n  for (const [ key, value ] of Object.entries(sources)) {\n    states.set(key, {\n      gen: resolveToGen(value),\n      done: false,\n      lastValue: undefined,\n      waiting: undefined,\n      key\n    })\n  }\n\n\n  const isDone = () => !MapFns.some(states, v => !v.done);\n\n  const isWaiting = () => MapFns.some(states, v => v.waiting !== undefined);\n  const allEmpty = (d: object) => {\n    for (const v of Object.values(d)) {\n      if (v !== undefined) return false;\n    }\n    return true;\n  }\n\n  const getData = (): GenValueTypeObject<T> => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n      (r as any)[ key ] = state.lastValue;\n    }\n    return r as GenValueTypeObject<T>;\n  }\n  let lastEmitted: GenValueTypeObject<T> | undefined;\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  while (true) {\n    const promises: Promise<any>[] = [];\n    for (const input of states.values()) {\n      //console.log(`  ${ input.key } done: ${ input.done } waiting: ${ input.waiting !== undefined } last: ${ input.lastValue }`);\n      if (input.done) continue;\n      if (input.waiting !== undefined) {\n        promises.push(input.waiting);\n        continue;\n      }\n      const p = Promise.resolve((async () => {\n        if (input.done) return input;\n        const v = await input.gen.next();\n        input.waiting = undefined;\n        if (v.done) {\n          input.done = true;\n          if (finalValue === `undefined`) input.lastValue = undefined;\n        } else {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          input.lastValue = v.value;\n        }\n        return input;\n      })());\n      input.waiting = p;\n      promises.push(p);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const won = await Promise.race(promises);\n    if (`done` in won) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (won.done && onSourceDone === `break`) break;\n    } else {\n      throw new Error(`Result missing 'done' property`);\n    }\n\n\n    const d = getData();\n    //console.log(`d`, d);\n    // if (isEqualValueIgnoreOrder(d, {} as any)) {\n    //   console.log(`keys is empty`);\n    //   return;\n    // }\n\n    const dataEmpty = allEmpty(d);\n    if (dataEmpty && !isWaiting()) {\n      //console.log(`dataEmpty and not waiting`);\n      return;\n    }\n\n    if (!isEqualValueIgnoreOrder(lastEmitted, d) && !dataEmpty) {\n      //console.log(` -- emitting!`);\n      lastEmitted = d;\n      yield d;\n    }\n    if (afterEmit === `undefined`) {\n      for (const input of states.values()) {\n        if (input.waiting !== undefined) continue;\n        input.lastValue = undefined;\n      }\n    }\n    if (isDone()) {\n      break;\n    }\n  }\n}\n","\nimport { func as fromFunction } from \"./from/function.js\";\nimport type { GenOrData, LazyChain, DelayOptions, Link } from \"./types.js\";\nimport { isGenFactoryNoInput, resolveToAsyncGen } from \"./utility.js\";\nimport * as L from './links.js';\nimport type { RankFunction, RankArrayOptions, RankOptions, Interval } from \"@ixfx/core\";\nimport { Async } from \"../index.js\";\n\nconst getLinkName = (c: Link<any, any>): string => {\n  //return c._name;\n  return c._name ?? c.name;\n}\n\nexport function lazy<In, Out>(): LazyChain<In, Out> {\n  const chained: Link<any, any>[] = [];\n  let dataToUse: GenOrData<In> | undefined;\n\n  const asGenerator = <V>(data?: GenOrData<In>) => {\n    if (data === undefined) data = dataToUse;\n    let d = resolveToAsyncGen(data);\n    for (const c of chained) {\n      if (d === undefined) {\n        if (isGenFactoryNoInput<In>(c)) {\n          d = c();\n        } else {\n          throw new Error(`Function '${ getLinkName(c) }' requires input. Provide it to the function, or call 'input' earlier.`)\n        }\n      } else {\n        d = c(d);\n      }\n    }\n    return d as AsyncGenerator<V>\n  }\n\n  const w: LazyChain<In, Out> = {\n    rankArray: (r: RankFunction<In>, options: Partial<RankArrayOptions>): LazyChain<In, Out> => {\n      chained.push(L.rankArray(r, options));\n      return w;\n    },\n    rank: (r: RankFunction<In>, options: Partial<RankOptions>): LazyChain<In, Out> => {\n      chained.push(L.rank(r, options));\n      return w;\n    },\n    transform: (transformer: (v: any) => any) => {\n      chained.push(L.transform(transformer));\n      return w;\n    },\n    reduce: (reducer: (values: any[]) => any) => {\n\n      chained.push(L.reduce(reducer));\n      return w;\n    },\n    drop: (predicate: (v: In) => boolean) => {\n      chained.push(L.drop(predicate));\n      return w;\n    },\n    delay: (options: DelayOptions) => {\n      chained.push(L.delay(options));\n      return w;\n    },\n    duration: (elapsed: Interval) => {\n      chained.push(L.duration(elapsed));\n      return w;\n    },\n    debounce: (rate: Interval) => {\n      chained.push(L.debounce(rate));\n      return w;\n    },\n    fromFunction: (callback: () => any) => {\n      chained.push(fromFunction(callback));\n      return w;\n    },\n    take: (limit: number) => {\n      chained.push(L.take(limit));\n      return w;\n    },\n    chunk: (size: number, returnRemainders = true) => {\n      chained.push(L.chunk(size, returnRemainders))\n      return w;\n    },\n    filter: (predicate: (input: any) => boolean) => {\n      chained.push(L.filter(v => predicate(v)));\n      return w;\n    },\n    min: (): LazyChain<any, number> => {\n      chained.push(L.min());\n      return w as unknown as LazyChain<any, number>;\n    },\n    max: (): LazyChain<any, number> => {\n      chained.push(L.max());\n      return w as unknown as LazyChain<any, number>;\n    },\n    average: (): LazyChain<any, number> => {\n      chained.push(L.average());\n      return w as unknown as LazyChain<any, number>;\n    },\n    sum: (): LazyChain<any, number> => {\n      chained.push(L.sum());\n      return w as unknown as LazyChain<any, number>;\n    },\n    tally: (countArrayItems: boolean): LazyChain<any, number> => {\n      chained.push(L.tally(countArrayItems));\n      return w as unknown as LazyChain<any, number>;\n    },\n    input(data: GenOrData<In>) {\n      dataToUse = data;\n      return w\n    },\n    asGenerator,\n    asAsync(data?: GenOrData<In>) {\n      let d = data ?? dataToUse;\n      for (const c of chained) {\n        if (d === undefined && isGenFactoryNoInput<In>(c)) {\n          d = c();\n        } else if (d === undefined) {\n          throw new Error(`Function '${ getLinkName(c) }' needs input. Pass in data calling 'asAsync', or call 'input' earlier`);\n        } else {\n          d = c(d);\n        }\n      }\n      return w;\n    },\n    asArray: async (data?: GenOrData<In>): Promise<Out[]> => {\n      const g = asGenerator<Out>(data);\n      return await Async.toArray<Out>(g);\n    },\n    firstOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      const v = await g.next();\n      return v.value as Out;\n    },\n    lastOutput: async (data?: GenOrData<In>): Promise<Out | undefined> => {\n      const g = asGenerator<Out>(data);\n      let lastValue: Out | undefined;\n      for await (const v of g) {\n        lastValue = v as Out;\n      }\n      return lastValue;\n    },\n  }\n  return w as unknown as LazyChain<In, Out>;\n}","export class QueueMutable<V> {\n  #store: V[] = [];\n\n  enqueue(data: V) {\n    this.#store.push(data);\n  }\n\n  dequeue(): V | undefined {\n    return this.#store.shift();\n  }\n}","import { sleep } from \"@ixfx/core\";\nimport { QueueMutable } from \"../util/queueMutable.js\";\nimport type { GenFactoryNoInput, GenOrData } from \"./types.js\";\nimport { resolveToAsyncGen } from \"./utility.js\";\n/**\n * Merge values from several sources into one stream, interleaving values.\n * When all streams are complete it finishes.\n * \n * Alternatively:\n * - {@link combineLatestToArray}/{@link combineLatestToObject} emits snapshots of all the generators, as quickly as the fastest one\n * - {@link syncToArray}/{@link syncToObject} which releases a set of results when all inputs have emitted a value\n * @param sources \n */\nexport async function* mergeFlat<Out>(...sources: (GenOrData<any> | GenFactoryNoInput<any>)[]): AsyncGenerator<Out> {\n  const sourcesInput = sources.map(source => resolveToAsyncGen(source));\n  const buffer = new QueueMutable<Out>();\n  let completed = 0;\n\n  const schedule = async (source: AsyncGenerator<any> | undefined) => {\n    if (source === undefined) {\n      completed++;\n      return;\n    }\n\n    const x = await source.next();\n    if (x.done) {\n      completed++;\n    } else {\n      buffer.enqueue(x.value as Out);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(() => schedule(source), 1);\n    }\n  }\n\n  for (const source of sourcesInput) {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(() => schedule(source), 1);\n  }\n\n  const loopSpeed = 10;\n  let loopFactor = 1;\n  while (completed < sourcesInput.length) {\n    const d = buffer.dequeue();\n    if (d === undefined) {\n      // Grow loop factor up to 10\n      loopFactor = Math.min(loopFactor + 1, 10);\n    } else {\n      yield d;\n      // Reset loop factor\n      loopFactor = 1;\n    }\n    await sleep(loopSpeed * loopFactor);\n  }\n}","import type { LinksWithSource, Gen, GenOrData, GenFactoryNoInput, Link } from \"./types.js\";\nimport { resolveToGen } from \"./utility.js\";\n\n/**\n * Chain functions together. First argument is the source.\n * `runN` takes any number of chain functions. Use {@link run} if\n * possible, because it has improved type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.runN(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform<string, number>(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * \n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n * \n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param functions \n * @returns \n */\nexport async function* runN<In, Out>(...functions: LinksWithSource<In, Out>): AsyncGenerator<Out> {\n  let input: Gen<In> | undefined;\n  for (const fnOrData of functions) {\n    input = typeof fnOrData === `function` ? fnOrData(input ?? []) : resolveToGen(fnOrData);\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v as Out;\n  }\n}\n\nexport function run<T1>(gen: GenOrData<T1> | GenFactoryNoInput<T1>): AsyncGenerator<T1>;\nexport function run<T1, T2>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>): AsyncGenerator<T2>;\nexport function run<T1, T2, T3>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>): AsyncGenerator<T3>;\nexport function run<T1, T2, T3, T4>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>): AsyncGenerator<T4>;\nexport function run<T1, T2, T3, T4, T5>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>): AsyncGenerator<T5>;\nexport function run<T1, T2, T3, T4, T5, T6>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>): AsyncGenerator<T6>;\nexport function run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0: Link<T1, T2>, l1: Link<T2, T3>, l2: Link<T3, T4>, l3: Link<T4, T5>, l4: Link<T5, T6>, l5: Link<T6, T7>): AsyncGenerator<T7>;\n\n/**\n * Chain functions together. First argument is the source.\n * Use {@link runN} if you want to chain more links than is possible here,\n * at the cost of poorer type hinting.\n * \n * @example Process an array of strings. Transforming into\n * integers, and then filtering only even numbers.\n * ```js\n * const ch = Chains.run(\n *  [ `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10` ],\n *  Chains.transform(v => Number.parseInt(v)),\n *  Chains.filter(v => v % 2 === 0)\n *);\n * const output = await Async.toArray(ch2);\n * // [ 2, 4, 6, 8, 10 ]\n * ```\n * \n * @example Grab the x/y coordinate from pointermove\n * ```js\n * const c1 = Chains.run(\n *  Chains.fromEvent(window, `pointermove`),\n *  Chains.Links.transform(event => ({ x: event.x, y: event.y }))\n * );\n * \n * // Eg: print out data as it comes in\n * Iterables.forEach(c1, coord => {\n *   console.log(coord);\n * });\n * // Execution continues immediately\n * ```\n * @param gen \n * @param l0 \n * @param l1 \n * @param l2 \n * @param l3 \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport async function* run<T1, T2, T3, T4, T5, T6, T7>(gen: GenOrData<T1> | GenFactoryNoInput<T1>, l0?: Link<T1, T2>, l1?: Link<T2, T3>, l2?: Link<T3, T4>, l3?: Link<T4, T5>, l4?: Link<T5, T6>, l5?: Link<T6, T7>): AsyncGenerator<T1> {\n  let input: Gen<any> | undefined;\n  // eslint-disable-next-line prefer-rest-params\n  const functions = arguments;\n  for (const fnOrData of functions) {\n\n    if (typeof fnOrData === `function`) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-assignment\n      input = fnOrData(input ?? []);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      input = resolveToGen(fnOrData);\n    }\n  }\n  if (input === undefined) return;\n  for await (const v of input) {\n    yield v;\n  }\n}\n","import { runN } from \"./run.js\";\nimport type { GenFactoryNoInput, GenOrData, Links } from \"./types.js\";\n\n/**\n * Prepare a chain, allowing you to provide a source at execution time.\n * ```js\n * const chain = Chains.prepare(\n *  Chains.transform<string,number>( v => Number.parseInt(v) ),\n *  Chains.filter<number>(v => v % 2 === 0)\n * );\n *\n * // Run it with provided source\n * for await (const v of chain([`1`, `2`, `3`])) {\n *\n * }\n * ```\n * @param functions\n * @returns\n */\nexport function prepare<In, Out>(...functions: Links<In, Out>) {\n  const r = (source: GenOrData<In> | GenFactoryNoInput<In>) => {\n    return runN<In, Out>(source, ...functions);\n  }\n  return r;\n}\n\n// const chain = combine(\n//   Chains.Links.transform(v => Number.parseInt(v)),\n//   Chains.Links.filter(v => v % 2 === 0)\n// );\n// const read = chain(Chains.From.array([ 1, 2, 3 ], 100));\n","import type { Link } from \"./types.js\";\n\n/**\n * Input a single value to the chain, return a single result\n * \n * \n * ```js\n * // Create chain link\n * const f = Chains.Links.flatten<string, string>(data => data.join(`-`));\n * // Input a single value (an array)\n * const r1 = await Chains.single(f, [ `a`, `b`, `c` ]);\n * // r1 = `a-b-c`\n * ```\n * @param f \n * @param input \n * @returns \n */\nexport async function single<In, Out>(f: Link<In, Out>, input: In): Promise<Out | undefined> {\n  const iterator = await f([ input ]).next();\n  return iterator.value as Out | undefined;\n}","\nimport { intervalToMs, type SleepOpts } from \"@ixfx/core\";\nimport * as Async from \"../async.js\";\nimport type { GenOrData, GenFactoryNoInput, SyncOptions } from \"./types.js\";\nimport { resolveToGen } from \"./utility.js\";\n\n// export function syncToObject<const T extends Record<string, GenOrData<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): AsyncGenerator<GenValueTypeObject<T>> {\n//   const keys = Object.keys(reactiveSources)\n//   const values = Object.values(reactiveSources);\n\n//   const s = syncToArray(values, options);\n//   const st = transform(s, (streamValues) => {\n//     return zipKeyValue(keys, streamValues);\n//   });\n//   return st as AsyncGenerator<GenValueTypeObject<T>>;\n// }\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and \n * source C is still producing values, synchronisation is not possible \n * because A & B stopped producing values. Thus the stream will terminate\n * after `maximumWait` (2 seconds). Newer values from C are lost.\n */\nexport async function* syncToArray(sources: (GenOrData<any> | GenFactoryNoInput<any>)[], options: Partial<SyncOptions> = {}): AsyncGenerator<any[]> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  //const ac = new AbortController();\n  const maximumWaitMs = intervalToMs(options.maximumWait, 2000);\n  const finalValue = options.finalValue ?? `undefined`;\n  const inputs = sources.map(source => ({ seq: 0, lastValue: undefined, gen: resolveToGen(source), done: false }));\n  const nextWithTimeoutOpts: SleepOpts<any> = {\n    millis: maximumWaitMs\n  };\n  let seq = 0;\n  const isAllDone = () => !inputs.some(v => !v.done);\n  let go = true;\n  while (go) {\n    seq++;\n    for (const input of inputs) {\n      if (input.done) {\n        input.seq = seq;\n        continue;\n      }\n      // Read source, with a timeout\n      const v = await Async.nextWithTimeout(input.gen, nextWithTimeoutOpts);\n\n      // Input has finished\n      if (v.done) {\n        input.done = true;\n        input.seq = seq;\n        if (finalValue === `undefined`) {\n          input.lastValue = undefined;\n        }\n        if (onSourceDone === `break`) {\n          return;\n        }\n      } else {\n        // Stash away value\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        input.lastValue = v.value;\n        input.seq = seq;\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (go) {\n      // Return the set of data\n      const d = inputs.filter(v => v.seq === seq).map(v => v.lastValue);\n      if (d.length === 0) return;\n      if (!d.some(v => typeof v !== `undefined`)) return;\n      yield d;\n    }\n    if (isAllDone()) go = false;\n  }\n  // let somethingProduced = true;\n\n  // while (somethingProduced) {\n  //   let data = [];\n  //   for (let index = 0; index < sourcesInput.length; index++) {\n  //     // eslint-disable-next-line unicorn/no-null\n  //     data[ index ] = null;\n  //   }\n\n  //   somethingProduced = false;\n  //   // Request the next value from each source\n  //   for (const [ index, source ] of sourcesInput.entries()) {\n  //     const v = await source.next();\n  //     if (!v.done) {\n  //       data[ index ] = v.value;\n  //       somethingProduced = true;\n  //     }\n  //   }\n  //   if (somethingProduced) {\n  //     // Send data\n  //     yield data;\n  //     data = [];\n  //   }\n  // }\n}","export * as Dom from './dom.js';\nexport * as Links from './links.js';\nexport * as From from './from/index.js';\n\nexport * from './add-to-array.js';\nexport * from './as-array.js';\nexport * from './as-callback.js';\nexport * from './as-promise.js';\nexport * from './as-value.js';\nexport * from './combine-latest-to-array.js';\nexport * from './combine-latest-to-object.js';\nexport * from './lazy.js';\nexport * from './merge-flat.js';\nexport * from './prepare.js';\nexport * from './run.js';\nexport * from './single.js';\nexport * from './sync.js';\nexport * from './types.js';\nexport * from './utility.js';\n\n","import { compareIterableValuesShallow, isEqualDefault, type IsEqual } from \"@ixfx/core\";\n\n/**\n * Returns the 'max' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer \n * @returns \n */\nexport const maxScore = <V>(iterable: Iterable<V>, scorer: (v: V) => number): V | undefined => {\n  let highestValue: V | undefined;\n  let highestScore = Number.MIN_SAFE_INTEGER;\n  for (const value of iterable) {\n    const score = scorer(value);\n    if (score >= highestScore) {\n      highestScore = score;\n      highestValue = value;\n    }\n  }\n  return highestValue;\n}\n\n/**\n * Returns the 'min' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable \n * @param scorer \n * @returns \n */\nexport const minScore = <V>(iterable: Iterable<V>, scorer: (v: V) => number): V | undefined => {\n  let lowestValue: V | undefined;\n  let lowestScore\n    = Number.MAX_SAFE_INTEGER;\n  for (const value of iterable) {\n    const score = scorer(value);\n    if (score <= lowestScore) {\n      lowestScore = score;\n      lowestValue = value;\n    }\n  }\n  return lowestValue;\n}\n\n\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n * \n * Is NOT recursive.\n * \n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * hasEqualValuesShallow(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * hasEqualValuesShallow(a, b); \n * // True, since now we're comparing by value\n * hasEqualValuesShallow(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param iterableA First iterable to check\n * @param iterableB Iterable to compare against\n * @param eq Equality function, uses === by default\n */\nexport const hasEqualValuesShallow = <V>(\n  iterableA: Iterable<V>,\n  iterableB: Iterable<V>,\n  eq?: IsEqual<V>\n): boolean => {\n  const returnValue = compareIterableValuesShallow(iterableA, iterableB, eq);\n  return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n\n","import { intervalToMs } from \"@ixfx/core\"\nimport type { IteratorControllerState, IteratorControllerOptions } from \"./types.js\"\nimport { continuously } from \"@ixfx/core/continuously\";\n\nexport type IteratorController = {\n  get state(): IteratorControllerState\n  /**\n   * Starts 'playback' of the iterator.\n   * If already started, this does nothing.\n   * If paused, continues playback.\n   * Use {@link restart} if you want to start with a reset.\n   * @returns \n   */\n  start: () => void\n  /**\n   * Starts or restarts 'playback' of the iterator.\n   * @returns \n   */\n  restart: () => void\n  /**\n   * Pauses 'playback' of the iterator.\n   * If already paused, does nothing.\n   * Use {@link start} to resume.\n   * @returns \n   */\n  pause: () => void\n  /**\n   * Cancels the running timer. This will\n   * stop playback, and next time {@link start}\n   * is called, it will be from the beginning.\n   * @returns \n   */\n  cancel: () => void\n}\n\n/**\n * Retrieve values from an iterator, passing them to a callback.\n * Allows iterator to be started, paused, or restarted and an optional delay between reading items from iterator.\n * @param options \n * @returns \n */\nexport const iteratorController = <T>(options: IteratorControllerOptions<T>): IteratorController => {\n  const delayMs = intervalToMs(options.delay, 10);\n  let gen: AsyncGenerator<T> | IterableIterator<T> | undefined;\n  const onValue = options.onValue;\n  let state: IteratorControllerState = `stopped`;\n\n  const loop = continuously(async () => {\n    if (gen) {\n      const r = await gen.next();\n      if (r.done) {\n        state = `stopped`;\n        return false;\n      }\n      const r2 = onValue(r.value);\n      if (typeof r2 === `boolean`) {\n        if (!r2) {\n          state = `stopped`;\n        }\n        return r2;\n\n      }\n      return true;\n    } else {\n      state = `stopped`\n      return false;\n    }\n  }, delayMs);\n\n  const cancel = () => {\n    if (state === `stopped`) return;\n    gen = undefined;\n    loop.cancel();\n    state = `stopped`;\n  }\n\n  const pause = () => {\n    if (state === `paused`) return;\n    loop.cancel();\n    state = `paused`;\n  }\n\n  const start = () => {\n    if (state === `running`) return;\n    if (!gen) {\n      remake();\n    }\n    state = `running`;\n    loop.start();\n  }\n\n  const remake = () => {\n    if (options.iterator) {\n      gen = options.iterator();\n    } else {\n      throw new Error(`No source iterator`);\n    }\n  }\n  const restart = () => {\n    remake();\n    start();\n  }\n\n  return {\n    start, cancel, restart, pause,\n    get state() {\n      return state\n    }\n  }\n}","import type { WithEvents } from \"./types.js\";\n\nexport const fromEvent = <V>(\n  eventSource: WithEvents,\n  eventType: string\n): AsyncIterator<any> => {\n  const pullQueue: Array<any> = [];\n  const pushQueue: Array<any> = [];\n  let done = false;\n  const pushValue = (args: any) => {\n    if (pullQueue.length > 0) {\n      //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const resolver = pullQueue.shift();\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      resolver(...args);\n    } else {\n      pushQueue.push(args);\n    }\n  };\n\n  const pullValue = (): Promise<V> =>\n    new Promise<V>((resolve) => {\n      if (pushQueue.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const arguments_ = pushQueue.shift();\n        // @ts-expect-error\n        resolve(...arguments_);\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const handler = (...arguments_: any) => {\n    pushValue(arguments_);\n  };\n\n  eventSource.addEventListener(eventType, handler);\n\n  const r: AsyncIterator<V> = {\n    next: async (): Promise<IteratorResult<V>> => {\n      if (done) return { done: true, value: undefined };\n      return {\n        done: false,\n        value: await pullValue(),\n      };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    return: async (): Promise<IteratorResult<V>> => {\n      done = true;\n      eventSource.removeEventListener(eventType, handler);\n      return { done: true, value: undefined };\n    },\n    //eslint-disable-next-line @typescript-eslint/require-await\n    throw: async (error: any): Promise<IteratorResult<V>> => {\n      done = true;\n      return {\n        done: true,\n        value: Promise.reject(new Error(error)),\n      };\n    },\n  };\n  return r;\n};","import { numberArrayCompute, type NumbersComputeOptions, type NumbersComputeResult } from \"@ixfx/numbers\";\nimport { isIterable } from \"./guard.js\";\n\n\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * const v = [ 10, 2, 4.2, 99 ];\n * const mma = numbersCompute(v);\n * // Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link @ixfx/numbers.average}, {@link @ixfx/numbers.max}, {@link @ixfx/numbers.min} or {@link @ixfx/numers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * import { count } from '@ixfx/numbers';\n * numbersCompute(count(5,1)); // Averages 1,2,3,4,5\n * ```\n * \n * Returns `NaN` if the input data is empty.\n * @param data\n * @param options Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const numbersCompute = (\n  data: readonly number[] | number[] | Iterable<number>,\n  options: NumbersComputeOptions = {}\n): NumbersComputeResult => {\n  if (typeof data === `undefined`) throw new Error(`Param 'data' is undefined`);\n  if (Array.isArray(data)) {\n    return numberArrayCompute(data, options);\n  }\n  if (isIterable(data)) {\n    return numbersComputeIterable(data, options);\n  }\n  throw new Error(`Param 'data' is neither an array nor iterable`);\n};\n\n\nfunction numbersComputeIterable(data: Iterable<number>, options: NumbersComputeOptions = {}): NumbersComputeResult {\n  // if (typeof options.startIndex !== `undefined` || typeof options.endIndex !== `undefined`) {\n  //   data = slice(data, options.startIndex, options.endIndex);\n  // }\n  let total = 0;\n  const nonNumbers = options.nonNumbers ?? `ignore`;\n\n  let min = Number.MAX_SAFE_INTEGER;\n  let max = Number.MIN_SAFE_INTEGER;\n  let count = 0;\n  for (let v of data) {\n    if (typeof v !== `number` || Number.isNaN(v)) {\n      if (nonNumbers === `throw`) throw new TypeError(`Data contains something not a number. Got type '${ typeof v }'`);\n      if (nonNumbers === `nan`) v = Number.NaN;\n      if (nonNumbers === `ignore`) continue;\n    }\n\n    total += v;\n    count++;\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n  }\n  return {\n    avg: total / count,\n    total, max, min, count\n  };\n}\n\nexport function computeAverage(data: Iterable<number>, options: NumbersComputeOptions = {}): number {\n  let count = 0;\n  let total = 0;\n  const nonNumbers = options.nonNumbers ?? `ignore`;\n\n  for (let d of data) {\n    if (typeof d !== `number` || Number.isNaN(d)) {\n      if (nonNumbers === `throw`) throw new TypeError(`Data contains something not a number. Got type '${ typeof d }'`);\n      if (nonNumbers === `nan`) d = Number.NaN;\n      if (nonNumbers === `ignore`) continue;\n    }\n    total += d;\n    count++;\n  }\n  return total / count;\n}","import * as Async from './async.js';\nimport * as Sync from './sync.js';\nexport * as Async from './async.js';\nexport * as Sync from './sync.js';\nexport * as Chains from './chain/index.js';\n\nexport { combineLatestToArray } from './chain/combine-latest-to-array.js';\nexport { combineLatestToObject } from './chain/combine-latest-to-object.js';\n\nexport * from './compare-values.js';\nexport * from './controller.js';\nexport * from './from-event.js';\nexport * from './guard.js';\nexport * from './types.js';\n\nimport { isAsyncIterable } from './guard.js';\n//import * as Chains from './chain/index.js';\n// import type { Interval } from '../flow/IntervalType.js';\n\nimport { toStringDefault } from '@ixfx/core';\nimport type { Interval } from '@ixfx/core';\n\n//import type { GenFactoryNoInput } from './chain/Types.js';\nimport type { ForEachOptions, ToArrayOptions, IteratorControllerOptions, IteratorControllerState } from './types.js';\n\nexport * from './numbers-compute.js';\n\nexport function min<V>(it: AsyncIterable<V>, gt?: (a: V, b: V) => boolean): AsyncGenerator<V>;\nexport function min<V>(it: Iterable<V>, gt?: (a: V, b: V) => boolean): Generator<V>;\n\n\n/**\n * Returns a stream of minimum values.\n * \n * Streaming result: works with endless iterables.\n * \n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min<V>(it: AsyncIterable<V> | Iterable<V>, gt = (a: V, b: V) => a > b): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n\nexport function max<V>(it: AsyncIterable<V>, gt?: (a: V, b: V) => boolean): AsyncGenerator<V>;\nexport function max<V>(it: Iterable<V>, gt?: (a: V, b: V) => boolean): Generator<V>;\n\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n * \n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max<V>(it: AsyncIterable<V> | Iterable<V>, gt = (a: V, b: V) => a > b): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n\nexport function dropWhile<V>(it: AsyncIterable<V>, f: (v: V) => boolean): AsyncGenerator<V>;\nexport function dropWhile<V>(it: Iterable<V>, f: (v: V) => boolean): Generator<V>;\n\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n * \n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n\nexport function until(it: AsyncIterable<any>, f: () => Promise<boolean> | Promise<undefined>): Promise<undefined>;\nexport function until(it: Iterable<any>, f: () => boolean | never): void;\nexport function until(it: Iterable<any>, f: () => Promise<boolean>): Promise<undefined>;\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* \n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it: AsyncIterable<any> | Iterable<any>, callback: () => Promise<boolean> | never | boolean | Promise<undefined>): Promise<undefined> | undefined {\n  if (isAsyncIterable(it)) {\n    return Async.until(it, callback);\n  } else {\n    Sync.until(it, callback as (() => boolean));\n  }\n}\n\n\nexport function chunks<V>(it: Iterable<V>, size: number): Generator<V[]>;\nexport function chunks<V>(it: AsyncIterable<V>, size: number): AsyncGenerator<V[]>;\n\n/**\n * Breaks an iterable into array chunks\n * \n * Streaming: works with infinite iterables.\n * \n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks<V>(it: AsyncIterable<V> | Iterable<V>, size: number): Generator<V[]> | AsyncGenerator<V[]> {\n  return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n\nexport function filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): AsyncGenerator<V>;\nexport function filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean): Generator<V>;\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * \n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean | Promise<boolean>): AsyncGenerator<V> | Generator<V> {\n\n  return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f as (v: V) => boolean);\n}\n\n\nexport function fill<V>(it: AsyncIterable<V>, v: V): AsyncGenerator<V>;\nexport function fill<V>(it: Iterable<V>, v: V): Generator<V>;\n\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n * \n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill<V>(it: AsyncIterable<V> | Iterable<V>, v: V): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n\nexport function concat<V>(...its: Iterable<V>[]): Generator<V>;\nexport function concat<V>(...its: AsyncIterable<V>[]): AsyncGenerator<V>;\n\n\n/**\n * Return concatenation of iterators.\n * \n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat<V>(...its: Iterable<V>[] | AsyncIterable<V>[]): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(its[ 0 ]) ? Async.concat(...its as AsyncIterable<V>[]) : Sync.concat(...its as Iterable<V>[]);\n}\n\nexport function find<V>(it: V[] | Iterable<V>, f: (v: V) => boolean): V | undefined;\nexport function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<V | undefined>;\n\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n * \n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find<V>(it: V[] | Iterable<V> | AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<V | undefined> | V | undefined {\n\n  return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f as (v: V) => boolean);\n}\n\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n * \n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach<T>(it: T[] | AsyncIterable<T> | Iterable<T>, fn: (v: T | undefined) => boolean | Promise<boolean> | void | Promise<void>, options: Partial<ForEachOptions> = {}) {\n  if (isAsyncIterable(it)) {\n    return Async.forEach(it, fn, options);\n  } else {\n    Sync.forEach(it, fn as (v: T) => boolean);\n  }\n}\n\nexport function map<V, X>(it: AsyncIterable<V>, f: (v: V) => Promise<X> | X): Generator<X>;\nexport function map<V, X>(it: V[] | Iterable<V>, f: (v: V) => X): Generator<X>;\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map<V, X>(it: V[] | AsyncIterable<V> | Iterable<V>, f: (v: V) => X | Promise<X>) {\n  return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n\nexport function fromArray<V>(array: V[], interval: Interval): AsyncGenerator<V>;\nexport function fromArray<V>(array: V[]): Generator<V>;\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray<V>(array: V[], interval?: Interval): AsyncGenerator<V> | Generator<V> {\n  return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n\nexport function flatten<V>(it: AsyncIterable<V[] | V>): AsyncIterable<V>;\nexport function flatten<V>(it: Iterable<V[] | V> | V[]): Iterable<V>;\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten<V>(it: V[] | AsyncIterable<V | V[]> | Iterable<V | V[]>): AsyncIterable<V> | Iterable<V> {\n  return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n\nexport function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean>\nexport function some<V>(it: Iterable<V> | V[], f: (v: V) => boolean): boolean\n\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean | Promise<boolean>): boolean | Promise<boolean> {\n  return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f as (v: V) => boolean);\n}\n\nexport function last<V>(it: AsyncIterable<V>): Promise<V | undefined>\nexport function last<V>(it: Iterable<V>): V\n\n/**\n * Returns the last item of an iterable, or _undefined_ if it yields no results.\n * @param it \n * @returns \n */\nexport function last<V>(it: AsyncIterable<V> | Iterable<V>): undefined | V | Promise<V | undefined> {\n  return isAsyncIterable(it) ? Async.last(it) : Sync.last(it);\n}\n\nexport function reduce<V>(it: AsyncIterable<V>, f: (accumulator: V, current: V) => V, start: V): Promise<V>;\nexport function reduce<V>(it: Iterable<V> | V[], f: (accumulator: V, current: V) => V, start: V): V;\n\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce<V>(it: AsyncIterable<V> | Iterable<V> | V[], f: (accumulator: V, current: V) => V, start: V): Promise<V> | V {\n  return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n\nexport function slice<V>(it: AsyncIterable<V>, start?: number, end?: number): AsyncGenerator<V>;\nexport function slice<V>(it: Iterable<V> | V[], start?: number, end?: number): Generator<V>;\n/**\n * Returns a section from an iterable.\n * \n * 'end' is the end index, not the number of items.\n * \n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice<V>(\n  it: Iterable<V> | AsyncIterable<V> | V[],\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, start, end);\n}\n\nexport function unique<V>(iterable: Iterable<V> | Iterable<V>[]): Generator<V>;\nexport function unique<V>(iterable: AsyncIterable<V> | AsyncIterable<V>[]): AsyncGenerator<V>;\n\n\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique<V>(iterable: V[] | AsyncIterable<V> | Iterable<V> | Iterable<V>[] | AsyncIterable<V>[]): Generator<V> | AsyncGenerator<V> {\n  if (Array.isArray(iterable)) {\n    if (iterable.length === 0) return Sync.fromArray([]);\n    return isAsyncIterable(iterable[ 0 ]) ? Async.unique(iterable as AsyncIterable<V>[]) : Sync.unique(iterable as Iterable<V>[]);\n  } else if (isAsyncIterable(iterable)) {\n    return Async.unique(iterable);\n  } else {\n    return Sync.unique(iterable);\n  }\n}\n\nexport function uniqueByValue<T>(input: Iterable<T> | T[], toString: (v: T) => string, seen?: Set<string>): Generator<T>;\nexport function uniqueByValue<T>(input: AsyncIterable<T>, toString: (v: T) => string, seen?: Set<string>): AsyncGenerator<T>;\n\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n * \n * Streaming: Works with unbounded iterables.\n * \n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n * \n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n * \n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n * \n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n * \n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n * \n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input \n * @param seen \n * @param toString \n */\nexport function* uniqueByValue<T>(input: AsyncIterable<T> | Iterable<T> | T[], toString: (v: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> | AsyncGenerator<T> {\n  yield* isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n\nexport function toArray<V>(it: AsyncIterable<V>, options?: Partial<ToArrayOptions>): Promise<V[]>;\nexport function toArray<V>(it: Iterable<V>, options?: Partial<ToArrayOptions>): V[];\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\n\nexport function toArray<V>(it: Iterable<V> | AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): V[] | Promise<V[]> {\n  return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n\nexport function every<V>(it: Iterable<V> | V[], f: (v: V) => boolean): boolean\nexport function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean>\n\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n * \n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every<V>(it: Iterable<V> | V[] | AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n  return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f as (v: V) => boolean);\n}\n\nexport function equals<V>(it1: AsyncIterable<V>, it2: AsyncIterable<V>, equality?: (a: V, b: V) => boolean): Promise<boolean>\nexport function equals<V>(it1: IterableIterator<V>, it2: IterableIterator<V>, equality?: (a: V, b: V) => boolean): boolean\n\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(it1: AsyncIterable<V> | IterableIterator<V>, it2: AsyncIterable<V> | IterableIterator<V>, equality?: (a: V, b: V) => boolean) {\n  const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n  return as ? Async.equals(it1, it2, equality) : Sync.equals(it1 as IterableIterator<V>, it2 as IterableIterator<V>, equality);\n}\n\nexport function zip<V>(...its: readonly AsyncIterable<V>[]): Generator<V[]>;\nexport function zip<V>(...its: readonly Iterable<V>[]): Generator<V>;\n\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip<V>(...its: readonly AsyncIterable<V>[] | readonly Iterable<V>[]) {\n  if (its.length === 0) return Sync.fromArray([]);\n  return isAsyncIterable(its[ 0 ]) ? Async.zip(...its as readonly AsyncIterable<V>[]) : Sync.zip(...its as readonly Iterable<V>[]);\n}\n\nexport function fromIterable<V>(iterable: Iterable<V>): Generator<V>\nexport function fromIterable<V>(iterable: AsyncIterable<V> | Iterable<V>, interval: Interval): AsyncGenerator<V>\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield \n */\nexport function fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval?: Interval): AsyncGenerator<V> | Generator<V> {\n  if (isAsyncIterable(iterable) || interval !== undefined) return Async.fromIterable(iterable, interval);\n  return Sync.fromIterable(iterable);\n}\n\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction<T>(callback: () => T) {\n  while (true) {\n    const v = callback();\n    yield v;\n  }\n}\n\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback \n */\nexport async function* fromFunctionAwaited<T>(callback: () => Promise<T> | T) {\n  while (true) {\n    const v = await callback();\n    yield v;\n  }\n}\n\n\n/**\n * Calls `callback` whenever the generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport function asCallback<V>(input: AsyncIterable<V> | Iterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  if (isAsyncIterable(input)) {\n    return Async.asCallback(input, callback);\n  } else {\n    Sync.asCallback(input, callback); return;\n  }\n}\n\n"],"mappings":"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"}