{"version":3,"file":"visual.js","names":["clamp","rect","rect","isEqual","PointsIsEqual","rect","peek","isEmpty","isFull","isEmpty","isFull","peek","#data","isEqual","toCartesian","polarToCartesian","line","piPi","PointsSubtract","PointsDistance","line","LinesGuard","Empty","Placeholder","LineLength","LinesEmpty","PointsPlaceholder","grid","grid","grid","wrap","grid","wrap","grid","grid","grid","wrap","guard","PointsGuard","scaler","PlaceholderRect","corners","guard","#el","#containerEl","#stretch","#onSizeChanging","#size","#sizeDebounce","#naturalRatio","#naturalSize","#viewport","#byViewport","#byContainer","#disposed","#resizeObservable","el","#onParentResize","#computeSizeBasedOnParent","#onViewportResize","multiplyOpacity","withOpacity","canvasElementContextOrQuery: CanvasContextQuery","makeHelper","ctxOrCanvasEl: CanvasContextQuery","canvasBounds?: Rects.Rect","pathsToDraw: Paths.Path[] | readonly Paths.Path[]","opts?: DrawingOpts","lineToDraw: Lines.Line | Lines.Line[]","line","rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts?: RectOpts","bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier","pointsToDraw: Points.Point[]","opts?: DrawingOpts & Partial<ConnectedPointsOptions>","dotPosition: Points.Point | Points.Point[]","opts?: DotOpts","circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[]","opts: DrawingOpts","circle","arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[]","lines: string[]","opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }","applyOpts","ctx: CanvasRenderingContext2D","arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[]","arc: Arcs.ArcPositioned","arc","arcsArray: Arcs.ArcPositioned[]","strokeStyle: string | CanvasGradient | CanvasPattern | undefined","fillStyle: string | CanvasGradient | CanvasPattern | undefined","lineWidth: number | undefined","lineJoin: CanvasLineJoin | undefined","lineCap: CanvasLineCap | undefined","stk?: IStackImmutable<StackOp>","push","pop","points: readonly Points.Point[]","circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[]","c: Circles.CirclePositioned","ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[]","ellipse: Ellipses.EllipsePositioned","ellipse","pathsToDraw: readonly Paths.Path[] | Paths.Path","opts: { readonly strokeStyle?: string; readonly debug?: boolean }","path: Paths.Path","path","pts: readonly Points.Point[]","opts: Partial<ConnectedPointsOptions>","opts: { readonly fillStyle?: string }","labels?: readonly string[]","point: Points.Point","canvasEl: HTMLCanvasElement","pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned","pos","bezierToDraw: Beziers.CubicBezier","bezierToDraw: Beziers.QuadraticBezier","toDraw: Lines.Line | readonly Lines.Line[]","opts: LineOpts & DrawingOpts","d: Lines.Line","toDraw: Triangles.Triangle | readonly Triangles.Triangle[]","opts: DrawingOpts & { readonly filled?: boolean }","t: Triangles.Triangle","toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts: RectOpts","d: Rects.RectPositioned | Rects.Rect","text?: string | null","widthMultiple?: number","rect","text","lines: readonly string[]","opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }","text: readonly string[] | string","opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }","v: any","a: number","b: number","value: number","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","changeLightness","value: Hsl","amount: Partial<{ pdelta: number, delta: number, fixed: number }>","hsl: Hsl","value: number","property: `l` | `h` | `s`","fromHexString","hexString: string","options: ParsingOptions<Hsl>","fromLibrary","fromCss","value: string","options: Partial<ParsingOptions<Hsl>>","rgbToLibraryHsl","toScalar","toAbsolute","hsl: C.HSL","parsingOptions: ParsingOptions<T>","absolute","hslOrString: Hsl | Rgb | string","guard","generateScalar","absoluteHslOrVariable: string | number | Angle","lightness","hslOrString: Rgb | Hsl | string","interpolator","a: Hsl | string","b: Hsl | string","direction: `longer` | `shorter`","amount: number","hsl: HslScalar","hsl: HslAbsolute","v: string","pos: number","vf","hsl: Hsl | string","guard","lch: OkLch","fromLibrary","lch: C.LCH","parsingOptions: ParsingOptions<OkLch>","scalar","fromHexString","hexString: string","options: ParsingOptions<OkLch>","oklchTransparent: OkLchAbsolute","fromCss","value: string","rgbTo8bit","lch","Colorizr","lchOrString: OkLch | string","toScalar","toCssString","absoluteHslOrVariable: string | number | Angle","lightness","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","interpolator","a: OkLch | string","b: OkLch | string","direction: `longer` | `shorter`","amount: number","lch: OkLchScalar","l: number","c: number","h: number","lch: OkLchAbsolute","colour: string","fromCss","fallback?: string","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","hexString: string","scalar","srgbTansparent: Rgb8Bit","value: string","options: ParsingOptions<Rgb>","hslToLibraryRgb","toCssString","rgb: Rgb","guard","rgb: C.RGB","parsingOptions: ParsingOptions<Rgb>","rgbOrString: Rgb | string","rgbOrString: Rgb | Hsl | string","amount: Partial<{ pdelta: number, delta: number, fixed: number }>","Colorizr","rgb: Rgb8Bit","rgb: RgbScalar","v: string","pos: number","interpolator","colourA: Rgb | string","colourB: Rgb | string","amount: number","rgb: Rgb | string","grid","image: ImageData","fn: Grids.GridCellAccessor<Rgb8Bit>","cell: Grids.GridCell","fn: Grids.GridCellSetter<Rgb>","value: Rgb","col: Rgb8Bit[]","domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>","opts: Partial<CanvasHelperOptions>","#scaler","scaler","#scalerSize","#init","#logicalSize","reason?: string","#disposed","#resizer","#ctx","#drawHelper","#getContext","logicalSize: Rect","#handleEvents","resizerOptions: ElementSizerOptions<HTMLCanvasElement>","#onResizeDone","size: Rect","event: PointerEvent","colour?: string","#viewport","grid","elem: SVGElement","opts: DrawingOpts","svg: SVGElement","bounds: Rect","type: string","id?: string","parent: SVGElement","queryOrExisting?: string | V","suffix?: string","existing:SVGElement|HTMLElement|null","index: number","lightness","hslScalar","rand: RandomSource","colourish: Colourish","amount: number","withOpacity","fn: (scalarOpacity: number) => number","toColour","result: Colour | undefined","toCssColour","opacity: number","colours: Colourish[]","destination: ColourSpaces","toCssColour","c","colourA: Colourish","colourB: Colourish","options: Partial<ColourInterpolationOpts>","inter: ColourInterpolator<Colour> | undefined","convert","amount: number","opts: Partial<ColourStepOpts>","piece: Colour[]","pieceSteps: Colour[]","a: Colourish | string","b: Colourish","options: CreateStepsOptions","results: Colour[]","convert","colour: Colourish","destination: ConvertDestinations","toCssColour","destination: ColourSpaces","colour: Colourish | object","Colorizr","guard","colour: Colour","toColour","colourish: any","c: Colour | undefined","rgb: Rgb","scalarResult: boolean","elem: SVGElement","opts: StrokeOpts","id: string","opts: MarkerOpts","childCreator?: () => SVGElement","elem: SVGElement | null","_context: DrawingOpts","elem: SVGElement","opts: PathDrawingOpts","v: number","svgOrArray: string | readonly string[]","parent: SVGElement","opts?: PathDrawingOpts","queryOrExisting?: string | SVGPathElement","elem: SVGPathElement","elem: SVGCircleElement","circle: CirclePositioned","opts?: CircleDrawingOpts","circle","queryOrExisting?: string | SVGCircleElement","children: readonly SVGElement[]","queryOrExisting?: string | SVGGElement","elem: SVGGElement","line: Line","opts?: LineDrawingOpts","queryOrExisting?: string | SVGLineElement","line","lineEl: SVGLineElement","ray: Polar.PolarRay","el: SVGTextPathElement","text?: string","opts?: TextPathDrawingOpts","text","pathReference: string","text: string","textQueryOrExisting?: string | SVGTextElement","pathQueryOrExisting?: string | SVGTextPathElement","el: SVGTextElement","pos?: Point","opts?: TextDrawingOpts","queryOrExisting?: string | SVGTextElement","center: Point","spacing: number","width: number","height: number","opts: LineDrawingOpts","ColourStringFirst","el: SVGLineElement","origin: Point","parent: SVGElement","queryOrExisting: string | V","parent: SVGElement","parentOpts?: DrawingOpts & StrokeOpts","o: SvgHelper","queryOrExisting: string | SVGElement","text: string","pos: Point","opts?: TextDrawingOpts","queryOrExisting?: string | SVGTextElement","text","pathReference: string","textQueryOrExisting?: string | SVGTextElement","pathQueryOrExisting?: string | SVGTextPathElement","line: Line","opts?: LineDrawingOpts","queryOrExisting?: string | SVGLineElement","line","circle: CirclePositioned","opts?: CircleDrawingOpts","queryOrExisting?: string | SVGCircleElement","circle","svgString: string | readonly string[]","opts?: PathDrawingOpts","queryOrExisting?: string | SVGPathElement","center: Point","spacing: number","width: number","height: number","center","selectors: string","elOrQuery: HTMLElement | string","options: Opts","event: PointerEvent","el","fallbacks?: ReadonlyArray<string>","#store","#aliases","#elementBase","el: Element","key: string","colour: string","from: string","to: string","fallback?: string","fromCss","#lastFallback","sourceVideoEl: HTMLVideoElement","opts: FramesOpts","c: CanvasRenderingContext2D | null","opts: CaptureOpts","worker: Worker | undefined","pixels: ImageData | undefined","opts: ManualCaptureOpts","capture","c: CanvasRenderingContext2D | undefined | null","c","c: ManualCapturer","el: HTMLElement","name: string","defaultValue: number","elementQuery: string","options: BipolarViewOptions","lastValues: IQueueImmutable<CirclePositioned> | undefined","v: number","renderBackground: Render","ctx","width","height","x: number","y: number","mm: Point[]","minMax: PointMinMax","point: Point","mm: PointMinMax","increments: number","major: number","xValues: AxisMark[]","yValues: AxisMark[]","#data","#meta","series: string","data: TValue[]","meta: TSeriesMeta","value: TValue","canvasElementOrQuery: HTMLCanvasElement | string","sizeBasis: `min` | `max`","#canvasEl","#sizeBasis","#pixelScaling","#sizeScaler","#createSizeScaler","#logicalSize","size: Rect","#ctx","region: CanvasRegion","#regions","pt: Point","kind: `independent`","source: `screen` | `source`","kind: `independent` | `skip`","rect: Rect | RectPositioned","rect","spec: CanvasRegionSpec","#add","compute: ((source: CanvasSource) => RectPositioned)","source: CanvasSource","_source: CanvasSource","regionCompute: (parent: CanvasSource) => RectPositioned","#regionCompute","#r","regionRel: Point","scaleBy: `both`","p: Point","relativePoints: Point[]","strokeStyle: string","points: Point[]","text: string","relPos: Point","font: string","baseline: CanvasTextBaseline","align: CanvasTextAlign","text","point: Point","relativeCircles: CirclePositioned[]","fillStyle: string","c","circle","source: `screen`","clamped: boolean","value: RectPositioned","insertOptions: InsertOptions","options: RecursivePartial<Cart.CartesianPlotOptions>","cr: CanvasRegion","data: DataSet<Cart.PlotPoint, SeriesMeta>","#data","#canvasRegion","#lastDataChange","#visualClear","#rangeMode","#valueStyle","#connectStyle","#visualPadding","#axisStyle","#textStyle","#grid","#currentRange","#createRange","pt: Point","data: Point","elementToPosition: HTMLElement | string","by: `middle` | `top-left`","relativeToQuery?: HTMLElement | string","#rangeManual","dataPoint: Point","offset","dataValue: Point","point: Point","_source: `screen`","valueA: Point","valueB: Point","#useGrid","#drawAxes","#drawSeries","line","line: Line","colour: string","width: number","#valueLineToCanvasSpace","#drawLineCanvasSpace","series: string","meta: Partial<SeriesMeta>","yPoints: Point[]","xPoints: Point[]","p: Cart.AxisMark","vertical: boolean","#drawGridline","#drawWhisker","#drawXAxisValues","#drawYAxisValues","name: string","series: Cart.PlotPoint[]","meta: SeriesMeta","#drawConnected","#drawDot","dots: Cart.PlotPoint[]","dot","ColourToString","originalDot: Cart.PlotPoint","fallbackColour: string","fallbackRadius: number"],"sources":["../../arrays/dist/src/pairwise.js","../../numbers/dist/src/bipolar.js","../../geometry/dist/src/rect/apply.js","../../geometry/dist/src/rect/center.js","../../geometry/dist/src/point/is-equal.js","../../geometry/dist/src/rect/is-equal.js","../../geometry/dist/src/rect/multiply.js","../../geometry/dist/src/rect/subtract.js","../../geometry/dist/src/point/centroid.js","../../flow/dist/src/delay.js","../../collections/dist/src/stack/StackFns.js","../../collections/dist/src/stack/StackImmutable.js","../../collections/dist/src/queue/queue-immutable.js","../../collections/dist/src/map/map-multi-fns.js","../../collections/dist/src/map/map-of-simple-base.js","../../collections/dist/src/map/map-of-simple-mutable.js","../../geometry/dist/src/polar/ray.js","../../geometry/dist/src/vector.js","../../geometry/dist/src/line/from-numbers.js","../../geometry/dist/src/line/index.js","../../geometry/dist/src/point/relation.js","../../geometry/dist/src/point/point-tracker.js","../../geometry/dist/src/grid/inside.js","../../geometry/dist/src/grid/guards.js","../../geometry/dist/src/grid/apply-bounds.js","../../geometry/dist/src/grid/enumerators/cells.js","../../geometry/dist/src/grid/as.js","../../geometry/dist/src/grid/offset.js","../../geometry/dist/src/grid/indexing.js","../../geometry/dist/src/triangle/guard.js","../../geometry/dist/src/scaler.js","../../geometry/dist/src/triangle/corners.js","../../dom/dist/src/css.js","../../dom/dist/src/internal/debounce.js","../../dom/dist/src/element-sizing.js","../../visual/dist/src/colour/math.js","../../visual/src/drawing.ts","../../visual/src/colour/guards.ts","../../visual/src/colour/utility.ts","../../visual/src/colour/hsl.ts","../../visual/src/colour/oklch.ts","../../visual/src/colour/css-colours.ts","../../visual/src/colour/srgb.ts","../../visual/src/image-data-grid.ts","../../visual/src/canvas-helper.ts","../../visual/src/svg/apply.ts","../../visual/src/svg/bounds.ts","../../visual/src/svg/create.ts","../../visual/src/colour/generate.ts","../../visual/src/colour/math.ts","../../visual/src/colour/interpolate.ts","../../visual/src/colour/index.ts","../../visual/src/colour/conversion.ts","../../visual/src/svg/stroke.ts","../../visual/src/svg/markers.ts","../../visual/src/svg/path.ts","../../visual/src/svg/elements.ts","../../visual/src/svg/geometry.ts","../../visual/src/svg/remove.ts","../../visual/src/svg/helper.ts","../../visual/src/svg/index.ts","../../visual/src/pointer-visualise.ts","../../visual/src/named-colour-palette.ts","../../visual/src/video.ts","../../visual/src/plot/bipolar-view.ts","../../visual/src/plot/cartesian.ts","../../visual/src/plot/DataSet.ts","../../visual/src/pi-pi.ts","../../visual/src/canvas-region.ts","../../visual/src/plot/cartesian-canvas-plot.ts","../../visual/src/plot/index.ts","../../visual/src/index.ts"],"sourcesContent":["import { resultThrow, arrayTest } from \"@ixfx/guards\";\n/**\n * Yields pairs made up of overlapping items from the input array.\n *\n * Throws an error if there are less than two entries.\n *\n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [ [1,2], [2,3], [3,4], [4,5] ]\n * ```\n * @param values\n */\nexport function* pairwise(values) {\n    resultThrow(arrayTest(values, `values`));\n    if (values.length < 2)\n        throw new Error(`Array needs to have at least two entries. Length: ${values.length}`);\n    for (let index = 1; index < values.length; index++) {\n        yield [values[index - 1], values[index]];\n    }\n}\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = (array, reducer, initial) => {\n    resultThrow(arrayTest(array, `arr`));\n    if (array.length < 2)\n        return initial;\n    for (let index = 0; index < array.length - 1; index++) {\n        initial = reducer(initial, array[index], array[index + 1]);\n    }\n    return initial;\n};\n","//import { floatSource,type RandomOptions, type RandomSource } from '@ixfx/random';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { interpolate, scaler as numberScaler, scale as numberScale } from '@ixfx/numbers';\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n *\n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n *\n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n *\n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns\n */\nexport const immutable = (startingValueOrBipolar = 0) => {\n    if (typeof startingValueOrBipolar === `undefined`)\n        throw new Error(`Start value is undefined`);\n    const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n    if (startingValue > 1)\n        throw new Error(`Start value cannot be larger than 1`);\n    if (startingValue < -1)\n        throw new Error(`Start value cannot be smaller than -1`);\n    if (Number.isNaN(startingValue))\n        throw new Error(`Start value is NaN`);\n    const v = startingValue;\n    return {\n        [Symbol.toPrimitive](hint) {\n            if (hint === `number`)\n                return v;\n            else if (hint === `string`)\n                return v.toString();\n            return true;\n        },\n        value: v,\n        towardZero: (amt) => {\n            return immutable(towardZero(v, amt));\n        },\n        add: (amt) => {\n            return immutable(clamp(v + amt));\n        },\n        multiply: (amt) => {\n            return immutable(clamp(v * amt));\n        },\n        inverse: () => {\n            return immutable(-v);\n        },\n        interpolate: (amt, b) => {\n            return immutable(clamp(interpolate(amt, v, b)));\n        },\n        asScalar: (max = 1, min = 0) => {\n            return toScalar(v, max, min);\n        }\n    };\n};\n/**\n * Converts bipolar value to a scalar. That is, converts from\n * -1..1 range to 0..1.\n *\n * ```js\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n *\n * Range can be changed:\n * ```js\n * Bipolar.toScalar(0, 100); // Uses 0..100 scale, so output is 50\n * Bipolar.toScalar(0, 100, 50); // Uses 50..1000 scale, so output is 75\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue, max = 1, min = 0) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Expected v to be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Parameter is NaN`);\n    return numberScale(bipolarValue, -1, 1, min, max);\n};\n/**\n * Makes a scalar into a bipolar value.\n *\n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n *\n * Throws an error if `scalarValue` is outside 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue) => {\n    resultThrow(numberTest(scalarValue, `percentage`, `v`));\n    return (scalarValue * 2) - 1;\n};\n/**\n * Scale & clamp value to bipolar range (-1..1).\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue, inMin, inMax) => {\n    return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n};\n/**\n * Scale a number to bipolar range (-1..1). Not clamped, so we might exceed range.\n *\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scaleUnclamped(100, 0, 100); // 1\n * Bipolar.scaleUnclamped(50, 0, 100);  // 0\n * Bipolar.scaleUnclamped(0, 0, 100);   // -1\n * ```\n *\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleUnclamped = (inputValue, inMin, inMax) => {\n    return numberScaler(inMin, inMax, -1, 1)(inputValue);\n};\n/**\n * Clamp a bipolar value\n * ```js\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Param 'bipolarValue' is NaN`);\n    if (bipolarValue > 1)\n        return 1;\n    if (bipolarValue < -1)\n        return -1;\n    return bipolarValue;\n};\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n *\n * ```js\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n *\n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue, amount) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Parameter 'v' must be a number. Got: ${typeof bipolarValue}`);\n    if (typeof amount !== `number`)\n        throw new Error(`Parameter 'amt' must be a number. Got: ${typeof amount}`);\n    if (amount < 0)\n        throw new Error(`Parameter 'amt' must be positive`);\n    if (bipolarValue < 0) {\n        bipolarValue += amount;\n        if (bipolarValue > 0)\n            bipolarValue = 0;\n    }\n    else if (bipolarValue > 0) {\n        bipolarValue -= amount;\n        if (bipolarValue < 0)\n            bipolarValue = 0;\n    }\n    return bipolarValue;\n};\n","import { guard } from \"./guard.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./guard.js\";\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth\n * @param heightValue\n * @returns\n */\nexport function applyFields(op, rectOrWidth, heightValue) {\n    let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n    let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n    if (width === undefined)\n        throw new Error(`Param 'width' undefined`);\n    if (height === undefined)\n        throw new Error(`Param 'height' undefined`);\n    width = op(width, `width`);\n    height = op(height, `height`);\n    if (typeof rectOrWidth === `object`) {\n        if (isPositioned(rectOrWidth)) {\n            const x = op(rectOrWidth.x, `x`);\n            const y = op(rectOrWidth.y, `y`);\n            return { ...rectOrWidth, width, height, x, y };\n        }\n        else {\n            return {\n                ...rectOrWidth, width, height\n            };\n        }\n    }\n    return { width, height };\n}\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function applyMerge(op, a, b, c) {\n    guard(a, `a`);\n    if (isRect(b)) {\n        // Math op by another rectangle\n        return isRectPositioned(a) ? Object.freeze({\n            ...a,\n            x: op(a.x, b.width),\n            y: op(a.y, b.height),\n            width: op(a.width, b.width),\n            height: op(a.height, b.height),\n        }) : Object.freeze({\n            ...a,\n            width: op(a.width, b.width),\n            height: op(a.height, b.height),\n        });\n    }\n    else {\n        // Math op with a series of values\n        if (typeof b !== `number`) {\n            throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(b)}`);\n        }\n        if (typeof c !== `number`)\n            throw new Error(`Expected third param as height. Got ${JSON.stringify(c)}`);\n        return isRectPositioned(a) ? Object.freeze({\n            ...a,\n            x: op(a.x, b),\n            y: op(a.y, c),\n            width: op(a.width, b),\n            height: op(a.height, c),\n        }) : Object.freeze({\n            ...a,\n            width: op(a.width, b),\n            height: op(a.height, c),\n        });\n    }\n}\nexport function applyScalar(op, rect, parameter) {\n    return isPositioned(rect) ? Object.freeze({\n        ...rect,\n        x: op(rect.x, parameter),\n        y: op(rect.y, parameter),\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    }) : Object.freeze({\n        ...rect,\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    });\n}\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op\n * @param rect\n * @param parameter\n * @returns\n */\nexport function applyDim(op, rect, parameter) {\n    return Object.freeze({\n        ...rect,\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    });\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { getRectPositioned, guard } from \"./guard.js\";\n/**\n * Returns the center of a rectangle as a {@link Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (rect, origin) => {\n    guard(rect);\n    if (origin === undefined && isPoint(rect))\n        origin = rect;\n    else if (origin === undefined)\n        origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n    const r = getRectPositioned(rect, origin);\n    return Object.freeze({\n        x: origin.x + rect.width / 2,\n        y: origin.y + rect.height / 2,\n    });\n};\n","/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p) => {\n    if (p === undefined)\n        throw new Error(`parameter 'p' is undefined`);\n    if (p.length < 2)\n        return true;\n    for (let index = 1; index < p.length; index++) {\n        if (p[index].x !== p[0].x)\n            return false;\n        if (p[index].y !== p[0].y)\n            return false;\n    }\n    return true;\n};\n","import { isPositioned } from \"./guard.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a, b) => {\n    if (a === undefined)\n        throw new Error(`a undefined`);\n    if (b === undefined)\n        throw new Error(`b undefined`);\n    return a.width === b.width && a.height === b.height;\n};\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => {\n    if (isPositioned(a) && isPositioned(b)) {\n        if (!PointsIsEqual(a, b))\n            return false;\n        return a.width === b.width && a.height === b.height;\n    }\n    else if (!isPositioned(a) && !isPositioned(b)) {\n        return a.width === b.width && a.height === b.height;\n    }\n    else {\n        // One param is positioned, the other is not\n        return false;\n    }\n};\n","import { applyMerge, applyDim, applyScalar } from \"./apply.js\";\nconst multiplyOp = (a, b) => a * b;\n/**\n * @internal\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function multiply(a, b, c) {\n    // @ts-ignore\n    return applyMerge(multiplyOp, a, b, c);\n}\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n *\n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect, amount) {\n    return applyScalar(multiplyOp, rect, amount);\n    // return isPositioned(rect) ? Object.freeze({\n    //   ...rect,\n    //   x: rect.x * amount,\n    //   y: rect.y * amount,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // }) : Object.freeze({\n    //   ...rect,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // });\n}\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n *\n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns\n */\nexport function multiplyDim(rect, amount) {\n    return applyDim(multiplyOp, rect, amount);\n    // return isPositioned(rect) ? Object.freeze({\n    //   ...rect,\n    //   x: rect.x * amount,\n    //   y: rect.y * amount,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // }) : Object.freeze({\n    //   ...rect,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // });\n}\n","import { applyMerge } from \"./apply.js\";\nimport { isPositioned } from \"./guard.js\";\nconst subtractOp = (a, b) => a - b;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a, b, c) {\n    // @ts-ignore\n    return applyMerge(subtractOp, a, b, c);\n}\nexport function subtractSize(a, b, c) {\n    const w = typeof b === `number` ? b : b.width;\n    const h = typeof b === `number` ? c : b.height;\n    if (h === undefined)\n        throw new Error(`Expected height as third parameter`);\n    const r = {\n        ...a,\n        width: a.width - w,\n        height: a.height - h\n    };\n    return r;\n}\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 },\n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a\n * @param b\n * @returns\n */\nexport function subtractOffset(a, b) {\n    let x = 0;\n    let y = 0;\n    if (isPositioned(a)) {\n        x = a.x;\n        y = a.y;\n    }\n    let xB = 0;\n    let yB = 0;\n    if (isPositioned(b)) {\n        xB = b.x;\n        yB = b.y;\n    }\n    return Object.freeze({\n        ...a,\n        x: x - xB,\n        y: y - yB,\n        width: a.width - b.width,\n        height: a.height - b.height\n    });\n}\n","import { isPoint } from \"./guard.js\";\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points) => {\n    if (!Array.isArray(points))\n        throw new Error(`Expected list of points`);\n    // eslint-disable-next-line unicorn/no-array-reduce\n    const sum = points.reduce((previous, p) => {\n        if (p === undefined)\n            return previous; // Ignore undefined\n        if (Array.isArray(p)) {\n            throw new TypeError(`'points' list contains an array. Did you mean: centroid(...myPoints)?`);\n        }\n        if (!isPoint(p)) {\n            throw new Error(`'points' contains something which is not a point: ${JSON.stringify(p)}`);\n        }\n        return {\n            x: previous.x + p.x,\n            y: previous.y + p.y,\n        };\n    }, { x: 0, y: 0 });\n    return Object.freeze({\n        x: sum.x / points.length,\n        y: sum.y / points.length,\n    });\n};\n","import { intervalToMs } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n/**\n * Pauses execution for interval after which the asynchronous `callback` is executed and awaited.\n * Must be called with `await` if you want the pause effect.\n *\n * @example Pause and wait for function\n * ```js\n * const result = await delay(async () => Math.random(), 1000);\n * console.log(result); // Prints out result after one second\n * ```\n *\n * If the `interval` option is a number its treated as milliseconds. {@link Interval} can also be used:\n * ```js\n * const result = await delay(async () => Math.random(), { mins: 1 });\n * ```\n *\n * If `await` is omitted, the function will run after the provided timeout, and code will continue to run.\n *\n * @example Schedule a function without waiting\n * ```js\n * await delay(async () => {\n *  console.log(Math.random())\n * }, 1000);\n * // Prints out a random number after 1 second.\n * ```\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * Optionally takes an AbortSignal to cancel delay.\n * ```js\n * const ac = new AbortController();\n * // Super long wait\n * await delay(someFn, { signal: ac.signal, hours: 1 }}\n * ...\n * ac.abort(); // Cancels long delay\n * ```\n *\n * It also allows choice of when delay should happen.\n * If you want to be able to cancel or re-run a delayed function, consider using\n * {@link timeout} instead.\n *\n * @typeParam V - Type of callback return value\n * @param callback What to run after interval\n * @param optsOrMillis Options for delay, or millisecond delay. By default delay is before `callback` is executed.\n * @return Returns result of `callback`.\n */\nexport const delay = async (callback, \n//eslint-disable-next-line functional/prefer-immutable-types\noptsOrMillis) => {\n    const opts = typeof optsOrMillis === `number` ? { millis: optsOrMillis } : optsOrMillis;\n    const delayWhen = opts.delay ?? `before`;\n    if (delayWhen === `before` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    const r = Promise.resolve(await callback());\n    if (delayWhen === `after` || delayWhen === `both`) {\n        await sleep(opts);\n    }\n    return r;\n};\n/**\n * Iterate over a source iterable with some delay between results.\n * Delay can be before, after or both before and after each result from the\n * source iterable.\n *\n * Since it's an async iterable, `for await ... of` is needed.\n *\n * ```js\n * const opts = { intervalMs: 1000, delay: 'before' };\n * const iterable = count(10);\n * for await (const i of delayIterable(iterable, opts)) {\n *  // Prints 0..9 with one second between\n * }\n * ```\n *\n * Use {@link delay} to return a result after some delay\n *\n * @param iter\n * @param opts\n */\n// export async function* delayIterable<V>(\n//   iter: AsyncIterable<V> | Iterable<V>,\n//   //eslint-disable-next-line functional/prefer-immutable-types\n//   opts: DelayOpts\n// ) {\n//   const intervalMs = intervalToMs(opts);\n//   const delayWhen = opts.delay;\n//   const signal = opts.signal;\n//   for await (const v of iter) {\n//     // Pre-delay\n//     if (delayWhen === 'before' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//     // Yield value\n//     yield v;\n//     // Post-delay\n//     if (delayWhen === 'after' || delayWhen === 'both') {\n//       await sleep({ millis: intervalMs, signal });\n//       if (signal?.aborted) break;\n//     }\n//   }\n// }\n/**\n * Async generator that loops via `requestAnimationFrame`.\n *\n * We can use `for await of` to run code:\n * ```js\n * const loop = delayAnimationLoop();\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * // Warning: execution doesn't continue to this point\n * // unless there is a 'break' in loop.\n * ```\n *\n * Or use the generator in manually:\n * ```js\n * // Loop forever\n * (async () => {\n *  const loop = delayAnimationLoop();\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Practically, these approaches are not so useful\n * because execution blocks until the loop finishes.\n *\n * Instead, we might want to continually loop a bit\n * of code while other bits of code continue to run.\n *\n * The below example shows how to do this.\n *\n * ```js\n * setTimeout(async () => {\n *  for await (const _ of delayAnimationLoop()) {\n *    // Do soething at animation speed\n *  }\n * });\n *\n * // Execution continues while loop also runs\n * ```\n *\n */\nasync function* delayAnimationLoop() {\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer = 0;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.requestAnimationFrame(callback);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        globalThis.cancelAnimationFrame(timer);\n    }\n}\n/**\n * Async generator that loops at a given interval.\n *\n * @example\n * For Await loop every second\n * ```js\n * const loop = delayLoop(1000);\n * // Or: const loop = delayLoop({ secs: 1 });\n * for await (const o of loop) {\n *  // Do something...\n *  // Warning: loops forever\n * }\n * ```\n *\n * @example\n * Loop runs every second\n * ```js\n * (async () => {\n *  const loop = delayLoop(1000);\n *  // or: loop = delayLoop({ secs: 1 });\n *  while (true) {\n *    await loop.next();\n *\n *    // Do something...\n *    // Warning: loops forever\n *  }\n * })();\n * ```\n *\n * Alternatives:\n * * {@link delay} to run a single function after a delay\n * * {@link sleep} pause execution\n * * {@link continuously} to start/stop/adjust a constantly running loop\n *\n * @param timeout Delay. If 0 is given, `requestAnimationFrame` is used over `setTimeout`.\n */\nexport async function* delayLoop(timeout) {\n    const timeoutMs = intervalToMs(timeout);\n    if (typeof timeoutMs === `undefined`)\n        throw new Error(`timeout is undefined`);\n    if (timeoutMs < 0)\n        throw new Error(`Timeout is less than zero`);\n    if (timeoutMs === 0)\n        return yield* delayAnimationLoop();\n    let resolve;\n    let p = new Promise((r) => (resolve = r));\n    let timer;\n    const callback = () => {\n        if (resolve)\n            resolve();\n        p = new Promise((r) => (resolve = r));\n    };\n    try {\n        while (true) {\n            timer = globalThis.setTimeout(callback, timeoutMs);\n            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression\n            const _ = await p;\n            yield _;\n        }\n    }\n    finally {\n        if (resolve)\n            resolve();\n        if (timer !== undefined)\n            globalThis.clearTimeout(timer);\n        timer = undefined;\n    }\n}\n","export const trimStack = (opts, stack, toAdd) => {\n    const potentialLength = stack.length + toAdd.length;\n    const policy = opts.discardPolicy ?? `additions`;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    if (opts.debug) {\n        console.log(`Stack.push: stackLen: ${stack.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy}`);\n    }\n    switch (policy) {\n        case `additions`: {\n            if (opts.debug) {\n                console.log(`Stack.push:DiscardAdditions: stackLen: ${stack.length} slice: ${potentialLength - capacity} toAddLen: ${toAdd.length}`);\n            }\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (stack.length === opts.capacity) {\n                return stack; // Completely full\n            }\n            else {\n                // Only add some from the new array\n                return [...stack, ...toAdd.slice(0, toAdd.length - toRemove)];\n            }\n        }\n        case `newer`: {\n            if (toRemove >= stack.length) {\n                // New items will completely flush out old\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n            }\n            else {\n                // Keep some of the old (from 0)\n                //if (opts.debug) console.log(` orig: ${JSON.stringify(stack)}`);\n                if (opts.debug) {\n                    console.log(` from orig: ${JSON.stringify(stack.slice(0, stack.length - toRemove))}`);\n                }\n                return [\n                    ...stack.slice(0, stack.length - toRemove),\n                    ...toAdd.slice(0, Math.min(toAdd.length, capacity - toRemove + 1)),\n                ];\n            }\n        }\n        case `older`: {\n            // Oldest item in stack is position 0\n            return [...stack, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown discard policy ${policy}`);\n        }\n    }\n};\n// Add to top (last index)\nexport const push = (opts, stack, ...toAdd) => {\n    // If stack is A, B and toAdd is C, D this yields A, B, C, D\n    //const mutated = [...stack, ...toAdd];\n    const potentialLength = stack.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimStack(opts, stack, toAdd)\n        : [...stack, ...toAdd];\n    return toReturn;\n};\n// Remove from top (last index)\nexport const pop = (opts, stack) => {\n    if (stack.length === 0)\n        throw new Error(`Stack is empty`);\n    return stack.slice(0, -1);\n};\n/**\n * Peek at the top of the stack (end of array)\n *\n * @typeParam V - Type of stored items\n * @param {StackOpts} opts\n * @param {V[]} stack\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, stack) => stack.at(-1);\nexport const isEmpty = (opts, stack) => stack.length === 0;\nexport const isFull = (opts, stack) => {\n    if (opts.capacity) {\n        return stack.length >= opts.capacity;\n    }\n    return false;\n};\n","import { push, pop, isEmpty, isFull, peek } from './StackFns.js';\nexport class StackImmutable {\n    opts;\n    /* eslint-disable-next-line functional/prefer-readonly-type */\n    data;\n    constructor(opts = {}, data = []) {\n        this.opts = opts;\n        this.data = data;\n    }\n    push(...toAdd) {\n        return new StackImmutable(this.opts, push(this.opts, this.data, ...toAdd));\n    }\n    pop() {\n        return new StackImmutable(this.opts, pop(this.opts, this.data));\n    }\n    forEach(fn) {\n        this.data.forEach(fn);\n    }\n    forEachFromTop(fn) {\n        [...this.data].reverse().forEach(fn);\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.data);\n    }\n    get peek() {\n        return peek(this.opts, this.data);\n    }\n    get length() {\n        return this.data.length;\n    }\n}\n/**\n * Returns a stack. Immutable. Use {@link Stacks.mutable} for a mutable alternative.\n *\n * The basic usage is `push`/`pop` to add/remove, returning the modified stack. Use the\n * property `peek` to see what's on top.\n *\n * @example Basic usage\n * ```js\n * // Create\n * let s = stack();\n * // Add one or more items\n * s = s.push(1, 2, 3, 4);\n * // See what's at the top of the stack\n * s.peek;      // 4\n *\n * // Remove from the top of the stack, returning\n * // a new stack without item\n * s = s.pop();\n * s.peek;        // 3\n * ```\n * @param options Options\n * @param startingItems List of items to add to stack. Items will be pushed 'left to right', ie array index 0 will be bottom of the stack.\n */\nexport const immutable = (options = {}, ...startingItems) => new StackImmutable({ ...options }, [...startingItems]);\n","import { peek, isFull, isEmpty, enqueue, dequeue } from './queue-fns.js';\nimport {} from './queue-types.js';\n// -------------------------------\n// Immutable\n// -------------------------------\nexport class QueueImmutable {\n    opts;\n    #data;\n    /**\n     * Creates an instance of Queue.\n     * @param {QueueOpts} opts Options foor queue\n     * @param {V[]} data Initial data. Index 0 is front of queue\n     */\n    constructor(opts = {}, data = []) {\n        if (opts === undefined)\n            throw new Error(`opts parameter undefined`);\n        this.opts = opts;\n        this.#data = data;\n    }\n    forEach(fn) {\n        //eslint-disable-next-line functional/no-let\n        for (let index = this.#data.length - 1; index >= 0; index--) {\n            fn(this.#data[index]);\n        }\n    }\n    forEachFromFront(fn) {\n        // From front of queue\n        this.#data.forEach(item => { fn(item); }); //(vv) => fn(vv));\n    }\n    enqueue(...toAdd) {\n        return new QueueImmutable(this.opts, enqueue(this.opts, this.#data, ...toAdd));\n    }\n    dequeue() {\n        return new QueueImmutable(this.opts, dequeue(this.opts, this.#data));\n    }\n    get isEmpty() {\n        return isEmpty(this.opts, this.#data);\n    }\n    get isFull() {\n        return isFull(this.opts, this.#data);\n    }\n    get length() {\n        return this.#data.length;\n    }\n    get peek() {\n        return peek(this.opts, this.#data);\n    }\n    toArray() {\n        return [...this.#data];\n    }\n}\n/**\n * Returns an immutable queue. Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * let q = Queues.immutable();           // Create\n * q = q.enqueue(`a`, `b`);   // Add two strings\n * const front = q.peek();    // `a` is at the front of queue (oldest)\n * q = q.dequeue();           // q now just consists of `b`\n * ```\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * @typeParam V - Type of values stored\n * @param options\n * @param startingItems Index 0 is the front of the queue\n * @returns A new queue\n */\nexport const immutable = (options = {}, ...startingItems) => {\n    options = { ...options }; // Make a copy of options\n    return new QueueImmutable(options, [...startingItems]); // Make a copy of array so it can't be modified\n};\n","//  UNIT TESTED\nimport { isEqualDefault } from '@ixfx/core';\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntry(map, (value, key) => {\n *  return (value === 'e');\n * });\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const firstEntry = (map, predicate) => {\n    for (const e of map.entries()) {\n        const value = e[1];\n        for (const subValue of value) {\n            if (predicate(subValue, e[0]))\n                return e;\n        }\n    }\n};\n/**\n * Returns the size of the largest key, or 0 if empty.\n */\nexport const lengthMax = (map) => {\n    //eslint-disable-next-line functional/no-let\n    let largest = ['', 0];\n    for (const e of map.keysAndCounts()) {\n        if (e[1] > largest[1]) {\n            largest = e;\n        }\n    }\n    return largest[1];\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', ['a', 'b', 'c']);\n * map.set('there', ['d', 'e', 'f']);\n *\n * const entry = firstEntryByValue(map, 'e');\n * // Entry is: ['there', ['d', 'e', 'f']]\n * ```\n *\n * An alternative is {@link firstEntry} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const firstEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const e of map.entries()) {\n        const value_ = e[1];\n        for (const subValue of value_) {\n            if (isEqual(subValue, value))\n                return e;\n        }\n    }\n};\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { firstEntryByValue } from './map-multi-fns.js';\nexport class MapOfSimpleBase {\n    map;\n    groupBy;\n    valueEq;\n    /**\n     * Constructor\n     * @param groupBy Creates keys for values when using `addValue`. By default uses JSON.stringify\n     * @param valueEq Compare values. By default uses JS logic for equality\n     */\n    constructor(groupBy = defaultKeyer, valueEq = (isEqualDefault), initial = []) {\n        this.groupBy = groupBy;\n        this.valueEq = valueEq;\n        this.map = new Map(initial);\n    }\n    /**\n     * Returns _true_ if `key` exists\n     * @param key\n     * @returns\n     */\n    has(key) {\n        return this.map.has(key);\n    }\n    /**\n     * Returns _true_ if `value` exists under `key`.\n     * @param key Key\n     * @param value Value to seek under `key`\n     * @returns _True_ if `value` exists under `key`.\n     */\n    hasKeyValue(key, value) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        for (const v of values) {\n            if (this.valueEq(v, value))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Debug dump of contents\n     * @returns\n     */\n    debugString() {\n        let r = ``;\n        const keys = [...this.map.keys()];\n        keys.every((k) => {\n            const v = this.map.get(k);\n            if (v === undefined)\n                return;\n            r += k + ` (${v.length}) = ${JSON.stringify(v)}\\r\\n`;\n        });\n        return r;\n    }\n    /**\n     * Return number of values stored under `key`.\n     * Returns 0 if `key` is not found.\n     * @param key\n     * @returns\n     */\n    count(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return 0;\n        return values.length;\n    }\n    /**\n   * Returns first key that contains `value`\n   * @param value\n   * @param eq\n   * @returns\n   */\n    firstKeyByValue(value, eq = isEqualDefault) {\n        const entry = firstEntryByValue(this, value, eq);\n        if (entry)\n            return entry[0];\n    }\n    /**\n     * Iterate over all entries\n     */\n    *entriesFlat() {\n        for (const key of this.map.keys()) {\n            for (const value of this.map.get(key)) {\n                yield [key, value];\n            }\n        }\n    }\n    /**\n     * Iterate over keys and array of values for that key\n     */\n    *entries() {\n        for (const [k, v] of this.map.entries()) {\n            yield [k, [...v]];\n        }\n    }\n    /**\n     * Get all values under `key`\n     * @param key\n     * @returns\n     */\n    *get(key) {\n        const m = this.map.get(key);\n        if (!m)\n            return;\n        yield* m.values();\n    }\n    /**\n     * Iterate over all keys\n     */\n    *keys() {\n        yield* this.map.keys();\n    }\n    /**\n     * Iterate over all values (regardless of key).\n     * Use {@link values} to iterate over a set of values per key\n     */\n    *valuesFlat() {\n        for (const entries of this.map) {\n            yield* entries[1];\n        }\n    }\n    /**\n     * Yields the values for each key in sequence, returning an array.\n     * Use {@link valuesFlat} to iterate over all keys regardless of key.\n     */\n    *values() {\n        for (const entries of this.map) {\n            yield entries[1];\n        }\n    }\n    /**\n     * Iterate over keys and length of values stored under keys\n     */\n    *keysAndCounts() {\n        for (const entries of this.map) {\n            yield [entries[0], entries[1].length];\n        }\n    }\n    /**\n     * Returns the count of keys.\n     */\n    get lengthKeys() {\n        return this.map.size;\n    }\n    /**\n    * _True_ if empty\n    */\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\n","import { defaultKeyer, isEqualDefault } from '@ixfx/core';\nimport { MapOfSimpleBase } from './map-of-simple-base.js';\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider ofArrayMutable, ofCircularMutable or ofSetMutable.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * Constructor takes a `groupBy` parameter, which yields a string key for a value. This is the\n * basis by which values are keyed when using `addValues`.\n *\n * Constructor takes a `valueEq` parameter, which compares values. This is used when checking\n * if a value exists under a key, for example.\n * @typeParam V - Type of items\n */\nexport class MapOfSimpleMutable extends MapOfSimpleBase {\n    addKeyedValues(key, ...values) {\n        const existing = this.map.get(key);\n        if (existing === undefined) {\n            this.map.set(key, values);\n        }\n        else {\n            this.map.set(key, [...existing, ...values]);\n        }\n    }\n    /**\n     * Set `values` to `key`.\n     * Previous data stored under `key` is thrown away.\n     * @param key\n     * @param values\n     */\n    setValues(key, values) {\n        this.map.set(key, values);\n    }\n    /**\n     * Adds a value, automatically extracting a key via the\n     * `groupBy` function assigned in the constructor options.\n     * @param values Adds several values\n     */\n    addValue(...values) {\n        for (const v of values) {\n            const key = this.groupBy(v);\n            this.addKeyedValues(key, v);\n        }\n    }\n    /**\n     * Delete `value` under a particular `key`\n     * @param key\n     * @param value\n     * @returns _True_ if `value` was found under `key`\n     */\n    deleteKeyValue(key, value) {\n        const existing = this.map.get(key);\n        if (existing === undefined)\n            return false;\n        const without = existing.filter((existingValue) => !this.valueEq(existingValue, value));\n        this.map.set(key, without);\n        return without.length < existing.length;\n    }\n    /**\n     * Deletes `value` regardless of key.\n     *\n     * Uses the constructor-defined equality function.\n     * @param value Value to delete\n     * @returns\n     */\n    deleteByValue(value) {\n        let del = false;\n        const entries = [...this.map.entries()];\n        for (const keyEntries of entries) {\n            for (const values of keyEntries[1]) {\n                if (this.valueEq(values, value)) {\n                    del = true;\n                    this.deleteKeyValue(keyEntries[0], value);\n                }\n            }\n        }\n        return del;\n    }\n    /**\n     * Deletes all values under `key`,\n     * @param key\n     * @returns _True_ if `key` was found and values stored\n     */\n    delete(key) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        if (values.length === 0)\n            return false;\n        this.map.delete(key);\n        return true;\n    }\n    /**\n     * Clear contents\n     */\n    clear() {\n        this.map.clear();\n    }\n}\n/**\n * A simple mutable map of arrays, without events. It can store multiple values\n * under the same key.\n *\n * For a fancier approaches, consider {@link ofArrayMutable}, {@link ofCircularMutable} or {@link ofSetMutable}.\n *\n * @example\n * ```js\n * const m = mapOfSimpleMutable();\n * m.add(`hello`, 1, 2, 3); // Adds numbers under key `hello`\n * m.delete(`hello`);       // Deletes everything under `hello`\n *\n * const hellos = m.get(`hello`); // Get list of items under `hello`\n * ```\n *\n * @typeParam V - Type of items\n * @returns New instance\n */\nexport const ofSimpleMutable = (groupBy = defaultKeyer, valueEq = (isEqualDefault)) => new MapOfSimpleMutable(groupBy, valueEq);\n","import {} from \"../line/line-type.js\";\nimport {} from '../point/point-type.js';\nimport { distance } from '../point/distance.js';\nimport { angleRadian } from '../point/angle.js';\nimport { toString as pointToString } from '../point/To.js';\nimport {} from \"./types.js\";\nimport { toCartesian as polarToCartesian } from \"./conversions.js\";\n/**\n * Converts a ray to a Line in cartesian coordinates.\n *\n * @param ray\n * @param origin Override or provide origin point\n * @returns\n */\nexport const toCartesian = (ray, origin) => {\n    const o = getOrigin(ray, origin);\n    const a = polarToCartesian(ray.offset, ray.angleRadian, o);\n    const b = polarToCartesian(ray.offset + ray.length, ray.angleRadian, o);\n    return { a, b };\n};\nconst getOrigin = (ray, origin) => {\n    if (origin !== undefined)\n        return origin;\n    if (ray.origin !== undefined)\n        return ray.origin;\n    return { x: 0, y: 0 };\n};\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray\n * @param origin\n * @returns\n */\n// const withOrigin = (ray: PolarRay, origin?: Point): PolarRayWithOrigin => {\n//   if (origin) {\n//     return {\n//       ...ray,\n//       origin\n//     };\n//   }\n//   if (ray.origin !== undefined) return { ...ray } as PolarRayWithOrigin;\n//   return {\n//     ...ray,\n//     origin: { x: 0, y: 0 }\n//   }\n// }\n// function getAngle(a: Point, b: Point) {\n//   const angle = Math.atan2(b.y - a.y, b.x - a.x);// * (180 / Math.PI) + 90;\n//   return angle;//return (angle < 0) ? scale(angle, -90, 0, 0, piPi) : angle;\n// }\n/**\n * Returns a string representation of the ray\n * @param ray\n * @returns\n */\nexport const toString = (ray) => {\n    let basic = `PolarRay(angle: ${ray.angleRadian} offset: ${ray.offset} len: ${ray.length}`;\n    if (ray.origin) {\n        basic += ` origin: ${pointToString(ray.origin)}`;\n    }\n    basic += `)`;\n    return basic;\n};\n/**\n * Returns a PolarRay based on a line and origin.\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * @param line\n * @param origin\n * @returns\n */\nexport const fromLine = (line, origin) => {\n    const o = origin ?? line.a;\n    return {\n        angleRadian: angleRadian(line.b, o),\n        offset: distance(line.a, o),\n        length: distance(line.b, line.a),\n        origin: o\n    };\n};\n","import { normalise as PointsNormalise } from './point/normalise.js';\nimport { isPoint } from './point/guard.js';\nimport * as Polar from './polar/index.js';\nimport { divide as PointDivide } from './point/divider.js';\nimport { guard as LinesGuard } from './line/guard.js';\nimport { sum as PointsSum } from './point/sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/dot-product.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/magnitude.js';\nimport { distance as PointsDistance } from './point/distance.js';\nimport { Empty as PointEmpty } from './point/empty.js';\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\nexport const fromRadians = (radians) => {\n    return Object.freeze({\n        x: Math.cos(radians),\n        y: Math.sin(radians)\n    });\n};\nexport const toRadians = (point) => {\n    return Math.atan2(point.y, point.x);\n};\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2\n * if `bipolar` normalisation is used, direction will be fixed to -...\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (pt, angleNormalisation = ``, origin = EmptyCartesian) => {\n    pt = PointsSubtract(pt, origin);\n    let direction = Math.atan2(pt.y, pt.x);\n    if (angleNormalisation === `unipolar` && direction < 0)\n        direction += piPi;\n    else if (angleNormalisation === `bipolar`) {\n        if (direction > pi)\n            direction -= piPi;\n        else if (direction <= -pi)\n            direction += piPi;\n    }\n    return Object.freeze({\n        distance: PointsDistance(pt),\n        angleRadian: direction,\n    });\n};\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line) => PointsSubtract(line.b, line.a);\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line) => {\n    LinesGuard(line, `line`);\n    const pt = PointsSubtract(line.b, line.a);\n    return fromPointPolar(pt);\n};\nconst isPolar = (v) => {\n    if (Polar.isPolarCoord(v))\n        return true;\n    return false;\n};\nconst isCartesian = (v) => {\n    if (isPoint(v))\n        return true;\n    return false;\n};\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v) => {\n    if (isPolar(v)) {\n        return Polar.normalise(v);\n    }\n    else if (isCartesian(v)) {\n        return PointsNormalise(v);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\nexport const quadrantOffsetAngle = (p) => {\n    if (p.x >= 0 && p.y >= 0)\n        return 0; // Q1\n    if (p.x < 0 && p.y >= 0)\n        return pi; // Q2\n    if (p.x < 0 && p.y < 0)\n        return pi; // Q3\n    return piPi; // Q4\n};\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v, origin = PointEmpty) => {\n    if (isPolar(v)) {\n        return v;\n    }\n    else if (isCartesian(v)) {\n        return Polar.fromCartesian(v, origin);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v) => {\n    if (isPolar(v)) {\n        return Polar.toPoint(v);\n    }\n    else if (isCartesian(v)) {\n        return v;\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v, digits) => {\n    if (isPolar(v)) {\n        return Polar.toString(v, digits);\n    }\n    else if (isCartesian(v)) {\n        return PointsToString(v, digits);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a, b) => {\n    if (isPolar(a) && isPolar(b)) {\n        return Polar.dotProduct(a, b);\n    }\n    else if (isCartesian(a) && isCartesian(b)) {\n        return PointsDotProduct(a, b);\n    }\n    throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v, max = 1, min = 0) => {\n    if (isPolar(v)) {\n        return Polar.clampMagnitude(v, max, min);\n    }\n    else if (isCartesian(v)) {\n        return PointsClampMagnitude(v, max, min);\n    }\n    throw new Error(`Expected either polar or Cartesian vector`);\n};\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsSum(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsSubtract(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsMultiply(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointDivide(a, b);\n    return polar ? toPolar(c) : c;\n};\n","import { fromPoints } from \"./from-points.js\";\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n *\n * ```js\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns\n */\nexport const fromNumbers = (x1, y1, x2, y2) => {\n    if (Number.isNaN(x1))\n        throw new Error(`x1 is NaN`);\n    if (Number.isNaN(x2))\n        throw new Error(`x2 is NaN`);\n    if (Number.isNaN(y1))\n        throw new Error(`y1 is NaN`);\n    if (Number.isNaN(y2))\n        throw new Error(`y2 is NaN`);\n    const a = { x: x1, y: y1 };\n    const b = { x: x2, y: y2 };\n    return fromPoints(a, b);\n};\n","//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/normalise-by-rect.js';\nimport { minFast } from '@ixfx/numbers';\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isLine } from './guard.js';\nimport { length } from './length.js';\nimport { interpolate } from './interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/guard.js';\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\nexport const Empty = Object.freeze({\n    a: Object.freeze({ x: 0, y: 0 }),\n    b: Object.freeze({ x: 0, y: 0 })\n});\nexport const Placeholder = Object.freeze({\n    a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n    b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l\n * @returns\n */\nexport const isEmpty = (l) => PointIsEmpty(l.a) && PointIsEmpty(l.b);\nexport const isPlaceholder = (l) => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n/**\n * Applies `fn` to both start and end points.\n *\n * ```js\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n *\n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n *\n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns\n */\nexport const apply = (line, fn) => Object.freeze({\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n});\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint\n * @param b\n * @returns\n */\nexport const angleRadian = (lineOrPoint, b) => {\n    let a;\n    if (isLine(lineOrPoint)) {\n        a = lineOrPoint.a;\n        b = lineOrPoint.b;\n    }\n    else {\n        a = lineOrPoint;\n        if (b === undefined)\n            throw new Error(`b point must be provided`);\n    }\n    return Math.atan2(b.y - a.y, b.x - a.x);\n};\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line\n * @param width\n * @param height\n * @returns\n */\nexport const normaliseByRect = (line, width, height) => Object.freeze({\n    ...line,\n    a: PointsNormaliseByRect(line.a, width, height),\n    b: PointsNormaliseByRect(line.b, width, height)\n});\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n *\n * ```js\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange\n * @returns True if point is within range\n */\nexport const withinRange = (line, point, maxRange) => {\n    const calculatedDistance = distance(line, point);\n    return calculatedDistance <= maxRange;\n};\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n *\n * @example\n * ```js\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns\n */\nexport const slope = (lineOrPoint, b) => {\n    let a;\n    if (isLine(lineOrPoint)) {\n        a = lineOrPoint.a;\n        b = lineOrPoint.b;\n    }\n    else {\n        a = lineOrPoint;\n        if (b === undefined)\n            throw new Error(`b parameter required`);\n    }\n    if (b === undefined) {\n        throw new TypeError(`Second point missing`);\n    }\n    else {\n        return (b.y - a.y) / (b.x - a.x);\n    }\n};\n/**\n * Scales a line from its midpoint\n *\n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor\n */\nexport const scaleFromMidpoint = (line, factor) => {\n    const a = interpolate(factor / 2, line);\n    const b = interpolate(0.5 + factor / 2, line);\n    return { a, b };\n};\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line, x) => {\n    const y = line.a.y + (x - line.a.x) * slope(line);\n    return Object.freeze({ x: x, y });\n};\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line, distance) => {\n    const calculatedLength = length(line);\n    return Object.freeze({\n        ...line,\n        a: line.a,\n        b: Object.freeze({\n            x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n            y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n        })\n    });\n};\n/**\n * Yields every integer point along `line`.\n *\n * @example Basic usage\n * ```js\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n *\n * Some precision is lost as start and end\n * point is also returned as an integer.\n *\n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\nexport function* pointsOf(line) {\n    // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n    const { a, b } = line;\n    let x0 = Math.floor(a.x);\n    let y0 = Math.floor(a.y);\n    const x1 = Math.floor(b.x);\n    const y1 = Math.floor(b.y);\n    const dx = Math.abs(x1 - x0);\n    const dy = -Math.abs(y1 - y0);\n    const sx = x0 < x1 ? 1 : -1;\n    const sy = y0 < y1 ? 1 : -1;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    let err = dx + dy;\n    while (true) {\n        yield { x: x0, y: y0 };\n        if (x0 === x1 && y0 === y1)\n            break;\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const e2 = 2 * err;\n        if (e2 >= dy) {\n            err += dy;\n            x0 += sx;\n        }\n        if (e2 <= dx) {\n            err += dx;\n            y0 += sy;\n        }\n    }\n}\n/**\n * Returns the distance of `point` to the\n * nearest point on `line`.\n *\n * ```js\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line, point) => {\n    if (Array.isArray(line)) {\n        const distances = line.map(l => distanceSingleLine(l, point));\n        return minFast(distances);\n    }\n    else {\n        return distanceSingleLine(line, point);\n    }\n};\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n *\n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a, b) => {\n    if (isLine(a)) {\n        return [a.a.x, a.a.y, a.b.x, a.b.y];\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        return [a.x, a.y, b.x, b.y];\n    }\n    else {\n        throw new Error(`Expected single line parameter, or a and b points`);\n    }\n};\n/**\n * Yields all the points of all the lines.\n *\n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines\n */\nexport function* asPoints(lines) {\n    for (const l of lines) {\n        yield l.a;\n        yield l.b;\n    }\n}\n/**\n * Returns an SVG description of line\n * ```\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const toSvgString = (a, b) => [`M${a.x} ${a.y} L ${b.x} ${b.y}`];\n","import { angleRadian } from \"./angle.js\";\nimport { centroid } from \"./centroid.js\";\nimport { distance } from \"./distance.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\n/**\n * Tracks the relation between two points.\n *\n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n *\n * It computes angle, average, centroid, distance and speed.\n *\n * ```js\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n *\n * Or with destructuring:\n *\n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link PointsTracker}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a, b) => {\n    const start = getPointParameter(a, b);\n    let totalX = 0;\n    let totalY = 0;\n    let count = 0;\n    let lastUpdate = performance.now();\n    let lastPoint = start;\n    const update = (aa, bb) => {\n        const p = getPointParameter(aa, bb);\n        totalX += p.x;\n        totalY += p.y;\n        count++;\n        const distanceFromStart = distance(p, start);\n        const distanceFromLast = distance(p, lastPoint);\n        // Track speed\n        const now = performance.now();\n        const speed = distanceFromLast / (now - lastUpdate);\n        lastUpdate = now;\n        lastPoint = p;\n        return Object.freeze({\n            angle: angleRadian(p, start),\n            distanceFromStart,\n            distanceFromLast,\n            speed,\n            centroid: centroid(p, start),\n            average: {\n                x: totalX / count,\n                y: totalY / count,\n            },\n        });\n    };\n    return update;\n};\n","import { TrackedValueMap, } from '@ixfx/trackers';\nimport { ObjectTracker } from '@ixfx/trackers';\nimport { length as LineLength } from '../line/length.js';\nimport * as Vectors from '../vector.js';\nimport { Empty as LinesEmpty } from '../line/index.js';\nimport { joinPointsToLines } from '../line/join-points-to-lines.js';\nimport { relation } from './relation.js';\nimport { distance } from './distance.js';\nimport { subtract } from './subtract.js';\nimport { angleRadian } from './angle.js';\nimport { Placeholder as PointsPlaceholder } from './point-type.js';\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link PointsTracker}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport class PointTracker extends ObjectTracker {\n    initialRelation;\n    markRelation;\n    lastResult;\n    constructor(opts = {}) {\n        super(opts);\n    }\n    /**\n     * Notification that buffer has been knocked down to `sampleLimit`.\n     *\n     * This will reset the `initialRelation`, which will use the new oldest value.\n     */\n    onTrimmed(_reason) {\n        // Force new relation calculations\n        this.initialRelation = undefined;\n    }\n    /**\n     * @ignore\n     */\n    onReset() {\n        super.onReset();\n        this.lastResult = undefined;\n        this.initialRelation = undefined;\n        this.markRelation = undefined;\n    }\n    /**\n     * Adds a PointerEvent along with its\n     * coalesced events, if available.\n     * @param p\n     * @returns\n     */\n    seenEvent(p) {\n        if (`getCoalescedEvents` in p) {\n            const events = p.getCoalescedEvents();\n            const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n            return this.seen(...asPoints);\n        }\n        else {\n            return this.seen({ x: (p).clientX, y: (p).clientY });\n        }\n    }\n    /**\n     * Makes a 'mark' in the tracker, allowing you to compare values\n     * to this point.\n     */\n    mark() {\n        this.markRelation = relation(this.last);\n    }\n    /**\n     * Tracks a point, returning data on its relation to the\n     * initial point and the last received point.\n     *\n     * Use {@link seenEvent} to track a raw `PointerEvent`.\n     *\n     * @param _p Point\n     */\n    computeResults(_p) {\n        const currentLast = this.last;\n        const previousLast = this.values.at(-2);\n        if (this.initialRelation === undefined && this.initial) {\n            // Don't yet have an initial relation function\n            // Use the oldest point in the buffer (this.initial)\n            this.initialRelation = relation(this.initial);\n        }\n        else if (this.initialRelation === undefined) {\n            // Don't have an initial relation, but also don't have an initial point :()\n            throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n        }\n        // Make a new relator based on previous point\n        const lastRelation = previousLast === undefined ? relation(currentLast) : relation(previousLast);\n        // Compute relation from initial point to latest\n        const initialRel = this.initialRelation(currentLast);\n        const markRel = (this.markRelation !== undefined) ? this.markRelation(currentLast) : undefined;\n        const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n        // Compute relation from current point to the previous\n        const lastRel = {\n            ...lastRelation(currentLast),\n            speed,\n        };\n        const r = {\n            fromInitial: initialRel,\n            fromLast: lastRel,\n            fromMark: markRel,\n            values: [...this.values],\n        };\n        this.lastResult = r;\n        return r;\n    }\n    /**\n     * Returns a polyline representation of stored points.\n     * Returns an empty array if points were not saved, or there's only one.\n     */\n    get line() {\n        if (this.values.length === 1)\n            return [];\n        return joinPointsToLines(...this.values);\n    }\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a polar coordinate\n     */\n    get vectorPolar() {\n        return Vectors.fromLinePolar(this.lineStartEnd);\n    }\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a Cartesian coordinate\n     */\n    get vectorCartesian() {\n        return Vectors.fromLineCartesian(this.lineStartEnd);\n    }\n    /**\n     * Returns a line from initial point to last point.\n     *\n     * If there are less than two points, Lines.Empty is returned\n     */\n    get lineStartEnd() {\n        const initial = this.initial;\n        if (this.values.length < 2 || !initial)\n            return LinesEmpty;\n        return {\n            a: initial,\n            b: this.last,\n        };\n    }\n    /**\n     * Returns distance from latest point to initial point.\n     * If there are less than two points, zero is returned.\n     *\n     * This is the direct distance from initial to last,\n     * not the accumulated length.\n     * @returns Distance\n     */\n    distanceFromStart() {\n        const initial = this.initial;\n        return this.values.length >= 2 && initial !== undefined ? distance(initial, this.last) : 0;\n    }\n    /**\n     * Difference between last point and the initial point, calculated\n     * as a simple subtraction of x,y & z.\n     *\n     * `Points.Placeholder` is returned if there's only one point so far.\n     */\n    difference() {\n        const initial = this.initial;\n        return this.values.length >= 2 && initial !== undefined ? subtract(this.last, initial) : PointsPlaceholder;\n    }\n    /**\n     * Returns angle (in radians) from latest point to the initial point\n     * If there are less than two points, undefined is return.\n     * @returns Angle in radians\n     */\n    angleFromStart() {\n        const initial = this.initial;\n        if (initial !== undefined && this.values.length > 2) {\n            return angleRadian(initial, this.last);\n        }\n    }\n    /**\n     * Returns the total length of accumulated points.\n     * Returns 0 if points were not saved, or there's only one\n     */\n    get length() {\n        if (this.values.length === 1)\n            return 0;\n        const l = this.line;\n        return LineLength(l);\n    }\n    /**\n   * Returns the last x coord\n   */\n    get x() {\n        return this.last.x;\n    }\n    /**\n     * Returns the last y coord\n     */\n    get y() {\n        return this.last.y;\n    }\n    /**\n     * Returns the last z coord (or _undefined_ if not available)\n     */\n    get z() {\n        return this.last.z;\n    }\n}\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class PointsTracker extends TrackedValueMap {\n    constructor(opts = {}) {\n        super((key, start) => {\n            if (start === undefined)\n                throw new Error(`Requires start point`);\n            const p = new PointTracker({\n                ...opts,\n                id: key,\n            });\n            p.seen(start);\n            return p;\n        });\n    }\n    /**\n     * Track a PointerEvent\n     * @param event\n     */\n    seenEvent(event) {\n        if (`getCoalescedEvents` in event) {\n            const events = event.getCoalescedEvents();\n            const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n            return Promise.all(seens);\n        }\n        else {\n            return Promise.all([super.seen(event.pointerId.toString(), event)]);\n        }\n    }\n}\n","/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid, cell) => {\n    if (cell.x < 0 || cell.y < 0)\n        return false;\n    if (cell.x >= grid.cols || cell.y >= grid.rows)\n        return false;\n    return true;\n};\n","import { inside } from \"./inside.js\";\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell) => {\n    if (cell === undefined)\n        return false;\n    return `x` in cell && `y` in cell;\n};\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (cell, parameterName = `Param`, grid) => {\n    if (cell === undefined) {\n        throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n    }\n    if (cell.x === undefined)\n        throw new Error(parameterName + `.x is undefined`);\n    if (cell.y === undefined)\n        throw new Error(parameterName + `.y is undefined`);\n    if (Number.isNaN(cell.x))\n        throw new Error(parameterName + `.x is NaN`);\n    if (Number.isNaN(cell.y))\n        throw new Error(parameterName + `.y is NaN`);\n    if (!Number.isInteger(cell.x)) {\n        throw new TypeError(parameterName + `.x is non-integer`);\n    }\n    if (!Number.isInteger(cell.y)) {\n        throw new TypeError(parameterName + `.y is non-integer`);\n    }\n    if (grid !== undefined && !inside(grid, cell)) {\n        throw new Error(`${parameterName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid.cols}, ${grid.rows}`);\n    }\n};\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid, parameterName = `Param`) => {\n    if (grid === undefined) {\n        throw new Error(`${parameterName} is undefined. Expecting grid.`);\n    }\n    if (!(`rows` in grid))\n        throw new Error(`${parameterName}.rows is undefined`);\n    if (!(`cols` in grid))\n        throw new Error(`${parameterName}.cols is undefined`);\n    if (!Number.isInteger(grid.rows)) {\n        throw new TypeError(`${parameterName}.rows is not an integer`);\n    }\n    if (!Number.isInteger(grid.cols)) {\n        throw new TypeError(`${parameterName}.cols is not an integer`);\n    }\n};\n","import { clampIndex } from \"@ixfx/numbers\";\nimport { guardCell, guardGrid } from \"./guards.js\";\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid\n * @param cell\n * @param wrap\n * @returns\n */\nexport const applyBounds = function (grid, cell, wrap = `undefined`) {\n    guardGrid(grid, `grid`);\n    guardCell(cell, `cell`);\n    let x = cell.x;\n    let y = cell.y;\n    switch (wrap) {\n        case `wrap`: {\n            x = x % grid.cols;\n            y = y % grid.rows;\n            if (x < 0)\n                x = grid.cols + x;\n            else if (x >= grid.cols) {\n                x -= grid.cols;\n            }\n            if (y < 0)\n                y = grid.rows + y;\n            else if (y >= grid.rows) {\n                y -= grid.rows;\n            }\n            x = Math.abs(x);\n            y = Math.abs(y);\n            break;\n        }\n        case `stop`: {\n            x = clampIndex(x, grid.cols);\n            y = clampIndex(y, grid.rows);\n            break;\n        }\n        case `undefined`: {\n            if (x < 0 || y < 0)\n                return;\n            if (x >= grid.cols || y >= grid.rows)\n                return;\n            break;\n        }\n        case `unbounded`: {\n            break;\n        }\n        default: {\n            throw new Error(`Unknown BoundsLogic '${wrap}'. Expected: wrap, stop, undefined or unbounded`);\n        }\n    }\n    return Object.freeze({ x, y });\n};\n","import { guardGrid, guardCell } from \"../guards.js\";\nimport { values } from \"../values.js\";\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n *\n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n *\n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n *\n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n *\n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid, start, wrap = true) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`, grid);\n    let { x, y } = start;\n    let canMove = true;\n    do {\n        yield { x, y };\n        x++;\n        if (x === grid.cols) {\n            y++;\n            x = 0;\n        }\n        if (y === grid.rows) {\n            if (wrap) {\n                y = 0;\n                x = 0;\n            }\n            else {\n                canMove = false;\n            }\n        }\n        if (x === start.x && y === start.y)\n            canMove = false; // Complete\n    } while (canMove);\n}\n;\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n *\n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport function* cellValues(grid, start, wrap = true) {\n    yield* values(grid, cells(grid, start, wrap));\n}\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport function* cellsAndValues(grid, start, wrap = true) {\n    for (const cell of cells(grid, start, wrap)) {\n        yield { cell, value: grid.get(cell) };\n    }\n}\n","import { cells } from \"./enumerators/cells.js\";\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n *\n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid, start) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    let row = start.y;\n    let rowCells = [];\n    for (const c of cells(grid, start)) {\n        if (c.y === row) {\n            rowCells.push(c);\n        }\n        else {\n            yield rowCells;\n            rowCells = [c];\n            row = c.y;\n        }\n    }\n    if (rowCells.length > 0)\n        yield rowCells;\n};\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n *\n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n *\n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport function* columns(grid, start) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    for (let x = start.x; x < grid.cols; x++) {\n        let colCells = [];\n        for (let y = start.y; y < grid.rows; y++) {\n            colCells.push({ x, y });\n        }\n        yield colCells;\n    }\n}\n","//import { clampIndex } from '@ixfx/numbers';\nimport { applyBounds } from './apply-bounds.js';\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n *\n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (grid, start, vector, bounds = `undefined`) {\n    return applyBounds(grid, {\n        x: start.x + vector.x,\n        y: start.y + vector.y\n    }, bounds);\n    // guardCell(start, `start`, grid);\n    // guardCell(vector);\n    // guardGrid(grid, `grid`);\n    // // eslint-disable-next-line functional/no-let\n    // let x = start.x;\n    // // eslint-disable-next-line functional/no-let\n    // let y = start.y;\n    // switch (bounds) {\n    //   case `wrap`: {\n    //     x += vector.x % grid.cols;\n    //     y += vector.y % grid.rows;\n    //     if (x < 0) x = grid.cols + x;\n    //     else if (x >= grid.cols) {\n    //       x -= grid.cols;\n    //     }\n    //     if (y < 0) y = grid.rows + y;\n    //     else if (y >= grid.rows) {\n    //       y -= grid.rows;\n    //     }\n    //     break;\n    //   }\n    //   case `stop`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     x = clampIndex(x, grid.cols);\n    //     y = clampIndex(y, grid.rows);\n    //     break;\n    //   }\n    //   case `undefined`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     if (x < 0 || y < 0) return;\n    //     if (x >= grid.cols || y >= grid.rows) return;\n    //     break;\n    //   }\n    //   case `unbounded`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     break;\n    //   }\n    //   default: {\n    //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n    //   }\n    // }\n    // return Object.freeze({ x, y });\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (grid, cell, wrap) => {\n    guardGrid(grid, `grid`);\n    if (cell.x < 0) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, x: 0 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                //cell = { ...cell, x: grid.cols + cell.x };\n                cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`);\n                break;\n            }\n        }\n    }\n    if (cell.y < 0) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, y: 0 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, y: grid.rows + cell.y };\n                break;\n            }\n        }\n    }\n    if (cell.x >= grid.cols) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, x: grid.cols - 1 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, x: cell.x % grid.cols };\n                break;\n            }\n        }\n    }\n    if (cell.y >= grid.rows) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, y: grid.rows - 1 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, y: cell.y % grid.rows };\n                break;\n            }\n        }\n    }\n    const index = cell.y * grid.cols + cell.x;\n    return index;\n};\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (colsOrGrid, index) => {\n    let cols = 0;\n    cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n    resultThrow(integerTest(cols, `aboveZero`, `colsOrGrid`));\n    return {\n        x: index % cols,\n        y: Math.floor(index / cols),\n    };\n};\n","import { isPoint, guard as PointsGuard, isPlaceholder as PointsIsPlaceholder, isEmpty as PointsIsEmpty } from '../point/guard.js';\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t, name = `t`) => {\n    if (t === undefined)\n        throw new Error(`{$name} undefined`);\n    PointsGuard(t.a, name + `.a`);\n    PointsGuard(t.b, name + `.b`);\n    PointsGuard(t.c, name + `.c`);\n};\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p) => {\n    if (p === undefined)\n        return false;\n    const tri = p;\n    if (!isPoint(tri.a))\n        return false;\n    if (!isPoint(tri.b))\n        return false;\n    if (!isPoint(tri.c))\n        return false;\n    return true;\n};\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t) => PointsIsEmpty(t.a) && PointsIsEmpty(t.b) && PointsIsEmpty(t.c);\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t) => PointsIsPlaceholder(t.a) &&\n    PointsIsPlaceholder(t.b) &&\n    PointsIsPlaceholder(t.c);\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => PointsIsEqual(a.a, b.a) &&\n    PointsIsEqual(a.b, b.b) &&\n    PointsIsEqual(a.c, b.c);\n","import { isPoint } from './point/index.js';\nimport { isRect } from './rect/guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/placeholder.js';\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (scaleBy = `both`, defaultRect) => {\n    const defaultBounds = defaultRect ?? PlaceholderRect;\n    let sw = 1;\n    let sh = 1;\n    let s = { x: 1, y: 1 };\n    const computeScale = () => {\n        switch (scaleBy) {\n            case `height`: {\n                return { x: sh, y: sh };\n            }\n            case `width`: {\n                return { x: sw, y: sw };\n            }\n            case `min`: {\n                return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n            }\n            case `max`: {\n                return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n            }\n            default: {\n                return { x: sw, y: sh };\n            }\n        }\n    };\n    const normalise = (a, b, c, d) => {\n        let inX = Number.NaN;\n        let inY = Number.NaN;\n        let outW = defaultBounds.width;\n        let outH = defaultBounds.height;\n        if (typeof a === `number`) {\n            inX = a;\n            if (typeof b === `number`) {\n                inY = b;\n                if (c === undefined)\n                    return [inX, inY, outW, outH];\n                if (isRect(c)) {\n                    outW = c.width;\n                    outH = c.height;\n                }\n                else if (typeof c === `number`) {\n                    outW = c;\n                    if (typeof d === `number`) {\n                        outH = d;\n                    }\n                    else {\n                        throw new TypeError(`Missing final height value`);\n                    }\n                }\n                else\n                    throw new Error(`Missing valid output range`);\n            }\n            else if (isRect(b)) {\n                outW = b.width;\n                outH = b.height;\n            }\n            else {\n                throw new Error(`Expected input y or output Rect to follow first number parameter`);\n            }\n        }\n        else if (isPoint(a)) {\n            inX = a.x;\n            inY = a.y;\n            if (b === undefined)\n                return [inX, inY, outW, outH];\n            if (isRect(b)) {\n                outW = b.width;\n                outH = b.height;\n            }\n            else if (typeof b === `number`) {\n                outW = b;\n                if (typeof c === `number`) {\n                    outH = c;\n                }\n                else {\n                    throw new TypeError(`Expected height as third parameter after Point and output width`);\n                }\n            }\n            else {\n                throw new TypeError(`Expected Rect or width as second parameter when first parameter is a Point`);\n            }\n        }\n        else {\n            throw new Error(`Expected input Point or x value as first parameter`);\n        }\n        return [inX, inY, outW, outH];\n    };\n    const scaleAbs = (a, b, c, d) => {\n        const n = normalise(a, b, c, d);\n        return scaleNormalised(true, ...n);\n    };\n    const scaleRel = (a, b, c, d) => {\n        const n = normalise(a, b, c, d);\n        return scaleNormalised(false, ...n);\n    };\n    const scaleNormalised = (abs, x, y, w, h) => {\n        if (Number.isNaN(w))\n            throw new Error(`Output width range missing`);\n        if (Number.isNaN(h))\n            throw new Error(`Output height range missing`);\n        // If output dimensions has changed since last, create a new scale\n        if (w !== sw || h !== sh) {\n            sw = w;\n            sh = h;\n            s = computeScale();\n        }\n        return abs ? {\n            x: x * s.x,\n            y: y * s.y,\n        } : {\n            x: x / s.x,\n            y: y / s.y,\n        };\n    };\n    return {\n        computeScale,\n        rel: scaleRel,\n        abs: scaleAbs,\n        width: defaultBounds.width,\n        height: defaultBounds.height\n    };\n};\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }\n","import { guard } from \"./guard.js\";\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t) => {\n    guard(t);\n    return [t.a, t.b, t.c];\n};\n","import { resolveEl, resolveEls } from \"./resolve-el.js\";\n/**\n * Returns the value of `getBoundingClientRect` plus the width of all the borders\n * @param elOrQuery\n * @returns\n */\nexport const getBoundingClientRectWithBorder = (elOrQuery) => {\n    let el = resolveEl(elOrQuery);\n    const size = el.getBoundingClientRect();\n    if (el instanceof SVGElement) {\n        el = el.parentElement;\n    }\n    const border = getComputedPixels(el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);\n    return {\n        x: size.x,\n        y: size.y,\n        width: size.width + border.borderLeftWidth + border.borderRightWidth,\n        height: size.height + border.borderTopWidth + border.borderBottomWidth\n    };\n};\n/**\n * Returns the computed measurements of CSS properties via [getComputedStyle](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle).\n *\n * ```js\n * const v = getComputedPixels(`#some-el`, `borderTopWidth`, `borderLeftWidth`);\n * v.borderTopWidth;  // number\n * b.borderLeftWidth; // number\n * ```\n *\n * Throws an error if value from `getComputedStyle` is not a string or does not end in 'px'.\n * @param elOrQuery\n * @param properties\n * @returns\n */\nexport const getComputedPixels = (elOrQuery, ...properties) => {\n    const s = getComputedStyle(resolveEl(elOrQuery));\n    const returnValue = {};\n    for (const property of properties) {\n        const v = s[property];\n        if (typeof v === `string`) {\n            if (v.endsWith(`px`)) {\n                returnValue[property] = Number.parseFloat(v.substring(0, v.length - 2));\n            }\n            else {\n                throw new Error(`Property '${String(property)}' does not end in 'px'. Value: ${v}`);\n            }\n        }\n        else {\n            throw new Error(`Property '${String(property)}' is not type string. Got: ${typeof v} Value: ${v}`);\n        }\n    }\n    return returnValue;\n};\n/**\n * If `value` is _true_, the provided CSS class is added to element(s), otherwise it is removed.\n *\n * ```js\n * setClass(`#someId`, true, `activated`); // Add 'activated'\n * setClass(`#someId`, false, `activated`); // Removes 'activated'\n * ```\n *\n * @param selectors\n * @param value\n * @param cssClass\n * @returns\n */\nexport const setCssClass = (selectors, value, cssClass) => {\n    const elements = resolveEls(selectors);\n    if (elements.length === 0)\n        return;\n    for (const element of elements) {\n        if (value)\n            element.classList.add(cssClass);\n        else\n            element.classList.remove(cssClass);\n    }\n};\n/**\n * Toggles a CSS class on all elements that match selector.\n *\n * ```js\n * setCssToggle(`span`, `activated`); // Toggles the 'activated' class on all SPAN elements\n * ```\n *\n * Uses `HTMLElement.classList.toggle`\n * @param selectors\n * @param cssClass\n * @returns\n */\nexport const setCssToggle = (selectors, cssClass) => {\n    const elements = resolveEls(selectors);\n    if (elements.length === 0)\n        return;\n    for (const element of elements) {\n        element.classList.toggle(cssClass);\n    }\n};\n/**\n * Sets the CSS 'display' property\n *\n * ```js\n * setCssDisplay(`span`, `block`); // Sets display:block for all spans\n * ```\n *\n * @param selectors\n * @param value\n * @returns\n */\nexport const setCssDisplay = (selectors, value) => {\n    const elements = resolveEls(selectors);\n    if (elements.length === 0)\n        return;\n    for (const element of elements) {\n        (element).style.display = value;\n    }\n};\n","import { intervalToMs } from \"@ixfx/core\";\nexport const debounce = (callback, interval) => {\n    let timer;\n    const ms = intervalToMs(interval, 100);\n    return () => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        if (timer)\n            clearTimeout(timer);\n        timer = setTimeout(callback, ms);\n    };\n};\n","import { resolveEl } from \"./resolve-el.js\";\nimport { getComputedPixels } from \"./css.js\";\nimport { Rects } from \"@ixfx/geometry\";\nimport { debounce } from \"./internal/debounce.js\";\nimport { intervalToMs } from \"@ixfx/core\";\n/**\n * Consider using static methods:\n *\n * ```js\n * // Resize an <SVG> element to match viewport\n * Dom.ElementSizer.svgViewport(svg);\n *\n * // Resize canvas to match its parent\n * Dom.ElementSizer.canvasParent(canvas);\n *\n * // Resize canvas to match viewport\n * Dom.ElementSizer.canvasViewport(canvas);\n * ```\n */\nexport class ElementSizer {\n    #stretch;\n    #size;\n    #naturalSize;\n    #naturalRatio;\n    #viewport;\n    #onSizeChanging;\n    #el;\n    #containerEl;\n    #disposed = false;\n    #resizeObservable;\n    #sizeDebounce = () => ({});\n    constructor(elOrQuery, options) {\n        this.#el = resolveEl(elOrQuery);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.#containerEl = options.containerEl ? resolveEl(options.containerEl) : this.#el.parentElement;\n        this.#stretch = options.stretch ?? `none`;\n        this.#onSizeChanging = options.onSizeChanging;\n        this.#size = Rects.Empty;\n        const onSizeDone = options.onSizeDone;\n        if (typeof onSizeDone !== `undefined`) {\n            this.#sizeDebounce = debounce(() => {\n                onSizeDone(this.size, this.#el);\n            }, options.debounceTimeout);\n        }\n        let naturalSize = options.naturalSize;\n        naturalSize ??= this.#el.getBoundingClientRect();\n        this.#naturalRatio = 1;\n        this.#naturalSize = naturalSize;\n        this.setNaturalSize(naturalSize);\n        this.#viewport = Rects.EmptyPositioned;\n        if (this.#containerEl === document.body) {\n            this.#byViewport();\n        }\n        else {\n            this.#byContainer();\n        }\n    }\n    dispose(reason) {\n        if (this.#disposed)\n            return;\n        this.#disposed = true;\n        if (this.#resizeObservable) {\n            this.#resizeObservable.disconnect();\n            this.#resizeObservable = undefined;\n        }\n    }\n    static canvasParent(canvasElementOrQuery, options) {\n        const el = resolveEl(canvasElementOrQuery);\n        const er = new ElementSizer(el, {\n            ...options,\n            onSizeChanging(size, el) {\n                el.width = size.width;\n                el.height = size.height;\n                if (options.onSizeChanging)\n                    options.onSizeChanging(size, el);\n            },\n        });\n        return er;\n    }\n    static canvasViewport(canvasElementOrQuery, options) {\n        const el = resolveEl(canvasElementOrQuery);\n        el.style.position = `absolute`;\n        el.style.zIndex = (options.zIndex ?? 0).toString();\n        el.style.left = `0px`;\n        el.style.top = `0px`;\n        const opts = { ...options, containerEl: document.body };\n        return this.canvasParent(canvasElementOrQuery, opts);\n    }\n    /**\n     * Size an SVG element to match viewport\n     * @param svg\n     * @returns\n     */\n    static svgViewport(svg, onSizeSet) {\n        const er = new ElementSizer(svg, {\n            containerEl: document.body,\n            stretch: `both`,\n            onSizeChanging(size) {\n                svg.setAttribute(`width`, size.width.toString());\n                svg.setAttribute(`height`, size.height.toString());\n                if (onSizeSet)\n                    onSizeSet(size);\n            },\n        });\n        return er;\n    }\n    #byContainer() {\n        const c = this.#containerEl;\n        if (!c)\n            throw new Error(`No container element`);\n        // Listen for resize\n        const r = new ResizeObserver((entries) => {\n            this.#onParentResize(entries);\n        });\n        r.observe(c);\n        // Get current value\n        const current = this.#computeSizeBasedOnParent(c.getBoundingClientRect());\n        this.size = current;\n        this.#resizeObservable = r;\n    }\n    #byViewport() {\n        const r = new ResizeObserver((entries) => {\n            this.#onViewportResize();\n        });\n        r.observe(document.documentElement);\n        this.#resizeObservable = r;\n        this.#onViewportResize();\n    }\n    #onViewportResize() {\n        this.size = { width: window.innerWidth, height: window.innerHeight };\n        this.#viewport = {\n            x: 0, y: 0,\n            ...this.size\n        };\n    }\n    /**\n     * Sets the 'natural' size of an element.\n     * This can also be specified when creating ElementSizer.\n     * @param size\n     */\n    setNaturalSize(size) {\n        this.#naturalSize = size;\n        this.#naturalRatio = size.width / size.height;\n    }\n    get naturalSize() {\n        return this.#naturalSize;\n    }\n    get viewport() {\n        return this.#viewport;\n    }\n    #computeSizeBasedOnParent(parentSize) {\n        let { width, height } = parentSize;\n        let stretch = this.#stretch;\n        if (stretch === `min`) {\n            stretch = width < height ? `width` : `height`;\n        }\n        else if (stretch === `max`) {\n            stretch = width > height ? `width` : `height`;\n        }\n        if (stretch === `width`) {\n            height = width / this.#naturalRatio;\n        }\n        else if (stretch === `height`) {\n            width = height * this.#naturalRatio;\n        }\n        // If we have a border, take that into account\n        if (this.#el instanceof HTMLElement) {\n            const b = getComputedPixels(this.#el, `borderTopWidth`, `borderLeftWidth`, `borderRightWidth`, `borderBottomWidth`);\n            width -= (b.borderLeftWidth + b.borderRightWidth);\n            height -= (b.borderTopWidth + b.borderBottomWidth);\n        }\n        return { width, height };\n    }\n    #onParentResize(args) {\n        const box = args[0].contentBoxSize[0];\n        const parentSize = { width: box.inlineSize, height: box.blockSize };\n        this.size = this.#computeSizeBasedOnParent(parentSize);\n        this.#viewport = {\n            x: 0, y: 0,\n            width: parentSize.width,\n            height: parentSize.height\n        };\n    }\n    set size(size) {\n        Rects.guard(size, `size`);\n        this.#size = size;\n        this.#onSizeChanging(size, this.#el);\n        this.#sizeDebounce();\n    }\n    get size() {\n        return this.#size;\n    }\n}\n","import { toColour, toCssColour } from './conversion.js';\nimport * as HslSpace from './hsl.js';\nimport * as SrgbSpace from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\nimport { OklchSpace } from './index.js';\nimport * as C from 'colorizr';\n/**\n * Multiplies the opacity of a colour by `amount`, returning a computed CSS colour.\n *\n * ```js\n * multiplyOpacity(`red`, 0.5); // Returns a colour string\n * ```\n *\n * For example, to half the opacity, use `amount: 0.5`.\n * Clamps the result to ensure it's between 0..1\n * @param colourish Colour\n * @param amount Amount\n * @returns\n */\nexport function multiplyOpacity(colourish, amount) {\n    return withOpacity(colourish, o => clamp(o * amount));\n}\n/**\n * Does a computation with the opacity of a colour, returning colour.\n *\n * Passes operation to `HslSpace` or `SrgbSpace` depending on space of `colourish`.\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\nexport function withOpacity(colourish, fn) {\n    const colour = toColour(colourish);\n    let result;\n    switch (colour.space) {\n        case `hsl`:\n            result = HslSpace.withOpacity(colour, fn);\n            break;\n        case `srgb`:\n            result = SrgbSpace.withOpacity(colour, fn);\n            break;\n        case `oklch`:\n            result = OklchSpace.withOpacity(colour, fn);\n            break;\n        default:\n            throw new Error(`Unknown space: '${colour.space}'. Expected hsl, srgb, oklch`);\n    }\n    if (!result)\n        throw new Error(`Is colour in correct form?`);\n    // If input type was string, return result as string\n    if (typeof colourish === `string`) {\n        return toCssColour(result);\n    }\n    return result;\n}\n;\nexport function setOpacity(colourish, opacity) {\n    const colour = toColour(colourish);\n    colour.opacity = opacity;\n    if (typeof colourish === `string`) {\n        return toCssColour(colour);\n    }\n    return colour;\n}\n// export function lighten(colour: string, amount: number): string;\n// export function lighten(colour: Colour, amount: number): Colour;\n// export function lighten(colourish: Colourish, amount: number): Colourish {\n//   const asString = toCssColour(colourish);\n//   const result = C.lighten(asString, amount, ``)\n// }\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };\n","import { arrayTest, resultThrow } from '@ixfx/guards';\nimport { Colour } from '@ixfx/visual';\nimport { resolveEl } from '@ixfx/dom';\n//import type { IStackImmutable } from '@ixfx/collections';\nimport { StackImmutable, type IStackImmutable } from '@ixfx/collections/stack';\nimport { Beziers, Lines, Points, Rects, Triangles, type Arcs, type Circles, type Ellipses, type Paths } from '@ixfx/geometry';\nimport { quantiseEvery } from '@ixfx/numbers';\n\n// import type { Point } from '../geometry/point/PointType.js';\n// import type { Line } from '../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../geometry/circle/CircleType.js';\n// import type { Rect, RectPositioned } from '../geometry/rect/index.js';\n// import type { Path } from '../geometry/path/PathType.js';\n// import type { Triangle } from '../geometry/triangle/TriangleType.js';\n\n// import { Empty as RectsEmpty } from '../geometry/rect/Empty.js';\n// import { corners as RectsCorners } from '../geometry/rect/Corners.js';\n// import { isLine } from '../geometry/line/Guard.js';\n// import { quantiseEvery } from '../numbers/Quantise.js';\n\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElementContextOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\n\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rects.Rect\n) => {\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    ctx,\n    paths(pathsToDraw: Paths.Path[] | readonly Paths.Path[], opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Lines.Line | Lines.Line[], opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n      opts?: RectOpts\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Points.Point[],\n      opts?: DrawingOpts & Partial<ConnectedPointsOptions>\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Points.Point[], opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Points.Point | Points.Point[],\n      opts?: DotOpts\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[],\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[],\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: string[],\n      opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: readonly StackOp[]\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray: Arcs.ArcPositioned[] = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: readonly StackOp[]): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  stk ??= new StackImmutable<StackOp>();\n\n  const push = (...ops: StackOp[]): DrawingStack => {\n    stk ??= new StackImmutable<StackOp>();\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: readonly Points.Point[],\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: Circles.CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c as Circles.CirclePositioned);\n  } else {\n    draw(circlesToDraw as Circles.CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: readonly Paths.Path[] | Paths.Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Paths.Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (Lines.isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Paths.Path);\n  }\n};\n\nexport type ConnectedPointsOptions = {\n  readonly lineWidth: number\n  readonly loop: boolean\n  readonly fillStyle: string\n  readonly strokeStyle: string\n}\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: Partial<ConnectedPointsOptions> = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n  resultThrow(arrayTest(pts, `pts`));\n\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: { readonly fillStyle?: string } = {},\n  labels?: readonly string[]\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Points.Point\n): Points.Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\nexport type DotOpts = DrawingOpts & {\n  readonly radius?: number;\n  readonly stroke?: boolean;\n  readonly filled?: boolean;\n  readonly strokeWidth?: number;\n}\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned,\n  opts?: DotOpts\n) => {\n  opts ??= {};\n  const radius = opts.radius ?? 10;\n  const positions = Array.isArray(pos) ? pos : [ pos ];\n  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== undefined;\n  let filled = opts.filled ? opts.filled : opts.fillStyle !== undefined;\n  if (!stroke && !filled) filled = true;\n\n  applyOpts(ctx, opts);\n\n  for (const pos of positions) {\n    ctx.beginPath();\n    if (`radius` in pos) {\n      ctx.arc(pos.x, pos.y, pos.radius, 0, 2 * Math.PI);\n    } else {\n      ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\n    }\n    if (filled) {\n      ctx.fill();\n    }\n    if (stroke) {\n      ctx.stroke();\n    }\n  }\n\n  // const makePath = () => {\n  //   ctx.beginPath();\n\n  //   // x&y for arc is the center of circle\n  //   if (Array.isArray(pos)) {\n  //     for (const p of pos) {\n  //       ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //     }\n  //   } else {\n  //     const p = pos as Point;\n  //     ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //   }\n  // }\n  // makePath();\n  // if (opts.filled || !opts.stroke) {\n  //   ctx.fill();\n  // }\n  // if (opts.stroke) {\n  //   if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n  //   //makePath();\n  //   ctx.stroke();\n  // }\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Lines.Line | readonly Lines.Line[],\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Lines.Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t as Lines.Line);\n  } else {\n    draw(toDraw as Lines.Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangles.Triangle | readonly Triangles.Triangle[],\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangles.Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangles.Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n\nexport type RectOpts = DrawingOpts & Readonly<Partial<{\n  stroke: boolean\n  filled: boolean\n  strokeWidth: number\n  /**\n   * If true, diagonals are drawn\n   */\n  crossed: boolean\n}>>\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n  opts: RectOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroke = opts.stroke ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: Rects.RectPositioned | Rects.Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroke) {\n      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n      //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n      ctx.strokeRect(x, y, d.width, d.height);\n    }\n    if (opts.crossed) {\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(d.width, d.height);\n      ctx.stroke();\n      ctx.moveTo(0, d.height);\n      ctx.lineTo(d.width, 0);\n      ctx.stroke();\n    }\n    if (opts.debug) {\n      pointLabels(ctx, Rects.corners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Rects.RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rects.Rect => {\n  if (text === undefined || text === null || text.length === 0) return Rects.Empty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? quantiseEvery(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: readonly string[],\n  opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n  const align = opts.align ?? `top`;\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  if (align === `top`) {\n    ctx.textBaseline = `top`;\n  } else {\n    ctx.textBaseline = `middle`;\n  }\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: readonly string[] | string,\n  opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import type { Hsl, Rgb, OkLch, Colourish } from \"./types.js\";\n\nexport const isHsl = (v: any): v is Hsl => {\n  if (typeof v !== `object`) return false;\n  if (!(`h` in v)) return false;\n  if (!(`s` in v)) return false;\n  if (!(`l` in v)) return false;\n  if (!(`unit` in v)) return false;\n  if (!(`space` in v)) return false;\n  if (v.space !== `hsl`) return false;\n  return true;\n}\n\nexport const isRgb = (v: any): v is Rgb => {\n  if (typeof v !== `object`) return false;\n  if (!(`r` in v)) return false;\n  if (!(`g` in v)) return false;\n  if (!(`b` in v)) return false;\n  if (!(`space` in v)) return false;\n  if (!(`unit` in v)) return false;\n  if (v.space === `srgb`) return true;\n  return false;\n}\n\n\n/**\n * If the input object has r,g&b properties, it will return a fully-\n * formed Rgb type with `unit` and `space` properties.\n * \n * If it lacks these basic three properties or they are out of range,\n *  _undefined_ is returned.\n * \n * If RGB values are less than 1 assumes unit:scalar. Otherwise unit:8bit.\n * If RGB values exceed 255, _undefined_ returned.\n * @param v \n * @returns \n */\nexport const tryParseObjectToRgb = (v: any): Rgb | undefined => {\n  if (!(`r` in v && `g` in v && `b` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.r > 255 && v.g <= 255 && v.b <= 255) {\n      return; // out of range\n    } else {\n      v.unit = `8bit`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `srgb`;\n  }\n  return v as Rgb;\n}\n\nexport const tryParseObjectToHsl = (v: any): Hsl | undefined => {\n  if (!(`h` in v && `s` in v && `l` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.s > 100 && v.l <= 100) {\n      return; // out of range\n    } else {\n      v.unit = `absolute`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `hsl`;\n  }\n  return v as Hsl;\n}\n\nexport const isOkLch = (v: any): v is OkLch => {\n  if (typeof v !== `object`) return false;\n  if (!(`l` in v)) return false;\n  if (!(`c` in v)) return false;\n  if (!(`h` in v)) return false;\n  if (!(`unit` in v)) return false;\n  if (!(`space` in v)) return false;\n  if (v.space === `lch`) return true;\n  if (v.space === `oklch`) return true;\n  return false;\n}\n\nexport const isColourish = (v: any): v is Colourish => {\n  if (typeof v === `string`) return true;\n  if (typeof v !== `object`) return false;\n  if (isHsl(v)) return true;\n  if (isOkLch(v)) return true;\n  if (isRgb(v)) return true;\n  return false;\n}","export function calculateHueDistance(a: number, b: number, limit = 1) {\n  let long = -1;\n  let short = -1;\n  if (b < a) {\n    long = (b - a);\n    short = limit - (a - b);\n  } else {\n    long = (b - a);\n    short = (long) - limit;\n  }\n  const forward = short > 0 ? short : long;\n  const backward = short > 0 ? long : short;\n  if (Math.abs(long) < Math.abs(short)) {\n    const t = short;\n    short = long;\n    long = t;\n  }\n  return { long, short, forward, backward };\n}\n\nexport function wrapScalarHue(value: number) {\n  value = value % 1;\n  if (value < 0) return (1 - Math.abs(value)) % 1;\n  return value;\n}\n\n// export function cssAngleFormat(value:string) {\n//   let start = value.indexOf(`)`);\n//   let end = value.lastIndexOf(')');\n//   if (start < 0) return value;\n//   if (end < start) return value;\n\n// }","import Colorizr, * as C from \"colorizr\";\nimport type { Colourish, Hsl, HslAbsolute, HslScalar, ParsingOptions, Rgb } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest, percentTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours, resolveCss } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { isRgb } from \"./guards.js\";\nimport { calculateHueDistance, wrapScalarHue } from \"./utility.js\";\nimport { parseCssRgbFunction, to8bit as rgbTo8bit, toLibraryHsl as rgbToLibraryHsl } from \"./srgb.js\";\n\n/**\n * Scales the opacity value of an input HSL value\n * ```js\n * withOpacity()\n * ```\n * @param value Colour\n * @param fn Function that calcules opacity based on input scalar value\n * @returns \n */\nexport const withOpacity = <T extends Hsl>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\n/**\n * Increases or decreases lightness by this percentage, returning new colour\n * \n * Amount to change:\n * * 'fixed': a fixed amount\n * * 'delta': increase/decrease by this amount\n * * 'pdelta': proportion of current value to change by ('percentage delta')\n * \n * ```\n * const colour = { h: 0.5, s: 0.5, l: 0.5, space: `hsl`, unit: `scalar` };\n * changeLightness(colour, { pdelta: 0.1 }); // l: 0.55\n * changeLightness(colour, { delta: 0.1 });  // l: 0.6\n * changeLightness(colour, { fixed: 0.5 });  // l: 0.5\n * ```\n * \n * Keep in mind the numerical value will depend on the unit of `value`. If it's scalar,\n * lightness is 0..1 scale, otherwise 0..100 scale.\n * \n * Use negative values to decrease (does not apply to 'fixed')\n * @param value Hsl colour\n * @param amount Amount to change\n */\nexport const changeLightness = (value: Hsl, amount: Partial<{ pdelta: number, delta: number, fixed: number }>): Hsl => {\n  let newL = 0;\n  if (typeof amount.pdelta !== `undefined`) {\n    newL = value.l + (value.l * amount.pdelta);\n  } else if (typeof amount.delta !== `undefined`) {\n    newL = amount.delta + value.l;\n  } else if (typeof amount.fixed !== `undefined`) {\n    if (amount.fixed < 0) throw new TypeError(`Cannot use negative value with 'fixed'`);\n    newL = amount.fixed;\n  } else {\n    throw new TypeError(`Parameter 'amount' is missing 'delta/pdelta/fixed' properties`);\n  }\n  return {\n    ...value,\n    l: scaleProperty(value, newL, `l`)\n  }\n}\n\nconst scaleProperty = (hsl: Hsl, value: number, property: `l` | `h` | `s`) => {\n  if (hsl.unit === `scalar`) {\n    // 0..1 scale\n    if (value > 1) value = 1;\n    else if (value < 0) value = 0;\n  } else {\n    // 0..100 scale\n    if (value > 100) value = 100;\n    else if (value < 0) value = 0;\n  }\n  return value;\n}\n\nconst hslTransparent = Object.freeze({\n  h: 0, s: 0, l: 0, opacity: 0, unit: `absolute`, space: `hsl`\n});\n\nexport function fromHexString<T extends ParsingOptions<Hsl>>(hexString: string, scalar: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\n\nexport function fromHexString(hexString: string, options: ParsingOptions<Hsl> = {}): Hsl {\n  return fromLibrary(C.hex2hsl(hexString), options);\n}\n\nexport function fromCss<T extends ParsingOptions<Hsl>>(value: string, options?: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\nexport function fromCss(value: string, options: Partial<ParsingOptions<Hsl>> = {}): Hsl {\n  value = value.toLowerCase();\n\n  if (value.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);\n  if (value.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);\n\n  if (value.startsWith(`#`)) {\n    return fromHexString(value, options);\n  }\n  if (value.startsWith(`--`)) {\n    try {\n      value = resolveCss(value);\n    } catch (error) {\n      if (typeof options.fallbackString !== `undefined`) value = options.fallbackString;\n      if (typeof options.fallbackColour !== `undefined`) return options.fallbackColour;\n      throw error;\n    }\n  }\n  if (value === `transparent`) return hslTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string, options);\n  }\n\n  if (value.startsWith(`rgb(`)) {\n    const hsl = rgbToLibraryHsl(value);\n    return fromLibrary(hsl, options);\n  }\n\n  if (!value.startsWith(`hsl(`)) {\n    try {\n      value = C.convert(value, `hsl`);\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  try {\n    // Hand-rolled hsl() parse because the package is broken\n    const hsl = parseCssHslFunction(value);\n    if (options.scalar) return toScalar(hsl);\n    return toAbsolute(hsl);\n  } catch (error) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw error;\n  }\n\n}\n\nexport const toCssString = (hsl: Hsl): string => {\n  const abs = toAbsolute(hsl);\n  let css = `hsl(${ abs.h }deg ${ abs.s }% ${ abs.l }%`;\n  if (`opacity` in abs && abs.opacity !== undefined && abs.opacity < 100) {\n    css += ` / ${ abs.opacity }%`;\n  }\n  css += ')';\n  return css;\n}\n\nconst toLibrary = (hsl: Hsl): C.HSL => {\n  const abs = toAbsolute(hsl);\n  return {\n    h: abs.h,\n    s: abs.s,\n    l: abs.l,\n    alpha: abs.opacity,\n  }\n}\nfunction fromLibrary<T extends ParsingOptions<Hsl>>(hsl: C.HSL, parsingOptions: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\n\nfunction fromLibrary<T extends Hsl>(hsl: C.HSL, parsingOptions: ParsingOptions<T> = {}): T {\n  if (typeof hsl === `undefined` || hsl === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n  const scalarOpt = parsingOptions.scalar ?? true;\n\n  // Library result is absolute\n  resultThrow(\n    numberInclusiveRangeTest(hsl.h, 0, 360, `h`),\n    numberInclusiveRangeTest(hsl.s, 0, 100, `s`),\n    numberInclusiveRangeTest(hsl.l, 0, 100, `l`),\n    percentTest((hsl.alpha ?? 1), `alpha`)\n    // () => hsl.alpha !== undefined ? numberInclusiveRangeTest(hsl.alpha, 0, 100, `alpha`) : { success: true, value: hsl },\n  );\n  if (scalarOpt) {\n    return scalar(hsl.h / 360, hsl.s / 100, hsl.l / 100, (hsl.alpha ?? 1)) as T;\n  } else {\n    return absolute(hsl.h, hsl.s, hsl.l, (hsl.alpha ?? 1) * 100) as T;\n  }\n}\n\nexport const toAbsolute = (hslOrString: Hsl | Rgb | string): HslAbsolute => {\n  // if (typeof hslOrString === `string`) {\n  //   return toAbsolute(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: false }));\n  // }\n  if (typeof hslOrString === `string`) {\n    return fromCss(hslOrString, { scalar: false });\n    // try {\n    //   return toScalar(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: true }));\n    // } catch (error) {\n    //   console.error(`Hsl.toScalar: ${ hslOrString }`);\n    //   throw error;\n    // }\n  }\n  if (isRgb(hslOrString)) {\n    return toAbsolute(fromLibrary(rgbToLibraryHsl(hslOrString), { scalar: false }));\n  }\n  const hsl = hslOrString;\n  guard(hsl);\n  if (hsl.unit === `absolute`) return hsl;\n  return {\n    h: hsl.h * 360,\n    s: hsl.s * 100,\n    l: hsl.l * 100,\n    opacity: (hsl.opacity ?? 1) * 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\n/**\n * Generates a {@link HslScalar} value.\n * \n * ```js\n * generateScaler(10); // 10deg, default to full saturation, half lightness and full opacity\n * \n * // Generate HSL value from radian angle and 50% saturation\n * generateScalar(`10rad`, 0.5); \n * \n * // Generate from numeric CSS variable\n * generateScalar(`--hue`);\n * ```\n * @param absoluteHslOrVariable Hue angle or CSS variable\n * @param saturation \n * @param lightness \n * @param opacity \n */\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, saturation = 1, lightness = 0.5, opacity = 1): HslScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  const hue = angleParse(absoluteHslOrVariable);\n  if (saturation > 1) throw new TypeError(`Param 'saturation' must be between 0..1`);\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  return {\n    h: hueDeg,\n    s: saturation,\n    l: lightness,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\n/**\n * Converts a {@link Hsl} value to scalar units, or parses a colour string\n * and converts it.\n * \n * ```js\n * toScalar({ h: 100, s: 50, l: 100, unit: `absolute` });\n * toScalar(`red`);\n * ```\n * @param hslOrString \n * @returns \n */\nexport const toScalar = (hslOrString: Rgb | Hsl | string): HslScalar => {\n  if (typeof hslOrString === `string`) {\n    return fromCss(hslOrString, { scalar: true });\n    // try {\n    //   return toScalar(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: true }));\n    // } catch (error) {\n    //   console.error(`Hsl.toScalar: ${ hslOrString }`);\n    //   throw error;\n    // }\n  }\n  if (isRgb(hslOrString)) {\n    return toScalar(fromLibrary(rgbToLibraryHsl(hslOrString), { scalar: true }));\n  }\n\n  const hsl = hslOrString;\n  guard(hsl);\n  if (hsl.unit === `scalar`) return hsl;\n  return {\n    h: hsl.h / 360,\n    s: hsl.s / 100,\n    l: hsl.l / 100,\n    opacity: (hsl.opacity ?? 1) / 100,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\nexport const guard = (hsl: Hsl) => {\n  const { h, s, l, opacity, space, unit } = hsl;\n  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${ space }`);\n  if (unit === `absolute`) {\n    resultThrow(\n      numberTest(h, `finite`, `h`),\n      numberInclusiveRangeTest(s, 0, 100, `s`),\n      numberInclusiveRangeTest(l, 0, 100, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 100, `opacity`);\n        }\n      });\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(h, `percentage`, `h`),\n      numberTest(s, `percentage`, `s`),\n      numberTest(l, `percentage`, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport const interpolator = (a: Hsl | string, b: Hsl | string, direction: `longer` | `shorter` = `shorter`) => {\n  a = toScalar(a);\n  b = toScalar(b);\n  const aOpacity = a.opacity ?? 1;\n  const distanceCalc = calculateHueDistance(a.h, b.h, 1);\n  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;\n  const satDistance = b.s - a.s;\n  const lightDistance = b.l - a.l;\n  const opacityDistance = (b.opacity ?? 1) - aOpacity;\n\n  return (amount: number): HslScalar => {\n    amount = clamp(amount);\n    let h = interpolate(amount, 0, Math.abs(hueDistance));\n    if (hueDistance < 0) h = a.h - h;\n    else h = a.h + h;\n\n    const s = interpolate(amount, 0, satDistance);\n    const l = interpolate(amount, 0, lightDistance);\n    const o = interpolate(amount, 0, opacityDistance);\n    return scalar(wrapScalarHue(h), s + a.s, l + a.l, o + aOpacity);\n  }\n}\n\n/**\n * Creates a HslScalar value from scalar (0..1) values\n * @param hue \n * @param sat \n * @param lightness \n * @param opacity \n * @returns \n */\nexport function scalar(hue = 0.5, sat = 1, lightness = 0.5, opacity = 1): HslScalar {\n  const hsl: HslScalar = {\n    unit: `scalar`,\n    space: `hsl`,\n    h: hue,\n    s: sat,\n    l: lightness,\n    opacity: opacity\n  }\n  guard(hsl);\n  return hsl;\n}\n\nexport function absolute(hue = 200, sat = 100, lightness = 50, opacity = 100): HslAbsolute {\n  const hsl: HslAbsolute = {\n    unit: `absolute`,\n    space: `hsl`,\n    h: hue,\n    s: sat,\n    l: lightness,\n    opacity: opacity\n  }\n  guard(hsl);\n  return hsl;\n}\n\n/**\n * It seems Colorizr can't handle 'deg' units\n * @param value \n */\nexport function parseCssHslFunction(value: string): Hsl {\n  if (value.startsWith(`hsla`)) throw new Error(`hsla() is not supported`);\n  if (!value.startsWith(`hsl(`)) throw new Error(`Expected hsl(..) CSS colour`);\n\n  const start = value.indexOf('(');\n  const end = value.indexOf(')');\n  if (end < start) throw new Error(`Is hsl() not terminated? Missing ')'`);\n\n  const part = value.substring(start + 1, end);\n  let split = part.split(/[\\s,]+/);\n  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${ split.length } length`);\n\n  let returnRelative = false;\n  if (split[ 0 ].endsWith(`%`)) returnRelative = true;\n  if (split[ 1 ].endsWith(`%`) && split[ 2 ].endsWith(`%`)) returnRelative = true;\n\n  const valueAsScalar = (v: string, pos: number) => {\n    if (v === `none`) return 0;\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100;\n    }\n    if (v.endsWith(`deg`) && pos === 0) {\n      v = v.substring(0, v.length - 3);\n    }\n\n    const vf = Number.parseFloat(v);\n    if (pos === 0) return vf / 360;\n    if (pos === 3) return vf; // opacity\n    return vf / 100;\n  }\n\n  const valueAsAbs = (v: string, pos: number) => {\n    if (v === `none`) return 0;\n    if (v.endsWith(`%`)) {\n      const vf = Number.parseFloat(v.substring(0, v.length - 1));\n      if (pos === 0) return vf * 360;\n      return vf;\n    }\n    if (v.endsWith(`deg`) && pos === 0) {\n      return Number.parseFloat(v.substring(0, v.length - 3));\n    }\n    const vf = Number.parseFloat(v);\n    return vf;\n  }\n\n  // Is there opacity?\n  if (split.length > 3) {\n    if (split[ 3 ] === '/') {\n      // Remove / part\n      split = [ split[ 0 ], split[ 1 ], split[ 2 ], split[ 4 ] ];\n    }\n  }\n  if (returnRelative) {\n    return scalar(\n      valueAsScalar(split[ 0 ], 0),\n      valueAsScalar(split[ 1 ], 1),\n      valueAsScalar(split[ 2 ], 2),\n      valueAsScalar(split[ 3 ] ?? `100%`, 3)\n    )\n  } else {\n    // Return as absolute\n    return absolute(\n      valueAsAbs(split[ 0 ], 0),\n      valueAsAbs(split[ 1 ], 1),\n      valueAsAbs(split[ 2 ], 2),\n      valueAsAbs(split[ 3 ] ?? `100%`, 3)\n    )\n  }\n}\n\n/**\n * Converts a Hsl structure (or CSS string) to Colorizr's RGB format\n * @param hsl HSL colour\n * @returns \n */\nexport function toLibraryRgb(hsl: Hsl | string): C.RGB {\n  if (typeof hsl === `string`) {\n    const parseResult = fromCss(hsl, { scalar: false });\n    //console.log(`parseResult hsl: ${ hsl } pr: `, parseResult);\n    return toLibraryRgb(parseResult);\n  }\n  hsl = toAbsolute(hsl);\n  //console.log(`toLibraryRgb hsl`, hsl);\n  const rgb = C.hsl2rgb({ h: hsl.h, s: hsl.s, l: hsl.l });\n  return { ...rgb, alpha: (hsl.opacity ?? 100) / 100 * 255 };\n}","import type { OkLch, OkLchAbsolute, OkLchScalar, ParsingOptions } from \"./types.js\";\nimport { numberInclusiveRangeTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport Colorizr, * as C from \"colorizr\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\nimport { calculateHueDistance, wrapScalarHue } from \"./utility.js\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { parseCssRgbFunction, to8bit as rgbTo8bit } from \"./srgb.js\";\n\nexport const OKLCH_CHROMA_MAX = 0.4;\n\nexport const guard = (lch: OkLch) => {\n  const { l, c, h, opacity, space, unit } = lch;\n  if (space !== `oklch`) throw new Error(`Space is expected to be 'oklch'. Got: ${ space }`);\n\n  if (unit === `absolute`) {\n    resultThrow(\n      percentTest(l, `l`),\n      () => {\n        if (typeof c === `number`) {\n          return numberInclusiveRangeTest(c, 0, OKLCH_CHROMA_MAX, `c`);\n        }\n      },\n      () => {\n        if (typeof h === `number`) {\n          return numberInclusiveRangeTest(c, 0, 360, `h`);\n        }\n      },\n      percentTest((opacity ?? 1), `opacity`)\n    );\n  } else if (unit === `scalar`) {\n    // Percentage values for L,C,H\n    resultThrow(\n      percentTest(l, `l`),\n      percentTest(c, `c`),\n      percentTest(h, `h`),\n      percentTest((lch.opacity ?? 1), `opacity`)\n    );\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport function fromLibrary<T extends ParsingOptions<OkLch>>(lch: C.LCH, options: T): T extends { scalar: true } ? OkLchScalar : OkLchAbsolute;\n\n/**\n * Coverts from the Colorizr library\n * Tests ranges:\n * * l: 0..1\n * * c: 0..1\n * * h: 0..360\n * * alpha: 0..1\n * \n * Default option: { scalar: true }\n * @param lch LCH value\n * @param parsingOptions Options for parsing \n * @returns \n */\nexport function fromLibrary(lch: C.LCH, parsingOptions: ParsingOptions<OkLch> = {}): OkLch {\n  if (typeof lch === `undefined` || lch === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n\n  const scalarReturn = parsingOptions.scalar ?? true;\n\n  // Validate\n  resultThrow(\n    percentTest(lch.l, `l`),\n    percentTest(lch.c, `c`),\n    numberInclusiveRangeTest(lch.h, 0, 360, `h`),\n    percentTest((lch.alpha ?? 1), `alpha`)\n  );\n\n  if (scalarReturn) {\n    return scalar(lch.l, lch.c / OKLCH_CHROMA_MAX, lch.h / 360, (lch.alpha ?? 1));\n  } else {\n    return absolute(lch.l, lch.c, lch.h, (lch.alpha ?? 1));\n  }\n\n}\n\nexport const fromHexString = (hexString: string, options: ParsingOptions<OkLch> = {}): OkLch => {\n  return fromLibrary(C.hex2oklch(hexString), options);\n}\n\nconst oklchTransparent: OkLchAbsolute = Object.freeze({\n  l: 0, c: 0, h: 0, opacity: 0, unit: `absolute`, space: `oklch`\n});\n\nexport function fromCss<T extends ParsingOptions<OkLch>>(value: string, options: T): T extends { scalar: true } ? OkLchScalar : OkLchAbsolute;\nexport function fromCss(value: string, options: ParsingOptions<OkLch> = {}): OkLch {\n  value = value.toLowerCase();\n  if (value.startsWith(`#`)) {\n    return fromHexString(value, options);\n  }\n  if (value === `transparent`) return oklchTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string, options);\n  }\n\n  if (value.startsWith(`rgb(`)) {\n    const rgb = rgbTo8bit(parseCssRgbFunction(value));\n    const lch = C.rgb2oklch({ r: rgb.r, g: rgb.g, b: rgb.b });\n    return fromLibrary(lch, options);\n  }\n\n  if (!value.startsWith(`hsl(`) && !value.startsWith(`oklch(`)) {\n    try {\n      const converted = C.convert(value, `oklch`);\n      value = converted;\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n  const cc = new Colorizr(value);\n  const lch = cc.oklch;\n  return fromLibrary(lch, options);\n  // const c = C.extractColorParts(value);\n  // if (c.model !== `oklch`) {\n  //   if (options.fallbackColour) return options.fallbackColour;\n  //   throw new Error(`Expecting OKLCH colour space. Got: ${ c.model }`);\n  // }\n  // return fromLibrary(c as any as C.LCH, options);\n}\n\n//export const fromCssScalar = (value: string, options: ParsingOptions<OkLchAbsolute> = {}): OkLchScalar => toScalar(fromCssAbsolute(value, options));\n\n/**\n * Returns a string or {@link OkLch} value to absolute form.\n * \n * This means ranges are:\n * * lightness: 0..1\n * * chroma: 0...CHROMA_MAX (0.4)\n * * hue: 0..360\n * @param lchOrString \n * @returns \n */\nexport const toAbsolute = (lchOrString: OkLch | string): OkLchAbsolute => {\n  if (typeof lchOrString === `string`) {\n    return toAbsolute(fromCss(lchOrString, { scalar: true }));\n  }\n  guard(lchOrString);\n  if (lchOrString.unit === `absolute`) return lchOrString;\n  return {\n    space: `oklch`,\n    unit: `absolute`,\n    l: lchOrString.l,\n    c: lchOrString.c * OKLCH_CHROMA_MAX,\n    h: lchOrString.h * 360,\n    opacity: lchOrString.opacity\n  }\n}\n\n\nexport const toScalar = (lchOrString: OkLch | string): OkLchScalar => {\n  if (typeof lchOrString === `string`) {\n    return toScalar(fromCss(lchOrString, { scalar: true }));\n  }\n  const lch = lchOrString;\n  guard(lch);\n\n  //console.log(`toScalar input: ${ JSON.stringify(lchOrString) } lch: `, lch);\n  // Already relative\n  if (lch.unit === `scalar`) return lch;\n\n  // Absolute values\n  return {\n    l: lch.l, // unchanged\n    c: lch.c / OKLCH_CHROMA_MAX,\n    h: lch.h / 360,\n    opacity: (lch.opacity ?? 1),\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\nconst toLibrary = (lch: OkLch): C.LCH => {\n  const abs = toAbsolute(lch);\n  return {\n    l: abs.l,\n    c: abs.c,\n    h: abs.h,\n    alpha: abs.opacity,\n  }\n}\n// const libraryLchToScalar = (c: C.LCH): OkLchScalar => {\n//   return {\n//     l: c.h,\n//     c: c.c,\n//     h: c.h / 360,\n//     opacity: c.alpha ?? 1,\n//     unit: `scalar`,\n//     space: `oklch`\n//   }\n// }\n\n\n/**\n * Returns the colour as a CSS colour string: `oklch(l c h / opacity)`.\n *\n * @param lch Colour\n * @param precision Set precision of numbers, defaults to 3 \n * @returns CSS colour string\n */\nexport const toCssString = (lch: OkLch, precision = 3): string => {\n  guard(lch);\n  const { l, c, h, opacity } = lch;\n  let css = ``;\n  switch (lch.unit) {\n    case `absolute`:\n      css = `oklch(${ (l * 100).toFixed(precision) }% ${ c.toFixed(precision) } ${ h.toFixed(precision) }`\n      break;\n    case `scalar`:\n      css = `oklch(${ l.toFixed(precision) } ${ (c * OKLCH_CHROMA_MAX).toFixed(precision) } ${ (h * 360).toFixed(precision) }`\n      break;\n  }\n  if (typeof opacity !== `undefined` && opacity !== 1) {\n    css += ` / ${ opacity.toFixed(precision) }`;\n  }\n  css += `)`;\n  return css;\n}\n\n// export const oklchFromCss = (css: string): OkLchScalar => {\n//   if (css.startsWith(`#`)) {\n//     libraryLchToScalar(C.hex2oklch(css));\n//   }\n//   const p = C.extractColorParts(css);\n//   return libraryToScalar(p);\n// }\n\n// const libraryToScalar = (colour: unknown): OkLchScalar => {\n//   if (C.isLCH(colour)) {\n//     return libraryLchToScalar(colour);\n//   }\n//   if (C.isRGB(colour)) {\n//     return libraryToScalar(C.rgb2oklch(colour));\n//   }\n//   if (C.isLAB(colour)) {\n//     return libraryToScalar(C.oklab2oklch(colour));\n//   }\n//   if (C.isHSL(colour)) {\n//     return libraryToScalar(C.hsl2oklch(colour));\n//   }\n//   if (C.isHex(colour)) {\n//     return libraryLchToScalar(C.hex2oklch(colour));\n//   }\n//   throw new Error(`Unexpected colour format`);\n// }\n\n// export const oklchToColorJs = (lch: OkLch): ColorConstructor => {\n//   throwNumberTest(lch.l, `percentage`, `lch.l`);\n//   throwNumberTest(lch.c, `percentage`, `lch.c`);\n//   throwNumberTest(lch.h, `percentage`, `lch.h`);\n//   throwNumberTest(lch.opacity, `percentage`, `lch.opacity`);\n//   return {\n//     alpha: lch.opacity,\n//     coords: [ lch.l, lch.c * 0.4, lch.h * 360 ],\n//     spaceId: `oklch`\n//   }\n// }\n\n// const oklchToColorJs = (oklch: OkLch) => {\n//   throwNumberTest(oklch.l, `percentage`, `oklch.l`);\n//   throwNumberTest(oklch.c, `percentage`, `oklch.c`);\n//   throwNumberTest(oklch.h, `percentage`, `oklch.h`);\n//   throwNumberTest(oklch.opacity, `percentage`, `oklch.opacity`);\n//   const coords: [ number, number, number ] = [\n//     oklch.l,\n//     oklch.c * 0.4,\n//     oklch.h * 360\n//   ]\n//   return new ColorJs.default(`oklch`, coords, oklch.opacity);\n// }\n\n// export const isOklch = (p: Colourish | undefined | null): p is OkLch => {\n//   if (typeof p === `undefined` || p === null) return false;\n//   if (typeof p !== `object`) return false;\n\n//   // Check if Colourjs\n//   //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n//   //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n//   if (p.space !== `oklch`) return false;\n//   if (typeof p.l === `undefined`) return false;\n//   if (typeof p.c === `undefined`) return false;\n//   if (typeof p.h === `undefined`) return false;\n//   return true;\n// }\n\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, chroma = 1, lightness = 0.5, opacity = 1): OkLchScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (chroma > 1) throw new TypeError(`Param 'chroma' must be between 0..1`);\n  const hue = angleParse(absoluteHslOrVariable);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n\n  return {\n    l: lightness,\n    c: chroma,\n    h: hueDeg,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\n/**\n * Scales the opacity value of an input Oklch value\n * ```js\n * withOpacity()\n * ```\n * @param value \n * @param fn \n * @returns \n */\nexport const withOpacity = <T extends OkLch>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport const interpolator = (a: OkLch | string, b: OkLch | string, direction: `longer` | `shorter` = `shorter`) => {\n  a = toScalar(a);\n  b = toScalar(b);\n  //console.log(`a`, a);\n  //console.log(`b`, b);\n\n  const aOpacity = a.opacity ?? 1;\n  const distanceCalc = calculateHueDistance(a.h, b.h, 1);\n  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;\n  const chromaDistance = b.c - a.c;\n  const lightDistance = b.l - a.l;\n  const opacityDistance = (b.opacity ?? 1) - aOpacity;\n  //console.log(`distanceCalc`, distanceCalc);\n  //console.log(`interpolator distances: hue: ${ hueDistance } c: ${ chromaDistance } light: ${ lightDistance } opacity: ${ opacityDistance }`);\n\n  return (amount: number): OkLchScalar => {\n    amount = clamp(amount);\n    let h = interpolate(amount, 0, Math.abs(hueDistance));\n    if (hueDistance < 0) h = a.h - h;\n    else h = a.h + h;\n\n    const c = interpolate(amount, 0, chromaDistance);\n    const l = interpolate(amount, 0, lightDistance);\n    const o = interpolate(amount, 0, opacityDistance);\n    //console.log(`amount: ${ amount } h: ${ h } s: ${ s } l: ${ l } o: ${ o }`);\n    return scalar(l + a.l, c + a.c, wrapScalarHue(h), o + aOpacity);\n  }\n}\n\nexport function scalar(lightness = 0.7, chroma = 0.1, hue = 0.5, opacity = 1): OkLchScalar {\n  const lch: OkLchScalar = {\n    unit: `scalar`,\n    space: `oklch`,\n    l: lightness,\n    c: chroma,\n    h: hue,\n    opacity: opacity\n  }\n  guard(lch);\n  return lch;\n}\n\n/**\n * Create an LCH colour using absolute hue\n * @param l Lightness 0..1\n * @param c Chroma 0..4\n * @param h Hue 0..360\n * @param opacity \n * @returns \n */\nexport const absolute = (l: number, c: number, h: number, opacity = 1): OkLchAbsolute => {\n  const lch: OkLchAbsolute = {\n    space: `oklch`,\n    unit: `absolute`,\n    opacity,\n    l, c, h\n  };\n  guard(lch);\n  return lch;\n}\n","import * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport * as OklchSpace from './oklch.js';\nimport type { Colour } from \"./types.js\";\n\n/**\n * Converts from some kind of colour that is legal in CSS\n * into a structured Colour type.\n * \n * Handles: hex format, CSS variables, colour names\n * ```js\n * fromCssColour(`#ffffff`);\n * fromCssColour(`blue`);\n * fromCssColour(`--some-variable`);\n * fromCssColour(`hsl(50, 50%, 50%)`);\n * fromCssColour(`rgb(50, 100, 100)`);\n * ```\n * @param colour \n * @returns \n */\nexport const fromCssColour = (colour: string): Colour => {\n  if (colour.startsWith(`#`)) {\n    return SrgbSpace.fromHexString(colour, true);\n  }\n\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return SrgbSpace.fromHexString(cssDefinedHexColours[ colour ] as string, true);\n  }\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0 || fromCss === null) throw new Error(`Variable missing: ${ colour }`);\n    return fromCssColour(fromCss);\n  }\n  colour = colour.toLowerCase();\n  if (colour.startsWith(`hsl(`)) {\n    return HslSpace.fromCss(colour, { scalar: true });\n  }\n  if (colour.startsWith(`rgb(`)) {\n    return SrgbSpace.fromCss(colour, { scalar: true });\n  }\n  if (colour.startsWith(`oklch(`)) {\n    return OklchSpace.fromCss(colour, { scalar: true });\n  }\n\n  throw new Error(`String colour is not a hex colour, CSS variable nor well-defined colour. Input: '${ colour }'`);\n}\n\n/**\n * Resolves a named colour or CSS variable to a colour string.\n * Doesn't do conversion or parsing.\n * \n * ```js\n * resolveCss(`red`);\n * resolveCss(`my-var`);\n * ```\n * @param colour Colour\n * @param fallback Fallback if CSS variable is missing\n * @returns \n */\nexport const resolveCss = (colour: string, fallback?: string): string => {\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0 || fromCss === null) {\n      if (typeof fallback !== `undefined`) return fallback;\n      throw new Error(`CSS variable missing: '${ colour }'`);\n    }\n    return resolveCss(fromCss); // Recurse, because value might be a named colour\n  }\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return cssDefinedHexColours[ colour ] as string;\n  }\n  return colour; // assume legit\n}\n\nexport const cssDefinedHexColours = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",\n  \"blue\": \"#0000ff\",\n  \"blueviolet\": \"#8a2be2\",\n  \"brown\": \"#a52a2a\",\n  \"burlywood\": \"#deb887\",\n  \"cadetblue\": \"#5f9ea0\",\n  \"chartreuse\": \"#7fff00\",\n  \"chocolate\": \"#d2691e\",\n  \"coral\": \"#ff7f50\",\n  \"cornflowerblue\": \"#6495ed\",\n  \"cornsilk\": \"#fff8dc\",\n  \"crimson\": \"#dc143c\",\n  \"cyan\": \"#00ffff\",\n  \"darkblue\": \"#00008b\",\n  \"darkcyan\": \"#008b8b\",\n  \"darkgoldenrod\": \"#b8860b\",\n  \"darkgray\": \"#a9a9a9\",\n  \"darkgreen\": \"#006400\",\n  \"darkkhaki\": \"#bdb76b\",\n  \"darkmagenta\": \"#8b008b\",\n  \"darkolivegreen\": \"#556b2f\",\n  \"darkorange\": \"#ff8c00\",\n  \"darkorchid\": \"#9932cc\",\n  \"darkred\": \"#8b0000\",\n  \"darksalmon\": \"#e9967a\",\n  \"darkseagreen\": \"#8fbc8f\",\n  \"darkslateblue\": \"#483d8b\",\n  \"darkslategray\": \"#2f4f4f\",\n  \"darkturquoise\": \"#00ced1\",\n  \"darkviolet\": \"#9400d3\",\n  \"deeppink\": \"#ff1493\",\n  \"deepskyblue\": \"#00bfff\",\n  \"dimgray\": \"#696969\",\n  \"dodgerblue\": \"#1e90ff\",\n  \"firebrick\": \"#b22222\",\n  \"floralwhite\": \"#fffaf0\",\n  \"forestgreen\": \"#228b22\",\n  \"fuchsia\": \"#ff00ff\",\n  \"gainsboro\": \"#dcdcdc\",\n  \"ghostwhite\": \"#f8f8ff\",\n  \"gold\": \"#ffd700\",\n  \"goldenrod\": \"#daa520\",\n  \"gray\": \"#808080\",\n  \"green\": \"#008000\",\n  \"greenyellow\": \"#adff2f\",\n  \"honeydew\": \"#f0fff0\",\n  \"hotpink\": \"#ff69b4\",\n  \"indianred\": \"#cd5c5c\",\n  \"indigo\": \"#4b0082\",\n  \"ivory\": \"#fffff0\",\n  \"khaki\": \"#f0e68c\",\n  \"lavender\": \"#e6e6fa\",\n  \"lavenderblush\": \"#fff0f5\",\n  \"lawngreen\": \"#7cfc00\",\n  \"lemonchiffon\": \"#fffacd\",\n  \"lightblue\": \"#add8e6\",\n  \"lightcoral\": \"#f08080\",\n  \"lightcyan\": \"#e0ffff\",\n  \"lightgoldenrodyellow\": \"#fafad2\",\n  \"lightgray\": \"#d3d3d3\",\n  \"lightgreen\": \"#90ee90\",\n  \"lightpink\": \"#ffb6c1\",\n  \"lightsalmon\": \"#ffa07a\",\n  \"lightseagreen\": \"#20b2aa\",\n  \"lightskyblue\": \"#87cefa\",\n  \"lightslategray\": \"#778899\",\n  \"lightsteelblue\": \"#b0c4de\",\n  \"lightyellow\": \"#ffffe0\",\n  \"lime\": \"#00ff00\",\n  \"limegreen\": \"#32cd32\",\n  \"linen\": \"#faf0e6\",\n  \"magenta\": \"#ff00ff\",\n  \"maroon\": \"#800000\",\n  \"mediumaquamarine\": \"#66cdaa\",\n  \"mediumblue\": \"#0000cd\",\n  \"mediumorchid\": \"#ba55d3\",\n  \"mediumpurple\": \"#9370db\",\n  \"mediumseagreen\": \"#3cb371\",\n  \"mediumslateblue\": \"#7b68ee\",\n  \"mediumspringgreen\": \"#00fa9a\",\n  \"mediumturquoise\": \"#48d1cc\",\n  \"mediumvioletred\": \"#c71585\",\n  \"midnightblue\": \"#191970\",\n  \"mintcream\": \"#f5fffa\",\n  \"mistyrose\": \"#ffe4e1\",\n  \"moccasin\": \"#ffe4b5\",\n  \"navajowhite\": \"#ffdead\",\n  \"navy\": \"#000080\",\n  \"oldlace\": \"#fdf5e6\",\n  \"olive\": \"#808000\",\n  \"olivedrab\": \"#6b8e23\",\n  \"orange\": \"#ffa500\",\n  \"orangered\": \"#ff4500\",\n  \"orchid\": \"#da70d6\",\n  \"palegoldenrod\": \"#eee8aa\",\n  \"palegreen\": \"#98fb98\",\n  \"paleturquoise\": \"#afeeee\",\n  \"palevioletred\": \"#db7093\",\n  \"papayawhip\": \"#ffefd5\",\n  \"peachpuff\": \"#ffdab9\",\n  \"peru\": \"#cd853f\",\n  \"pink\": \"#ffc0cb\",\n  \"plum\": \"#dda0dd\",\n  \"powderblue\": \"#b0e0e6\",\n  \"purple\": \"#800080\",\n  \"rebeccapurple\": \"#663399\",\n  \"red\": \"#ff0000\",\n  \"rosybrown\": \"#bc8f8f\",\n  \"royalblue\": \"#4169e1\",\n  \"saddlebrown\": \"#8b4513\",\n  \"salmon\": \"#fa8072\",\n  \"sandybrown\": \"#f4a460\",\n  \"seagreen\": \"#2e8b57\",\n  \"seashell\": \"#fff5ee\",\n  \"sienna\": \"#a0522d\",\n  \"silver\": \"#c0c0c0\",\n  \"skyblue\": \"#87ceeb\",\n  \"slateblue\": \"#6a5acd\",\n  \"slategray\": \"#708090\",\n  \"snow\": \"#fffafa\",\n  \"springgreen\": \"#00ff7f\",\n  \"steelblue\": \"#4682b4\",\n  \"tan\": \"#d2b48c\",\n  \"teal\": \"#008080\",\n  \"thistle\": \"#d8bfd8\",\n  \"tomato\": \"#ff6347\",\n  \"turquoise\": \"#40e0d0\",\n  \"violet\": \"#ee82ee\",\n  \"wheat\": \"#f5deb3\",\n  \"white\": \"#ffffff\",\n  \"whitesmoke\": \"#f5f5f5\",\n  \"yellow\": \"#ffff00\",\n  \"yellowgreen\": \"#9acd32\",\n  \"transparent\": \"#00000000\"\n}\n","import Colorizr, * as C from \"colorizr\";\n\nimport type { Hsl, ParsingOptions, Rgb, Rgb8Bit, RgbScalar } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { toLibraryRgb as hslToLibraryRgb } from \"./hsl.js\";\nimport { isHsl } from \"./guards.js\";\n\nexport const withOpacity = <T extends Rgb>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `8bit`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 255) / 255, value) * 255\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport function fromHexString<T extends boolean>(hexString: string, scalar: T): T extends true ? RgbScalar : Rgb8Bit;\nexport function fromHexString(hexString: string, scalar = true): RgbScalar | Rgb8Bit {\n  return fromLibrary(C.hex2rgb(hexString), { scalar });\n};\n\nconst srgbTansparent: Rgb8Bit = Object.freeze({\n  r: 0, g: 0, b: 0, opacity: 0, unit: `8bit`, space: `srgb`\n})\n\nexport function fromCss<T extends ParsingOptions<Rgb>>(value: string, options: T): T extends { scalar: true } ? RgbScalar : Rgb8Bit;\n\n/**\n * Converts a colour in a legal CSS form into Rgb value, by default RgbScalar (0..1) scale.\n * ```js\n * fromCss(`rebeccapurple`);\n * fromCss(`rgb(40% 20% 60%)`);\n * \n * // Get 8bit version on 0..255 scale\n * fromCss(`blue`, { scalar: false });\n * ```\n * \n * @param value \n * @param options \n * @returns \n */\nexport function fromCss(value: string, options: ParsingOptions<Rgb> = {}): Rgb {\n  value = value.toLowerCase();\n  if (value.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);\n  if (value.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);\n\n\n  const scalar = options.scalar ?? true;\n\n  // Convert from hex\n  if (value.startsWith(`#`)) return fromHexString(value, scalar);\n  // Special-case transparent\n  if (value === `transparent`) return srgbTansparent;\n  // Convert from named colour\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) fromHexString(cssDefinedHexColours[ value ] as string, scalar);\n\n  if (value.startsWith(`hsl(`)) {\n    const rgb = hslToLibraryRgb(value);\n    return fromLibrary(rgb, options);\n  }\n\n  // if (value.startsWith(`hsl(`)) {\n\n  //   const hslRel = hslToScalar(parseCssHslFunction(value));\n  //   const rgb = C.hsl2rgb({ h: hslRel.h, s: hslRel.s, l: hslRel.l, alpha: hslRel.opacity ?? 1 });\n  //   return fromLibrary(rgb, options);\n\n  // }\n\n  // Convert to rgb() colour function\n  if (!value.startsWith(`rgb(`)) {\n    try {\n      value = C.convert(value, `rgb`);\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  try {\n    // Hand-rolled rgb() parse because the package is broken\n    const rgb = parseCssRgbFunction(value);\n    if (scalar) return toScalar(rgb);\n    return to8bit(rgb);\n  } catch (error) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw error;\n  }\n}\n\nexport const toCssString = (rgb: Rgb): string => {\n  guard(rgb);\n  switch (rgb.unit) {\n    case `8bit`:\n      if (rgb.opacity === undefined || rgb.opacity === 255) {\n        return `rgb(${ rgb.r } ${ rgb.g } ${ rgb.b })`;\n      }\n      return `rgb(${ rgb.r } ${ rgb.g } ${ rgb.b } / ${ (rgb.opacity ?? 255) / 255 })`;\n    case `scalar`:\n      if (rgb.opacity === undefined || rgb.opacity === 1) {\n        return `rgb(${ rgb.r * 100 }% ${ rgb.g * 100 }% ${ rgb.b * 100 }%)`;\n      }\n      return `rgb(${ rgb.r * 100 }% ${ rgb.g * 100 }% ${ rgb.b * 100 }% / ${ (rgb.opacity ?? 1) * 100 }%)`;\n    default:\n\n      throw new Error(`Unknown unit: ${ (rgb as any).unit }`);\n  }\n}\n\nconst toLibrary = (rgb: Rgb): C.RGB => {\n  const abs = to8bit(rgb);\n  return {\n    r: abs.r,\n    g: abs.g,\n    b: abs.b,\n    alpha: abs.opacity,\n  }\n}\n\nfunction fromLibrary<T extends ParsingOptions<Rgb>>(rgb: C.RGB, parsingOptions: T):\n  T extends { scalar: true } ? RgbScalar : Rgb8Bit\n\nfunction fromLibrary(rgb: C.RGB, parsingOptions: ParsingOptions<Rgb> = {}): Rgb8Bit | RgbScalar {\n  if (parsingOptions.scalar) {\n    return {\n      r: rgb.r / 255,\n      g: rgb.g / 255,\n      b: rgb.b / 255,\n      opacity: rgb.alpha ?? 1,\n      unit: `scalar`,\n      space: `srgb`\n    }\n  } else {\n    return {\n      r: rgb.r,\n      g: rgb.g,\n      b: rgb.b,\n      opacity: rgb.alpha ?? 255,\n      unit: `8bit`,\n      space: `srgb`\n    }\n  }\n}\n\n\nexport const to8bit = (rgbOrString: Rgb | string): Rgb8Bit => {\n  if (typeof rgbOrString === `string`) {\n    return fromCss(rgbOrString, { scalar: false });\n  }\n  if (isHsl(rgbOrString)) {\n    return to8bit(fromLibrary(hslToLibraryRgb(rgbOrString), { scalar: false }));\n  }\n  guard(rgbOrString);\n  if (rgbOrString.unit === `8bit`) return rgbOrString;\n  return {\n    r: rgbOrString.r * 255,\n    g: rgbOrString.g * 255,\n    b: rgbOrString.b * 255,\n    opacity: (rgbOrString.opacity ?? 1) * 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nexport const toScalar = (rgbOrString: Rgb | Hsl | string): RgbScalar => {\n  if (typeof rgbOrString === `string`) {\n    return fromCss(rgbOrString, { scalar: true });\n  }\n  if (isHsl(rgbOrString)) {\n    return toScalar(fromLibrary(hslToLibraryRgb(rgbOrString), { scalar: true }));\n  }\n  guard(rgbOrString);\n  if (rgbOrString.unit === `scalar`) return rgbOrString;\n  return {\n    r: rgbOrString.r / 255,\n    g: rgbOrString.g / 255,\n    b: rgbOrString.b / 255,\n    opacity: (rgbOrString.opacity ?? 1) / 255,\n    unit: `scalar`,\n    space: `srgb`\n  }\n}\n\nexport const guard = (rgb: Rgb) => {\n  const { r, g, b, opacity, space, unit } = rgb;\n  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${ space }`);\n  if (unit === `8bit`) {\n    resultThrow(\n      numberInclusiveRangeTest(r, 0, 255, `r`),\n      numberInclusiveRangeTest(g, 0, 255, `g`),\n      numberInclusiveRangeTest(b, 0, 255, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 255, `opacity`);\n        }\n      }\n    );\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(r, `percentage`, `r`),\n      numberTest(g, `percentage`, `g`),\n      numberTest(b, `percentage`, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\n/**\n * Sets the lightness value.\n * \n * Amount to change:\n * * 'fixed': a fixed amount\n * * 'delta': increase/decrease by this amount\n * * 'pdelta': proportion of current value to change by ('percentage delta')\n * \n * Use negative values to decrease\n * @param value \n * @param amount \n */\nexport const changeLightness = (rgb: Rgb, amount: Partial<{ pdelta: number, delta: number, fixed: number }>): Rgb => {\n  let newL = 0;\n  const co = new Colorizr(toCssString(rgb));\n  const scalarUnit = rgb.unit === `scalar`;\n  if (typeof amount.pdelta !== `undefined`) {\n    newL = co.oklab.l + (co.oklab.l * amount.pdelta);\n  } else if (typeof amount.delta !== `undefined`) {\n    newL = co.oklab.l + amount.delta;\n  } else if (typeof amount.fixed !== `undefined`) {\n    if (amount.fixed < 0) throw new TypeError(`Amount cannot be negative when using 'fixed'`);\n    newL = amount.fixed;\n  } else {\n    throw new TypeError(`Parameter 'amount' is missing 'pdelta/delta/fixed' properties`);\n  }\n  if (newL < 0) newL = 0;\n  else if (newL > 1) newL = 1;\n\n  const rgbResult = C.oklab2rgb({ a: co.oklab.a, b: co.oklab.b, l: newL, alpha: co.oklab.alpha });\n  return fromLibrary(rgbResult, { scalar: scalarUnit });\n  //return eightBit ? fromLibrary8bit(rgbResult) : fromLibraryScalar(rgbResult);\n}\n\n/**\n * Returns a lightness value (0..1) for an RGB input\n * \n * Calculates lightness by converting to Oklab and using the 'L' value\n * @param rgb \n * @returns \n */\nexport function lightness(rgb: Rgb) {\n  const co = new Colorizr(toCssString(rgb));\n  return co.oklab.l;\n}\n\nconst scaleProperty = (rgb: Rgb, value: number, property: `r` | `g` | `b` | `opacity`) => {\n  if (rgb.unit === `scalar`) {\n    // 0..1 scale\n    if (value > 1) value = 1;\n    else if (value < 0) value = 0;\n  } else {\n    // 0..255 scale\n    if (value > 255) value = 255;\n    else if (value < 0) value = 0;\n  }\n  return value;\n}\n\n/**\n * Creates a Rgb8Bit value from 8bit (0..255) values\n * @param red \n * @param green \n * @param blue \n * @param opacity \n * @returns \n */\nexport function eightBit(red = 100, green = 100, blue = 100, opacity = 255): Rgb8Bit {\n  const rgb: Rgb8Bit = {\n    unit: `8bit`,\n    space: `srgb`,\n    r: red,\n    g: green,\n    b: blue,\n    opacity: opacity\n  }\n  guard(rgb);\n  return rgb;\n}\n\n/**\n * Creates a RgbScalar value from scalar (0..1) values\n * @param red \n * @param green \n * @param blue \n * @param opacity \n * @returns \n */\nexport function scalar(red = 0.5, green = 0.5, blue = 0.5, opacity = 1): RgbScalar {\n  const rgb: RgbScalar = {\n    unit: `scalar`,\n    space: `srgb`,\n    r: red,\n    g: green,\n    b: blue,\n    opacity: opacity\n  }\n  guard(rgb);\n  return rgb;\n}\n\n\n/**\n * It seems Colorizr can't handle % values properly :'(\n * @param value \n */\nexport function parseCssRgbFunction(value: string): Rgb {\n  if (value.startsWith(`rgba`)) throw new Error(`RGBA is not supported`);\n  if (!value.startsWith(`rgb(`)) throw new Error(`Expected rgb(..) CSS colour`);\n\n  const start = value.indexOf('(');\n  const end = value.indexOf(')');\n  if (end < start) throw new Error(`Is rgb() not terminated? Missing ')'`);\n\n  const part = value.substring(start + 1, end);\n  let split = part.split(/[\\s,]+/);\n  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${ split.length } length`);\n\n  let relativeCount = 0;\n  for (const s of split) {\n    if (s.endsWith('%')) relativeCount++;\n  }\n\n  const valueAsScalar = (v: string, pos: number) => {\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100;\n    }\n    if (pos < 3) {\n      // r, g or b\n      return Number.parseFloat(v) / 255;\n    } else {\n      // opacity should already be in scalar value\n      return Number.parseFloat(v);\n    }\n  }\n\n  const valueAs8bit = (v: string, pos: number) => {\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100 * 255;\n    }\n    if (pos < 3) {\n      // r, g or b\n      return Number.parseFloat(v);\n    } else {\n      // opacity should already be in scalar value\n      return Number.parseFloat(v) * 255;\n    }\n  }\n\n  // Is there opacity?\n  if (split.length > 3) {\n    if (split[ 3 ] === '/') {\n      // Remove / part\n      split = [ split[ 0 ], split[ 1 ], split[ 2 ], split[ 4 ] ];\n    }\n  }\n  if (relativeCount > 1) {\n    // Return as scalar\n    return scalar(\n      valueAsScalar(split[ 0 ], 0),\n      valueAsScalar(split[ 1 ], 1),\n      valueAsScalar(split[ 2 ], 2),\n      valueAsScalar(split[ 3 ] ?? `1`, 3)\n    )\n  } else {\n    // Return as 8bit\n    return eightBit(\n      valueAs8bit(split[ 0 ], 0),\n      valueAs8bit(split[ 1 ], 1),\n      valueAs8bit(split[ 2 ], 2),\n      valueAs8bit(split[ 3 ] ?? `1`, 3)\n    )\n  }\n}\n\n/**\n * Interpolates colours in Srgb space. Probably\n * really ugly, use OkLch space isntead.\n * \n * ```js\n * const i = interpolator(`red`, `blue`);\n * i(0.5); // Get 50% between these colours\n * ```\n * @param colourA \n * @param colourB \n * @returns \n */\nexport const interpolator = (colourA: Rgb | string, colourB: Rgb | string) => {\n  const aa = toScalar(colourA);\n  const bb = toScalar(colourB);\n\n  const aOpacity = aa.opacity ?? 1;\n  const opacityDistance = (bb.opacity ?? 1) - aOpacity;\n\n  const r = bb.r - aa.r;\n  const g = bb.g - aa.g;\n  const b = bb.b - aa.b;\n\n  return (amount: number): RgbScalar => {\n    amount = clamp(amount);\n    return scalar(\n      aa.r + interpolate(amount, 0, r),\n      aa.g + interpolate(amount, 0, g),\n      aa.b + interpolate(amount, 0, b),\n      aOpacity + interpolate(amount, 0, opacityDistance));\n  }\n}\n\n/**\n * Converts a Rgb structure (or CSS string) to Colorizr's HSL format\n * @param rgb \n * @returns \n */\nexport function toLibraryHsl(rgb: Rgb | string): C.HSL {\n  if (typeof rgb === `string`) {\n    const parseResult = fromCss(rgb, { scalar: false });\n    return toLibraryHsl(parseResult);\n  }\n  rgb = to8bit(rgb);\n  const hsl = C.rgb2hsl({ r: rgb.r, g: rgb.g, b: rgb.b });\n  return { ...hsl, alpha: (rgb.opacity ?? 255) / 255 };\n}","import { Grids } from '@ixfx/geometry';\nimport * as SrgbSpace from './colour/srgb.js';\nimport type { Rgb, Rgb8Bit } from './colour/types.js';\n\n/**\n * Returns a {@link @ixfx/geometry/Grids.Grid} based on the provided `image`\n * @param image ImageData\n * @returns Grid\n */\nexport const grid = (image: ImageData): Grids.Grid => {\n  const g = { rows: image.width, cols: image.height };\n  return g;\n}\n\n/**\n * Returns an object that allows get/set grid semantics on the underlying `image` data.\n * Uses 8-bit sRGB values, meaning 0..255 range for red, green, blue & opacity.\n * \n * ```js\n * // Get CANVAS element, drawing context and then image data\n * const canvasEl = document.querySelector(`#my-canvas`);\n * const ctx = canvasEl.getContext(`2d`);\n * const imageData = ctx.getImageData();\n * \n * // Now that we have image data, we can wrap it:\n * const asGrid = ImageDataGrid.wrap(imageData);\n * asGrid.get({ x:10, y: 20 }); // Get pixel at 10,20\n * asGrid.set(colour, { x:10, y: 20 }); // Set pixel value\n * \n * // Display changes back on the canvas\n * ctx.putImageData(imageData, 0, 0)\n * ```\n * @param image \n * @returns \n */\nexport const wrap = (image: ImageData): Grids.GridWritable<Rgb8Bit> & Grids.GridReadable<Rgb8Bit> => {\n  return {\n    ...grid(image),\n    get: accessor(image),\n    set: setter(image)\n  }\n}\n\n/**\n * Returns a function to access pixel values by x,y\n * @param image \n * @returns \n */\nexport const accessor = (image: ImageData): Grids.GridCellAccessor<Rgb8Bit> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellAccessor<Rgb8Bit> = (cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) return;\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      unit: `8bit`,\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns a function that sets pixel values\n * @param image \n * @returns \n */\nexport const setter = (image: ImageData): Grids.GridCellSetter<Rgb> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellSetter<Rgb> = (value: Rgb, cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) throw new Error(`Cell out of range. ${ cell.x },${ cell.y }`);\n    const pixel = SrgbSpace.to8bit(value);\n    const pxIndex = index * 4;\n    data[ pxIndex ] = pixel.r;\n    data[ pxIndex + 1 ] = pixel.g;\n    data[ pxIndex + 2 ] = pixel.b;\n    data[ pxIndex + 3 ] = pixel.opacity ?? 255;\n  };\n  return fn;\n}\n\n// export function* visit(image: ImageData, visitor: Grids.VisitGenerator) {\n//   const a = accessor(image);\n\n//   for (const cell of visitor) {\n//     yield a(cell, `undefined`);\n//   }\n// }\n\n/**\n * Yields pixels of an image row by row\n * @param image \n */\nexport function* byRow(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  const v = Grids.As.rows(g, { x: 0, y: 0 });\n  for (const row of v) {\n    const pixels = row.map(p => a(p, `undefined`));\n    yield pixels\n  }\n}\n\n/**\n * Yields pixels of an image column by column\n * @param image \n */\nexport function* byColumn(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  for (let x = 0; x < g.cols; x++) {\n    const col: Rgb8Bit[] = [];\n    for (let y = 0; y < g.rows; y++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) col.push(p);\n    }\n    yield col;\n  }\n}","import { ElementSizer, resolveEl, type ElementResizeLogic, type ElementSizerOptions } from '@ixfx/dom';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport type { ScaleBy, ScalerCombined } from '@ixfx/geometry';\nimport type { Rect, RectPositioned } from '@ixfx/geometry/rect';\nimport { Rects, scaler } from '@ixfx/geometry';\nimport * as Drawing from './drawing.js';\nimport * as ImageDataGrid from './image-data-grid.js';\nimport { cloneFromFields } from '@ixfx/core/records';\nimport type { Grid } from '@ixfx/geometry/grid';\nimport type { DrawingHelper } from './types.js';\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n\n  resized: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n  /**\n   * Pointerdown. \n   * \n   * Adds logicalX/Y to get logical pixel coordinate\n   */\n  pointerdown: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointerup. \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointerup: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointermove \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointermove: PointerEvent & { physicalX: number, physicalY: number },\n}\n\n\n/**\n * CanvasHelper options\n */\nexport type CanvasHelperOptions = Readonly<{\n  /**\n   * Automatic canvas resizing logic.\n   */\n  resizeLogic?: ElementResizeLogic\n  /**\n   * By default, the helper emits pointer events from the canvas.\n   * Set this to _true_ to disable.\n   */\n  disablePointerEvents: boolean\n  /**\n   * By default the display DPI is used for scaling.\n   * If this is set, this will override.\n   */\n  pixelZoom: number\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  skipCss: boolean;\n  coordinateScale: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  onResizing?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  onResized?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Logical width of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  width: number\n  /**\n   * Logical height of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  zIndex: number\n  /**\n   * Colour space to use. Defaults to sRGB.\n   */\n  colourSpace: PredefinedColorSpace;\n\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx Drawing context\n   * @param size Viewport size\n   * @param helper CanvasHelper instance\n   * @returns \n   */\n  draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n}>;\n\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, draw });\n * ```\n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasHelperOptions\n\n  #scaler: ScalerCombined;\n  #scalerSize: ScalerCombined;\n  #viewport: RectPositioned = Rects.EmptyPositioned;\n  #logicalSize: Rect = Rects.Empty;\n  #ctx: CanvasRenderingContext2D | undefined;\n  #drawHelper: DrawingHelper | undefined;\n  #resizer: ElementSizer<HTMLCanvasElement> | undefined;\n  #disposed = false;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasHelperOptions> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n\n    const size = this.el.getBoundingClientRect();\n    this.opts = {\n      resizeLogic: opts.resizeLogic ?? `none`,\n      disablePointerEvents: opts.disablePointerEvents ?? false,\n      pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),\n      height: opts.height ?? size.height,\n      width: opts.width ?? size.width,\n      zIndex: opts.zIndex ?? -1,\n      coordinateScale: opts.coordinateScale ?? `both`,\n      onResizing: opts.onResizing,\n      onResized: opts.onResized,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false,\n      colourSpace: `srgb`\n    }\n\n    this.#scaler = scaler(`both`);\n    this.#scalerSize = scaler(`both`, size);\n    this.#init();\n  }\n\n  getRectangle(): RectPositioned {\n    return {\n      x: 0, y: 0,\n      ...this.#logicalSize\n    }\n  }\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizer) {\n      this.#resizer.dispose(`CanvasHelper disposing ${ reason }`.trim());\n      this.#resizer = undefined;\n    }\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  /**\n   * Gets the drawable area of the canvas.\n   * This accounts for scaling due to high-DPI displays etc.\n   * @returns \n   */\n  getPhysicalSize() {\n    return {\n      width: this.width * this.ratio,\n      height: this.height * this.ratio\n    }\n  }\n\n  /**\n   * Creates a drawing helper for the canvas.\n   * If one is already created it is reused.\n   */\n  getDrawHelper() {\n    if (!this.#drawHelper) {\n      this.#drawHelper = Drawing.makeHelper(this.#getContext(), {\n        width: this.width, height: this.height\n      });\n    }\n  }\n\n  setLogicalSize(logicalSize: Rect) {\n    Rects.guard(logicalSize, `logicalSize`);\n    const logicalSizeInteger = Rects.applyFields(v => Math.floor(v), logicalSize);\n    const ratio = this.opts.pixelZoom;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = scaler(this.opts.coordinateScale, logicalSize);\n    this.#scalerSize = scaler(`both`, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = Rects.multiplyScalar(logicalSize, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSizeInteger.width.toString() + `px`;\n    this.el.style.height = logicalSizeInteger.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#logicalSize = logicalSizeInteger;\n\n    //console.log(`setting logical size to ${ this.#logicalSize.width }x${ this.#logicalSize.height }`);\n\n    // Notify listeners of resize\n    // const r = this.opts.onResizing;\n    // if (r) {\n    //   setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    // }\n    if (this.opts.onResizing) {\n      this.opts.onResizing(this.ctx, this.size, this);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n\n  #init() {\n    //console.log(`init`, this.opts);\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#logicalSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n\n    if (!this.opts.disablePointerEvents) {\n      this.#handleEvents();\n    }\n\n    const resizeLogic = this.opts.resizeLogic ?? `none`;\n    if (resizeLogic === `none`) {\n      this.setLogicalSize({ width: this.opts.width, height: this.opts.height });\n    } else {\n      const resizerOptions: ElementSizerOptions<HTMLCanvasElement> = {\n        onSizeChanging: (size) => {\n          if (Rects.isEqual(this.#logicalSize, size)) return;\n          this.setLogicalSize(size);\n        },\n        onSizeDone: (size, el) => {\n          this.#onResizeDone(size);\n        },\n        naturalSize: { width: this.opts.width, height: this.opts.height },\n        stretch: this.opts.resizeLogic ?? `none`\n      };\n      this.#resizer = new ElementSizer(this.el, resizerOptions);\n    }\n\n    this.#getContext();\n  }\n\n  #onResizeDone(size: Rect) {\n    if (this.opts.onResized) this.opts.onResized(this.ctx, this.size, this);\n    this.fireEvent(`resized`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n  #handleEvents() {\n    const handlePointerEvent = (event: PointerEvent) => {\n      const { offsetX, offsetY } = event;\n      const physicalX = offsetX * this.ratio;\n      const physicalY = offsetY * this.ratio;\n      event = cloneFromFields(event);\n      const eventData = {\n        physicalX, physicalY,\n        // eslint-disable-next-line @typescript-eslint/no-misused-spread\n        ...event\n      };\n\n      switch (event.type) {\n        case `pointerup`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n        case `pointermove`: {\n          {\n            this.fireEvent(`pointermove`, eventData);\n            break;\n          };\n        }\n        case `pointerdown`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n      };\n    }\n\n    this.el.addEventListener(`pointermove`, handlePointerEvent);\n    this.el.addEventListener(`pointerdown`, handlePointerEvent);\n    this.el.addEventListener(`pointerup`, handlePointerEvent);\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `ctx.clearRect(0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (!this.#ctx) return;\n    this.#ctx.clearRect(0, 0, this.width, this.height);\n\n  }\n\n  /**\n   * Fills the canvas with a given colour.\n   * \n   * Shortcut for:\n   * ```js\n      * ctx.fillStyle = ``;\n   * ctx.fillRect(0, 0, this.width, this.height);\n   * ```\n   * @param colour Colour\n   */\n  fill(colour?: string) {\n    if (!this.#ctx) return;\n    if (colour) this.#ctx.fillStyle = colour;\n    this.#ctx.fillRect(0, 0, this.width, this.height);\n\n  }\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#logicalSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#logicalSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n\n\n  drawBounds(strokeStyle = `green`) {\n    const ctx = this.#getContext();\n    Drawing.rect(ctx,\n      { x: 0, y: 0, width: this.width, height: this.height },\n      { crossed: true, strokeStyle, strokeWidth: 1 });\n\n    Drawing.rect(ctx, this.#viewport, { crossed: true, strokeStyle: `silver`, strokeWidth: 3 })\n  }\n\n  /**\n   * Returns a Scaler that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n      * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toAbsoluteFixed() {\n    return this.#scalerSize.abs\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toRelativeFixed() {\n    return this.#scalerSize.rel;\n  }\n\n  get logicalCenter() {\n    return {\n      x: this.#logicalSize.width / 2,\n      y: this.#logicalSize.height / 2\n    }\n  }\n\n  /**\n * Returns a Scaler that converts from relative to absolute\n * coordinates.\n * This is based on the canvas size.\n * \n * ```js\n * // Assuming a canvas of 800x600\n * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n * ```\n */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n\n  /**\n   * Gets the image data for the canvas.\n   * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be\n   * 536x536 with a high-DPI display.\n   * @returns \n   */\n  getImageData(): ImageData {\n    const size = this.getPhysicalSize();\n    const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });\n\n    if (data === null || data === undefined) throw new Error(`Could not get image data from context`);\n    return data;\n  }\n\n  /**\n   * Returns the canvas frame data as a writable grid.\n   * When editing, make as many edits as needed before calling\n   * `flip`, which writes buffer back to the canvas.\n   * ```js\n      * const g = helper.getWritableBuffer();\n   * // Get {r,g,b,opacity} of pixel 10,10\n   * const pixel = g.get({ x: 10, y: 10 });\n   * \n   * // Set a colour to pixel 10,10\n   * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });\n   * \n   * // Write buffer to canvas\n   * g.flip();\n   * ```\n   * \n   * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will\n   * mean a higher number of rows and columns compared to the logical size.\n   * @returns\n   */\n  getWritableBuffer() {\n    const ctx = this.ctx;\n    const data = this.getImageData();\n    const grid = ImageDataGrid.grid(data);\n    const get = ImageDataGrid.accessor(data);\n    const set = ImageDataGrid.setter(data);\n\n    const flip = () => {\n      ctx.putImageData(data, 0, 0);\n    }\n\n    return { grid, get, set, flip };\n  }\n}\n\n// export const imageDataAsGrid = (canvas: HTMLCanvasElement, colorSpace: PredefinedColorSpace = `srgb`) => {\n//   const ctx = canvas.getContext(`2d`);\n//   if (!ctx) throw new Error(`Could not create context`);\n\n//   const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace });\n//   if (!data) throw new Error(`Could not get image data from context`);\n\n//   const get = ImageDataGrid.accessor(data);\n//   const set = ImageDataGrid.setter(data);\n// }","import type { DrawingOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: fillStyle\n * @param elem Element\n * @param opts Drawing options\n */\nexport const applyOpts = (elem: SVGElement, opts: DrawingOpts) => {\n  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);\n  if (opts.opacity) {\n    elem.setAttributeNS(null, `opacity`, opts.opacity.toString());\n  }\n\n};","import { type Rect } from '@ixfx/geometry/rect';\n/**\n * Get the bounds of an SVG element (determined by its width/height attribs)\n * @param svg\n * @returns\n */\nexport const getBounds = (svg: SVGElement): Rect => {\n  const w = svg.getAttributeNS(null, `width`);\n  const width = w === null ? 0 : Number.parseFloat(w);\n  const h = svg.getAttributeNS(null, `height`);\n  const height = h === null ? 0 : Number.parseFloat(h);\n  return { width, height };\n};\n\n/**\n * Set the bounds of an element, using its width/height attribs.\n * @param svg\n * @param bounds\n */\nexport const setBounds = (svg: SVGElement, bounds: Rect): void => {\n  svg.setAttributeNS(null, `width`, bounds.width.toString());\n  svg.setAttributeNS(null, `height`, bounds.height.toString());\n};","/**\n * Creates an element of `type` and with `id` (if specified)\n * @param type Element type, eg `circle`\n * @param id Optional id to assign to element\n * @returns Element\n */\nexport const createEl = <V extends SVGElement>(\n  type: string,\n  id?: string\n): V => {\n  const m = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n  if (id) {\n    m.id = id;\n  }\n  return m;\n};\n\n\n/**\n * Creates and appends a SVG element.\n *\n * ```js\n * // Create a circle\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`);\n * ```\n *\n * If `queryOrExisting` is specified, it is used as a query to find an existing element. If\n * query starts with `#`, this will be set as the element id, if created.\n *\n * ```js\n * // Creates an element with id 'myCircle' if it doesn't exist\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`, `#myCircle`);\n * ```\n * @param parent Parent element\n * @param type Type of SVG element\n * @param queryOrExisting Query, eg `#id`\n * @returns\n */\nexport const createOrResolve = <V extends SVGElement>(\n  parent: SVGElement,\n  type: string,\n  queryOrExisting?: string | V,\n  suffix?: string\n): V => {\n  let existing:SVGElement|HTMLElement|null = null;\n  if (queryOrExisting !== undefined) {\n    existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;\n  }\n  if (existing === null) {\n    const p = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n    parent.append(p);\n    if (queryOrExisting && typeof queryOrExisting === `string` &&\n      queryOrExisting.startsWith(`#`)) {\n      p.id = suffix !== undefined && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);\n    }\n    return p;\n  }\n  return existing as V;\n};","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { type RandomSource } from '@ixfx/random';\nimport { scalar as hslScalar, toCssString } from './hsl.js';\n\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (\n  index: number,\n  saturation = 0.5,\n  lightness = 0.75,\n  alpha = 1\n) => {\n  resultThrow(\n    numberTest(index, `positive`, `index`),\n    numberTest(saturation, `percentage`, `saturation`),\n    numberTest(lightness, `percentage`, `lightness`),\n    numberTest(alpha, `percentage`, `alpha`)\n  );\n  // Via Stackoverflow\n  const hueDeg = index * 137.508; // use golden angle approximation\n  const hueRel = (hueDeg % 360) / 360\n  return toCssString(hslScalar(hueRel, saturation, lightness, alpha));\n  //return alpha === 1 ? `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%)` : `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%,${ alpha * 100 }%)`;\n};\n\n/**\n * Returns a random hue component (0..359)\n * \n * ```\n * // Generate hue\n * const h = randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand: RandomSource = Math.random): number => rand() * 360;\n","import type { Colour, Colourish, Hsl, OkLch, Rgb } from './types.js';\nimport { toColour, toCssColour } from './conversion.js';\nimport * as HslSpace from './hsl.js';\nimport * as SrgbSpace from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\nimport { OklchSpace } from './index.js';\nimport * as C from 'colorizr';\n\nexport function multiplyOpacity<T extends Colourish>(colourish: T, amount: number):\n  T extends string ? string :\n  T extends Hsl ? Hsl :\n  T extends OkLch ? OkLch :\n  T extends Rgb ? Rgb : never\n\n/**\n * Multiplies the opacity of a colour by `amount`, returning a computed CSS colour.\n * \n * ```js\n * multiplyOpacity(`red`, 0.5); // Returns a colour string\n * ```\n * \n * For example, to half the opacity, use `amount: 0.5`.\n * Clamps the result to ensure it's between 0..1\n * @param colourish Colour\n * @param amount Amount\n * @returns \n */\nexport function multiplyOpacity(colourish: Colourish, amount: number): Colourish {\n  return withOpacity(colourish, o => clamp(o * amount));\n}\n\n/**\n * Does a computation with the opacity of a colour, returning colour string\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n//export function withOpacity(colourish: string, fn: (scalarOpacity: number) => number): string;\n\n/**\n * Does a computation with the opacity of a colour in a HSL structure\n * @param hsl Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n//export function withOpacity(hsl: Hsl, fn: (scalarOpacity: number) => number): Hsl;\n\n/**\n * Does a computation with the opacity of a colour in a RGB structure\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n\n//export function withOpacity(rgb: Rgb, fn: (scalarOpacity: number) => number): Rgb;\nexport function withOpacity<T extends Colourish>(colourish: T, fn: (scalarOpacity: number) => number):\n  T extends string ? string :\n  T extends Hsl ? Hsl :\n  T extends OkLch ? OkLch :\n  T extends Rgb ? Rgb : never\n\n/**\n * Does a computation with the opacity of a colour, returning colour.\n * \n * Passes operation to `HslSpace` or `SrgbSpace` depending on space of `colourish`.\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\nexport function withOpacity(colourish: Colourish, fn: (scalarOpacity: number) => number): Colourish {\n  const colour = toColour(colourish);\n  let result: Colour | undefined;\n  switch (colour.space) {\n    case `hsl`:\n      result = HslSpace.withOpacity(colour, fn);\n      break;\n    case `srgb`:\n      result = SrgbSpace.withOpacity(colour, fn);\n      break;\n    case `oklch`:\n      result = OklchSpace.withOpacity(colour, fn);\n      break;\n    default:\n      throw new Error(`Unknown space: '${ colour.space }'. Expected hsl, srgb, oklch`)\n  }\n  if (!result) throw new Error(`Is colour in correct form?`);\n\n  // If input type was string, return result as string\n  if (typeof colourish === `string`) {\n    return toCssColour(result);\n  }\n  return result;\n};\n\nexport function setOpacity<T extends Colourish>(colourish: T, amount: number):\n  T extends string ? string :\n  T extends Hsl ? Hsl :\n  T extends OkLch ? OkLch :\n  T extends Rgb ? Rgb : never\n\nexport function setOpacity(colourish: Colourish, opacity: number): Colourish {\n  const colour = toColour(colourish);\n  colour.opacity = opacity;\n  if (typeof colourish === `string`) {\n    return toCssColour(colour);\n  }\n  return colour;\n}\n\n// export function lighten(colour: string, amount: number): string;\n// export function lighten(colour: Colour, amount: number): Colour;\n// export function lighten(colourish: Colourish, amount: number): Colourish {\n//   const asString = toCssColour(colourish);\n//   const result = C.lighten(asString, amount, ``)\n// }\n\n\n\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };","import type { Colour, ColourInterpolationOpts, ColourInterpolator, Colourish, ColourSpaces, ColourStepOpts, Hsl, HslScalar, OkLch, OkLchScalar, RgbScalar } from \"./types.js\";\nimport { pairwise } from '@ixfx/arrays';\nimport * as HslSpace from './hsl.js';\nimport { convert, toCssColour, type ConvertDestinations } from \"./conversion.js\";\nimport { convertScalar, OklchSpace, SrgbSpace } from \"./index.js\";\n\n/**\n * Returns a function to interpolate between colours\n * ```js\n * const i = interpolator([`orange`, `yellow`, `red`]);\n * \n * // Get a random colour on the above spectrum\n * i(Math.random());\n * ```\n * \n * Results will vary depending on the colour space used, play with the options.\n * When using a hue-based colour space, the `hue` option sets the logic for how hue values wrap.\n * \n * ```js\n * interpolator([`orange`, `yellow`, `red`], { space: `hsl`, hue: `longer })\n * ```\n * @param colours Colours to interpolate between\n * @param opts Options for interpolation\n * @returns \n */\n// export const interpolator = (colours: Colourish[], opts: Partial<ColourInterpolationOpts> = {}) => {\n//   const spaceDestination: ConvertDestinations = `oklch-scalar`;\n//   let ranges: Colour[] = [];\n//   const direction = opts.direction ?? `shorter`;\n\n//   switch (opts.space) {\n//     case `hsl`:\n//       ranges = interpolateInit(colours, `hsl-scalar`)\n//         .map(piece => HslSpace.interpolator(piece[ 0 ], piece[ 1 ], direction));\n//       break;\n//     default:\n//       ranges = interpolateInit(colours, `oklch-scalar`)\n//         .map(piece => OklchSpace.interpolator(piece[ 0 ], piece[ 1 ], direction));\n//       break;\n//   }\n\n\n//   return (amt: number): string => {\n//     amt = clamp(amt);\n\n//     // Scale to 0..1 to 0...ranges.length\n//     const s = scaleNumber(amt, 0, 1, 0, ranges.length);\n//     const index = Math.floor(s);\n//     const amtAdjusted = s - index;\n//     const range = ranges[ index ];\n\n//     // If we're at the end, return the last colour\n\n//     if (index === 1) return toHex(colours.at(-1)!);\n\n//     const colour = range(amtAdjusted);\n//     return colour.display();\n\n//   }\n// }\n\n// const interpolatorInit = (colours: Colourish[]) => {\n//   if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n//   if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n//   const c = colours.map(colour => toLibraryColour(colour));\n//   return [ ...pairwise(c) ];\n// }\n\n// function interpolateInit(colours: Colourish[], destination: `oklch-scalar`): OkLchScalar[][];\n// function interpolateInit(colours: Colourish[], destination: `hsl-scalar`): HslScalar[][];\nfunction interpolateInit<T extends ColourSpaces>(colours: Colourish[], destination: T):\n  T extends `oklch` ? OkLchScalar[][] :\n  T extends `hsl` ? HslScalar[][] :\n  T extends `srgb` ? RgbScalar[][] : HslScalar[][]\n\nfunction interpolateInit(colours: Colourish[], destination: ColourSpaces = `hsl`): (OkLchScalar | HslScalar | RgbScalar)[][] {\n  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n\n  const c = colours.map(colour => convertScalar(colour, destination));\n  return [ ...pairwise(c) ];\n}\n\n/**\n * Returns a CSS `linear-gradient` with stops corresponding to the given list of `colours`.\n * ```js\n * element.style.background = Colour.cssLinearGradient(['red','green','blue']);\n * ```\n * @param colours \n * @returns \n */\nexport const cssLinearGradient = (colours: Colourish[]) => {\n  const c = colours.map(c => toCssColour(c));\n  return `linear-gradient(to right, ${ c.join(`, `) })`;\n}\n\n/**\n * Returns a function that interpolates between two colours. Returns string colour values.\n * ```js\n * const i = interpolator(`blue`, `red`);\n * i(0.5); // Get the colour at 50%, as a string.\n * ```\n * \n * To work with structured colour values, use one of the space's `interpolate` functions.\n * @param colourA \n * @param colourB \n * @param options \n * @returns \n */\nexport const interpolator = (colourA: Colourish, colourB: Colourish, options: Partial<ColourInterpolationOpts> = {}) => {\n  const space = options.space ?? `oklch`;\n  const direction = options.direction ?? `shorter`;\n\n  let inter: ColourInterpolator<Colour> | undefined;\n  switch (space) {\n    case `hsl`:\n      inter = HslSpace.interpolator(convert(colourA, `hsl-scalar`), convert(colourB, `hsl-scalar`), direction);\n      break;\n    case `srgb`:\n      inter = SrgbSpace.interpolator(convert(colourA, `srgb-scalar`), convert(colourB, `srgb-scalar`));\n      break;\n    default:\n      inter = OklchSpace.interpolator(convert(colourA, `oklch-scalar`), convert(colourB, `oklch-scalar`), direction);\n  }\n\n  return (amount: number) => toCssColour(inter(amount));\n\n}\n\n/**\n * Produces a stepped scale of colours.\n * \n * ```js\n * // A scale of from red to green, with three colours in-between\n * const steps = Colour.scale([ `red`, `green` ], { stepsBetween: 3 });\n * for (const step of steps) {\n *  // A CSS colour string\n * }\n * ```\n * \n * {@link cssLinearGradient} can produce a smooth gradient in CSS on the basis\n * of the stepped colours.\n * @param colours \n * @param opts \n * @returns \n */\nexport const scale = (colours: Colourish[], opts: Partial<ColourStepOpts> = {}): string[] => {\n  const direction = opts.direction ?? `shorter`;\n  const space = opts.space ?? `oklch`;\n  const pieces = interpolateInit(colours, space);\n\n  let stepsBetween = 0;\n  if (typeof opts.stepsBetween === `number`) {\n    stepsBetween = opts.stepsBetween;\n    if (stepsBetween < 1) throw new Error(`Param 'stepsBetween' must be at least 1`);\n  } else if (typeof opts.stepsTotal === `number`) {\n    if (opts.stepsTotal <= colours.length) throw new Error(`Param 'stepsTotal' must be greater than number of provided colour stops (${ colours.length }) +1 per stop`);\n    const totalSteps = opts.stepsTotal - colours.length;\n    stepsBetween = Math.floor(totalSteps / pieces.length);\n  }\n\n  const steps = pieces.map((piece: Colour[]) => {\n    //const pieceSteps = HslSpace.createSteps(piece[ 0 ], piece[ 1 ], stepsBetween, direction, true);\n    const pieceSteps: Colour[] = createSteps(piece[ 0 ], piece[ 1 ], { steps: stepsBetween, space, direction, exclusive: true });\n\n    // Add end colour\n    pieceSteps.push(piece[ 1 ]);\n    return pieceSteps;\n  });\n\n  // Add very first colour\n  const firstPiece = pieces[ 0 ];\n  steps.unshift([ firstPiece[ 0 ] ]);\n  return steps.flat().map(c => toCssColour(c));\n}\n\nexport type CreateStepsOptions = Partial<{ space: ColourSpaces, steps: number, direction: `longer` | `shorter`, exclusive: boolean }>\n\n/**\n * Creates discrete colour steps between two colours. \n * \n * Start and end colours are included (and counted as a step) unless `exclusive` is set to _true_\n * \n * ```js\n * // Array of five HslScalar \n * createSteps(`red`,`blue`, { steps: 5 });\n * ```\n * \n * Defaults to the oklch colour space, 5 steps and non-exclusive.\n * @param a Start colour\n * @param b End colour\n * @param options\n * @returns \n */\nexport function createSteps<T extends CreateStepsOptions>(a: Colourish | string, b: Colourish, options: T):\n  T extends { space: `oklch` } ? OkLchScalar[] :\n  T extends { space: `srgb` } ? RgbScalar[] :\n  T extends { space: `hsl` } ? HslScalar[] : OkLchScalar[];\n\nexport function createSteps(a: Colourish | string, b: Colourish, options: CreateStepsOptions = {}): Colour[] {\n  const exclusive = options.exclusive ?? false;\n  const steps = options.steps ?? 5;\n  const space = options.space ?? `oklch`;\n  const direction = options.direction ?? `shorter`;\n\n  if (!exclusive && steps < 2) throw new Error(`Param 'steps' should be at least 2 when 'exclusive' is false`);\n  if (exclusive && steps < 1) throw new Error(`Param 'steps' should be at least 1 when 'exlusive' is true`);\n\n  const aa = convertScalar(a, space);\n  const bb = convertScalar(b, space);\n\n  // Create interpolator\n  let inter: ColourInterpolator<Colour> | undefined;\n  switch (space) {\n    case `hsl`:\n      inter = HslSpace.interpolator(aa as HslScalar, bb as HslScalar, direction);\n      break;\n    case `oklch`:\n      inter = OklchSpace.interpolator(aa as OkLchScalar, bb as OkLchScalar, direction);\n      break;\n    case `srgb`:\n      inter = SrgbSpace.interpolator(aa as RgbScalar, bb as RgbScalar);\n      break;\n    default:\n      throw new Error(`Colour space '${ space }' not supported for interpolation.`);\n  }\n  if (!inter) throw new Error(`Could not create interpolator for space: ${ space }`);\n\n  let stepBy = 0;\n  let startAt = 0;\n  let endAt = 1;\n  if (exclusive) {\n    stepBy = 1 / (steps + 1);\n    startAt = stepBy;\n    endAt = 1 - stepBy;\n  } else {\n    stepBy = 1 / (steps - 1);\n  }\n\n  const results: Colour[] = [];\n  for (let interpolateAmount = startAt; interpolateAmount <= endAt; interpolateAmount += stepBy) {\n    results.push(inter(interpolateAmount));\n  }\n\n  return results;\n}\n","export * from './conversion.js';\nexport * from './css-colours.js';\nexport * from './generate.js';\nexport * from './guards.js';\n//export * from './interpolate.js';\nexport * from './math.js';\nexport * from './interpolate.js';\nexport * as HslSpace from './hsl.js';\nexport * as OklchSpace from './oklch.js';\nexport * as SrgbSpace from './srgb.js';\n\nexport * from './types.js';","import Colorizr, * as C from \"colorizr\";\nimport { type Colour, type Colourish, type ColourSpaces, type Hsl, type HslAbsolute, type HslScalar, type OkLch, type OkLchAbsolute, type OkLchScalar, type Rgb, type Rgb8Bit, type RgbScalar } from \"./types.js\";\nimport * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport * as OkLchSpace from './oklch.js';\nimport { fromCssColour } from \"./css-colours.js\";\nimport { isHsl, isRgb, tryParseObjectToRgb, tryParseObjectToHsl, isColourish, isOkLch } from \"./guards.js\";\nimport { OklchSpace } from \"./index.js\";\n\nexport type ConvertDestinations = `hsl-scalar` | `hsl-absolute` | `oklch-scalar` | `oklch-absolute` | `srgb-8bit` | `srgb-scalar`;\n\nexport function convert<T extends ConvertDestinations>(colour: Colourish, destination: T):\n  T extends \"oklch-absolute\" ? OkLchAbsolute :\n  T extends \"oklch-scalar\" ? OkLchScalar :\n  T extends \"srgb-8bit\" ? Rgb8Bit :\n  T extends \"srgb-scalar\" ? RgbScalar :\n  T extends \"hsl-scalar\" ? HslScalar :\n  T extends \"hsl-absolute\" ? HslAbsolute : never\n\n/**\n * Converts an object or string representation of colour to ixfx's\n * structured colour.\n * Use {@link convertToString} if you want a CSS colour string instead.\n * @param colour \n * @param destination \n * @returns \n */\nexport function convert(colour: Colourish, destination: ConvertDestinations): Hsl | OkLch | Rgb {\n  if (destination === `hsl-scalar`) {\n    if (typeof colour === `string` || isHsl(colour) || isRgb(colour)) {\n      return HslSpace.toScalar(colour);\n    }\n  } else if (destination === `hsl-absolute`) {\n    if (typeof colour === `string` || isHsl(colour)) {\n      return HslSpace.toAbsolute(colour);\n    }\n  } else if (destination === `oklch-scalar`) {\n    if (typeof colour === `string` || isOkLch(colour)) {\n      return OkLchSpace.toScalar(colour);\n    }\n  } else if (destination === `oklch-absolute`) {\n    if (typeof colour === `string` || isOkLch(colour)) {\n      return OkLchSpace.toAbsolute(colour);\n    }\n  } else if (destination === `srgb-8bit`) {\n    if (typeof colour === `string` || isRgb(colour)) {\n      return SrgbSpace.to8bit(colour);\n    }\n  } else if (destination === `srgb-scalar`) {\n    if (typeof colour === `string` || isRgb(colour)) {\n      return SrgbSpace.toScalar(colour);\n    }\n  } else {\n    throw new Error(`Destination '${ destination }' not supported for input: ${ JSON.stringify(colour) }`);\n  }\n  return convert(toCssColour(colour), destination);\n}\n\n/**\n * Like {@link convert}, but result is a CSS colour string\n * @param colour \n * @param destination \n * @returns \n */\nexport function convertToString(colour: Colourish, destination: ConvertDestinations): string {\n  const c = convert(colour, destination);\n  return toCssColour(c);\n}\n\nexport function convertScalar<T extends ColourSpaces>(colour: Colourish, destination: T):\n  T extends \"oklch\" ? OkLchScalar :\n  T extends \"hsl\" ? HslScalar :\n  T extends \"srgb\" ? RgbScalar : never\n\nexport function convertScalar(colour: Colourish, destination: ColourSpaces): HslScalar | OkLchScalar | RgbScalar {\n  if (destination === `oklch`) return convert(colour, `oklch-scalar`);\n  if (destination === `srgb`) return convert(colour, `srgb-scalar`);\n  if (destination === `hsl`) return convert(colour, `hsl-scalar`);\n  throw new Error(`Unknown destination: '${ destination }'`);\n}\n\nexport const toCssColour = (colour: Colourish | object): string => {\n  if (typeof colour === `string`) return colour;\n\n  if (isHsl(colour)) {\n    return HslSpace.toCssString(colour);\n  }\n\n  if (isRgb(colour)) {\n    return SrgbSpace.toCssString(colour);\n  }\n\n  if (isOkLch(colour)) {\n    return OklchSpace.toCssString(colour);\n  }\n  const asRgb = tryParseObjectToRgb(colour);\n  if (asRgb) return SrgbSpace.toCssString(asRgb);\n\n  const asHsl = tryParseObjectToHsl(colour);\n  if (asHsl) return HslSpace.toCssString(asHsl);\n\n  throw new Error(`Unknown colour format: '${ JSON.stringify(colour) }'`);\n}\n\nexport const toLibraryColour = (colour: Colourish): Colorizr => {\n  const asCss = toCssColour(colour);\n  return new Colorizr(asCss);\n}\n\n// export const convertColourString = (colour: string, destination: 'hex' | 'hsl' | 'oklab' | 'oklch' | 'srgb' | `rgb`): string => {\n//   if (destination === `srgb`) destination = `rgb`;\n//   return C.convert(colour, destination);\n// }\n\nexport const guard = (colour: Colour) => {\n  switch (colour.space) {\n    case `hsl`:\n      HslSpace.guard(colour);\n      break;\n    case `srgb`:\n      SrgbSpace.guard(colour);\n      break;\n    case `oklch`:\n      OkLchSpace.guard(colour);\n      break;\n    default:\n      throw new Error(`Unsupported colour space: '${ colour.space }'`);\n  }\n}\n\nexport const toColour = (colourish: any): Colour => {\n  if (!isColourish(colourish)) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc. Got: ${ JSON.stringify(colourish) }`);\n  let c: Colour | undefined;\n  if (typeof colourish === `string`) c = fromCssColour(colourish);\n  else c = colourish;\n  if (c === undefined) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n\n  guard(c);\n  return c;\n}\n\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const toStringFirst = (...colours: (Colourish | undefined)[]): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    try {\n      const c = toColour(colour);\n      return toCssColour(c);\n    } catch { /* empty */ }\n  }\n  return `rebeccapurple`;\n}\n\n\nexport function rgbToHsl(rgb: Rgb, scalarResult: true): HslScalar\nexport function rgbToHsl(rgb: Rgb, scalarResult: false): HslAbsolute\nexport function rgbToHsl(rgb: Rgb, scalarResult: boolean): Hsl {\n  // Needed because the Colorizr package has broken RGB to HSL\n  // Converts rgb { model: 'rgb', r: 40, g: 20, b: 60, alpha: undefined }\n  // to : { h: 270, s: 50, l: 0.06 }\n  // when it should be: { h: 270, s: 50, l: 40 }\n\n  // Source: https://www.jameslmilner.com/posts/converting-rgb-hex-hsl-colors/\n  let { r, g, b } = rgb;\n  const opacity = rgb.opacity ?? 1;\n  if (rgb.unit === `8bit`) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n  }\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n\n  let h = (max + min) / 2;\n  let s = h;\n  const l = h;\n\n  if (max === min) {\n    // Achromatic\n    if (scalarResult) {\n      return HslSpace.scalar(0, 0, 0, opacity);\n    } else {\n      return HslSpace.absolute(0, 0, 0, opacity);\n    }\n  }\n\n  const d = max - min;\n  s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n  switch (max) {\n    case r:\n      h = ((g - b) / d + 0) * 60;\n      break;\n    case g:\n      h = ((b - r) / d + 2) * 60;\n      break;\n    case b:\n      h = ((r - g) / d + 4) * 60;\n      break;\n  }\n\n  if (scalarResult) {\n    return HslSpace.scalar(h / 360, s, l, opacity)\n  } else {\n    return HslSpace.absolute(h, s * 100, l * 100, opacity);\n  }\n}","import type { StrokeOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: strokeStyle, strokeWidth, strokeDash, strokeLineCap\n * @param elem Element\n * @param opts\n */\nexport const applyStrokeOpts = (elem: SVGElement, opts: StrokeOpts) => {\n  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);\n  if (opts.strokeWidth) {\n    elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());\n  }\n  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);\n  if (opts.strokeLineCap) {\n    elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);\n  }\n};","import { applyOpts } from \"./apply.js\";\nimport { createEl, createOrResolve } from \"./create.js\";\nimport type { DrawingOpts, MarkerOpts } from \"./types.js\";\n\nexport const createMarker = (\n  id: string,\n  opts: MarkerOpts,\n  childCreator?: () => SVGElement\n): SVGMarkerElement => {\n  const m = createEl<SVGMarkerElement>(`marker`, id);\n\n  if (opts.markerWidth) {\n    m.setAttribute(`markerWidth`, opts.markerWidth?.toString());\n  }\n  if (opts.markerHeight) {\n    m.setAttribute(`markerHeight`, opts.markerHeight?.toString());\n  }\n  if (opts.orient) m.setAttribute(`orient`, opts.orient.toString());\n  else m.setAttribute(`orient`, `auto-start-reverse`);\n\n  if (opts.viewBox) m.setAttribute(`viewBox`, opts.viewBox.toString());\n  if (opts.refX) m.setAttribute(`refX`, opts.refX.toString());\n  if (opts.refY) m.setAttribute(`refY`, opts.refY.toString());\n\n  if (childCreator) {\n    const c = childCreator();\n    m.appendChild(c);\n  }\n  return m;\n};\n\nexport const markerPrebuilt = (\n  elem: SVGElement | null,\n  opts: MarkerOpts,\n  _context: DrawingOpts\n): string => {\n  if (elem === null) return `(elem null)`;\n\n  const parent = elem.ownerSVGElement;\n  if (parent === null) throw new Error(`parent for elem is null`);\n  const defsEl = createOrResolve<SVGDefsElement>(parent, `defs`, `defs`);\n\n  //eslint-disable-next-line functional/no-let\n  let defEl = defsEl.querySelector(`#${ opts.id }`) as SVGElement | null;\n\n  if (defEl !== null) {\n    return `url(#${ opts.id })`;\n  }\n\n  if (opts.id === `triangle`) {\n    opts = { ...opts, strokeStyle: `transparent` };\n    if (!opts.markerHeight) opts = { ...opts, markerHeight: 6 };\n    if (!opts.markerWidth) opts = { ...opts, markerWidth: 6 };\n    if (!opts.refX) opts = { ...opts, refX: opts.markerWidth };\n    if (!opts.refY) opts = { ...opts, refY: opts.markerHeight };\n    if (!opts.fillStyle || opts.fillStyle === `none`) {\n      opts = { ...opts, fillStyle: `black` };\n    }\n    if (!opts.viewBox) opts = { ...opts, viewBox: `0 0 10 10` };\n\n    defEl = createMarker(opts.id, opts, () => {\n      const tri = createEl<SVGPathElement>(`path`);\n      tri.setAttribute(`d`, `M 0 0 L 10 5 L 0 10 z`);\n      if (opts) applyOpts(tri, opts);\n      return tri;\n    });\n  } else throw new Error(`Do not know how to make ${ opts.id }`);\n\n  //eslint-disable-next-line functional/immutable-data\n  defEl.id = opts.id;\n  defsEl.appendChild(defEl);\n\n  return `url(#${ opts.id })`;\n};\n","import type { DrawingOpts } from \"../drawing.js\";\nimport { markerPrebuilt } from \"./markers.js\";\nimport type { PathDrawingOpts } from \"./types.js\";\n\n/**\n * Applies path drawing options to given element\n * Applies: markerEnd, markerStart, markerMid\n * @param elem Element (presumed path)\n * @param opts Options\n */\nexport const applyPathOpts = (elem: SVGElement, opts: PathDrawingOpts) => {\n  if (opts.markerEnd) {\n    elem.setAttribute(\n      `marker-end`,\n      markerPrebuilt(elem, opts.markerEnd, opts as DrawingOpts)\n    );\n  }\n  if (opts.markerStart) {\n    elem.setAttribute(\n      `marker-start`,\n      markerPrebuilt(elem, opts.markerStart, opts as DrawingOpts)\n    );\n  }\n  if (opts.markerMid) {\n    elem.setAttribute(\n      `marker-mid`,\n      markerPrebuilt(elem, opts.markerMid, opts as DrawingOpts)\n    );\n  }\n};","\n//import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\n//import type { Point } from '../../geometry/point/PointType.js';\n//import type { Line } from '../../geometry/line/LineType.js';\n//import * as Lines from '../geometry/line/index.js';\nimport { Lines, Polar } from '@ixfx/geometry';\n//import * as Svg from './index.js';\nimport { toStringFirst as ColourStringFirst } from '../colour/conversion.js';\n//import { getCssVariable } from '../colour/index.js';\nimport type { CircleDrawingOpts, LineDrawingOpts, PathDrawingOpts, TextDrawingOpts, TextPathDrawingOpts } from './types.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { createEl, createOrResolve } from './create.js';\nimport { applyPathOpts } from './path.js';\nimport type { CirclePositioned } from '@ixfx/geometry/circle';\nimport type { Line } from '@ixfx/geometry/line';\nimport type { Point } from '@ixfx/geometry/point';\n//import type { PolarRay } from 'src/geometry/polar/Types.js';\n//import { toCartesian as polarRayToCartesian } from 'src/geometry/polar/Ray.js';\n//import {Palette} from \".\";\n\nconst numberOrPercentage = (v: number): string => {\n  if (v >= 0 && v <= 1) return `${ v * 100 }%`;\n  return v.toString();\n};\n\n/**\n * Creates and adds an SVG path element\n * @example\n * ```js\n * const paths = [\n *  `M300,200`,\n *  `a25,25 -30 0,1 50, -25 l 50,-25`\n * ]\n * const pathEl = path(paths, parentEl);\n * ```\n * @param svgOrArray Path syntax, or array of paths. Can be empty if path data will be added later\n * @param parent SVG parent element\n * @param opts Options Drawing options\n * @returns\n */\nexport const path = (\n  svgOrArray: string | readonly string[],\n  parent: SVGElement,\n  opts?: PathDrawingOpts,\n  queryOrExisting?: string | SVGPathElement\n): SVGPathElement => {\n  const elem = createOrResolve<SVGPathElement>(\n    parent,\n    `path`,\n    queryOrExisting\n  );\n  const svg =\n    typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`\\n`);\n\n  elem.setAttributeNS(null, `d`, svg);\n  parent.append(elem);\n  return pathUpdate(elem, opts);\n};\n\nexport const pathUpdate = (\n  elem: SVGPathElement,\n  opts?: PathDrawingOpts\n) => {\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n  return elem;\n};\n\n/**\n * Updates an existing `SVGCircleElement` with potentially updated circle data and drawing options\n * @param elem Element\n * @param circle Circle\n * @param opts Drawing options\n * @returns SVGCircleElement\n */\nexport const circleUpdate = (\n  elem: SVGCircleElement,\n  circle: CirclePositioned,\n  opts?: CircleDrawingOpts\n) => {\n  elem.setAttributeNS(null, `cx`, circle.x.toString());\n  elem.setAttributeNS(null, `cy`, circle.y.toString());\n  elem.setAttributeNS(null, `r`, circle.radius.toString());\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n\n  return elem;\n};\n\n/**\n * Creates or reuses a `SVGCircleElement`.\n *\n * To update an existing element, use `circleUpdate`\n * @param circle\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const circle = (\n  circle: CirclePositioned,\n  parent: SVGElement,\n  opts?: CircleDrawingOpts,\n  queryOrExisting?: string | SVGCircleElement\n): SVGCircleElement => {\n  const p = createOrResolve<SVGCircleElement>(\n    parent,\n    `circle`,\n    queryOrExisting\n  );\n  return circleUpdate(p, circle, opts);\n};\n\n/**\n * Creates or resuses a `SVGGElement` (group)\n *\n * To update an existing elemnet, use `groupUpdate`\n * @param children\n * @param parent\n * @param queryOrExisting\n * @returns\n */\nexport const group = (\n  children: readonly SVGElement[],\n  parent: SVGElement,\n  queryOrExisting?: string | SVGGElement\n): SVGGElement => {\n  const p = createOrResolve<SVGGElement>(parent, `g`, queryOrExisting);\n  return groupUpdate(p, children);\n};\n\nexport const groupUpdate = (\n  elem: SVGGElement,\n  children: readonly SVGElement[]\n) => {\n  for (const c of children) {\n    if (c.parentNode !== elem) {\n      elem.append(c);\n    }\n  }\n\n  return elem;\n};\n\n/**\n * Creates or reuses a SVGLineElement.\n *\n * @param line\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const line = (\n  line: Line,\n  parent: SVGElement,\n  opts?: LineDrawingOpts,\n  queryOrExisting?: string | SVGLineElement\n): SVGLineElement => {\n  const lineEl = createOrResolve<SVGLineElement>(\n    parent,\n    `line`,\n    queryOrExisting\n  );\n  return lineUpdate(lineEl, line, opts);\n};\n\n/**\n * Updates a SVGLineElement instance with potentially changed line and drawing data\n * @param lineEl\n * @param line\n * @param opts\n * @returns\n */\nexport const lineUpdate = (\n  lineEl: SVGLineElement,\n  line: Line,\n  opts?: LineDrawingOpts\n) => {\n  lineEl.setAttributeNS(null, `x1`, line.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, line.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, line.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, line.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n};\n\nexport const polarRayUpdate = (lineEl: SVGLineElement, ray: Polar.PolarRay, opts?: LineDrawingOpts) => {\n  const l = Polar.Ray.toCartesian(ray);\n  lineEl.setAttributeNS(null, `x1`, l.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, l.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, l.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, l.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n}\n\n/**\n * Updates an existing SVGTextPathElement instance with text and drawing options\n * @param el\n * @param text\n * @param opts\n * @returns\n */\nexport const textPathUpdate = (\n  el: SVGTextPathElement,\n  text?: string,\n  opts?: TextPathDrawingOpts\n) => {\n  if (opts?.method) el.setAttributeNS(null, `method`, opts.method);\n  if (opts?.side) el.setAttributeNS(null, `side`, opts.side);\n  if (opts?.spacing) el.setAttributeNS(null, `spacing`, opts.spacing);\n  if (opts?.startOffset) {\n    el.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));\n  }\n  if (opts?.textLength) {\n    el.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));\n  }\n\n  if (text) {\n    el.textContent = text;\n  }\n  if (opts) applyOpts(el, opts);\n  if (opts) applyStrokeOpts(el, opts);\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextPathElement.\n * @param pathReference\n * @param text\n * @param parent\n * @param opts\n * @param textQueryOrExisting\n * @param pathQueryOrExisting\n * @returns\n */\nexport const textPath = (\n  pathReference: string,\n  text: string,\n  parent: SVGElement,\n  opts?: TextPathDrawingOpts,\n  textQueryOrExisting?: string | SVGTextElement,\n  pathQueryOrExisting?: string | SVGTextPathElement\n): SVGTextPathElement => {\n  const textEl = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    textQueryOrExisting, `-text`\n  );\n  // Update text properties, but don't pass in position or text\n  textUpdate(textEl, undefined, undefined, opts);\n\n  const p = createOrResolve<SVGTextPathElement>(\n    textEl,\n    `textPath`,\n    pathQueryOrExisting\n  );\n  p.setAttributeNS(null, `href`, pathReference);\n  return textPathUpdate(p, text, opts);\n};\n\n/**\n * Updates an existing SVGTextElement instance with position, text and drawing options\n * @param el\n * @param pos\n * @param text\n * @param opts\n * @returns\n */\nexport const textUpdate = (\n  el: SVGTextElement,\n  pos?: Point,\n  text?: string,\n  opts?: TextDrawingOpts\n) => {\n  if (pos) {\n    el.setAttributeNS(null, `x`, pos.x.toString());\n    el.setAttributeNS(null, `y`, pos.y.toString());\n  }\n  if (text) {\n    el.textContent = text;\n  }\n\n  if (opts) {\n    applyOpts(el, opts);\n    if (opts) applyStrokeOpts(el, opts);\n\n    if (opts.anchor) el.setAttributeNS(null, `text-anchor`, opts.anchor);\n    if (opts.align) el.setAttributeNS(null, `alignment-baseline`, opts.align);\n\n    const userSelect = opts.userSelect ?? true;\n\n    if (!userSelect) {\n      el.style.userSelect = `none`;\n    }\n  }\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextElement\n * @param pos Position of text\n * @param text Text\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const text = (\n  text: string,\n  parent: SVGElement,\n  pos?: Point,\n  opts?: TextDrawingOpts,\n  queryOrExisting?: string | SVGTextElement\n): SVGTextElement => {\n  const p = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    queryOrExisting\n  );\n  return textUpdate(p, pos, text, opts);\n};\n\n/**\n * Creates a square grid based at a center point, with cells having `spacing` height and width.\n *\n * It fits in as many cells as it can within `width` and `height`.\n *\n * Returns a SVG group, consisting of horizontal and vertical lines\n * @param parent Parent element\n * @param center Center point of grid\n * @param spacing Width/height of cells\n * @param width How wide grid should be\n * @param height How high grid should be\n * @param opts\n */\nexport const grid = (\n  parent: SVGElement,\n  center: Point,\n  spacing: number,\n  width: number,\n  height: number,\n  opts: LineDrawingOpts = {}\n) => {\n  if (!opts.strokeStyle) {\n    opts = { ...opts, strokeStyle: ColourStringFirst(`bg-dim`, `silver`) };\n  }\n  if (!opts.strokeWidth) opts = { ...opts, strokeWidth: 1 };\n\n  const g = createEl<SVGGElement>(`g`);\n  applyOpts(g, opts);\n  applyPathOpts(g, opts);\n  applyStrokeOpts(g, opts);\n\n  // Horizontals\n  let y = 0;\n  while (y < height) {\n    const horiz = Lines.fromNumbers(0, y, width, y);\n    line(horiz, g);\n    y += spacing;\n  }\n\n  // Verticals\n  let x = 0;\n  while (x < width) {\n    const vert = Lines.fromNumbers(x, 0, x, height);\n    line(vert, g);\n    x += spacing;\n  }\n  parent.append(g);\n  return g;\n};\n","import { Polar } from \"@ixfx/geometry\";\nimport type { Line } from \"@ixfx/geometry/line\";\nimport type { Point } from \"@ixfx/geometry/point\";\n// import type { Line } from \"../../geometry/line/LineType.js\";\n// import type { Point } from \"../../geometry/point/PointType.js\";\n// import { fromLine as polarRayFromLine } from \"../../geometry/polar/Ray.js\";\n\n/**\n * Returns a Line type from an SVGLineElement\n * @param el SVG Line Element\n * @returns \n */\nexport const lineFromSvgLine = (el: SVGLineElement): Line => {\n  if (!el) throw new Error(`Param 'el' is undefined`);\n  const a = { x: el.x1.baseVal.value, y: el.y1.baseVal.value };\n  const b = { x: el.x2.baseVal.value, y: el.y2.baseVal.value };\n  return { a, b }\n}\n\nexport const polarRayFromSvgLine = (el: SVGLineElement, origin: Point): Polar.PolarRay => {\n  const l = lineFromSvgLine(el);\n  return Polar.Ray.fromLine(l, origin);\n}","/**\n * Removes an SVG element from a parent\n * @param parent Parent\n * @param queryOrExisting Query or existing element \n * @returns \n */\nexport const remove = <V extends SVGElement>(\n  parent: SVGElement,\n  queryOrExisting: string | V\n) => {\n  if (typeof queryOrExisting === `string`) {\n    const elem = parent.querySelector(queryOrExisting);\n    if (elem === null) return;\n    elem.remove();\n  } else {\n    queryOrExisting.remove();\n  }\n};\n\n/**\n * Removes all children of `parent`, but not `parent` itself.\n * @param parent \n */\nexport const clear = (parent: SVGElement) => {\n  let c = parent.lastElementChild;\n  while (c) {\n    c.remove();\n    c = parent.lastElementChild;\n  }\n};","// import { Point } from '@ixfx/geometry';\n// import type { Line } from '../../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\nimport type { CircleDrawingOpts, DrawingOpts, LineDrawingOpts, PathDrawingOpts, StrokeOpts, TextDrawingOpts } from './types.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { remove } from './remove.js';\nimport * as Elements from './elements.js';\nimport type { Point } from '@ixfx/geometry/point';\nimport type { CirclePositioned } from '@ixfx/geometry/circle';\nimport type { Line } from '@ixfx/geometry/line';\n\n/**\n * Helper to make SVG elements with a common parent.\n *\n * Create with {@link makeHelper}.\n */\nexport type SvgHelper = {\n  remove(queryOrExisting: string | SVGElement): void;\n  /**\n   * Creates a text element\n   * @param text Text\n   * @param pos Position\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  text(\n    text: string,\n    pos: Point,\n    opts?: TextDrawingOpts,\n    queryOrExisting?: string | SVGTextElement\n  ): SVGTextElement;\n  /**\n   * Creates text on a path\n   * @param pathReference Reference to path element\n   * @param text Text\n   * @param opts Drawing options\n   * @param textQueryOrExisting DOM query to look up existing element, or the element instance\n   * @param pathQueryOrExisting DOM query to look up existing element, or the element instance\n   */\n  textPath(\n    pathReference: string,\n    text: string,\n    opts?: TextDrawingOpts,\n    textQueryOrExisting?: string | SVGTextElement,\n    pathQueryOrExisting?: string | SVGTextPathElement\n  ): SVGTextPathElement;\n  /**\n   * Creates a line\n   * @param line Line\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  line(\n    line: Line,\n    opts?: LineDrawingOpts,\n    queryOrExisting?: string | SVGLineElement\n  ): SVGLineElement;\n  /**\n   * Creates a circle\n   * @param circle Circle\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  circle(\n    circle: CirclePositioned,\n    opts?: CircleDrawingOpts,\n    queryOrExisting?: string | SVGCircleElement\n  ): SVGCircleElement;\n  /**\n   * Creates a path\n   * @param svgString Path description, or empty string\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  path(\n    svgString: string | readonly string[],\n    opts?: PathDrawingOpts,\n    queryOrExisting?: string | SVGPathElement\n  ): SVGPathElement;\n  /**\n   * Creates a grid of horizontal and vertical lines inside of a group\n   * @param center Grid origin\n   * @param spacing Cell size\n   * @param width Width of grid\n   * @param height Height of grid\n   * @param opts Drawing options\n   */\n  grid(\n    center: Point,\n    spacing: number,\n    width: number,\n    height: number,\n    opts?: LineDrawingOpts\n  ): SVGGElement;\n  /**\n   * Returns an element if it exists in parent\n   * @param selectors Eg `#path`\n   */\n  query<V extends SVGElement>(selectors: string): V | null;\n  /**\n   * Gets/sets the width of the parent\n   */\n  get width(): number;\n  set width(width: number);\n  /**\n   * Gets the parent\n   */\n  get parent(): SVGElement;\n  /**\n   * Gets/sets the height of the parent\n   */\n  get height(): number;\n  set height(height: number);\n  /**\n   * Deletes all child elements\n   */\n  clear(): void;\n};\n\n/**\n * Creates a {@link SvgHelper} for the creating and management of SVG elements.\n * @param parent\n * @param parentOpts\n * @returns\n */\nexport const makeHelper = (\n  parent: SVGElement,\n  parentOpts?: DrawingOpts & StrokeOpts\n): SvgHelper => {\n  if (parentOpts) {\n    applyOpts(parent, parentOpts);\n    applyStrokeOpts(parent, parentOpts);\n  }\n\n  const o: SvgHelper = {\n    remove: (queryOrExisting: string | SVGElement) => { remove(parent, queryOrExisting); },\n    text: (\n      text: string,\n      pos: Point,\n      opts?: TextDrawingOpts,\n      queryOrExisting?: string | SVGTextElement\n    ) => Elements.text(text, parent, pos, opts, queryOrExisting),\n    textPath: (\n      pathReference: string,\n      text: string,\n      opts?: TextDrawingOpts,\n      textQueryOrExisting?: string | SVGTextElement,\n      pathQueryOrExisting?: string | SVGTextPathElement\n    ) => Elements.textPath(pathReference, text, parent, opts, textQueryOrExisting, pathQueryOrExisting),\n    line: (\n      line: Line,\n      opts?: LineDrawingOpts,\n      queryOrExisting?: string | SVGLineElement\n    ) => Elements.line(line, parent, opts, queryOrExisting),\n    circle: (\n      circle: CirclePositioned,\n      opts?: CircleDrawingOpts,\n      queryOrExisting?: string | SVGCircleElement\n    ) => Elements.circle(circle, parent, opts, queryOrExisting),\n    path: (\n      svgString: string | readonly string[],\n      opts?: PathDrawingOpts,\n      queryOrExisting?: string | SVGPathElement\n    ) => Elements.path(svgString, parent, opts, queryOrExisting),\n    grid: (\n      center: Point,\n      spacing: number,\n      width: number,\n      height: number,\n      opts?: LineDrawingOpts\n    ) => Elements.grid(parent, center, spacing, width, height, opts),\n    query: <V extends SVGElement>(selectors: string): V | null =>\n      parent.querySelector(selectors),\n    get width(): number {\n      const w = parent.getAttributeNS(null, `width`);\n      if (w === null) return 0;\n      return Number.parseFloat(w);\n    },\n    set width(width: number) {\n      parent.setAttributeNS(null, `width`, width.toString());\n    },\n    get parent(): SVGElement {\n      return parent;\n    },\n    get height(): number {\n      const w = parent.getAttributeNS(null, `height`);\n      if (w === null) return 0;\n      return Number.parseFloat(w);\n    },\n    set height(height: number) {\n      parent.setAttributeNS(null, `height`, height.toString());\n    },\n    clear: () => {\n      while (parent.firstChild) {\n        (parent.lastChild as HTMLElement).remove();\n      }\n    },\n  };\n  return o;\n};\n","export * from './apply.js'\nexport * from './bounds.js'\nexport * from './create.js'\nexport * as Elements from './elements.js';\nexport * from './geometry.js';\nexport * from './helper.js';\nexport * from './markers.js';\nexport * from './path.js'\nexport * from './remove.js';\nexport * from './stroke.js'\nexport type * from './types.js';\n","\nimport { PointsTracker } from '@ixfx/geometry/point';\nimport * as Svg from './svg/index.js';\nimport { ElementSizer, resolveEl } from '@ixfx/dom';\nexport type Opts = {\n  readonly touchRadius?: number;\n  readonly mouseRadius?: number;\n  readonly trace?: boolean;\n  readonly hue?: number;\n};\n\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery Element to monitor\n * @param options Options\n */\nexport const pointerVisualise = (\n  elOrQuery: HTMLElement | string,\n  options: Opts = {}\n) => {\n  const touchRadius = options.touchRadius ?? 45;\n  const mouseRadius = options.touchRadius ?? 20;\n  const trace = options.trace ?? false;\n  const hue = options.hue ?? 100;\n\n  const startFillStyle = `hsla(${ hue }, 100%, 10%, 10%)`;\n  let currentHue = hue;\n\n  const el = resolveEl(elOrQuery);\n  const tracker = new PointsTracker({\n    storeIntermediate: trace,\n  });\n\n\n  const svg = document.createElementNS(\n    `http://www.w3.org/2000/svg`,\n    `svg`\n  ) as any as SVGElement & HTMLElement;\n  svg.id = `pointerVis`;\n  svg.style.zIndex = `-1000`;\n  svg.style.position = `fixed`;\n  svg.style.top = `0`;\n  svg.style.left = `0`;\n  svg.style.width = `100%`;\n  svg.style.height = `100%`;\n  svg.style.boxSizing = `border-box`;\n  svg.style.border = `3px solid red`;\n  svg.style.pointerEvents = `none`;\n  svg.style.touchAction = `none`;\n\n  // const er = new ElementSizer(svg, {\n  //   containerEl:document.body,\n  //   stretch:`both`,\n  //   onSetSize(size) {\n  //     svg.setAttribute(`width`, size.width.toString());\n  //     svg.setAttribute(`height`, size.height.toString());\n  //   },\n  // })\n  const er = ElementSizer.svgViewport(svg);\n  //fullSizeElement(svg);\n  let pointerCount = 0;\n\n  const lostPointer = (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n\n    tracker.delete(id);\n    currentHue = hue;\n    svg.querySelector(`#pv-start-${ id }`)?.remove();\n\n    for (let index = 0; index < pointerCount + 10; index++) {\n      svg.querySelector(`#pv-progress-${ id }-${ index }`)?.remove();\n    }\n    pointerCount = 0;\n  };\n\n  const trackPointer = async (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    const pt = { x: event.x, y: event.y };\n    const type = event.pointerType;\n    if (event.type === `pointermove` && !tracker.has(id)) {\n      return;\n    }\n    const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n\n    if (info.values.length === 1) {\n      const el = Svg.Elements.circle(\n        {\n          ...info.values[ 0 ],\n          radius: type === `touch` ? touchRadius : mouseRadius,\n        },\n        svg,\n        {\n          fillStyle: startFillStyle,\n        },\n        `#pv-start-${ id }`\n      );\n      el.style.pointerEvents = `none`;\n      el.style.touchAction = `none`;\n    }\n\n    const fillStyle = `hsla(${ currentHue }, 100%, 50%, 50%)`;\n\n    const el2 = Svg.Elements.circle(\n      { ...pt, radius: type === `touch` ? touchRadius : mouseRadius },\n      svg,\n      {\n        fillStyle,\n      },\n      `#pv-progress-${ id }-${ info.values.length }`\n    );\n    el2.style.pointerEvents = `none`;\n    el2.style.touchAction = `none`;\n    currentHue += 1;\n    pointerCount = info.values.length;\n  };\n\n  document.body.append(svg);\n\n\n  el.addEventListener(`pointerdown`, trackPointer);\n\n  el.addEventListener(`pointermove`, trackPointer);\n  el.addEventListener(`pointerup`, lostPointer);\n  el.addEventListener(`pointerleave`, lostPointer);\n  el.addEventListener(`contextmenu`, (event) => {\n    event.preventDefault();\n  });\n};\n","/**\n * Manage a set of named colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type NamedColourPalette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: ReadonlyArray<string>): NamedColourPalette =>\n  new NamedColourPaletteImpl(fallbacks);\n\nclass NamedColourPaletteImpl {\n  readonly #store: Map<string, string> = new Map();\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: ReadonlyArray<string>;\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: ReadonlyArray<string>) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const variableName = `--` + key;\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(variableName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import { continuously } from '@ixfx/core';\nimport { delayLoop } from '@ixfx/flow';\n\nexport type Capturer = {\n  start(): void;\n  cancel(): void;\n  readonly canvasEl: HTMLCanvasElement;\n};\n\nexport type ManualCapturer = {\n  capture(): ImageData;\n  readonly canvasEl: HTMLCanvasElement;\n  dispose(): void;\n};\n\nexport type CaptureOpts = {\n  /**\n   * Delay between reading frames.\n   * Default: 0, reading as fast as possible\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * Whether to show the created capture canvas.\n   * Default: false\n   */\n  readonly showCanvas?: boolean;\n  readonly workerScript?: string;\n  readonly onFrame?: (pixels: ImageData) => void;\n};\n\nexport type ManualCaptureOpts = {\n  /**\n   * If true, the intermediate canvas is shown\n   * The intermediate canvas is where captures from the source are put in order\n   * to get the ImageData\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * If specified, this is the canvas captured to\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Options for frames generator\n */\nexport type FramesOpts = {\n  /**\n   * Max frame rate (millis per frame), or 0 for animation speed\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * False by default, created canvas will be hidden\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If provided, this canvas will be used as the buffer rather than creating one.\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import { Video } from '@ixfx/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\n\nexport async function* frames(\n  sourceVideoEl: HTMLVideoElement,\n  opts: FramesOpts = {}\n): AsyncIterable<ImageData> {\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n\n  const showCanvas = opts.showCanvas ?? false;\n  let canvasEl = opts.canvasEl;\n  let w, h;\n  w = h = 0;\n\n  // Create & setup canvas\n  if (canvasEl === undefined) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-frames`);\n    if (!showCanvas) {\n      canvasEl.style.display = `none`;\n    }\n    document.body.appendChild(canvasEl);\n  }\n\n  // Update size of canvas based on video\n  const updateSize = () => {\n    if (canvasEl === undefined) return;\n    w = sourceVideoEl.videoWidth;\n    h = sourceVideoEl.videoHeight;\n    canvasEl.width = w;\n    canvasEl.height = h;\n  };\n\n  let c: CanvasRenderingContext2D | null = null;\n\n  const looper = delayLoop(maxIntervalMs);\n  for await (const _ of looper) {\n    // If we don't yet have the size of video, get it\n    if (w === 0 || h === 0) updateSize();\n\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n    if (w === 0 || h === 0) continue;\n\n    // Draw current frame from video element to hidden canvas\n    c ??= canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    // Get pixels\n    const pixels = c.getImageData(0, 0, w, h);\n    yield pixels;\n  }\n}\n\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: CaptureOpts = {}\n): Capturer => {\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  const showCanvas = opts.showCanvas ?? false;\n  const onFrame = opts.onFrame;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n  canvasEl.classList.add(`ixfx-capture`);\n\n  if (!showCanvas) {\n    canvasEl.style.display = `none`;\n  }\n  canvasEl.width = w;\n  canvasEl.height = h;\n  let c: CanvasRenderingContext2D | null = null;\n  let worker: Worker | undefined;\n  if (opts.workerScript) {\n    worker = new Worker(opts.workerScript);\n  }\n\n  // Should we get image data?\n  const getPixels = worker || onFrame;\n  if (!getPixels && !showCanvas) {\n    console.warn(\n      `Video will be captured to hidden element without any processing. Is this what you want?`\n    );\n  }\n\n  const loop = continuously(() => {\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n    let pixels: ImageData | undefined;\n\n    if (getPixels) {\n      // ImageData necessary\n      pixels = c.getImageData(0, 0, w, h);\n    }\n\n    if (worker) {\n      // Send to worker\n      worker.postMessage(\n        {\n          pixels: pixels!.data.buffer,\n          width: w,\n          height: h,\n          channels: 4,\n        },\n        [ pixels!.data.buffer ]\n      );\n    }\n    if (onFrame) {\n      // Send to callback\n      try {\n        onFrame(pixels!);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, maxIntervalMs);\n\n  return {\n    start: () => { loop.start(); },\n    cancel: () => { loop.cancel(); },\n    canvasEl,\n  };\n};\n\nexport const manualCapture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: ManualCaptureOpts = {}\n): ManualCapturer => {\n  const showCanvas = opts.showCanvas ?? false;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas if necessary\n  const definedCanvasEl = opts.canvasEl !== undefined;\n  let canvasEl = opts.canvasEl;\n  if (!canvasEl) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-capture`);\n    document.body.append(canvasEl);\n    if (!showCanvas) canvasEl.style.display = `none`;\n  }\n\n  canvasEl.width = w;\n  canvasEl.height = h;\n\n  const capture = (): ImageData => {\n    let c: CanvasRenderingContext2D | undefined | null;\n\n    // Draw current frame from video element to canvas\n    if (!c) c = canvasEl.getContext(`2d`, { willReadFrequently: true });\n    if (!c) throw new Error(`Could not create graphics context`);\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    const pixels = c.getImageData(0, 0, w, h);\n\n    (pixels as any).currentTime = sourceVideoEl.currentTime;\n\n    if (opts.postCaptureDraw) opts.postCaptureDraw(c, w, h);\n    return pixels;\n  };\n\n  const dispose = (): void => {\n    if (definedCanvasEl) return; // we didn't create it\n    try {\n      canvasEl.remove();\n    } catch (_) {\n      // no-op\n    }\n  };\n\n  const c: ManualCapturer = {\n    canvasEl,\n    capture,\n    dispose,\n  };\n  return c;\n};\n","import * as Drawing from \"../drawing.js\";\nimport { Bipolar } from \"@ixfx/numbers\";\nimport { type IQueueImmutable, QueueImmutable } from \"@ixfx/collections/queue\";\nimport * as Colour from \"../colour/index.js\";\nimport { type CirclePositioned } from \"@ixfx/geometry/circle\";\n\n/**\n * Options\n */\nexport type BipolarViewOptions = Readonly<{\n  width?: number,\n  height?: number,\n  labelPrecision?: number\n  labels?: [ string, string ],\n  axisColour?: string,\n  bgColour?: string,\n  whiskerColour?: string,\n  whiskerSize?: number,\n  dotColour?: string,\n  dotRadius?: number,\n  showWhiskers?: boolean,\n  showDot?: boolean,\n  showLabels?: boolean,\n  padding?: number,\n  labelColour?: string,\n  axisWidth?: number,\n  asPercentages?: boolean,\n  /**\n   * If non-zero, will render the last X number of values with increasing opacity.\n   * Default: 0\n   */\n  displayLastValues?: number\n  /**\n   * If _true_, (default) negative y values are at the bottom.\n   * If _false_  negative y values are at the top.\n   */\n  yAxisBottomNegative?: boolean,\n  /**\n   * Custom rendering for background\n   */\n  renderBackground?: Render\n}>\n\nfunction getNumericAttribute(el: HTMLElement, name: string, defaultValue: number) {\n  const a = el.getAttribute(name);\n  if (a === null) return defaultValue;\n  return Number.parseInt(a);\n}\n\nexport type Render = (ctx: CanvasRenderingContext2D, width: number, height: number) => void;\n/**\n * A function that plots a point on the graph\n */\nexport type BipolarView = (x: number, y: number) => void;\n\n/**\n * Initialises a plotter for bipolar values (-1...1)\n * \n * ```js\n * const p = BipolarView.init(`#my-canvas`);\n * // Shows the dot at 1, 0.5\n * p(1, 0.5);\n * ```\n * @param elementQuery \n * @param options \n * @returns \n */\nexport const init = (elementQuery: string, options: BipolarViewOptions = {}): BipolarView => {\n  const element = document.querySelector<HTMLCanvasElement>(elementQuery);\n  if (!element) throw new Error(`Element query could not be found (${ elementQuery })`);\n  const labels = options.labels ?? [ `x`, `y` ];\n  const labelPrecision = options.labelPrecision ?? 2;\n  const asPercentages = options.asPercentages ?? false;\n  const displayLastValues = options.displayLastValues ?? 0;\n  // Flags\n  const showWhiskers = options.showWhiskers ?? true;\n  const showDot = options.showDot ?? true;\n  const showLabels = options.showLabels ?? true;\n  const yAxisBottomNegative = options.yAxisBottomNegative ?? true;\n  // Colours\n  const axisColour = Colour.toStringFirst(options.axisColour, `silver`);\n  const bgColour = Colour.toStringFirst(options.bgColour, `white`);\n  const whiskerColour = Colour.toStringFirst(options.whiskerColour, `black`);\n  const dotColour = Colour.toStringFirst(options.dotColour, options.whiskerColour, `black`);\n  const labelColour = Colour.toStringFirst(options.labelColour, options.axisColour, `silver`);\n\n  // Sizes\n  const axisWidth = (options.axisWidth ?? 1 * window.devicePixelRatio);\n  const dotRadius = (options.dotRadius ?? 5 * window.devicePixelRatio);\n  const pad = (options.padding ?? 10 * window.devicePixelRatio);\n  const whiskerSize = (options.whiskerSize ?? 5 * window.devicePixelRatio);\n  const width = (options.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio);\n  const height = (options.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio);\n\n  let lastValues: IQueueImmutable<CirclePositioned> | undefined;\n  if (displayLastValues > 0) {\n    lastValues = new QueueImmutable<CirclePositioned>({\n      capacity: displayLastValues,\n      discardPolicy: `older`\n    });\n  }\n\n  element.width = width;// * window.devicePixelRatio;\n  element.height = height;// * window.devicePixelRatio;\n  element.style.width = `${ (width / window.devicePixelRatio) }px`;\n  element.style.height = `${ (height / window.devicePixelRatio) }px`;\n\n  const midY = height / 2;\n  const midX = width / 2;\n  const ctx = element.getContext(`2d`);\n  if (!ctx) throw new Error(`Could not create drawing context`);\n\n  if (window.devicePixelRatio >= 2) {\n    ctx.font = `20px sans-serif`;\n  }\n  const percentageFormat = (v: number) => `${ Math.round(v * 100) }%`;\n  const fixedFormat = (v: number) => v.toFixed(labelPrecision);\n\n  const valueFormat = asPercentages ? percentageFormat : fixedFormat;\n  if (showLabels) {\n    labels[ 0 ] = labels[ 0 ] + `:`;\n    labels[ 1 ] = labels[ 1 ] + `:`;\n  } else {\n    labels[ 0 ] = ``;\n    labels[ 1 ] = ``;\n  }\n\n  const renderBackground: Render = options.renderBackground ?? ((ctx, width, height): void => {\n    if (options.bgColour === `transparent`) {\n      ctx.clearRect(0, 0, width, height);\n    } else {\n      ctx.fillStyle = bgColour;\n      ctx.fillRect(0, 0, width, height);\n    }\n  });\n\n  return (x: number, y: number) => {\n    x = Bipolar.clamp(x);\n    y = Bipolar.clamp(y);\n\n    renderBackground(ctx, width, height);\n\n    // Labels\n    ctx.fillStyle = labelColour;\n    ctx.textBaseline = `top`;\n    ctx.save();\n    ctx.translate(midX, midY);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText((labels[ 1 ] + ` ` + valueFormat(y)).trim(), -midX + pad, 1);\n    ctx.restore();\n    ctx.fillText((labels[ 0 ] + ` ` + valueFormat(x)).trim(), pad, midX + 2);\n\n    if (!yAxisBottomNegative) y *= -1;\n\n    // Axes\n    ctx.strokeStyle = axisColour;\n    ctx.lineWidth = axisWidth;\n    ctx.beginPath();\n    ctx.moveTo(pad, midY);\n    ctx.lineTo(width - pad, midY);\n    ctx.moveTo(midX, pad);\n    ctx.lineTo(midX, height - pad);\n    ctx.stroke();\n    ctx.closePath();\n\n    const yy = (height - pad - pad) / 2 * -y;\n    const xx = (width - pad - pad) / 2 * x;\n    const dotPos = { x: xx, y: yy, radius: dotRadius };\n\n    if (lastValues) {\n      lastValues = lastValues.enqueue(dotPos);\n    }\n    ctx.save();\n    ctx.translate(midX, midY);\n\n    // Dot\n    if (showDot) {\n      if (lastValues) {\n        const opacityStep = 1 / lastValues.length;\n        let opacity = 1;\n        lastValues.forEach(d => {\n          const colour = Colour.multiplyOpacity(dotColour, opacity);\n          Drawing.circle(ctx, d, { fillStyle: colour });\n          opacity -= opacityStep;\n        });\n      } else {\n        Drawing.circle(ctx, dotPos, { fillStyle: dotColour });\n      }\n    }\n\n    // Whiskers\n    if (showWhiskers) {\n      ctx.strokeStyle = whiskerColour;\n\n      // y line\n      ctx.beginPath();\n      ctx.moveTo(0, yy - whiskerSize);\n      ctx.lineTo(0, yy + whiskerSize);\n\n      // x line\n      ctx.moveTo(xx - whiskerSize, 0);\n      ctx.lineTo(xx + whiskerSize, 0);\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    // Restore transform\n    ctx.restore();\n  }\n}\n","\nimport { scaler } from \"@ixfx/numbers\";\nimport type { GridStyle, LineStyle, ShowOptions, TextStyle } from \"./types.js\";\nimport type { Point } from \"@ixfx/geometry/point\";\n\nexport type PointMinMax = { min: Point, max: Point, width: number, height: number, minDim: number, maxDim: number };\n\nexport type PlotPoint = Point & {\n  fillStyle?: string\n  radius?: number\n}\n\nexport type CartesianScaler = (pt: Point) => Point;\n\nexport type CartesianDataRange = {\n  /**\n   * Converts a data value to relative value (0..1)\n   */\n  absDataToRelative: CartesianScaler\n  /**\n   * Converts a relative value to element-based coordinates\n   * (ie 0,0 is top-left of CANVAS)\n   */\n  relDataToCanvas: CartesianScaler\n  canvasToRelData: CartesianScaler\n  /**\n   * Converts canvas coordinate to relative\n   */\n  regionSpaceToRelative: CartesianScaler,\n  /**\n   * Converts relative coordinate to value\n   */\n  relDataToAbs: CartesianScaler\n  range: PointMinMax\n}\n\n\nexport type CartesianPlotOptions = {\n  clear: `region` | `canvas`\n  onInvalidated: () => void\n  /**\n * Margin around whole plot area. Use\n * to avoid dots being cut off by edge of canvas\n */\n  visualPadding: number\n  // canvasWidth: number\n  // canvasHeight: number\n  // canvasResize: ElementResizeLogic\n  // coordinateScale: ScaleBy\n  show: Partial<ShowOptions>\n  /**\n   * If 'auto' (default), range of plot is based on data.\n   * Otherwise specify the range, eg:\n   * `{ min: {x:-1,y:-1}, {x:1,y:1}}`\n   * \n   */\n  range: `auto` | { min: Point, max: Point }\n\n  /**\n   * Gridline setting\n   */\n  grid: Partial<GridStyle>\n  /**\n   * Drawing settings for axis (if 'showAxes' is enabled)\n   */\n  axisStyle: LineStyle\n  /**\n   * How values are drawn. Default: 'dot'\n   */\n  valueStyle: `dot` | ``,\n  /**\n   * How values are connected. Default: '' (no connecting)\n   * Values are connected in order of dataset.\n   */\n  connectStyle: `` | `line`,\n  textStyle: TextStyle\n  whiskerLength: number\n}\n\nexport const computeMinMax = (mm: Point[]): PointMinMax => {\n  const x = mm.map(m => m.x);\n  const y = mm.map(m => m.y);\n  const minX = Math.min(...x);\n  const maxX = Math.max(...x);\n  const minY = Math.min(...y);\n  const maxY = Math.max(...y);\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  return {\n    min: { x: minX, y: minY },\n    max: { x: maxX, y: maxY },\n    width, height,\n    minDim: Math.min(width, height),\n    maxDim: Math.max(width, height)\n  }\n}\n\nexport const relativeCompute = (minMax: PointMinMax) => {\n  if (!Number.isFinite(minMax.height)) {\n    return (point: Point) => point;\n  }\n  const xScale = scaler(minMax.min.x, minMax.max.x);\n  const yScale = scaler(minMax.min.y, minMax.max.y);\n  return (point: Point) => ({\n    x: xScale(point.x),\n    y: yScale(point.y)\n  });\n}\n\nexport const absoluteCompute = (minMax: PointMinMax) => {\n  const xScale = scaler(0, 1, minMax.min.x, minMax.max.x);\n  const yScale = scaler(0, 1, minMax.min.y, minMax.max.y);\n  return (point: Point) => ({\n    x: xScale(point.x),\n    y: yScale(point.y)\n  });\n}\n\nexport type AxisMark = Point & {\n  major: boolean\n}\nexport const computeAxisMark = (mm: PointMinMax, increments: number, major: number): { x: AxisMark[], y: AxisMark[] } => {\n  // Vertical\n  const xValues: AxisMark[] = [];\n  let count = 0;\n\n  for (let x = mm.min.x; x < mm.max.x; x += increments) {\n    const isMajor = count % major === 0;\n    xValues.push({ x, y: 0, major: isMajor });\n    count++;\n  }\n\n  // Horizontal\n  count = 0;\n  const yValues: AxisMark[] = [];\n  for (let y = mm.min.y; y < mm.max.y; y += increments) {\n    const isMajor = count % major === 0;\n    yValues.push({ x: 0, y, major: isMajor })\n    count++;\n  }\n  return { x: xValues, y: yValues }\n}","import { MapOfSimpleMutable } from \"@ixfx/collections\";\n\nexport class DataSet<TValue, TSeriesMeta> {\n  #data;\n  #meta;\n  lastChange;\n\n  constructor() {\n    this.lastChange = performance.now();\n    this.#data = new MapOfSimpleMutable<TValue>();\n\n    this.#meta = new Map<string, TSeriesMeta>();\n  }\n\n  get metaCount() {\n    return this.#meta.size;\n  }\n\n  clear() {\n    this.#data.clear();\n    this.lastChange = performance.now();\n  }\n\n  set(series: string, data: TValue[]) {\n    this.#data.setValues(series, data);\n  }\n\n  deleteBySeries(series: string) {\n    const changed = this.#data.delete(series);\n    if (changed) {\n      this.lastChange = performance.now();\n    }\n    return changed;\n  }\n\n  setMeta(series: string, meta: TSeriesMeta) {\n    this.#meta.set(series, meta);\n  }\n\n  hasMeta(series: string) {\n    return this.#meta.has(series);\n  }\n\n  getMeta(series: string) {\n    return this.#meta.get(series);\n  }\n\n  *getValues() {\n    yield* this.#data.valuesFlat();\n  }\n\n  *getEntries() {\n    yield* this.#data.entries();\n  }\n\n  *getSeries() {\n    yield* this.#data.values();\n  }\n\n  add(value: TValue, series = `default`) {\n    this.#data.addKeyedValues(series, value);\n    this.lastChange = performance.now();\n  }\n}","export const piPi = Math.PI*2;","import { scalerTwoWay, clamp } from \"@ixfx/numbers\";\nimport { resolveEl, resolveElementTry } from \"@ixfx/dom\";\nimport { resultErrorToString } from \"@ixfx/guards\";\nimport type { Rect, RectPositioned } from \"@ixfx/geometry/rect\";\nimport type { Point } from \"@ixfx/geometry/point\";\nimport { Points, Rects } from \"@ixfx/geometry\";\nimport type { CirclePositioned } from \"@ixfx/geometry/circle\";\nimport { piPi } from \"./pi-pi.js\";\n\nexport type CanvasRegionSpecRelativePositioned = {\n  relativePositioned: RectPositioned\n  scale?: `independent`\n}\n\nexport type CanvasRegionSpecAbsolutePositioned = {\n  absPositioned: RectPositioned\n}\n\nexport type CanvasRegionSpecRelativeSized = {\n  relativeSize: Rect\n  scale?: `independent`\n  /**\n   * Cardinal directions, or 'center' (default)\n   */\n  position: `center` | `n` | `s`\n}\n\nexport type CanvasRegionSpecMatched = {\n  match: HTMLElement | string\n}\n\nexport type CanvasRegionSpec = { marginPx?: number } & (CanvasRegionSpecAbsolutePositioned | CanvasRegionSpecRelativePositioned | CanvasRegionSpecRelativeSized | CanvasRegionSpecMatched);\n\nexport class CanvasSource {\n  #canvasEl: HTMLCanvasElement;\n  #ctx: undefined | CanvasRenderingContext2D;\n  #sizeBasis: `min` | `max`;\n  #sizeScaler;\n  #logicalSize: Rect;\n  #pixelScaling: number;\n\n  #regions: CanvasRegion[] = [];\n\n  constructor(canvasElementOrQuery: HTMLCanvasElement | string, sizeBasis: `min` | `max` = `min`) {\n    this.#canvasEl = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    this.#sizeBasis = sizeBasis;\n    this.#pixelScaling = window.devicePixelRatio || 1;\n    this.#sizeScaler = this.#createSizeScaler();\n    this.#logicalSize = this.setLogicalSize({ width: this.#canvasEl.width, height: this.#canvasEl.height });\n  }\n\n\n  setLogicalSize(size: Rect) {\n    this.#logicalSize = size;\n    const el = this.#canvasEl;\n    el.width = (size.width * this.#pixelScaling);\n    el.height = (size.height * this.#pixelScaling);\n\n    el.style.width = `${ (size.width).toString() }px`;\n    el.style.height = `${ (size.height).toString() }px`;\n    this.#sizeScaler = this.#createSizeScaler();\n    this.invalidateContext();\n    return size;\n  }\n\n  #createSizeScaler() {\n    let inMax = 1;\n    switch (this.#sizeBasis) {\n      case `min`:\n        inMax = Math.min(this.#canvasEl.width, this.#canvasEl.height);\n        break;\n      case `max`:\n        inMax = Math.max(this.#canvasEl.width, this.#canvasEl.height);\n        break;\n    }\n    const s = scalerTwoWay(0, inMax, 0, 1);\n    return {\n      abs: s.in,\n      rel: s.out\n    }\n  }\n\n  invalidateContext() {\n    this.#ctx = undefined;\n  }\n\n  #add(region: CanvasRegion) {\n    if (!region) throw new Error(`Param 'region' is undefined/null`);\n    if (this.#regions.includes(region)) throw new Error(`Region already exists`);\n    this.#regions.push(region);\n    return region;\n  }\n\n\n  toAbsPoint(pt: Point, kind: `independent` = `independent`) {\n    let { x, y } = pt;\n    switch (kind) {\n      case `independent`:\n        x *= this.width;\n        y *= this.height;\n\n    }\n    return { x, y };\n  }\n\n  get offset() {\n    const b = this.#canvasEl.getBoundingClientRect();\n    return { x: b.left, y: b.top };\n  }\n\n  toRelPoint(pt: Point, source: `screen` | `source`, kind: `independent` | `skip` = `independent`, clamped = true) {\n    let { x, y } = pt;\n    if (source === `screen`) {\n      const b = this.#canvasEl.getBoundingClientRect();\n      x -= b.x;\n      y -= b.y;\n    }\n    switch (kind) {\n      case `independent`:\n        x /= this.width;\n        y /= this.height;\n        break;\n      case `skip`:\n        break;\n    }\n    if (clamped) {\n      x = clamp(x);\n      y = clamp(y);\n    }\n    return { x, y };\n  }\n\n  toAbsRect(rect: Rect | RectPositioned, kind: `independent` = `independent`) {\n    let { width, height } = rect;\n    switch (kind) {\n      case `independent`:\n        width *= this.width;\n        height *= this.height;\n        if (Rects.isRectPositioned(rect)) {\n          return {\n            ...this.toAbsPoint(rect),\n            width,\n            height\n          }\n        }\n    }\n    return { width, height }\n  }\n\n\n  /**\n   * Creates a region\n   * \n   * Absolute positioned. Uses source coordinates which don't change\n   * ```js\n   * source.createRegion({ \n   *  absPositioned: { x: 0, y: 0, width: 100, height: 100} \n   * });\n   * ```\n   * \n   * Relative positioned. Uses coordiantes relative to source dimensions.\n   * Updated if source changes.\n   * ```js\n   * source.createRegion({\n   *  relativePositioned: { x: 0, y:0, width: 1, height: 0.5 },\n   *  scale: `independent`\n   * });\n   * ```\n   * \n   * Relative sized. Uses size relative to source dimension. By default centers.\n   * ```js\n   * source.createRegion({\n   *  relativeSize: { width: 0.5, height: 0.5 }\n   *  position: `center`\n   * })\n   * ```\n   * @param spec \n   * @returns \n   */\n  createRegion(spec: CanvasRegionSpec) {\n    const marginPx = spec.marginPx ?? 0;\n    const marginPx2 = marginPx * 2;\n    if (`absPositioned` in spec) {\n      const rect = Rects.subtractSize(spec.absPositioned, marginPx, marginPx);\n      return this.#add(new CanvasRegion(this, () => rect))\n    }\n\n    if (`relativePositioned` in spec) {\n      let compute: ((source: CanvasSource) => RectPositioned);\n      const rect = spec.relativePositioned;\n      switch (spec.scale) {\n        case `independent`:\n          compute = (source: CanvasSource): RectPositioned => ({\n            x: (rect.x * source.width) + marginPx,\n            y: (rect.y * source.height) + marginPx,\n            width: (rect.width * source.width) - marginPx2,\n            height: (rect.height * source.height) - marginPx2\n          });\n          break;\n        default:\n          throw new Error(`Param 'kind' unknown (${ spec.scale })`);\n      }\n      return this.#add(new CanvasRegion(this, compute));\n    }\n\n    if (`relativeSize` in spec) {\n      let compute: ((source: CanvasSource) => RectPositioned);\n      const rect = spec.relativeSize;\n      const position = spec.position;\n\n      switch (spec.scale) {\n        case `independent`:\n          compute = (source: CanvasSource): RectPositioned => {\n            const width = (rect.width * source.width) - marginPx2;\n            const height = (rect.height * source.height) - marginPx2;\n            let x = source.width / 2 - width / 2;\n            let y = source.height / 2 - height / 2;\n            switch (position) {\n              case `n`:\n                y = 0;\n                break;\n              case `s`:\n                y = source.height - height;\n                break;\n              default:\n              /** no-op, */\n            }\n            x += marginPx;\n            y += marginPx;\n            return { width, height, x, y }\n          }\n          break;\n        default:\n          throw new Error(`Param 'kind' unknown (${ spec.scale })`);\n      }\n      return this.#add(new CanvasRegion(this, compute));\n    }\n\n    if (`match` in spec) {\n      const result = resolveElementTry(spec.match);\n      if (!result.success) {\n        throw new Error(`Could not resolve match element. ${ resultErrorToString(result) }`);\n      }\n      const compute = (_source: CanvasSource): RectPositioned => {\n        const bounds = result.value.getBoundingClientRect();\n        return {\n          x: bounds.x + marginPx,\n          y: bounds.y + marginPx,\n          width: bounds.width - marginPx2,\n          height: bounds.height - marginPx2\n        }\n      }\n      return this.#add(new CanvasRegion(this, compute));\n    }\n    throw new Error(`Spec doesn't seem valid`);\n  }\n\n  clear() {\n    const c = this.context;\n    c.clearRect(0, 0, this.width, this.height);\n  }\n\n  get context() {\n    if (this.#ctx) return this.#ctx;\n    const c = this.#canvasEl.getContext(`2d`);\n    if (!c) throw new Error(`Could not create 2d context`);\n    c.setTransform(1, 0, 0, 1, 0, 0);\n    c.scale(this.#pixelScaling, this.#pixelScaling);\n\n    this.#ctx = c;\n\n    for (const r of this.#regions) {\n      r.recomputeRegion();\n    }\n    return this.#ctx;\n  }\n\n  get sizeScaler() {\n    return this.#sizeScaler;\n  }\n\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  get height() {\n    return this.#logicalSize.height;\n  }\n}\n\n/**\n * Draws on a canvas, constrained to a specific region\n */\nexport class CanvasRegion {\n  source: CanvasSource;\n  #regionCompute: (parent: CanvasSource) => RectPositioned;\n  #r: RectPositioned;\n\n  /**\n   * Creates, using coordinate in canvas coordinates\n   */\n  constructor(source: CanvasSource, regionCompute: (parent: CanvasSource) => RectPositioned) {\n    this.source = source;\n    this.#regionCompute = regionCompute;\n    this.#r = regionCompute(source);\n  }\n\n  /**\n   * Calls the original `regionCompute` function passed in to the constructor\n   * to recompute the absolute region\n   */\n  recomputeRegion() {\n    this.#r = this.#regionCompute(this.source);\n  }\n\n  /**\n   * Converts a region-relative point (0..1) to an absolute\n   * point, which uses region-relative coordinates.\n   * \n   * Eg if the region had an x,y of 100,100, `toAbsRegion({x:0,y:0})`\n   * will return 0,0.\n   *\n   * @param regionRel \n   * @param scaleBy \n   * @returns \n   */\n  toAbsRegion(regionRel: Point, scaleBy: `both` = `both`) {\n    switch (scaleBy) {\n      case `both`:\n        return {\n          x: regionRel.x * this.#r.width,\n          y: regionRel.y * this.#r.height\n        }\n        break;\n    }\n  }\n\n  /**\n   * Returns a copy of `p` offset by the region's x & y\n   * @param p \n   * @returns \n   */\n  applyRegionOffset(p: Point) {\n    return {\n      x: p.x + this.#r.x,\n      y: p.y + this.#r.y\n    }\n  }\n\n  /**\n   * Draws a line from a series of points.\n   * Assumes region-relative, % coordinates (ie 0..1 scale)\n   * @param relativePoints Points to connect, in region-relative coordinates\n   * @param strokeStyle Stroke style\n   * @param lineWidth Line with\n   */\n  drawConnectedPointsRelative(relativePoints: Point[], strokeStyle: string, lineWidth = 1) {\n    const points = relativePoints.map(p => this.toAbsRegion(p));\n    this.drawConnectedPoints(points, strokeStyle, lineWidth);\n  }\n\n  /**\n   * Draws connected points in absolute coordinates,\n   * however with 0,0 being the top-left of the region.\n   * \n   * Thus, this will apply the region offset before drawing.\n   * @param points Points to draw\n   * @param strokeStyle Stroke style\n   * @param lineWidth Line width\n   */\n  drawConnectedPoints(points: Point[], strokeStyle: string, lineWidth = 1) {\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    c.beginPath();\n    c.strokeStyle = strokeStyle;\n    c.lineWidth = lineWidth;\n    for (let index = 0; index < points.length; index++) {\n      if (index === 0) {\n        c.moveTo(points[ index ].x, points[ index ].y);\n      } else {\n        c.lineTo(points[ index ].x, points[ index ].y);\n      }\n    }\n    c.stroke();\n    c.restore();\n  }\n\n  /**\n   * Fills text at a relative position\n   * @param text \n   * @param relPos Relative, meaning 0.5,0.5 is the middle of the region\n   * @param fillStyle \n   * @param baseline \n   * @param align \n   */\n  fillTextRelative(text: string, relPos: Point, fillStyle = `black`, font: string, baseline: CanvasTextBaseline = `alphabetic`, align: CanvasTextAlign = `start`) {\n    const point = this.toAbsRegion(relPos);\n    this.fillTextRelative(text, point, fillStyle, font, baseline, align);\n  }\n\n  /**\n   * Fills text at a region-relative position\n   * @param text \n   * @param point Region relative, meaning 0,0 is top-left of region\n   * @param fillStyle \n   * @param baseline \n   * @param align \n   */\n  fillText(text: string, point: Point, fillStyle = `black`, font: string, baseline: CanvasTextBaseline = `alphabetic`, align: CanvasTextAlign = `start`) {\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    if (font.length > 0) {\n      c.font = font;\n    }\n    c.textBaseline = baseline;\n    c.textAlign = align;\n    c.fillStyle = fillStyle;\n    c.fillText(text, point.x, point.y);\n    c.restore();\n  }\n\n  drawCircles(relativeCircles: CirclePositioned[], fillStyle: string, strokeStyle = ``, lineWidth = 1) {\n    const circles = relativeCircles.map(c => {\n      return {\n        ...this.toAbsRegion(c),\n        radius: this.source.sizeScaler.abs(c.radius)\n      }\n    });\n\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    c.fillStyle = fillStyle;\n    c.strokeStyle = strokeStyle;\n    c.lineWidth = lineWidth;\n\n    for (const circle of circles) {\n      c.beginPath();\n      c.arc(circle.x, circle.y, circle.radius, 0, piPi);\n      c.closePath();\n      if (fillStyle.length > 0) {\n        c.fill();\n      }\n      if (strokeStyle.length > 0) {\n        c.stroke();\n      }\n    }\n    c.restore();\n  }\n\n  clear() {\n    const c = this.context;\n    c.clearRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);\n  }\n\n  fill(fillStyle = `white`) {\n    const c = this.context;\n    c.fillStyle = fillStyle;\n    c.fillRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);\n  }\n\n  drawBounds(strokeStyle: string, lineWidth = 1) {\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 0 },\n      { x: 1, y: 0 },\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: 0, y: 0 }\n    ], strokeStyle, lineWidth);\n\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 1 },\n      { x: 1, y: 0 }\n    ], strokeStyle, lineWidth);\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 0 },\n      { x: 1, y: 1 }\n    ], strokeStyle, lineWidth);\n  }\n\n  /**\n   * Converts a  point to a region-relative one.\n   * @param pt \n   * @param kind \n   * @returns \n   */\n  toRelPoint(pt: Point, source: `screen` | `source` = `screen`, kind: `independent` = `independent`, clamped = true) {\n    pt = this.source.toRelPoint(pt, source, `skip`, false);\n    let { x, y } = pt;\n    x -= this.x;\n    y -= this.y;\n\n    switch (kind) {\n      case `independent`:\n        x /= this.width;\n        y /= this.height;\n    }\n    if (clamped) {\n      x = clamp(x);\n      y = clamp(y);\n    }\n    return { x, y };\n  }\n\n  absToRegionPoint(pt: Point, source: `screen`, clamped: boolean) {\n    if (source === `screen`) {\n      pt = Points.subtract(pt, this.source.offset);\n    }\n\n    let { x, y } = pt;\n    x -= this.x;\n    y -= this.y;\n\n    if (clamped) {\n      if (x < 0) x = 0;\n      if (y < 0) y = 0;\n      if (x > this.width + this.x) x = this.x + this.width;\n      if (y > this.height + this.y) y = this.y + this.height;\n    }\n    return { x, y };\n  }\n\n  get center() {\n    return Rects.center(this.#r);\n  }\n\n  get context() {\n    return this.source.context;\n  }\n\n  set region(value: RectPositioned) {\n    this.#r = value;\n  }\n\n  get region() {\n    return this.#r;\n  }\n\n  get width() {\n    return this.#r.width;\n  }\n\n  get height() {\n    return this.#r.height;\n  }\n\n  get x() {\n    return this.#r.x;\n  }\n\n  get y() {\n    return this.#r.y;\n  }\n\n  get dimensionMin() {\n    return Math.min(this.#r.width, this.#r.height);\n  }\n}\n","\nimport { DataSet } from \"./DataSet.js\";\nimport * as Cart from './cartesian.js';\nimport { round } from \"@ixfx/numbers\";\nimport type { GridStyle, LineStyle, SeriesMeta, ShowOptions, TextStyle } from \"./types.js\";\nimport type { RecursivePartial } from \"@ixfx/core\";\nimport type { CanvasRegion, CanvasRegionSpec } from \"../canvas-region.js\";\nimport { CanvasSource } from \"../canvas-region.js\";\nimport { resolveEl } from \"@ixfx/dom\";\nimport { ElementSizer } from \"@ixfx/dom\";\nimport type { RectPositioned } from \"@ixfx/geometry/rect\";\nimport { Points, Rects } from \"@ixfx/geometry\";\nimport type { Line } from \"@ixfx/geometry/line\";\nimport type { Point } from \"@ixfx/geometry/point\";\nimport { goldenAngleColour } from \"../colour/generate.js\";\nimport { toCssColour as ColourToString } from \"../colour/conversion.js\";\nexport type InsertOptions = {\n  region?: CanvasRegionSpec\n  /**\n   * Parent to insert CANVAS element into.\n   * If undefined, it will be added to the body.\n   */\n  parent?: HTMLElement | string\n  /**\n   * How canvas should be sized\n   */\n  canvasResizeTo: `parent` | `viewport`\n};\n\n\nexport const insert = (insertOptions: InsertOptions, options: RecursivePartial<Cart.CartesianPlotOptions> = {}) => {\n\n  const parentEl = (insertOptions.parent === undefined) ? document.body : resolveEl(insertOptions.parent);\n  const canvasEl = document.createElement(`canvas`);\n  parentEl.prepend(canvasEl);\n\n  const ds = new DataSet<Cart.PlotPoint, SeriesMeta>();\n\n  const source = new CanvasSource(canvasEl, `min`);\n  const spec = insertOptions.region ?? ({ relativePositioned: { x: 0, y: 0, width: 1, height: 1 } });\n  const region = source.createRegion(spec);\n  const p = new CartesianCanvasPlot(region, ds, options);\n\n  if (insertOptions.canvasResizeTo === `viewport`) {\n    ElementSizer.canvasViewport(canvasEl, {\n      onSizeChanging: (size, _el) => {\n        source.setLogicalSize(size);\n        p.invalidateRange();\n        p.draw();\n      }\n    });\n  } else {\n    // Parent\n    ElementSizer.canvasParent(canvasEl, {\n      onSizeChanging: (size, _el) => {\n        source.setLogicalSize(size);\n        p.invalidateRange();\n        p.draw();\n      }\n    });\n  }\n  return p;\n}\n\n\n/**\n * Simple plotting of cartesian values.\n * \n * Create a plot that fills screen\n * ```js\n * const p = Plot.insert({fill`viewport});\n * const dataSet = p.dataSet;\n * \n * // Add data\n * ds.add({ x: 1, y: 2 });\n * \n * // Draw\n * p.draw();\n * ```\n *\n * Create a plot that fills a container\n * ```js\n * const p = Plot.insert({parent:`#someel`});\n * ```\n * \n * Add data using the created data set\n * ```js\n * \n * // Add a value to the `alpha` series\n * p.dataSet.add({x:1,y:1}, `alpha`);\n * ```\n * \n * Set default series formatting\n * ```js\n * p.setMeta(`default`, {\n *  colour: `hsl(50,100%,50%)`,\n *  lineWidth: 10\n * });\n * ```\n * \n * Series can have metadata associated with it in the DataSet\n * ```js\n * // Use 'pink' by default for the series 'alpha'\n * p.setMeta(`alpha`, { colour: `pink` });\n * ``\n * \n */\nexport class CartesianCanvasPlot {\n  #data;\n  #lastDataChange;\n  #canvasRegion: CanvasRegion;\n\n  actualDataRange: RectPositioned = Rects.EmptyPositioned;\n  visibleRange: RectPositioned = Rects.PlaceholderPositioned;\n  show: ShowOptions;\n  whiskerLength: number;\n  axisRounder = round(1, true);\n  onInvalidated: undefined | (() => void);\n\n  /**\n   * List of lines to draw after drawing everything else.\n   * Lines are given in value-coordinate space\n   */\n  overlayLines: (Line & LineStyle)[] = [];\n  #grid: GridStyle\n  #rangeMode;\n\n  #currentRange?: Cart.CartesianDataRange;\n\n  #axisStyle: LineStyle;\n  #valueStyle;\n  #connectStyle;\n  #rangeManual: Cart.PointMinMax | undefined;\n  #textStyle: TextStyle;\n  #visualPadding: number;\n  #visualClear: `region` | `canvas`;\n\n  constructor(cr: CanvasRegion, data: DataSet<Cart.PlotPoint, SeriesMeta>, options: RecursivePartial<Cart.CartesianPlotOptions> = {}) {\n    if (!data) throw new TypeError(`Param 'data' is undefined`);\n    if (typeof data !== `object`) throw new TypeError(`Param 'data' is not an object. Got: ${ typeof data }`);\n    this.onInvalidated = options.onInvalidated as undefined | (() => void);\n    this.#data = data;\n    this.#canvasRegion = cr;\n    this.#lastDataChange = 0;\n    this.#visualClear = options.clear ?? `region`;\n    this.#rangeMode = options.range ?? `auto`;\n    this.#valueStyle = options.valueStyle ?? `dot`;\n    this.#connectStyle = options.connectStyle ?? ``;\n    this.whiskerLength = options.whiskerLength ?? 5;\n    this.#visualPadding = options.visualPadding ?? 20;\n    this.show = {\n      axes: true,\n      axisValues: true,\n      grid: true,\n      whiskers: true,\n      ...options.show\n    };\n\n    this.#axisStyle = {\n      colour: `black`,\n      width: 2,\n      ...options.axisStyle\n    };\n    this.#textStyle = {\n      colour: `black`,\n      size: `1em`,\n      font: `system-ui`,\n      ...options.textStyle\n    };\n\n    this.#grid = {\n      increments: 0.1,\n      major: 5,\n      colour: `whitesmoke`,\n      width: 1,\n      ...options.grid\n    }\n  }\n\n  getCurrentRange() {\n    if (this.#data.lastChange === this.#lastDataChange && this.#currentRange) return this.#currentRange;\n    this.#lastDataChange = this.#data.lastChange;\n    const r = this.#createRange();\n    this.#currentRange = r;\n    if (this.onInvalidated) this.onInvalidated();\n    return r;\n  }\n\n  invalidateRange() {\n    this.#currentRange = undefined;\n  }\n\n  #createRange(): Cart.CartesianDataRange {\n    // Compute scale of data\n    const range = this.getDataRange(); // actual data range, or user-provided\n\n    const absDataToRelative = Cart.relativeCompute(range);\n    const relDataToAbs = Cart.absoluteCompute(range);\n    const cr = this.#canvasRegion;\n    const padding = this.#visualPadding;\n\n    // Offsets are in canvas coordinates, not region\n    // eg 0,0 is top-left corner of canvas\n    let xOffset = cr.x + padding;\n    let yOffset = cr.y + padding;\n\n    const allowedHeight = cr.height - (padding * 2);\n    const allowedWidth = cr.width - (padding * 2);\n    const dimensionMin = Math.min(allowedHeight, allowedWidth);;\n\n    if (allowedWidth >= allowedHeight) {\n      // Landscape\n      xOffset += (allowedWidth / 2) - (dimensionMin / 2);\n    } else {\n      // Portrait\n      yOffset += (allowedHeight / 2) - (dimensionMin / 2);\n    }\n\n    const relDataToCanvas = (pt: Point) => {\n      let { x, y } = pt;\n      if (x === Number.NEGATIVE_INFINITY) x = 0;\n      else if (x === Number.POSITIVE_INFINITY) x = 1;\n      if (y === Number.NEGATIVE_INFINITY) y = 0;\n      else if (y === Number.POSITIVE_INFINITY) y = 1;\n      x = x * dimensionMin;\n      y = (1 - y) * dimensionMin;\n\n      x += xOffset;\n      y += yOffset;\n\n      return { x, y }\n    };\n\n    const canvasToRelData = (pt: Point) => {\n      let { x, y } = pt;\n      x -= xOffset;\n      y -= yOffset;\n      x = x / dimensionMin;\n      y = 1 - (y / dimensionMin);\n      return { x, y }\n    };\n\n    // Convert region-space to plot area relative\n    const regionSpaceToRelative = (pt: Point) => {\n      let { x, y } = pt;\n      x = x - cr.x + this.#visualPadding;\n      y = (dimensionMin + this.#visualPadding) - y;\n      x /= dimensionMin;\n      y = (y / dimensionMin);\n      return { x, y }\n    }\n\n    return {\n      absDataToRelative, relDataToCanvas, canvasToRelData, regionSpaceToRelative, relDataToAbs, range\n    }\n  }\n\n\n  /**\n   * Positions an element at the viewport location of `data` point.\n   * Ensure the element has `position:absolute` set.\n   * @param data \n   * @param elementToPosition \n   * @param by \n   */\n  positionElementAt(data: Point, elementToPosition: HTMLElement | string, by: `middle` | `top-left` = `middle`, relativeToQuery?: HTMLElement | string) {\n    const el = resolveEl(elementToPosition);\n    let { x, y } = this.valueToScreenSpace(data);\n    // x -= this.canvasSource.offset.x;\n    // y -= this.canvasSource.offset.y;\n    if (by === `middle`) {\n      const bounds = el.getBoundingClientRect();\n      x -= bounds.width / 2;\n      y -= bounds.height / 2;\n    } else if (by === `top-left`) {\n      // no-op\n    } else throw new Error(`Param 'by' expected to be 'middle' or 'top-left'.`);\n    if (relativeToQuery) {\n      const relativeTo = resolveEl(relativeToQuery);\n      const bounds = relativeTo.getBoundingClientRect();\n\n      //console.log(`Plot relativeTo: ${ relativeTo.scrollTop } y:  ${ bounds.y }`);\n      x -= bounds.x;\n      y -= bounds.y;\n    }\n    el.style.left = `${ x }px`;\n    el.style.top = `${ y }px`;\n  }\n\n  /**\n   * When range is auto, returns the range of the data\n   * Otherwise returns the user-provided range.\n   * @returns \n   */\n  getDataRange(): Cart.PointMinMax {\n    if (this.#rangeMode === `auto`) {\n      return Cart.computeMinMax([ ...this.#data.getValues() ]);\n    } else {\n      if (!this.#rangeManual) {\n        this.#rangeManual = Cart.computeMinMax([ this.#rangeMode.max, this.#rangeMode.min ]);\n      }\n      return this.#rangeManual;\n    }\n  }\n\n  valueToScreenSpace(dataPoint: Point) {\n    const region = this.valueToRegionSpace(dataPoint);\n    const offset = this.canvasSource.offset;\n    const scr = {\n      x: region.x + offset.x,\n      y: region.y + offset.y\n    }\n    return scr;\n  }\n\n  valueToRegionSpace(dataValue: Point, debug = false) {\n    const ds = this.getCurrentRange();\n\n    // Scale absolute value relative to total dimensions of data\n    const rel = ds.absDataToRelative(dataValue);\n\n    // Scale relative data value to canvas space\n    const region = ds.relDataToCanvas(rel);\n\n    if (debug) console.log(`orig: ${ dataValue.x }x${ dataValue.y } rel: ${ rel.x }x${ rel.y } region: ${ region.x }x${ region.y }`);\n    return {\n      ...dataValue,\n      x: region.x,\n      y: region.y\n    }\n  }\n\n  // #regionSpaceToValue(scr: Point, clamped: boolean) {\n  //   const ds = this.getCurrentRange();\n\n  //   const rel = ds.regionSpaceToRelative(scr);\n  //   //console.log(`regionSpaceToRelative ${ rel.x.toFixed(2) },${ rel.y.toFixed(2) }`);\n\n  //   const value = ds.relDataToAbs(rel);\n  //   //if (debug) console.log(`orig: ${ a.x }x${ a.y } rel: ${ rel.x }x${ rel.y } scr: ${ scr.x }x${ scr.y }`);\n\n  //   const pt = {\n  //     ...scr,\n  //     x: value.x,\n  //     y: value.y\n  //   }\n  //   if (clamped) return clamp(pt);\n  //   return pt;\n  // }\n\n  /**\n   * Converts a point in pixel coordinates to a value.\n   * Useful for converting from user input coordinates.\n   * @param point \n   * @returns \n   */\n  pointToValue(point: Point, _source: `screen`) {\n    const ds = this.getCurrentRange();\n\n    // Apply offset\n    const canvasPoint = Points.subtract(point, this.canvasSource.offset);\n\n    const v = ds.canvasToRelData(canvasPoint);\n    return ds.relDataToAbs(v);\n  }\n\n  // valueToScreen(a: Point) {\n  //   const ds = this.getCurrentRange();\n  //   const rel = ds.valueToRelative(a);\n  //   const scr = ds.relativeToElementSpace(rel);\n  //   const bounds = this.helper.el.getBoundingClientRect();\n  //   return {\n  //     x: scr.x + bounds.x,\n  //     y: scr.y + bounds.y\n  //   }\n  // }\n\n  // valueRectToScreen(a: Point, b: Point): RectPositioned {\n  //   a = this.valueToScreen(a);\n  //   b = this.valueToScreen(b);\n  //   return {\n  //     x: a.x,\n  //     y: b.y,\n  //     width: b.x - a.x,\n  //     height: a.y - b.y\n  //   }\n  // }\n\n  /**\n   * Compute canvas-relative coordinates based on two points in value space\n   * @param valueA \n   * @param valueB \n   */\n  #valueLineToCanvasSpace(valueA: Point, valueB: Point, debug = false): Line {\n    valueA = this.valueToRegionSpace(valueA, debug) as Point;\n    valueB = this.valueToRegionSpace(valueB, debug) as Point;\n    return { a: valueA, b: valueB };\n  }\n\n  getDefaultMeta(): SeriesMeta {\n    return {\n      colour: goldenAngleColour(this.#data.metaCount),\n      lineWidth: 2,\n      dotRadius: 5\n    }\n  }\n\n  draw() {\n    if (this.#visualClear === `region`) {\n      this.#canvasRegion.clear();\n    } else {\n      this.canvasSource.clear();\n    }\n\n    //const ctx = this.helper.ctx;\n    //this.helper.drawBounds(`whitesmoke`);\n    //Drawing.rect(ctx, this.renderArea, { strokeStyle: `whitesmoke` });\n\n    this.#useGrid();\n    if (this.show.axes) this.#drawAxes();\n\n    //let seriesCount = 0;\n    for (const [ k, v ] of this.#data.getEntries()) {\n      let meta = this.#data.getMeta(k);\n      if (!meta) {\n        meta = this.getDefaultMeta();\n        this.#data.setMeta(k, meta);\n      }\n      this.#drawSeries(k, v, meta);\n      //seriesCount++;\n    }\n    //console.log(`series count: ${ seriesCount }`);\n    for (const line of this.overlayLines) {\n      this.drawLine(line, line.colour, line.width);\n    }\n  }\n\n  /**\n   * Draws a line in value-coordinate space\n   * @param line \n   * @param colour \n   * @param width \n   */\n  drawLine(line: Line, colour: string, width: number) {\n    const l = this.#valueLineToCanvasSpace(line.a, line.b);\n    this.#drawLineCanvasSpace(l, colour, width);\n  }\n\n  setMeta(series: string, meta: Partial<SeriesMeta>) {\n    this.#data.setMeta(series, {\n      ...this.getDefaultMeta(),\n      ...meta\n    })\n  }\n\n  #drawAxes() {\n    const { colour, width } = this.#axisStyle;\n    // Axis coordinates in canvas-space\n    const yAxis = this.#valueLineToCanvasSpace({ x: 0, y: Number.NEGATIVE_INFINITY }, { x: 0, y: Number.POSITIVE_INFINITY }, false);\n    const xAxis = this.#valueLineToCanvasSpace({ x: Number.NEGATIVE_INFINITY, y: 0 }, { x: Number.POSITIVE_INFINITY, y: 0 }, false);\n\n    //console.log(`x axis: ${ xAxis.a.x }-${ xAxis.b.x }`);\n    this.#drawLineCanvasSpace(xAxis, colour, width, false);\n    this.#drawLineCanvasSpace(yAxis, colour, width, false);\n  }\n\n\n  #drawYAxisValues(yPoints: Point[]) {\n    //const { ctx } = this.helper;\n    const ctx = this.#canvasRegion.context;\n\n    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;\n    ctx.fillStyle = this.#textStyle.colour;\n    ctx.textBaseline = `middle`;\n\n\n    for (const p of yPoints) {\n      if (p.x === 0 && p.y === 0) continue;\n      const reg = this.valueToRegionSpace(p, false);\n      const value = this.axisRounder(p.y);\n      const label = value.toString();\n      const measure = ctx.measureText(label);\n      const x = reg.x - measure.width - (this.whiskerLength / 2) - 5;\n      const y = reg.y;\n      ctx.fillText(label, x, y);\n    }\n  }\n\n  #drawXAxisValues(xPoints: Point[]) {\n    //const { ctx } = this.helper;\n    const ctx = this.#canvasRegion.context;\n    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;\n    ctx.fillStyle = this.#textStyle.colour;\n    ctx.textBaseline = `top`;\n    for (const p of xPoints) {\n      const reg = this.valueToRegionSpace(p, false);\n      const value = this.axisRounder(p.x);\n      const label = value.toString();\n      const measure = ctx.measureText(label);\n      const x = reg.x - measure.width / 2;\n      const y = reg.y + measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent + (this.whiskerLength / 2);\n      ctx.fillText(label, x, y);\n    }\n  }\n\n  #drawWhisker(p: Cart.AxisMark, vertical: boolean) {\n    const whiskerHalfLength = this.whiskerLength / 2;\n    const v = vertical ? { x: p.x, y: 0 } : { y: p.y, x: 0 }\n    const reg = this.valueToRegionSpace(v, false);\n\n    const line = vertical ? {\n      a: { x: reg.x, y: reg.y - whiskerHalfLength },\n      b: { x: reg.x, y: reg.y + whiskerHalfLength },\n    } :\n      {\n        a: { y: reg.y, x: reg.x - whiskerHalfLength },\n        b: { y: reg.y, x: reg.x + whiskerHalfLength },\n      }\n    this.#drawLineCanvasSpace(line, this.#axisStyle.colour, this.#axisStyle.width, false);\n  }\n\n  #drawGridline(p: Cart.AxisMark, vertical: boolean) {\n    const line = vertical ?\n      this.#valueLineToCanvasSpace({ x: p.x, y: Number.NEGATIVE_INFINITY }, { x: p.x, y: Number.POSITIVE_INFINITY }) :\n      this.#valueLineToCanvasSpace({ y: p.y, x: Number.NEGATIVE_INFINITY }, { y: p.y, x: Number.POSITIVE_INFINITY }, false);\n    this.#drawLineCanvasSpace(line, this.#grid.colour, p.major ? this.#grid.width * 2 : this.#grid.width);\n  }\n\n  #useGrid() {\n    const g = this.#grid;\n    const showGrid = this.show.grid;\n    const showWhiskers = this.show.whiskers;\n    const showValues = this.show.axisValues;\n    const mm = this.getCurrentRange().range; // actual data range, or user-provided\n    const { increments, major } = g;\n\n    // Vertical lines\n    const axisMarks = Cart.computeAxisMark(mm, increments, major);\n    for (const p of axisMarks.x) {\n      if (showGrid) this.#drawGridline(p, true);\n      if (showWhiskers && p.major) this.#drawWhisker(p, true);\n    }\n\n    // Horizontal lines\n    for (const p of axisMarks.y) {\n      if (showGrid) this.#drawGridline(p, false);\n      if (showWhiskers && p.major) this.#drawWhisker(p, false);\n    }\n\n    if (showValues) {\n      this.#drawXAxisValues(axisMarks.x.filter(p => p.major));\n      this.#drawYAxisValues(axisMarks.y.filter(p => p.major));\n    }\n  }\n\n  #drawSeries(name: string, series: Cart.PlotPoint[], meta: SeriesMeta) {\n    if (this.#connectStyle === `line`) {\n      this.#drawConnected(series, meta.colour, meta.lineWidth);\n    }\n\n    //let valueCount = 0;\n    if (this.#valueStyle === `dot`) {\n      for (const v of series) {\n        this.#drawDot(v, meta.colour, meta.dotRadius);\n        //valueCount++;\n      }\n    }\n    //console.log(`valueCount: ${ valueCount }`);\n  }\n\n  #drawConnected(dots: Cart.PlotPoint[], colour: string, width: number) {\n    const ctx = this.#canvasRegion.context;\n    ctx.beginPath();\n    for (const [ index, dot_ ] of dots.entries()) {\n      const dot = this.valueToRegionSpace(dot_, false);\n      if (index === 0) ctx.moveTo(dot.x, dot.y);\n      ctx.lineTo(dot.x, dot.y);\n    }\n    ctx.strokeStyle = ColourToString(colour);\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  #drawDot(originalDot: Cart.PlotPoint, fallbackColour: string, fallbackRadius: number) {\n    const colour = ColourToString(originalDot.fillStyle ?? fallbackColour);\n    const pos = this.valueToRegionSpace(originalDot);\n    const radius = originalDot.radius ?? fallbackRadius;\n    this.#canvasRegion.drawCircles([\n      { ...pos, radius }\n    ], colour);\n\n    // const ctx = this.helper.ctx;\n    // const dot = this.#valueToElementSpace(originalDot, false);\n    // const radius = originalDot.radius ?? fallbackRadius;\n    // //console.log(`dot ${ dot.x }x${ dot.y } (from ${ originalDot.x }x${ originalDot.y })`);\n    // ctx.fillStyle = Colour.resolveToString(originalDot.fillStyle ?? fallbackColour);\n    // ctx.beginPath();\n    // ctx.arc(dot.x, dot.y, radius, 0, Math.PI * 2);\n    // ctx.fill();\n    // ctx.closePath();\n  }\n\n\n  #drawLineCanvasSpace(line: Line, colour: string, width: number, debug = false) {\n    if (debug) console.log(line);\n    const ctx = this.#canvasRegion.context;\n\n    colour = ColourToString(colour);\n    //this.#canvasRegion.drawConnectedPoints([ line.a, line.b ], colour, width);\n    ctx.beginPath();\n    ctx.moveTo(line.a.x, line.a.y);\n    ctx.lineTo(line.b.x, line.b.y);\n    ctx.strokeStyle = ColourToString(colour);\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  get dataSet() {\n    return this.#data;\n  }\n\n  get canvasRegion() {\n    return this.#canvasRegion;\n  }\n\n  get canvasSource() {\n    return this.#canvasRegion.source;\n  }\n}","export * as BipolarView from './bipolar-view.js'\nexport * from './cartesian.js';\nexport * from './cartesian-canvas-plot.js';\nexport * from './DataSet.js';\nexport type * from './types.js';","export * from './canvas-helper.js';\nexport * from './pointer-visualise.js';\nexport * as Svg from './svg/index.js';\nexport type * from './types.js';\n\nimport * as NamedColourPalette from './named-colour-palette.js';\n\n\nimport * as Colour from './colour/index.js';\n\nexport * as Colour from './colour/index.js';\n\nimport * as Video from './video.js';\n\nexport * as Drawing from './drawing.js';\n\n/**\n * Wraps [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData) as an ixfx {@link @ixfx/geometry.Grid} type.\n * This is useful because it's otherwise a one-dimensional array listing each rgba in turn.\n */\nexport * as ImageDataGrid from './image-data-grid.js';\n\nexport * as Plot from './plot/index.js';\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from '@ixfx/visual.js'\n * ```\n */\nexport * as Video from './video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        NamedColourPalette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA,UAAiB,SAAS,QAAQ;CAC9B,YAAY,UAAU,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;AACxC,KAAI,OAAO,SAAS,EAChB,OAAM,IAAI,MAAM,CAAC,kDAAkD,EAAE,OAAO,QAAQ;AACxF,MAAK,IAAI,QAAQ,GAAG,QAAQ,OAAO,QAAQ,SACvC,MAAM,CAAC,OAAO,QAAQ,IAAI,OAAO,MAAO;AAE/C;;;;;;;;;;;;;;;AC4ID,MAAaA,UAAQ,CAAC,iBAAiB;AACnC,KAAI,OAAO,iBAAiB,CAAC,MAAM,CAAC,CAChC,OAAM,IAAI,MAAM,CAAC,4CAA4C,EAAE,OAAO,cAAc;AACxF,KAAI,OAAO,MAAM,aAAa,CAC1B,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AACjD,KAAI,eAAe,EACf,QAAO;AACX,KAAI,eAAe,GACf,QAAO;AACX,QAAO;AACV;;;;;;;;;;;;;;;AC7JD,SAAgB,YAAY,IAAI,aAAa,aAAa;CACtD,IAAI,QAAS,OAAO,gBAAgB,CAAC,MAAM,CAAC,GAAI,cAAc,YAAY;CAC1E,IAAI,SAAU,OAAO,gBAAgB,CAAC,MAAM,CAAC,GAAI,cAAc,YAAY;AAC3E,KAAI,UAAU,OACV,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;AAC7C,KAAI,WAAW,OACX,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;CAC9C,QAAQ,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;CAC1B,SAAS,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;AAC7B,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CAC/B,KAAI,aAAa,YAAY,EAAE;EAC3B,MAAM,IAAI,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;EAChC,MAAM,IAAI,GAAG,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC;AAChC,SAAO;GAAE,GAAG;GAAa;GAAO;GAAQ;GAAG;EAAG;CACjD,MAEG,QAAO;EACH,GAAG;EAAa;EAAO;CAC1B;AAGT,QAAO;EAAE;EAAO;CAAQ;AAC3B;AAiDD,SAAgB,YAAY,IAAIC,QAAM,WAAW;AAC7C,QAAO,aAAaA,OAAK,GAAG,OAAO,OAAO;EACtC,GAAGA;EACH,GAAG,GAAGA,OAAK,GAAG,UAAU;EACxB,GAAG,GAAGA,OAAK,GAAG,UAAU;EACxB,OAAO,GAAGA,OAAK,OAAO,UAAU;EAChC,QAAQ,GAAGA,OAAK,QAAQ,UAAU;CACrC,EAAC,GAAG,OAAO,OAAO;EACf,GAAGA;EACH,OAAO,GAAGA,OAAK,OAAO,UAAU;EAChC,QAAQ,GAAGA,OAAK,QAAQ,UAAU;CACrC,EAAC;AACL;;;;;;;;;;;;;;;;AClFD,MAAa,SAAS,CAACC,QAAM,WAAW;CACpC,MAAMA,OAAK;AACX,KAAI,WAAW,UAAa,QAAQA,OAAK,EACrC,SAASA;UACJ,WAAW,QAChB,SAAS;EAAE,GAAG;EAAG,GAAG;CAAG;CAC3B,MAAM,IAAI,kBAAkBA,QAAM,OAAO;AACzC,QAAO,OAAO,OAAO;EACjB,GAAG,OAAO,IAAIA,OAAK,QAAQ;EAC3B,GAAG,OAAO,IAAIA,OAAK,SAAS;CAC/B,EAAC;AACL;;;;;;;;;;;;;;;;ACbD,MAAa,UAAU,CAAC,GAAG,MAAM;AAC7B,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAChD,KAAI,EAAE,SAAS,EACX,QAAO;AACX,MAAK,IAAI,QAAQ,GAAG,QAAQ,EAAE,QAAQ,SAAS;AAC3C,MAAI,EAAE,OAAO,MAAM,EAAE,GAAG,EACpB,QAAO;AACX,MAAI,EAAE,OAAO,MAAM,EAAE,GAAG,EACpB,QAAO;CACd;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;ACoBD,MAAaC,YAAU,CAAC,GAAG,MAAM;AAC7B,KAAI,aAAa,EAAE,IAAI,aAAa,EAAE,EAAE;AACpC,MAAI,CAACC,QAAc,GAAG,EAAE,CACpB,QAAO;AACX,SAAO,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE;CAChD,WACQ,CAAC,aAAa,EAAE,IAAI,CAAC,aAAa,EAAE,CACzC,QAAO,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE;KAI7C,QAAO;AAEd;;;;ACxDD,MAAM,aAAa,CAAC,GAAG,MAAM,IAAI;;;;;;;;;;;;;;AAyBjC,SAAgB,eAAeC,QAAM,QAAQ;AACzC,QAAO,YAAY,YAAYA,QAAM,OAAO;AAY/C;;;;AChBD,SAAgB,aAAa,GAAG,GAAG,GAAG;CAClC,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,EAAE;CACxC,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,EAAE;AACxC,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,kCAAkC,CAAC;CACxD,MAAM,IAAI;EACN,GAAG;EACH,OAAO,EAAE,QAAQ;EACjB,QAAQ,EAAE,SAAS;CACtB;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;ACnBD,MAAa,WAAW,CAAC,GAAG,WAAW;AACnC,KAAI,CAAC,MAAM,QAAQ,OAAO,CACtB,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;CAE7C,MAAM,MAAM,OAAO,OAAO,CAAC,UAAU,MAAM;AACvC,MAAI,MAAM,OACN,QAAO;AACX,MAAI,MAAM,QAAQ,EAAE,CAChB,OAAM,IAAI,UAAU,CAAC,qEAAqE,CAAC;AAE/F,MAAI,CAAC,QAAQ,EAAE,CACX,OAAM,IAAI,MAAM,CAAC,kDAAkD,EAAE,KAAK,UAAU,EAAE,EAAE;AAE5F,SAAO;GACH,GAAG,SAAS,IAAI,EAAE;GAClB,GAAG,SAAS,IAAI,EAAE;EACrB;CACJ,GAAE;EAAE,GAAG;EAAG,GAAG;CAAG,EAAC;AAClB,QAAO,OAAO,OAAO;EACjB,GAAG,IAAI,IAAI,OAAO;EAClB,GAAG,IAAI,IAAI,OAAO;CACrB,EAAC;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACkHD,gBAAgB,qBAAqB;CACjC,IAAI;CACJ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAO,UAAU;CACtC,IAAI,QAAQ;CACZ,MAAM,WAAW,MAAM;AACnB,MAAI,SACA,SAAS;EACb,IAAI,IAAI,QAAQ,CAAC,MAAO,UAAU;CACrC;AACD,KAAI;AACA,SAAO,MAAM;GACT,QAAQ,WAAW,sBAAsB,SAAS;GAElD,MAAM,IAAI,MAAM;GAChB,MAAM;EACT;CACJ,UACO;AACJ,MAAI,SACA,SAAS;EACb,WAAW,qBAAqB,MAAM;CACzC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCD,gBAAuB,UAAU,SAAS;CACtC,MAAM,YAAY,aAAa,QAAQ;AACvC,KAAI,OAAO,cAAc,CAAC,SAAS,CAAC,CAChC,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;AAC1C,KAAI,YAAY,EACZ,OAAM,IAAI,MAAM,CAAC,yBAAyB,CAAC;AAC/C,KAAI,cAAc,EACd,QAAO,OAAO,oBAAoB;CACtC,IAAI;CACJ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAO,UAAU;CACtC,IAAI;CACJ,MAAM,WAAW,MAAM;AACnB,MAAI,SACA,SAAS;EACb,IAAI,IAAI,QAAQ,CAAC,MAAO,UAAU;CACrC;AACD,KAAI;AACA,SAAO,MAAM;GACT,QAAQ,WAAW,WAAW,UAAU,UAAU;GAElD,MAAM,IAAI,MAAM;GAChB,MAAM;EACT;CACJ,UACO;AACJ,MAAI,SACA,SAAS;AACb,MAAI,UAAU,QACV,WAAW,aAAa,MAAM;EAClC,QAAQ;CACX;AACJ;;;;ACjPD,MAAa,YAAY,CAAC,MAAM,OAAO,UAAU;CAC7C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,SAAS,KAAK,iBAAiB,CAAC,SAAS,CAAC;CAChD,MAAM,WAAW,KAAK,YAAY;CAClC,MAAM,WAAW,kBAAkB;AACnC,KAAI,KAAK,OACL,QAAQ,IAAI,CAAC,sBAAsB,EAAE,MAAM,OAAO,eAAe,EAAE,gBAAgB,WAAW,EAAE,SAAS,SAAS,EAAE,QAAQ,CAAC;AAEjI,SAAQ,QAAR;EACI,KAAK,CAAC,SAAS,CAAC,EAAE;AACd,OAAI,KAAK,OACL,QAAQ,IAAI,CAAC,uCAAuC,EAAE,MAAM,OAAO,QAAQ,EAAE,kBAAkB,SAAS,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGxI,OAAI,MAAM,WAAW,KAAK,SACtB,QAAO;OAIP,QAAO,CAAC,GAAG,OAAO,GAAG,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS,AAAC;EAEpE;EACD,KAAK,CAAC,KAAK,CAAC,CACR,KAAI,YAAY,MAAM,OAElB,QAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAS,SAAS,EAAE,KAAK,IAAI,MAAM,QAAQ,SAAS,GAAG,EAAE;OAE7F;AAGD,OAAI,KAAK,OACL,QAAQ,IAAI,CAAC,YAAY,EAAE,KAAK,UAAU,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS,CAAC,EAAE,CAAC;AAEzF,UAAO,CACH,GAAG,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS,EAC1C,GAAG,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAW,WAAW,EAAE,CAAC,AACrE;EACJ;EAEL,KAAK,CAAC,KAAK,CAAC,CAER,QAAO,CAAC,GAAG,OAAO,GAAG,KAAM,EAAC,MAAM,SAAS;EAE/C,QAEI,OAAM,IAAI,MAAM,CAAC,uBAAuB,EAAE,QAAQ;CAEzD;AACJ;AAED,MAAa,OAAO,CAAC,MAAM,OAAO,GAAG,UAAU;CAG3C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,WAAW,KAAK,YAAY,kBAAkB,KAAK;CACzD,MAAM,WAAW,WACX,UAAU,MAAM,OAAO,MAAM,GAC7B,CAAC,GAAG,OAAO,GAAG,KAAM;AAC1B,QAAO;AACV;AAED,MAAa,MAAM,CAAC,MAAM,UAAU;AAChC,KAAI,MAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,cAAc,CAAC;AACpC,QAAO,MAAM,MAAM,GAAG,GAAG;AAC5B;;;;;;;;;AASD,MAAaC,SAAO,CAAC,MAAM,UAAU,MAAM,GAAG,GAAG;AACjD,MAAaC,YAAU,CAAC,MAAM,UAAU,MAAM,WAAW;AACzD,MAAaC,WAAS,CAAC,MAAM,UAAU;AACnC,KAAI,KAAK,SACL,QAAO,MAAM,UAAU,KAAK;AAEhC,QAAO;AACV;;;;AChFD,IAAa,iBAAb,MAAa,eAAe;CACxB;CAEA;CACA,YAAY,OAAO,CAAE,GAAE,OAAO,CAAE,GAAE;EAC9B,KAAK,OAAO;EACZ,KAAK,OAAO;CACf;CACD,KAAK,GAAG,OAAO;AACX,SAAO,IAAI,eAAe,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,MAAM,GAAG,MAAM;CAC5E;CACD,MAAM;AACF,SAAO,IAAI,eAAe,KAAK,MAAM,IAAI,KAAK,MAAM,KAAK,KAAK;CACjE;CACD,QAAQ,IAAI;EACR,KAAK,KAAK,QAAQ,GAAG;CACxB;CACD,eAAe,IAAI;EACf,CAAC,GAAG,KAAK,IAAK,EAAC,SAAS,CAAC,QAAQ,GAAG;CACvC;CACD,IAAI,UAAU;AACV,SAAOC,UAAQ,KAAK,MAAM,KAAK,KAAK;CACvC;CACD,IAAI,SAAS;AACT,SAAOC,SAAO,KAAK,MAAM,KAAK,KAAK;CACtC;CACD,IAAI,OAAO;AACP,SAAOC,OAAK,KAAK,MAAM,KAAK,KAAK;CACpC;CACD,IAAI,SAAS;AACT,SAAO,KAAK,KAAK;CACpB;AACJ;;;;AC5BD,IAAa,iBAAb,MAAa,eAAe;CACxB;CACA;;;;;;CAMA,YAAY,OAAO,CAAE,GAAE,OAAO,CAAE,GAAE;AAC9B,MAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;EAC9C,KAAK,OAAO;EACZ,KAAKC,QAAQ;CAChB;CACD,QAAQ,IAAI;AAER,OAAK,IAAI,QAAQ,KAAKA,MAAM,SAAS,GAAG,SAAS,GAAG,SAChD,GAAG,KAAKA,MAAM,OAAO;CAE5B;CACD,iBAAiB,IAAI;EAEjB,KAAKA,MAAM,QAAQ,UAAQ;GAAE,GAAG,KAAK;EAAG,EAAC;CAC5C;CACD,QAAQ,GAAG,OAAO;AACd,SAAO,IAAI,eAAe,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAKA,OAAO,GAAG,MAAM;CAChF;CACD,UAAU;AACN,SAAO,IAAI,eAAe,KAAK,MAAM,QAAQ,KAAK,MAAM,KAAKA,MAAM;CACtE;CACD,IAAI,UAAU;AACV,SAAO,QAAQ,KAAK,MAAM,KAAKA,MAAM;CACxC;CACD,IAAI,SAAS;AACT,SAAO,OAAO,KAAK,MAAM,KAAKA,MAAM;CACvC;CACD,IAAI,SAAS;AACT,SAAO,KAAKA,MAAM;CACrB;CACD,IAAI,OAAO;AACP,SAAO,KAAK,KAAK,MAAM,KAAKA,MAAM;CACrC;CACD,UAAU;AACN,SAAO,CAAC,GAAG,KAAKA,KAAM;CACzB;AACJ;;;;;;;;;;;;;;;;;;;;;;ACWD,MAAa,oBAAoB,CAAC,KAAK,OAAOC,YAAU,mBAAmB;AACvE,MAAK,MAAM,KAAK,IAAI,SAAS,EAAE;EAC3B,MAAM,SAAS,EAAE;AACjB,OAAK,MAAM,YAAY,OACnB,KAAIA,UAAQ,UAAU,MAAM,CACxB,QAAO;CAElB;AACJ;;;;ACnED,IAAa,kBAAb,MAA6B;CACzB;CACA;CACA;;;;;;CAMA,YAAY,UAAU,cAAc,UAAW,gBAAiB,UAAU,CAAE,GAAE;EAC1E,KAAK,UAAU;EACf,KAAK,UAAU;EACf,KAAK,MAAM,IAAI,IAAI;CACtB;;;;;;CAMD,IAAI,KAAK;AACL,SAAO,KAAK,IAAI,IAAI,IAAI;CAC3B;;;;;;;CAOD,YAAY,KAAK,OAAO;EACpB,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI;AAChC,MAAI,CAAC,OACD,QAAO;AACX,OAAK,MAAM,KAAK,OACZ,KAAI,KAAK,QAAQ,GAAG,MAAM,CACtB,QAAO;AAEf,SAAO;CACV;;;;;CAKD,cAAc;EACV,IAAI,IAAI,EAAE;EACV,MAAM,OAAO,CAAC,GAAG,KAAK,IAAI,MAAM,AAAC;EACjC,KAAK,MAAM,CAAC,MAAM;GACd,MAAM,IAAI,KAAK,IAAI,IAAI,EAAE;AACzB,OAAI,MAAM,OACN;GACJ,KAAK,IAAI,CAAC,EAAE,EAAE,EAAE,OAAO,IAAI,EAAE,KAAK,UAAU,EAAE,CAAC,IAAI,CAAC;EACvD,EAAC;AACF,SAAO;CACV;;;;;;;CAOD,MAAM,KAAK;EACP,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI;AAChC,MAAI,CAAC,OACD,QAAO;AACX,SAAO,OAAO;CACjB;;;;;;;CAOD,gBAAgB,OAAO,KAAK,gBAAgB;EACxC,MAAM,QAAQ,kBAAkB,MAAM,OAAO,GAAG;AAChD,MAAI,MACA,QAAO,MAAM;CACpB;;;;CAID,CAAC,cAAc;AACX,OAAK,MAAM,OAAO,KAAK,IAAI,MAAM,CAC7B,MAAK,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI,EACjC,MAAM,CAAC,KAAK,KAAM;CAG7B;;;;CAID,CAAC,UAAU;AACP,OAAK,MAAM,CAAC,GAAG,EAAE,IAAI,KAAK,IAAI,SAAS,EACnC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAE,CAAC;CAExB;;;;;;CAMD,CAAC,IAAI,KAAK;EACN,MAAM,IAAI,KAAK,IAAI,IAAI,IAAI;AAC3B,MAAI,CAAC,EACD;EACJ,OAAO,EAAE,QAAQ;CACpB;;;;CAID,CAAC,OAAO;EACJ,OAAO,KAAK,IAAI,MAAM;CACzB;;;;;CAKD,CAAC,aAAa;AACV,OAAK,MAAM,WAAW,KAAK,KACvB,OAAO,QAAQ;CAEtB;;;;;CAKD,CAAC,SAAS;AACN,OAAK,MAAM,WAAW,KAAK,KACvB,MAAM,QAAQ;CAErB;;;;CAID,CAAC,gBAAgB;AACb,OAAK,MAAM,WAAW,KAAK,KACvB,MAAM,CAAC,QAAQ,IAAI,QAAQ,GAAG,MAAO;CAE5C;;;;CAID,IAAI,aAAa;AACb,SAAO,KAAK,IAAI;CACnB;;;;CAID,IAAI,UAAU;AACV,SAAO,KAAK,IAAI,SAAS;CAC5B;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;AC/HD,IAAa,qBAAb,cAAwC,gBAAgB;CACpD,eAAe,KAAK,GAAG,QAAQ;EAC3B,MAAM,WAAW,KAAK,IAAI,IAAI,IAAI;AAClC,MAAI,aAAa,QACb,KAAK,IAAI,IAAI,KAAK,OAAO;OAGzB,KAAK,IAAI,IAAI,KAAK,CAAC,GAAG,UAAU,GAAG,MAAO,EAAC;CAElD;;;;;;;CAOD,UAAU,KAAK,QAAQ;EACnB,KAAK,IAAI,IAAI,KAAK,OAAO;CAC5B;;;;;;CAMD,SAAS,GAAG,QAAQ;AAChB,OAAK,MAAM,KAAK,QAAQ;GACpB,MAAM,MAAM,KAAK,QAAQ,EAAE;GAC3B,KAAK,eAAe,KAAK,EAAE;EAC9B;CACJ;;;;;;;CAOD,eAAe,KAAK,OAAO;EACvB,MAAM,WAAW,KAAK,IAAI,IAAI,IAAI;AAClC,MAAI,aAAa,OACb,QAAO;EACX,MAAM,UAAU,SAAS,OAAO,CAAC,kBAAkB,CAAC,KAAK,QAAQ,eAAe,MAAM,CAAC;EACvF,KAAK,IAAI,IAAI,KAAK,QAAQ;AAC1B,SAAO,QAAQ,SAAS,SAAS;CACpC;;;;;;;;CAQD,cAAc,OAAO;EACjB,IAAI,MAAM;EACV,MAAM,UAAU,CAAC,GAAG,KAAK,IAAI,SAAS,AAAC;AACvC,OAAK,MAAM,cAAc,QACrB,MAAK,MAAM,UAAU,WAAW,GAC5B,KAAI,KAAK,QAAQ,QAAQ,MAAM,EAAE;GAC7B,MAAM;GACN,KAAK,eAAe,WAAW,IAAI,MAAM;EAC5C;AAGT,SAAO;CACV;;;;;;CAMD,OAAO,KAAK;EACR,MAAM,SAAS,KAAK,IAAI,IAAI,IAAI;AAChC,MAAI,CAAC,OACD,QAAO;AACX,MAAI,OAAO,WAAW,EAClB,QAAO;EACX,KAAK,IAAI,OAAO,IAAI;AACpB,SAAO;CACV;;;;CAID,QAAQ;EACJ,KAAK,IAAI,OAAO;CACnB;AACJ;;;;;;;;;;;AC9FD,MAAaC,gBAAc,CAAC,KAAK,WAAW;CACxC,MAAM,IAAI,UAAU,KAAK,OAAO;CAChC,MAAM,IAAIC,YAAiB,IAAI,QAAQ,IAAI,aAAa,EAAE;CAC1D,MAAM,IAAIA,YAAiB,IAAI,SAAS,IAAI,QAAQ,IAAI,aAAa,EAAE;AACvE,QAAO;EAAE;EAAG;CAAG;AAClB;AACD,MAAM,YAAY,CAAC,KAAK,WAAW;AAC/B,KAAI,WAAW,OACX,QAAO;AACX,KAAI,IAAI,WAAW,OACf,QAAO,IAAI;AACf,QAAO;EAAE,GAAG;EAAG,GAAG;CAAG;AACxB;;;;;;;;AA8CD,MAAa,WAAW,CAACC,QAAM,WAAW;CACtC,MAAM,IAAI,UAAUA,OAAK;AACzB,QAAO;EACH,aAAa,YAAYA,OAAK,GAAG,EAAE;EACnC,QAAQ,SAASA,OAAK,GAAG,EAAE;EAC3B,QAAQ,SAASA,OAAK,GAAGA,OAAK,EAAE;EAChC,QAAQ;CACX;AACJ;;;;ACnED,MAAM,iBAAiB,OAAO,OAAO;CAAE,GAAG;CAAG,GAAG;AAAG,EAAC;AACpD,MAAMC,SAAO,KAAK,KAAK;AACvB,MAAM,KAAK,KAAK;;;;;;;;;;;AAwBhB,MAAa,iBAAiB,CAAC,IAAI,qBAAqB,EAAE,EAAE,SAAS,mBAAmB;CACpF,KAAKC,SAAe,IAAI,OAAO;CAC/B,IAAI,YAAY,KAAK,MAAM,GAAG,GAAG,GAAG,EAAE;AACtC,KAAI,uBAAuB,CAAC,QAAQ,CAAC,IAAI,YAAY,GACjD,aAAaD;UACR,uBAAuB,CAAC,OAAO,CAAC,EACrC;MAAI,YAAY,IACZ,aAAaA;WACR,aAAa,CAAC,IACnB,aAAaA;CAAK;AAE1B,QAAO,OAAO,OAAO;EACjB,UAAUE,SAAe,GAAG;EAC5B,aAAa;CAChB,EAAC;AACL;;;;;;AAMD,MAAa,oBAAoB,CAACC,WAASF,SAAeE,OAAK,GAAGA,OAAK,EAAE;;;;;;AAMzE,MAAa,gBAAgB,CAACA,WAAS;CACnCC,QAAWD,QAAM,CAAC,IAAI,CAAC,CAAC;CACxB,MAAM,KAAKF,SAAeE,OAAK,GAAGA,OAAK,EAAE;AACzC,QAAO,eAAe,GAAG;AAC5B;;;;;;;;;;;;;;;;;ACxDD,MAAa,cAAc,CAAC,IAAI,IAAI,IAAI,OAAO;AAC3C,KAAI,OAAO,MAAM,GAAG,CAChB,OAAM,IAAI,MAAM,CAAC,SAAS,CAAC;AAC/B,KAAI,OAAO,MAAM,GAAG,CAChB,OAAM,IAAI,MAAM,CAAC,SAAS,CAAC;AAC/B,KAAI,OAAO,MAAM,GAAG,CAChB,OAAM,IAAI,MAAM,CAAC,SAAS,CAAC;AAC/B,KAAI,OAAO,MAAM,GAAG,CAChB,OAAM,IAAI,MAAM,CAAC,SAAS,CAAC;CAC/B,MAAM,IAAI;EAAE,GAAG;EAAI,GAAG;CAAI;CAC1B,MAAM,IAAI;EAAE,GAAG;EAAI,GAAG;CAAI;AAC1B,QAAO,WAAW,GAAG,EAAE;AAC1B;;;;ACOD,MAAaE,UAAQ,OAAO,OAAO;CAC/B,GAAG,OAAO,OAAO;EAAE,GAAG;EAAG,GAAG;CAAG,EAAC;CAChC,GAAG,OAAO,OAAO;EAAE,GAAG;EAAG,GAAG;CAAG,EAAC;AACnC,EAAC;AACF,MAAaC,gBAAc,OAAO,OAAO;CACrC,GAAG,OAAO,OAAO;EAAE,GAAG;EAAY,GAAG;CAAY,EAAC;CAClD,GAAG,OAAO,OAAO;EAAE,GAAG;EAAY,GAAG;CAAY,EAAC;AACrD,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACCF,MAAa,WAAW,CAAC,GAAG,MAAM;CAC9B,MAAM,QAAQ,kBAAkB,GAAG,EAAE;CACrC,IAAI,SAAS;CACb,IAAI,SAAS;CACb,IAAI,QAAQ;CACZ,IAAI,aAAa,YAAY,KAAK;CAClC,IAAI,YAAY;CAChB,MAAM,SAAS,CAAC,IAAI,OAAO;EACvB,MAAM,IAAI,kBAAkB,IAAI,GAAG;EACnC,UAAU,EAAE;EACZ,UAAU,EAAE;EACZ;EACA,MAAM,oBAAoB,SAAS,GAAG,MAAM;EAC5C,MAAM,mBAAmB,SAAS,GAAG,UAAU;EAE/C,MAAM,MAAM,YAAY,KAAK;EAC7B,MAAM,QAAQ,oBAAoB,MAAM;EACxC,aAAa;EACb,YAAY;AACZ,SAAO,OAAO,OAAO;GACjB,OAAO,YAAY,GAAG,MAAM;GAC5B;GACA;GACA;GACA,UAAU,SAAS,GAAG,MAAM;GAC5B,SAAS;IACL,GAAG,SAAS;IACZ,GAAG,SAAS;GACf;EACJ,EAAC;CACL;AACD,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFD,IAAa,eAAb,cAAkC,cAAc;CAC5C;CACA;CACA;CACA,YAAY,OAAO,CAAE,GAAE;EACnB,MAAM,KAAK;CACd;;;;;;CAMD,UAAU,SAAS;EAEf,KAAK,kBAAkB;CAC1B;;;;CAID,UAAU;EACN,MAAM,SAAS;EACf,KAAK,aAAa;EAClB,KAAK,kBAAkB;EACvB,KAAK,eAAe;CACvB;;;;;;;CAOD,UAAU,GAAG;AACT,MAAI,CAAC,kBAAkB,CAAC,IAAI,GAAG;GAC3B,MAAM,SAAS,EAAE,oBAAoB;GACrC,MAAM,WAAW,OAAO,IAAI,YAAU;IAAE,GAAG,MAAM;IAAS,GAAG,MAAM;GAAS,GAAE;AAC9E,UAAO,KAAK,KAAK,GAAG,SAAS;EAChC,MAEG,QAAO,KAAK,KAAK;GAAE,GAAI,EAAG;GAAS,GAAI,EAAG;EAAS,EAAC;CAE3D;;;;;CAKD,OAAO;EACH,KAAK,eAAe,SAAS,KAAK,KAAK;CAC1C;;;;;;;;;CASD,eAAe,IAAI;EACf,MAAM,cAAc,KAAK;EACzB,MAAM,eAAe,KAAK,OAAO,GAAG,GAAG;AACvC,MAAI,KAAK,oBAAoB,UAAa,KAAK,SAG3C,KAAK,kBAAkB,SAAS,KAAK,QAAQ;WAExC,KAAK,oBAAoB,OAE9B,OAAM,IAAI,MAAM,CAAC,sDAAsD,CAAC;EAG5E,MAAM,eAAe,iBAAiB,SAAY,SAAS,YAAY,GAAG,SAAS,aAAa;EAEhG,MAAM,aAAa,KAAK,gBAAgB,YAAY;EACpD,MAAM,UAAW,KAAK,iBAAiB,SAAa,KAAK,aAAa,YAAY,GAAG;EACrF,MAAM,QAAQ,iBAAiB,SAAY,IAAIC,OAAW,cAAc,YAAY,IAAI,YAAY,KAAK,aAAa;EAEtH,MAAM,UAAU;GACZ,GAAG,aAAa,YAAY;GAC5B;EACH;EACD,MAAM,IAAI;GACN,aAAa;GACb,UAAU;GACV,UAAU;GACV,QAAQ,CAAC,GAAG,KAAK,MAAO;EAC3B;EACD,KAAK,aAAa;AAClB,SAAO;CACV;;;;;CAKD,IAAI,OAAO;AACP,MAAI,KAAK,OAAO,WAAW,EACvB,QAAO,CAAE;AACb,SAAO,kBAAkB,GAAG,KAAK,OAAO;CAC3C;;;;;CAKD,IAAI,cAAc;AACd,uBAA6B,KAAK,aAAa;CAClD;;;;;CAKD,IAAI,kBAAkB;AAClB,2BAAiC,KAAK,aAAa;CACtD;;;;;;CAMD,IAAI,eAAe;EACf,MAAM,UAAU,KAAK;AACrB,MAAI,KAAK,OAAO,SAAS,KAAK,CAAC,QAC3B,QAAOC;AACX,SAAO;GACH,GAAG;GACH,GAAG,KAAK;EACX;CACJ;;;;;;;;;CASD,oBAAoB;EAChB,MAAM,UAAU,KAAK;AACrB,SAAO,KAAK,OAAO,UAAU,KAAK,YAAY,SAAY,SAAS,SAAS,KAAK,KAAK,GAAG;CAC5F;;;;;;;CAOD,aAAa;EACT,MAAM,UAAU,KAAK;AACrB,SAAO,KAAK,OAAO,UAAU,KAAK,YAAY,SAAY,SAAS,KAAK,MAAM,QAAQ,GAAGC;CAC5F;;;;;;CAMD,iBAAiB;EACb,MAAM,UAAU,KAAK;AACrB,MAAI,YAAY,UAAa,KAAK,OAAO,SAAS,EAC9C,QAAO,YAAY,SAAS,KAAK,KAAK;CAE7C;;;;;CAKD,IAAI,SAAS;AACT,MAAI,KAAK,OAAO,WAAW,EACvB,QAAO;EACX,MAAM,IAAI,KAAK;AACf,SAAOF,OAAW,EAAE;CACvB;;;;CAID,IAAI,IAAI;AACJ,SAAO,KAAK,KAAK;CACpB;;;;CAID,IAAI,IAAI;AACJ,SAAO,KAAK,KAAK;CACpB;;;;CAID,IAAI,IAAI;AACJ,SAAO,KAAK,KAAK;CACpB;AACJ;;;;;AAKD,IAAa,gBAAb,cAAmC,gBAAgB;CAC/C,YAAY,OAAO,CAAE,GAAE;EACnB,MAAM,CAAC,KAAK,UAAU;AAClB,OAAI,UAAU,OACV,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;GAC1C,MAAM,IAAI,IAAI,aAAa;IACvB,GAAG;IACH,IAAI;GACP;GACD,EAAE,KAAK,MAAM;AACb,UAAO;EACV,EAAC;CACL;;;;;CAKD,UAAU,OAAO;AACb,MAAI,CAAC,kBAAkB,CAAC,IAAI,OAAO;GAC/B,MAAM,SAAS,MAAM,oBAAoB;GACzC,MAAM,QAAQ,OAAO,IAAI,cAAY,MAAM,KAAK,SAAS,UAAU,UAAU,EAAE,SAAS,CAAC;AACzF,UAAO,QAAQ,IAAI,MAAM;EAC5B,MAEG,QAAO,QAAQ,IAAI,CAAC,MAAM,KAAK,MAAM,UAAU,UAAU,EAAE,MAAM,AAAC,EAAC;CAE1E;AACJ;;;;;;;;;;;AC1RD,MAAa,SAAS,CAACG,QAAM,SAAS;AAClC,KAAI,KAAK,IAAI,KAAK,KAAK,IAAI,EACvB,QAAO;AACX,KAAI,KAAK,KAAKA,OAAK,QAAQ,KAAK,KAAKA,OAAK,KACtC,QAAO;AACX,QAAO;AACV;;;;;;;;;;;ACOD,MAAa,YAAY,CAAC,MAAM,gBAAgB,CAAC,KAAK,CAAC,EAAEC,WAAS;AAC9D,KAAI,SAAS,OACT,OAAM,IAAI,MAAM,gBAAgB,CAAC,8BAA8B,CAAC;AAEpE,KAAI,KAAK,MAAM,OACX,OAAM,IAAI,MAAM,gBAAgB,CAAC,eAAe,CAAC;AACrD,KAAI,KAAK,MAAM,OACX,OAAM,IAAI,MAAM,gBAAgB,CAAC,eAAe,CAAC;AACrD,KAAI,OAAO,MAAM,KAAK,EAAE,CACpB,OAAM,IAAI,MAAM,gBAAgB,CAAC,SAAS,CAAC;AAC/C,KAAI,OAAO,MAAM,KAAK,EAAE,CACpB,OAAM,IAAI,MAAM,gBAAgB,CAAC,SAAS,CAAC;AAC/C,KAAI,CAAC,OAAO,UAAU,KAAK,EAAE,CACzB,OAAM,IAAI,UAAU,gBAAgB,CAAC,iBAAiB,CAAC;AAE3D,KAAI,CAAC,OAAO,UAAU,KAAK,EAAE,CACzB,OAAM,IAAI,UAAU,gBAAgB,CAAC,iBAAiB,CAAC;AAE3D,KAAIA,WAAS,UAAa,CAAC,OAAOA,QAAM,KAAK,CACzC,OAAM,IAAI,MAAM,GAAG,cAAc,2BAA2B,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,EAAE,OAAO,EAAEA,OAAK,KAAK,EAAE,EAAEA,OAAK,MAAM;AAExH;;;;;;AAMD,MAAa,YAAY,CAACA,QAAM,gBAAgB,CAAC,KAAK,CAAC,KAAK;AACxD,KAAIA,WAAS,OACT,OAAM,IAAI,MAAM,GAAG,cAAc,8BAA8B,CAAC;AAEpE,KAAI,EAAE,CAAC,IAAI,CAAC,IAAIA,QACZ,OAAM,IAAI,MAAM,GAAG,cAAc,kBAAkB,CAAC;AACxD,KAAI,EAAE,CAAC,IAAI,CAAC,IAAIA,QACZ,OAAM,IAAI,MAAM,GAAG,cAAc,kBAAkB,CAAC;AACxD,KAAI,CAAC,OAAO,UAAUA,OAAK,KAAK,CAC5B,OAAM,IAAI,UAAU,GAAG,cAAc,uBAAuB,CAAC;AAEjE,KAAI,CAAC,OAAO,UAAUA,OAAK,KAAK,CAC5B,OAAM,IAAI,UAAU,GAAG,cAAc,uBAAuB,CAAC;AAEpE;;;;;;;;;;;;ACnDD,MAAa,cAAc,SAAUC,QAAM,MAAMC,SAAO,CAAC,SAAS,CAAC,EAAE;CACjE,UAAUD,QAAM,CAAC,IAAI,CAAC,CAAC;CACvB,UAAU,MAAM,CAAC,IAAI,CAAC,CAAC;CACvB,IAAI,IAAI,KAAK;CACb,IAAI,IAAI,KAAK;AACb,SAAQC,QAAR;EACI,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,IAAI,IAAID,OAAK;GACb,IAAI,IAAIA,OAAK;AACb,OAAI,IAAI,GACJ,IAAIA,OAAK,OAAO;YACX,KAAKA,OAAK,MACf,KAAKA,OAAK;AAEd,OAAI,IAAI,GACJ,IAAIA,OAAK,OAAO;YACX,KAAKA,OAAK,MACf,KAAKA,OAAK;GAEd,IAAI,KAAK,IAAI,EAAE;GACf,IAAI,KAAK,IAAI,EAAE;AACf;EACH;EACD,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,IAAI,WAAW,GAAGA,OAAK,KAAK;GAC5B,IAAI,WAAW,GAAGA,OAAK,KAAK;AAC5B;EACH;EACD,KAAK,CAAC,SAAS,CAAC,EAAE;AACd,OAAI,IAAI,KAAK,IAAI,EACb;AACJ,OAAI,KAAKA,OAAK,QAAQ,KAAKA,OAAK,KAC5B;AACJ;EACH;EACD,KAAK,CAAC,SAAS,CAAC,CACZ;EAEJ,QACI,OAAM,IAAI,MAAM,CAAC,qBAAqB,EAAEC,OAAK,+CAA+C,CAAC;CAEpG;AACD,QAAO,OAAO,OAAO;EAAE;EAAG;CAAG,EAAC;AACjC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3BD,UAAiB,MAAMC,QAAM,OAAOC,SAAO,MAAM;AAC7C,KAAI,CAAC,OACD,QAAQ;EAAE,GAAG;EAAG,GAAG;CAAG;CAC1B,UAAUD,QAAM,CAAC,IAAI,CAAC,CAAC;CACvB,UAAU,OAAO,CAAC,KAAK,CAAC,EAAEA,OAAK;CAC/B,IAAI,EAAE,GAAG,GAAG,GAAG;CACf,IAAI,UAAU;AACd,IAAG;EACC,MAAM;GAAE;GAAG;EAAG;EACd;AACA,MAAI,MAAMA,OAAK,MAAM;GACjB;GACA,IAAI;EACP;AACD,MAAI,MAAMA,OAAK,KACX,KAAIC,QAAM;GACN,IAAI;GACJ,IAAI;EACP,OAEG,UAAU;AAGlB,MAAI,MAAM,MAAM,KAAK,MAAM,MAAM,GAC7B,UAAU;CACjB,SAAQ;AACZ;;;;;;;;;;;;;;;;;;;;;;;AChCD,MAAa,OAAO,WAAWC,QAAM,OAAO;AACxC,KAAI,CAAC,OACD,QAAQ;EAAE,GAAG;EAAG,GAAG;CAAG;CAC1B,IAAI,MAAM,MAAM;CAChB,IAAI,WAAW,CAAE;AACjB,MAAK,MAAM,KAAK,MAAMA,QAAM,MAAM,CAC9B,KAAI,EAAE,MAAM,KACR,SAAS,KAAK,EAAE;MAEf;EACD,MAAM;EACN,WAAW,CAAC,CAAE;EACd,MAAM,EAAE;CACX;AAEL,KAAI,SAAS,SAAS,GAClB,MAAM;AACb;;;;;;;;;;;;;;;;;;ACrBD,MAAa,SAAS,SAAUC,QAAM,OAAO,QAAQ,SAAS,CAAC,SAAS,CAAC,EAAE;AACvE,QAAO,YAAYA,QAAM;EACrB,GAAG,MAAM,IAAI,OAAO;EACpB,GAAG,MAAM,IAAI,OAAO;CACvB,GAAE,OAAO;AA+Cb;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCD,MAAa,gBAAgB,CAACC,QAAM,MAAMC,WAAS;CAC/C,UAAUD,QAAM,CAAC,IAAI,CAAC,CAAC;AACvB,KAAI,KAAK,IAAI,EACT,SAAQC,QAAR;EACI,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAG;GAAG;AACxB;EACH;EACD,KAAK,CAAC,SAAS,CAAC,CACZ,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;EAE7C,KAAK,CAAC,SAAS,CAAC,CACZ,QAAO;EAEX,KAAK,CAAC,IAAI,CAAC,EAAE;GAET,OAAO,OAAOD,QAAM;IAAE,GAAG;IAAG,GAAG,KAAK;GAAG,GAAE;IAAE,GAAG,KAAK;IAAG,GAAG;GAAG,GAAE,CAAC,IAAI,CAAC,CAAC;AACrE;EACH;CACJ;AAEL,KAAI,KAAK,IAAI,EACT,SAAQC,QAAR;EACI,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAG;GAAG;AACxB;EACH;EACD,KAAK,CAAC,SAAS,CAAC,CACZ,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;EAE7C,KAAK,CAAC,SAAS,CAAC,CACZ,QAAO;EAEX,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAGD,OAAK,OAAO,KAAK;GAAG;AACzC;EACH;CACJ;AAEL,KAAI,KAAK,KAAKA,OAAK,KACf,SAAQC,QAAR;EACI,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAGD,OAAK,OAAO;GAAG;AACpC;EACH;EACD,KAAK,CAAC,SAAS,CAAC,CACZ,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;EAE7C,KAAK,CAAC,SAAS,CAAC,CACZ,QAAO;EAEX,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAG,KAAK,IAAIA,OAAK;GAAM;AACzC;EACH;CACJ;AAEL,KAAI,KAAK,KAAKA,OAAK,KACf,SAAQC,QAAR;EACI,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAGD,OAAK,OAAO;GAAG;AACpC;EACH;EACD,KAAK,CAAC,SAAS,CAAC,CACZ,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;EAE7C,KAAK,CAAC,SAAS,CAAC,CACZ,QAAO;EAEX,KAAK,CAAC,IAAI,CAAC,EAAE;GACT,OAAO;IAAE,GAAG;IAAM,GAAG,KAAK,IAAIA,OAAK;GAAM;AACzC;EACH;CACJ;CAEL,MAAM,QAAQ,KAAK,IAAIA,OAAK,OAAO,KAAK;AACxC,QAAO;AACV;;;;;;;;;AChGD,MAAaE,UAAQ,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,KAAK;AACpC,KAAI,MAAM,OACN,OAAM,IAAI,MAAM,CAAC,iBAAiB,CAAC;CACvCC,QAAY,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC;CAC7BA,QAAY,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC;CAC7BA,QAAY,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC;AAChC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACoBD,MAAaC,WAAS,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,gBAAgB;CACrD,MAAM,gBAAgB,eAAeC;CACrC,IAAI,KAAK;CACT,IAAI,KAAK;CACT,IAAI,IAAI;EAAE,GAAG;EAAG,GAAG;CAAG;CACtB,MAAM,eAAe,MAAM;AACvB,UAAQ,SAAR;GACI,KAAK,CAAC,MAAM,CAAC,CACT,QAAO;IAAE,GAAG;IAAI,GAAG;GAAI;GAE3B,KAAK,CAAC,KAAK,CAAC,CACR,QAAO;IAAE,GAAG;IAAI,GAAG;GAAI;GAE3B,KAAK,CAAC,GAAG,CAAC,CACN,QAAO;IAAE,GAAG,KAAK,IAAI,IAAI,GAAG;IAAE,GAAG,KAAK,IAAI,IAAI,GAAG;GAAE;GAEvD,KAAK,CAAC,GAAG,CAAC,CACN,QAAO;IAAE,GAAG,KAAK,IAAI,IAAI,GAAG;IAAE,GAAG,KAAK,IAAI,IAAI,GAAG;GAAE;GAEvD,QACI,QAAO;IAAE,GAAG;IAAI,GAAG;GAAI;EAE9B;CACJ;CACD,MAAM,YAAY,CAAC,GAAG,GAAG,GAAG,MAAM;EAC9B,IAAI,MAAM;EACV,IAAI,MAAM;EACV,IAAI,OAAO,cAAc;EACzB,IAAI,OAAO,cAAc;AACzB,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE;GACvB,MAAM;AACN,OAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE;IACvB,MAAM;AACN,QAAI,MAAM,OACN,QAAO;KAAC;KAAK;KAAK;KAAM;IAAK;AACjC,QAAI,OAAO,EAAE,EAAE;KACX,OAAO,EAAE;KACT,OAAO,EAAE;IACZ,WACQ,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE;KAC5B,OAAO;AACP,SAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EACrB,OAAO;SAGP,OAAM,IAAI,UAAU,CAAC,0BAA0B,CAAC;IAEvD,MAEG,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;GACnD,WACQ,OAAO,EAAE,EAAE;IAChB,OAAO,EAAE;IACT,OAAO,EAAE;GACZ,MAEG,OAAM,IAAI,MAAM,CAAC,gEAAgE,CAAC;EAEzF,WACQ,QAAQ,EAAE,EAAE;GACjB,MAAM,EAAE;GACR,MAAM,EAAE;AACR,OAAI,MAAM,OACN,QAAO;IAAC;IAAK;IAAK;IAAM;GAAK;AACjC,OAAI,OAAO,EAAE,EAAE;IACX,OAAO,EAAE;IACT,OAAO,EAAE;GACZ,WACQ,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE;IAC5B,OAAO;AACP,QAAI,OAAO,MAAM,CAAC,MAAM,CAAC,EACrB,OAAO;QAGP,OAAM,IAAI,UAAU,CAAC,+DAA+D,CAAC;GAE5F,MAEG,OAAM,IAAI,UAAU,CAAC,0EAA0E,CAAC;EAEvG,MAEG,OAAM,IAAI,MAAM,CAAC,kDAAkD,CAAC;AAExE,SAAO;GAAC;GAAK;GAAK;GAAM;EAAK;CAChC;CACD,MAAM,WAAW,CAAC,GAAG,GAAG,GAAG,MAAM;EAC7B,MAAM,IAAI,UAAU,GAAG,GAAG,GAAG,EAAE;AAC/B,SAAO,gBAAgB,MAAM,GAAG,EAAE;CACrC;CACD,MAAM,WAAW,CAAC,GAAG,GAAG,GAAG,MAAM;EAC7B,MAAM,IAAI,UAAU,GAAG,GAAG,GAAG,EAAE;AAC/B,SAAO,gBAAgB,OAAO,GAAG,EAAE;CACtC;CACD,MAAM,kBAAkB,CAAC,KAAK,GAAG,GAAG,GAAG,MAAM;AACzC,MAAI,OAAO,MAAM,EAAE,CACf,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAChD,MAAI,OAAO,MAAM,EAAE,CACf,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;AAEjD,MAAI,MAAM,MAAM,MAAM,IAAI;GACtB,KAAK;GACL,KAAK;GACL,IAAI,cAAc;EACrB;AACD,SAAO,MAAM;GACT,GAAG,IAAI,EAAE;GACT,GAAG,IAAI,EAAE;EACZ,IAAG;GACA,GAAG,IAAI,EAAE;GACT,GAAG,IAAI,EAAE;EACZ;CACJ;AACD,QAAO;EACH;EACA,KAAK;EACL,KAAK;EACL,OAAO,cAAc;EACrB,QAAQ,cAAc;CACzB;AACJ;;;;;;;;;ACnJD,MAAaC,YAAU,CAAC,MAAM;CAC1BC,QAAM,EAAE;AACR,QAAO;EAAC,EAAE;EAAG,EAAE;EAAG,EAAE;CAAE;AACzB;;;;;;;;;;;;;;;;;;ACyBD,MAAa,oBAAoB,CAAC,WAAW,GAAG,eAAe;CAC3D,MAAM,IAAI,iBAAiB,UAAU,UAAU,CAAC;CAChD,MAAM,cAAc,CAAE;AACtB,MAAK,MAAM,YAAY,YAAY;EAC/B,MAAM,IAAI,EAAE;AACZ,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACrB,KAAI,EAAE,SAAS,CAAC,EAAE,CAAC,CAAC,EAChB,YAAY,YAAY,OAAO,WAAW,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE,CAAC;MAGvE,OAAM,IAAI,MAAM,CAAC,UAAU,EAAE,OAAO,SAAS,CAAC,+BAA+B,EAAE,GAAG;MAItF,OAAM,IAAI,MAAM,CAAC,UAAU,EAAE,OAAO,SAAS,CAAC,2BAA2B,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG;CAExG;AACD,QAAO;AACV;;;;ACnDD,MAAa,WAAW,CAAC,UAAU,aAAa;CAC5C,IAAI;CACJ,MAAM,KAAK,aAAa,UAAU,IAAI;AACtC,QAAO,MAAM;AAET,MAAI,OACA,aAAa,MAAM;EACvB,QAAQ,WAAW,UAAU,GAAG;CACnC;AACJ;;;;;;;;;;;;;;;;;;ACSD,IAAa,eAAb,MAAa,aAAa;CACtB;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA,YAAY;CACZ;CACA,gBAAgB,OAAO,CAAE;CACzB,YAAY,WAAW,SAAS;EAC5B,KAAKC,MAAM,UAAU,UAAU;EAE/B,KAAKC,eAAe,QAAQ,cAAc,UAAU,QAAQ,YAAY,GAAG,KAAKD,IAAI;EACpF,KAAKE,WAAW,QAAQ,WAAW,CAAC,IAAI,CAAC;EACzC,KAAKC,kBAAkB,QAAQ;EAC/B,KAAKC;EACL,MAAM,aAAa,QAAQ;AAC3B,MAAI,OAAO,eAAe,CAAC,SAAS,CAAC,EACjC,KAAKC,gBAAgB,SAAS,MAAM;GAChC,WAAW,KAAK,MAAM,KAAKL,IAAI;EAClC,GAAE,QAAQ,gBAAgB;EAE/B,IAAI,cAAc,QAAQ;EAC1B,gBAAgB,KAAKA,IAAI,uBAAuB;EAChD,KAAKM,gBAAgB;EACrB,KAAKC,eAAe;EACpB,KAAK,eAAe,YAAY;EAChC,KAAKC;AACL,MAAI,KAAKP,iBAAiB,SAAS,MAC/B,KAAKQ,aAAa;OAGlB,KAAKC,cAAc;CAE1B;CACD,QAAQ,QAAQ;AACZ,MAAI,KAAKC,UACL;EACJ,KAAKA,YAAY;AACjB,MAAI,KAAKC,mBAAmB;GACxB,KAAKA,kBAAkB,YAAY;GACnC,KAAKA,oBAAoB;EAC5B;CACJ;CACD,OAAO,aAAa,sBAAsB,SAAS;EAC/C,MAAM,KAAK,UAAU,qBAAqB;EAC1C,MAAM,KAAK,IAAI,aAAa,IAAI;GAC5B,GAAG;GACH,eAAe,MAAMC,MAAI;IACrBA,KAAG,QAAQ,KAAK;IAChBA,KAAG,SAAS,KAAK;AACjB,QAAI,QAAQ,gBACR,QAAQ,eAAe,MAAMA,KAAG;GACvC;EACJ;AACD,SAAO;CACV;CACD,OAAO,eAAe,sBAAsB,SAAS;EACjD,MAAM,KAAK,UAAU,qBAAqB;EAC1C,GAAG,MAAM,WAAW,CAAC,QAAQ,CAAC;EAC9B,GAAG,MAAM,UAAU,QAAQ,UAAU,GAAG,UAAU;EAClD,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;EACrB,GAAG,MAAM,MAAM,CAAC,GAAG,CAAC;EACpB,MAAM,OAAO;GAAE,GAAG;GAAS,aAAa,SAAS;EAAM;AACvD,SAAO,KAAK,aAAa,sBAAsB,KAAK;CACvD;;;;;;CAMD,OAAO,YAAY,KAAK,WAAW;EAC/B,MAAM,KAAK,IAAI,aAAa,KAAK;GAC7B,aAAa,SAAS;GACtB,SAAS,CAAC,IAAI,CAAC;GACf,eAAe,MAAM;IACjB,IAAI,aAAa,CAAC,KAAK,CAAC,EAAE,KAAK,MAAM,UAAU,CAAC;IAChD,IAAI,aAAa,CAAC,MAAM,CAAC,EAAE,KAAK,OAAO,UAAU,CAAC;AAClD,QAAI,WACA,UAAU,KAAK;GACtB;EACJ;AACD,SAAO;CACV;CACD,eAAe;EACX,MAAM,IAAI,KAAKZ;AACf,MAAI,CAAC,EACD,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;EAE1C,MAAM,IAAI,IAAI,eAAe,CAAC,YAAY;GACtC,KAAKa,gBAAgB,QAAQ;EAChC;EACD,EAAE,QAAQ,EAAE;EAEZ,MAAM,UAAU,KAAKC,0BAA0B,EAAE,uBAAuB,CAAC;EACzE,KAAK,OAAO;EACZ,KAAKH,oBAAoB;CAC5B;CACD,cAAc;EACV,MAAM,IAAI,IAAI,eAAe,CAAC,YAAY;GACtC,KAAKI,mBAAmB;EAC3B;EACD,EAAE,QAAQ,SAAS,gBAAgB;EACnC,KAAKJ,oBAAoB;EACzB,KAAKI,mBAAmB;CAC3B;CACD,oBAAoB;EAChB,KAAK,OAAO;GAAE,OAAO,OAAO;GAAY,QAAQ,OAAO;EAAa;EACpE,KAAKR,YAAY;GACb,GAAG;GAAG,GAAG;GACT,GAAG,KAAK;EACX;CACJ;;;;;;CAMD,eAAe,MAAM;EACjB,KAAKD,eAAe;EACpB,KAAKD,gBAAgB,KAAK,QAAQ,KAAK;CAC1C;CACD,IAAI,cAAc;AACd,SAAO,KAAKC;CACf;CACD,IAAI,WAAW;AACX,SAAO,KAAKC;CACf;CACD,0BAA0B,YAAY;EAClC,IAAI,EAAE,OAAO,QAAQ,GAAG;EACxB,IAAI,UAAU,KAAKN;AACnB,MAAI,YAAY,CAAC,GAAG,CAAC,EACjB,UAAU,QAAQ,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC;WAExC,YAAY,CAAC,GAAG,CAAC,EACtB,UAAU,QAAQ,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC;AAEjD,MAAI,YAAY,CAAC,KAAK,CAAC,EACnB,SAAS,QAAQ,KAAKI;WAEjB,YAAY,CAAC,MAAM,CAAC,EACzB,QAAQ,SAAS,KAAKA;AAG1B,MAAI,KAAKN,eAAe,aAAa;GACjC,MAAM,IAAI,kBAAkB,KAAKA,KAAK,CAAC,cAAc,CAAC,EAAE,CAAC,eAAe,CAAC,EAAE,CAAC,gBAAgB,CAAC,EAAE,CAAC,iBAAiB,CAAC,CAAC;GACnH,SAAU,EAAE,kBAAkB,EAAE;GAChC,UAAW,EAAE,iBAAiB,EAAE;EACnC;AACD,SAAO;GAAE;GAAO;EAAQ;CAC3B;CACD,gBAAgB,MAAM;EAClB,MAAM,MAAM,KAAK,GAAG,eAAe;EACnC,MAAM,aAAa;GAAE,OAAO,IAAI;GAAY,QAAQ,IAAI;EAAW;EACnE,KAAK,OAAO,KAAKe,0BAA0B,WAAW;EACtD,KAAKP,YAAY;GACb,GAAG;GAAG,GAAG;GACT,OAAO,WAAW;GAClB,QAAQ,WAAW;EACtB;CACJ;CACD,IAAI,KAAK,MAAM;QACC,MAAM,CAAC,IAAI,CAAC,CAAC;EACzB,KAAKJ,QAAQ;EACb,KAAKD,gBAAgB,MAAM,KAAKH,IAAI;EACpC,KAAKK,eAAe;CACvB;CACD,IAAI,OAAO;AACP,SAAO,KAAKD;CACf;AACJ;;;;;;;;;;;;;;;;;AC7KD,SAAgBa,kBAAgB,WAAW,QAAQ;AAC/C,QAAOC,cAAY,WAAW,OAAK,MAAM,IAAI,OAAO,CAAC;AACxD;;;;;;;;AAQD,SAAgBA,cAAY,WAAW,IAAI;CACvC,MAAM,SAAS,SAAS,UAAU;CAClC,IAAI;AACJ,SAAQ,OAAO,OAAf;EACI,KAAK,CAAC,GAAG,CAAC;GACN,qBAA8B,QAAQ,GAAG;AACzC;EACJ,KAAK,CAAC,IAAI,CAAC;GACP,uBAA+B,QAAQ,GAAG;AAC1C;EACJ,KAAK,CAAC,KAAK,CAAC;GACR,uBAAgC,QAAQ,GAAG;AAC3C;EACJ,QACI,OAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,OAAO,MAAM,4BAA4B,CAAC;CACpF;AACD,KAAI,CAAC,OACD,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAEhD,KAAI,OAAO,cAAc,CAAC,MAAM,CAAC,CAC7B,QAAO,YAAY,OAAO;AAE9B,QAAO;AACV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChCD,MAAM,OAAO,KAAK,KAAK;;;;;;AAavB,MAAa,aAAa,CACxBC,gCAC6B;AAC7B,KAAI,gCAAgC,KAClC,OAAM,IAAI,MACR,CAAC,uEAAuE,CAAC;AAG7E,KAAI,gCAAgC,OAClC,OAAM,IAAI,MACR,CAAC,4EAA4E,CAAC;CAIlF,MAAM,MACJ,uCAAuC,2BACnC,8BACA,uCAAuC,oBACrC,4BAA4B,WAAW,CAAC,EAAE,CAAC,CAAC,GAE5C,OAAO,gCAAgC,CAAC,MAAM,CAAC,GAC7C,UAA6B,4BAA4B,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,GAC1E;AACV,KAAI,QAAQ,KAAM,OAAM,IAAI,MAAM,CAAC,sCAAsC,CAAC;AAC1E,QAAO;AACR;;;;;;;AASD,MAAaC,eAAa,CACxBC,eACAC,iBACG;CACH,MAAM,MAAM,WAAW,cAAc;AACrC,QAAO;EACL;EACA,MAAMC,aAAmDC,MAA0B;GACjF,MAAM,KAAK,aAAa,KAAK;EAC9B;EACD,KAAKC,YAAuCD,MAA0B;GACpEE,OAAK,KAAK,YAAY,KAAK;EAC5B;EACD,KACEC,aACAC,MACM;GACN,KAAK,KAAK,aAAa,KAAK;EAC7B;EACD,OACEC,cACAL,MACM;GACN,OAAO,KAAK,cAAc,KAAK;EAChC;EACD,gBACEM,cACAC,MACM;GACN,gBAAgB,KAAK,cAAc,KAAK;EACzC;EACD,YAAYD,cAA8BN,MAA0B;GAClE,YAAY,KAAK,cAAc,KAAK;EACrC;EACD,IACEQ,aACAC,MACM;GACN,IAAI,KAAK,aAAa,KAAK;EAC5B;EACD,OACEC,eACAC,MACM;GACNC,SAAO,KAAK,eAAe,KAAK;EACjC;EACD,IACEC,YACAF,MACM;GACN,IAAI,KAAK,YAAY,KAAK;EAC3B;EACD,UACEG,OACAC,MAKM;AACN,OAAI,KAAK,WAAW,UAAa,iBAAiB,QAChD,OAAO;IAAE,GAAG;IAAM,QAAQ;KAAE,GAAG;KAAc,GAAG;KAAG,GAAG;IAAG;GAAE;GAE7D,UAAU,KAAK,OAAO,KAAK;EAC5B;CACF;AACF;;;;;;AA+BD,MAAM,SAAS,CAACJ,SACd,WAAW,KAAK,aAAa,KAAK,UAAU;;;;;;;AAQ9C,MAAMK,cAAY,CAChBC,KACAN,OAAoB,CAAE,GACtB,GAAG,kBACc;AACjB,KAAI,QAAQ,OAAW,OAAM,IAAI,MAAM,CAAC,aAAa,CAAC;CAGtD,MAAM,QAAQ,aAAa,IAAI,CAAC,KAAK,OAAO,KAAK,EAAE,GAAG,cAAc;CAGpE,MAAM,OAAO;AACb,QAAO;AACR;;;;;;;AAQD,MAAa,MAAM,CACjBM,KACAC,MACAP,OAAoB,CAAE,MACnB;CACHK,YAAU,KAAK,KAAK;CAEpB,MAAM,OAAO,CAACG,UAA4B;EACxC,IAAI,WAAW;EACf,IAAI,IAAIC,MAAI,GAAGA,MAAI,GAAGA,MAAI,QAAQA,MAAI,aAAaA,MAAI,UAAU;EACjE,IAAI,QAAQ;CACb;CAED,MAAMC,YAAkC,MAAM,QAAQ,KAAK,GAAG,OAAO,CAAE,IAAM;AAC7E,MAAK,MAAMD,SAAO,WAChB,KAAKA,MAAI;AAGZ;;;;;;;AAkCD,MAAM,aAAa,CACjBE,aACAC,cACY;CACZ,MAAM,QAAQ,CAACN,QAAkC;AAC/C,MAAI,WAAW,IAAI,YAAY;AAC/B,MAAI,aAAa,IAAI,cAAc;CACpC;AACD,QAAO;AACR;AAED,MAAM,SAAS,CACbO,WACAC,UACAC,YACY;CACZ,MAAM,QAAQ,CAACT,QAAkC;AAC/C,MAAI,WAAW,IAAI,YAAY;AAC/B,MAAI,UAAU,IAAI,WAAW;AAC7B,MAAI,SAAS,IAAI,UAAU;CAC5B;AACD,QAAO;AACR;;;;;;;AAQD,MAAa,eAAe,CAC1BA,KACAU,QACiB;CACjB,QAAQ,IAAI;CAEZ,MAAMC,SAAO,CAAC,GAAG,QAAiC;EAChD,QAAQ,IAAI;EACZ,MAAM,IAAI,IAAI,KAAK,GAAG,IAAI;AAC1B,OAAK,MAAM,KAAK,KAAK,EAAE,IAAI;AAC3B,SAAO,aAAa,KAAK,EAAE;CAC5B;CAED,MAAMC,QAAM,MAAoB;EAC9B,MAAM,IAAI,KAAK,KAAK;AACpB,SAAO,aAAa,KAAK,EAAE;CAC5B;CAED,MAAM,QAAQ,MAAoB;AAChC,MAAI,QAAQ,OAAW,QAAO,aAAa,IAAI;AAC/C,OAAK,MAAM,MAAM,IAAI,MAAM,GAAG,IAAI;AAClC,SAAO,aAAa,KAAK,IAAI;CAC9B;AAED,QAAO;EAAE;EAAM;EAAK;CAAO;AAC5B;;;;;;;AAQD,MAAa,oBAAoB,CAC/BZ,KACAa,QACA9B,SACS;CACTgB,YAAU,KAAK,KAAK;CAGpB,IAAI,OAAO,OAAQ,GAAI,GAAG,OAAQ,GAAI,EAAE;AAExC,MAAK,MAAM,CAAE,OAAO,EAAG,IAAI,OAAO,SAAS,EAAE;AAC3C,MAAI,QAAQ,KAAK,OAAO,OAAQ;EAChC,MAAM,QAAQ,OAAQ,QAAQ;EAC9B,MAAM,MAAM;GACV,IAAI,EAAE,IAAI,MAAM,KAAK;GACrB,IAAI,EAAE,IAAI,MAAM,KAAK;EACtB;EACD,MAAM,QAAQ,IAAI,IAAI,EAAE,KAAK;EAC7B,MAAM,QAAQ,IAAI,IAAI,MAAM,KAAK;EACjC,IAAI,iBAAiB,MAAM,MAAM,GAAG,IAAI,GAAG,IAAI,EAAE;EACjD,IAAI,iBAAiB,MAAM,MAAM,GAAG,MAAM,GAAG,MAAM,EAAE;CACtD;AACF;;;;;;;;;;;;;;;;;;;AAoBD,MAAaJ,WAAS,CACpBK,KACAc,eACApB,OAAoB,CAAE,MACnB;CACHK,YAAU,KAAK,KAAK;CAEpB,MAAM,OAAO,CAACgB,MAAgC;EAC5C,IAAI,WAAW;EACf,IAAI,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,QAAQ,GAAG,KAAK;AACpC,MAAI,KAAK,aAAa,IAAI,QAAQ;AAClC,MAAI,KAAK,WAAW,IAAI,MAAM;CAC/B;AAED,KAAI,MAAM,QAAQ,cAAc,CAC9B,MAAK,MAAM,KAAK,eAAe,KAAK,EAA8B;MAElE,KAAK,cAA0C;AAElD;;;;;;;;AASD,MAAa,UAAU,CACrBf,KACAgB,gBAGAtB,OAAoB,CAAE,MACnB;CACHK,YAAU,KAAK,KAAK;CAEpB,MAAM,OAAO,CAACkB,cAAwC;EACpD,IAAI,WAAW;EACf,MAAM,WAAWC,UAAQ,YAAY;EACrC,MAAM,aAAaA,UAAQ,cAAc;EACzC,MAAM,WAAWA,UAAQ,YAAY;EACrC,IAAI,QAAQA,UAAQ,GAAGA,UAAQ,GAAGA,UAAQ,SAASA,UAAQ,SAAS,UAAU,YAAY,SAAS;AACnG,MAAI,KAAK,aAAa,IAAI,QAAQ;AAClC,MAAI,KAAK,WAAW,IAAI,MAAM;CAC/B;CAED,MAAM,gBAAgB,MAAM,QAAQ,eAAe,GAAG,iBAAiB,CAAE,cAAgB;AACzF,MAAK,MAAMA,aAAW,eACpB,KAAKA,UAAQ;AAEhB;;;;;;;;AASD,MAAa,QAAQ,CACnBlB,KACAmB,aACAC,OAAoE,CAAE,MACnE;CACHrB,YAAU,KAAK,KAAK;CAEpB,MAAM,OAAO,CAACsB,WAAqB;AAEjC,wBAA8BC,OAAK,EAAE,gBAAgB,KAAKA,QAAM,KAAK;kBAC/CA,OAAK,EAAErC,OAAK,KAAKqC,QAAM,KAAK;MAC7C,OAAM,IAAI,MAAM,CAAC,kBAAkB,EAAG,KAAK,UAAUA,OAAK,EAAG;CACnE;AAED,KAAI,MAAM,QAAQ,YAAY,CAC5B,MAAK,MAAM,KAAK,aAAa,KAAK,EAAE;MAEpC,KAAK,YAA0B;AAElC;;;;;;;;;;;AAkBD,MAAa,kBAAkB,CAC7BtB,KACAuB,KACAC,OAAwC,CAAE,MACvC;CACH,MAAM,aAAa,KAAK,QAAQ;CAEhC,YAAY,UAAU,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAElC,KAAI,IAAI,WAAW,EAAG;AAGtB,MAAK,MAAM,CAAE,OAAO,GAAI,IAAI,IAAI,SAAS,UAAe,IAAI,CAAC,MAAM,EAAG,OAAQ,CAAC;CAE/EzB,YAAU,KAAK,KAAK;AAGpB,KAAI,KAAK,WAAW,IAAI,YAAY,KAAK;CACzC,IAAI,WAAW;CACf,IAAI,OAAO,IAAK,GAAI,GAAG,IAAK,GAAI,EAAE;AAClC,MAAK,MAAM,MAAM,KAAK,IAAI,OAAO,GAAG,GAAG,GAAG,EAAE;AAE5C,KAAI,YAAY,IAAI,OAAO,IAAK,GAAI,GAAG,IAAK,GAAI,EAAE;AAGlD,KACE,KAAK,eACJ,KAAK,gBAAgB,UAAa,KAAK,cAAc,QAEtD,IAAI,QAAQ;AAEd,KAAI,KAAK,WACP,IAAI,MAAM;AAEb;;;;;;;;AASD,MAAa,cAAc,CACzBC,KACAuB,KACAE,OAAwC,CAAE,GAC1CC,WACG;AACH,KAAI,IAAI,WAAW,EAAG;AAGtB,MAAK,MAAM,CAAE,OAAO,GAAI,IAAI,IAAI,SAAS,UAAe,IAAI,CAAC,MAAM,EAAG,OAAQ,CAAC;CAE/E3B,YAAU,KAAK,KAAK;AAEpB,MAAK,MAAM,CAAE,OAAO,GAAI,IAAI,IAAI,SAAS,EAAE;EACzC,MAAM,QACJ,WAAW,UAAa,QAAQ,OAAO,SAAS,OAAQ,SAAU,MAAM,UAAU;EACpF,IAAI,SAAS,MAAM,UAAU,EAAE,GAAG,GAAG,GAAG,EAAE;CAC3C;AACF;;;;;;;AAQD,MAAa,iBAAiB,CAC5BC,KACA2B,UACiB;CACjB,MAAM,IAAI,IAAI,cAAc;AAC5B,QAAO;EACL,GAAG,MAAM,IAAI,EAAE,IAAI,MAAM,IAAI,EAAE,IAAI,EAAE;EACrC,GAAG,MAAM,IAAI,EAAE,IAAI,MAAM,IAAI,EAAE,IAAI,EAAE;CACtC;AACF;;;;;;;;;;;;;AAcD,MAAa,YAAY,CAACC,aAAkD;CAC1E,MAAM,MAAM,SAAS,cAAc,CAAC,GAAG,CAAC,CAAC;CACzC,IAAI,MAAM,SAAS,UAAU,CAAC,UAAU,CAAC,CAAC;AAC1C,QAAO;AACR;;;;;;;AAeD,MAAa,MAAM,CACjB5B,KACA6B,KACArC,SACG;CACH,SAAS,CAAE;CACX,MAAM,SAAS,KAAK,UAAU;CAC9B,MAAM,YAAY,MAAM,QAAQ,IAAI,GAAG,MAAM,CAAE,GAAK;CACpD,MAAM,SAAS,KAAK,SAAS,KAAK,SAAS,KAAK,gBAAgB;CAChE,IAAI,SAAS,KAAK,SAAS,KAAK,SAAS,KAAK,cAAc;AAC5D,KAAI,CAAC,UAAU,CAAC,QAAQ,SAAS;CAEjCO,YAAU,KAAK,KAAK;AAEpB,MAAK,MAAM+B,SAAO,WAAW;EAC3B,IAAI,WAAW;AACf,MAAI,CAAC,MAAM,CAAC,IAAIA,OACd,IAAI,IAAIA,MAAI,GAAGA,MAAI,GAAGA,MAAI,QAAQ,GAAG,IAAI,KAAK,GAAG;OAEjD,IAAI,IAAIA,MAAI,GAAGA,MAAI,GAAG,QAAQ,GAAG,IAAI,KAAK,GAAG;AAE/C,MAAI,QACF,IAAI,MAAM;AAEZ,MAAI,QACF,IAAI,QAAQ;CAEf;AAwBF;;;;;;;AAQD,MAAa,SAAS,CACpB9B,KACAZ,cACAL,SACG;AACH,uBAA8B,aAAa,EACzC,gBAAgB,KAAK,cAAc,KAAK;wBACT,aAAa,EAC5C,YAAY,KAAK,cAAc,KAAK;AAEvC;AAED,MAAM,cAAc,CAClBiB,KACA+B,cACArC,OAAoB,CAAE,MACnB;CACH,IAAI,QAAQK,YAAU,KAAK,KAAK;CAEhC,MAAM,EAAE,GAAG,GAAG,QAAQ,QAAQ,GAAG;CACjC,MAAM,UAAU,KAAK,SAAS;AAE9B,KAAI,SAAS,CAKZ;CACD,IAAI,WAAW;CACf,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;CACpB,IAAI,cAAc,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,OAAO,GAAG,EAAE,GAAG,EAAE,EAAE;CACnE,IAAI,QAAQ;AAEZ,KAAI,SAAS;EACX,QAAQ,MAAM,KACZ,OAAO;GACL,GAAG;GACH,+BAAoC,KAAK,eAAe,CAAC,MAAM,CAAC,EAAE,GAAI;GACtE,6BAAkC,KAAK,aAAa,CAAC,MAAM,CAAC,EAAE,GAAI;EACnE,EAAC,CACH;EAED,MAAM,OAAO;EACb,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;EACpB,IAAI,OAAO,OAAO,GAAG,OAAO,EAAE;EAC9B,IAAI,QAAQ;EACZ,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;EACpB,IAAI,OAAO,OAAO,GAAG,OAAO,EAAE;EAC9B,IAAI,QAAQ;EAEZ,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;EAC/B,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;EAC/B,IAAI,SAAS,CAAC,EAAE,CAAC,EAAE,OAAO,IAAI,GAAG,OAAO,EAAE;EAC1C,IAAI,SAAS,CAAC,EAAE,CAAC,EAAE,OAAO,IAAI,GAAG,OAAO,EAAE;EAE1C,IAAI,KAAK,QAAQ,EAAE,QAAQ,EAAG,EAAC;EAC/B,IAAI,KAAK,QAAQ,EAAE,QAAQ,EAAG,EAAC;EAC/B,IAAI,KAAK,GAAG,EAAE,QAAQ,EAAG,EAAC;EAC1B,IAAI,KAAK,GAAG,EAAE,QAAQ,EAAG,EAAC;EAC1B,QAAQ,MAAM,KAAK;EACnB,MAAM,OAAO;CACd;AACF;AAED,MAAM,kBAAkB,CACtBC,KACAgC,cACAtC,OAAoB,CAAE,MACnB;CACH,MAAM,EAAE,GAAG,GAAG,WAAW,GAAG;CAC5B,MAAM,UAAU,KAAK,SAAS;CAC9B,IAAI,QAAQK,YAAU,KAAK,KAAK;CAEhC,IAAI,WAAW;CACf,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;CACpB,IAAI,iBAAiB,UAAU,GAAG,UAAU,GAAG,EAAE,GAAG,EAAE,EAAE;CACxD,IAAI,QAAQ;AAEZ,KAAI,SAAS;EAOX,QAAQ,MAAM,KACZ,OAAO;GACL,GAAG;GACH,+BAAoC,KAAK,eAAe,CAAC,MAAM,CAAC,EAAE,GAAI;GACtE,6BAAkC,KAAK,aAAa,CAAC,MAAM,CAAC,EAAE,GAAI;EACnE,EAAC,CACH;EACD,gBAAgB,KAAK;GAAE;GAAG;GAAW;EAAG,EAAC;EAEzC,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;EAC/B,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,IAAI,GAAG,EAAE,EAAE;EAC/B,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,UAAU,IAAI,GAAG,UAAU,EAAE;EAC/C,IAAI,KAAK,WAAW,EAAE,QAAQ,EAAG,EAAC;EAClC,IAAI,KAAK,GAAG,EAAE,QAAQ,EAAG,EAAC;EAC1B,IAAI,KAAK,GAAG,EAAE,QAAQ,EAAG,EAAC;EAK1B,QAAQ,MAAM,KAAK;EACnB,MAAM,OAAO;CACd;AACF;;;;;;;;;;;;AAaD,MAAad,SAAO,CAClBe,KACAiC,QACAC,OAA+B,CAAE,MAC9B;CACH,MAAM,UAAU,KAAK,SAAS;CAC9B,MAAM,IAAI,OAAO,KAAK,WAAW,KAAK,UAAU,KAAK,QAAQ;CAC7DnC,YAAU,KAAK,MAAM,EAAE;CAEvB,MAAM,OAAO,CAACoC,MAAkB;EAC9B,MAAM,EAAE,GAAG,GAAG,GAAG;EACjB,IAAI,WAAW;EACf,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;EACpB,IAAI,OAAO,EAAE,GAAG,EAAE,EAAE;AACpB,MAAI,SAAS;GACX,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE;GAC3B,IAAI,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE;GAC3B,IAAI,KAAK,GAAG;IAAE,QAAQ;IAAG,aAAa,CAAC,KAAK,CAAC;GAAE,EAAC;GAChD,IAAI,KAAK,GAAG;IAAE,QAAQ;IAAG,aAAa,CAAC,KAAK,CAAC;GAAE,EAAC;EACjD;EACD,IAAI,QAAQ;CACb;AAED,KAAI,MAAM,QAAQ,OAAO,CACvB,MAAK,MAAM,KAAK,QAAQ,KAAK,EAAgB;MAE7C,KAAK,OAAqB;AAE7B;;;;;;;AAQD,MAAa,WAAW,CACtBnC,KACAoC,QACAC,OAAoD,CAAE,MACnD;CACHtC,YAAU,KAAK,KAAK;CAEpB,MAAM,OAAO,CAACuC,MAA0B;EACtC,gBAAgB,eAAuB,EAAE,EAAE;GAAE,GAAG;GAAM,MAAM;EAAM,EAAC;AAEnE,MAAI,KAAK,OACP,YAAY,eAAuB,EAAE,EAAE,QAAW;GAAE,CAAC,CAAC,CAAC;GAAE,CAAC,CAAC,CAAC;GAAE,CAAC,CAAC,CAAC;EAAE,EAAC;CAEvE;AAED,KAAI,MAAM,QAAQ,OAAO,CACvB,MAAK,MAAM,KAAK,QACd,KAAK,EAAE;MAGT,KAAK,OAA6B;AAErC;;;;;;;;AA6BD,MAAa,OAAO,CAClBtC,KACAuC,QACAC,OAAiB,CAAE,MAChB;CACHzC,YAAU,KAAK,KAAK;CAEpB,MAAM,SAAS,KAAK,WAAW,KAAK,cAAc,SAAY,QAAQ;CACtE,MAAM,SAAS,KAAK,WAAW,KAAK,gBAAgB,SAAY,QAAQ;CACxE,MAAM,OAAO,CAAC0C,MAAyC;EACrD,MAAM,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,IAAI;EAC3B,MAAM,IAAI,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,IAAI;AAC3B,MAAI,QAAQ,IAAI,SAAS,GAAG,GAAG,EAAE,OAAO,EAAE,OAAO;AACjD,MAAI,QAAQ;AACV,OAAI,KAAK,aAAa,IAAI,YAAY,KAAK;GAE3C,IAAI,WAAW,GAAG,GAAG,EAAE,OAAO,EAAE,OAAO;EACxC;AACD,MAAI,KAAK,SAAS;GAChB,IAAI,WAAW;GACf,IAAI,OAAO,GAAG,EAAE;GAChB,IAAI,OAAO,EAAE,OAAO,EAAE,OAAO;GAC7B,IAAI,QAAQ;GACZ,IAAI,OAAO,GAAG,EAAE,OAAO;GACvB,IAAI,OAAO,EAAE,OAAO,EAAE;GACtB,IAAI,QAAQ;EACb;AACD,MAAI,KAAK,OACP,YAAY,aAAmB,EAAE,EAAE,QAAW;GAAE,CAAC,EAAE,CAAC;GAAE,CAAC,EAAE,CAAC;GAAE,CAAC,EAAE,CAAC;GAAE,CAAC,EAAE,CAAC;EAAE,EAAC;CAE5E;AAED,KAAI,MAAM,QAAQ,OAAO,CACvB,MAAK,MAAM,KAAK,QACd,KAAK,EAAE;MAGT,KAAK,OAA+B;AAEvC;;;;;;;;;AAUD,MAAa,YAAY,CACvBzC,KACA0C,QACA,UAAU,GACVC,kBACW;CACX,MAAMC,SAAO,SAAS,KAAKC,QAAM,SAAS,cAAc;AACxD,QAAOD,OAAK;AACb;AAED,MAAa,WAAW,CAAC5C,KACvB0C,QACA,UAAU,GAAGC,kBAAuC;AACpD,KAAIE,WAAS,UAAaA,WAAS,QAAQA,OAAK,WAAW,EAAG;CAC9D,MAAM,IAAI,IAAI,YAAYA,OAAK;CAE/B,MAAM,QAAS,gBAAiB,cAAc,EAAE,OAAO,cAAc,GAAG,UAAU,EAAE,QAAQ;AAE5F,QAAO;EACE;EACP,QAAQ,EAAE,0BAA0B,EAAE,2BAA2B,UAAU;CAC5E;AACF;AAED,MAAa,aAAa,CACxB7C,KACA0C,QACA,UAAU,MAAc;CACxB,MAAME,SAAO,SAAS,KAAKC,QAAM,QAAQ;AACzC,QAAOD,OAAK;AAIb;;;;;;;AASD,MAAa,YAAY,CACvB5C,KACA8C,OACAC,SAMG;CACHhD,YAAU,KAAK,KAAK;CACpB,MAAM,gBAAgB,KAAK,iBAAiB;CAC5C,MAAM,QAAQ,KAAK,SAAS,CAAC,GAAG,CAAC;CACjC,MAAM,SAAS,KAAK;CACpB,MAAM,SAAS,KAAK,UAAU;EAAE,GAAG;EAAG,GAAG;EAAG,OAAO;EAAW,QAAQ;CAAW;CAGjF,MAAM,SAAS,MAAM,IAAI,CAAC,MAAM,IAAI,YAAY,EAAE,CAAC;CAGnD,MAAM,SAAS,OAAO,IAAI,CAAC,OAAO,GAAG,MAAM;CAC3C,MAAM,UAAU,OAAO,IACrB,CAAC,OAAO,GAAG,0BAA0B,GAAG,2BAA2B,EACpE;CAGD,MAAM,WAAW,KAAK,IAAI,GAAG,OAAO;CACpC,MAAM,cAAc,QAAQ,OAAO,CAAC,aAAa,UAAU,cAAc,OAAO,EAAE;CAElF,IAAI,EAAE,GAAG,GAAG,GAAG;AAEf,KAAI,OAAO,IAAI,WAAW,OAAO,OAC/B,IAAI,OAAO,SAAS,WAAW;MAC1B,KAAK;AAEZ,KAAI,IAAI,OAAO,GAAG,IAAI,OAAO,IAAI;AAEjC,KAAI,OAAO,IAAI,cAAc,OAAO,QAClC,IAAI,OAAO,UAAU,cAAc;MAC9B,KAAK;AAEZ,KAAI,IAAI,OAAO,GAAG,IAAI,OAAO,IAAI;AAEjC,KAAI,UAAU,CAAC,GAAG,CAAC,EACjB,IAAI,eAAe,CAAC,GAAG,CAAC;MAExB,IAAI,eAAe,CAAC,MAAM,CAAC;AAE7B,MAAK,MAAM,CAAE,OAAOd,OAAM,IAAI,MAAM,SAAS,EAAE;EAC7C,IAAI,SAASA,QAAM,GAAG,EAAE;EACxB,KAAK,QAAS;CACf;AACF;;;;AAQD,MAAa,mBAAmB,CAC9Be,KACAgD,QACAC,SAKG;CACH,MAAM,EAAE,QAAQ,GAAG;CACnB,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,EAAE,GAAG;CAEzC,MAAM,QAAQ,OAAOJ,WAAS,CAAC,MAAM,CAAC,GAAG,CAAEA,MAAM,IAAGA;CAEpD9C,YAAU,KAAK,KAAK;CAEpB,IAAI,MAAM;CACV,IAAI,UAAU,OAAO,GAAG,OAAO,EAAE;CACjC,IAAI,YAAY,CAAC,IAAI,CAAC;CACtB,IAAI,eAAe,CAAC,GAAG,CAAC;CACxB,MAAM,UAAU,OAAO,QAAQ;CAC/B,MAAM,UAAU,OAAO,SAAS;CAGhC,MAAM,SAAS,MAAM,IAAI,CAAC,MAAM,IAAI,YAAY,EAAE,CAAC;CACnD,MAAM,UAAU,OAAO,IACrB,CAAC,OAAO,GAAG,0BAA0B,GAAG,yBACzC;CACD,MAAM,cAAc,QAAQ,OAAO,CAAC,aAAa,UAAU,cAAc,OAAO,EAAE;CAElF,IAAI,IAAI;AACR,KAAI,SAAS,CAAC,MAAM,CAAC,EAAE,IAAI,UAAU,cAAc;UAC1C,SAAS,CAAC,MAAM,CAAC,EACxB,IAAI,OAAO,SAAS;AAGtB,MAAK,MAAM,CAAE,OAAOd,OAAM,IAAI,MAAM,SAAS,EAAE;EAC7C,IAAI,IAAI;AACR,MAAI,UAAU,CAAC,MAAM,CAAC,EAAE,IAAI,UAAU,OAAQ,OAAQ,QAAQ;WACrD,UAAU,CAAC,KAAK,CAAC,EAAE,IAAI,OAAO,QAAQ,OAAQ,OAAQ;EAC/D,IAAI,SAASA,QAAM,GAAG,EAAE;EACxB,KAAK,QAAS;CACf;CAED,IAAI,SAAS;AACd;;;;AC3/BD,MAAa,QAAQ,CAACiE,MAAqB;AACzC,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,QAAO;AAClC,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,IAAI,CAAC,IAAI,GAAI,QAAO;AAC3B,KAAI,EAAE,CAAC,KAAK,CAAC,IAAI,GAAI,QAAO;AAC5B,KAAI,EAAE,UAAU,CAAC,GAAG,CAAC,CAAE,QAAO;AAC9B,QAAO;AACR;AAED,MAAa,QAAQ,CAACA,MAAqB;AACzC,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,QAAO;AAClC,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,KAAK,CAAC,IAAI,GAAI,QAAO;AAC5B,KAAI,EAAE,CAAC,IAAI,CAAC,IAAI,GAAI,QAAO;AAC3B,KAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAE,QAAO;AAC/B,QAAO;AACR;;;;;;;;;;;;;AAeD,MAAa,sBAAsB,CAACA,MAA4B;AAC9D,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,GAAI;AACzC,KAAI,EAAE,CAAC,IAAI,CAAC,IAAI,GACd,KAAI,EAAE,KAAK,KAAK,EAAE,KAAK,KAAK,EAAE,KAAK,GACjC,EAAE,OAAO,CAAC,MAAM,CAAC;UACR,EAAE,IAAI,OAAO,EAAE,KAAK,OAAO,EAAE,KAAK,IAC3C;MAEA,EAAE,OAAO,CAAC,IAAI,CAAC;AAGnB,KAAI,EAAE,CAAC,KAAK,CAAC,IAAI,IACf,EAAE,QAAQ,CAAC,IAAI,CAAC;AAElB,QAAO;AACR;AAED,MAAa,sBAAsB,CAACA,MAA4B;AAC9D,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC,IAAI,GAAI;AACzC,KAAI,EAAE,CAAC,IAAI,CAAC,IAAI,GACd,KAAI,EAAE,KAAK,KAAK,EAAE,KAAK,KAAK,EAAE,KAAK,GACjC,EAAE,OAAO,CAAC,MAAM,CAAC;UACR,EAAE,IAAI,OAAO,EAAE,KAAK,IAC7B;MAEA,EAAE,OAAO,CAAC,QAAQ,CAAC;AAGvB,KAAI,EAAE,CAAC,KAAK,CAAC,IAAI,IACf,EAAE,QAAQ,CAAC,GAAG,CAAC;AAEjB,QAAO;AACR;AAED,MAAa,UAAU,CAACA,MAAuB;AAC7C,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,QAAO;AAClC,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,CAAC,CAAC,IAAI,GAAI,QAAO;AACxB,KAAI,EAAE,CAAC,IAAI,CAAC,IAAI,GAAI,QAAO;AAC3B,KAAI,EAAE,CAAC,KAAK,CAAC,IAAI,GAAI,QAAO;AAC5B,KAAI,EAAE,UAAU,CAAC,GAAG,CAAC,CAAE,QAAO;AAC9B,KAAI,EAAE,UAAU,CAAC,KAAK,CAAC,CAAE,QAAO;AAChC,QAAO;AACR;AAED,MAAa,cAAc,CAACA,MAA2B;AACrD,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,QAAO;AAClC,KAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CAAE,QAAO;AAClC,KAAI,MAAM,EAAE,CAAE,QAAO;AACrB,KAAI,QAAQ,EAAE,CAAE,QAAO;AACvB,KAAI,MAAM,EAAE,CAAE,QAAO;AACrB,QAAO;AACR;;;;AC1FD,SAAgB,qBAAqBC,GAAWC,GAAW,QAAQ,GAAG;CACpE,IAAI,OAAO;CACX,IAAI,QAAQ;AACZ,KAAI,IAAI,GAAG;EACT,OAAQ,IAAI;EACZ,QAAQ,SAAS,IAAI;CACtB,OAAM;EACL,OAAQ,IAAI;EACZ,QAAS,OAAQ;CAClB;CACD,MAAM,UAAU,QAAQ,IAAI,QAAQ;CACpC,MAAM,WAAW,QAAQ,IAAI,OAAO;AACpC,KAAI,KAAK,IAAI,KAAK,GAAG,KAAK,IAAI,MAAM,EAAE;EACpC,MAAM,IAAI;EACV,QAAQ;EACR,OAAO;CACR;AACD,QAAO;EAAE;EAAM;EAAO;EAAS;CAAU;AAC1C;AAED,SAAgB,cAAcC,OAAe;CAC3C,QAAQ,QAAQ;AAChB,KAAI,QAAQ,EAAG,SAAQ,IAAI,KAAK,IAAI,MAAM,IAAI;AAC9C,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACJD,MAAaC,gBAAc,CAAgBC,OAAUC,OAAuD;AAC1G,SAAQ,MAAM,MAAd;EACE,KAAK,CAAC,QAAQ,CAAC,CACb,QAAO;GACL,GAAG;GACH,SAAS,IAAI,MAAM,WAAW,OAAO,KAAK,MAAM,GAAG;EACpD;EACH,KAAK,CAAC,MAAM,CAAC,CACX,QAAO;GACL,GAAG;GACH,SAAS,GAAI,MAAM,WAAW,GAAI,MAAM;EACzC;CACJ;AACF;;;;;;;;;;;;;;;;;;;;;;;AAwBD,MAAaC,oBAAkB,CAACC,OAAYC,WAA2E;CACrH,IAAI,OAAO;AACX,KAAI,OAAO,OAAO,WAAW,CAAC,SAAS,CAAC,EACtC,OAAO,MAAM,IAAK,MAAM,IAAI,OAAO;UAC1B,OAAO,OAAO,UAAU,CAAC,SAAS,CAAC,EAC5C,OAAO,OAAO,QAAQ,MAAM;UACnB,OAAO,OAAO,UAAU,CAAC,SAAS,CAAC,EAAE;AAC9C,MAAI,OAAO,QAAQ,EAAG,OAAM,IAAI,UAAU,CAAC,sCAAsC,CAAC;EAClF,OAAO,OAAO;CACf,MACC,OAAM,IAAI,UAAU,CAAC,6DAA6D,CAAC;AAErF,QAAO;EACL,GAAG;EACH,GAAG,cAAc,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;CACnC;AACF;AAED,MAAM,gBAAgB,CAACC,KAAUC,OAAeC,aAA8B;AAC5E,KAAI,IAAI,SAAS,CAAC,MAAM,CAAC,EAEvB;MAAI,QAAQ,GAAG,QAAQ;WACd,QAAQ,GAAG,QAAQ;CAAE,WAG1B,QAAQ,KAAK,QAAQ;UAChB,QAAQ,GAAG,QAAQ;AAE9B,QAAO;AACR;AAED,MAAM,iBAAiB,OAAO,OAAO;CACnC,GAAG;CAAG,GAAG;CAAG,GAAG;CAAG,SAAS;CAAG,MAAM,CAAC,QAAQ,CAAC;CAAE,OAAO,CAAC,GAAG,CAAC;AAC7D,EAAC;AAIF,SAAgBC,gBAAcC,WAAmBC,UAA+B,CAAE,GAAO;AACvF,QAAOC,sBAAsB,UAAU,EAAE,QAAQ;AAClD;AAGD,SAAgBC,UAAQC,OAAeC,UAAwC,CAAE,GAAO;CACtF,QAAQ,MAAM,aAAa;AAE3B,KAAI,MAAM,WAAW,CAAC,KAAK,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;AACrE,KAAI,MAAM,WAAW,CAAC,KAAK,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;AAErE,KAAI,MAAM,WAAW,CAAC,CAAC,CAAC,CAAC,CACvB,QAAON,gBAAc,OAAO,QAAQ;AAEtC,KAAI,MAAM,WAAW,CAAC,EAAE,CAAC,CAAC,CACxB,KAAI;EACF,QAAQ,WAAW,MAAM;CAC1B,SAAQ,OAAO;AACd,MAAI,OAAO,QAAQ,mBAAmB,CAAC,SAAS,CAAC,EAAE,QAAQ,QAAQ;AACnE,MAAI,OAAO,QAAQ,mBAAmB,CAAC,SAAS,CAAC,CAAE,QAAO,QAAQ;AAClE,QAAM;CACP;AAEH,KAAI,UAAU,CAAC,WAAW,CAAC,CAAE,QAAO;AACpC,KAAI,OAAO,qBAAsB,WAAY,CAAC,SAAS,CAAC,CACtD,QAAOA,gBAAc,qBAAsB,QAAmB,QAAQ;AAGxE,KAAI,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;EAC5B,MAAM,MAAMO,aAAgB,MAAM;AAClC,SAAOJ,cAAY,KAAK,QAAQ;CACjC;AAED,KAAI,CAAC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,CAC3B,KAAI;EACF,gBAAkB,OAAO,CAAC,GAAG,CAAC,CAAC;CAChC,SAAQ,OAAO;AACd,MAAI,QAAQ,gBACV,QAAQ,QAAQ;MAEhB,OAAM;CAET;AAGH,KAAI;EAEF,MAAM,MAAM,oBAAoB,MAAM;AACtC,MAAI,QAAQ,OAAQ,QAAOK,WAAS,IAAI;AACxC,SAAOC,aAAW,IAAI;CACvB,SAAQ,OAAO;AACd,MAAI,QAAQ,eAAgB,QAAO,QAAQ;AAC3C,QAAM;CACP;AAEF;AAED,MAAa,cAAc,CAACZ,QAAqB;CAC/C,MAAM,MAAMY,aAAW,IAAI;CAC3B,IAAI,MAAM,CAAC,IAAI,EAAG,IAAI,EAAG,IAAI,EAAG,IAAI,EAAG,EAAE,EAAG,IAAI,EAAG,CAAC,CAAC;AACrD,KAAI,CAAC,OAAO,CAAC,IAAI,OAAO,IAAI,YAAY,UAAa,IAAI,UAAU,KACjE,OAAO,CAAC,GAAG,EAAG,IAAI,QAAS,CAAC,CAAC;CAE/B,OAAO;AACP,QAAO;AACR;AAaD,SAASN,cAA2BO,KAAYC,iBAAoC,CAAE,GAAK;AACzF,KAAI,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,MACxC;MAAI,eAAe,eAAgB,QAAO,eAAe;CAAe;CAE1E,MAAM,YAAY,eAAe,UAAU;CAG3C,YACE,yBAAyB,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EAC5C,yBAAyB,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EAC5C,yBAAyB,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EAC5C,YAAa,IAAI,SAAS,GAAI,CAAC,KAAK,CAAC,CAAC,CAEvC;AACD,KAAI,UACF,QAAO,OAAO,IAAI,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,KAAM,IAAI,SAAS,EAAG;KAEtE,QAAOC,WAAS,IAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI,SAAS,KAAK,IAAI;AAE/D;AAED,MAAaH,eAAa,CAACI,gBAAiD;AAI1E,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,QAAOT,UAAQ,aAAa,EAAE,QAAQ,MAAO,EAAC;AAQhD,KAAI,MAAM,YAAY,CACpB,QAAOK,aAAWN,cAAYI,aAAgB,YAAY,EAAE,EAAE,QAAQ,MAAO,EAAC,CAAC;CAEjF,MAAM,MAAM;CACZO,QAAM,IAAI;AACV,KAAI,IAAI,SAAS,CAAC,QAAQ,CAAC,CAAE,QAAO;AACpC,QAAO;EACL,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,UAAU,IAAI,WAAW,KAAK;EAC9B,MAAM,CAAC,QAAQ,CAAC;EAChB,OAAO,CAAC,GAAG,CAAC;CACb;AACF;;;;;;;;;;;;;;;;;;AAmBD,MAAaC,mBAAiB,CAACC,uBAAgD,aAAa,GAAGC,cAAY,IAAK,UAAU,MAAiB;AAEzI,KAAI,OAAO,0BAA0B,CAAC,MAAM,CAAC,EAC3C;MAAI,sBAAsB,WAAW,CAAC,EAAE,CAAC,CAAC,EACxC,wBAAwB,iBAAiB,SAAS,KAAK,CAAC,iBAAiB,sBAAsB,CAAC,MAAM;CACvG;CAEH,MAAM,MAAM,WAAW,sBAAsB;AAC7C,KAAI,aAAa,EAAG,OAAM,IAAI,UAAU,CAAC,uCAAuC,CAAC;AACjF,KAAIA,cAAY,EAAG,OAAM,IAAI,UAAU,CAAC,sCAAsC,CAAC;AAC/E,KAAI,UAAU,EAAG,OAAM,IAAI,UAAU,CAAC,oCAAoC,CAAC;CAC3E,MAAM,SAAS,aAAa,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ;AAChD,QAAO;EACL,GAAG;EACH,GAAG;EACH,GAAGA;EACM;EACT,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,GAAG,CAAC;CACb;AACF;;;;;;;;;;;;AAaD,MAAaT,aAAW,CAACU,gBAA+C;AACtE,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,QAAOd,UAAQ,aAAa,EAAE,QAAQ,KAAM,EAAC;AAQ/C,KAAI,MAAM,YAAY,CACpB,QAAOI,WAASL,cAAYI,aAAgB,YAAY,EAAE,EAAE,QAAQ,KAAM,EAAC,CAAC;CAG9E,MAAM,MAAM;CACZO,QAAM,IAAI;AACV,KAAI,IAAI,SAAS,CAAC,MAAM,CAAC,CAAE,QAAO;AAClC,QAAO;EACL,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,UAAU,IAAI,WAAW,KAAK;EAC9B,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,GAAG,CAAC;CACb;AACF;AAED,MAAaA,UAAQ,CAACjB,QAAa;CACjC,MAAM,EAAE,GAAG,GAAG,GAAG,SAAS,OAAO,MAAM,GAAG;AAC1C,KAAI,UAAU,CAAC,GAAG,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,oCAAoC,EAAG,OAAQ;AACrF,KAAI,SAAS,CAAC,QAAQ,CAAC,EACrB,YACE,WAAW,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAC5B,yBAAyB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EACxC,yBAAyB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EACxC,MAAM;AACJ,MAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC7B,QAAO,yBAAyB,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;CAE9D,EAAC;UACK,SAAS,CAAC,MAAM,CAAC,EAC1B,YACE,WAAW,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAChC,WAAW,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAChC,WAAW,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAChC,MAAM;AACJ,MAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC7B,QAAO,WAAW,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;CAEtD,EAAC;KAEJ,OAAM,IAAI,MAAM,CAAC,oDAAoD,EAAG,MAAO;AAElF;AAED,MAAasB,iBAAe,CAACC,GAAiBC,GAAiBC,YAAkC,CAAC,OAAO,CAAC,KAAK;CAC7G,IAAId,WAAS,EAAE;CACf,IAAIA,WAAS,EAAE;CACf,MAAM,WAAW,EAAE,WAAW;CAC9B,MAAM,eAAe,qBAAqB,EAAE,GAAG,EAAE,GAAG,EAAE;CACtD,MAAM,cAAc,cAAc,CAAC,MAAM,CAAC,GAAG,aAAa,OAAO,aAAa;CAC9E,MAAM,cAAc,EAAE,IAAI,EAAE;CAC5B,MAAM,gBAAgB,EAAE,IAAI,EAAE;CAC9B,MAAM,mBAAmB,EAAE,WAAW,KAAK;AAE3C,QAAO,CAACe,WAA8B;EACpC,SAAS,MAAM,OAAO;EACtB,IAAI,IAAI,YAAY,QAAQ,GAAG,KAAK,IAAI,YAAY,CAAC;AACrD,MAAI,cAAc,GAAG,IAAI,EAAE,IAAI;OAC1B,IAAI,EAAE,IAAI;EAEf,MAAM,IAAI,YAAY,QAAQ,GAAG,YAAY;EAC7C,MAAM,IAAI,YAAY,QAAQ,GAAG,cAAc;EAC/C,MAAM,IAAI,YAAY,QAAQ,GAAG,gBAAgB;AACjD,SAAO,OAAO,cAAc,EAAE,EAAE,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,SAAS;CAChE;AACF;;;;;;;;;AAUD,SAAgB,OAAO,MAAM,IAAK,MAAM,GAAGN,cAAY,IAAK,UAAU,GAAc;CAClF,MAAMO,MAAiB;EACrB,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,GAAG,CAAC;EACZ,GAAG;EACH,GAAG;EACH,GAAGP;EACM;CACV;CACDH,QAAM,IAAI;AACV,QAAO;AACR;AAED,SAAgBF,WAAS,MAAM,KAAK,MAAM,KAAKK,cAAY,IAAI,UAAU,KAAkB;CACzF,MAAMQ,MAAmB;EACvB,MAAM,CAAC,QAAQ,CAAC;EAChB,OAAO,CAAC,GAAG,CAAC;EACZ,GAAG;EACH,GAAG;EACH,GAAGR;EACM;CACV;CACDH,QAAM,IAAI;AACV,QAAO;AACR;;;;;AAMD,SAAgB,oBAAoBT,OAAoB;AACtD,KAAI,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;AACvE,KAAI,CAAC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;CAE5E,MAAM,QAAQ,MAAM,QAAQ,IAAI;CAChC,MAAM,MAAM,MAAM,QAAQ,IAAI;AAC9B,KAAI,MAAM,MAAO,OAAM,IAAI,MAAM,CAAC,oCAAoC,CAAC;CAEvE,MAAM,OAAO,MAAM,UAAU,QAAQ,GAAG,IAAI;CAC5C,IAAI,QAAQ,KAAK,MAAM,SAAS;AAChC,KAAI,MAAM,SAAS,EAAG,OAAM,IAAI,MAAM,CAAC,4BAA4B,EAAG,MAAM,OAAQ,OAAO,CAAC;CAE5F,IAAI,iBAAiB;AACrB,KAAI,MAAO,GAAI,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,iBAAiB;AAC/C,KAAI,MAAO,GAAI,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,MAAO,GAAI,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE,iBAAiB;CAE3E,MAAM,gBAAgB,CAACqB,GAAWC,QAAgB;AAChD,MAAI,MAAM,CAAC,IAAI,CAAC,CAAE,QAAO;AACzB,MAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CACjB,QAAO,OAAO,WAAW,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE,CAAC,GAAG;AAE3D,MAAI,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,QAAQ,GAC/B,IAAI,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE;EAGlC,MAAM,KAAK,OAAO,WAAW,EAAE;AAC/B,MAAI,QAAQ,EAAG,QAAO,KAAK;AAC3B,MAAI,QAAQ,EAAG,QAAO;AACtB,SAAO,KAAK;CACb;CAED,MAAM,aAAa,CAACD,GAAWC,QAAgB;AAC7C,MAAI,MAAM,CAAC,IAAI,CAAC,CAAE,QAAO;AACzB,MAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;GACnB,MAAMC,OAAK,OAAO,WAAW,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE,CAAC;AAC1D,OAAI,QAAQ,EAAG,QAAOA,OAAK;AAC3B,UAAOA;EACR;AACD,MAAI,EAAE,SAAS,CAAC,GAAG,CAAC,CAAC,IAAI,QAAQ,EAC/B,QAAO,OAAO,WAAW,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE,CAAC;EAExD,MAAM,KAAK,OAAO,WAAW,EAAE;AAC/B,SAAO;CACR;AAGD,KAAI,MAAM,SAAS,GACjB;MAAI,MAAO,OAAQ,KAEjB,QAAQ;GAAE,MAAO;GAAK,MAAO;GAAK,MAAO;GAAK,MAAO;EAAK;CAC3D;AAEH,KAAI,eACF,QAAO,OACL,cAAc,MAAO,IAAK,EAAE,EAC5B,cAAc,MAAO,IAAK,EAAE,EAC5B,cAAc,MAAO,IAAK,EAAE,EAC5B,cAAc,MAAO,MAAO,CAAC,IAAI,CAAC,EAAE,EAAE,CACvC;KAGD,QAAOhB,WACL,WAAW,MAAO,IAAK,EAAE,EACzB,WAAW,MAAO,IAAK,EAAE,EACzB,WAAW,MAAO,IAAK,EAAE,EACzB,WAAW,MAAO,MAAO,CAAC,IAAI,CAAC,EAAE,EAAE,CACpC;AAEJ;;;;;;AAOD,SAAgB,aAAaiB,KAA0B;AACrD,KAAI,OAAO,QAAQ,CAAC,MAAM,CAAC,EAAE;EAC3B,MAAM,cAAczB,UAAQ,KAAK,EAAE,QAAQ,MAAO,EAAC;AAEnD,SAAO,aAAa,YAAY;CACjC;CACD,MAAMK,aAAW,IAAI;CAErB,MAAM,cAAgB;EAAE,GAAG,IAAI;EAAG,GAAG,IAAI;EAAG,GAAG,IAAI;CAAG,EAAC;AACvD,QAAO;EAAE,GAAG;EAAK,QAAQ,IAAI,WAAW,OAAO,MAAM;CAAK;AAC3D;;;;;;;;;;;;;;;;;;;;AChdD,MAAa,mBAAmB;AAEhC,MAAaqB,UAAQ,CAACC,QAAe;CACnC,MAAM,EAAE,GAAG,GAAG,GAAG,SAAS,OAAO,MAAM,GAAG;AAC1C,KAAI,UAAU,CAAC,KAAK,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,sCAAsC,EAAG,OAAQ;AAEzF,KAAI,SAAS,CAAC,QAAQ,CAAC,EACrB,YACE,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,EACnB,MAAM;AACJ,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACvB,QAAO,yBAAyB,GAAG,GAAG,kBAAkB,CAAC,CAAC,CAAC,CAAC;CAE/D,GACD,MAAM;AACJ,MAAI,OAAO,MAAM,CAAC,MAAM,CAAC,CACvB,QAAO,yBAAyB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;CAElD,GACD,YAAa,WAAW,GAAI,CAAC,OAAO,CAAC,CAAC,CACvC;UACQ,SAAS,CAAC,MAAM,CAAC,EAE1B,YACE,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,EACnB,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,EACnB,YAAY,GAAG,CAAC,CAAC,CAAC,CAAC,EACnB,YAAa,IAAI,WAAW,GAAI,CAAC,OAAO,CAAC,CAAC,CAC3C;KAED,OAAM,IAAI,MAAM,CAAC,oDAAoD,EAAG,MAAO;AAElF;;;;;;;;;;;;;;AAiBD,SAAgBC,cAAYC,KAAYC,iBAAwC,CAAE,GAAS;AACzF,KAAI,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,QAAQ,MACxC;MAAI,eAAe,eAAgB,QAAO,eAAe;CAAe;CAG1E,MAAM,eAAe,eAAe,UAAU;CAG9C,YACE,YAAY,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,EACvB,YAAY,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,EACvB,yBAAyB,IAAI,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EAC5C,YAAa,IAAI,SAAS,GAAI,CAAC,KAAK,CAAC,CAAC,CACvC;AAED,KAAI,aACF,QAAOC,SAAO,IAAI,GAAG,IAAI,IAAI,kBAAkB,IAAI,IAAI,KAAM,IAAI,SAAS,EAAG;KAE7E,QAAO,SAAS,IAAI,GAAG,IAAI,GAAG,IAAI,GAAI,IAAI,SAAS,EAAG;AAGzD;AAED,MAAaC,kBAAgB,CAACC,WAAmBC,UAAiC,CAAE,MAAY;AAC9F,QAAON,wBAAwB,UAAU,EAAE,QAAQ;AACpD;AAED,MAAMO,mBAAkC,OAAO,OAAO;CACpD,GAAG;CAAG,GAAG;CAAG,GAAG;CAAG,SAAS;CAAG,MAAM,CAAC,QAAQ,CAAC;CAAE,OAAO,CAAC,KAAK,CAAC;AAC/D,EAAC;AAGF,SAAgBC,UAAQC,OAAeH,UAAiC,CAAE,GAAS;CACjF,QAAQ,MAAM,aAAa;AAC3B,KAAI,MAAM,WAAW,CAAC,CAAC,CAAC,CAAC,CACvB,QAAOF,gBAAc,OAAO,QAAQ;AAEtC,KAAI,UAAU,CAAC,WAAW,CAAC,CAAE,QAAO;AACpC,KAAI,OAAO,qBAAsB,WAAY,CAAC,SAAS,CAAC,CACtD,QAAOA,gBAAc,qBAAsB,QAAmB,QAAQ;AAGxE,KAAI,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;EAC5B,MAAM,MAAMM,OAAU,oBAAoB,MAAM,CAAC;EACjD,MAAMC,kBAAkB;GAAE,GAAG,IAAI;GAAG,GAAG,IAAI;GAAG,GAAG,IAAI;EAAG,EAAC;AACzD,SAAOX,cAAYW,OAAK,QAAQ;CACjC;AAED,KAAI,CAAC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,WAAW,CAAC,MAAM,CAAC,CAAC,CAC1D,KAAI;EACF,MAAM,oBAAsB,OAAO,CAAC,KAAK,CAAC,CAAC;EAC3C,QAAQ;CACT,SAAQ,OAAO;AACd,MAAI,QAAQ,gBACV,QAAQ,QAAQ;MAEhB,OAAM;CAET;CAEH,MAAM,KAAK,IAAIC,cAAS;CACxB,MAAM,MAAM,GAAG;AACf,QAAOZ,cAAY,KAAK,QAAQ;AAOjC;;;;;;;;;;;AAcD,MAAa,aAAa,CAACa,gBAA+C;AACxE,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,QAAO,WAAWL,UAAQ,aAAa,EAAE,QAAQ,KAAM,EAAC,CAAC;CAE3DV,QAAM,YAAY;AAClB,KAAI,YAAY,SAAS,CAAC,QAAQ,CAAC,CAAE,QAAO;AAC5C,QAAO;EACL,OAAO,CAAC,KAAK,CAAC;EACd,MAAM,CAAC,QAAQ,CAAC;EAChB,GAAG,YAAY;EACf,GAAG,YAAY,IAAI;EACnB,GAAG,YAAY,IAAI;EACnB,SAAS,YAAY;CACtB;AACF;AAGD,MAAagB,aAAW,CAACD,gBAA6C;AACpE,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,QAAOC,WAASN,UAAQ,aAAa,EAAE,QAAQ,KAAM,EAAC,CAAC;CAEzD,MAAM,MAAM;CACZV,QAAM,IAAI;AAIV,KAAI,IAAI,SAAS,CAAC,MAAM,CAAC,CAAE,QAAO;AAGlC,QAAO;EACL,GAAG,IAAI;EACP,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,SAAU,IAAI,WAAW;EACzB,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,KAAK,CAAC;CACf;AACF;;;;;;;;AA8BD,MAAaiB,gBAAc,CAAChB,KAAY,YAAY,MAAc;CAChED,QAAM,IAAI;CACV,MAAM,EAAE,GAAG,GAAG,GAAG,SAAS,GAAG;CAC7B,IAAI,MAAM,EAAE;AACZ,SAAQ,IAAI,MAAZ;EACE,KAAK,CAAC,QAAQ,CAAC;GACb,MAAM,CAAC,MAAM,GAAI,IAAI,KAAK,QAAQ,UAAU,CAAE,EAAE,EAAG,EAAE,QAAQ,UAAU,CAAE,CAAC,EAAG,EAAE,QAAQ,UAAU,EAAG;AACpG;EACF,KAAK,CAAC,MAAM,CAAC;GACX,MAAM,CAAC,MAAM,EAAG,EAAE,QAAQ,UAAU,CAAE,CAAC,GAAI,IAAI,kBAAkB,QAAQ,UAAU,CAAE,CAAC,GAAI,IAAI,KAAK,QAAQ,UAAU,EAAG;AACxH;CACH;AACD,KAAI,OAAO,YAAY,CAAC,SAAS,CAAC,IAAI,YAAY,GAChD,OAAO,CAAC,GAAG,EAAG,QAAQ,QAAQ,UAAU,EAAG;CAE7C,OAAO,CAAC,CAAC,CAAC;AACV,QAAO;AACR;AAoED,MAAa,iBAAiB,CAACkB,uBAAgD,SAAS,GAAGC,cAAY,IAAK,UAAU,MAAmB;AAEvI,KAAI,OAAO,0BAA0B,CAAC,MAAM,CAAC,EAC3C;MAAI,sBAAsB,WAAW,CAAC,EAAE,CAAC,CAAC,EACxC,wBAAwB,iBAAiB,SAAS,KAAK,CAAC,iBAAiB,sBAAsB,CAAC,MAAM;CACvG;AAEH,KAAIA,cAAY,EAAG,OAAM,IAAI,UAAU,CAAC,sCAAsC,CAAC;AAC/E,KAAI,SAAS,EAAG,OAAM,IAAI,UAAU,CAAC,mCAAmC,CAAC;CACzE,MAAM,MAAM,WAAW,sBAAsB;CAC7C,MAAM,SAAS,aAAa,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,QAAQ;AAChD,KAAI,UAAU,EAAG,OAAM,IAAI,UAAU,CAAC,oCAAoC,CAAC;AAE3E,QAAO;EACL,GAAGA;EACH,GAAG;EACH,GAAG;EACM;EACT,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,KAAK,CAAC;CACf;AACF;;;;;;;;;;AAWD,MAAaC,gBAAc,CAAkBC,OAAUC,OAAuD;AAC5G,SAAQ,MAAM,MAAd;EACE,KAAK,CAAC,QAAQ,CAAC,CACb,QAAO;GACL,GAAG;GACH,SAAS,IAAI,MAAM,WAAW,OAAO,KAAK,MAAM,GAAG;EACpD;EACH,KAAK,CAAC,MAAM,CAAC,CACX,QAAO;GACL,GAAG;GACH,SAAS,GAAI,MAAM,WAAW,GAAI,MAAM;EACzC;CACJ;AACF;AAED,MAAaC,iBAAe,CAACC,GAAmBC,GAAmBC,YAAkC,CAAC,OAAO,CAAC,KAAK;CACjH,IAAIV,WAAS,EAAE;CACf,IAAIA,WAAS,EAAE;CAIf,MAAM,WAAW,EAAE,WAAW;CAC9B,MAAM,eAAe,qBAAqB,EAAE,GAAG,EAAE,GAAG,EAAE;CACtD,MAAM,cAAc,cAAc,CAAC,MAAM,CAAC,GAAG,aAAa,OAAO,aAAa;CAC9E,MAAM,iBAAiB,EAAE,IAAI,EAAE;CAC/B,MAAM,gBAAgB,EAAE,IAAI,EAAE;CAC9B,MAAM,mBAAmB,EAAE,WAAW,KAAK;AAI3C,QAAO,CAACW,WAAgC;EACtC,SAAS,MAAM,OAAO;EACtB,IAAI,IAAI,YAAY,QAAQ,GAAG,KAAK,IAAI,YAAY,CAAC;AACrD,MAAI,cAAc,GAAG,IAAI,EAAE,IAAI;OAC1B,IAAI,EAAE,IAAI;EAEf,MAAM,IAAI,YAAY,QAAQ,GAAG,eAAe;EAChD,MAAM,IAAI,YAAY,QAAQ,GAAG,cAAc;EAC/C,MAAM,IAAI,YAAY,QAAQ,GAAG,gBAAgB;AAEjD,SAAOtB,SAAO,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,cAAc,EAAE,EAAE,IAAI,SAAS;CAChE;AACF;AAED,SAAgBA,SAAOc,cAAY,IAAK,SAAS,IAAK,MAAM,IAAK,UAAU,GAAgB;CACzF,MAAMS,MAAmB;EACvB,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,KAAK,CAAC;EACd,GAAGT;EACH,GAAG;EACH,GAAG;EACM;CACV;CACDnB,QAAM,IAAI;AACV,QAAO;AACR;;;;;;;;;AAUD,MAAa,WAAW,CAAC6B,GAAWC,GAAWC,GAAW,UAAU,MAAqB;CACvF,MAAMC,MAAqB;EACzB,OAAO,CAAC,KAAK,CAAC;EACd,MAAM,CAAC,QAAQ,CAAC;EAChB;EACA;EAAG;EAAG;CACP;CACDhC,QAAM,IAAI;AACV,QAAO;AACR;;;;;;;;;;;;;;;;;;;AC3XD,MAAa,gBAAgB,CAACiC,WAA2B;AACvD,KAAI,OAAO,WAAW,CAAC,CAAC,CAAC,CAAC,CACxB,sBAA+B,QAAQ,KAAK;AAG9C,KAAI,OAAO,qBAAsB,YAAa,CAAC,SAAS,CAAC,CACvD,sBAA+B,qBAAsB,SAAoB,KAAK;AAEhF,KAAI,OAAO,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;EAC3B,MAAMC,YAAU,iBAAiB,SAAS,KAAK,CAAC,iBAAiB,OAAO,CAAC,MAAM;AAC/E,MAAIA,UAAQ,WAAW,KAAKA,cAAY,KAAM,OAAM,IAAI,MAAM,CAAC,kBAAkB,EAAG,QAAS;AAC7F,SAAO,cAAcA,UAAQ;CAC9B;CACD,SAAS,OAAO,aAAa;AAC7B,KAAI,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,CAC3B,kBAAwB,QAAQ,EAAE,QAAQ,KAAM,EAAC;AAEnD,KAAI,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,CAC3B,gBAAyB,QAAQ,EAAE,QAAQ,KAAM,EAAC;AAEpD,KAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAAC,CAC7B,kBAA0B,QAAQ,EAAE,QAAQ,KAAM,EAAC;AAGrD,OAAM,IAAI,MAAM,CAAC,iFAAiF,EAAG,OAAQ,CAAC,CAAC;AAChH;;;;;;;;;;;;;AAcD,MAAa,aAAa,CAACD,QAAgBE,aAA8B;AACvE,KAAI,OAAO,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;EAC3B,MAAMD,YAAU,iBAAiB,SAAS,KAAK,CAAC,iBAAiB,OAAO,CAAC,MAAM;AAC/E,MAAIA,UAAQ,WAAW,KAAKA,cAAY,MAAM;AAC5C,OAAI,OAAO,aAAa,CAAC,SAAS,CAAC,CAAE,QAAO;AAC5C,SAAM,IAAI,MAAM,CAAC,uBAAuB,EAAG,OAAQ,CAAC,CAAC;EACtD;AACD,SAAO,WAAWA,UAAQ;CAC3B;AACD,KAAI,OAAO,qBAAsB,YAAa,CAAC,SAAS,CAAC,CACvD,QAAO,qBAAsB;AAE/B,QAAO;AACR;AAED,MAAa,uBAAuB;CAClC,aAAa;CACb,gBAAgB;CAChB,QAAQ;CACR,cAAc;CACd,SAAS;CACT,SAAS;CACT,UAAU;CACV,SAAS;CACT,kBAAkB;CAClB,QAAQ;CACR,cAAc;CACd,SAAS;CACT,aAAa;CACb,aAAa;CACb,cAAc;CACd,aAAa;CACb,SAAS;CACT,kBAAkB;CAClB,YAAY;CACZ,WAAW;CACX,QAAQ;CACR,YAAY;CACZ,YAAY;CACZ,iBAAiB;CACjB,YAAY;CACZ,aAAa;CACb,aAAa;CACb,eAAe;CACf,kBAAkB;CAClB,cAAc;CACd,cAAc;CACd,WAAW;CACX,cAAc;CACd,gBAAgB;CAChB,iBAAiB;CACjB,iBAAiB;CACjB,iBAAiB;CACjB,cAAc;CACd,YAAY;CACZ,eAAe;CACf,WAAW;CACX,cAAc;CACd,aAAa;CACb,eAAe;CACf,eAAe;CACf,WAAW;CACX,aAAa;CACb,cAAc;CACd,QAAQ;CACR,aAAa;CACb,QAAQ;CACR,SAAS;CACT,eAAe;CACf,YAAY;CACZ,WAAW;CACX,aAAa;CACb,UAAU;CACV,SAAS;CACT,SAAS;CACT,YAAY;CACZ,iBAAiB;CACjB,aAAa;CACb,gBAAgB;CAChB,aAAa;CACb,cAAc;CACd,aAAa;CACb,wBAAwB;CACxB,aAAa;CACb,cAAc;CACd,aAAa;CACb,eAAe;CACf,iBAAiB;CACjB,gBAAgB;CAChB,kBAAkB;CAClB,kBAAkB;CAClB,eAAe;CACf,QAAQ;CACR,aAAa;CACb,SAAS;CACT,WAAW;CACX,UAAU;CACV,oBAAoB;CACpB,cAAc;CACd,gBAAgB;CAChB,gBAAgB;CAChB,kBAAkB;CAClB,mBAAmB;CACnB,qBAAqB;CACrB,mBAAmB;CACnB,mBAAmB;CACnB,gBAAgB;CAChB,aAAa;CACb,aAAa;CACb,YAAY;CACZ,eAAe;CACf,QAAQ;CACR,WAAW;CACX,SAAS;CACT,aAAa;CACb,UAAU;CACV,aAAa;CACb,UAAU;CACV,iBAAiB;CACjB,aAAa;CACb,iBAAiB;CACjB,iBAAiB;CACjB,cAAc;CACd,aAAa;CACb,QAAQ;CACR,QAAQ;CACR,QAAQ;CACR,cAAc;CACd,UAAU;CACV,iBAAiB;CACjB,OAAO;CACP,aAAa;CACb,aAAa;CACb,eAAe;CACf,UAAU;CACV,cAAc;CACd,YAAY;CACZ,YAAY;CACZ,UAAU;CACV,UAAU;CACV,WAAW;CACX,aAAa;CACb,aAAa;CACb,QAAQ;CACR,eAAe;CACf,aAAa;CACb,OAAO;CACP,QAAQ;CACR,WAAW;CACX,UAAU;CACV,aAAa;CACb,UAAU;CACV,SAAS;CACT,SAAS;CACT,cAAc;CACd,UAAU;CACV,eAAe;CACf,eAAe;AAChB;;;;;;;;;;;;;;;;;;;;;AC/MD,MAAaE,gBAAc,CAAgBC,OAAUC,OAAuD;AAC1G,SAAQ,MAAM,MAAd;EACE,KAAK,CAAC,IAAI,CAAC,CACT,QAAO;GACL,GAAG;GACH,SAAS,IAAI,MAAM,WAAW,OAAO,KAAK,MAAM,GAAG;EACpD;EACH,KAAK,CAAC,MAAM,CAAC,CACX,QAAO;GACL,GAAG;GACH,SAAS,GAAI,MAAM,WAAW,GAAI,MAAM;EACzC;CACJ;AACF;AAGD,SAAgB,cAAcC,WAAmBC,WAAS,MAA2B;AACnF,QAAO,oBAAsB,UAAU,EAAE,EAAE,iBAAQ,EAAC;AACrD;AAED,MAAMC,iBAA0B,OAAO,OAAO;CAC5C,GAAG;CAAG,GAAG;CAAG,GAAG;CAAG,SAAS;CAAG,MAAM,CAAC,IAAI,CAAC;CAAE,OAAO,CAAC,IAAI,CAAC;AAC1D,EAAC;;;;;;;;;;;;;;;AAkBF,SAAgB,QAAQC,OAAeC,UAA+B,CAAE,GAAO;CAC7E,QAAQ,MAAM,aAAa;AAC3B,KAAI,MAAM,WAAW,CAAC,KAAK,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;AACrE,KAAI,MAAM,WAAW,CAAC,KAAK,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,oBAAoB,CAAC;CAGrE,MAAMH,WAAS,QAAQ,UAAU;AAGjC,KAAI,MAAM,WAAW,CAAC,CAAC,CAAC,CAAC,CAAE,QAAO,cAAc,OAAOA,SAAO;AAE9D,KAAI,UAAU,CAAC,WAAW,CAAC,CAAE,QAAO;AAEpC,KAAI,OAAO,qBAAsB,WAAY,CAAC,SAAS,CAAC,EAAE,cAAc,qBAAsB,QAAmBA,SAAO;AAExH,KAAI,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE;EAC5B,MAAM,MAAMI,aAAgB,MAAM;AAClC,SAAO,YAAY,KAAK,QAAQ;CACjC;AAWD,KAAI,CAAC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,CAC3B,KAAI;EACF,gBAAkB,OAAO,CAAC,GAAG,CAAC,CAAC;CAChC,SAAQ,OAAO;AACd,MAAI,QAAQ,gBACV,QAAQ,QAAQ;MAEhB,OAAM;CAET;AAGH,KAAI;EAEF,MAAM,MAAM,oBAAoB,MAAM;AACtC,MAAIJ,SAAQ,QAAO,SAAS,IAAI;AAChC,SAAO,OAAO,IAAI;CACnB,SAAQ,OAAO;AACd,MAAI,QAAQ,eAAgB,QAAO,QAAQ;AAC3C,QAAM;CACP;AACF;AAED,MAAaK,gBAAc,CAACC,QAAqB;CAC/CC,QAAM,IAAI;AACV,SAAQ,IAAI,MAAZ;EACE,KAAK,CAAC,IAAI,CAAC;AACT,OAAI,IAAI,YAAY,UAAa,IAAI,YAAY,IAC/C,QAAO,CAAC,IAAI,EAAG,IAAI,EAAG,CAAC,EAAG,IAAI,EAAG,CAAC,EAAG,IAAI,EAAG,CAAC,CAAC;AAEhD,UAAO,CAAC,IAAI,EAAG,IAAI,EAAG,CAAC,EAAG,IAAI,EAAG,CAAC,EAAG,IAAI,EAAG,GAAG,GAAI,IAAI,WAAW,OAAO,IAAK,CAAC,CAAC;EAClF,KAAK,CAAC,MAAM,CAAC;AACX,OAAI,IAAI,YAAY,UAAa,IAAI,YAAY,EAC/C,QAAO,CAAC,IAAI,EAAG,IAAI,IAAI,IAAK,EAAE,EAAG,IAAI,IAAI,IAAK,EAAE,EAAG,IAAI,IAAI,IAAK,EAAE,CAAC;AAErE,UAAO,CAAC,IAAI,EAAG,IAAI,IAAI,IAAK,EAAE,EAAG,IAAI,IAAI,IAAK,EAAE,EAAG,IAAI,IAAI,IAAK,IAAI,GAAI,IAAI,WAAW,KAAK,IAAK,EAAE,CAAC;EACtG,QAEE,OAAM,IAAI,MAAM,CAAC,cAAc,EAAI,IAAY,MAAO;CACzD;AACF;AAeD,SAAS,YAAYC,KAAYC,iBAAsC,CAAE,GAAuB;AAC9F,KAAI,eAAe,OACjB,QAAO;EACL,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,GAAG,IAAI,IAAI;EACX,SAAS,IAAI,SAAS;EACtB,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,IAAI,CAAC;CACd;KAED,QAAO;EACL,GAAG,IAAI;EACP,GAAG,IAAI;EACP,GAAG,IAAI;EACP,SAAS,IAAI,SAAS;EACtB,MAAM,CAAC,IAAI,CAAC;EACZ,OAAO,CAAC,IAAI,CAAC;CACd;AAEJ;AAGD,MAAa,SAAS,CAACC,gBAAuC;AAC5D,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,QAAO,QAAQ,aAAa,EAAE,QAAQ,MAAO,EAAC;AAEhD,KAAI,MAAM,YAAY,CACpB,QAAO,OAAO,YAAYN,aAAgB,YAAY,EAAE,EAAE,QAAQ,MAAO,EAAC,CAAC;CAE7EG,QAAM,YAAY;AAClB,KAAI,YAAY,SAAS,CAAC,IAAI,CAAC,CAAE,QAAO;AACxC,QAAO;EACL,GAAG,YAAY,IAAI;EACnB,GAAG,YAAY,IAAI;EACnB,GAAG,YAAY,IAAI;EACnB,UAAU,YAAY,WAAW,KAAK;EACtC,MAAM,CAAC,IAAI,CAAC;EACZ,OAAO,CAAC,IAAI,CAAC;CACd;AACF;AAED,MAAa,WAAW,CAACI,gBAA+C;AACtE,KAAI,OAAO,gBAAgB,CAAC,MAAM,CAAC,CACjC,QAAO,QAAQ,aAAa,EAAE,QAAQ,KAAM,EAAC;AAE/C,KAAI,MAAM,YAAY,CACpB,QAAO,SAAS,YAAYP,aAAgB,YAAY,EAAE,EAAE,QAAQ,KAAM,EAAC,CAAC;CAE9EG,QAAM,YAAY;AAClB,KAAI,YAAY,SAAS,CAAC,MAAM,CAAC,CAAE,QAAO;AAC1C,QAAO;EACL,GAAG,YAAY,IAAI;EACnB,GAAG,YAAY,IAAI;EACnB,GAAG,YAAY,IAAI;EACnB,UAAU,YAAY,WAAW,KAAK;EACtC,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,IAAI,CAAC;CACd;AACF;AAED,MAAaA,UAAQ,CAACD,QAAa;CACjC,MAAM,EAAE,GAAG,GAAG,GAAG,SAAS,OAAO,MAAM,GAAG;AAC1C,KAAI,UAAU,CAAC,IAAI,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,qCAAqC,EAAG,OAAQ;AACvF,KAAI,SAAS,CAAC,IAAI,CAAC,EACjB,YACE,yBAAyB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EACxC,yBAAyB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EACxC,yBAAyB,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,EACxC,MAAM;AACJ,MAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC7B,QAAO,yBAAyB,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC;CAE9D,EACF;UACQ,SAAS,CAAC,MAAM,CAAC,EAC1B,YACE,WAAW,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAChC,WAAW,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAChC,WAAW,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,EAChC,MAAM;AACJ,MAAI,OAAO,YAAY,CAAC,MAAM,CAAC,CAC7B,QAAO,WAAW,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC;CAEtD,EAAC;KAEJ,OAAM,IAAI,MAAM,CAAC,gDAAgD,EAAG,MAAO;AAE9E;;;;;;;;;;;;;AAcD,MAAa,kBAAkB,CAACA,KAAUM,WAA2E;CACnH,IAAI,OAAO;CACX,MAAM,KAAK,IAAIC,cAASR,cAAY,IAAI;CACxC,MAAM,aAAa,IAAI,SAAS,CAAC,MAAM,CAAC;AACxC,KAAI,OAAO,OAAO,WAAW,CAAC,SAAS,CAAC,EACtC,OAAO,GAAG,MAAM,IAAK,GAAG,MAAM,IAAI,OAAO;UAChC,OAAO,OAAO,UAAU,CAAC,SAAS,CAAC,EAC5C,OAAO,GAAG,MAAM,IAAI,OAAO;UAClB,OAAO,OAAO,UAAU,CAAC,SAAS,CAAC,EAAE;AAC9C,MAAI,OAAO,QAAQ,EAAG,OAAM,IAAI,UAAU,CAAC,4CAA4C,CAAC;EACxF,OAAO,OAAO;CACf,MACC,OAAM,IAAI,UAAU,CAAC,6DAA6D,CAAC;AAErF,KAAI,OAAO,GAAG,OAAO;UACZ,OAAO,GAAG,OAAO;CAE1B,MAAM,sBAAwB;EAAE,GAAG,GAAG,MAAM;EAAG,GAAG,GAAG,MAAM;EAAG,GAAG;EAAM,OAAO,GAAG,MAAM;CAAO,EAAC;AAC/F,QAAO,YAAY,WAAW,EAAE,QAAQ,WAAY,EAAC;AAEtD;;;;;;;;AASD,SAAgB,UAAUC,KAAU;CAClC,MAAM,KAAK,IAAIO,cAASR,cAAY,IAAI;AACxC,QAAO,GAAG,MAAM;AACjB;;;;;;;;;AAuBD,SAAgB,SAAS,MAAM,KAAK,QAAQ,KAAK,OAAO,KAAK,UAAU,KAAc;CACnF,MAAMS,MAAe;EACnB,MAAM,CAAC,IAAI,CAAC;EACZ,OAAO,CAAC,IAAI,CAAC;EACb,GAAG;EACH,GAAG;EACH,GAAG;EACM;CACV;CACDP,QAAM,IAAI;AACV,QAAO;AACR;;;;;;;;;AAUD,SAAgBP,SAAO,MAAM,IAAK,QAAQ,IAAK,OAAO,IAAK,UAAU,GAAc;CACjF,MAAMe,MAAiB;EACrB,MAAM,CAAC,MAAM,CAAC;EACd,OAAO,CAAC,IAAI,CAAC;EACb,GAAG;EACH,GAAG;EACH,GAAG;EACM;CACV;CACDR,QAAM,IAAI;AACV,QAAO;AACR;;;;;AAOD,SAAgB,oBAAoBL,OAAoB;AACtD,KAAI,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,qBAAqB,CAAC;AACrE,KAAI,CAAC,MAAM,WAAW,CAAC,IAAI,CAAC,CAAC,CAAE,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;CAE5E,MAAM,QAAQ,MAAM,QAAQ,IAAI;CAChC,MAAM,MAAM,MAAM,QAAQ,IAAI;AAC9B,KAAI,MAAM,MAAO,OAAM,IAAI,MAAM,CAAC,oCAAoC,CAAC;CAEvE,MAAM,OAAO,MAAM,UAAU,QAAQ,GAAG,IAAI;CAC5C,IAAI,QAAQ,KAAK,MAAM,SAAS;AAChC,KAAI,MAAM,SAAS,EAAG,OAAM,IAAI,MAAM,CAAC,4BAA4B,EAAG,MAAM,OAAQ,OAAO,CAAC;CAE5F,IAAI,gBAAgB;AACpB,MAAK,MAAM,KAAK,MACd,KAAI,EAAE,SAAS,IAAI,EAAE;CAGvB,MAAM,gBAAgB,CAACc,GAAWC,QAAgB;AAChD,MAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CACjB,QAAO,OAAO,WAAW,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE,CAAC,GAAG;AAE3D,MAAI,MAAM,EAER,QAAO,OAAO,WAAW,EAAE,GAAG;MAG9B,QAAO,OAAO,WAAW,EAAE;CAE9B;CAED,MAAM,cAAc,CAACD,GAAWC,QAAgB;AAC9C,MAAI,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CACjB,QAAO,OAAO,WAAW,EAAE,UAAU,GAAG,EAAE,SAAS,EAAE,CAAC,GAAG,MAAM;AAEjE,MAAI,MAAM,EAER,QAAO,OAAO,WAAW,EAAE;MAG3B,QAAO,OAAO,WAAW,EAAE,GAAG;CAEjC;AAGD,KAAI,MAAM,SAAS,GACjB;MAAI,MAAO,OAAQ,KAEjB,QAAQ;GAAE,MAAO;GAAK,MAAO;GAAK,MAAO;GAAK,MAAO;EAAK;CAC3D;AAEH,KAAI,gBAAgB,EAElB,QAAOjB,SACL,cAAc,MAAO,IAAK,EAAE,EAC5B,cAAc,MAAO,IAAK,EAAE,EAC5B,cAAc,MAAO,IAAK,EAAE,EAC5B,cAAc,MAAO,MAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CACpC;KAGD,QAAO,SACL,YAAY,MAAO,IAAK,EAAE,EAC1B,YAAY,MAAO,IAAK,EAAE,EAC1B,YAAY,MAAO,IAAK,EAAE,EAC1B,YAAY,MAAO,MAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAClC;AAEJ;;;;;;;;;;;;;AAcD,MAAakB,iBAAe,CAACC,SAAuBC,YAA0B;CAC5E,MAAM,KAAK,SAAS,QAAQ;CAC5B,MAAM,KAAK,SAAS,QAAQ;CAE5B,MAAM,WAAW,GAAG,WAAW;CAC/B,MAAM,mBAAmB,GAAG,WAAW,KAAK;CAE5C,MAAM,IAAI,GAAG,IAAI,GAAG;CACpB,MAAM,IAAI,GAAG,IAAI,GAAG;CACpB,MAAM,IAAI,GAAG,IAAI,GAAG;AAEpB,QAAO,CAACC,WAA8B;EACpC,SAAS,MAAM,OAAO;AACtB,SAAOrB,SACL,GAAG,IAAI,YAAY,QAAQ,GAAG,EAAE,EAChC,GAAG,IAAI,YAAY,QAAQ,GAAG,EAAE,EAChC,GAAG,IAAI,YAAY,QAAQ,GAAG,EAAE,EAChC,WAAW,YAAY,QAAQ,GAAG,gBAAgB,CAAC;CACtD;AACF;;;;;;AAOD,SAAgB,aAAasB,KAA0B;AACrD,KAAI,OAAO,QAAQ,CAAC,MAAM,CAAC,EAAE;EAC3B,MAAM,cAAc,QAAQ,KAAK,EAAE,QAAQ,MAAO,EAAC;AACnD,SAAO,aAAa,YAAY;CACjC;CACD,MAAM,OAAO,IAAI;CACjB,MAAM,cAAgB;EAAE,GAAG,IAAI;EAAG,GAAG,IAAI;EAAG,GAAG,IAAI;CAAG,EAAC;AACvD,QAAO;EAAE,GAAG;EAAK,QAAQ,IAAI,WAAW,OAAO;CAAK;AACrD;;;;;;;;;;;;;;;;;;ACpbD,MAAaC,SAAO,CAACC,UAAiC;CACpD,MAAM,IAAI;EAAE,MAAM,MAAM;EAAO,MAAM,MAAM;CAAQ;AACnD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;AAuBD,MAAa,OAAO,CAACA,UAAgF;AACnG,QAAO;EACL,GAAGD,OAAK,MAAM;EACd,KAAK,SAAS,MAAM;EACpB,KAAK,OAAO,MAAM;CACnB;AACF;;;;;;AAOD,MAAa,WAAW,CAACC,UAAsD;CAC7E,MAAM,IAAID,OAAK,MAAM;CACrB,MAAM,OAAO,MAAM;CAEnB,MAAME,KAAsC,CAACC,MAAsB,SAAS,CAAC,SAAS,CAAC,KAAK;EAC1F,MAAM,sBAA4B,GAAG,MAAM,OAAO;AAClD,MAAI,UAAU,OAAW;EACzB,MAAM,UAAU,QAAQ;AACxB,SAAO;GACL,GAAG,KAAM;GACT,GAAG,KAAM,UAAU;GACnB,GAAG,KAAM,UAAU;GACnB,SAAS,KAAM,UAAU;GACzB,MAAM,CAAC,IAAI,CAAC;GACZ,OAAO,CAAC,IAAI,CAAC;EACd;CACF;AACD,QAAO;AACR;;;;;;AAOD,MAAa,SAAS,CAACF,UAAgD;CACrE,MAAM,IAAID,OAAK,MAAM;CACrB,MAAM,OAAO,MAAM;CAEnB,MAAMI,KAAgC,CAACC,OAAYF,MAAsB,SAAS,CAAC,SAAS,CAAC,KAAK;EAChG,MAAM,sBAA4B,GAAG,MAAM,OAAO;AAClD,MAAI,UAAU,OAAW,OAAM,IAAI,MAAM,CAAC,mBAAmB,EAAG,KAAK,EAAG,CAAC,EAAG,KAAK,GAAI;EACrF,MAAM,eAAyB,MAAM;EACrC,MAAM,UAAU,QAAQ;EACxB,KAAM,WAAY,MAAM;EACxB,KAAM,UAAU,KAAM,MAAM;EAC5B,KAAM,UAAU,KAAM,MAAM;EAC5B,KAAM,UAAU,KAAM,MAAM,WAAW;CACxC;AACD,QAAO;AACR;;;;;AAcD,UAAiB,MAAMF,OAAkB;CACvC,MAAM,IAAI,SAAS,MAAM;CACzB,MAAM,IAAID,OAAK,MAAM;CAErB,MAAM,SAAkB,GAAG;EAAE,GAAG;EAAG,GAAG;CAAG,EAAC;AAC1C,MAAK,MAAM,OAAO,GAAG;EACnB,MAAM,SAAS,IAAI,IAAI,OAAK,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;EAC9C,MAAM;CACP;AACF;;;;;AAMD,UAAiB,SAASC,OAAkB;CAC1C,MAAM,IAAI,SAAS,MAAM;CACzB,MAAM,IAAID,OAAK,MAAM;AAErB,MAAK,IAAI,IAAI,GAAG,IAAI,EAAE,MAAM,KAAK;EAC/B,MAAMM,MAAiB,CAAE;AACzB,OAAK,IAAI,IAAI,GAAG,IAAI,EAAE,MAAM,KAAK;GAC/B,MAAM,IAAI,EAAE;IAAE;IAAG;GAAG,GAAE,CAAC,SAAS,CAAC,CAAC;AAClC,OAAI,GAAG,IAAI,KAAK,EAAE;EACnB;EACD,MAAM;CACP;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACMD,IAAa,eAAb,cAAkC,mBAAiC;CACjE,AAAS;CACT,AAAS;CAET;CACA;CACA;CACA;CACA;CACA;CACA;CACA,YAAY;CAEZ,YAAYC,cAAuEC,OAAqC,CAAE,GAAE;EAC1H,OAAO;AACP,MAAI,CAAC,aAAc,OAAM,IAAI,MAAM,CAAC,yCAAyC,CAAC;EAC9E,KAAK,KAAK,UAA6B,aAAa;AACpD,MAAI,KAAK,GAAG,aAAa,CAAC,MAAM,CAAC,CAC/B,OAAM,IAAI,MAAM,CAAC,mCAAmC,EAAG,KAAK,GAAG,UAAW;EAG5E,MAAM,OAAO,KAAK,GAAG,uBAAuB;EAC5C,KAAK,OAAO;GACV,aAAa,KAAK,eAAe,CAAC,IAAI,CAAC;GACvC,sBAAsB,KAAK,wBAAwB;GACnD,WAAW,KAAK,cAAc,OAAO,oBAAoB;GACzD,QAAQ,KAAK,UAAU,KAAK;GAC5B,OAAO,KAAK,SAAS,KAAK;GAC1B,QAAQ,KAAK,UAAU;GACvB,iBAAiB,KAAK,mBAAmB,CAAC,IAAI,CAAC;GAC/C,YAAY,KAAK;GACjB,WAAW,KAAK;GAChB,eAAe,KAAK,iBAAiB;GACrC,MAAM,KAAK;GACX,SAAS,KAAK,WAAW;GACzB,aAAa,CAAC,IAAI,CAAC;EACpB;EAED,KAAKC,UAAUC,SAAO,CAAC,IAAI,CAAC,CAAC;EAC7B,KAAKC,cAAcD,SAAO,CAAC,IAAI,CAAC,EAAE,KAAK;EACvC,KAAKE,OAAO;CACb;CAED,eAA+B;AAC7B,SAAO;GACL,GAAG;GAAG,GAAG;GACT,GAAG,KAAKC;EACT;CACF;CACD,QAAQC,QAAiB;AACvB,MAAI,KAAKC,UAAW;EACpB,KAAKA,YAAY;AACjB,MAAI,KAAKC,UAAU;GACjB,KAAKA,SAAS,QAAQ,CAAC,uBAAuB,EAAG,QAAS,CAAC,MAAM,CAAC;GAClE,KAAKA,WAAW;EACjB;CACF;CAED,YAAY,QAAQ,OAAO;AACzB,MAAI,KAAKC,SAAS,UAAa,OAAO;GACpC,MAAM,QAAQ,KAAK;GACnB,MAAM,IAAI,KAAK,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC;AAClC,OAAI,MAAM,KAAM,OAAM,IAAI,MAAM,CAAC,gCAAgC,CAAC;GAClE,KAAKA,OAAO;GAEZ,EAAE,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE;GAChC,EAAE,MAAM,OAAO,MAAM;EACtB;AACD,SAAO,KAAKA;CACb;;;;;;CAOD,kBAAkB;AAChB,SAAO;GACL,OAAO,KAAK,QAAQ,KAAK;GACzB,QAAQ,KAAK,SAAS,KAAK;EAC5B;CACF;;;;;CAMD,gBAAgB;AACd,MAAI,CAAC,KAAKC,aACR,KAAKA,2BAAiC,KAAKC,aAAa,EAAE;GACxD,OAAO,KAAK;GAAO,QAAQ,KAAK;EACjC,EAAC;CAEL;CAED,eAAeC,aAAmB;QACpB,aAAa,CAAC,WAAW,CAAC,CAAC;EACvC,MAAM,iCAAuC,OAAK,KAAK,MAAM,EAAE,EAAE,YAAY;EAC7E,MAAM,QAAQ,KAAK,KAAK;EAGxB,KAAKX,UAAUC,SAAO,KAAK,KAAK,iBAAiB,YAAY;EAC7D,KAAKC,cAAcD,SAAO,CAAC,IAAI,CAAC,EAAE,YAAY;EAG9C,MAAM,6BAAmC,aAAa,MAAM;EAG5D,KAAK,GAAG,QAAQ,YAAY;EAC5B,KAAK,GAAG,SAAS,YAAY;EAG7B,KAAK,GAAG,MAAM,QAAQ,mBAAmB,MAAM,UAAU,GAAG,CAAC,EAAE,CAAC;EAChE,KAAK,GAAG,MAAM,SAAS,mBAAmB,OAAO,UAAU,GAAG,CAAC,EAAE,CAAC;EAGlE,KAAKS,YAAY,KAAK;AAEtB,MAAI,KAAK,KAAK,eACZ,KAAK,IAAI,UAAU,GAAG,GAAG,KAAK,OAAO,KAAK,OAAO;EAGnD,KAAKN,eAAe;AASpB,MAAI,KAAK,KAAK,YACZ,KAAK,KAAK,WAAW,KAAK,KAAK,KAAK,MAAM,KAAK;EAEjD,KAAK,UAAU,CAAC,MAAM,CAAC,EAAE;GAAE,KAAK,KAAK;GAAK,MAAM,KAAKA;GAAc,QAAQ;EAAM,EAAC;CACnF;CAGD,QAAQ;EAIN,MAAM,IAAI,KAAK,KAAK;AACpB,MAAI,GAAG;GACL,MAAM,QAAQ,MAAM;IAClB,EAAE,KAAK,KAAK,KAAKA,cAAc,KAAK;IACpC,sBAAsB,MAAM;GAC7B;GACD,WAAW,MAAM;IAAE,OAAO;GAAE,GAAE,IAAI;EACnC;AAED,MAAI,CAAC,KAAK,KAAK,sBACb,KAAKQ,eAAe;EAGtB,MAAM,cAAc,KAAK,KAAK,eAAe,CAAC,IAAI,CAAC;AACnD,MAAI,gBAAgB,CAAC,IAAI,CAAC,EACxB,KAAK,eAAe;GAAE,OAAO,KAAK,KAAK;GAAO,QAAQ,KAAK,KAAK;EAAQ,EAAC;OACpE;GACL,MAAMC,iBAAyD;IAC7D,gBAAgB,CAAC,SAAS;AACxB,mBAAkB,KAAKT,cAAc,KAAK,CAAE;KAC5C,KAAK,eAAe,KAAK;IAC1B;IACD,YAAY,CAAC,MAAM,OAAO;KACxB,KAAKU,cAAc,KAAK;IACzB;IACD,aAAa;KAAE,OAAO,KAAK,KAAK;KAAO,QAAQ,KAAK,KAAK;IAAQ;IACjE,SAAS,KAAK,KAAK,eAAe,CAAC,IAAI,CAAC;GACzC;GACD,KAAKP,WAAW,IAAI,aAAa,KAAK,IAAI;EAC3C;EAED,KAAKG,aAAa;CACnB;CAED,cAAcK,MAAY;AACxB,MAAI,KAAK,KAAK,WAAW,KAAK,KAAK,UAAU,KAAK,KAAK,KAAK,MAAM,KAAK;EACvE,KAAK,UAAU,CAAC,OAAO,CAAC,EAAE;GAAE,KAAK,KAAK;GAAK,MAAM,KAAKX;GAAc,QAAQ;EAAM,EAAC;CACpF;CAED,gBAAgB;EACd,MAAM,qBAAqB,CAACY,UAAwB;GAClD,MAAM,EAAE,SAAS,SAAS,GAAG;GAC7B,MAAM,YAAY,UAAU,KAAK;GACjC,MAAM,YAAY,UAAU,KAAK;GACjC,QAAQ,gBAAgB,MAAM;GAC9B,MAAM,YAAY;IAChB;IAAW;IAEX,GAAG;GACJ;AAED,WAAQ,MAAM,MAAd;IACE,KAAK,CAAC,SAAS,CAAC,EACd;KACE,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE,UAAU;AACtC;IACD;IAEH,KAAK,CAAC,WAAW,CAAC,EAChB;KACE,KAAK,UAAU,CAAC,WAAW,CAAC,EAAE,UAAU;AACxC;IACD;IAEH,KAAK,CAAC,WAAW,CAAC,EAChB;KACE,KAAK,UAAU,CAAC,SAAS,CAAC,EAAE,UAAU;AACtC;IACD;GAEJ;EACF;EAED,KAAK,GAAG,iBAAiB,CAAC,WAAW,CAAC,EAAE,mBAAmB;EAC3D,KAAK,GAAG,iBAAiB,CAAC,WAAW,CAAC,EAAE,mBAAmB;EAC3D,KAAK,GAAG,iBAAiB,CAAC,SAAS,CAAC,EAAE,mBAAmB;CAC1D;;;;;;;CAQD,QAAQ;AACN,MAAI,CAAC,KAAKR,KAAM;EAChB,KAAKA,KAAK,UAAU,GAAG,GAAG,KAAK,OAAO,KAAK,OAAO;CAEnD;;;;;;;;;;;CAYD,KAAKS,QAAiB;AACpB,MAAI,CAAC,KAAKT,KAAM;AAChB,MAAI,QAAQ,KAAKA,KAAK,YAAY;EAClC,KAAKA,KAAK,SAAS,GAAG,GAAG,KAAK,OAAO,KAAK,OAAO;CAElD;;;;CAID,IAAI,MAAM;AACR,MAAI,KAAKA,SAAS,OAAW,OAAM,IAAI,MAAM,CAAC,qBAAqB,CAAC;AACpE,SAAO,KAAKE,aAAa;CAC1B;CAED,IAAI,WAAW;AACb,SAAO,KAAKQ;CACb;;;;;CAMD,IAAI,QAAQ;AACV,SAAO,KAAKd,aAAa;CAC1B;;;;;CAMD,IAAI,SAAS;AACX,SAAO,KAAKA,aAAa;CAC1B;;;;;CAMD,IAAI,OAAO;AACT,SAAO,KAAKA;CACb;;;;;CAMD,IAAI,QAAQ;AACV,SAAO,OAAO,oBAAoB;CACnC;;;;CAKD,IAAI,eAAe;AACjB,SAAO,KAAK,IAAI,KAAK,OAAO,KAAK,OAAO;CACzC;;;;CAKD,IAAI,eAAe;AACjB,SAAO,KAAK,IAAI,KAAK,OAAO,KAAK,OAAO;CACzC;CAID,WAAW,cAAc,CAAC,KAAK,CAAC,EAAE;EAChC,MAAM,MAAM,KAAKM,aAAa;OACjB,KACX;GAAE,GAAG;GAAG,GAAG;GAAG,OAAO,KAAK;GAAO,QAAQ,KAAK;EAAQ,GACtD;GAAE,SAAS;GAAM;GAAa,aAAa;EAAG,EAAC;OAEpC,KAAK,KAAKQ,WAAW;GAAE,SAAS;GAAM,aAAa,CAAC,MAAM,CAAC;GAAE,aAAa;EAAG,EAAC;CAC5F;;;;;;;;;;;;;CAcD,IAAI,aAAa;AACf,SAAO,KAAKlB,QAAQ;CACrB;;;;CAKD,IAAI,kBAAkB;AACpB,SAAO,KAAKE,YAAY;CACzB;;;;CAKD,IAAI,kBAAkB;AACpB,SAAO,KAAKA,YAAY;CACzB;CAED,IAAI,gBAAgB;AAClB,SAAO;GACL,GAAG,KAAKE,aAAa,QAAQ;GAC7B,GAAG,KAAKA,aAAa,SAAS;EAC/B;CACF;;;;;;;;;;;;;CAcD,IAAI,aAAa;AACf,SAAO,KAAKJ,QAAQ;CACrB;;;;CAKD,IAAI,SAAS;AACX,SAAO;GAAE,GAAG,KAAK,QAAQ;GAAG,GAAG,KAAK,SAAS;EAAG;CACjD;;;;;;;CAQD,eAA0B;EACxB,MAAM,OAAO,KAAK,iBAAiB;EACnC,MAAM,OAAO,KAAK,IAAI,aAAa,GAAG,GAAG,KAAK,OAAO,KAAK,QAAQ,EAAE,YAAY,KAAK,KAAK,YAAa,EAAC;AAExG,MAAI,SAAS,QAAQ,SAAS,OAAW,OAAM,IAAI,MAAM,CAAC,qCAAqC,CAAC;AAChG,SAAO;CACR;;;;;;;;;;;;;;;;;;;;;CAsBD,oBAAoB;EAClB,MAAM,MAAM,KAAK;EACjB,MAAM,OAAO,KAAK,cAAc;EAChC,MAAMmB,gBAA0B,KAAK;EACrC,MAAM,eAA6B,KAAK;EACxC,MAAM,aAA2B,KAAK;EAEtC,MAAM,OAAO,MAAM;GACjB,IAAI,aAAa,MAAM,GAAG,EAAE;EAC7B;AAED,SAAO;GAAE;GAAM;GAAK;GAAK;EAAM;CAChC;AACF;;;;;;;;;;ACviBD,MAAa,YAAY,CAACC,MAAkBC,SAAsB;AAChE,KAAI,KAAK,WAAW,KAAK,eAAe,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,UAAU;AACrE,KAAI,KAAK,SACP,KAAK,eAAe,MAAM,CAAC,OAAO,CAAC,EAAE,KAAK,QAAQ,UAAU,CAAC;AAGhE;;;;;;;;;ACRD,MAAa,YAAY,CAACC,QAA0B;CAClD,MAAM,IAAI,IAAI,eAAe,MAAM,CAAC,KAAK,CAAC,CAAC;CAC3C,MAAM,QAAQ,MAAM,OAAO,IAAI,OAAO,WAAW,EAAE;CACnD,MAAM,IAAI,IAAI,eAAe,MAAM,CAAC,MAAM,CAAC,CAAC;CAC5C,MAAM,SAAS,MAAM,OAAO,IAAI,OAAO,WAAW,EAAE;AACpD,QAAO;EAAE;EAAO;CAAQ;AACzB;;;;;;AAOD,MAAa,YAAY,CAACA,KAAiBC,WAAuB;CAChE,IAAI,eAAe,MAAM,CAAC,KAAK,CAAC,EAAE,OAAO,MAAM,UAAU,CAAC;CAC1D,IAAI,eAAe,MAAM,CAAC,MAAM,CAAC,EAAE,OAAO,OAAO,UAAU,CAAC;AAC7D;;;;;;;;;;AChBD,MAAa,WAAW,CACtBC,MACAC,OACM;CACN,MAAM,IAAI,SAAS,gBAAgB,CAAC,0BAA0B,CAAC,EAAE,KAAK;AACtE,KAAI,IACF,EAAE,KAAK;AAET,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;AAuBD,MAAa,kBAAkB,CAC7BC,QACAF,MACAG,iBACAC,WACM;CACN,IAAIC,WAAuC;AAC3C,KAAI,oBAAoB,QACtB,WAAW,OAAO,oBAAoB,CAAC,MAAM,CAAC,GAAG,OAAO,cAAc,gBAAgB,GAAG;AAE3F,KAAI,aAAa,MAAM;EACrB,MAAM,IAAI,SAAS,gBAAgB,CAAC,0BAA0B,CAAC,EAAE,KAAK;EACtE,OAAO,OAAO,EAAE;AAChB,MAAI,mBAAmB,OAAO,oBAAoB,CAAC,MAAM,CAAC,IACxD,gBAAgB,WAAW,CAAC,CAAC,CAAC,CAAC,EAC/B,EAAE,KAAK,WAAW,UAAa,CAAC,gBAAgB,SAAS,OAAO,GAAG,gBAAgB,MAAM,EAAE,GAAG,SAAS,gBAAgB,MAAM,EAAE;AAEjI,SAAO;CACR;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;;ACvCD,MAAa,oBAAoB,CAC/BC,OACA,aAAa,IACbC,cAAY,KACZ,QAAQ,MACL;CACH,YACE,WAAW,OAAO,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,EACtC,WAAW,YAAY,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,EAClD,WAAWA,aAAW,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC,EAChD,WAAW,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CACzC;CAED,MAAM,SAAS,QAAQ;CACvB,MAAM,SAAU,SAAS,MAAO;AAChC,QAAO,YAAYC,OAAU,QAAQ,YAAYD,aAAW,MAAM,CAAC;AAEpE;;;;;;;;;;;;;;AAeD,MAAa,YAAY,CAACE,OAAqB,KAAK,WAAmB,MAAM,GAAG;;;;;;;;;;;;;;;;;ACxBhF,SAAgB,gBAAgBC,WAAsBC,QAA2B;AAC/E,QAAOC,cAAY,WAAW,OAAK,MAAM,IAAI,OAAO,CAAC;AACtD;;;;;;;;AAoCD,SAAgBA,cAAYF,WAAsBG,IAAkD;CAClG,MAAM,SAASC,WAAS,UAAU;CAClC,IAAIC;AACJ,SAAQ,OAAO,OAAf;EACE,KAAK,CAAC,GAAG,CAAC;GACR,uBAA8B,QAAQ,GAAG;AACzC;EACF,KAAK,CAAC,IAAI,CAAC;GACT,uBAA+B,QAAQ,GAAG;AAC1C;EACF,KAAK,CAAC,KAAK,CAAC;GACV,uBAAgC,QAAQ,GAAG;AAC3C;EACF,QACE,OAAM,IAAI,MAAM,CAAC,gBAAgB,EAAG,OAAO,MAAO,4BAA4B,CAAC;CAClF;AACD,KAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,CAAC,0BAA0B,CAAC;AAGzD,KAAI,OAAO,cAAc,CAAC,MAAM,CAAC,CAC/B,QAAOC,cAAY,OAAO;AAE5B,QAAO;AACR;AAQD,SAAgB,WAAWN,WAAsBO,SAA4B;CAC3E,MAAM,SAASH,WAAS,UAAU;CAClC,OAAO,UAAU;AACjB,KAAI,OAAO,cAAc,CAAC,MAAM,CAAC,CAC/B,QAAOE,cAAY,OAAO;AAE5B,QAAO;AACR;;;;AC5BD,SAAS,gBAAgBE,SAAsBC,cAA4B,CAAC,GAAG,CAAC,EAA6C;AAC3H,KAAI,CAAC,MAAM,QAAQ,QAAQ,CAAE,OAAM,IAAI,MAAM,CAAC,kDAAkD,EAAG,OAAO,SAAU;AACpH,KAAI,QAAQ,SAAS,EAAG,OAAM,IAAI,MAAM,CAAC,uDAAuD,EAAG,QAAQ,QAAS;CAEpH,MAAM,IAAI,QAAQ,IAAI,YAAU,cAAc,QAAQ,YAAY,CAAC;AACnE,QAAO,CAAE,GAAG,SAAS,EAAE,AAAE;AAC1B;;;;;;;;;AAUD,MAAa,oBAAoB,CAACD,YAAyB;CACzD,MAAM,IAAI,QAAQ,IAAI,SAAKE,cAAYC,IAAE,CAAC;AAC1C,QAAO,CAAC,0BAA0B,EAAG,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAE,CAAC,CAAC;AACtD;;;;;;;;;;;;;;AAeD,MAAa,eAAe,CAACC,SAAoBC,SAAoBC,UAA4C,CAAE,MAAK;CACtH,MAAM,QAAQ,QAAQ,SAAS,CAAC,KAAK,CAAC;CACtC,MAAM,YAAY,QAAQ,aAAa,CAAC,OAAO,CAAC;CAEhD,IAAIC;AACJ,SAAQ,OAAR;EACE,KAAK,CAAC,GAAG,CAAC;GACR,uBAA8BC,UAAQ,SAAS,CAAC,UAAU,CAAC,CAAC,EAAEA,UAAQ,SAAS,CAAC,UAAU,CAAC,CAAC,EAAE,UAAU;AACxG;EACF,KAAK,CAAC,IAAI,CAAC;GACT,uBAA+BA,UAAQ,SAAS,CAAC,WAAW,CAAC,CAAC,EAAEA,UAAQ,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;AAChG;EACF,SACE,uBAAgCA,UAAQ,SAAS,CAAC,YAAY,CAAC,CAAC,EAAEA,UAAQ,SAAS,CAAC,YAAY,CAAC,CAAC,EAAE,UAAU;CACjH;AAED,QAAO,CAACC,WAAmBP,cAAY,MAAM,OAAO,CAAC;AAEtD;;;;;;;;;;;;;;;;;;AAmBD,MAAa,QAAQ,CAACF,SAAsBU,OAAgC,CAAE,MAAe;CAC3F,MAAM,YAAY,KAAK,aAAa,CAAC,OAAO,CAAC;CAC7C,MAAM,QAAQ,KAAK,SAAS,CAAC,KAAK,CAAC;CACnC,MAAM,SAAS,gBAAgB,SAAS,MAAM;CAE9C,IAAI,eAAe;AACnB,KAAI,OAAO,KAAK,iBAAiB,CAAC,MAAM,CAAC,EAAE;EACzC,eAAe,KAAK;AACpB,MAAI,eAAe,EAAG,OAAM,IAAI,MAAM,CAAC,uCAAuC,CAAC;CAChF,WAAU,OAAO,KAAK,eAAe,CAAC,MAAM,CAAC,EAAE;AAC9C,MAAI,KAAK,cAAc,QAAQ,OAAQ,OAAM,IAAI,MAAM,CAAC,yEAAyE,EAAG,QAAQ,OAAQ,aAAa,CAAC;EAClK,MAAM,aAAa,KAAK,aAAa,QAAQ;EAC7C,eAAe,KAAK,MAAM,aAAa,OAAO,OAAO;CACtD;CAED,MAAM,QAAQ,OAAO,IAAI,CAACC,UAAoB;EAE5C,MAAMC,aAAuB,YAAY,MAAO,IAAK,MAAO,IAAK;GAAE,OAAO;GAAc;GAAO;GAAW,WAAW;EAAM,EAAC;EAG5H,WAAW,KAAK,MAAO,GAAI;AAC3B,SAAO;CACR,EAAC;CAGF,MAAM,aAAa,OAAQ;CAC3B,MAAM,QAAQ,CAAE,WAAY,EAAK,EAAC;AAClC,QAAO,MAAM,MAAM,CAAC,IAAI,OAAKV,cAAY,EAAE,CAAC;AAC7C;AAyBD,SAAgB,YAAYW,GAAuBC,GAAcC,UAA8B,CAAE,GAAY;CAC3G,MAAM,YAAY,QAAQ,aAAa;CACvC,MAAM,QAAQ,QAAQ,SAAS;CAC/B,MAAM,QAAQ,QAAQ,SAAS,CAAC,KAAK,CAAC;CACtC,MAAM,YAAY,QAAQ,aAAa,CAAC,OAAO,CAAC;AAEhD,KAAI,CAAC,aAAa,QAAQ,EAAG,OAAM,IAAI,MAAM,CAAC,4DAA4D,CAAC;AAC3G,KAAI,aAAa,QAAQ,EAAG,OAAM,IAAI,MAAM,CAAC,0DAA0D,CAAC;CAExG,MAAM,KAAK,cAAc,GAAG,MAAM;CAClC,MAAM,KAAK,cAAc,GAAG,MAAM;CAGlC,IAAIR;AACJ,SAAQ,OAAR;EACE,KAAK,CAAC,GAAG,CAAC;GACR,uBAA8B,IAAiB,IAAiB,UAAU;AAC1E;EACF,KAAK,CAAC,KAAK,CAAC;GACV,uBAAgC,IAAmB,IAAmB,UAAU;AAChF;EACF,KAAK,CAAC,IAAI,CAAC;GACT,uBAA+B,IAAiB,GAAgB;AAChE;EACF,QACE,OAAM,IAAI,MAAM,CAAC,cAAc,EAAG,MAAO,kCAAkC,CAAC;CAC/E;AACD,KAAI,CAAC,MAAO,OAAM,IAAI,MAAM,CAAC,yCAAyC,EAAG,OAAQ;CAEjF,IAAI,SAAS;CACb,IAAI,UAAU;CACd,IAAI,QAAQ;AACZ,KAAI,WAAW;EACb,SAAS,KAAK,QAAQ;EACtB,UAAU;EACV,QAAQ,IAAI;CACb,OACC,SAAS,KAAK,QAAQ;CAGxB,MAAMS,UAAoB,CAAE;AAC5B,MAAK,IAAI,oBAAoB,SAAS,qBAAqB,OAAO,qBAAqB,QACrF,QAAQ,KAAK,MAAM,kBAAkB,CAAC;AAGxC,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE1ND,SAAgBC,UAAQC,QAAmBC,aAAqD;AAC9F,KAAI,gBAAgB,CAAC,UAAU,CAAC,EAC9B;MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,MAAM,OAAO,IAAI,MAAM,OAAO,CAC9D,mBAAyB,OAAO;CACjC,WACQ,gBAAgB,CAAC,YAAY,CAAC,EACvC;MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,MAAM,OAAO,CAC7C,qBAA2B,OAAO;CACnC,WACQ,gBAAgB,CAAC,YAAY,CAAC,EACvC;MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,QAAQ,OAAO,CAC/C,mBAA2B,OAAO;CACnC,WACQ,gBAAgB,CAAC,cAAc,CAAC,EACzC;MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,QAAQ,OAAO,CAC/C,mBAA6B,OAAO;CACrC,WACQ,gBAAgB,CAAC,SAAS,CAAC,EACpC;MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,MAAM,OAAO,CAC7C,eAAwB,OAAO;CAChC,WACQ,gBAAgB,CAAC,WAAW,CAAC,EACtC;MAAI,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,MAAM,OAAO,CAC7C,iBAA0B,OAAO;CAClC,MAED,OAAM,IAAI,MAAM,CAAC,aAAa,EAAG,YAAa,2BAA2B,EAAG,KAAK,UAAU,OAAO,EAAG;AAEvG,QAAOF,UAAQG,cAAY,OAAO,EAAE,YAAY;AACjD;;;;;;;AAQD,SAAgB,gBAAgBF,QAAmBC,aAA0C;CAC3F,MAAM,IAAIF,UAAQ,QAAQ,YAAY;AACtC,QAAOG,cAAY,EAAE;AACtB;AAOD,SAAgB,cAAcF,QAAmBG,aAAgE;AAC/G,KAAI,gBAAgB,CAAC,KAAK,CAAC,CAAE,QAAOJ,UAAQ,QAAQ,CAAC,YAAY,CAAC,CAAC;AACnE,KAAI,gBAAgB,CAAC,IAAI,CAAC,CAAE,QAAOA,UAAQ,QAAQ,CAAC,WAAW,CAAC,CAAC;AACjE,KAAI,gBAAgB,CAAC,GAAG,CAAC,CAAE,QAAOA,UAAQ,QAAQ,CAAC,UAAU,CAAC,CAAC;AAC/D,OAAM,IAAI,MAAM,CAAC,sBAAsB,EAAG,YAAa,CAAC,CAAC;AAC1D;AAED,MAAaG,gBAAc,CAACE,WAAuC;AACjE,KAAI,OAAO,WAAW,CAAC,MAAM,CAAC,CAAE,QAAO;AAEvC,KAAI,MAAM,OAAO,CACf,oBAA4B,OAAO;AAGrC,KAAI,MAAM,OAAO,CACf,sBAA6B,OAAO;AAGtC,KAAI,QAAQ,OAAO,CACjB,sBAA8B,OAAO;CAEvC,MAAM,QAAQ,oBAAoB,OAAO;AACzC,KAAI,MAAO,sBAA6B,MAAM;CAE9C,MAAM,QAAQ,oBAAoB,OAAO;AACzC,KAAI,MAAO,oBAA4B,MAAM;AAE7C,OAAM,IAAI,MAAM,CAAC,wBAAwB,EAAG,KAAK,UAAU,OAAO,CAAE,CAAC,CAAC;AACvE;AAED,MAAa,kBAAkB,CAACJ,WAAgC;CAC9D,MAAM,QAAQE,cAAY,OAAO;AACjC,QAAO,IAAIG,cAAS;AACrB;AAOD,MAAaC,UAAQ,CAACC,WAAmB;AACvC,SAAQ,OAAO,OAAf;EACE,KAAK,CAAC,GAAG,CAAC;WACO,OAAO;AACtB;EACF,KAAK,CAAC,IAAI,CAAC;WACO,OAAO;AACvB;EACF,KAAK,CAAC,KAAK,CAAC;WACO,OAAO;AACxB;EACF,QACE,OAAM,IAAI,MAAM,CAAC,2BAA2B,EAAG,OAAO,MAAO,CAAC,CAAC;CAClE;AACF;AAED,MAAaC,aAAW,CAACC,cAA2B;AAClD,KAAI,CAAC,YAAY,UAAU,CAAE,OAAM,IAAI,MAAM,CAAC,kGAAkG,EAAG,KAAK,UAAU,UAAU,EAAG;CAC/K,IAAIC;AACJ,KAAI,OAAO,cAAc,CAAC,MAAM,CAAC,EAAE,IAAI,cAAc,UAAU;MAC1D,IAAI;AACT,KAAI,MAAM,OAAW,OAAM,IAAI,MAAM,CAAC,4FAA4F,CAAC;CAEnIJ,QAAM,EAAE;AACR,QAAO;AACR;;;;;;;;;;;;;;;;;;;AAoBD,MAAa,gBAAgB,CAAC,GAAG,YAA+C;AAC9E,MAAK,MAAM,UAAU,SAAS;AAC5B,MAAI,WAAW,OAAW;AAC1B,MAAI,WAAW,KAAM;AACrB,MAAI;GACF,MAAM,IAAIE,WAAS,OAAO;AAC1B,UAAON,cAAY,EAAE;EACtB,QAAO,CAAe;CACxB;AACD,QAAO,CAAC,aAAa,CAAC;AACvB;AAKD,SAAgB,SAASS,KAAUC,cAA4B;CAO7D,IAAI,EAAE,GAAG,GAAG,GAAG,GAAG;CAClB,MAAM,UAAU,IAAI,WAAW;AAC/B,KAAI,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;EACvB,KAAK;EACL,KAAK;EACL,KAAK;CACN;CAED,MAAM,MAAM,KAAK,IAAI,GAAG,GAAG,EAAE;CAC7B,MAAM,MAAM,KAAK,IAAI,GAAG,GAAG,EAAE;CAE7B,IAAI,KAAK,MAAM,OAAO;CACtB,IAAI,IAAI;CACR,MAAM,IAAI;AAEV,KAAI,QAAQ,IAEV,KAAI,aACF,eAAuB,GAAG,GAAG,GAAG,QAAQ;KAExC,mBAAyB,GAAG,GAAG,GAAG,QAAQ;CAI9C,MAAM,IAAI,MAAM;CAChB,IAAI,KAAK,KAAM,KAAK,KAAK,MAAM,QAAQ,KAAK,MAAM;AAClD,SAAQ,KAAR;EACE,KAAK;GACH,MAAM,IAAI,KAAK,IAAI,KAAK;AACxB;EACF,KAAK;GACH,MAAM,IAAI,KAAK,IAAI,KAAK;AACxB;EACF,KAAK;GACH,MAAM,IAAI,KAAK,IAAI,KAAK;AACxB;CACH;AAED,KAAI,aACF,eAAuB,IAAI,KAAK,GAAG,GAAG,QAAQ;KAE9C,mBAAyB,GAAG,IAAI,KAAK,IAAI,KAAK,QAAQ;AAEzD;;;;;;;;;;ACxND,MAAa,kBAAkB,CAACC,MAAkBC,SAAqB;AACrE,KAAI,KAAK,aAAa,KAAK,eAAe,MAAM,CAAC,MAAM,CAAC,EAAE,KAAK,YAAY;AAC3E,KAAI,KAAK,aACP,KAAK,eAAe,MAAM,CAAC,YAAY,CAAC,EAAE,KAAK,YAAY,UAAU,CAAC;AAExE,KAAI,KAAK,YAAY,KAAK,aAAa,CAAC,gBAAgB,CAAC,EAAE,KAAK,WAAW;AAC3E,KAAI,KAAK,eACP,KAAK,aAAa,CAAC,cAAc,CAAC,EAAE,KAAK,cAAc;AAE1D;;;;ACbD,MAAa,eAAe,CAC1BC,IACAC,MACAC,iBACqB;CACrB,MAAM,IAAI,SAA2B,CAAC,MAAM,CAAC,EAAE,GAAG;AAElD,KAAI,KAAK,aACP,EAAE,aAAa,CAAC,WAAW,CAAC,EAAE,KAAK,aAAa,UAAU,CAAC;AAE7D,KAAI,KAAK,cACP,EAAE,aAAa,CAAC,YAAY,CAAC,EAAE,KAAK,cAAc,UAAU,CAAC;AAE/D,KAAI,KAAK,QAAQ,EAAE,aAAa,CAAC,MAAM,CAAC,EAAE,KAAK,OAAO,UAAU,CAAC;MAC5D,EAAE,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC,kBAAkB,CAAC,CAAC;AAEnD,KAAI,KAAK,SAAS,EAAE,aAAa,CAAC,OAAO,CAAC,EAAE,KAAK,QAAQ,UAAU,CAAC;AACpE,KAAI,KAAK,MAAM,EAAE,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,KAAK,UAAU,CAAC;AAC3D,KAAI,KAAK,MAAM,EAAE,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,KAAK,UAAU,CAAC;AAE3D,KAAI,cAAc;EAChB,MAAM,IAAI,cAAc;EACxB,EAAE,YAAY,EAAE;CACjB;AACD,QAAO;AACR;AAED,MAAa,iBAAiB,CAC5BC,MACAF,MACAG,aACW;AACX,KAAI,SAAS,KAAM,QAAO,CAAC,WAAW,CAAC;CAEvC,MAAM,SAAS,KAAK;AACpB,KAAI,WAAW,KAAM,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;CAC9D,MAAM,SAAS,gBAAgC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;CAGtE,IAAI,QAAQ,OAAO,cAAc,CAAC,CAAC,EAAG,KAAK,IAAK,CAAC;AAEjD,KAAI,UAAU,KACZ,QAAO,CAAC,KAAK,EAAG,KAAK,GAAI,CAAC,CAAC;AAG7B,KAAI,KAAK,OAAO,CAAC,QAAQ,CAAC,EAAE;EAC1B,OAAO;GAAE,GAAG;GAAM,aAAa,CAAC,WAAW,CAAC;EAAE;AAC9C,MAAI,CAAC,KAAK,cAAc,OAAO;GAAE,GAAG;GAAM,cAAc;EAAG;AAC3D,MAAI,CAAC,KAAK,aAAa,OAAO;GAAE,GAAG;GAAM,aAAa;EAAG;AACzD,MAAI,CAAC,KAAK,MAAM,OAAO;GAAE,GAAG;GAAM,MAAM,KAAK;EAAa;AAC1D,MAAI,CAAC,KAAK,MAAM,OAAO;GAAE,GAAG;GAAM,MAAM,KAAK;EAAc;AAC3D,MAAI,CAAC,KAAK,aAAa,KAAK,cAAc,CAAC,IAAI,CAAC,EAC9C,OAAO;GAAE,GAAG;GAAM,WAAW,CAAC,KAAK,CAAC;EAAE;AAExC,MAAI,CAAC,KAAK,SAAS,OAAO;GAAE,GAAG;GAAM,SAAS,CAAC,SAAS,CAAC;EAAE;EAE3D,QAAQ,aAAa,KAAK,IAAI,MAAM,MAAM;GACxC,MAAM,MAAM,SAAyB,CAAC,IAAI,CAAC,CAAC;GAC5C,IAAI,aAAa,CAAC,CAAC,CAAC,EAAE,CAAC,qBAAqB,CAAC,CAAC;AAC9C,OAAI,MAAM,UAAU,KAAK,KAAK;AAC9B,UAAO;EACR,EAAC;CACH,MAAM,OAAM,IAAI,MAAM,CAAC,wBAAwB,EAAG,KAAK,IAAK;CAG7D,MAAM,KAAK,KAAK;CAChB,OAAO,YAAY,MAAM;AAEzB,QAAO,CAAC,KAAK,EAAG,KAAK,GAAI,CAAC,CAAC;AAC5B;;;;;;;;;;AC/DD,MAAa,gBAAgB,CAACC,MAAkBC,SAA0B;AACxE,KAAI,KAAK,WACP,KAAK,aACH,CAAC,UAAU,CAAC,EACZ,eAAe,MAAM,KAAK,WAAW,KAAoB,CAC1D;AAEH,KAAI,KAAK,aACP,KAAK,aACH,CAAC,YAAY,CAAC,EACd,eAAe,MAAM,KAAK,aAAa,KAAoB,CAC5D;AAEH,KAAI,KAAK,WACP,KAAK,aACH,CAAC,UAAU,CAAC,EACZ,eAAe,MAAM,KAAK,WAAW,KAAoB,CAC1D;AAEJ;;;;;;;;;;;;;;;;;;;;;ACRD,MAAM,qBAAqB,CAACC,MAAsB;AAChD,KAAI,KAAK,KAAK,KAAK,EAAG,QAAO,GAAI,IAAI,IAAK,CAAC,CAAC;AAC5C,QAAO,EAAE,UAAU;AACpB;;;;;;;;;;;;;;;;AAiBD,MAAa,OAAO,CAClBC,YACAC,QACAC,MACAC,oBACmB;CACnB,MAAM,OAAO,gBACX,QACA,CAAC,IAAI,CAAC,EACN,gBACD;CACD,MAAM,MACJ,OAAO,eAAe,CAAC,MAAM,CAAC,GAAG,aAAa,WAAW,KAAK,CAAC,EAAE,CAAC,CAAC;CAErE,KAAK,eAAe,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI;CACnC,OAAO,OAAO,KAAK;AACnB,QAAO,WAAW,MAAM,KAAK;AAC9B;AAED,MAAa,aAAa,CACxBC,MACAF,SACG;AACH,KAAI,MAAM,UAAU,MAAM,KAAK;AAC/B,KAAI,MAAM,gBAAgB,MAAM,KAAK;AACrC,QAAO;AACR;;;;;;;;AASD,MAAa,eAAe,CAC1BG,MACAC,UACAC,SACG;CACH,KAAK,eAAe,MAAM,CAAC,EAAE,CAAC,EAAEC,SAAO,EAAE,UAAU,CAAC;CACpD,KAAK,eAAe,MAAM,CAAC,EAAE,CAAC,EAAEA,SAAO,EAAE,UAAU,CAAC;CACpD,KAAK,eAAe,MAAM,CAAC,CAAC,CAAC,EAAEA,SAAO,OAAO,UAAU,CAAC;AACxD,KAAI,MAAM,UAAU,MAAM,KAAK;AAC/B,KAAI,MAAM,gBAAgB,MAAM,KAAK;AAErC,QAAO;AACR;;;;;;;;;;;AAYD,MAAa,SAAS,CACpBF,UACAL,QACAM,MACAE,oBACqB;CACrB,MAAM,IAAI,gBACR,QACA,CAAC,MAAM,CAAC,EACR,gBACD;AACD,QAAO,aAAa,GAAGD,UAAQ,KAAK;AACrC;;;;;;;;;;AAWD,MAAa,QAAQ,CACnBE,UACAT,QACAU,oBACgB;CAChB,MAAM,IAAI,gBAA6B,QAAQ,CAAC,CAAC,CAAC,EAAE,gBAAgB;AACpE,QAAO,YAAY,GAAG,SAAS;AAChC;AAED,MAAa,cAAc,CACzBC,MACAF,aACG;AACH,MAAK,MAAM,KAAK,SACd,KAAI,EAAE,eAAe,MACnB,KAAK,OAAO,EAAE;AAIlB,QAAO;AACR;;;;;;;;;;AAWD,MAAa,OAAO,CAClBG,QACAZ,QACAa,MACAC,oBACmB;CACnB,MAAM,SAAS,gBACb,QACA,CAAC,IAAI,CAAC,EACN,gBACD;AACD,QAAO,WAAW,QAAQC,QAAM,KAAK;AACtC;;;;;;;;AASD,MAAa,aAAa,CACxBC,QACAJ,QACAC,SACG;CACH,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAEE,OAAK,EAAE,EAAE,UAAU,CAAC;CACtD,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAEA,OAAK,EAAE,EAAE,UAAU,CAAC;CACtD,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAEA,OAAK,EAAE,EAAE,UAAU,CAAC;CACtD,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAEA,OAAK,EAAE,EAAE,UAAU,CAAC;AACtD,KAAI,MAAM,UAAU,QAAQ,KAAK;AACjC,KAAI,MAAM,cAAc,QAAQ,KAAK;AACrC,KAAI,MAAM,gBAAgB,QAAQ,KAAK;AACvC,QAAO;AACR;AAED,MAAa,iBAAiB,CAACC,QAAwBC,KAAqBJ,SAA2B;CACrG,MAAM,kBAA0B,IAAI;CACpC,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,UAAU,CAAC;CACnD,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,UAAU,CAAC;CACnD,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,UAAU,CAAC;CACnD,OAAO,eAAe,MAAM,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,UAAU,CAAC;AACnD,KAAI,MAAM,UAAU,QAAQ,KAAK;AACjC,KAAI,MAAM,cAAc,QAAQ,KAAK;AACrC,KAAI,MAAM,gBAAgB,QAAQ,KAAK;AACvC,QAAO;AACR;;;;;;;;AASD,MAAa,iBAAiB,CAC5BK,IACAC,QACAC,SACG;AACH,KAAI,MAAM,QAAQ,GAAG,eAAe,MAAM,CAAC,MAAM,CAAC,EAAE,KAAK,OAAO;AAChE,KAAI,MAAM,MAAM,GAAG,eAAe,MAAM,CAAC,IAAI,CAAC,EAAE,KAAK,KAAK;AAC1D,KAAI,MAAM,SAAS,GAAG,eAAe,MAAM,CAAC,OAAO,CAAC,EAAE,KAAK,QAAQ;AACnE,KAAI,MAAM,aACR,GAAG,eAAe,MAAM,CAAC,WAAW,CAAC,EAAE,mBAAmB,KAAK,YAAY,CAAC;AAE9E,KAAI,MAAM,YACR,GAAG,eAAe,MAAM,CAAC,UAAU,CAAC,EAAE,mBAAmB,KAAK,WAAW,CAAC;AAG5E,KAAIC,QACF,GAAG,cAAcA;AAEnB,KAAI,MAAM,UAAU,IAAI,KAAK;AAC7B,KAAI,MAAM,gBAAgB,IAAI,KAAK;AACnC,QAAO;AACR;;;;;;;;;;;AAYD,MAAa,WAAW,CACtBC,eACAC,QACAvB,QACAoB,MACAI,qBACAC,wBACuB;CACvB,MAAM,SAAS,gBACb,QACA,CAAC,IAAI,CAAC,EACN,qBAAqB,CAAC,KAAK,CAAC,CAC7B;CAED,WAAW,QAAQ,QAAW,QAAW,KAAK;CAE9C,MAAM,IAAI,gBACR,QACA,CAAC,QAAQ,CAAC,EACV,oBACD;CACD,EAAE,eAAe,MAAM,CAAC,IAAI,CAAC,EAAE,cAAc;AAC7C,QAAO,eAAe,GAAGJ,QAAM,KAAK;AACrC;;;;;;;;;AAUD,MAAa,aAAa,CACxBK,IACAC,KACAR,QACAS,SACG;AACH,KAAI,KAAK;EACP,GAAG,eAAe,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,CAAC;EAC9C,GAAG,eAAe,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,UAAU,CAAC;CAC/C;AACD,KAAIP,QACF,GAAG,cAAcA;AAGnB,KAAI,MAAM;EACR,UAAU,IAAI,KAAK;AACnB,MAAI,MAAM,gBAAgB,IAAI,KAAK;AAEnC,MAAI,KAAK,QAAQ,GAAG,eAAe,MAAM,CAAC,WAAW,CAAC,EAAE,KAAK,OAAO;AACpE,MAAI,KAAK,OAAO,GAAG,eAAe,MAAM,CAAC,kBAAkB,CAAC,EAAE,KAAK,MAAM;EAEzE,MAAM,aAAa,KAAK,cAAc;AAEtC,MAAI,CAAC,YACH,GAAG,MAAM,aAAa,CAAC,IAAI,CAAC;CAE/B;AACD,QAAO;AACR;;;;;;;;;;AAWD,MAAa,OAAO,CAClBE,QACAvB,QACA2B,KACAC,MACAC,oBACmB;CACnB,MAAM,IAAI,gBACR,QACA,CAAC,IAAI,CAAC,EACN,gBACD;AACD,QAAO,WAAW,GAAG,KAAKR,QAAM,KAAK;AACtC;;;;;;;;;;;;;;AAeD,MAAa,OAAO,CAClBrB,QACA8B,UACAC,SACAC,OACAC,QACAC,OAAwB,CAAE,MACvB;AACH,KAAI,CAAC,KAAK,aACR,OAAO;EAAE,GAAG;EAAM,aAAaC,cAAkB,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC;CAAE;AAExE,KAAI,CAAC,KAAK,aAAa,OAAO;EAAE,GAAG;EAAM,aAAa;CAAG;CAEzD,MAAM,IAAI,SAAsB,CAAC,CAAC,CAAC,CAAC;CACpC,UAAU,GAAG,KAAK;CAClB,cAAc,GAAG,KAAK;CACtB,gBAAgB,GAAG,KAAK;CAGxB,IAAI,IAAI;AACR,QAAO,IAAI,QAAQ;EACjB,MAAM,oBAA0B,GAAG,GAAG,OAAO,EAAE;EAC/C,KAAK,OAAO,EAAE;EACd,KAAK;CACN;CAGD,IAAI,IAAI;AACR,QAAO,IAAI,OAAO;EAChB,MAAM,mBAAyB,GAAG,GAAG,GAAG,OAAO;EAC/C,KAAK,MAAM,EAAE;EACb,KAAK;CACN;CACD,OAAO,OAAO,EAAE;AAChB,QAAO;AACR;;;;;;;;;AC7WD,MAAa,kBAAkB,CAACC,OAA6B;AAC3D,KAAI,CAAC,GAAI,OAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;CAClD,MAAM,IAAI;EAAE,GAAG,GAAG,GAAG,QAAQ;EAAO,GAAG,GAAG,GAAG,QAAQ;CAAO;CAC5D,MAAM,IAAI;EAAE,GAAG,GAAG,GAAG,QAAQ;EAAO,GAAG,GAAG,GAAG,QAAQ;CAAO;AAC5D,QAAO;EAAE;EAAG;CAAG;AAChB;AAED,MAAa,sBAAsB,CAACA,IAAoBC,WAAkC;CACxF,MAAM,IAAI,gBAAgB,GAAG;AAC7B,iBAA0B,GAAG,OAAO;AACrC;;;;;;;;;;AChBD,MAAa,SAAS,CACpBC,QACAC,oBACG;AACH,KAAI,OAAO,oBAAoB,CAAC,MAAM,CAAC,EAAE;EACvC,MAAM,OAAO,OAAO,cAAc,gBAAgB;AAClD,MAAI,SAAS,KAAM;EACnB,KAAK,QAAQ;CACd,OACC,gBAAgB,QAAQ;AAE3B;;;;;AAMD,MAAa,QAAQ,CAACD,WAAuB;CAC3C,IAAI,IAAI,OAAO;AACf,QAAO,GAAG;EACR,EAAE,QAAQ;EACV,IAAI,OAAO;CACZ;AACF;;;;;;;;;;ACiGD,MAAa,aAAa,CACxBE,QACAC,eACc;AACd,KAAI,YAAY;EACd,UAAU,QAAQ,WAAW;EAC7B,gBAAgB,QAAQ,WAAW;CACpC;CAED,MAAMC,IAAe;EACnB,QAAQ,CAACC,oBAAyC;GAAE,OAAO,QAAQ,gBAAgB;EAAG;EACtF,MAAM,CACJC,QACAC,KACAC,MACAC,yBACiBC,QAAM,QAAQ,KAAK,MAAM,gBAAgB;EAC5D,UAAU,CACRC,eACAL,QACAE,MACAI,qBACAC,iCACqB,eAAeH,QAAM,QAAQ,MAAM,qBAAqB,oBAAoB;EACnG,MAAM,CACJI,QACAC,MACAC,yBACiBC,QAAM,QAAQ,MAAM,gBAAgB;EACvD,QAAQ,CACNC,UACAC,MACAC,2BACmBC,UAAQ,QAAQ,MAAM,gBAAgB;EAC3D,MAAM,CACJC,WACAC,MACAC,yBACiB,WAAW,QAAQ,MAAM,gBAAgB;EAC5D,MAAM,CACJC,UACAC,SACAC,OACAC,QACAb,cACiB,QAAQc,UAAQ,SAAS,OAAO,QAAQ,KAAK;EAChE,OAAO,CAAuBC,cAC5B,OAAO,cAAc,UAAU;EACjC,IAAI,QAAgB;GAClB,MAAM,IAAI,OAAO,eAAe,MAAM,CAAC,KAAK,CAAC,CAAC;AAC9C,OAAI,MAAM,KAAM,QAAO;AACvB,UAAO,OAAO,WAAW,EAAE;EAC5B;EACD,IAAI,MAAMH,OAAe;GACvB,OAAO,eAAe,MAAM,CAAC,KAAK,CAAC,EAAE,MAAM,UAAU,CAAC;EACvD;EACD,IAAI,SAAqB;AACvB,UAAO;EACR;EACD,IAAI,SAAiB;GACnB,MAAM,IAAI,OAAO,eAAe,MAAM,CAAC,MAAM,CAAC,CAAC;AAC/C,OAAI,MAAM,KAAM,QAAO;AACvB,UAAO,OAAO,WAAW,EAAE;EAC5B;EACD,IAAI,OAAOC,QAAgB;GACzB,OAAO,eAAe,MAAM,CAAC,MAAM,CAAC,EAAE,OAAO,UAAU,CAAC;EACzD;EACD,OAAO,MAAM;AACX,UAAO,OAAO,YACX,OAAO,UAA0B,QAAQ;EAE7C;CACF;AACD,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AEvKD,MAAa,mBAAmB,CAC9BG,WACAC,UAAgB,CAAE,MACf;CACH,MAAM,cAAc,QAAQ,eAAe;CAC3C,MAAM,cAAc,QAAQ,eAAe;CAC3C,MAAM,QAAQ,QAAQ,SAAS;CAC/B,MAAM,MAAM,QAAQ,OAAO;CAE3B,MAAM,iBAAiB,CAAC,KAAK,EAAG,IAAK,iBAAiB,CAAC;CACvD,IAAI,aAAa;CAEjB,MAAM,KAAK,UAAU,UAAU;CAC/B,MAAM,UAAU,IAAI,cAAc,EAChC,mBAAmB,MACpB;CAGD,MAAM,MAAM,SAAS,gBACnB,CAAC,0BAA0B,CAAC,EAC5B,CAAC,GAAG,CAAC,CACN;CACD,IAAI,KAAK,CAAC,UAAU,CAAC;CACrB,IAAI,MAAM,SAAS,CAAC,KAAK,CAAC;CAC1B,IAAI,MAAM,WAAW,CAAC,KAAK,CAAC;CAC5B,IAAI,MAAM,MAAM,CAAC,CAAC,CAAC;CACnB,IAAI,MAAM,OAAO,CAAC,CAAC,CAAC;CACpB,IAAI,MAAM,QAAQ,CAAC,IAAI,CAAC;CACxB,IAAI,MAAM,SAAS,CAAC,IAAI,CAAC;CACzB,IAAI,MAAM,YAAY,CAAC,UAAU,CAAC;CAClC,IAAI,MAAM,SAAS,CAAC,aAAa,CAAC;CAClC,IAAI,MAAM,gBAAgB,CAAC,IAAI,CAAC;CAChC,IAAI,MAAM,cAAc,CAAC,IAAI,CAAC;CAU9B,MAAM,KAAK,aAAa,YAAY,IAAI;CAExC,IAAI,eAAe;CAEnB,MAAM,cAAc,CAACC,UAAwB;EAC3C,MAAM,KAAK,MAAM,UAAU,UAAU;EAErC,QAAQ,OAAO,GAAG;EAClB,aAAa;EACb,IAAI,cAAc,CAAC,UAAU,EAAG,IAAK,CAAC,EAAE,QAAQ;AAEhD,OAAK,IAAI,QAAQ,GAAG,QAAQ,eAAe,IAAI,SAC7C,IAAI,cAAc,CAAC,aAAa,EAAG,GAAI,CAAC,EAAG,OAAQ,CAAC,EAAE,QAAQ;EAEhE,eAAe;CAChB;CAED,MAAM,eAAe,OAAOA,UAAwB;EAClD,MAAM,KAAK,MAAM,UAAU,UAAU;EACrC,MAAM,KAAK;GAAE,GAAG,MAAM;GAAG,GAAG,MAAM;EAAG;EACrC,MAAM,OAAO,MAAM;AACnB,MAAI,MAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,IAAI,GAAG,CAClD;EAEF,MAAM,OAAQ,MAAM,QAAQ,KAAK,MAAM,UAAU,UAAU,EAAE;GAAE,GAAG,MAAM;GAAS,GAAG,MAAM;EAAS,EAAC;AAEpG,MAAI,KAAK,OAAO,WAAW,GAAG;GAC5B,MAAMC,cACJ;IACE,GAAG,KAAK,OAAQ;IAChB,QAAQ,SAAS,CAAC,KAAK,CAAC,GAAG,cAAc;GAC1C,GACD,KACA,EACE,WAAW,eACZ,GACD,CAAC,UAAU,EAAG,IAAK,CACpB;GACDA,KAAG,MAAM,gBAAgB,CAAC,IAAI,CAAC;GAC/BA,KAAG,MAAM,cAAc,CAAC,IAAI,CAAC;EAC9B;EAED,MAAM,YAAY,CAAC,KAAK,EAAG,WAAY,iBAAiB,CAAC;EAEzD,MAAM,aACJ;GAAE,GAAG;GAAI,QAAQ,SAAS,CAAC,KAAK,CAAC,GAAG,cAAc;EAAa,GAC/D,KACA,EACE,UACD,GACD,CAAC,aAAa,EAAG,GAAI,CAAC,EAAG,KAAK,OAAO,QAAS,CAC/C;EACD,IAAI,MAAM,gBAAgB,CAAC,IAAI,CAAC;EAChC,IAAI,MAAM,cAAc,CAAC,IAAI,CAAC;EAC9B,cAAc;EACd,eAAe,KAAK,OAAO;CAC5B;CAED,SAAS,KAAK,OAAO,IAAI;CAGzB,GAAG,iBAAiB,CAAC,WAAW,CAAC,EAAE,aAAa;CAEhD,GAAG,iBAAiB,CAAC,WAAW,CAAC,EAAE,aAAa;CAChD,GAAG,iBAAiB,CAAC,SAAS,CAAC,EAAE,YAAY;CAC7C,GAAG,iBAAiB,CAAC,YAAY,CAAC,EAAE,YAAY;CAChD,GAAG,iBAAiB,CAAC,WAAW,CAAC,EAAE,CAAC,UAAU;EAC5C,MAAM,gBAAgB;CACvB,EAAC;AACH;;;;;;ACzGD,MAAa,SAAS,CAACC,cACrB,IAAI,uBAAuB;AAE7B,IAAM,yBAAN,MAA6B;CAC3B,AAASC,yBAA8B,IAAI;CAC3C,AAASC,2BAAgC,IAAI;CAE7C,AAAS;CACT,gBAAgB;CAEhB;CAEA,YAAYF,WAAmC;AAC7C,MAAI,cAAc,QAAW,KAAK,YAAY;OACzC,KAAK,YAAY;GAAE,CAAC,GAAG,CAAC;GAAE,CAAC,IAAI,CAAC;GAAE,CAAC,KAAK,CAAC;GAAE,CAAC,MAAM,CAAC;EAAE;EAC1D,KAAKG,eAAe,SAAS;CAC9B;CAED,eAAeC,IAAa;EAC1B,KAAKD,eAAe;CACrB;CAED,IAAIE,KAAaC,QAAgB;EAC/B,KAAKL,OAAO,IAAI,KAAK,OAAO;CAC7B;CAED,MAAMM,MAAcC,IAAY;EAC9B,KAAKN,SAAS,IAAI,MAAM,GAAG;CAC5B;CAED,IAAIG,KAAaI,UAA2B;EAC1C,MAAM,QAAQ,KAAKP,SAAS,IAAI,IAAI;AACpC,MAAI,UAAU,QAAW,MAAM;EAE/B,MAAM,IAAI,KAAKD,OAAO,IAAI,IAAI;AAC9B,MAAI,MAAM,OAAW,QAAO;EAE5B,MAAM,eAAe,CAAC,EAAE,CAAC,GAAG;EAC5B,IAAIS,YAAU,iBAAiB,KAAKP,aAAa,CAC9C,iBAAiB,aAAa,CAC9B,MAAM;AAGT,MAAIO,cAAY,UAAaA,UAAQ,WAAW,GAAG;AACjD,OAAI,aAAa,OAAW,QAAO;GACnCA,YAAU,KAAK,UAAW,KAAKC;GAC/B,KAAKA;AACL,OAAI,KAAKA,kBAAkB,KAAK,UAAU,QAAQ,KAAKA,gBAAgB;EACxE;AACD,SAAOD;CACR;CAED,SAASL,KAAaI,UAA2B;AAC/C,MAAI,KAAK,IAAI,IAAI,CAAE,QAAO,KAAK,IAAI,IAAI;EACvC,MAAM,IAAI,KAAK,IAAI,KAAK,SAAS;EACjC,KAAK,IAAI,KAAK,EAAE;AAChB,SAAO;CACR;CAED,IAAIJ,KAAsB;AACxB,SAAO,KAAKJ,OAAO,IAAI,IAAI;CAC5B;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHD,gBAAuB,OACrBW,eACAC,OAAmB,CAAE,GACK;CAI1B,MAAM,gBAAgB,KAAK,iBAAiB;CAE5C,MAAM,aAAa,KAAK,cAAc;CACtC,IAAI,WAAW,KAAK;CACpB,IAAI,GAAG;CACP,IAAI,IAAI;AAGR,KAAI,aAAa,QAAW;EAC1B,WAAW,SAAS,cAAc,CAAC,MAAM,CAAC,CAAC;EAC3C,SAAS,UAAU,IAAI,CAAC,WAAW,CAAC,CAAC;AACrC,MAAI,CAAC,YACH,SAAS,MAAM,UAAU,CAAC,IAAI,CAAC;EAEjC,SAAS,KAAK,YAAY,SAAS;CACpC;CAGD,MAAM,aAAa,MAAM;AACvB,MAAI,aAAa,OAAW;EAC5B,IAAI,cAAc;EAClB,IAAI,cAAc;EAClB,SAAS,QAAQ;EACjB,SAAS,SAAS;CACnB;CAED,IAAIC,IAAqC;CAEzC,MAAM,SAAS,UAAU,cAAc;AACvC,YAAW,MAAM,KAAK,QAAQ;AAE5B,MAAI,MAAM,KAAK,MAAM,GAAG,YAAY;AAGpC,MAAI,MAAM,KAAK,MAAM,EAAG;EAGxB,MAAM,SAAS,WAAW,CAAC,EAAE,CAAC,CAAC;AAC/B,MAAI,MAAM,KAAM;EAChB,EAAE,UAAU,eAAe,GAAG,GAAG,GAAG,EAAE;EAGtC,MAAM,SAAS,EAAE,aAAa,GAAG,GAAG,GAAG,EAAE;EACzC,MAAM;CACP;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDD,MAAa,UAAU,CACrBF,eACAG,OAAoB,CAAE,MACT;CACb,MAAM,gBAAgB,KAAK,iBAAiB;CAC5C,MAAM,aAAa,KAAK,cAAc;CACtC,MAAM,UAAU,KAAK;CAGrB,MAAM,IAAI,cAAc;CACxB,MAAM,IAAI,cAAc;CAGxB,MAAM,WAAW,SAAS,cAAc,CAAC,MAAM,CAAC,CAAC;CACjD,SAAS,UAAU,IAAI,CAAC,YAAY,CAAC,CAAC;AAEtC,KAAI,CAAC,YACH,SAAS,MAAM,UAAU,CAAC,IAAI,CAAC;CAEjC,SAAS,QAAQ;CACjB,SAAS,SAAS;CAClB,IAAID,IAAqC;CACzC,IAAIE;AACJ,KAAI,KAAK,cACP,SAAS,IAAI,OAAO,KAAK;CAI3B,MAAM,YAAY,UAAU;AAC5B,KAAI,CAAC,aAAa,CAAC,YACjB,QAAQ,KACN,CAAC,uFAAuF,CAAC,CAC1F;CAGH,MAAM,OAAO,aAAa,MAAM;AAE9B,MAAI,MAAM,MAAM,IAAI,SAAS,WAAW,CAAC,EAAE,CAAC,CAAC;AAC7C,MAAI,MAAM,KAAM;EAChB,EAAE,UAAU,eAAe,GAAG,GAAG,GAAG,EAAE;EACtC,IAAIC;AAEJ,MAAI,WAEF,SAAS,EAAE,aAAa,GAAG,GAAG,GAAG,EAAE;AAGrC,MAAI,QAEF,OAAO,YACL;GACE,QAAQ,OAAQ,KAAK;GACrB,OAAO;GACP,QAAQ;GACR,UAAU;EACX,GACD,CAAE,OAAQ,KAAK,MAAQ,EACxB;AAEH,MAAI,QAEF,KAAI;GACF,QAAQ,OAAQ;EACjB,SAAQ,GAAG;GACV,QAAQ,MAAM,EAAE;EACjB;CAEJ,GAAE,cAAc;AAEjB,QAAO;EACL,OAAO,MAAM;GAAE,KAAK,OAAO;EAAG;EAC9B,QAAQ,MAAM;GAAE,KAAK,QAAQ;EAAG;EAChC;CACD;AACF;AAED,MAAa,gBAAgB,CAC3BL,eACAM,OAA0B,CAAE,MACT;CACnB,MAAM,aAAa,KAAK,cAAc;CAGtC,MAAM,IAAI,cAAc;CACxB,MAAM,IAAI,cAAc;CAGxB,MAAM,kBAAkB,KAAK,aAAa;CAC1C,IAAI,WAAW,KAAK;AACpB,KAAI,CAAC,UAAU;EACb,WAAW,SAAS,cAAc,CAAC,MAAM,CAAC,CAAC;EAC3C,SAAS,UAAU,IAAI,CAAC,YAAY,CAAC,CAAC;EACtC,SAAS,KAAK,OAAO,SAAS;AAC9B,MAAI,CAAC,YAAY,SAAS,MAAM,UAAU,CAAC,IAAI,CAAC;CACjD;CAED,SAAS,QAAQ;CACjB,SAAS,SAAS;CAElB,MAAMC,YAAU,MAAiB;EAC/B,IAAIC;AAGJ,MAAI,CAACC,KAAGA,MAAI,SAAS,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,oBAAoB,KAAM,EAAC;AACnE,MAAI,CAACA,IAAG,OAAM,IAAI,MAAM,CAAC,iCAAiC,CAAC;EAC3DA,IAAE,UAAU,eAAe,GAAG,GAAG,GAAG,EAAE;EAEtC,MAAM,SAASA,IAAE,aAAa,GAAG,GAAG,GAAG,EAAE;EAExC,OAAe,cAAc,cAAc;AAE5C,MAAI,KAAK,iBAAiB,KAAK,gBAAgBA,KAAG,GAAG,EAAE;AACvD,SAAO;CACR;CAED,MAAM,UAAU,MAAY;AAC1B,MAAI,gBAAiB;AACrB,MAAI;GACF,SAAS,QAAQ;EAClB,SAAQ,GAAG,CAEX;CACF;CAED,MAAMC,IAAoB;EACxB;EACA;EACA;CACD;AACD,QAAO;AACR;;;;;;ACpSD,SAAS,oBAAoBC,IAAiBC,MAAcC,cAAsB;CAChF,MAAM,IAAI,GAAG,aAAa,KAAK;AAC/B,KAAI,MAAM,KAAM,QAAO;AACvB,QAAO,OAAO,SAAS,EAAE;AAC1B;;;;;;;;;;;;;AAoBD,MAAa,OAAO,CAACC,cAAsBC,UAA8B,CAAE,MAAkB;CAC3F,MAAM,UAAU,SAAS,cAAiC,aAAa;AACvE,KAAI,CAAC,QAAS,OAAM,IAAI,MAAM,CAAC,kCAAkC,EAAG,aAAc,CAAC,CAAC;CACpF,MAAM,SAAS,QAAQ,UAAU,CAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,AAAE;CAC7C,MAAM,iBAAiB,QAAQ,kBAAkB;CACjD,MAAM,gBAAgB,QAAQ,iBAAiB;CAC/C,MAAM,oBAAoB,QAAQ,qBAAqB;CAEvD,MAAM,eAAe,QAAQ,gBAAgB;CAC7C,MAAM,UAAU,QAAQ,WAAW;CACnC,MAAM,aAAa,QAAQ,cAAc;CACzC,MAAM,sBAAsB,QAAQ,uBAAuB;CAE3D,MAAM,2BAAkC,QAAQ,YAAY,CAAC,MAAM,CAAC,CAAC;CACrE,MAAM,yBAAgC,QAAQ,UAAU,CAAC,KAAK,CAAC,CAAC;CAChE,MAAM,8BAAqC,QAAQ,eAAe,CAAC,KAAK,CAAC,CAAC;CAC1E,MAAM,0BAAiC,QAAQ,WAAW,QAAQ,eAAe,CAAC,KAAK,CAAC,CAAC;CACzF,MAAM,4BAAmC,QAAQ,aAAa,QAAQ,YAAY,CAAC,MAAM,CAAC,CAAC;CAG3F,MAAM,YAAa,QAAQ,aAAa,IAAI,OAAO;CACnD,MAAM,YAAa,QAAQ,aAAa,IAAI,OAAO;CACnD,MAAM,MAAO,QAAQ,WAAW,KAAK,OAAO;CAC5C,MAAM,cAAe,QAAQ,eAAe,IAAI,OAAO;CACvD,MAAM,QAAS,QAAQ,SAAS,oBAAoB,SAAS,CAAC,KAAK,CAAC,EAAE,IAAI,GAAG,OAAO;CACpF,MAAM,SAAU,QAAQ,UAAU,oBAAoB,SAAS,CAAC,MAAM,CAAC,EAAE,IAAI,GAAG,OAAO;CAEvF,IAAIC;AACJ,KAAI,oBAAoB,GACtB,aAAa,IAAI,eAAiC;EAChD,UAAU;EACV,eAAe,CAAC,KAAK,CAAC;CACvB;CAGH,QAAQ,QAAQ;CAChB,QAAQ,SAAS;CACjB,QAAQ,MAAM,QAAQ,GAAK,QAAQ,OAAO,iBAAmB,EAAE,CAAC;CAChE,QAAQ,MAAM,SAAS,GAAK,SAAS,OAAO,iBAAmB,EAAE,CAAC;CAElE,MAAM,OAAO,SAAS;CACtB,MAAM,OAAO,QAAQ;CACrB,MAAM,MAAM,QAAQ,WAAW,CAAC,EAAE,CAAC,CAAC;AACpC,KAAI,CAAC,IAAK,OAAM,IAAI,MAAM,CAAC,gCAAgC,CAAC;AAE5D,KAAI,OAAO,oBAAoB,GAC7B,IAAI,OAAO,CAAC,eAAe,CAAC;CAE9B,MAAM,mBAAmB,CAACC,MAAc,GAAI,KAAK,MAAM,IAAI,IAAI,CAAE,CAAC,CAAC;CACnE,MAAM,cAAc,CAACA,MAAc,EAAE,QAAQ,eAAe;CAE5D,MAAM,cAAc,gBAAgB,mBAAmB;AACvD,KAAI,YAAY;EACd,OAAQ,KAAM,OAAQ,KAAM,CAAC,CAAC,CAAC;EAC/B,OAAQ,KAAM,OAAQ,KAAM,CAAC,CAAC,CAAC;CAChC,OAAM;EACL,OAAQ,KAAM,EAAE;EAChB,OAAQ,KAAM,EAAE;CACjB;CAED,MAAMC,mBAA2B,QAAQ,qBAAqB,CAACC,OAAKC,SAAOC,aAAiB;AAC1F,MAAI,QAAQ,aAAa,CAAC,WAAW,CAAC,EACpCF,MAAI,UAAU,GAAG,GAAGC,SAAOC,SAAO;OAC7B;GACLF,MAAI,YAAY;GAChBA,MAAI,SAAS,GAAG,GAAGC,SAAOC,SAAO;EAClC;CACF;AAED,QAAO,CAACC,GAAWC,MAAc;EAC/B,YAAkB,EAAE;EACpB,YAAkB,EAAE;EAEpB,iBAAiB,KAAK,OAAO,OAAO;EAGpC,IAAI,YAAY;EAChB,IAAI,eAAe,CAAC,GAAG,CAAC;EACxB,IAAI,MAAM;EACV,IAAI,UAAU,MAAM,KAAK;EACzB,IAAI,OAAO,CAAC,KAAK,KAAK,EAAE;EACxB,IAAI,UAAU,OAAQ,KAAM,CAAC,CAAC,CAAC,GAAG,YAAY,EAAE,EAAE,MAAM,EAAE,CAAC,OAAO,KAAK,EAAE;EACzE,IAAI,SAAS;EACb,IAAI,UAAU,OAAQ,KAAM,CAAC,CAAC,CAAC,GAAG,YAAY,EAAE,EAAE,MAAM,EAAE,KAAK,OAAO,EAAE;AAExE,MAAI,CAAC,qBAAqB,KAAK;EAG/B,IAAI,cAAc;EAClB,IAAI,YAAY;EAChB,IAAI,WAAW;EACf,IAAI,OAAO,KAAK,KAAK;EACrB,IAAI,OAAO,QAAQ,KAAK,KAAK;EAC7B,IAAI,OAAO,MAAM,IAAI;EACrB,IAAI,OAAO,MAAM,SAAS,IAAI;EAC9B,IAAI,QAAQ;EACZ,IAAI,WAAW;EAEf,MAAM,MAAM,SAAS,MAAM,OAAO,IAAI,CAAC;EACvC,MAAM,MAAM,QAAQ,MAAM,OAAO,IAAI;EACrC,MAAM,SAAS;GAAE,GAAG;GAAI,GAAG;GAAI,QAAQ;EAAW;AAElD,MAAI,YACF,aAAa,WAAW,QAAQ,OAAO;EAEzC,IAAI,MAAM;EACV,IAAI,UAAU,MAAM,KAAK;AAGzB,MAAI,QACF,KAAI,YAAY;GACd,MAAM,cAAc,IAAI,WAAW;GACnC,IAAI,UAAU;GACd,WAAW,QAAQ,OAAK;IACtB,MAAM,yBAAgC,WAAW,QAAQ;aAC1C,KAAK,GAAG,EAAE,WAAW,OAAQ,EAAC;IAC7C,WAAW;GACZ,EAAC;EACH,gBACgB,KAAK,QAAQ,EAAE,WAAW,UAAW,EAAC;AAKzD,MAAI,cAAc;GAChB,IAAI,cAAc;GAGlB,IAAI,WAAW;GACf,IAAI,OAAO,GAAG,KAAK,YAAY;GAC/B,IAAI,OAAO,GAAG,KAAK,YAAY;GAG/B,IAAI,OAAO,KAAK,aAAa,EAAE;GAC/B,IAAI,OAAO,KAAK,aAAa,EAAE;GAC/B,IAAI,QAAQ;GACZ,IAAI,WAAW;EAChB;EAGD,IAAI,SAAS;CACd;AACF;;;;AClID,MAAa,gBAAgB,CAACC,OAA6B;CACzD,MAAM,IAAI,GAAG,IAAI,OAAK,EAAE,EAAE;CAC1B,MAAM,IAAI,GAAG,IAAI,OAAK,EAAE,EAAE;CAC1B,MAAM,OAAO,KAAK,IAAI,GAAG,EAAE;CAC3B,MAAM,OAAO,KAAK,IAAI,GAAG,EAAE;CAC3B,MAAM,OAAO,KAAK,IAAI,GAAG,EAAE;CAC3B,MAAM,OAAO,KAAK,IAAI,GAAG,EAAE;CAC3B,MAAM,QAAQ,OAAO;CACrB,MAAM,SAAS,OAAO;AAEtB,QAAO;EACL,KAAK;GAAE,GAAG;GAAM,GAAG;EAAM;EACzB,KAAK;GAAE,GAAG;GAAM,GAAG;EAAM;EACzB;EAAO;EACP,QAAQ,KAAK,IAAI,OAAO,OAAO;EAC/B,QAAQ,KAAK,IAAI,OAAO,OAAO;CAChC;AACF;AAED,MAAa,kBAAkB,CAACC,WAAwB;AACtD,KAAI,CAAC,OAAO,SAAS,OAAO,OAAO,CACjC,QAAO,CAACC,UAAiB;CAE3B,MAAM,SAAS,OAAO,OAAO,IAAI,GAAG,OAAO,IAAI,EAAE;CACjD,MAAM,SAAS,OAAO,OAAO,IAAI,GAAG,OAAO,IAAI,EAAE;AACjD,QAAO,CAACA,WAAkB;EACxB,GAAG,OAAO,MAAM,EAAE;EAClB,GAAG,OAAO,MAAM,EAAE;CACnB;AACF;AAED,MAAa,kBAAkB,CAACD,WAAwB;CACtD,MAAM,SAAS,OAAO,GAAG,GAAG,OAAO,IAAI,GAAG,OAAO,IAAI,EAAE;CACvD,MAAM,SAAS,OAAO,GAAG,GAAG,OAAO,IAAI,GAAG,OAAO,IAAI,EAAE;AACvD,QAAO,CAACC,WAAkB;EACxB,GAAG,OAAO,MAAM,EAAE;EAClB,GAAG,OAAO,MAAM,EAAE;CACnB;AACF;AAKD,MAAa,kBAAkB,CAACC,IAAiBC,YAAoBC,UAAoD;CAEvH,MAAMC,UAAsB,CAAE;CAC9B,IAAI,QAAQ;AAEZ,MAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,YAAY;EACpD,MAAM,UAAU,QAAQ,UAAU;EAClC,QAAQ,KAAK;GAAE;GAAG,GAAG;GAAG,OAAO;EAAS,EAAC;EACzC;CACD;CAGD,QAAQ;CACR,MAAMC,UAAsB,CAAE;AAC9B,MAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,KAAK,YAAY;EACpD,MAAM,UAAU,QAAQ,UAAU;EAClC,QAAQ,KAAK;GAAE,GAAG;GAAG;GAAG,OAAO;EAAS,EAAC;EACzC;CACD;AACD,QAAO;EAAE,GAAG;EAAS,GAAG;CAAS;AAClC;;;;AC5ID,IAAa,UAAb,MAA0C;CACxC;CACA;CACA;CAEA,cAAc;EACZ,KAAK,aAAa,YAAY,KAAK;EACnC,KAAKC,QAAQ,IAAI;EAEjB,KAAKC,wBAAQ,IAAI;CAClB;CAED,IAAI,YAAY;AACd,SAAO,KAAKA,MAAM;CACnB;CAED,QAAQ;EACN,KAAKD,MAAM,OAAO;EAClB,KAAK,aAAa,YAAY,KAAK;CACpC;CAED,IAAIE,QAAgBC,MAAgB;EAClC,KAAKH,MAAM,UAAU,QAAQ,KAAK;CACnC;CAED,eAAeE,QAAgB;EAC7B,MAAM,UAAU,KAAKF,MAAM,OAAO,OAAO;AACzC,MAAI,SACF,KAAK,aAAa,YAAY,KAAK;AAErC,SAAO;CACR;CAED,QAAQE,QAAgBE,MAAmB;EACzC,KAAKH,MAAM,IAAI,QAAQ,KAAK;CAC7B;CAED,QAAQC,QAAgB;AACtB,SAAO,KAAKD,MAAM,IAAI,OAAO;CAC9B;CAED,QAAQC,QAAgB;AACtB,SAAO,KAAKD,MAAM,IAAI,OAAO;CAC9B;CAED,CAAC,YAAY;EACX,OAAO,KAAKD,MAAM,YAAY;CAC/B;CAED,CAAC,aAAa;EACZ,OAAO,KAAKA,MAAM,SAAS;CAC5B;CAED,CAAC,YAAY;EACX,OAAO,KAAKA,MAAM,QAAQ;CAC3B;CAED,IAAIK,OAAe,SAAS,CAAC,OAAO,CAAC,EAAE;EACrC,KAAKL,MAAM,eAAe,QAAQ,MAAM;EACxC,KAAK,aAAa,YAAY,KAAK;CACpC;AACF;;;;AC/DD,MAAa,OAAO,KAAK,KAAG;;;;ACiC5B,IAAa,eAAb,MAA0B;CACxB;CACA;CACA;CACA;CACA;CACA;CAEA,WAA2B,CAAE;CAE7B,YAAYM,sBAAkDC,YAA2B,CAAC,GAAG,CAAC,EAAE;EAC9F,KAAKC,YAAY,UAA6B,qBAAqB;EACnE,KAAKC,aAAa;EAClB,KAAKC,gBAAgB,OAAO,oBAAoB;EAChD,KAAKC,cAAc,KAAKC,mBAAmB;EAC3C,KAAKC,eAAe,KAAK,eAAe;GAAE,OAAO,KAAKL,UAAU;GAAO,QAAQ,KAAKA,UAAU;EAAQ,EAAC;CACxG;CAGD,eAAeM,MAAY;EACzB,KAAKD,eAAe;EACpB,MAAM,KAAK,KAAKL;EAChB,GAAG,QAAS,KAAK,QAAQ,KAAKE;EAC9B,GAAG,SAAU,KAAK,SAAS,KAAKA;EAEhC,GAAG,MAAM,QAAQ,GAAK,KAAK,MAAO,UAAU,CAAE,EAAE,CAAC;EACjD,GAAG,MAAM,SAAS,GAAK,KAAK,OAAQ,UAAU,CAAE,EAAE,CAAC;EACnD,KAAKC,cAAc,KAAKC,mBAAmB;EAC3C,KAAK,mBAAmB;AACxB,SAAO;CACR;CAED,oBAAoB;EAClB,IAAI,QAAQ;AACZ,UAAQ,KAAKH,YAAb;GACE,KAAK,CAAC,GAAG,CAAC;IACR,QAAQ,KAAK,IAAI,KAAKD,UAAU,OAAO,KAAKA,UAAU,OAAO;AAC7D;GACF,KAAK,CAAC,GAAG,CAAC;IACR,QAAQ,KAAK,IAAI,KAAKA,UAAU,OAAO,KAAKA,UAAU,OAAO;AAC7D;EACH;EACD,MAAM,IAAI,aAAa,GAAG,OAAO,GAAG,EAAE;AACtC,SAAO;GACL,KAAK,EAAE;GACP,KAAK,EAAE;EACR;CACF;CAED,oBAAoB;EAClB,KAAKO,OAAO;CACb;CAED,KAAKC,QAAsB;AACzB,MAAI,CAAC,OAAQ,OAAM,IAAI,MAAM,CAAC,gCAAgC,CAAC;AAC/D,MAAI,KAAKC,SAAS,SAAS,OAAO,CAAE,OAAM,IAAI,MAAM,CAAC,qBAAqB,CAAC;EAC3E,KAAKA,SAAS,KAAK,OAAO;AAC1B,SAAO;CACR;CAGD,WAAWC,IAAWC,OAAsB,CAAC,WAAW,CAAC,EAAE;EACzD,IAAI,EAAE,GAAG,GAAG,GAAG;AACf,UAAQ,MAAR;GACE,KAAK,CAAC,WAAW,CAAC;IAChB,KAAK,KAAK;IACV,KAAK,KAAK;EAEb;AACD,SAAO;GAAE;GAAG;EAAG;CAChB;CAED,IAAI,SAAS;EACX,MAAM,IAAI,KAAKX,UAAU,uBAAuB;AAChD,SAAO;GAAE,GAAG,EAAE;GAAM,GAAG,EAAE;EAAK;CAC/B;CAED,WAAWU,IAAWE,QAA6BC,OAA+B,CAAC,WAAW,CAAC,EAAE,UAAU,MAAM;EAC/G,IAAI,EAAE,GAAG,GAAG,GAAG;AACf,MAAI,WAAW,CAAC,MAAM,CAAC,EAAE;GACvB,MAAM,IAAI,KAAKb,UAAU,uBAAuB;GAChD,KAAK,EAAE;GACP,KAAK,EAAE;EACR;AACD,UAAQ,MAAR;GACE,KAAK,CAAC,WAAW,CAAC;IAChB,KAAK,KAAK;IACV,KAAK,KAAK;AACV;GACF,KAAK,CAAC,IAAI,CAAC,CACT;EACH;AACD,MAAI,SAAS;GACX,IAAI,MAAM,EAAE;GACZ,IAAI,MAAM,EAAE;EACb;AACD,SAAO;GAAE;GAAG;EAAG;CAChB;CAED,UAAUc,QAA6BH,OAAsB,CAAC,WAAW,CAAC,EAAE;EAC1E,IAAI,EAAE,OAAO,QAAQ,GAAGI;AACxB,UAAQ,MAAR;GACE,KAAK,CAAC,WAAW,CAAC;IAChB,SAAS,KAAK;IACd,UAAU,KAAK;AACf,yBAA2BA,OAAK,CAC9B,QAAO;KACL,GAAG,KAAK,WAAWA,OAAK;KACxB;KACA;IACD;EAEN;AACD,SAAO;GAAE;GAAO;EAAQ;CACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgCD,aAAaC,MAAwB;EACnC,MAAM,WAAW,KAAK,YAAY;EAClC,MAAM,YAAY,WAAW;AAC7B,MAAI,CAAC,aAAa,CAAC,IAAI,MAAM;GAC3B,MAAMD,sBAA0B,KAAK,eAAe,UAAU,SAAS;AACvE,UAAO,KAAKE,KAAK,IAAI,aAAa,MAAM,MAAMF,QAAM;EACrD;AAED,MAAI,CAAC,kBAAkB,CAAC,IAAI,MAAM;GAChC,IAAIG;GACJ,MAAMH,SAAO,KAAK;AAClB,WAAQ,KAAK,OAAb;IACE,KAAK,CAAC,WAAW,CAAC;KAChB,UAAU,CAACI,YAA0C;MACnD,GAAIJ,OAAK,IAAI,OAAO,QAAS;MAC7B,GAAIA,OAAK,IAAI,OAAO,SAAU;MAC9B,OAAQA,OAAK,QAAQ,OAAO,QAAS;MACrC,QAASA,OAAK,SAAS,OAAO,SAAU;KACzC;AACD;IACF,QACE,OAAM,IAAI,MAAM,CAAC,sBAAsB,EAAG,KAAK,MAAO,CAAC,CAAC;GAC3D;AACD,UAAO,KAAKE,KAAK,IAAI,aAAa,MAAM,SAAS;EAClD;AAED,MAAI,CAAC,YAAY,CAAC,IAAI,MAAM;GAC1B,IAAIC;GACJ,MAAMH,SAAO,KAAK;GAClB,MAAM,WAAW,KAAK;AAEtB,WAAQ,KAAK,OAAb;IACE,KAAK,CAAC,WAAW,CAAC;KAChB,UAAU,CAACI,WAAyC;MAClD,MAAM,QAASJ,OAAK,QAAQ,OAAO,QAAS;MAC5C,MAAM,SAAUA,OAAK,SAAS,OAAO,SAAU;MAC/C,IAAI,IAAI,OAAO,QAAQ,IAAI,QAAQ;MACnC,IAAI,IAAI,OAAO,SAAS,IAAI,SAAS;AACrC,cAAQ,UAAR;OACE,KAAK,CAAC,CAAC,CAAC;QACN,IAAI;AACJ;OACF,KAAK,CAAC,CAAC,CAAC;QACN,IAAI,OAAO,SAAS;AACpB;OACF;MAED;MACD,KAAK;MACL,KAAK;AACL,aAAO;OAAE;OAAO;OAAQ;OAAG;MAAG;KAC/B;AACD;IACF,QACE,OAAM,IAAI,MAAM,CAAC,sBAAsB,EAAG,KAAK,MAAO,CAAC,CAAC;GAC3D;AACD,UAAO,KAAKE,KAAK,IAAI,aAAa,MAAM,SAAS;EAClD;AAED,MAAI,CAAC,KAAK,CAAC,IAAI,MAAM;GACnB,MAAM,SAAS,kBAAkB,KAAK,MAAM;AAC5C,OAAI,CAAC,OAAO,QACV,OAAM,IAAI,MAAM,CAAC,iCAAiC,EAAG,oBAAoB,OAAO,EAAG;GAErF,MAAM,UAAU,CAACG,YAA0C;IACzD,MAAM,SAAS,OAAO,MAAM,uBAAuB;AACnD,WAAO;KACL,GAAG,OAAO,IAAI;KACd,GAAG,OAAO,IAAI;KACd,OAAO,OAAO,QAAQ;KACtB,QAAQ,OAAO,SAAS;IACzB;GACF;AACD,UAAO,KAAKH,KAAK,IAAI,aAAa,MAAM,SAAS;EAClD;AACD,QAAM,IAAI,MAAM,CAAC,uBAAuB,CAAC;CAC1C;CAED,QAAQ;EACN,MAAM,IAAI,KAAK;EACf,EAAE,UAAU,GAAG,GAAG,KAAK,OAAO,KAAK,OAAO;CAC3C;CAED,IAAI,UAAU;AACZ,MAAI,KAAKV,KAAM,QAAO,KAAKA;EAC3B,MAAM,IAAI,KAAKP,UAAU,WAAW,CAAC,EAAE,CAAC,CAAC;AACzC,MAAI,CAAC,EAAG,OAAM,IAAI,MAAM,CAAC,2BAA2B,CAAC;EACrD,EAAE,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE;EAChC,EAAE,MAAM,KAAKE,eAAe,KAAKA,cAAc;EAE/C,KAAKK,OAAO;AAEZ,OAAK,MAAM,KAAK,KAAKE,UACnB,EAAE,iBAAiB;AAErB,SAAO,KAAKF;CACb;CAED,IAAI,aAAa;AACf,SAAO,KAAKJ;CACb;CAED,IAAI,QAAQ;AACV,SAAO,KAAKE,aAAa;CAC1B;CAED,IAAI,SAAS;AACX,SAAO,KAAKA,aAAa;CAC1B;AACF;;;;AAKD,IAAa,eAAb,MAA0B;CACxB;CACA;CACA;;;;CAKA,YAAYc,QAAsBE,eAAyD;EACzF,KAAK,SAAS;EACd,KAAKC,iBAAiB;EACtB,KAAKC,KAAK,cAAc,OAAO;CAChC;;;;;CAMD,kBAAkB;EAChB,KAAKA,KAAK,KAAKD,eAAe,KAAK,OAAO;CAC3C;;;;;;;;;;;;CAaD,YAAYE,WAAkBC,UAAkB,CAAC,IAAI,CAAC,EAAE;AACtD,UAAQ,SAAR;GACE,KAAK,CAAC,IAAI,CAAC,CACT,QAAO;IACL,GAAG,UAAU,IAAI,KAAKF,GAAG;IACzB,GAAG,UAAU,IAAI,KAAKA,GAAG;GAC1B;EAEJ;CACF;;;;;;CAOD,kBAAkBG,GAAU;AAC1B,SAAO;GACL,GAAG,EAAE,IAAI,KAAKH,GAAG;GACjB,GAAG,EAAE,IAAI,KAAKA,GAAG;EAClB;CACF;;;;;;;;CASD,4BAA4BI,gBAAyBC,aAAqB,YAAY,GAAG;EACvF,MAAM,SAAS,eAAe,IAAI,OAAK,KAAK,YAAY,EAAE,CAAC;EAC3D,KAAK,oBAAoB,QAAQ,aAAa,UAAU;CACzD;;;;;;;;;;CAWD,oBAAoBC,QAAiBD,aAAqB,YAAY,GAAG;EACvE,MAAM,IAAI,KAAK;EACf,EAAE,MAAM;EACR,EAAE,UAAU,KAAKL,GAAG,GAAG,KAAKA,GAAG,EAAE;EACjC,EAAE,WAAW;EACb,EAAE,cAAc;EAChB,EAAE,YAAY;AACd,OAAK,IAAI,QAAQ,GAAG,QAAQ,OAAO,QAAQ,QACzC,KAAI,UAAU,GACZ,EAAE,OAAO,OAAQ,OAAQ,GAAG,OAAQ,OAAQ,EAAE;OAE9C,EAAE,OAAO,OAAQ,OAAQ,GAAG,OAAQ,OAAQ,EAAE;EAGlD,EAAE,QAAQ;EACV,EAAE,SAAS;CACZ;;;;;;;;;CAUD,iBAAiBO,QAAcC,QAAe,YAAY,CAAC,KAAK,CAAC,EAAEC,MAAcC,WAA+B,CAAC,UAAU,CAAC,EAAEC,QAAyB,CAAC,KAAK,CAAC,EAAE;EAC9J,MAAM,QAAQ,KAAK,YAAY,OAAO;EACtC,KAAK,iBAAiBC,QAAM,OAAO,WAAW,MAAM,UAAU,MAAM;CACrE;;;;;;;;;CAUD,SAASL,QAAcM,OAAc,YAAY,CAAC,KAAK,CAAC,EAAEJ,MAAcC,WAA+B,CAAC,UAAU,CAAC,EAAEC,QAAyB,CAAC,KAAK,CAAC,EAAE;EACrJ,MAAM,IAAI,KAAK;EACf,EAAE,MAAM;EACR,EAAE,UAAU,KAAKX,GAAG,GAAG,KAAKA,GAAG,EAAE;AACjC,MAAI,KAAK,SAAS,GAChB,EAAE,OAAO;EAEX,EAAE,eAAe;EACjB,EAAE,YAAY;EACd,EAAE,YAAY;EACd,EAAE,SAASY,QAAM,MAAM,GAAG,MAAM,EAAE;EAClC,EAAE,SAAS;CACZ;CAED,YAAYE,iBAAqCC,WAAmB,cAAc,EAAE,EAAE,YAAY,GAAG;EACnG,MAAM,UAAU,gBAAgB,IAAI,SAAK;AACvC,UAAO;IACL,GAAG,KAAK,YAAYC,IAAE;IACtB,QAAQ,KAAK,OAAO,WAAW,IAAIA,IAAE,OAAO;GAC7C;EACF,EAAC;EAEF,MAAM,IAAI,KAAK;EACf,EAAE,MAAM;EACR,EAAE,UAAU,KAAKhB,GAAG,GAAG,KAAKA,GAAG,EAAE;EACjC,EAAE,YAAY;EACd,EAAE,cAAc;EAChB,EAAE,YAAY;AAEd,OAAK,MAAMiB,YAAU,SAAS;GAC5B,EAAE,WAAW;GACb,EAAE,IAAIA,SAAO,GAAGA,SAAO,GAAGA,SAAO,QAAQ,GAAG,KAAK;GACjD,EAAE,WAAW;AACb,OAAI,UAAU,SAAS,GACrB,EAAE,MAAM;AAEV,OAAI,YAAY,SAAS,GACvB,EAAE,QAAQ;EAEb;EACD,EAAE,SAAS;CACZ;CAED,QAAQ;EACN,MAAM,IAAI,KAAK;EACf,EAAE,UAAU,KAAKjB,GAAG,GAAG,KAAKA,GAAG,GAAG,KAAKA,GAAG,OAAO,KAAKA,GAAG,OAAO;CACjE;CAED,KAAK,YAAY,CAAC,KAAK,CAAC,EAAE;EACxB,MAAM,IAAI,KAAK;EACf,EAAE,YAAY;EACd,EAAE,SAAS,KAAKA,GAAG,GAAG,KAAKA,GAAG,GAAG,KAAKA,GAAG,OAAO,KAAKA,GAAG,OAAO;CAChE;CAED,WAAWK,aAAqB,YAAY,GAAG;EAC7C,KAAK,4BAA4B;GAC/B;IAAE,GAAG;IAAG,GAAG;GAAG;GACd;IAAE,GAAG;IAAG,GAAG;GAAG;GACd;IAAE,GAAG;IAAG,GAAG;GAAG;GACd;IAAE,GAAG;IAAG,GAAG;GAAG;GACd;IAAE,GAAG;IAAG,GAAG;GAAG;EACf,GAAE,aAAa,UAAU;EAE1B,KAAK,4BAA4B,CAC/B;GAAE,GAAG;GAAG,GAAG;EAAG,GACd;GAAE,GAAG;GAAG,GAAG;EAAG,CACf,GAAE,aAAa,UAAU;EAC1B,KAAK,4BAA4B,CAC/B;GAAE,GAAG;GAAG,GAAG;EAAG,GACd;GAAE,GAAG;GAAG,GAAG;EAAG,CACf,GAAE,aAAa,UAAU;CAC3B;;;;;;;CAQD,WAAWlB,IAAWE,SAA8B,CAAC,MAAM,CAAC,EAAED,OAAsB,CAAC,WAAW,CAAC,EAAE,UAAU,MAAM;EACjH,KAAK,KAAK,OAAO,WAAW,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE,MAAM;EACtD,IAAI,EAAE,GAAG,GAAG,GAAG;EACf,KAAK,KAAK;EACV,KAAK,KAAK;AAEV,UAAQ,MAAR;GACE,KAAK,CAAC,WAAW,CAAC;IAChB,KAAK,KAAK;IACV,KAAK,KAAK;EACb;AACD,MAAI,SAAS;GACX,IAAI,MAAM,EAAE;GACZ,IAAI,MAAM,EAAE;EACb;AACD,SAAO;GAAE;GAAG;EAAG;CAChB;CAED,iBAAiBD,IAAW+B,QAAkBC,SAAkB;AAC9D,MAAI,WAAW,CAAC,MAAM,CAAC,EACrB,cAAqB,IAAI,KAAK,OAAO,OAAO;EAG9C,IAAI,EAAE,GAAG,GAAG,GAAG;EACf,KAAK,KAAK;EACV,KAAK,KAAK;AAEV,MAAI,SAAS;AACX,OAAI,IAAI,GAAG,IAAI;AACf,OAAI,IAAI,GAAG,IAAI;AACf,OAAI,IAAI,KAAK,QAAQ,KAAK,GAAG,IAAI,KAAK,IAAI,KAAK;AAC/C,OAAI,IAAI,KAAK,SAAS,KAAK,GAAG,IAAI,KAAK,IAAI,KAAK;EACjD;AACD,SAAO;GAAE;GAAG;EAAG;CAChB;CAED,IAAI,SAAS;AACX,gBAAoB,KAAKnB,GAAG;CAC7B;CAED,IAAI,UAAU;AACZ,SAAO,KAAK,OAAO;CACpB;CAED,IAAI,OAAOoB,OAAuB;EAChC,KAAKpB,KAAK;CACX;CAED,IAAI,SAAS;AACX,SAAO,KAAKA;CACb;CAED,IAAI,QAAQ;AACV,SAAO,KAAKA,GAAG;CAChB;CAED,IAAI,SAAS;AACX,SAAO,KAAKA,GAAG;CAChB;CAED,IAAI,IAAI;AACN,SAAO,KAAKA,GAAG;CAChB;CAED,IAAI,IAAI;AACN,SAAO,KAAKA,GAAG;CAChB;CAED,IAAI,eAAe;AACjB,SAAO,KAAK,IAAI,KAAKA,GAAG,OAAO,KAAKA,GAAG,OAAO;CAC/C;AACF;;;;ACjhBD,MAAa,SAAS,CAACqB,eAA8BC,UAAuD,CAAE,MAAK;CAEjH,MAAM,WAAY,cAAc,WAAW,SAAa,SAAS,OAAO,UAAU,cAAc,OAAO;CACvG,MAAM,WAAW,SAAS,cAAc,CAAC,MAAM,CAAC,CAAC;CACjD,SAAS,QAAQ,SAAS;CAE1B,MAAM,KAAK,IAAI;CAEf,MAAM,SAAS,IAAI,aAAa,UAAU,CAAC,GAAG,CAAC;CAC/C,MAAM,OAAO,cAAc,UAAW,EAAE,oBAAoB;EAAE,GAAG;EAAG,GAAG;EAAG,OAAO;EAAG,QAAQ;CAAG,EAAE;CACjG,MAAM,SAAS,OAAO,aAAa,KAAK;CACxC,MAAM,IAAI,IAAI,oBAAoB,QAAQ,IAAI;AAE9C,KAAI,cAAc,mBAAmB,CAAC,QAAQ,CAAC,EAC7C,aAAa,eAAe,UAAU,EACpC,gBAAgB,CAAC,MAAM,QAAQ;EAC7B,OAAO,eAAe,KAAK;EAC3B,EAAE,iBAAiB;EACnB,EAAE,MAAM;CACT,EACF,EAAC;MAGF,aAAa,aAAa,UAAU,EAClC,gBAAgB,CAAC,MAAM,QAAQ;EAC7B,OAAO,eAAe,KAAK;EAC3B,EAAE,iBAAiB;EACnB,EAAE,MAAM;CACT,EACF,EAAC;AAEJ,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CD,IAAa,sBAAb,MAAiC;CAC/B;CACA;CACA;CAEA;CACA;CACA;CACA;CACA,cAAc,MAAM,GAAG,KAAK;CAC5B;;;;;CAMA,eAAqC,CAAE;CACvC;CACA;CAEA;CAEA;CACA;CACA;CACA;CACA;CACA;CACA;CAEA,YAAYC,IAAkBC,MAA2CF,UAAuD,CAAE,GAAE;AAClI,MAAI,CAAC,KAAM,OAAM,IAAI,UAAU,CAAC,yBAAyB,CAAC;AAC1D,MAAI,OAAO,SAAS,CAAC,MAAM,CAAC,CAAE,OAAM,IAAI,UAAU,CAAC,oCAAoC,EAAG,OAAO,MAAO;EACxG,KAAK,gBAAgB,QAAQ;EAC7B,KAAKG,QAAQ;EACb,KAAKC,gBAAgB;EACrB,KAAKC,kBAAkB;EACvB,KAAKC,eAAe,QAAQ,SAAS,CAAC,MAAM,CAAC;EAC7C,KAAKC,aAAa,QAAQ,SAAS,CAAC,IAAI,CAAC;EACzC,KAAKC,cAAc,QAAQ,cAAc,CAAC,GAAG,CAAC;EAC9C,KAAKC,gBAAgB,QAAQ,gBAAgB,EAAE;EAC/C,KAAK,gBAAgB,QAAQ,iBAAiB;EAC9C,KAAKC,iBAAiB,QAAQ,iBAAiB;EAC/C,KAAK,OAAO;GACV,MAAM;GACN,YAAY;GACZ,MAAM;GACN,UAAU;GACV,GAAG,QAAQ;EACZ;EAED,KAAKC,aAAa;GAChB,QAAQ,CAAC,KAAK,CAAC;GACf,OAAO;GACP,GAAG,QAAQ;EACZ;EACD,KAAKC,aAAa;GAChB,QAAQ,CAAC,KAAK,CAAC;GACf,MAAM,CAAC,GAAG,CAAC;GACX,MAAM,CAAC,SAAS,CAAC;GACjB,GAAG,QAAQ;EACZ;EAED,KAAKC,QAAQ;GACX,YAAY;GACZ,OAAO;GACP,QAAQ,CAAC,UAAU,CAAC;GACpB,OAAO;GACP,GAAG,QAAQ;EACZ;CACF;CAED,kBAAkB;AAChB,MAAI,KAAKV,MAAM,eAAe,KAAKE,mBAAmB,KAAKS,cAAe,QAAO,KAAKA;EACtF,KAAKT,kBAAkB,KAAKF,MAAM;EAClC,MAAM,IAAI,KAAKY,cAAc;EAC7B,KAAKD,gBAAgB;AACrB,MAAI,KAAK,eAAe,KAAK,eAAe;AAC5C,SAAO;CACR;CAED,kBAAkB;EAChB,KAAKA,gBAAgB;CACtB;CAED,eAAwC;EAEtC,MAAM,QAAQ,KAAK,cAAc;EAEjC,MAAM,oCAAyC,MAAM;EACrD,MAAM,+BAAoC,MAAM;EAChD,MAAM,KAAK,KAAKV;EAChB,MAAM,UAAU,KAAKM;EAIrB,IAAI,UAAU,GAAG,IAAI;EACrB,IAAI,UAAU,GAAG,IAAI;EAErB,MAAM,gBAAgB,GAAG,SAAU,UAAU;EAC7C,MAAM,eAAe,GAAG,QAAS,UAAU;EAC3C,MAAM,eAAe,KAAK,IAAI,eAAe,aAAa;AAE1D,MAAI,gBAAgB,eAElB,WAAY,eAAe,IAAM,eAAe;OAGhD,WAAY,gBAAgB,IAAM,eAAe;EAGnD,MAAM,kBAAkB,CAACM,OAAc;GACrC,IAAI,EAAE,GAAG,GAAG,GAAG;AACf,OAAI,MAAM,OAAO,mBAAmB,IAAI;YAC/B,MAAM,OAAO,mBAAmB,IAAI;AAC7C,OAAI,MAAM,OAAO,mBAAmB,IAAI;YAC/B,MAAM,OAAO,mBAAmB,IAAI;GAC7C,IAAI,IAAI;GACR,KAAK,IAAI,KAAK;GAEd,KAAK;GACL,KAAK;AAEL,UAAO;IAAE;IAAG;GAAG;EAChB;EAED,MAAM,kBAAkB,CAACA,OAAc;GACrC,IAAI,EAAE,GAAG,GAAG,GAAG;GACf,KAAK;GACL,KAAK;GACL,IAAI,IAAI;GACR,IAAI,IAAK,IAAI;AACb,UAAO;IAAE;IAAG;GAAG;EAChB;EAGD,MAAM,wBAAwB,CAACA,OAAc;GAC3C,IAAI,EAAE,GAAG,GAAG,GAAG;GACf,IAAI,IAAI,GAAG,IAAI,KAAKN;GACpB,IAAK,eAAe,KAAKA,iBAAkB;GAC3C,KAAK;GACL,IAAK,IAAI;AACT,UAAO;IAAE;IAAG;GAAG;EAChB;AAED,SAAO;GACL;GAAmB;GAAiB;GAAiB;GAAuB;GAAc;EAC3F;CACF;;;;;;;;CAUD,kBAAkBO,MAAaC,mBAAyCC,KAA4B,CAAC,MAAM,CAAC,EAAEC,iBAAwC;EACpJ,MAAM,KAAK,UAAU,kBAAkB;EACvC,IAAI,EAAE,GAAG,GAAG,GAAG,KAAK,mBAAmB,KAAK;AAG5C,MAAI,OAAO,CAAC,MAAM,CAAC,EAAE;GACnB,MAAM,SAAS,GAAG,uBAAuB;GACzC,KAAK,OAAO,QAAQ;GACpB,KAAK,OAAO,SAAS;EACtB,WAAU,OAAO,CAAC,QAAQ,CAAC,EAAE,CAE7B,MAAM,OAAM,IAAI,MAAM,CAAC,iDAAiD,CAAC;AAC1E,MAAI,iBAAiB;GACnB,MAAM,aAAa,UAAU,gBAAgB;GAC7C,MAAM,SAAS,WAAW,uBAAuB;GAGjD,KAAK,OAAO;GACZ,KAAK,OAAO;EACb;EACD,GAAG,MAAM,OAAO,GAAI,EAAG,EAAE,CAAC;EAC1B,GAAG,MAAM,MAAM,GAAI,EAAG,EAAE,CAAC;CAC1B;;;;;;CAOD,eAAiC;AAC/B,MAAI,KAAKb,eAAe,CAAC,IAAI,CAAC,CAC5B,sBAA0B,CAAE,GAAG,KAAKJ,MAAM,WAAW,AAAE,EAAC;OACnD;AACL,OAAI,CAAC,KAAKkB,cACR,KAAKA,6BAAkC,CAAE,KAAKd,WAAW,KAAK,KAAKA,WAAW,GAAK,EAAC;AAEtF,UAAO,KAAKc;EACb;CACF;CAED,mBAAmBC,WAAkB;EACnC,MAAM,SAAS,KAAK,mBAAmB,UAAU;EACjD,MAAMC,WAAS,KAAK,aAAa;EACjC,MAAM,MAAM;GACV,GAAG,OAAO,IAAIA,SAAO;GACrB,GAAG,OAAO,IAAIA,SAAO;EACtB;AACD,SAAO;CACR;CAED,mBAAmBC,WAAkB,QAAQ,OAAO;EAClD,MAAM,KAAK,KAAK,iBAAiB;EAGjC,MAAM,MAAM,GAAG,kBAAkB,UAAU;EAG3C,MAAM,SAAS,GAAG,gBAAgB,IAAI;AAEtC,MAAI,OAAO,QAAQ,IAAI,CAAC,MAAM,EAAG,UAAU,EAAG,CAAC,EAAG,UAAU,EAAG,MAAM,EAAG,IAAI,EAAG,CAAC,EAAG,IAAI,EAAG,SAAS,EAAG,OAAO,EAAG,CAAC,EAAG,OAAO,GAAI,CAAC;AAChI,SAAO;GACL,GAAG;GACH,GAAG,OAAO;GACV,GAAG,OAAO;EACX;CACF;;;;;;;CA0BD,aAAaC,OAAcC,SAAmB;EAC5C,MAAM,KAAK,KAAK,iBAAiB;EAGjC,MAAM,uBAA8B,OAAO,KAAK,aAAa,OAAO;EAEpE,MAAM,IAAI,GAAG,gBAAgB,YAAY;AACzC,SAAO,GAAG,aAAa,EAAE;CAC1B;;;;;;CA6BD,wBAAwBC,QAAeC,QAAe,QAAQ,OAAa;EACzE,SAAS,KAAK,mBAAmB,QAAQ,MAAM;EAC/C,SAAS,KAAK,mBAAmB,QAAQ,MAAM;AAC/C,SAAO;GAAE,GAAG;GAAQ,GAAG;EAAQ;CAChC;CAED,iBAA6B;AAC3B,SAAO;GACL,QAAQ,kBAAkB,KAAKzB,MAAM,UAAU;GAC/C,WAAW;GACX,WAAW;EACZ;CACF;CAED,OAAO;AACL,MAAI,KAAKG,iBAAiB,CAAC,MAAM,CAAC,EAChC,KAAKF,cAAc,OAAO;OAE1B,KAAK,aAAa,OAAO;EAO3B,KAAKyB,UAAU;AACf,MAAI,KAAK,KAAK,MAAM,KAAKC,WAAW;AAGpC,OAAK,MAAM,CAAE,GAAG,EAAG,IAAI,KAAK3B,MAAM,YAAY,EAAE;GAC9C,IAAI,OAAO,KAAKA,MAAM,QAAQ,EAAE;AAChC,OAAI,CAAC,MAAM;IACT,OAAO,KAAK,gBAAgB;IAC5B,KAAKA,MAAM,QAAQ,GAAG,KAAK;GAC5B;GACD,KAAK4B,YAAY,GAAG,GAAG,KAAK;EAE7B;AAED,OAAK,MAAMC,UAAQ,KAAK,cACtB,KAAK,SAASA,QAAMA,OAAK,QAAQA,OAAK,MAAM;CAE/C;;;;;;;CAQD,SAASC,QAAYC,QAAgBC,OAAe;EAClD,MAAM,IAAI,KAAKC,wBAAwBJ,OAAK,GAAGA,OAAK,EAAE;EACtD,KAAKK,qBAAqB,GAAG,QAAQ,MAAM;CAC5C;CAED,QAAQC,QAAgBC,MAA2B;EACjD,KAAKpC,MAAM,QAAQ,QAAQ;GACzB,GAAG,KAAK,gBAAgB;GACxB,GAAG;EACJ,EAAC;CACH;CAED,YAAY;EACV,MAAM,EAAE,QAAQ,OAAO,GAAG,KAAKQ;EAE/B,MAAM,QAAQ,KAAKyB,wBAAwB;GAAE,GAAG;GAAG,GAAG,OAAO;EAAmB,GAAE;GAAE,GAAG;GAAG,GAAG,OAAO;EAAmB,GAAE,MAAM;EAC/H,MAAM,QAAQ,KAAKA,wBAAwB;GAAE,GAAG,OAAO;GAAmB,GAAG;EAAG,GAAE;GAAE,GAAG,OAAO;GAAmB,GAAG;EAAG,GAAE,MAAM;EAG/H,KAAKC,qBAAqB,OAAO,QAAQ,OAAO,MAAM;EACtD,KAAKA,qBAAqB,OAAO,QAAQ,OAAO,MAAM;CACvD;CAGD,iBAAiBG,SAAkB;EAEjC,MAAM,MAAM,KAAKpC,cAAc;EAE/B,IAAI,OAAO,KAAKQ,WAAW,OAAO,CAAC,CAAC,CAAC,GAAG,KAAKA,WAAW;EACxD,IAAI,YAAY,KAAKA,WAAW;EAChC,IAAI,eAAe,CAAC,MAAM,CAAC;AAG3B,OAAK,MAAM,KAAK,SAAS;AACvB,OAAI,EAAE,MAAM,KAAK,EAAE,MAAM,EAAG;GAC5B,MAAM,MAAM,KAAK,mBAAmB,GAAG,MAAM;GAC7C,MAAM,QAAQ,KAAK,YAAY,EAAE,EAAE;GACnC,MAAM,QAAQ,MAAM,UAAU;GAC9B,MAAM,UAAU,IAAI,YAAY,MAAM;GACtC,MAAM,IAAI,IAAI,IAAI,QAAQ,QAAS,KAAK,gBAAgB,IAAK;GAC7D,MAAM,IAAI,IAAI;GACd,IAAI,SAAS,OAAO,GAAG,EAAE;EAC1B;CACF;CAED,iBAAiB6B,SAAkB;EAEjC,MAAM,MAAM,KAAKrC,cAAc;EAC/B,IAAI,OAAO,KAAKQ,WAAW,OAAO,CAAC,CAAC,CAAC,GAAG,KAAKA,WAAW;EACxD,IAAI,YAAY,KAAKA,WAAW;EAChC,IAAI,eAAe,CAAC,GAAG,CAAC;AACxB,OAAK,MAAM,KAAK,SAAS;GACvB,MAAM,MAAM,KAAK,mBAAmB,GAAG,MAAM;GAC7C,MAAM,QAAQ,KAAK,YAAY,EAAE,EAAE;GACnC,MAAM,QAAQ,MAAM,UAAU;GAC9B,MAAM,UAAU,IAAI,YAAY,MAAM;GACtC,MAAM,IAAI,IAAI,IAAI,QAAQ,QAAQ;GAClC,MAAM,IAAI,IAAI,IAAI,QAAQ,0BAA0B,QAAQ,2BAA4B,KAAK,gBAAgB;GAC7G,IAAI,SAAS,OAAO,GAAG,EAAE;EAC1B;CACF;CAED,aAAa8B,GAAkBC,UAAmB;EAChD,MAAM,oBAAoB,KAAK,gBAAgB;EAC/C,MAAM,IAAI,WAAW;GAAE,GAAG,EAAE;GAAG,GAAG;EAAG,IAAG;GAAE,GAAG,EAAE;GAAG,GAAG;EAAG;EACxD,MAAM,MAAM,KAAK,mBAAmB,GAAG,MAAM;EAE7C,MAAMX,SAAO,WAAW;GACtB,GAAG;IAAE,GAAG,IAAI;IAAG,GAAG,IAAI,IAAI;GAAmB;GAC7C,GAAG;IAAE,GAAG,IAAI;IAAG,GAAG,IAAI,IAAI;GAAmB;EAC9C,IACC;GACE,GAAG;IAAE,GAAG,IAAI;IAAG,GAAG,IAAI,IAAI;GAAmB;GAC7C,GAAG;IAAE,GAAG,IAAI;IAAG,GAAG,IAAI,IAAI;GAAmB;EAC9C;EACH,KAAKK,qBAAqBL,QAAM,KAAKrB,WAAW,QAAQ,KAAKA,WAAW,OAAO,MAAM;CACtF;CAED,cAAc+B,GAAkBC,UAAmB;EACjD,MAAMX,SAAO,WACX,KAAKI,wBAAwB;GAAE,GAAG,EAAE;GAAG,GAAG,OAAO;EAAmB,GAAE;GAAE,GAAG,EAAE;GAAG,GAAG,OAAO;EAAmB,EAAC,GAC9G,KAAKA,wBAAwB;GAAE,GAAG,EAAE;GAAG,GAAG,OAAO;EAAmB,GAAE;GAAE,GAAG,EAAE;GAAG,GAAG,OAAO;EAAmB,GAAE,MAAM;EACvH,KAAKC,qBAAqBL,QAAM,KAAKnB,MAAM,QAAQ,EAAE,QAAQ,KAAKA,MAAM,QAAQ,IAAI,KAAKA,MAAM,MAAM;CACtG;CAED,WAAW;EACT,MAAM,IAAI,KAAKA;EACf,MAAM,WAAW,KAAK,KAAK;EAC3B,MAAM,eAAe,KAAK,KAAK;EAC/B,MAAM,aAAa,KAAK,KAAK;EAC7B,MAAM,KAAK,KAAK,iBAAiB,CAAC;EAClC,MAAM,EAAE,YAAY,OAAO,GAAG;EAG9B,MAAM,4BAAiC,IAAI,YAAY,MAAM;AAC7D,OAAK,MAAM,KAAK,UAAU,GAAG;AAC3B,OAAI,UAAU,KAAK+B,cAAc,GAAG,KAAK;AACzC,OAAI,gBAAgB,EAAE,OAAO,KAAKC,aAAa,GAAG,KAAK;EACxD;AAGD,OAAK,MAAM,KAAK,UAAU,GAAG;AAC3B,OAAI,UAAU,KAAKD,cAAc,GAAG,MAAM;AAC1C,OAAI,gBAAgB,EAAE,OAAO,KAAKC,aAAa,GAAG,MAAM;EACzD;AAED,MAAI,YAAY;GACd,KAAKC,iBAAiB,UAAU,EAAE,OAAO,OAAK,EAAE,MAAM,CAAC;GACvD,KAAKC,iBAAiB,UAAU,EAAE,OAAO,OAAK,EAAE,MAAM,CAAC;EACxD;CACF;CAED,YAAYC,MAAcC,QAA0BC,MAAkB;AACpE,MAAI,KAAKzC,kBAAkB,CAAC,IAAI,CAAC,EAC/B,KAAK0C,eAAe,QAAQ,KAAK,QAAQ,KAAK,UAAU;AAI1D,MAAI,KAAK3C,gBAAgB,CAAC,GAAG,CAAC,CAC5B,MAAK,MAAM,KAAK,QACd,KAAK4C,SAAS,GAAG,KAAK,QAAQ,KAAK,UAAU;CAKlD;CAED,eAAeC,MAAwBnB,QAAgBC,OAAe;EACpE,MAAM,MAAM,KAAK/B,cAAc;EAC/B,IAAI,WAAW;AACf,OAAK,MAAM,CAAE,OAAO,KAAM,IAAI,KAAK,SAAS,EAAE;GAC5C,MAAMkD,QAAM,KAAK,mBAAmB,MAAM,MAAM;AAChD,OAAI,UAAU,GAAG,IAAI,OAAOA,MAAI,GAAGA,MAAI,EAAE;GACzC,IAAI,OAAOA,MAAI,GAAGA,MAAI,EAAE;EACzB;EACD,IAAI,cAAcC,cAAe,OAAO;EACxC,IAAI,YAAY;EAChB,IAAI,QAAQ;EACZ,IAAI,WAAW;CAChB;CAED,SAASC,aAA6BC,gBAAwBC,gBAAwB;EACpF,MAAM,SAASH,cAAe,YAAY,aAAa,eAAe;EACtE,MAAM,MAAM,KAAK,mBAAmB,YAAY;EAChD,MAAM,SAAS,YAAY,UAAU;EACrC,KAAKnD,cAAc,YAAY,CAC7B;GAAE,GAAG;GAAK;EAAQ,CACnB,GAAE,OAAO;CAWX;CAGD,qBAAqB6B,QAAYC,QAAgBC,OAAe,QAAQ,OAAO;AAC7E,MAAI,OAAO,QAAQ,IAAIH,OAAK;EAC5B,MAAM,MAAM,KAAK5B,cAAc;EAE/B,SAASmD,cAAe,OAAO;EAE/B,IAAI,WAAW;EACf,IAAI,OAAOvB,OAAK,EAAE,GAAGA,OAAK,EAAE,EAAE;EAC9B,IAAI,OAAOA,OAAK,EAAE,GAAGA,OAAK,EAAE,EAAE;EAC9B,IAAI,cAAcuB,cAAe,OAAO;EACxC,IAAI,YAAY;EAChB,IAAI,QAAQ;EACZ,IAAI,WAAW;CAChB;CAED,IAAI,UAAU;AACZ,SAAO,KAAKpD;CACb;CAED,IAAI,eAAe;AACjB,SAAO,KAAKC;CACb;CAED,IAAI,eAAe;AACjB,SAAO,KAAKA,cAAc;CAC3B;AACF;;;;;;;;;;;;;;;;;;AE7kBD,IAAI;AACF,KAAI,OAAO,WAAW,CAAC,SAAS,CAAC,EAC9B,OAAe,OAAO;EACrB,GAAI,OAAe;EACnB,SAAS;GACP;GACA;GACA;EACD;CACF;AAEJ,QAAO,CAEP"}