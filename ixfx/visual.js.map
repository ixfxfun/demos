{"version":3,"file":"visual.js","names":["canvasElementContextOrQuery: CanvasContextQuery","ctxOrCanvasEl: CanvasContextQuery","canvasBounds?: Rects.Rect","pathsToDraw: Paths.Path[] | readonly Paths.Path[]","opts?: DrawingOpts","lineToDraw: Lines.Line | Lines.Line[]","rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts?: RectOpts","bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier","pointsToDraw: Points.Point[]","opts?: DrawingOpts & Partial<ConnectedPointsOptions>","dotPosition: Points.Point | Points.Point[]","opts?: DotOpts","circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[]","opts: DrawingOpts","circle","arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[]","lines: string[]","opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }","applyOpts","ctx: CanvasRenderingContext2D","arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[]","arc: Arcs.ArcPositioned","arc","arcsArray: Arcs.ArcPositioned[]","strokeStyle: string | CanvasGradient | CanvasPattern | undefined","fillStyle: string | CanvasGradient | CanvasPattern | undefined","lineWidth: number | undefined","lineJoin: CanvasLineJoin | undefined","lineCap: CanvasLineCap | undefined","stk?: IStackImmutable<StackOp>","points: readonly Points.Point[]","circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[]","c: Circles.CirclePositioned","ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[]","ellipse: Ellipses.EllipsePositioned","ellipse","pathsToDraw: readonly Paths.Path[] | Paths.Path","opts: { readonly strokeStyle?: string; readonly debug?: boolean }","path: Paths.Path","pts: readonly Points.Point[]","opts: Partial<ConnectedPointsOptions>","opts: { readonly fillStyle?: string }","labels?: readonly string[]","point: Points.Point","canvasEl: HTMLCanvasElement","pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned","pos","bezierToDraw: Beziers.CubicBezier","bezierToDraw: Beziers.QuadraticBezier","toDraw: Lines.Line | readonly Lines.Line[]","opts: LineOpts & DrawingOpts","d: Lines.Line","toDraw: Triangles.Triangle | readonly Triangles.Triangle[]","opts: DrawingOpts & { readonly filled?: boolean }","t: Triangles.Triangle","toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts: RectOpts","d: Rects.RectPositioned | Rects.Rect","text?: string | null","widthMultiple?: number","rect","lines: readonly string[]","opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }","line","text: readonly string[] | string","opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }","v: any","a: number","b: number","value: number","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","changeLightness","value: Hsl","amount: Partial<{ pdelta: number, delta: number, fixed: number }>","hsl: Hsl","value: number","property: `l` | `h` | `s`","fromHexString","hexString: string","options: ParsingOptions<Hsl>","fromLibrary","fromCss","value: string","rgbToLibraryHsl","toScalar","toAbsolute","toCssString","hsl: C.HSL","parsingOptions: ParsingOptions<T>","scalar","absolute","hslOrString: Hsl | Rgb | string","guard","generateScalar","absoluteHslOrVariable: string | number | Angle","lightness","hslOrString: Rgb | Hsl | string","interpolator","a: Hsl | string","b: Hsl | string","direction: `longer` | `shorter`","amount: number","hsl: HslScalar","hsl: HslAbsolute","v: string","pos: number","vf","hsl: Hsl | string","guard","lch: OkLch","fromLibrary","lch: C.LCH","parsingOptions: ParsingOptions<OkLch>","scalar","fromHexString","hexString: string","options: ParsingOptions<OkLch>","oklchTransparent: OkLchAbsolute","fromCss","value: string","rgbTo8bit","lch","Colorizr","lchOrString: OkLch | string","toScalar","toCssString","absoluteHslOrVariable: string | number | Angle","lightness","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","interpolator","a: OkLch | string","b: OkLch | string","direction: `longer` | `shorter`","amount: number","lch: OkLchScalar","l: number","c: number","h: number","lch: OkLchAbsolute","colour: string","fromCss","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","hexString: string","scalar","srgbTansparent: Rgb8Bit","value: string","options: ParsingOptions<Rgb>","hslToLibraryRgb","rgb: Rgb","guard","rgb: C.RGB","parsingOptions: ParsingOptions<Rgb>","rgbOrString: Rgb | string","rgbOrString: Rgb | Hsl | string","amount: Partial<{ pdelta: number, delta: number, fixed: number }>","Colorizr","rgb: Rgb8Bit","rgb: RgbScalar","v: string","pos: number","interpolator","colourA: Rgb | string","colourB: Rgb | string","amount: number","rgb: Rgb | string","image: ImageData","fn: Grids.GridCellAccessor<Rgb8Bit>","cell: Grids.GridCell","fn: Grids.GridCellSetter<Rgb>","value: Rgb","col: Rgb8Bit[]","domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>","opts: Partial<CanvasHelperOptions>","#scaler","#scalerSize","#init","#logicalSize","reason?: string","#disposed","#resizer","#ctx","#drawHelper","#getContext","logicalSize: Rect","#handleEvents","resizerOptions: ElementSizerOptions<HTMLCanvasElement>","event: PointerEvent","colour?: string","#viewport","grid","elem: SVGElement","opts: DrawingOpts","parent: SVGElement","type: string","queryOrExisting?: string | V","suffix?: string","existing:SVGElement|HTMLElement|null","index: number","lightness","rand: RandomSource","multiplyOpacity","colourish: string","amount: number","colourish: Colourish","fn: (scalarOpacity: number) => number","result: Colour | undefined","colours: Colourish[]","destination: ColourSpaces","c","colourA: Colourish","colourB: Colourish","options: Partial<ColourInterpolationOpts>","inter: ColourInterpolator<Colour> | undefined","convert","amount: number","opts: Partial<ColourStepOpts>","piece: Colour[]","pieceSteps: Colour[]","a: Colourish | string","b: Colourish","options: CreateStepsOptions","results: Colour[]","convert","colour: Colourish","destination: ConvertDestinations","destination: ColourSpaces","colour: Colourish | object","Colorizr","guard","colour: Colour","colourish: any","c: Colour | undefined","rgb: Rgb","scalarResult: boolean","elem: SVGElement","opts: StrokeOpts","elem: SVGCircleElement","circle: CirclePositioned","opts?: CircleDrawingOpts","circle","parent: SVGElement","queryOrExisting?: string | SVGCircleElement","elOrQuery: HTMLElement | string","options: Opts","event: PointerEvent","el","fallbacks?: ReadonlyArray<string>","#store","#aliases","#elementBase","el: Element","key: string","colour: string","from: string","to: string","fallback?: string","fromCss","#lastFallback","sourceVideoEl: HTMLVideoElement","opts: FramesOpts","c: CanvasRenderingContext2D | null","opts: CaptureOpts","worker: Worker | undefined","pixels: ImageData | undefined","opts: ManualCaptureOpts","capture","c: CanvasRenderingContext2D | undefined | null","c","c: ManualCapturer"],"sources":["../packages/visual/src/drawing.ts","../packages/visual/src/colour/guards.ts","../packages/visual/src/colour/utility.ts","../packages/visual/src/colour/hsl.ts","../packages/visual/src/colour/oklch.ts","../packages/visual/src/colour/css-colours.ts","../packages/visual/src/colour/srgb.ts","../packages/visual/src/image-data-grid.ts","../packages/visual/src/canvas-helper.ts","../packages/visual/src/svg/apply.ts","../packages/visual/src/svg/create.ts","../packages/visual/src/colour/generate.ts","../packages/visual/src/colour/math.ts","../packages/visual/src/colour/interpolate.ts","../packages/visual/src/colour/index.ts","../packages/visual/src/colour/conversion.ts","../packages/visual/src/svg/stroke.ts","../packages/visual/src/svg/elements.ts","../packages/visual/src/pointer-visualise.ts","../packages/visual/src/named-colour-palette.ts","../packages/visual/src/video.ts","../packages/visual/src/index.ts"],"sourcesContent":["import { arrayTest, resultThrow } from '@ixfx/guards';\nimport { Colour } from '@ixfx/visual';\nimport { resolveEl } from '@ixfx/dom';\n//import type { IStackImmutable } from '@ixfx/collections';\nimport { StackImmutable, type IStackImmutable } from '@ixfx/collections/stack';\nimport { Beziers, Lines, Points, Rects, Triangles, type Arcs, type Circles, type Ellipses, type Paths } from '@ixfx/geometry';\nimport { quantiseEvery } from '@ixfx/numbers';\n\n// import type { Point } from '../geometry/point/PointType.js';\n// import type { Line } from '../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../geometry/circle/CircleType.js';\n// import type { Rect, RectPositioned } from '../geometry/rect/index.js';\n// import type { Path } from '../geometry/path/PathType.js';\n// import type { Triangle } from '../geometry/triangle/TriangleType.js';\n\n// import { Empty as RectsEmpty } from '../geometry/rect/Empty.js';\n// import { corners as RectsCorners } from '../geometry/rect/Corners.js';\n// import { isLine } from '../geometry/line/Guard.js';\n// import { quantiseEvery } from '../numbers/Quantise.js';\n\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElementContextOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\nexport type DrawingHelper = ReturnType<typeof makeHelper>\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rects.Rect\n) => {\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    ctx,\n    paths(pathsToDraw: Paths.Path[] | readonly Paths.Path[], opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Lines.Line | Lines.Line[], opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n      opts?: RectOpts\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Points.Point[],\n      opts?: DrawingOpts & Partial<ConnectedPointsOptions>\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Points.Point[], opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Points.Point | Points.Point[],\n      opts?: DotOpts\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[],\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[],\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: string[],\n      opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: readonly StackOp[]\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray: Arcs.ArcPositioned[] = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: readonly StackOp[]): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  stk ??= new StackImmutable<StackOp>();\n\n  const push = (...ops: StackOp[]): DrawingStack => {\n    stk ??= new StackImmutable<StackOp>();\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: readonly Points.Point[],\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: Circles.CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c as Circles.CirclePositioned);\n  } else {\n    draw(circlesToDraw as Circles.CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: readonly Paths.Path[] | Paths.Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Paths.Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (Lines.isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Paths.Path);\n  }\n};\n\nexport type ConnectedPointsOptions = {\n  readonly lineWidth: number\n  readonly loop: boolean\n  readonly fillStyle: string\n  readonly strokeStyle: string\n}\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: Partial<ConnectedPointsOptions> = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n  resultThrow(arrayTest(pts, `pts`));\n\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: { readonly fillStyle?: string } = {},\n  labels?: readonly string[]\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Points.Point\n): Points.Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\nexport type DotOpts = DrawingOpts & {\n  readonly radius?: number;\n  readonly stroke?: boolean;\n  readonly filled?: boolean;\n  readonly strokeWidth?: number;\n}\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned,\n  opts?: DotOpts\n) => {\n  opts ??= {};\n  const radius = opts.radius ?? 10;\n  const positions = Array.isArray(pos) ? pos : [ pos ];\n  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== undefined;\n  let filled = opts.filled ? opts.filled : opts.fillStyle !== undefined;\n  if (!stroke && !filled) filled = true;\n\n  applyOpts(ctx, opts);\n\n  for (const pos of positions) {\n    ctx.beginPath();\n    if (`radius` in pos) {\n      ctx.arc(pos.x, pos.y, pos.radius, 0, 2 * Math.PI);\n    } else {\n      ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\n    }\n    if (filled) {\n      ctx.fill();\n    }\n    if (stroke) {\n      ctx.stroke();\n    }\n  }\n\n  // const makePath = () => {\n  //   ctx.beginPath();\n\n  //   // x&y for arc is the center of circle\n  //   if (Array.isArray(pos)) {\n  //     for (const p of pos) {\n  //       ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //     }\n  //   } else {\n  //     const p = pos as Point;\n  //     ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //   }\n  // }\n  // makePath();\n  // if (opts.filled || !opts.stroke) {\n  //   ctx.fill();\n  // }\n  // if (opts.stroke) {\n  //   if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n  //   //makePath();\n  //   ctx.stroke();\n  // }\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Lines.Line | readonly Lines.Line[],\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Lines.Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t as Lines.Line);\n  } else {\n    draw(toDraw as Lines.Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangles.Triangle | readonly Triangles.Triangle[],\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangles.Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangles.Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n\nexport type RectOpts = DrawingOpts & Readonly<Partial<{\n  stroke: boolean\n  filled: boolean\n  strokeWidth: number\n  /**\n   * If true, diagonals are drawn\n   */\n  crossed: boolean\n}>>\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n  opts: RectOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroke = opts.stroke ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: Rects.RectPositioned | Rects.Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroke) {\n      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n      //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n      ctx.strokeRect(x, y, d.width, d.height);\n    }\n    if (opts.crossed) {\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(d.width, d.height);\n      ctx.stroke();\n      ctx.moveTo(0, d.height);\n      ctx.lineTo(d.width, 0);\n      ctx.stroke();\n    }\n    if (opts.debug) {\n      pointLabels(ctx, Rects.corners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Rects.RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rects.Rect => {\n  if (text === undefined || text === null || text.length === 0) return Rects.Empty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? quantiseEvery(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: readonly string[],\n  opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n  const align = opts.align ?? `top`;\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  if (align === `top`) {\n    ctx.textBaseline = `top`;\n  } else {\n    ctx.textBaseline = `middle`;\n  }\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: readonly string[] | string,\n  opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import type { Hsl, Rgb, OkLch, Colourish } from \"./types.js\";\n\nexport const isHsl = (v: any): v is Hsl => {\n  if (typeof v === `object`) {\n    if (!(`h` in v && `s` in v && `l` in v)) return false;\n    if (!(`unit` in v)) return false;\n    if (`space` in v) {\n      if (v.space !== `hsl`) return false;\n    }\n  }\n  return false;\n}\n\nexport const isRgb = (v: any): v is Rgb => {\n  if (typeof v === `object`) {\n    if (!(`r` in v && `g` in v && `b` in v)) return false;\n    if (!(`unit` in v)) return false;\n    if (`space` in v) {\n      if (v.space !== `srgb`) return false;\n    }\n  }\n  return false;\n}\n\n\n/**\n * If the input object has r,g&b properties, it will return a fully-\n * formed Rgb type with `unit` and `space` properties.\n * \n * If it lacks these basic three properties or they are out of range,\n *  _undefined_ is returned.\n * \n * If RGB values are less than 1 assumes unit:scalar. Otherwise unit:8bit.\n * If RGB values exceed 255, _undefined_ returned.\n * @param v \n * @returns \n */\nexport const tryParseObjectToRgb = (v: any): Rgb | undefined => {\n  if (!(`r` in v && `g` in v && `b` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.r > 255 && v.g <= 255 && v.b <= 255) {\n      return; // out of range\n    } else {\n      v.unit = `8bit`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `srgb`;\n  }\n  return v as Rgb;\n}\n\nexport const tryParseObjectToHsl = (v: any): Hsl | undefined => {\n  if (!(`h` in v && `s` in v && `l` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.s > 100 && v.l <= 100) {\n      return; // out of range\n    } else {\n      v.unit = `absolute`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `hsl`;\n  }\n  return v as Hsl;\n}\n\nexport const isLch = (v: any): v is OkLch => {\n  if (typeof v === `object`) {\n    if (!(`l` in v && `c` in v && `h` in v)) return false;\n    if (!(`unit` in v)) return false;\n    if (`space` in v) {\n      if (v.space === `lch`) return true;\n      if (v.space == `oklch`) return true;\n    }\n  }\n  return false;\n}\n\nexport const isColourish = (v: any): v is Colourish => {\n  if (typeof v === `string`) return true;\n  if (typeof v !== `object`) return false;\n  if (isHsl(v)) return true;\n  if (isLch(v)) return true;\n  if (isRgb(v)) return true;\n  return false;\n}","export function calculateHueDistance(a: number, b: number, limit = 1) {\n  let long = -1;\n  let short = -1;\n  if (b < a) {\n    long = (b - a);\n    short = limit - (a - b);\n  } else {\n    long = (b - a);\n    short = (long) - limit;\n  }\n  const forward = short > 0 ? short : long;\n  const backward = short > 0 ? long : short;\n  if (Math.abs(long) < Math.abs(short)) {\n    const t = short;\n    short = long;\n    long = t;\n  }\n  return { long, short, forward, backward };\n}\n\nexport function wrapScalarHue(value: number) {\n  value = value % 1;\n  if (value < 0) return (1 - Math.abs(value)) % 1;\n  return value;\n}\n\n// export function cssAngleFormat(value:string) {\n//   let start = value.indexOf(`)`);\n//   let end = value.lastIndexOf(')');\n//   if (start < 0) return value;\n//   if (end < start) return value;\n\n// }","import Colorizr, * as C from \"colorizr\";\nimport type { Colourish, Hsl, HslAbsolute, HslScalar, ParsingOptions, Rgb } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest, percentTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { isRgb } from \"./guards.js\";\nimport { calculateHueDistance, wrapScalarHue } from \"./utility.js\";\nimport { parseCssRgbFunction, to8bit as rgbTo8bit, toLibraryHsl as rgbToLibraryHsl } from \"./srgb.js\";\n\n/**\n * Scales the opacity value of an input HSL value\n * ```js\n * withOpacity()\n * ```\n * @param value \n * @param fn \n * @returns \n */\nexport const withOpacity = <T extends Hsl>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\n/**\n * Increases or decreases lightness by this percentage, returning new colour\n * \n * Amount to change:\n * * 'fixed': a fixed amount\n * * 'delta': increase/decrease by this amount\n * * 'pdelta': proportion of current value to change by ('percentage delta')\n * \n * ```\n * const colour = { h: 0.5, s: 0.5, l: 0.5, space: `hsl`, unit: `scalar` };\n * changeLightness(colour, { pdelta: 0.1 }); // l: 0.55\n * changeLightness(colour, { delta: 0.1 });  // l: 0.6\n * changeLightness(colour, { fixed: 0.5 });  // l: 0.5\n * ```\n * \n * Keep in mind the numerical value will depend on the unit of `value`. If it's scalar,\n * lightness is 0..1 scale, otherwise 0..100 scale.\n * \n * Use negative values to decrease (does not apply to 'fixed')\n * @param value \n * @param amount \n */\nexport const changeLightness = (value: Hsl, amount: Partial<{ pdelta: number, delta: number, fixed: number }>): Hsl => {\n  let newL = 0;\n  if (typeof amount.pdelta !== `undefined`) {\n    newL = value.l + (value.l * amount.pdelta);\n  } else if (typeof amount.delta !== `undefined`) {\n    newL = amount.delta + value.l;\n  } else if (typeof amount.fixed !== `undefined`) {\n    if (amount.fixed < 0) throw new TypeError(`Cannot use negative value with 'fixed'`);\n    newL = amount.fixed;\n  } else {\n    throw new TypeError(`Parameter 'amount' is missing 'delta/pdelta/fixed' properties`);\n  }\n  return {\n    ...value,\n    l: scaleProperty(value, newL, `l`)\n  }\n}\n\nconst scaleProperty = (hsl: Hsl, value: number, property: `l` | `h` | `s`) => {\n  if (hsl.unit === `scalar`) {\n    // 0..1 scale\n    if (value > 1) value = 1;\n    else if (value < 0) value = 0;\n  } else {\n    // 0..100 scale\n    if (value > 100) value = 100;\n    else if (value < 0) value = 0;\n  }\n  return value;\n}\n\nconst hslTransparent = Object.freeze({\n  h: 0, s: 0, l: 0, opacity: 0, unit: `absolute`, space: `hsl`\n});\n\nexport function fromHexString<T extends ParsingOptions<Hsl>>(hexString: string, scalar: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\n\nexport function fromHexString(hexString: string, options: ParsingOptions<Hsl> = {}): Hsl {\n  return fromLibrary(C.hex2hsl(hexString), options);\n}\n\nexport function fromCss<T extends ParsingOptions<Hsl>>(value: string, options: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\nexport function fromCss(value: string, options: ParsingOptions<Hsl> = {}): Hsl {\n  value = value.toLowerCase();\n  if (value.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);\n  if (value.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);\n\n  if (value.startsWith(`#`)) {\n    return fromHexString(value, options);\n\n  }\n  if (value === `transparent`) return hslTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string, options);\n  }\n\n  if (value.startsWith(`rgb(`)) {\n    const hsl = rgbToLibraryHsl(value);\n    return fromLibrary(hsl, options);\n  }\n\n  if (!value.startsWith(`hsl(`)) {\n    try {\n      value = C.convert(value, `hsl`);\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  try {\n    // Hand-rolled hsl() parse because the package is broken\n    const hsl = parseCssHslFunction(value);\n    if (options.scalar) return toScalar(hsl);\n    return toAbsolute(hsl);\n  } catch (error) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw error;\n  }\n\n}\n\nexport const toCssString = (hsl: Hsl): string => {\n  const abs = toAbsolute(hsl);\n  let css = `hsl(${ abs.h }deg ${ abs.s }% ${ abs.l }%`;\n  if (`opacity` in abs && abs.opacity !== undefined && abs.opacity < 100) {\n    css += ` / ${ abs.opacity }%`;\n  }\n  css += ')';\n  return css;\n}\n\nconst toLibrary = (hsl: Hsl): C.HSL => {\n  const abs = toAbsolute(hsl);\n  return {\n    h: abs.h,\n    s: abs.s,\n    l: abs.l,\n    alpha: abs.opacity,\n  }\n}\nfunction fromLibrary<T extends ParsingOptions<Hsl>>(hsl: C.HSL, parsingOptions: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\n\nfunction fromLibrary<T extends Hsl>(hsl: C.HSL, parsingOptions: ParsingOptions<T> = {}): T {\n  if (typeof hsl === `undefined` || hsl === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n  const scalarOpt = parsingOptions.scalar ?? true;\n\n  // Library result is absolute\n  resultThrow(\n    numberInclusiveRangeTest(hsl.h, 0, 360, `h`),\n    numberInclusiveRangeTest(hsl.s, 0, 100, `s`),\n    numberInclusiveRangeTest(hsl.l, 0, 100, `l`),\n    percentTest((hsl.alpha ?? 1), `alpha`)\n    // () => hsl.alpha !== undefined ? numberInclusiveRangeTest(hsl.alpha, 0, 100, `alpha`) : { success: true, value: hsl },\n  );\n  if (scalarOpt) {\n    return scalar(hsl.h / 360, hsl.s / 100, hsl.l / 100, (hsl.alpha ?? 1)) as T;\n  } else {\n    return absolute(hsl.h, hsl.s, hsl.l, (hsl.alpha ?? 1) * 100) as T;\n  }\n}\n\nexport const toAbsolute = (hslOrString: Hsl | Rgb | string): HslAbsolute => {\n  // if (typeof hslOrString === `string`) {\n  //   return toAbsolute(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: false }));\n  // }\n  if (typeof hslOrString === `string`) {\n    return fromCss(hslOrString, { scalar: false });\n    // try {\n    //   return toScalar(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: true }));\n    // } catch (error) {\n    //   console.error(`Hsl.toScalar: ${ hslOrString }`);\n    //   throw error;\n    // }\n  }\n  if (isRgb(hslOrString)) {\n    return toAbsolute(fromLibrary(rgbToLibraryHsl(hslOrString), { scalar: false }));\n  }\n  const hsl = hslOrString;\n  guard(hsl);\n  if (hsl.unit === `absolute`) return hsl;\n  return {\n    h: hsl.h * 360,\n    s: hsl.s * 100,\n    l: hsl.l * 100,\n    opacity: (hsl.opacity ?? 1) * 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\n/**\n * Generates a {@link HslScalar} value.\n * \n * ```js\n * generateScaler(10); // 10deg, default to full saturation, half lightness and full opacity\n * \n * // Generate HSL value from radian angle and 50% saturation\n * generateScalar(`10rad`, 0.5); \n * \n * // Generate from numeric CSS variable\n * generateScalar(`--hue`);\n * ```\n * @param absoluteHslOrVariable Hue angle or CSS variable\n * @param saturation \n * @param lightness \n * @param opacity \n */\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, saturation = 1, lightness = 0.5, opacity = 1): HslScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  const hue = angleParse(absoluteHslOrVariable);\n  if (saturation > 1) throw new TypeError(`Param 'saturation' must be between 0..1`);\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  return {\n    h: hueDeg,\n    s: saturation,\n    l: lightness,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\n/**\n * Converts a {@link Hsl} value to scalar units, or parses a colour string\n * and converts it.\n * \n * ```js\n * toScalar({ h: 100, s: 50, l: 100, unit: `absolute` });\n * toScalar(`red`);\n * ```\n * @param hslOrString \n * @returns \n */\nexport const toScalar = (hslOrString: Rgb | Hsl | string): HslScalar => {\n  if (typeof hslOrString === `string`) {\n    return fromCss(hslOrString, { scalar: true });\n    // try {\n    //   return toScalar(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: true }));\n    // } catch (error) {\n    //   console.error(`Hsl.toScalar: ${ hslOrString }`);\n    //   throw error;\n    // }\n  }\n  if (isRgb(hslOrString)) {\n    return toScalar(fromLibrary(rgbToLibraryHsl(hslOrString), { scalar: true }));\n  }\n\n  const hsl = hslOrString;\n  guard(hsl);\n  if (hsl.unit === `scalar`) return hsl;\n  return {\n    h: hsl.h / 360,\n    s: hsl.s / 100,\n    l: hsl.l / 100,\n    opacity: (hsl.opacity ?? 1) / 100,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\nexport const guard = (hsl: Hsl) => {\n  const { h, s, l, opacity, space, unit } = hsl;\n  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${ space }`);\n  if (unit === `absolute`) {\n    resultThrow(\n      numberTest(h, `finite`, `h`),\n      numberInclusiveRangeTest(s, 0, 100, `s`),\n      numberInclusiveRangeTest(l, 0, 100, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 100, `opacity`);\n        }\n      });\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(h, `percentage`, `h`),\n      numberTest(s, `percentage`, `s`),\n      numberTest(l, `percentage`, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport const interpolator = (a: Hsl | string, b: Hsl | string, direction: `longer` | `shorter` = `shorter`) => {\n  a = toScalar(a);\n  b = toScalar(b);\n  const aOpacity = a.opacity ?? 1;\n  const distanceCalc = calculateHueDistance(a.h, b.h, 1);\n  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;\n  const satDistance = b.s - a.s;\n  const lightDistance = b.l - a.l;\n  const opacityDistance = (b.opacity ?? 1) - aOpacity;\n\n  return (amount: number): HslScalar => {\n    amount = clamp(amount);\n    let h = interpolate(amount, 0, Math.abs(hueDistance));\n    if (hueDistance < 0) h = a.h - h;\n    else h = a.h + h;\n\n    const s = interpolate(amount, 0, satDistance);\n    const l = interpolate(amount, 0, lightDistance);\n    const o = interpolate(amount, 0, opacityDistance);\n    return scalar(wrapScalarHue(h), s + a.s, l + a.l, o + aOpacity);\n  }\n}\n\n/**\n * Creates a HslScalar value from scalar (0..1) values\n * @param hue \n * @param sat \n * @param lightness \n * @param opacity \n * @returns \n */\nexport function scalar(hue = 0.5, sat = 1, lightness = 0.5, opacity = 1): HslScalar {\n  const hsl: HslScalar = {\n    unit: `scalar`,\n    space: `hsl`,\n    h: hue,\n    s: sat,\n    l: lightness,\n    opacity: opacity\n  }\n  guard(hsl);\n  return hsl;\n}\n\nexport function absolute(hue = 200, sat = 100, lightness = 50, opacity = 100): HslAbsolute {\n  const hsl: HslAbsolute = {\n    unit: `absolute`,\n    space: `hsl`,\n    h: hue,\n    s: sat,\n    l: lightness,\n    opacity: opacity\n  }\n  guard(hsl);\n  return hsl;\n}\n\n/**\n * It seems Colorizr can't handle 'deg' units\n * @param value \n */\nexport function parseCssHslFunction(value: string): Hsl {\n  if (value.startsWith(`hsla`)) throw new Error(`hsla() is not supported`);\n  if (!value.startsWith(`hsl(`)) throw new Error(`Expected hsl(..) CSS colour`);\n\n  const start = value.indexOf('(');\n  const end = value.indexOf(')');\n  if (end < start) throw new Error(`Is hsl() not terminated? Missing ')'`);\n\n  const part = value.substring(start + 1, end);\n  let split = part.split(/[\\s,]+/);\n  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${ split.length } length`);\n\n  let returnRelative = false;\n  if (split[ 0 ].endsWith(`%`)) returnRelative = true;\n  if (split[ 1 ].endsWith(`%`) && split[ 2 ].endsWith(`%`)) returnRelative = true;\n\n  const valueAsScalar = (v: string, pos: number) => {\n    if (v === `none`) return 0;\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100;\n    }\n    if (v.endsWith(`deg`) && pos === 0) {\n      v = v.substring(0, v.length - 3);\n    }\n\n    const vf = Number.parseFloat(v);\n    if (pos === 0) return vf / 360;\n    if (pos === 3) return vf; // opacity\n    return vf / 100;\n  }\n\n  const valueAsAbs = (v: string, pos: number) => {\n    if (v === `none`) return 0;\n    if (v.endsWith(`%`)) {\n      const vf = Number.parseFloat(v.substring(0, v.length - 1));\n      if (pos === 0) return vf * 360;\n      return vf;\n    }\n    if (v.endsWith(`deg`) && pos === 0) {\n      return Number.parseFloat(v.substring(0, v.length - 3));\n    }\n    const vf = Number.parseFloat(v);\n    return vf;\n  }\n\n  // Is there opacity?\n  if (split.length > 3) {\n    if (split[ 3 ] === '/') {\n      // Remove / part\n      split = [ split[ 0 ], split[ 1 ], split[ 2 ], split[ 4 ] ];\n    }\n  }\n  if (returnRelative) {\n    return scalar(\n      valueAsScalar(split[ 0 ], 0),\n      valueAsScalar(split[ 1 ], 1),\n      valueAsScalar(split[ 2 ], 2),\n      valueAsScalar(split[ 3 ] ?? `100%`, 3)\n    )\n  } else {\n    // Return as absolute\n    return absolute(\n      valueAsAbs(split[ 0 ], 0),\n      valueAsAbs(split[ 1 ], 1),\n      valueAsAbs(split[ 2 ], 2),\n      valueAsAbs(split[ 3 ] ?? `100%`, 3)\n    )\n  }\n}\n\n/**\n * Converts a Hsl structure (or CSS string) to Colorizr's RGB format\n * @param rgb \n * @returns \n */\nexport function toLibraryRgb(hsl: Hsl | string): C.RGB {\n  if (typeof hsl === `string`) {\n    const parseResult = fromCss(hsl, { scalar: false });\n    //console.log(`parseResult hsl: ${ hsl } pr: `, parseResult);\n    return toLibraryRgb(parseResult);\n  }\n  hsl = toAbsolute(hsl);\n  //console.log(`toLibraryRgb hsl`, hsl);\n  const rgb = C.hsl2rgb({ h: hsl.h, s: hsl.s, l: hsl.l });\n  return { ...rgb, alpha: (hsl.opacity ?? 100) / 100 * 255 };\n}","import type { OkLch, OkLchAbsolute, OkLchScalar, ParsingOptions } from \"./types.js\";\nimport { numberInclusiveRangeTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport Colorizr, * as C from \"colorizr\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\nimport { calculateHueDistance, wrapScalarHue } from \"./utility.js\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { parseCssRgbFunction, to8bit as rgbTo8bit } from \"./srgb.js\";\n\nexport const OKLCH_CHROMA_MAX = 0.4;\n\nexport const guard = (lch: OkLch) => {\n  const { l, c, h, opacity, space, unit } = lch;\n  if (space !== `oklch`) throw new Error(`Space is expected to be 'oklch'. Got: ${ space }`);\n\n  if (unit === `absolute`) {\n    resultThrow(\n      percentTest(l, `l`),\n      () => {\n        if (typeof c === `number`) {\n          return numberInclusiveRangeTest(c, 0, OKLCH_CHROMA_MAX, `c`);\n        }\n      },\n      () => {\n        if (typeof h === `number`) {\n          return numberInclusiveRangeTest(c, 0, 360, `h`);\n        }\n      },\n      percentTest((opacity ?? 1), `opacity`)\n    );\n  } else if (unit === `scalar`) {\n    // Percentage values for L,C,H\n    resultThrow(\n      percentTest(l, `l`),\n      percentTest(c, `c`),\n      percentTest(h, `h`),\n      percentTest((lch.opacity ?? 1), `opacity`)\n    );\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport function fromLibrary<T extends ParsingOptions<OkLch>>(lch: C.LCH, options: T): T extends { scalar: true } ? OkLchScalar : OkLchAbsolute;\n\n/**\n * Coverts from the Colorizr library\n * Tests ranges:\n * * l: 0..1\n * * c: 0..1\n * * h: 0..360\n * * alpha: 0..1\n * \n * Default option: { scalar: true }\n * @param lch \n * @param parsingOptions \n * @returns \n */\nexport function fromLibrary(lch: C.LCH, parsingOptions: ParsingOptions<OkLch> = {}): OkLch {\n  if (typeof lch === `undefined` || lch === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n\n  const scalarReturn = parsingOptions.scalar ?? true;\n\n  // Validate\n  resultThrow(\n    percentTest(lch.l, `l`),\n    percentTest(lch.c, `c`),\n    numberInclusiveRangeTest(lch.h, 0, 360, `h`),\n    percentTest((lch.alpha ?? 1), `alpha`)\n  );\n\n  if (scalarReturn) {\n    return scalar(lch.l, lch.c / OKLCH_CHROMA_MAX, lch.h / 360, (lch.alpha ?? 1));\n  } else {\n    return absolute(lch.l, lch.c, lch.h, (lch.alpha ?? 1));\n  }\n\n}\n\nexport const fromHexString = (hexString: string, options: ParsingOptions<OkLch> = {}): OkLch => {\n  return fromLibrary(C.hex2oklch(hexString), options);\n}\n\nconst oklchTransparent: OkLchAbsolute = Object.freeze({\n  l: 0, c: 0, h: 0, opacity: 0, unit: `absolute`, space: `oklch`\n});\n\nexport function fromCss<T extends ParsingOptions<OkLch>>(value: string, options: T): T extends { scalar: true } ? OkLchScalar : OkLchAbsolute;\nexport function fromCss(value: string, options: ParsingOptions<OkLch> = {}): OkLch {\n  value = value.toLowerCase();\n  if (value.startsWith(`#`)) {\n    return fromHexString(value, options);\n  }\n  if (value === `transparent`) return oklchTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string, options);\n  }\n\n  if (value.startsWith(`rgb(`)) {\n    const rgb = rgbTo8bit(parseCssRgbFunction(value));\n    const lch = C.rgb2oklch({ r: rgb.r, g: rgb.g, b: rgb.b });\n    return fromLibrary(lch, options);\n  }\n\n  if (!value.startsWith(`hsl(`) && !value.startsWith(`oklch(`)) {\n    try {\n      const converted = C.convert(value, `oklch`);\n      value = converted;\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n  const cc = new Colorizr(value);\n  const lch = cc.oklch;\n  return fromLibrary(lch, options);\n  // const c = C.extractColorParts(value);\n  // if (c.model !== `oklch`) {\n  //   if (options.fallbackColour) return options.fallbackColour;\n  //   throw new Error(`Expecting OKLCH colour space. Got: ${ c.model }`);\n  // }\n  // return fromLibrary(c as any as C.LCH, options);\n}\n\n//export const fromCssScalar = (value: string, options: ParsingOptions<OkLchAbsolute> = {}): OkLchScalar => toScalar(fromCssAbsolute(value, options));\n\n/**\n * Returns a string or {@link OkLch} value to absolute form.\n * \n * This means ranges are:\n * * lightness: 0..1\n * * chroma: 0...CHROMA_MAX (0.4)\n * * hue: 0..360\n * @param lchOrString \n * @returns \n */\nexport const toAbsolute = (lchOrString: OkLch | string): OkLchAbsolute => {\n  if (typeof lchOrString === `string`) {\n    return toAbsolute(fromCss(lchOrString, { scalar: true }));\n  }\n  guard(lchOrString);\n  if (lchOrString.unit === `absolute`) return lchOrString;\n  return {\n    space: `oklch`,\n    unit: `absolute`,\n    l: lchOrString.l,\n    c: lchOrString.c * OKLCH_CHROMA_MAX,\n    h: lchOrString.h * 360,\n    opacity: lchOrString.opacity\n  }\n}\n\n\nexport const toScalar = (lchOrString: OkLch | string): OkLchScalar => {\n  if (typeof lchOrString === `string`) {\n    return toScalar(fromCss(lchOrString, { scalar: true }));\n  }\n  const lch = lchOrString;\n  guard(lch);\n\n  //console.log(`toScalar input: ${ JSON.stringify(lchOrString) } lch: `, lch);\n  // Already relative\n  if (lch.unit === `scalar`) return lch;\n\n  // Absolute values\n  return {\n    l: lch.l, // unchanged\n    c: lch.c / OKLCH_CHROMA_MAX,\n    h: lch.h / 360,\n    opacity: (lch.opacity ?? 1),\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\nconst toLibrary = (lch: OkLch): C.LCH => {\n  const abs = toAbsolute(lch);\n  return {\n    l: abs.l,\n    c: abs.c,\n    h: abs.h,\n    alpha: abs.opacity,\n  }\n}\n// const libraryLchToScalar = (c: C.LCH): OkLchScalar => {\n//   return {\n//     l: c.h,\n//     c: c.c,\n//     h: c.h / 360,\n//     opacity: c.alpha ?? 1,\n//     unit: `scalar`,\n//     space: `oklch`\n//   }\n// }\n\n\n/**\n * Returns the colour as a CSS colour string: `oklch(l c h / opacity)`.\n *\n * @param lch Colour\n * @param precision Set precision of numbers, defaults to 3 \n * @returns CSS colour string\n */\nexport const toCssString = (lch: OkLch, precision = 3): string => {\n  guard(lch);\n  const { l, c, h, opacity } = lch;\n  let css = ``;\n  switch (lch.unit) {\n    case `absolute`:\n      css = `oklch(${ (l * 100).toFixed(precision) }% ${ c.toFixed(precision) } ${ h.toFixed(precision) }`\n      break;\n    case `scalar`:\n      css = `oklch(${ l.toFixed(precision) } ${ (c * OKLCH_CHROMA_MAX).toFixed(precision) } ${ (h * 360).toFixed(precision) }`\n      break;\n  }\n  if (typeof opacity !== `undefined` && opacity !== 1) {\n    css += ` / ${ opacity.toFixed(precision) }`;\n  }\n  css += `)`;\n  return css;\n}\n\n// export const oklchFromCss = (css: string): OkLchScalar => {\n//   if (css.startsWith(`#`)) {\n//     libraryLchToScalar(C.hex2oklch(css));\n//   }\n//   const p = C.extractColorParts(css);\n//   return libraryToScalar(p);\n// }\n\n// const libraryToScalar = (colour: unknown): OkLchScalar => {\n//   if (C.isLCH(colour)) {\n//     return libraryLchToScalar(colour);\n//   }\n//   if (C.isRGB(colour)) {\n//     return libraryToScalar(C.rgb2oklch(colour));\n//   }\n//   if (C.isLAB(colour)) {\n//     return libraryToScalar(C.oklab2oklch(colour));\n//   }\n//   if (C.isHSL(colour)) {\n//     return libraryToScalar(C.hsl2oklch(colour));\n//   }\n//   if (C.isHex(colour)) {\n//     return libraryLchToScalar(C.hex2oklch(colour));\n//   }\n//   throw new Error(`Unexpected colour format`);\n// }\n\n// export const oklchToColorJs = (lch: OkLch): ColorConstructor => {\n//   throwNumberTest(lch.l, `percentage`, `lch.l`);\n//   throwNumberTest(lch.c, `percentage`, `lch.c`);\n//   throwNumberTest(lch.h, `percentage`, `lch.h`);\n//   throwNumberTest(lch.opacity, `percentage`, `lch.opacity`);\n//   return {\n//     alpha: lch.opacity,\n//     coords: [ lch.l, lch.c * 0.4, lch.h * 360 ],\n//     spaceId: `oklch`\n//   }\n// }\n\n// const oklchToColorJs = (oklch: OkLch) => {\n//   throwNumberTest(oklch.l, `percentage`, `oklch.l`);\n//   throwNumberTest(oklch.c, `percentage`, `oklch.c`);\n//   throwNumberTest(oklch.h, `percentage`, `oklch.h`);\n//   throwNumberTest(oklch.opacity, `percentage`, `oklch.opacity`);\n//   const coords: [ number, number, number ] = [\n//     oklch.l,\n//     oklch.c * 0.4,\n//     oklch.h * 360\n//   ]\n//   return new ColorJs.default(`oklch`, coords, oklch.opacity);\n// }\n\n// export const isOklch = (p: Colourish | undefined | null): p is OkLch => {\n//   if (typeof p === `undefined` || p === null) return false;\n//   if (typeof p !== `object`) return false;\n\n//   // Check if Colourjs\n//   //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n//   //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n//   if (p.space !== `oklch`) return false;\n//   if (typeof p.l === `undefined`) return false;\n//   if (typeof p.c === `undefined`) return false;\n//   if (typeof p.h === `undefined`) return false;\n//   return true;\n// }\n\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, chroma = 1, lightness = 0.5, opacity = 1): OkLchScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (chroma > 1) throw new TypeError(`Param 'chroma' must be between 0..1`);\n  const hue = angleParse(absoluteHslOrVariable);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n\n  return {\n    l: lightness,\n    c: chroma,\n    h: hueDeg,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\n/**\n * Scales the opacity value of an input Oklch value\n * ```js\n * withOpacity()\n * ```\n * @param value \n * @param fn \n * @returns \n */\nexport const withOpacity = <T extends OkLch>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport const interpolator = (a: OkLch | string, b: OkLch | string, direction: `longer` | `shorter` = `shorter`) => {\n  a = toScalar(a);\n  b = toScalar(b);\n  //console.log(`a`, a);\n  //console.log(`b`, b);\n\n  const aOpacity = a.opacity ?? 1;\n  const distanceCalc = calculateHueDistance(a.h, b.h, 1);\n  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;\n  const chromaDistance = b.c - a.c;\n  const lightDistance = b.l - a.l;\n  const opacityDistance = (b.opacity ?? 1) - aOpacity;\n  //console.log(`distanceCalc`, distanceCalc);\n  //console.log(`interpolator distances: hue: ${ hueDistance } c: ${ chromaDistance } light: ${ lightDistance } opacity: ${ opacityDistance }`);\n\n  return (amount: number): OkLchScalar => {\n    amount = clamp(amount);\n    let h = interpolate(amount, 0, Math.abs(hueDistance));\n    if (hueDistance < 0) h = a.h - h;\n    else h = a.h + h;\n\n    const c = interpolate(amount, 0, chromaDistance);\n    const l = interpolate(amount, 0, lightDistance);\n    const o = interpolate(amount, 0, opacityDistance);\n    //console.log(`amount: ${ amount } h: ${ h } s: ${ s } l: ${ l } o: ${ o }`);\n    return scalar(l + a.l, c + a.c, wrapScalarHue(h), o + aOpacity);\n  }\n}\n\nexport function scalar(lightness = 0.7, chroma = 0.1, hue = 0.5, opacity = 1): OkLchScalar {\n  const lch: OkLchScalar = {\n    unit: `scalar`,\n    space: `oklch`,\n    l: lightness,\n    c: chroma,\n    h: hue,\n    opacity: opacity\n  }\n  guard(lch);\n  return lch;\n}\n\n/**\n * Create an LCH colour using absolute hue\n * @param l Lightness 0..1\n * @param c Chroma 0..4\n * @param h Hue 0..360\n * @param opacity \n * @returns \n */\nexport const absolute = (l: number, c: number, h: number, opacity = 1): OkLchAbsolute => {\n  const lch: OkLchAbsolute = {\n    space: `oklch`,\n    unit: `absolute`,\n    opacity,\n    l, c, h\n  };\n  guard(lch);\n  return lch;\n}\n","import * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport * as OklchSpace from './oklch.js';\nimport type { Colour } from \"./types.js\";\n\n/**\n * Converts from some kind of colour that is legal in CSS\n * into a structured Colour type.\n * \n * Handles: hex format, CSS variables, colour names\n * ```js\n * fromCssColour(`#ffffff`);\n * fromCssColour(`blue`);\n * fromCssColour(`--some-variable`);\n * fromCssColour(`hsl(50, 50%, 50%)`);\n * fromCssColour(`rgb(50, 100, 100)`);\n * ```\n * @param colour \n * @returns \n */\nexport const fromCssColour = (colour: string): Colour => {\n  if (colour.startsWith(`#`)) {\n    return SrgbSpace.fromHexString(colour, true);\n  }\n\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return SrgbSpace.fromHexString(cssDefinedHexColours[ colour ] as string, true);\n  }\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0 || fromCss === null) throw new Error(`Variable missing: ${ colour }`);\n    return fromCssColour(fromCss);\n  }\n  colour = colour.toLowerCase();\n  if (colour.startsWith(`hsl(`)) {\n    return HslSpace.fromCss(colour, { scalar: true });\n  }\n  if (colour.startsWith(`rgb(`)) {\n    return SrgbSpace.fromCss(colour, { scalar: true });\n  }\n  if (colour.startsWith(`oklch(`)) {\n    return OklchSpace.fromCss(colour, { scalar: true });\n  }\n\n  throw new Error(`String colour is not a hex colour, CSS variable nor well-defined colour. Input: '${ colour }'`);\n}\n\nexport const cssDefinedHexColours = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",\n  \"blue\": \"#0000ff\",\n  \"blueviolet\": \"#8a2be2\",\n  \"brown\": \"#a52a2a\",\n  \"burlywood\": \"#deb887\",\n  \"cadetblue\": \"#5f9ea0\",\n  \"chartreuse\": \"#7fff00\",\n  \"chocolate\": \"#d2691e\",\n  \"coral\": \"#ff7f50\",\n  \"cornflowerblue\": \"#6495ed\",\n  \"cornsilk\": \"#fff8dc\",\n  \"crimson\": \"#dc143c\",\n  \"cyan\": \"#00ffff\",\n  \"darkblue\": \"#00008b\",\n  \"darkcyan\": \"#008b8b\",\n  \"darkgoldenrod\": \"#b8860b\",\n  \"darkgray\": \"#a9a9a9\",\n  \"darkgreen\": \"#006400\",\n  \"darkkhaki\": \"#bdb76b\",\n  \"darkmagenta\": \"#8b008b\",\n  \"darkolivegreen\": \"#556b2f\",\n  \"darkorange\": \"#ff8c00\",\n  \"darkorchid\": \"#9932cc\",\n  \"darkred\": \"#8b0000\",\n  \"darksalmon\": \"#e9967a\",\n  \"darkseagreen\": \"#8fbc8f\",\n  \"darkslateblue\": \"#483d8b\",\n  \"darkslategray\": \"#2f4f4f\",\n  \"darkturquoise\": \"#00ced1\",\n  \"darkviolet\": \"#9400d3\",\n  \"deeppink\": \"#ff1493\",\n  \"deepskyblue\": \"#00bfff\",\n  \"dimgray\": \"#696969\",\n  \"dodgerblue\": \"#1e90ff\",\n  \"firebrick\": \"#b22222\",\n  \"floralwhite\": \"#fffaf0\",\n  \"forestgreen\": \"#228b22\",\n  \"fuchsia\": \"#ff00ff\",\n  \"gainsboro\": \"#dcdcdc\",\n  \"ghostwhite\": \"#f8f8ff\",\n  \"gold\": \"#ffd700\",\n  \"goldenrod\": \"#daa520\",\n  \"gray\": \"#808080\",\n  \"green\": \"#008000\",\n  \"greenyellow\": \"#adff2f\",\n  \"honeydew\": \"#f0fff0\",\n  \"hotpink\": \"#ff69b4\",\n  \"indianred\": \"#cd5c5c\",\n  \"indigo\": \"#4b0082\",\n  \"ivory\": \"#fffff0\",\n  \"khaki\": \"#f0e68c\",\n  \"lavender\": \"#e6e6fa\",\n  \"lavenderblush\": \"#fff0f5\",\n  \"lawngreen\": \"#7cfc00\",\n  \"lemonchiffon\": \"#fffacd\",\n  \"lightblue\": \"#add8e6\",\n  \"lightcoral\": \"#f08080\",\n  \"lightcyan\": \"#e0ffff\",\n  \"lightgoldenrodyellow\": \"#fafad2\",\n  \"lightgray\": \"#d3d3d3\",\n  \"lightgreen\": \"#90ee90\",\n  \"lightpink\": \"#ffb6c1\",\n  \"lightsalmon\": \"#ffa07a\",\n  \"lightseagreen\": \"#20b2aa\",\n  \"lightskyblue\": \"#87cefa\",\n  \"lightslategray\": \"#778899\",\n  \"lightsteelblue\": \"#b0c4de\",\n  \"lightyellow\": \"#ffffe0\",\n  \"lime\": \"#00ff00\",\n  \"limegreen\": \"#32cd32\",\n  \"linen\": \"#faf0e6\",\n  \"magenta\": \"#ff00ff\",\n  \"maroon\": \"#800000\",\n  \"mediumaquamarine\": \"#66cdaa\",\n  \"mediumblue\": \"#0000cd\",\n  \"mediumorchid\": \"#ba55d3\",\n  \"mediumpurple\": \"#9370db\",\n  \"mediumseagreen\": \"#3cb371\",\n  \"mediumslateblue\": \"#7b68ee\",\n  \"mediumspringgreen\": \"#00fa9a\",\n  \"mediumturquoise\": \"#48d1cc\",\n  \"mediumvioletred\": \"#c71585\",\n  \"midnightblue\": \"#191970\",\n  \"mintcream\": \"#f5fffa\",\n  \"mistyrose\": \"#ffe4e1\",\n  \"moccasin\": \"#ffe4b5\",\n  \"navajowhite\": \"#ffdead\",\n  \"navy\": \"#000080\",\n  \"oldlace\": \"#fdf5e6\",\n  \"olive\": \"#808000\",\n  \"olivedrab\": \"#6b8e23\",\n  \"orange\": \"#ffa500\",\n  \"orangered\": \"#ff4500\",\n  \"orchid\": \"#da70d6\",\n  \"palegoldenrod\": \"#eee8aa\",\n  \"palegreen\": \"#98fb98\",\n  \"paleturquoise\": \"#afeeee\",\n  \"palevioletred\": \"#db7093\",\n  \"papayawhip\": \"#ffefd5\",\n  \"peachpuff\": \"#ffdab9\",\n  \"peru\": \"#cd853f\",\n  \"pink\": \"#ffc0cb\",\n  \"plum\": \"#dda0dd\",\n  \"powderblue\": \"#b0e0e6\",\n  \"purple\": \"#800080\",\n  \"rebeccapurple\": \"#663399\",\n  \"red\": \"#ff0000\",\n  \"rosybrown\": \"#bc8f8f\",\n  \"royalblue\": \"#4169e1\",\n  \"saddlebrown\": \"#8b4513\",\n  \"salmon\": \"#fa8072\",\n  \"sandybrown\": \"#f4a460\",\n  \"seagreen\": \"#2e8b57\",\n  \"seashell\": \"#fff5ee\",\n  \"sienna\": \"#a0522d\",\n  \"silver\": \"#c0c0c0\",\n  \"skyblue\": \"#87ceeb\",\n  \"slateblue\": \"#6a5acd\",\n  \"slategray\": \"#708090\",\n  \"snow\": \"#fffafa\",\n  \"springgreen\": \"#00ff7f\",\n  \"steelblue\": \"#4682b4\",\n  \"tan\": \"#d2b48c\",\n  \"teal\": \"#008080\",\n  \"thistle\": \"#d8bfd8\",\n  \"tomato\": \"#ff6347\",\n  \"turquoise\": \"#40e0d0\",\n  \"violet\": \"#ee82ee\",\n  \"wheat\": \"#f5deb3\",\n  \"white\": \"#ffffff\",\n  \"whitesmoke\": \"#f5f5f5\",\n  \"yellow\": \"#ffff00\",\n  \"yellowgreen\": \"#9acd32\",\n  \"transparent\": \"#00000000\"\n}\n","import Colorizr, * as C from \"colorizr\";\n\nimport type { Hsl, ParsingOptions, Rgb, Rgb8Bit, RgbScalar } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { toLibraryRgb as hslToLibraryRgb } from \"./hsl.js\";\nimport { isHsl } from \"./guards.js\";\n\nexport const withOpacity = <T extends Rgb>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `8bit`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 255) / 255, value) * 255\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport function fromHexString<T extends boolean>(hexString: string, scalar: T): T extends true ? RgbScalar : Rgb8Bit;\nexport function fromHexString(hexString: string, scalar = true): RgbScalar | Rgb8Bit {\n  return fromLibrary(C.hex2rgb(hexString), { scalar });\n};\n\nconst srgbTansparent: Rgb8Bit = Object.freeze({\n  r: 0, g: 0, b: 0, opacity: 0, unit: `8bit`, space: `srgb`\n})\n\nexport function fromCss<T extends ParsingOptions<Rgb>>(value: string, options: T): T extends { scalar: true } ? RgbScalar : Rgb8Bit;\n\n/**\n * Converts a colour in a legal CSS form into Rgb value, by default RgbScalar (0..1) scale.\n * ```js\n * fromCss(`rebeccapurple`);\n * fromCss(`rgb(40% 20% 60%)`);\n * \n * // Get 8bit version on 0..255 scale\n * fromCss(`blue`, { scalar: false });\n * ```\n * \n * @param value \n * @param options \n * @returns \n */\nexport function fromCss(value: string, options: ParsingOptions<Rgb> = {}): Rgb {\n  value = value.toLowerCase();\n  if (value.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);\n  if (value.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);\n\n\n  const scalar = options.scalar ?? true;\n\n  // Convert from hex\n  if (value.startsWith(`#`)) return fromHexString(value, scalar);\n  // Special-case transparent\n  if (value === `transparent`) return srgbTansparent;\n  // Convert from named colour\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) fromHexString(cssDefinedHexColours[ value ] as string, scalar);\n\n  if (value.startsWith(`hsl(`)) {\n    const rgb = hslToLibraryRgb(value);\n    return fromLibrary(rgb, options);\n  }\n\n  // if (value.startsWith(`hsl(`)) {\n\n  //   const hslRel = hslToScalar(parseCssHslFunction(value));\n  //   const rgb = C.hsl2rgb({ h: hslRel.h, s: hslRel.s, l: hslRel.l, alpha: hslRel.opacity ?? 1 });\n  //   return fromLibrary(rgb, options);\n\n  // }\n\n  // Convert to rgb() colour function\n  if (!value.startsWith(`rgb(`)) {\n    try {\n      value = C.convert(value, `rgb`);\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  try {\n    // Hand-rolled rgb() parse because the package is broken\n    const rgb = parseCssRgbFunction(value);\n    if (scalar) return toScalar(rgb);\n    return to8bit(rgb);\n  } catch (error) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw error;\n  }\n}\n\nexport const toCssString = (rgb: Rgb): string => {\n  guard(rgb);\n  switch (rgb.unit) {\n    case `8bit`:\n      if (rgb.opacity === undefined || rgb.opacity === 255) {\n        return `rgb(${ rgb.r } ${ rgb.g } ${ rgb.b })`;\n      }\n      return `rgb(${ rgb.r } ${ rgb.g } ${ rgb.b } / ${ (rgb.opacity ?? 255) / 255 })`;\n    case `scalar`:\n      if (rgb.opacity === undefined || rgb.opacity === 1) {\n        return `rgb(${ rgb.r * 100 }% ${ rgb.g * 100 }% ${ rgb.b * 100 }%)`;\n      }\n      return `rgb(${ rgb.r * 100 }% ${ rgb.g * 100 }% ${ rgb.b * 100 }% / ${ (rgb.opacity ?? 1) * 100 }%)`;\n    default:\n\n      throw new Error(`Unknown unit: ${ (rgb as any).unit }`);\n  }\n}\n\nconst toLibrary = (rgb: Rgb): C.RGB => {\n  const abs = to8bit(rgb);\n  return {\n    r: abs.r,\n    g: abs.g,\n    b: abs.b,\n    alpha: abs.opacity,\n  }\n}\n\nfunction fromLibrary<T extends ParsingOptions<Rgb>>(rgb: C.RGB, parsingOptions: T):\n  T extends { scalar: true } ? RgbScalar : Rgb8Bit\n\nfunction fromLibrary(rgb: C.RGB, parsingOptions: ParsingOptions<Rgb> = {}): Rgb8Bit | RgbScalar {\n  if (parsingOptions.scalar) {\n    return {\n      r: rgb.r / 255,\n      g: rgb.g / 255,\n      b: rgb.b / 255,\n      opacity: rgb.alpha ?? 1,\n      unit: `scalar`,\n      space: `srgb`\n    }\n  } else {\n    return {\n      r: rgb.r,\n      g: rgb.g,\n      b: rgb.b,\n      opacity: rgb.alpha ?? 255,\n      unit: `8bit`,\n      space: `srgb`\n    }\n  }\n}\n\n\nexport const to8bit = (rgbOrString: Rgb | string): Rgb8Bit => {\n  if (typeof rgbOrString === `string`) {\n    return fromCss(rgbOrString, { scalar: false });\n  }\n  if (isHsl(rgbOrString)) {\n    return to8bit(fromLibrary(hslToLibraryRgb(rgbOrString), { scalar: false }));\n  }\n  guard(rgbOrString);\n  if (rgbOrString.unit === `8bit`) return rgbOrString;\n  return {\n    r: rgbOrString.r * 255,\n    g: rgbOrString.g * 255,\n    b: rgbOrString.b * 255,\n    opacity: (rgbOrString.opacity ?? 1) * 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nexport const toScalar = (rgbOrString: Rgb | Hsl | string): RgbScalar => {\n  if (typeof rgbOrString === `string`) {\n    return fromCss(rgbOrString, { scalar: true });\n  }\n  if (isHsl(rgbOrString)) {\n    return toScalar(fromLibrary(hslToLibraryRgb(rgbOrString), { scalar: true }));\n  }\n  guard(rgbOrString);\n  if (rgbOrString.unit === `scalar`) return rgbOrString;\n  return {\n    r: rgbOrString.r / 255,\n    g: rgbOrString.g / 255,\n    b: rgbOrString.b / 255,\n    opacity: (rgbOrString.opacity ?? 1) / 255,\n    unit: `scalar`,\n    space: `srgb`\n  }\n}\n\nexport const guard = (rgb: Rgb) => {\n  const { r, g, b, opacity, space, unit } = rgb;\n  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${ space }`);\n  if (unit === `8bit`) {\n    resultThrow(\n      numberInclusiveRangeTest(r, 0, 255, `r`),\n      numberInclusiveRangeTest(g, 0, 255, `g`),\n      numberInclusiveRangeTest(b, 0, 255, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 255, `opacity`);\n        }\n      }\n    );\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(r, `percentage`, `r`),\n      numberTest(g, `percentage`, `g`),\n      numberTest(b, `percentage`, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\n/**\n * Sets the lightness value.\n * \n * Amount to change:\n * * 'fixed': a fixed amount\n * * 'delta': increase/decrease by this amount\n * * 'pdelta': proportion of current value to change by ('percentage delta')\n * \n * Use negative values to decrease\n * @param value \n * @param amount \n */\nexport const changeLightness = (rgb: Rgb, amount: Partial<{ pdelta: number, delta: number, fixed: number }>): Rgb => {\n  let newL = 0;\n  const co = new Colorizr(toCssString(rgb));\n  const scalarUnit = rgb.unit === `scalar`;\n  if (typeof amount.pdelta !== `undefined`) {\n    newL = co.oklab.l + (co.oklab.l * amount.pdelta);\n  } else if (typeof amount.delta !== `undefined`) {\n    newL = co.oklab.l + amount.delta;\n  } else if (typeof amount.fixed !== `undefined`) {\n    if (amount.fixed < 0) throw new TypeError(`Amount cannot be negative when using 'fixed'`);\n    newL = amount.fixed;\n  } else {\n    throw new TypeError(`Parameter 'amount' is missing 'pdelta/delta/fixed' properties`);\n  }\n  if (newL < 0) newL = 0;\n  else if (newL > 1) newL = 1;\n\n  const rgbResult = C.oklab2rgb({ a: co.oklab.a, b: co.oklab.b, l: newL, alpha: co.oklab.alpha });\n  return fromLibrary(rgbResult, { scalar: scalarUnit });\n  //return eightBit ? fromLibrary8bit(rgbResult) : fromLibraryScalar(rgbResult);\n}\n\n/**\n * Returns a lightness value (0..1) for an RGB input\n * \n * Calculates lightness by converting to Oklab and using the 'L' value\n * @param rgb \n * @returns \n */\nexport function lightness(rgb: Rgb) {\n  const co = new Colorizr(toCssString(rgb));\n  return co.oklab.l;\n}\n\nconst scaleProperty = (rgb: Rgb, value: number, property: `r` | `g` | `b` | `opacity`) => {\n  if (rgb.unit === `scalar`) {\n    // 0..1 scale\n    if (value > 1) value = 1;\n    else if (value < 0) value = 0;\n  } else {\n    // 0..255 scale\n    if (value > 255) value = 255;\n    else if (value < 0) value = 0;\n  }\n  return value;\n}\n\n/**\n * Creates a Rgb8Bit value from 8bit (0..255) values\n * @param red \n * @param green \n * @param blue \n * @param opacity \n * @returns \n */\nexport function eightBit(red = 100, green = 100, blue = 100, opacity = 255): Rgb8Bit {\n  const rgb: Rgb8Bit = {\n    unit: `8bit`,\n    space: `srgb`,\n    r: red,\n    g: green,\n    b: blue,\n    opacity: opacity\n  }\n  guard(rgb);\n  return rgb;\n}\n\n/**\n * Creates a RgbScalar value from scalar (0..1) values\n * @param red \n * @param green \n * @param blue \n * @param opacity \n * @returns \n */\nexport function scalar(red = 0.5, green = 0.5, blue = 0.5, opacity = 1): RgbScalar {\n  const rgb: RgbScalar = {\n    unit: `scalar`,\n    space: `srgb`,\n    r: red,\n    g: green,\n    b: blue,\n    opacity: opacity\n  }\n  guard(rgb);\n  return rgb;\n}\n\n\n/**\n * It seems Colorizr can't handle % values properly :'(\n * @param value \n */\nexport function parseCssRgbFunction(value: string): Rgb {\n  if (value.startsWith(`rgba`)) throw new Error(`RGBA is not supported`);\n  if (!value.startsWith(`rgb(`)) throw new Error(`Expected rgb(..) CSS colour`);\n\n  const start = value.indexOf('(');\n  const end = value.indexOf(')');\n  if (end < start) throw new Error(`Is rgb() not terminated? Missing ')'`);\n\n  const part = value.substring(start + 1, end);\n  let split = part.split(/[\\s,]+/);\n  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${ split.length } length`);\n\n  let relativeCount = 0;\n  for (const s of split) {\n    if (s.endsWith('%')) relativeCount++;\n  }\n\n  const valueAsScalar = (v: string, pos: number) => {\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100;\n    }\n    if (pos < 3) {\n      // r, g or b\n      return Number.parseFloat(v) / 255;\n    } else {\n      // opacity should already be in scalar value\n      return Number.parseFloat(v);\n    }\n  }\n\n  const valueAs8bit = (v: string, pos: number) => {\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100 * 255;\n    }\n    if (pos < 3) {\n      // r, g or b\n      return Number.parseFloat(v);\n    } else {\n      // opacity should already be in scalar value\n      return Number.parseFloat(v) * 255;\n    }\n  }\n\n  // Is there opacity?\n  if (split.length > 3) {\n    if (split[ 3 ] === '/') {\n      // Remove / part\n      split = [ split[ 0 ], split[ 1 ], split[ 2 ], split[ 4 ] ];\n    }\n  }\n  if (relativeCount > 1) {\n    // Return as scalar\n    return scalar(\n      valueAsScalar(split[ 0 ], 0),\n      valueAsScalar(split[ 1 ], 1),\n      valueAsScalar(split[ 2 ], 2),\n      valueAsScalar(split[ 3 ] ?? `1`, 3)\n    )\n  } else {\n    // Return as 8bit\n    return eightBit(\n      valueAs8bit(split[ 0 ], 0),\n      valueAs8bit(split[ 1 ], 1),\n      valueAs8bit(split[ 2 ], 2),\n      valueAs8bit(split[ 3 ] ?? `1`, 3)\n    )\n  }\n}\n\n/**\n * Interpolates colours in Srgb space. Probably\n * really ugly, use OkLch space isntead.\n * \n * ```js\n * const i = interpolator(`red`, `blue`);\n * i(0.5); // Get 50% between these colours\n * ```\n * @param colourA \n * @param colourB \n * @returns \n */\nexport const interpolator = (colourA: Rgb | string, colourB: Rgb | string) => {\n  const aa = toScalar(colourA);\n  const bb = toScalar(colourB);\n\n  const aOpacity = aa.opacity ?? 1;\n  const opacityDistance = (bb.opacity ?? 1) - aOpacity;\n\n  const r = bb.r - aa.r;\n  const g = bb.g - aa.g;\n  const b = bb.b - aa.b;\n\n  return (amount: number): RgbScalar => {\n    amount = clamp(amount);\n    return scalar(\n      aa.r + interpolate(amount, 0, r),\n      aa.g + interpolate(amount, 0, g),\n      aa.b + interpolate(amount, 0, b),\n      aOpacity + interpolate(amount, 0, opacityDistance));\n  }\n}\n\n/**\n * Converts a Rgb structure (or CSS string) to Colorizr's HSL format\n * @param rgb \n * @returns \n */\nexport function toLibraryHsl(rgb: Rgb | string): C.HSL {\n  if (typeof rgb === `string`) {\n    const parseResult = fromCss(rgb, { scalar: false });\n    return toLibraryHsl(parseResult);\n  }\n  rgb = to8bit(rgb);\n  const hsl = C.rgb2hsl({ r: rgb.r, g: rgb.g, b: rgb.b });\n  return { ...hsl, alpha: (rgb.opacity ?? 255) / 255 };\n}","import { Grids } from '@ixfx/geometry';\nimport * as SrgbSpace from './colour/srgb.js';\nimport type { Rgb, Rgb8Bit } from './colour/types.js';\n\n/**\n * Returns a {@link @ixfx/geometry/Grids.Grid} based on the provided `image`\n * @param image ImageData\n * @returns Grid\n */\nexport const grid = (image: ImageData): Grids.Grid => {\n  const g = { rows: image.width, cols: image.height };\n  return g;\n}\n\n/**\n * Returns an object that allows get/set grid semantics on the underlying `image` data.\n * Uses 8-bit sRGB values, meaning 0..255 range for red, green, blue & opacity.\n * \n * ```js\n * // Get CANVAS element, drawing context and then image data\n * const canvasEl = document.querySelector(`#my-canvas`);\n * const ctx = canvasEl.getContext(`2d`);\n * const imageData = ctx.getImageData();\n * \n * // Now that we have image data, we can wrap it:\n * const asGrid = ImageDataGrid.wrap(imageData);\n * asGrid.get({ x:10, y: 20 }); // Get pixel at 10,20\n * asGrid.set(colour, { x:10, y: 20 }); // Set pixel value\n * \n * // Display changes back on the canvas\n * ctx.putImageData(imageData, 0, 0)\n * ```\n * @param image \n * @returns \n */\nexport const wrap = (image: ImageData): Grids.GridWritable<Rgb8Bit> & Grids.GridReadable<Rgb8Bit> => {\n  return {\n    ...grid(image),\n    get: accessor(image),\n    set: setter(image)\n  }\n}\n\n/**\n * Returns a function to access pixel values by x,y\n * @param image \n * @returns \n */\nexport const accessor = (image: ImageData): Grids.GridCellAccessor<Rgb8Bit> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellAccessor<Rgb8Bit> = (cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) return;\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      unit: `8bit`,\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns a function that sets pixel values\n * @param image \n * @returns \n */\nexport const setter = (image: ImageData): Grids.GridCellSetter<Rgb> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellSetter<Rgb> = (value: Rgb, cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) throw new Error(`Cell out of range. ${ cell.x },${ cell.y }`);\n    const pixel = SrgbSpace.to8bit(value);\n    const pxIndex = index * 4;\n    data[ pxIndex ] = pixel.r;\n    data[ pxIndex + 1 ] = pixel.g;\n    data[ pxIndex + 2 ] = pixel.b;\n    data[ pxIndex + 3 ] = pixel.opacity ?? 255;\n  };\n  return fn;\n}\n\n// export function* visit(image: ImageData, visitor: Grids.VisitGenerator) {\n//   const a = accessor(image);\n\n//   for (const cell of visitor) {\n//     yield a(cell, `undefined`);\n//   }\n// }\n\n/**\n * Yields pixels of an image row by row\n * @param image \n */\nexport function* byRow(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  const v = Grids.As.rows(g, { x: 0, y: 0 });\n  for (const row of v) {\n    const pixels = row.map(p => a(p, `undefined`));\n    yield pixels\n  }\n}\n\n/**\n * Yields pixels of an image column by column\n * @param image \n */\nexport function* byColumn(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  for (let x = 0; x < g.cols; x++) {\n    const col: Rgb8Bit[] = [];\n    for (let y = 0; y < g.rows; y++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) col.push(p);\n    }\n    yield col;\n  }\n}","import { ElementSizer, resolveEl, type ElementResizeLogic, type ElementSizerOptions } from '@ixfx/dom';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport type { ScaleBy, ScalerCombined } from '@ixfx/geometry';\nimport type { Rect, RectPositioned } from '@ixfx/geometry/rect';\nimport { Rects, scaler } from '@ixfx/geometry';\nimport * as Drawing from './drawing.js';\nimport * as ImageDataGrid from './image-data-grid.js';\nimport { cloneFromFields } from '@ixfx/core/records';\nimport type { Grid } from '@ixfx/geometry/grid';\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n\n  /**\n   * Pointerdown. \n   * \n   * Adds logicalX/Y to get logical pixel coordinate\n   */\n  pointerdown: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointerup. \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointerup: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointermove \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointermove: PointerEvent & { physicalX: number, physicalY: number },\n}\n\n\n/**\n * CanvasHelper options\n */\nexport type CanvasHelperOptions = Readonly<{\n  /**\n   * Automatic canvas resizing logic.\n   */\n  resizeLogic?: ElementResizeLogic\n  /**\n   * By default, the helper emits pointer events from the canvas.\n   * Set this to _true_ to disable.\n   */\n  disablePointerEvents: boolean\n  /**\n   * By default the display DPI is used for scaling.\n   * If this is set, this will override.\n   */\n  pixelZoom: number\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  skipCss: boolean;\n  coordinateScale: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  onResize?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Logical width of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  width: number\n  /**\n   * Logical height of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  zIndex: number\n  /**\n   * Colour space to use. Defaults to sRGB.\n   */\n  colourSpace: PredefinedColorSpace;\n\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx Drawing context\n   * @param size Viewport size\n   * @param helper CanvasHelper instance\n   * @returns \n   */\n  draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n}>;\n\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, draw });\n * ```\n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasHelperOptions\n\n  #scaler: ScalerCombined;\n  #scalerSize: ScalerCombined;\n  #viewport: RectPositioned = Rects.EmptyPositioned;\n  #logicalSize: Rect = Rects.Empty;\n  #ctx: CanvasRenderingContext2D | undefined;\n  #drawHelper: Drawing.DrawingHelper | undefined;\n  #resizer: ElementSizer<HTMLCanvasElement> | undefined;\n  #disposed = false;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasHelperOptions> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n\n    const size = this.el.getBoundingClientRect();\n    this.opts = {\n      resizeLogic: opts.resizeLogic ?? `none`,\n      disablePointerEvents: opts.disablePointerEvents ?? false,\n      pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),\n      height: opts.height ?? size.height,\n      width: opts.width ?? size.width,\n      zIndex: opts.zIndex ?? -1,\n      coordinateScale: opts.coordinateScale ?? `both`,\n      onResize: opts.onResize,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false,\n      colourSpace: `srgb`\n    }\n\n    this.#scaler = scaler(`both`);\n    this.#scalerSize = scaler(`both`, size);\n    this.#init();\n  }\n\n  getRectangle(): RectPositioned {\n    return {\n      x: 0, y: 0,\n      ...this.#logicalSize\n    }\n  }\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizer) {\n      this.#resizer.dispose(`CanvasHelper disposing ${ reason }`.trim());\n      this.#resizer = undefined;\n    }\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  /**\n   * Gets the drawable area of the canvas.\n   * This accounts for scaling due to high-DPI displays etc.\n   * @returns \n   */\n  getPhysicalSize() {\n    return {\n      width: this.width * this.ratio,\n      height: this.height * this.ratio\n    }\n  }\n\n  /**\n   * Creates a drawing helper for the canvas.\n   * If one is already created it is reused.\n   */\n  getDrawHelper() {\n    if (!this.#drawHelper) {\n      this.#drawHelper = Drawing.makeHelper(this.#getContext(), {\n        width: this.width, height: this.height\n      });\n    }\n  }\n\n  setLogicalSize(logicalSize: Rect) {\n    Rects.guard(logicalSize, `logicalSize`);\n    const logicalSizeInteger = Rects.applyFields(v => Math.floor(v), logicalSize);\n    const ratio = this.opts.pixelZoom;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = scaler(this.opts.coordinateScale, logicalSize);\n    this.#scalerSize = scaler(`both`, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = Rects.multiplyScalar(logicalSize, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSizeInteger.width.toString() + `px`;\n    this.el.style.height = logicalSizeInteger.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#logicalSize = logicalSizeInteger;\n\n    //console.log(`setting logical size to ${ this.#logicalSize.width }x${ this.#logicalSize.height }`);\n    // Notify listeners of resize\n    const r = this.opts.onResize;\n    if (r) {\n      setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n\n  #init() {\n    //console.log(`init`, this.opts);\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#logicalSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n\n    if (!this.opts.disablePointerEvents) {\n      this.#handleEvents();\n    }\n\n    const resizeLogic = this.opts.resizeLogic ?? `none`;\n    if (resizeLogic === `none`) {\n      this.setLogicalSize({ width: this.opts.width, height: this.opts.height });\n    } else {\n      const resizerOptions: ElementSizerOptions<HTMLCanvasElement> = {\n        onSetSize: (size) => {\n          if (Rects.isEqual(this.#logicalSize, size)) return;\n          this.setLogicalSize(size);\n        },\n        naturalSize: { width: this.opts.width, height: this.opts.height },\n        stretch: this.opts.resizeLogic ?? `none`\n      };\n      this.#resizer = new ElementSizer(this.el, resizerOptions);\n    }\n\n    this.#getContext();\n  }\n\n  #handleEvents() {\n    const handlePointerEvent = (event: PointerEvent) => {\n      const { offsetX, offsetY } = event;\n      const physicalX = offsetX * this.ratio;\n      const physicalY = offsetY * this.ratio;\n      event = cloneFromFields(event);\n      const eventData = {\n        physicalX, physicalY,\n        // eslint-disable-next-line @typescript-eslint/no-misused-spread\n        ...event\n      };\n\n      switch (event.type) {\n        case `pointerup`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n        case `pointermove`: {\n          {\n            this.fireEvent(`pointermove`, eventData);\n            break;\n          };\n        }\n        case `pointerdown`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n      };\n    }\n\n    this.el.addEventListener(`pointermove`, handlePointerEvent);\n    this.el.addEventListener(`pointerdown`, handlePointerEvent);\n    this.el.addEventListener(`pointerup`, handlePointerEvent);\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `ctx.clearRect(0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (!this.#ctx) return;\n    this.#ctx.clearRect(0, 0, this.width, this.height);\n\n  }\n\n  /**\n   * Fills the canvas with a given colour.\n   * \n   * Shortcut for:\n   * ```js\n      * ctx.fillStyle = ``;\n   * ctx.fillRect(0, 0, this.width, this.height);\n   * ```\n   * @param colour Colour\n   */\n  fill(colour?: string) {\n    if (!this.#ctx) return;\n    if (colour) this.#ctx.fillStyle = colour;\n    this.#ctx.fillRect(0, 0, this.width, this.height);\n\n  }\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#logicalSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#logicalSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n\n\n  drawBounds(strokeStyle = `green`) {\n    const ctx = this.#getContext();\n    Drawing.rect(ctx,\n      { x: 0, y: 0, width: this.width, height: this.height },\n      { crossed: true, strokeStyle, strokeWidth: 1 });\n\n    Drawing.rect(ctx, this.#viewport, { crossed: true, strokeStyle: `silver`, strokeWidth: 3 })\n  }\n\n  /**\n   * Returns a Scaler that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n      * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toAbsoluteFixed() {\n    return this.#scalerSize.abs\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toRelativeFixed() {\n    return this.#scalerSize.rel;\n  }\n\n  get logicalCenter() {\n    return {\n      x: this.#logicalSize.width / 2,\n      y: this.#logicalSize.height / 2\n    }\n  }\n\n  /**\n * Returns a Scaler that converts from relative to absolute\n * coordinates.\n * This is based on the canvas size.\n * \n * ```js\n * // Assuming a canvas of 800x600\n * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n * ```\n */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n\n  /**\n   * Gets the image data for the canvas.\n   * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be\n   * 536x536 with a high-DPI display.\n   * @returns \n   */\n  getImageData(): ImageData {\n    const size = this.getPhysicalSize();\n    const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data === null || data === undefined) throw new Error(`Could not get image data from context`);\n    return data;\n  }\n\n  /**\n   * Returns the canvas frame data as a writable grid.\n   * When editing, make as many edits as needed before calling\n   * `flip`, which writes buffer back to the canvas.\n   * ```js\n      * const g = helper.getWritableBuffer();\n   * // Get {r,g,b,opacity} of pixel 10,10\n   * const pixel = g.get({ x: 10, y: 10 });\n   * \n   * // Set a colour to pixel 10,10\n   * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });\n   * \n   * // Write buffer to canvas\n   * g.flip();\n   * ```\n   * \n   * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will\n   * mean a higher number of rows and columns compared to the logical size.\n   * @returns\n   */\n  getWritableBuffer() {\n    const ctx = this.ctx;\n    const data = this.getImageData();\n    const grid = ImageDataGrid.grid(data);\n    const get = ImageDataGrid.accessor(data);\n    const set = ImageDataGrid.setter(data);\n\n    const flip = () => {\n      ctx.putImageData(data, 0, 0);\n    }\n\n    return { grid, get, set, flip };\n  }\n}\n\n// export const imageDataAsGrid = (canvas: HTMLCanvasElement, colorSpace: PredefinedColorSpace = `srgb`) => {\n//   const ctx = canvas.getContext(`2d`);\n//   if (!ctx) throw new Error(`Could not create context`);\n\n//   const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace });\n//   if (!data) throw new Error(`Could not get image data from context`);\n\n//   const get = ImageDataGrid.accessor(data);\n//   const set = ImageDataGrid.setter(data);\n// }","import type { DrawingOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: fillStyle\n * @param elem Element\n * @param opts Drawing options\n */\nexport const applyOpts = (elem: SVGElement, opts: DrawingOpts) => {\n  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);\n  if (opts.opacity) {\n    elem.setAttributeNS(null, `opacity`, opts.opacity.toString());\n  }\n\n};","/**\n * Creates an element of `type` and with `id` (if specified)\n * @param type Element type, eg `circle`\n * @param id Optional id to assign to element\n * @returns Element\n */\nexport const createEl = <V extends SVGElement>(\n  type: string,\n  id?: string\n): V => {\n  const m = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n  if (id) {\n    m.id = id;\n  }\n  return m;\n};\n\n\n/**\n * Creates and appends a SVG element.\n *\n * ```js\n * // Create a circle\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`);\n * ```\n *\n * If `queryOrExisting` is specified, it is used as a query to find an existing element. If\n * query starts with `#`, this will be set as the element id, if created.\n *\n * ```js\n * // Creates an element with id 'myCircle' if it doesn't exist\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`, `#myCircle`);\n * ```\n * @param parent Parent element\n * @param type Type of SVG element\n * @param queryOrExisting Query, eg `#id`\n * @returns\n */\nexport const createOrResolve = <V extends SVGElement>(\n  parent: SVGElement,\n  type: string,\n  queryOrExisting?: string | V,\n  suffix?: string\n): V => {\n  let existing:SVGElement|HTMLElement|null = null;\n  if (queryOrExisting !== undefined) {\n    existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;\n  }\n  if (existing === null) {\n    const p = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n    parent.append(p);\n    if (queryOrExisting && typeof queryOrExisting === `string` &&\n      queryOrExisting.startsWith(`#`)) {\n      p.id = suffix !== undefined && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);\n    }\n    return p;\n  }\n  return existing as V;\n};","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { type RandomSource } from '@ixfx/random';\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (\n  index: number,\n  saturation = 0.5,\n  lightness = 0.75,\n  alpha = 1\n) => {\n  resultThrow(\n    numberTest(index, `positive`, `index`),\n    numberTest(saturation, `percentage`, `saturation`),\n    numberTest(lightness, `percentage`, `lightness`),\n    numberTest(alpha, `percentage`, `alpha`)\n  );\n  // Via Stackoverflow\n  const hue = index * 137.508; // use golden angle approximation\n  return alpha === 1 ? `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%)` : `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%,${ alpha * 100 }%)`;\n};\n\n/**\n * Returns a random hue component (0..359)\n * ```\n * // Generate hue\n * const h =randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand: RandomSource = Math.random): number => {\n  const r = rand();\n  return r * 360;\n};\n","import type { Colour, Colourish, Hsl, Rgb } from './types.js';\nimport { toColour, toCssColour } from './conversion.js';\nimport * as HslSpace from './hsl.js';\nimport * as SrgbSpace from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\nimport { OklchSpace } from './index.js';\nimport * as C from 'colorizr';\n\n/**\n * Multiplies the opacity of a colour by `amount`, returning a computed CSS colour.\n * \n * ```js\n * multiplyOpacity(`red`, 0.5); // Returns a colour string\n * ```\n * \n * For example, to half the opacity, use `amount: 0.5`.\n * Clamps the result to ensure it's between 0..1\n * @param colourish \n * @param amount \n * @returns \n */\nexport function multiplyOpacity(colourish: string, amount: number): string {\n  return withOpacity(colourish, o => clamp(o * amount));\n}\n\n/**\n * Does a computation with the opacity of a colour, returning colour string\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\nexport function withOpacity(colourish: string, fn: (scalarOpacity: number) => number): string;\n\n/**\n * Does a computation with the opacity of a colour in a HSL structure\n * @param hsl Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\nexport function withOpacity(hsl: Hsl, fn: (scalarOpacity: number) => number): Hsl;\n\n/**\n * Does a computation with the opacity of a colour in a RGB structure\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n\nexport function withOpacity(rgb: Rgb, fn: (scalarOpacity: number) => number): Rgb;\n\n/**\n * Does a computation with the opacity of a colour, returning colour.\n * \n * Passes operation to `HslSpace` or `SrgbSpace` depending on space of `colourish`.\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\nexport function withOpacity(colourish: Colourish, fn: (scalarOpacity: number) => number): Colourish {\n  const colour = toColour(colourish);\n  let result: Colour | undefined;\n  switch (colour.space) {\n    case `hsl`:\n      result = HslSpace.withOpacity(colour, fn);\n      break;\n    case `srgb`:\n      result = SrgbSpace.withOpacity(colour, fn);\n      break;\n    case `oklch`:\n      result = OklchSpace.withOpacity(colour, fn);\n      break;\n    default:\n      throw new Error(`Unknown space: '${ colour.space }'. Expected hsl, srgb, oklch`)\n  }\n  if (!result) throw new Error(`Is colour in correct form?`);\n\n  // If input type was string, return result as string\n  if (typeof colourish === `string`) {\n    return toCssColour(result);\n  }\n  return result;\n};\n\n// export function lighten(colour: string, amount: number): string;\n// export function lighten(colour: Colour, amount: number): Colour;\n// export function lighten(colourish: Colourish, amount: number): Colourish {\n//   const asString = toCssColour(colourish);\n//   const result = C.lighten(asString, amount, ``)\n// }\n\n\n\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };","import type { Colour, ColourInterpolationOpts, ColourInterpolator, Colourish, ColourSpaces, ColourStepOpts, Hsl, HslScalar, OkLch, OkLchScalar, RgbScalar } from \"./types.js\";\nimport { pairwise } from '@ixfx/arrays';\nimport * as HslSpace from './hsl.js';\nimport { convert, toCssColour, type ConvertDestinations } from \"./conversion.js\";\nimport { convertScalar, OklchSpace, SrgbSpace } from \"./index.js\";\n\n/**\n * Returns a function to interpolate between colours\n * ```js\n * const i = interpolator([`orange`, `yellow`, `red`]);\n * \n * // Get a random colour on the above spectrum\n * i(Math.random());\n * ```\n * \n * Results will vary depending on the colour space used, play with the options.\n * When using a hue-based colour space, the `hue` option sets the logic for how hue values wrap.\n * \n * ```js\n * interpolator([`orange`, `yellow`, `red`], { space: `hsl`, hue: `longer })\n * ```\n * @param colours Colours to interpolate between\n * @param opts Options for interpolation\n * @returns \n */\n// export const interpolator = (colours: Colourish[], opts: Partial<ColourInterpolationOpts> = {}) => {\n//   const spaceDestination: ConvertDestinations = `oklch-scalar`;\n//   let ranges: Colour[] = [];\n//   const direction = opts.direction ?? `shorter`;\n\n//   switch (opts.space) {\n//     case `hsl`:\n//       ranges = interpolateInit(colours, `hsl-scalar`)\n//         .map(piece => HslSpace.interpolator(piece[ 0 ], piece[ 1 ], direction));\n//       break;\n//     default:\n//       ranges = interpolateInit(colours, `oklch-scalar`)\n//         .map(piece => OklchSpace.interpolator(piece[ 0 ], piece[ 1 ], direction));\n//       break;\n//   }\n\n\n//   return (amt: number): string => {\n//     amt = clamp(amt);\n\n//     // Scale to 0..1 to 0...ranges.length\n//     const s = scaleNumber(amt, 0, 1, 0, ranges.length);\n//     const index = Math.floor(s);\n//     const amtAdjusted = s - index;\n//     const range = ranges[ index ];\n\n//     // If we're at the end, return the last colour\n\n//     if (index === 1) return toHex(colours.at(-1)!);\n\n//     const colour = range(amtAdjusted);\n//     return colour.display();\n\n//   }\n// }\n\n// const interpolatorInit = (colours: Colourish[]) => {\n//   if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n//   if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n//   const c = colours.map(colour => toLibraryColour(colour));\n//   return [ ...pairwise(c) ];\n// }\n\n// function interpolateInit(colours: Colourish[], destination: `oklch-scalar`): OkLchScalar[][];\n// function interpolateInit(colours: Colourish[], destination: `hsl-scalar`): HslScalar[][];\nfunction interpolateInit<T extends ColourSpaces>(colours: Colourish[], destination: T):\n  T extends `oklch` ? OkLchScalar[][] :\n  T extends `hsl` ? HslScalar[][] :\n  T extends `srgb` ? RgbScalar[][] : HslScalar[][]\n\nfunction interpolateInit(colours: Colourish[], destination: ColourSpaces = `hsl`): (OkLchScalar | HslScalar | RgbScalar)[][] {\n  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n\n  const c = colours.map(colour => convertScalar(colour, destination));\n  return [ ...pairwise(c) ];\n}\n\n/**\n * Returns a CSS `linear-gradient` with stops corresponding to the given list of `colours`.\n * ```js\n * element.style.background = Colour.cssLinearGradient(['red','green','blue']);\n * ```\n * @param colours \n * @returns \n */\nexport const cssLinearGradient = (colours: Colourish[]) => {\n  const c = colours.map(c => toCssColour(c));\n  return `linear-gradient(to right, ${ c.join(`, `) })`;\n}\n\n/**\n * Returns a function that interpolates between two colours. Returns string colour values.\n * ```js\n * const i = interpolator(`blue`, `red`);\n * i(0.5); // Get the colour at 50%, as a string.\n * ```\n * \n * To work with structured colour values, use one of the space's `interpolate` functions.\n * @param colourA \n * @param colourB \n * @param options \n * @returns \n */\nexport const interpolator = (colourA: Colourish, colourB: Colourish, options: Partial<ColourInterpolationOpts> = {}) => {\n  const space = options.space ?? `oklch`;\n  const direction = options.direction ?? `shorter`;\n\n  let inter: ColourInterpolator<Colour> | undefined;\n  switch (space) {\n    case `hsl`:\n      inter = HslSpace.interpolator(convert(colourA, `hsl-scalar`), convert(colourB, `hsl-scalar`), direction);\n      break;\n    case `srgb`:\n      inter = SrgbSpace.interpolator(convert(colourA, `srgb-scalar`), convert(colourB, `srgb-scalar`));\n      break;\n    default:\n      inter = OklchSpace.interpolator(convert(colourA, `oklch-scalar`), convert(colourB, `oklch-scalar`), direction);\n  }\n\n  return (amount: number) => toCssColour(inter(amount));\n\n}\n\n/**\n * Produces a stepped scale of colours.\n * \n * ```js\n * // A scale of from red to green, with three colours in-between\n * const steps = Colour.scale([ `red`, `green` ], { stepsBetween: 3 });\n * for (const step of steps) {\n *  // A CSS colour string\n * }\n * ```\n * \n * {@link cssLinearGradient} can produce a smooth gradient in CSS on the basis\n * of the stepped colours.\n * @param colours \n * @param opts \n * @returns \n */\nexport const scale = (colours: Colourish[], opts: Partial<ColourStepOpts> = {}): string[] => {\n  const direction = opts.direction ?? `shorter`;\n  const space = opts.space ?? `oklch`;\n  const pieces = interpolateInit(colours, space);\n\n  let stepsBetween = 0;\n  if (typeof opts.stepsBetween === `number`) {\n    stepsBetween = opts.stepsBetween;\n    if (stepsBetween < 1) throw new Error(`Param 'stepsBetween' must be at least 1`);\n  } else if (typeof opts.stepsTotal === `number`) {\n    if (opts.stepsTotal <= colours.length) throw new Error(`Param 'stepsTotal' must be greater than number of provided colour stops (${ colours.length }) +1 per stop`);\n    const totalSteps = opts.stepsTotal - colours.length;\n    stepsBetween = Math.floor(totalSteps / pieces.length);\n  }\n\n  const steps = pieces.map((piece: Colour[]) => {\n    //const pieceSteps = HslSpace.createSteps(piece[ 0 ], piece[ 1 ], stepsBetween, direction, true);\n    const pieceSteps: Colour[] = createSteps(piece[ 0 ], piece[ 1 ], { steps: stepsBetween, space, direction, exclusive: true });\n\n    // Add end colour\n    pieceSteps.push(piece[ 1 ]);\n    return pieceSteps;\n  });\n\n  // Add very first colour\n  const firstPiece = pieces[ 0 ];\n  steps.unshift([ firstPiece[ 0 ] ]);\n  return steps.flat().map(c => toCssColour(c));\n}\n\nexport type CreateStepsOptions = Partial<{ space: ColourSpaces, steps: number, direction: `longer` | `shorter`, exclusive: boolean }>\nexport function createSteps<T extends CreateStepsOptions>(a: Colourish | string, b: Colourish, options: T):\n  T extends { space: `oklch` } ? OkLchScalar[] :\n  T extends { space: `srgb` } ? RgbScalar[] :\n  T extends { space: `hsl` } ? HslScalar[] : OkLchScalar[];\n\n\n\n/**\n * Creates discrete colour steps between two colours. \n * \n * Start and end colours are included (and counted as a step) unless `exclusive` is set to _true_\n * \n * ```js\n * // Array of five HslScalar \n * createSteps(`red`,`blue`, { steps: 5 });\n * ```\n * \n * Defaults to the oklch colour space, 5 steps and non-exclusive.\n * @param a Start colour\n * @param b End colour\n * @param options\n * @returns \n */\nexport function createSteps(a: Colourish | string, b: Colourish, options: CreateStepsOptions = {}): Colour[] {\n  const exclusive = options.exclusive ?? false;\n  const steps = options.steps ?? 5;\n  const space = options.space ?? `oklch`;\n  const direction = options.direction ?? `shorter`;\n\n  if (!exclusive && steps < 2) throw new Error(`Param 'steps' should be at least 2 when 'exclusive' is false`);\n  if (exclusive && steps < 1) throw new Error(`Param 'steps' should be at least 1 when 'exlusive' is true`);\n\n  const aa = convertScalar(a, space);\n  const bb = convertScalar(b, space);\n\n  // Create interpolator\n  let inter: ColourInterpolator<Colour> | undefined;\n  switch (space) {\n    case `hsl`:\n      inter = HslSpace.interpolator(aa as HslScalar, bb as HslScalar, direction);\n      break;\n    case `oklch`:\n      inter = OklchSpace.interpolator(aa as OkLchScalar, bb as OkLchScalar, direction);\n      break;\n    case `srgb`:\n      inter = SrgbSpace.interpolator(aa as RgbScalar, bb as RgbScalar);\n      break;\n    default:\n      throw new Error(`Colour space '${ space }' not supported for interpolation.`);\n  }\n  if (!inter) throw new Error(`Could not create interpolator for space: ${ space }`);\n\n  let stepBy = 0;\n  let startAt = 0;\n  let endAt = 1;\n  if (exclusive) {\n    stepBy = 1 / (steps + 1);\n    startAt = stepBy;\n    endAt = 1 - stepBy;\n  } else {\n    stepBy = 1 / (steps - 1);\n  }\n\n  const results: Colour[] = [];\n  for (let interpolateAmount = startAt; interpolateAmount <= endAt; interpolateAmount += stepBy) {\n    results.push(inter(interpolateAmount));\n  }\n\n  return results;\n}\n","export * from './conversion.js';\nexport * from './css-colours.js';\nexport * from './generate.js';\n\n//export * from './interpolate.js';\nexport * from './math.js';\nexport * from './interpolate.js';\nexport * as HslSpace from './hsl.js';\nexport * as OklchSpace from './oklch.js';\nexport * as SrgbSpace from './srgb.js';\n\nexport * from './types.js';","import Colorizr, * as C from \"colorizr\";\nimport { type Colour, type Colourish, type ColourSpaces, type Hsl, type HslAbsolute, type HslScalar, type OkLch, type OkLchAbsolute, type OkLchScalar, type Rgb, type Rgb8Bit, type RgbScalar } from \"./types.js\";\nimport * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport * as OkLchSpace from './oklch.js';\nimport { fromCssColour } from \"./css-colours.js\";\nimport { isHsl, isRgb, tryParseObjectToRgb, tryParseObjectToHsl, isColourish, isLch } from \"./guards.js\";\nimport { OklchSpace } from \"./index.js\";\n\nexport type ConvertDestinations = `hsl-scalar` | `hsl-absolute` | `oklch-scalar` | `oklch-absolute` | `srgb-8bit` | `srgb-scalar`;\n\nexport function convert<T extends ConvertDestinations>(colour: Colourish, destination: T):\n  T extends \"oklch-absolute\" ? OkLchAbsolute :\n  T extends \"oklch-scalar\" ? OkLchScalar :\n  T extends \"srgb-8bit\" ? Rgb8Bit :\n  T extends \"srgb-scalar\" ? RgbScalar :\n  T extends \"hsl-scalar\" ? HslScalar :\n  T extends \"hsl-absolute\" ? HslAbsolute : never\n\n/**\n * Converts an object or string representation of colour to ixfx's\n * structured colour.\n * Use {@link convertToString} if you want a CSS colour string instead.\n * @param colour \n * @param destination \n * @returns \n */\nexport function convert(colour: Colourish, destination: ConvertDestinations): Hsl | OkLch | Rgb {\n  if (destination === `hsl-scalar`) {\n    if (typeof colour === `string` || isHsl(colour) || isRgb(colour)) {\n      return HslSpace.toScalar(colour);\n    }\n  } else if (destination === `hsl-absolute`) {\n    if (typeof colour === `string` || isHsl(colour)) {\n      return HslSpace.toAbsolute(colour);\n    }\n  } else if (destination === `oklch-scalar`) {\n    if (typeof colour === `string` || isLch(colour)) {\n      return OkLchSpace.toScalar(colour);\n    }\n  } else if (destination === `oklch-absolute`) {\n    if (typeof colour === `string` || isLch(colour)) {\n      return OkLchSpace.toAbsolute(colour);\n    }\n  } else if (destination === `srgb-8bit`) {\n    if (typeof colour === `string` || isRgb(colour)) {\n      return SrgbSpace.to8bit(colour);\n    }\n  } else if (destination === `srgb-scalar`) {\n    if (typeof colour === `string` || isRgb(colour)) {\n      return SrgbSpace.toScalar(colour);\n    }\n  } else {\n    throw new Error(`Destination '${ destination }' not supported for input: ${ JSON.stringify(colour) }`);\n  }\n  return convert(toCssColour(colour), destination);\n}\n\n/**\n * Like {@link convert}, but result is a CSS colour string\n * @param colour \n * @param destination \n * @returns \n */\nexport function convertToString(colour: Colourish, destination: ConvertDestinations): string {\n  const c = convert(colour, destination);\n  return toCssColour(c);\n}\n\nexport function convertScalar<T extends ColourSpaces>(colour: Colourish, destination: T):\n  T extends \"oklch\" ? OkLchScalar :\n  T extends \"hsl\" ? HslScalar :\n  T extends \"srgb\" ? RgbScalar : never\n\nexport function convertScalar(colour: Colourish, destination: ColourSpaces): HslScalar | OkLchScalar | RgbScalar {\n  if (destination === `oklch`) return convert(colour, `oklch-scalar`);\n  if (destination === `srgb`) return convert(colour, `srgb-scalar`);\n  if (destination === `hsl`) return convert(colour, `hsl-scalar`);\n  throw new Error(`Unknown destination: '${ destination }'`);\n}\n\nexport const toCssColour = (colour: Colourish | object): string => {\n  if (typeof colour === `string`) return colour;\n\n  if (isHsl(colour)) {\n    return HslSpace.toCssString(colour);\n  }\n\n  if (isRgb(colour)) {\n    return SrgbSpace.toCssString(colour);\n  }\n\n  if (isLch(colour)) {\n    return OklchSpace.toCssString(colour);\n  }\n  const asRgb = tryParseObjectToRgb(colour);\n  if (asRgb) return SrgbSpace.toCssString(asRgb);\n\n  const asHsl = tryParseObjectToHsl(colour);\n  if (asHsl) return HslSpace.toCssString(asHsl);\n\n  throw new Error(`Unknown colour format: '${ JSON.stringify(colour) }'`);\n}\n\nexport const toLibraryColour = (colour: Colourish): Colorizr => {\n  const asCss = toCssColour(colour);\n  return new Colorizr(asCss);\n}\n\n// export const convertColourString = (colour: string, destination: 'hex' | 'hsl' | 'oklab' | 'oklch' | 'srgb' | `rgb`): string => {\n//   if (destination === `srgb`) destination = `rgb`;\n//   return C.convert(colour, destination);\n// }\n\nexport const guard = (colour: Colour) => {\n  switch (colour.space) {\n    case `hsl`:\n      HslSpace.guard(colour);\n      break;\n    case `srgb`:\n      SrgbSpace.guard(colour);\n      break;\n    default:\n      throw new Error(`Unknown colour space: '${ colour.space }'`);\n  }\n}\n\nexport const toColour = (colourish: any): Colour => {\n  if (!isColourish(colourish)) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n  let c: Colour | undefined;\n  if (typeof colourish === `string`) c = fromCssColour(colourish);\n  else c = colourish;\n  if (c === undefined) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n\n  guard(c);\n  return c;\n}\n\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const toStringFirst = (...colours: (Colourish | undefined)[]): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    try {\n      const c = toColour(colour);\n      return toCssColour(c);\n    } catch { /* empty */ }\n  }\n  return `rebeccapurple`;\n}\n\n\nexport function rgbToHsl(rgb: Rgb, scalarResult: true): HslScalar\nexport function rgbToHsl(rgb: Rgb, scalarResult: false): HslAbsolute\nexport function rgbToHsl(rgb: Rgb, scalarResult: boolean): Hsl {\n  // Needed because the Colorizr package has broken RGB to HSL\n  // Converts rgb { model: 'rgb', r: 40, g: 20, b: 60, alpha: undefined }\n  // to : { h: 270, s: 50, l: 0.06 }\n  // when it should be: { h: 270, s: 50, l: 40 }\n\n  // Source: https://www.jameslmilner.com/posts/converting-rgb-hex-hsl-colors/\n  let { r, g, b } = rgb;\n  const opacity = rgb.opacity ?? 1;\n  if (rgb.unit === `8bit`) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n  }\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n\n  let h = (max + min) / 2;\n  let s = h;\n  const l = h;\n\n  if (max === min) {\n    // Achromatic\n    if (scalarResult) {\n      return HslSpace.scalar(0, 0, 0, opacity);\n    } else {\n      return HslSpace.absolute(0, 0, 0, opacity);\n    }\n  }\n\n  const d = max - min;\n  s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n  switch (max) {\n    case r:\n      h = ((g - b) / d + 0) * 60;\n      break;\n    case g:\n      h = ((b - r) / d + 2) * 60;\n      break;\n    case b:\n      h = ((r - g) / d + 4) * 60;\n      break;\n  }\n\n  if (scalarResult) {\n    return HslSpace.scalar(h / 360, s, l, opacity)\n  } else {\n    return HslSpace.absolute(h, s * 100, l * 100, opacity);\n  }\n}","import type { StrokeOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: strokeStyle, strokeWidth, strokeDash, strokeLineCap\n * @param elem Element\n * @param opts\n */\nexport const applyStrokeOpts = (elem: SVGElement, opts: StrokeOpts) => {\n  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);\n  if (opts.strokeWidth) {\n    elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());\n  }\n  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);\n  if (opts.strokeLineCap) {\n    elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);\n  }\n};","\n//import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\n//import type { Point } from '../../geometry/point/PointType.js';\n//import type { Line } from '../../geometry/line/LineType.js';\n//import * as Lines from '../geometry/line/index.js';\nimport { Lines, Polar } from '@ixfx/geometry';\n//import * as Svg from './index.js';\nimport { toStringFirst as ColourStringFirst } from '../colour/conversion.js';\n//import { getCssVariable } from '../colour/index.js';\nimport type { CircleDrawingOpts, LineDrawingOpts, PathDrawingOpts, TextDrawingOpts, TextPathDrawingOpts } from './types.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { createEl, createOrResolve } from './create.js';\nimport { applyPathOpts } from './path.js';\nimport type { CirclePositioned } from '@ixfx/geometry/circle';\nimport type { Line } from '@ixfx/geometry/line';\nimport type { Point } from '@ixfx/geometry/point';\n//import type { PolarRay } from 'src/geometry/polar/Types.js';\n//import { toCartesian as polarRayToCartesian } from 'src/geometry/polar/Ray.js';\n//import {Palette} from \".\";\n\nconst numberOrPercentage = (v: number): string => {\n  if (v >= 0 && v <= 1) return `${ v * 100 }%`;\n  return v.toString();\n};\n\n/**\n * Creates and adds an SVG path element\n * @example\n * ```js\n * const paths = [\n *  `M300,200`,\n *  `a25,25 -30 0,1 50, -25 l 50,-25`\n * ]\n * const pathEl = path(paths, parentEl);\n * ```\n * @param svgOrArray Path syntax, or array of paths. Can be empty if path data will be added later\n * @param parent SVG parent element\n * @param opts Options Drawing options\n * @returns\n */\nexport const path = (\n  svgOrArray: string | readonly string[],\n  parent: SVGElement,\n  opts?: PathDrawingOpts,\n  queryOrExisting?: string | SVGPathElement\n): SVGPathElement => {\n  const elem = createOrResolve<SVGPathElement>(\n    parent,\n    `path`,\n    queryOrExisting\n  );\n  const svg =\n    typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`\\n`);\n\n  elem.setAttributeNS(null, `d`, svg);\n  parent.append(elem);\n  return pathUpdate(elem, opts);\n};\n\nexport const pathUpdate = (\n  elem: SVGPathElement,\n  opts?: PathDrawingOpts\n) => {\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n  return elem;\n};\n\n/**\n * Updates an existing `SVGCircleElement` with potentially updated circle data and drawing options\n * @param elem Element\n * @param circle Circle\n * @param opts Drawing options\n * @returns SVGCircleElement\n */\nexport const circleUpdate = (\n  elem: SVGCircleElement,\n  circle: CirclePositioned,\n  opts?: CircleDrawingOpts\n) => {\n  elem.setAttributeNS(null, `cx`, circle.x.toString());\n  elem.setAttributeNS(null, `cy`, circle.y.toString());\n  elem.setAttributeNS(null, `r`, circle.radius.toString());\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n\n  return elem;\n};\n\n/**\n * Creates or reuses a `SVGCircleElement`.\n *\n * To update an existing element, use `circleUpdate`\n * @param circle\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const circle = (\n  circle: CirclePositioned,\n  parent: SVGElement,\n  opts?: CircleDrawingOpts,\n  queryOrExisting?: string | SVGCircleElement\n): SVGCircleElement => {\n  const p = createOrResolve<SVGCircleElement>(\n    parent,\n    `circle`,\n    queryOrExisting\n  );\n  return circleUpdate(p, circle, opts);\n};\n\n/**\n * Creates or resuses a `SVGGElement` (group)\n *\n * To update an existing elemnet, use `groupUpdate`\n * @param children\n * @param parent\n * @param queryOrExisting\n * @returns\n */\nexport const group = (\n  children: readonly SVGElement[],\n  parent: SVGElement,\n  queryOrExisting?: string | SVGGElement\n): SVGGElement => {\n  const p = createOrResolve<SVGGElement>(parent, `g`, queryOrExisting);\n  return groupUpdate(p, children);\n};\n\nexport const groupUpdate = (\n  elem: SVGGElement,\n  children: readonly SVGElement[]\n) => {\n  for (const c of children) {\n    if (c.parentNode !== elem) {\n      elem.append(c);\n    }\n  }\n\n  return elem;\n};\n\n/**\n * Creates or reuses a SVGLineElement.\n *\n * @param line\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const line = (\n  line: Line,\n  parent: SVGElement,\n  opts?: LineDrawingOpts,\n  queryOrExisting?: string | SVGLineElement\n): SVGLineElement => {\n  const lineEl = createOrResolve<SVGLineElement>(\n    parent,\n    `line`,\n    queryOrExisting\n  );\n  return lineUpdate(lineEl, line, opts);\n};\n\n/**\n * Updates a SVGLineElement instance with potentially changed line and drawing data\n * @param lineEl\n * @param line\n * @param opts\n * @returns\n */\nexport const lineUpdate = (\n  lineEl: SVGLineElement,\n  line: Line,\n  opts?: LineDrawingOpts\n) => {\n  lineEl.setAttributeNS(null, `x1`, line.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, line.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, line.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, line.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n};\n\nexport const polarRayUpdate = (lineEl: SVGLineElement, ray: Polar.PolarRay, opts?: LineDrawingOpts) => {\n  const l = Polar.Ray.toCartesian(ray);\n  lineEl.setAttributeNS(null, `x1`, l.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, l.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, l.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, l.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n}\n\n/**\n * Updates an existing SVGTextPathElement instance with text and drawing options\n * @param el\n * @param text\n * @param opts\n * @returns\n */\nexport const textPathUpdate = (\n  el: SVGTextPathElement,\n  text?: string,\n  opts?: TextPathDrawingOpts\n) => {\n  if (opts?.method) el.setAttributeNS(null, `method`, opts.method);\n  if (opts?.side) el.setAttributeNS(null, `side`, opts.side);\n  if (opts?.spacing) el.setAttributeNS(null, `spacing`, opts.spacing);\n  if (opts?.startOffset) {\n    el.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));\n  }\n  if (opts?.textLength) {\n    el.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));\n  }\n\n  if (text) {\n    el.textContent = text;\n  }\n  if (opts) applyOpts(el, opts);\n  if (opts) applyStrokeOpts(el, opts);\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextPathElement.\n * @param pathReference\n * @param text\n * @param parent\n * @param opts\n * @param textQueryOrExisting\n * @param pathQueryOrExisting\n * @returns\n */\nexport const textPath = (\n  pathReference: string,\n  text: string,\n  parent: SVGElement,\n  opts?: TextPathDrawingOpts,\n  textQueryOrExisting?: string | SVGTextElement,\n  pathQueryOrExisting?: string | SVGTextPathElement\n): SVGTextPathElement => {\n  const textEl = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    textQueryOrExisting, `-text`\n  );\n  // Update text properties, but don't pass in position or text\n  textUpdate(textEl, undefined, undefined, opts);\n\n  const p = createOrResolve<SVGTextPathElement>(\n    textEl,\n    `textPath`,\n    pathQueryOrExisting\n  );\n  p.setAttributeNS(null, `href`, pathReference);\n  return textPathUpdate(p, text, opts);\n};\n\n/**\n * Updates an existing SVGTextElement instance with position, text and drawing options\n * @param el\n * @param pos\n * @param text\n * @param opts\n * @returns\n */\nexport const textUpdate = (\n  el: SVGTextElement,\n  pos?: Point,\n  text?: string,\n  opts?: TextDrawingOpts\n) => {\n  if (pos) {\n    el.setAttributeNS(null, `x`, pos.x.toString());\n    el.setAttributeNS(null, `y`, pos.y.toString());\n  }\n  if (text) {\n    el.textContent = text;\n  }\n\n  if (opts) {\n    applyOpts(el, opts);\n    if (opts) applyStrokeOpts(el, opts);\n\n    if (opts.anchor) el.setAttributeNS(null, `text-anchor`, opts.anchor);\n    if (opts.align) el.setAttributeNS(null, `alignment-baseline`, opts.align);\n\n    const userSelect = opts.userSelect ?? true;\n\n    if (!userSelect) {\n      el.style.userSelect = `none`;\n    }\n  }\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextElement\n * @param pos Position of text\n * @param text Text\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const text = (\n  text: string,\n  parent: SVGElement,\n  pos?: Point,\n  opts?: TextDrawingOpts,\n  queryOrExisting?: string | SVGTextElement\n): SVGTextElement => {\n  const p = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    queryOrExisting\n  );\n  return textUpdate(p, pos, text, opts);\n};\n\n/**\n * Creates a square grid based at a center point, with cells having `spacing` height and width.\n *\n * It fits in as many cells as it can within `width` and `height`.\n *\n * Returns a SVG group, consisting of horizontal and vertical lines\n * @param parent Parent element\n * @param center Center point of grid\n * @param spacing Width/height of cells\n * @param width How wide grid should be\n * @param height How high grid should be\n * @param opts\n */\nexport const grid = (\n  parent: SVGElement,\n  center: Point,\n  spacing: number,\n  width: number,\n  height: number,\n  opts: LineDrawingOpts = {}\n) => {\n  if (!opts.strokeStyle) {\n    opts = { ...opts, strokeStyle: ColourStringFirst(`bg-dim`, `silver`) };\n  }\n  if (!opts.strokeWidth) opts = { ...opts, strokeWidth: 1 };\n\n  const g = createEl<SVGGElement>(`g`);\n  applyOpts(g, opts);\n  applyPathOpts(g, opts);\n  applyStrokeOpts(g, opts);\n\n  // Horizontals\n  let y = 0;\n  while (y < height) {\n    const horiz = Lines.fromNumbers(0, y, width, y);\n    line(horiz, g);\n    y += spacing;\n  }\n\n  // Verticals\n  let x = 0;\n  while (x < width) {\n    const vert = Lines.fromNumbers(x, 0, x, height);\n    line(vert, g);\n    x += spacing;\n  }\n  parent.append(g);\n  return g;\n};\n","\nimport { PointsTracker } from '@ixfx/geometry/point';\nimport * as Svg from './svg/index.js';\nimport { ElementSizer, resolveEl } from '@ixfx/dom';\nexport type Opts = {\n  readonly touchRadius?: number;\n  readonly mouseRadius?: number;\n  readonly trace?: boolean;\n  readonly hue?: number;\n};\n\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery Element to monitor\n * @param options Options\n */\nexport const pointerVisualise = (\n  elOrQuery: HTMLElement | string,\n  options: Opts = {}\n) => {\n  const touchRadius = options.touchRadius ?? 45;\n  const mouseRadius = options.touchRadius ?? 20;\n  const trace = options.trace ?? false;\n  const hue = options.hue ?? 100;\n\n  const startFillStyle = `hsla(${ hue }, 100%, 10%, 10%)`;\n  let currentHue = hue;\n\n  const el = resolveEl(elOrQuery);\n  const tracker = new PointsTracker({\n    storeIntermediate: trace,\n  });\n\n\n  const svg = document.createElementNS(\n    `http://www.w3.org/2000/svg`,\n    `svg`\n  ) as any as SVGElement & HTMLElement;\n  svg.id = `pointerVis`;\n  svg.style.zIndex = `-1000`;\n  svg.style.position = `fixed`;\n  svg.style.top = `0`;\n  svg.style.left = `0`;\n  svg.style.width = `100%`;\n  svg.style.height = `100%`;\n  svg.style.boxSizing = `border-box`;\n  svg.style.border = `3px solid red`;\n  svg.style.pointerEvents = `none`;\n  svg.style.touchAction = `none`;\n\n  // const er = new ElementSizer(svg, {\n  //   containerEl:document.body,\n  //   stretch:`both`,\n  //   onSetSize(size) {\n  //     svg.setAttribute(`width`, size.width.toString());\n  //     svg.setAttribute(`height`, size.height.toString());\n  //   },\n  // })\n  const er = ElementSizer.svgViewport(svg);\n  //fullSizeElement(svg);\n  let pointerCount = 0;\n\n  const lostPointer = (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n\n    tracker.delete(id);\n    currentHue = hue;\n    svg.querySelector(`#pv-start-${ id }`)?.remove();\n\n    for (let index = 0; index < pointerCount + 10; index++) {\n      svg.querySelector(`#pv-progress-${ id }-${ index }`)?.remove();\n    }\n    pointerCount = 0;\n  };\n\n  const trackPointer = async (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    const pt = { x: event.x, y: event.y };\n    const type = event.pointerType;\n    if (event.type === `pointermove` && !tracker.has(id)) {\n      return;\n    }\n    const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n\n    if (info.values.length === 1) {\n      const el = Svg.Elements.circle(\n        {\n          ...info.values[ 0 ],\n          radius: type === `touch` ? touchRadius : mouseRadius,\n        },\n        svg,\n        {\n          fillStyle: startFillStyle,\n        },\n        `#pv-start-${ id }`\n      );\n      el.style.pointerEvents = `none`;\n      el.style.touchAction = `none`;\n    }\n\n    const fillStyle = `hsla(${ currentHue }, 100%, 50%, 50%)`;\n\n    const el2 = Svg.Elements.circle(\n      { ...pt, radius: type === `touch` ? touchRadius : mouseRadius },\n      svg,\n      {\n        fillStyle,\n      },\n      `#pv-progress-${ id }-${ info.values.length }`\n    );\n    el2.style.pointerEvents = `none`;\n    el2.style.touchAction = `none`;\n    currentHue += 1;\n    pointerCount = info.values.length;\n  };\n\n  document.body.append(svg);\n\n\n  el.addEventListener(`pointerdown`, trackPointer);\n\n  el.addEventListener(`pointermove`, trackPointer);\n  el.addEventListener(`pointerup`, lostPointer);\n  el.addEventListener(`pointerleave`, lostPointer);\n  el.addEventListener(`contextmenu`, (event) => {\n    event.preventDefault();\n  });\n};\n","/**\n * Manage a set of named colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type NamedColourPalette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: ReadonlyArray<string>): NamedColourPalette =>\n  new NamedColourPaletteImpl(fallbacks);\n\nclass NamedColourPaletteImpl {\n  readonly #store: Map<string, string> = new Map();\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: ReadonlyArray<string>;\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: ReadonlyArray<string>) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const variableName = `--` + key;\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(variableName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import { continuously } from '@ixfx/core';\nimport { delayLoop } from '@ixfx/flow';\n\nexport type Capturer = {\n  start(): void;\n  cancel(): void;\n  readonly canvasEl: HTMLCanvasElement;\n};\n\nexport type ManualCapturer = {\n  capture(): ImageData;\n  readonly canvasEl: HTMLCanvasElement;\n  dispose(): void;\n};\n\nexport type CaptureOpts = {\n  /**\n   * Delay between reading frames.\n   * Default: 0, reading as fast as possible\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * Whether to show the created capture canvas.\n   * Default: false\n   */\n  readonly showCanvas?: boolean;\n  readonly workerScript?: string;\n  readonly onFrame?: (pixels: ImageData) => void;\n};\n\nexport type ManualCaptureOpts = {\n  /**\n   * If true, the intermediate canvas is shown\n   * The intermediate canvas is where captures from the source are put in order\n   * to get the ImageData\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * If specified, this is the canvas captured to\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Options for frames generator\n */\nexport type FramesOpts = {\n  /**\n   * Max frame rate (millis per frame), or 0 for animation speed\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * False by default, created canvas will be hidden\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If provided, this canvas will be used as the buffer rather than creating one.\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import { Video } from '@ixfx/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\n\nexport async function* frames(\n  sourceVideoEl: HTMLVideoElement,\n  opts: FramesOpts = {}\n): AsyncIterable<ImageData> {\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n\n  const showCanvas = opts.showCanvas ?? false;\n  let canvasEl = opts.canvasEl;\n  let w, h;\n  w = h = 0;\n\n  // Create & setup canvas\n  if (canvasEl === undefined) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-frames`);\n    if (!showCanvas) {\n      canvasEl.style.display = `none`;\n    }\n    document.body.appendChild(canvasEl);\n  }\n\n  // Update size of canvas based on video\n  const updateSize = () => {\n    if (canvasEl === undefined) return;\n    w = sourceVideoEl.videoWidth;\n    h = sourceVideoEl.videoHeight;\n    canvasEl.width = w;\n    canvasEl.height = h;\n  };\n\n  let c: CanvasRenderingContext2D | null = null;\n\n  const looper = delayLoop(maxIntervalMs);\n  for await (const _ of looper) {\n    // If we don't yet have the size of video, get it\n    if (w === 0 || h === 0) updateSize();\n\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n    if (w === 0 || h === 0) continue;\n\n    // Draw current frame from video element to hidden canvas\n    c ??= canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    // Get pixels\n    const pixels = c.getImageData(0, 0, w, h);\n    yield pixels;\n  }\n}\n\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: CaptureOpts = {}\n): Capturer => {\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  const showCanvas = opts.showCanvas ?? false;\n  const onFrame = opts.onFrame;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n  canvasEl.classList.add(`ixfx-capture`);\n\n  if (!showCanvas) {\n    canvasEl.style.display = `none`;\n  }\n  canvasEl.width = w;\n  canvasEl.height = h;\n  let c: CanvasRenderingContext2D | null = null;\n  let worker: Worker | undefined;\n  if (opts.workerScript) {\n    worker = new Worker(opts.workerScript);\n  }\n\n  // Should we get image data?\n  const getPixels = worker || onFrame;\n  if (!getPixels && !showCanvas) {\n    console.warn(\n      `Video will be captured to hidden element without any processing. Is this what you want?`\n    );\n  }\n\n  const loop = continuously(() => {\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n    let pixels: ImageData | undefined;\n\n    if (getPixels) {\n      // ImageData necessary\n      pixels = c.getImageData(0, 0, w, h);\n    }\n\n    if (worker) {\n      // Send to worker\n      worker.postMessage(\n        {\n          pixels: pixels!.data.buffer,\n          width: w,\n          height: h,\n          channels: 4,\n        },\n        [ pixels!.data.buffer ]\n      );\n    }\n    if (onFrame) {\n      // Send to callback\n      try {\n        onFrame(pixels!);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, maxIntervalMs);\n\n  return {\n    start: () => { loop.start(); },\n    cancel: () => { loop.cancel(); },\n    canvasEl,\n  };\n};\n\nexport const manualCapture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: ManualCaptureOpts = {}\n): ManualCapturer => {\n  const showCanvas = opts.showCanvas ?? false;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas if necessary\n  const definedCanvasEl = opts.canvasEl !== undefined;\n  let canvasEl = opts.canvasEl;\n  if (!canvasEl) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-capture`);\n    document.body.append(canvasEl);\n    if (!showCanvas) canvasEl.style.display = `none`;\n  }\n\n  canvasEl.width = w;\n  canvasEl.height = h;\n\n  const capture = (): ImageData => {\n    let c: CanvasRenderingContext2D | undefined | null;\n\n    // Draw current frame from video element to canvas\n    if (!c) c = canvasEl.getContext(`2d`, { willReadFrequently: true });\n    if (!c) throw new Error(`Could not create graphics context`);\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    const pixels = c.getImageData(0, 0, w, h);\n\n    (pixels as any).currentTime = sourceVideoEl.currentTime;\n\n    if (opts.postCaptureDraw) opts.postCaptureDraw(c, w, h);\n    return pixels;\n  };\n\n  const dispose = (): void => {\n    if (definedCanvasEl) return; // we didn't create it\n    try {\n      canvasEl.remove();\n    } catch (_) {\n      // no-op\n    }\n  };\n\n  const c: ManualCapturer = {\n    canvasEl,\n    capture,\n    dispose,\n  };\n  return c;\n};\n","export * from './canvas-helper.js';\nexport * from './pointer-visualise.js';\n// import * as Svg from './svg/index.js';\n// export * as Svg from './svg/index.js';\n\nimport * as NamedColourPalette from './named-colour-palette.js';\n\n\nimport * as Colour from './colour/index.js';\n\nexport * as Colour from './colour/index.js';\n\n//export type * from './types.js';\n\n//import * as SceneGraph from './SceneGraph.js';\nimport * as Video from './video.js';\n\n//export * from '../../dom/src/CanvasRegion.js';\n\nexport * as Drawing from './drawing.js';\n\n/**\n * Wraps [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData) as an ixfx {@link @ixfx/geometry.Grid} type.\n * This is useful because it's otherwise a one-dimensional array listing each rgba in turn.\n */\nexport * as ImageDataGrid from './image-data-grid.js';\n//export * as BipolarView from '../../dom/src/plot/BipolarView.js';\n//export * as NamedColourPalette from './named-colour-palette.js';\n\n//export * as Plot2 from './Plot2.js';\n\n//export * as Plot from './plot/index.js';\n//export * as SceneGraph from './SceneGraph.js';\n//export * from './ScaleCanvas.js';\n//export * from './plot/CartesianCanvasPlot.js';\n\n\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from '@ixfx/visual.js'\n * ```\n */\nexport * as Video from './video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        NamedColourPalette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n"],"mappings":"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"}