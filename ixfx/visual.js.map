{"version":3,"file":"visual.js","names":["canvasElementContextOrQuery: CanvasContextQuery","makeHelper","ctxOrCanvasEl: CanvasContextQuery","canvasBounds?: Rects.Rect","pathsToDraw: Paths.Path[] | readonly Paths.Path[]","opts?: DrawingOpts","lineToDraw: Lines.Line | Lines.Line[]","line","rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts?: RectOpts","bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier","pointsToDraw: Points.Point[]","opts?: DrawingOpts & Partial<ConnectedPointsOptions>","dotPosition: Points.Point | Points.Point[]","opts?: DotOpts","circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[]","opts: DrawingOpts","circle","arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[]","lines: string[]","opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }","applyOpts","ctx: CanvasRenderingContext2D","arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[]","arc: Arcs.ArcPositioned","arc","arcsArray: Arcs.ArcPositioned[]","strokeStyle: string | CanvasGradient | CanvasPattern | undefined","fillStyle: string | CanvasGradient | CanvasPattern | undefined","lineWidth: number | undefined","lineJoin: CanvasLineJoin | undefined","lineCap: CanvasLineCap | undefined","stk?: IStackImmutable<StackOp>","points: readonly Points.Point[]","circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[]","c: Circles.CirclePositioned","ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[]","ellipse: Ellipses.EllipsePositioned","ellipse","pathsToDraw: readonly Paths.Path[] | Paths.Path","opts: { readonly strokeStyle?: string; readonly debug?: boolean }","path: Paths.Path","path","pts: readonly Points.Point[]","opts: Partial<ConnectedPointsOptions>","opts: { readonly fillStyle?: string }","labels?: readonly string[]","point: Points.Point","canvasEl: HTMLCanvasElement","pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned","pos","bezierToDraw: Beziers.CubicBezier","bezierToDraw: Beziers.QuadraticBezier","toDraw: Lines.Line | readonly Lines.Line[]","opts: LineOpts & DrawingOpts","d: Lines.Line","toDraw: Triangles.Triangle | readonly Triangles.Triangle[]","opts: DrawingOpts & { readonly filled?: boolean }","t: Triangles.Triangle","toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts: RectOpts","d: Rects.RectPositioned | Rects.Rect","text?: string | null","widthMultiple?: number","rect","text","lines: readonly string[]","opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }","text: readonly string[] | string","opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }","v: any","a: number","b: number","rgb: RGB","c: number","value: number","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","changeLightness","value: Hsl","amount: Partial<{ pdelta: number, delta: number, fixed: number }>","hsl: Hsl","value: number","property: `l` | `h` | `s`","fromHexString","hexString: string","options: ParsingOptions<Hsl>","fromLibrary","fromCss","value: string","options: Partial<ParsingOptions<Hsl>>","rgbToLibraryHsl","toScalar","toAbsolute","toHexString","hsl: C.HSL","parsingOptions: ParsingOptions<T>","absolute","hslOrString: Hsl | Rgb | string","guard","generateScalar","absoluteHslOrVariable: string | number | Angle","lightness","hslOrString: Rgb | Hsl | string","interpolator","a: Hsl | string","b: Hsl | string","direction: `longer` | `shorter`","amount: number","hsl: HslScalar","hsl: HslAbsolute","v: string","pos: number","vf","hsl: Hsl | string","guard","lch: OkLch","fromLibrary","lch: C.LCH","parsingOptions: ParsingOptions<OkLch>","scalar","fromHexString","hexString: string","options: ParsingOptions<OkLch>","oklchTransparent: OkLchAbsolute","fromCss","value: string","rgbTo8bit","lch","Colorizr","lchOrString: OkLch | string","toScalar","toLibrary","toCssString","toHexString","absoluteHslOrVariable: string | number | Angle","lightness","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","interpolator","a: OkLch | string","b: OkLch | string","direction: `longer` | `shorter`","amount: number","lch: OkLchScalar","l: number","c: number","h: number","lch: OkLchAbsolute","colour: string","fromCss","fallback?: string","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","hexString: string","scalar","srgbTansparent: Rgb8Bit","value: string","options: ParsingOptions<Rgb>","hslToLibraryRgb","rgb: Rgb","toCssString","guard","rgb: C.RGB","parsingOptions: ParsingOptions<Rgb>","rgbOrString: Rgb | string","rgbOrString: Rgb | Hsl | string","amount: Partial<{ pdelta: number, delta: number, fixed: number }>","Colorizr","rgb: Rgb8Bit","rgb: RgbScalar","v: string","pos: number","interpolator","colourA: Rgb | string","colourB: Rgb | string","amount: number","rgb: Rgb | string","grid","image: ImageData","fn: Grids.GridCellAccessor<Rgb8Bit>","cell: Grids.GridCell","fn: Grids.GridCellSetter<Rgb>","value: Rgb","col: Rgb8Bit[]","domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>","opts: Partial<CanvasHelperOptions>","#scaler","scaler","#scalerSize","#init","#logicalSize","reason?: string","#disposed","#resizer","#ctx","#drawHelper","#getContext","logicalSize: Rect","#handleEvents","resizerOptions: ElementSizerOptions<HTMLCanvasElement>","#onResizeDone","size: Rect","event: PointerEvent","colour?: string","#viewport","grid","canvasElementOrQuery: HTMLCanvasElement | string","sizeBasis: `min` | `max`","#canvasEl","#sizeBasis","#pixelScaling","#sizeScaler","#createSizeScaler","#logicalSize","size: Rect","#ctx","region: CanvasRegion","#regions","pt: Point","kind: `independent`","source: `screen` | `source`","kind: `independent` | `skip`","rect: Rect | RectPositioned","rect","spec: CanvasRegionSpec","#add","compute: ((source: CanvasSource) => RectPositioned)","source: CanvasSource","_source: CanvasSource","regionCompute: (parent: CanvasSource) => RectPositioned","#regionCompute","#r","regionRel: Point","scaleBy: `both`","p: Point","relativePoints: Point[]","strokeStyle: string","points: Point[]","text: string","relPos: Point","font: string","baseline: CanvasTextBaseline","align: CanvasTextAlign","text","point: Point","relativeCircles: CirclePositioned[]","fillStyle: string","c","circle","source: `screen`","clamped: boolean","value: RectPositioned","elem: SVGElement","opts: DrawingOpts","svg: SVGElement","bounds: Rect","type: string","id?: string","parent: SVGElement","queryOrExisting?: string | V","suffix?: string","existing:SVGElement|HTMLElement|null","index: number","lightness","hslScalar","rand: RandomSource","multiplyOpacity","colourish: Colourish","amount: number","fn: (scalarOpacity: number) => number","result: Colour | undefined","opacity: number","colours: Colourish[]","destination: ColourSpaces","c","colourA: Colourish","colourB: Colourish","options: Partial<ColourInterpolationOpts>","inter: ColourInterpolator<Colour> | undefined","convert","amount: number","opts: Partial<ColourStepOpts>","piece: Colour[]","pieceSteps: Colour[]","a: Colourish | string","b: Colourish","options: CreateStepsOptions","results: Colour[]","convert","colour: Colourish","destination: ConvertDestinations","destination: ColourSpaces","colour: Colourish | object","Colorizr","guard","colour: Colour","colourish: any","c: Colour | undefined","rgb: Rgb","scalarResult: boolean","elem: SVGElement","opts: StrokeOpts","id: string","opts: MarkerOpts","childCreator?: () => SVGElement","elem: SVGElement | null","_context: DrawingOpts","elem: SVGElement","opts: PathDrawingOpts","v: number","svgOrArray: string | readonly string[]","parent: SVGElement","opts?: PathDrawingOpts","queryOrExisting?: string | SVGPathElement","elem: SVGPathElement","elem: SVGCircleElement","circle: CirclePositioned","opts?: CircleDrawingOpts","circle","queryOrExisting?: string | SVGCircleElement","children: readonly SVGElement[]","queryOrExisting?: string | SVGGElement","elem: SVGGElement","line: Line","opts?: LineDrawingOpts","queryOrExisting?: string | SVGLineElement","line","lineEl: SVGLineElement","ray: Polar.PolarRay","el: SVGTextPathElement","text?: string","opts?: TextPathDrawingOpts","text","pathReference: string","text: string","textQueryOrExisting?: string | SVGTextElement","pathQueryOrExisting?: string | SVGTextPathElement","el: SVGTextElement","pos?: Point","opts?: TextDrawingOpts","queryOrExisting?: string | SVGTextElement","center: Point","spacing: number","width: number","height: number","opts: LineDrawingOpts","ColourStringFirst","el: SVGLineElement","origin: Point","parent: SVGElement","queryOrExisting: string | V","parent: SVGElement","parentOpts?: DrawingOpts & StrokeOpts","o: SvgHelper","queryOrExisting: string | SVGElement","text: string","pos: Point","opts?: TextDrawingOpts","queryOrExisting?: string | SVGTextElement","text","pathReference: string","textQueryOrExisting?: string | SVGTextElement","pathQueryOrExisting?: string | SVGTextPathElement","line: Line","opts?: LineDrawingOpts","queryOrExisting?: string | SVGLineElement","line","circle: CirclePositioned","opts?: CircleDrawingOpts","queryOrExisting?: string | SVGCircleElement","circle","svgString: string | readonly string[]","opts?: PathDrawingOpts","queryOrExisting?: string | SVGPathElement","center: Point","spacing: number","width: number","height: number","center","selectors: string","elOrQuery: HTMLElement | string","options: Opts","event: PointerEvent","el","kernel: Kernel<number>","scalar: number","rows","copy: number[][]","scalar","cell: Grids.GridCell","kernel: Kernel2dArray<TKernel>","source: Grids.GridReadable<TCell>","reduce: KernelReduce<TCell, TKernel>","valuesAtKernelPos: CellValueScalar<TCell, TKernel>[]","kernelValue: TKernel | undefined","sourceValue: TCell | undefined","image: ImageData","kernel: Kernel<TKernel>","visitor: Iterable<Grids.GridCell>","origin?: Grids.GridCell","kernel: Kernel<T>","offsets: Kernel2dArray<T>","v: Grids.GridCellAndValue<T>","rgbReducer: KernelReduce<Rgb8Bit, number>","values: CellValueScalar<Rgb8Bit, number>[]","result: Rgb8Bit","fallbacks?: ReadonlyArray<string>","#store","#aliases","#elementBase","el: Element","key: string","colour: string","from: string","to: string","fallback?: string","fromCss","#lastFallback","sourceVideoEl: HTMLVideoElement","opts: FramesOpts","c: CanvasRenderingContext2D | null","opts: CaptureOpts","worker: Worker | undefined","pixels: ImageData | undefined","opts: ManualCaptureOpts","capture","c: CanvasRenderingContext2D | undefined | null","c","c: ManualCapturer","el: HTMLElement","name: string","defaultValue: number","elementQuery: string","options: BipolarViewOptions","lastValues: IQueueImmutable<CirclePositioned> | undefined","v: number","renderBackground: Render","ctx","width","height","x: number","y: number","mm: Point[]","minMax: PointMinMax","point: Point","mm: PointMinMax","increments: number","major: number","xValues: AxisMark[]","yValues: AxisMark[]","#data","#meta","series: string","data: TValue[]","meta: TSeriesMeta","value: TValue","insertOptions: InsertOptions","options: RecursivePartial<Cart.CartesianPlotOptions>","cr: CanvasRegion","data: DataSet<Cart.PlotPoint, SeriesMeta>","#data","#canvasRegion","#lastDataChange","#visualClear","#rangeMode","#valueStyle","#connectStyle","#visualPadding","#axisStyle","#textStyle","#grid","#currentRange","#createRange","pt: Point","data: Point","elementToPosition: HTMLElement | string","by: `middle` | `top-left`","relativeToQuery?: HTMLElement | string","#rangeManual","dataPoint: Point","offset","dataValue: Point","point: Point","_source: `screen`","valueA: Point","valueB: Point","#useGrid","#drawAxes","#drawSeries","line","line: Line","colour: string","width: number","#valueLineToCanvasSpace","#drawLineCanvasSpace","series: string","meta: Partial<SeriesMeta>","yPoints: Point[]","xPoints: Point[]","p: Cart.AxisMark","vertical: boolean","#drawGridline","#drawWhisker","#drawXAxisValues","#drawYAxisValues","name: string","series: Cart.PlotPoint[]","meta: SeriesMeta","#drawConnected","#drawDot","dots: Cart.PlotPoint[]","dot","ColourToString","originalDot: Cart.PlotPoint","fallbackColour: string","fallbackRadius: number"],"sources":["../../visual/src/drawing.ts","../../visual/src/colour/guards.ts","../../visual/src/colour/utility.ts","../../visual/src/colour/hsl.ts","../../visual/src/colour/oklch.ts","../../visual/src/colour/css-colours.ts","../../visual/src/colour/srgb.ts","../../visual/src/image-data-grid.ts","../../visual/src/canvas-helper.ts","../../visual/src/pi-pi.ts","../../visual/src/canvas-region.ts","../../visual/src/svg/apply.ts","../../visual/src/svg/bounds.ts","../../visual/src/svg/create.ts","../../visual/src/colour/generate.ts","../../visual/src/colour/math.ts","../../visual/src/colour/interpolate.ts","../../visual/src/colour/index.ts","../../visual/src/colour/conversion.ts","../../visual/src/svg/stroke.ts","../../visual/src/svg/markers.ts","../../visual/src/svg/path.ts","../../visual/src/svg/elements.ts","../../visual/src/svg/geometry.ts","../../visual/src/svg/remove.ts","../../visual/src/svg/helper.ts","../../visual/src/svg/index.ts","../../visual/src/pointer-visualise.ts","../../visual/src/convolve-2d.ts","../../visual/src/named-colour-palette.ts","../../visual/src/video.ts","../../visual/src/plot/bipolar-view.ts","../../visual/src/plot/cartesian.ts","../../visual/src/plot/DataSet.ts","../../visual/src/plot/cartesian-canvas-plot.ts","../../visual/src/plot/index.ts","../../visual/src/index.ts"],"sourcesContent":["import { arrayTest, resultThrow } from '@ixfx/guards';\nimport { Colour } from '@ixfx/visual';\nimport { resolveEl } from '@ixfx/dom';\n//import type { IStackImmutable } from '@ixfx/collections';\nimport { StackImmutable, type IStackImmutable } from '@ixfx/collections/stack';\nimport { Beziers, Lines, Points, Rects, Triangles, type Arcs, type Circles, type Ellipses, type Paths } from '@ixfx/geometry';\nimport { quantiseEvery } from '@ixfx/numbers';\n\n// import type { Point } from '../geometry/point/PointType.js';\n// import type { Line } from '../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../geometry/circle/CircleType.js';\n// import type { Rect, RectPositioned } from '../geometry/rect/index.js';\n// import type { Path } from '../geometry/path/PathType.js';\n// import type { Triangle } from '../geometry/triangle/TriangleType.js';\n\n// import { Empty as RectsEmpty } from '../geometry/rect/Empty.js';\n// import { corners as RectsCorners } from '../geometry/rect/Corners.js';\n// import { isLine } from '../geometry/line/Guard.js';\n// import { quantiseEvery } from '../numbers/Quantise.js';\n\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElementContextOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\n\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rects.Rect\n) => {\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    ctx,\n    paths(pathsToDraw: Paths.Path[] | readonly Paths.Path[], opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Lines.Line | Lines.Line[], opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n      opts?: RectOpts\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Points.Point[],\n      opts?: DrawingOpts & Partial<ConnectedPointsOptions>\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Points.Point[], opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Points.Point | Points.Point[],\n      opts?: DotOpts\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[],\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[],\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: string[],\n      opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: readonly StackOp[]\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray: Arcs.ArcPositioned[] = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: readonly StackOp[]): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  stk ??= new StackImmutable<StackOp>();\n\n  const push = (...ops: StackOp[]): DrawingStack => {\n    stk ??= new StackImmutable<StackOp>();\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: readonly Points.Point[],\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: Circles.CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c as Circles.CirclePositioned);\n  } else {\n    draw(circlesToDraw as Circles.CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: readonly Paths.Path[] | Paths.Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Paths.Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (Lines.isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Paths.Path);\n  }\n};\n\nexport type ConnectedPointsOptions = {\n  readonly lineWidth: number\n  readonly loop: boolean\n  readonly fillStyle: string\n  readonly strokeStyle: string\n}\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: Partial<ConnectedPointsOptions> = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n  resultThrow(arrayTest(pts, `pts`));\n\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: { readonly fillStyle?: string } = {},\n  labels?: readonly string[]\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Points.Point\n): Points.Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\nexport type DotOpts = DrawingOpts & {\n  readonly radius?: number;\n  readonly stroke?: boolean;\n  readonly filled?: boolean;\n  readonly strokeWidth?: number;\n}\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned,\n  opts?: DotOpts\n) => {\n  opts ??= {};\n  const radius = opts.radius ?? 10;\n  const positions = Array.isArray(pos) ? pos : [ pos ];\n  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== undefined;\n  let filled = opts.filled ? opts.filled : opts.fillStyle !== undefined;\n  if (!stroke && !filled) filled = true;\n\n  applyOpts(ctx, opts);\n\n  for (const pos of positions) {\n    ctx.beginPath();\n    if (`radius` in pos) {\n      ctx.arc(pos.x, pos.y, pos.radius, 0, 2 * Math.PI);\n    } else {\n      ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\n    }\n    if (filled) {\n      ctx.fill();\n    }\n    if (stroke) {\n      ctx.stroke();\n    }\n  }\n\n  // const makePath = () => {\n  //   ctx.beginPath();\n\n  //   // x&y for arc is the center of circle\n  //   if (Array.isArray(pos)) {\n  //     for (const p of pos) {\n  //       ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //     }\n  //   } else {\n  //     const p = pos as Point;\n  //     ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //   }\n  // }\n  // makePath();\n  // if (opts.filled || !opts.stroke) {\n  //   ctx.fill();\n  // }\n  // if (opts.stroke) {\n  //   if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n  //   //makePath();\n  //   ctx.stroke();\n  // }\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Lines.Line | readonly Lines.Line[],\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Lines.Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t as Lines.Line);\n  } else {\n    draw(toDraw as Lines.Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangles.Triangle | readonly Triangles.Triangle[],\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangles.Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangles.Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n\nexport type RectOpts = DrawingOpts & Readonly<Partial<{\n  stroke: boolean\n  filled: boolean\n  strokeWidth: number\n  /**\n   * If true, diagonals are drawn\n   */\n  crossed: boolean\n}>>\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n  opts: RectOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroke = opts.stroke ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: Rects.RectPositioned | Rects.Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroke) {\n      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n      //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n      ctx.strokeRect(x, y, d.width, d.height);\n    }\n    if (opts.crossed) {\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(d.width, d.height);\n      ctx.stroke();\n      ctx.moveTo(0, d.height);\n      ctx.lineTo(d.width, 0);\n      ctx.stroke();\n    }\n    if (opts.debug) {\n      pointLabels(ctx, Rects.corners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Rects.RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rects.Rect => {\n  if (text === undefined || text === null || text.length === 0) return Rects.Empty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? quantiseEvery(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: readonly string[],\n  opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n  const align = opts.align ?? `top`;\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  if (align === `top`) {\n    ctx.textBaseline = `top`;\n  } else {\n    ctx.textBaseline = `middle`;\n  }\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: readonly string[] | string,\n  opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import type { Hsl, Rgb, OkLch, Colourish } from \"./types.js\";\n\nexport const isHsl = (v: any): v is Hsl => {\n  if (typeof v !== `object`) return false;\n  if (!(`h` in v)) return false;\n  if (!(`s` in v)) return false;\n  if (!(`l` in v)) return false;\n  if (!(`unit` in v)) return false;\n  if (!(`space` in v)) return false;\n  if (v.space !== `hsl`) return false;\n  return true;\n}\n\nexport const isRgb = (v: any): v is Rgb => {\n  if (typeof v !== `object`) return false;\n  if (!(`r` in v)) return false;\n  if (!(`g` in v)) return false;\n  if (!(`b` in v)) return false;\n  if (!(`space` in v)) return false;\n  if (!(`unit` in v)) return false;\n  if (v.space === `srgb`) return true;\n  return false;\n}\n\n\n/**\n * If the input object has r,g&b properties, it will return a fully-\n * formed Rgb type with `unit` and `space` properties.\n * \n * If it lacks these basic three properties or they are out of range,\n *  _undefined_ is returned.\n * \n * If RGB values are less than 1 assumes unit:scalar. Otherwise unit:8bit.\n * If RGB values exceed 255, _undefined_ returned.\n * @param v \n * @returns \n */\nexport const tryParseObjectToRgb = (v: any): Rgb | undefined => {\n  if (!(`r` in v && `g` in v && `b` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.r > 255 && v.g <= 255 && v.b <= 255) {\n      return; // out of range\n    } else {\n      v.unit = `8bit`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `srgb`;\n  }\n  return v as Rgb;\n}\n\nexport const tryParseObjectToHsl = (v: any): Hsl | undefined => {\n  if (!(`h` in v && `s` in v && `l` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.s > 100 && v.l <= 100) {\n      return; // out of range\n    } else {\n      v.unit = `absolute`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `hsl`;\n  }\n  return v as Hsl;\n}\n\nexport const isOkLch = (v: any): v is OkLch => {\n  if (typeof v !== `object`) return false;\n  if (!(`l` in v)) return false;\n  if (!(`c` in v)) return false;\n  if (!(`h` in v)) return false;\n  if (!(`unit` in v)) return false;\n  if (!(`space` in v)) return false;\n  if (v.space === `lch`) return true;\n  if (v.space === `oklch`) return true;\n  return false;\n}\n\nexport const isColourish = (v: any): v is Colourish => {\n  if (typeof v === `string`) return true;\n  if (typeof v !== `object`) return false;\n  if (isHsl(v)) return true;\n  if (isOkLch(v)) return true;\n  if (isRgb(v)) return true;\n  return false;\n}","import type { RGB } from \"colorizr\";\n\nexport function calculateHueDistance(a: number, b: number, limit = 1) {\n  let long = -1;\n  let short = -1;\n  if (b < a) {\n    long = (b - a);\n    short = limit - (a - b);\n  } else {\n    long = (b - a);\n    short = (long) - limit;\n  }\n  const forward = short > 0 ? short : long;\n  const backward = short > 0 ? long : short;\n  if (Math.abs(long) < Math.abs(short)) {\n    const t = short;\n    short = long;\n    long = t;\n  }\n  return { long, short, forward, backward };\n}\n\nexport const libraryRgbToHexString = (rgb: RGB): string => {\n  const componentToHex = (c: number) => {\n    const hex = Math.floor(c).toString(16);\n    return hex.length == 1 ? \"0\" + hex : hex;\n  }\n\n  let part = `#${ componentToHex(rgb.r) }${ componentToHex(rgb.g) }${ componentToHex(rgb.b) }`;\n  if (typeof rgb.alpha !== `undefined` && rgb.alpha !== 255) {\n    part += componentToHex(rgb.alpha);\n  }\n  return part;\n}\n\nexport function wrapScalarHue(value: number) {\n  value = value % 1;\n  if (value < 0) return (1 - Math.abs(value)) % 1;\n  return value;\n}\n\n// export function cssAngleFormat(value:string) {\n//   let start = value.indexOf(`)`);\n//   let end = value.lastIndexOf(')');\n//   if (start < 0) return value;\n//   if (end < start) return value;\n\n// }","import Colorizr, * as C from \"colorizr\";\nimport type { Colourish, Hsl, HslAbsolute, HslScalar, ParsingOptions, Rgb } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest, percentTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours, resolveCss } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { isRgb } from \"./guards.js\";\nimport { calculateHueDistance, libraryRgbToHexString, wrapScalarHue } from \"./utility.js\";\nimport { parseCssRgbFunction, to8bit as rgbTo8bit, toLibraryHsl as rgbToLibraryHsl } from \"./srgb.js\";\n\n/**\n * Scales the opacity value of an input HSL value\n * ```js\n * withOpacity()\n * ```\n * @param value Colour\n * @param fn Function that calcules opacity based on input scalar value\n * @returns \n */\nexport const withOpacity = <T extends Hsl>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\n/**\n * Increases or decreases lightness by this percentage, returning new colour\n * \n * Amount to change:\n * * 'fixed': a fixed amount\n * * 'delta': increase/decrease by this amount\n * * 'pdelta': proportion of current value to change by ('percentage delta')\n * \n * ```\n * const colour = { h: 0.5, s: 0.5, l: 0.5, space: `hsl`, unit: `scalar` };\n * changeLightness(colour, { pdelta: 0.1 }); // l: 0.55\n * changeLightness(colour, { delta: 0.1 });  // l: 0.6\n * changeLightness(colour, { fixed: 0.5 });  // l: 0.5\n * ```\n * \n * Keep in mind the numerical value will depend on the unit of `value`. If it's scalar,\n * lightness is 0..1 scale, otherwise 0..100 scale.\n * \n * Use negative values to decrease (does not apply to 'fixed')\n * @param value Hsl colour\n * @param amount Amount to change\n */\nexport const changeLightness = (value: Hsl, amount: Partial<{ pdelta: number, delta: number, fixed: number }>): Hsl => {\n  let newL = 0;\n  if (typeof amount.pdelta !== `undefined`) {\n    newL = value.l + (value.l * amount.pdelta);\n  } else if (typeof amount.delta !== `undefined`) {\n    newL = amount.delta + value.l;\n  } else if (typeof amount.fixed !== `undefined`) {\n    if (amount.fixed < 0) throw new TypeError(`Cannot use negative value with 'fixed'`);\n    newL = amount.fixed;\n  } else {\n    throw new TypeError(`Parameter 'amount' is missing 'delta/pdelta/fixed' properties`);\n  }\n  return {\n    ...value,\n    l: scaleProperty(value, newL, `l`)\n  }\n}\n\nconst scaleProperty = (hsl: Hsl, value: number, property: `l` | `h` | `s`) => {\n  if (hsl.unit === `scalar`) {\n    // 0..1 scale\n    if (value > 1) value = 1;\n    else if (value < 0) value = 0;\n  } else {\n    // 0..100 scale\n    if (value > 100) value = 100;\n    else if (value < 0) value = 0;\n  }\n  return value;\n}\n\nconst hslTransparent = Object.freeze({\n  h: 0, s: 0, l: 0, opacity: 0, unit: `absolute`, space: `hsl`\n});\n\nexport function fromHexString<T extends ParsingOptions<Hsl>>(hexString: string, scalar: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\n\nexport function fromHexString(hexString: string, options: ParsingOptions<Hsl> = {}): Hsl {\n  return fromLibrary(C.hex2hsl(hexString), options);\n}\n\nexport function fromCss<T extends ParsingOptions<Hsl>>(value: string, options?: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\nexport function fromCss(value: string, options: Partial<ParsingOptions<Hsl>> = {}): Hsl {\n  value = value.toLowerCase();\n\n  if (value.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);\n  if (value.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);\n\n  if (value.startsWith(`#`)) {\n    return fromHexString(value, options);\n  }\n  if (value.startsWith(`--`)) {\n    try {\n      value = resolveCss(value);\n    } catch (error) {\n      if (typeof options.fallbackString !== `undefined`) value = options.fallbackString;\n      if (typeof options.fallbackColour !== `undefined`) return options.fallbackColour;\n      throw error;\n    }\n  }\n  if (value === `transparent`) return hslTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string, options);\n  }\n\n  if (value.startsWith(`rgb(`)) {\n    const hsl = rgbToLibraryHsl(value);\n    return fromLibrary(hsl, options);\n  }\n\n  if (!value.startsWith(`hsl(`)) {\n    try {\n      value = C.convert(value, `hsl`);\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  try {\n    // Hand-rolled hsl() parse because the package is broken\n    const hsl = parseCssHslFunction(value);\n    if (options.scalar) return toScalar(hsl);\n    return toAbsolute(hsl);\n  } catch (error) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw error;\n  }\n\n}\n\nexport const toCssString = (hsl: Hsl): string => {\n  const abs = toAbsolute(hsl);\n  let css = `hsl(${ abs.h }deg ${ abs.s }% ${ abs.l }%`;\n  if (`opacity` in abs && abs.opacity !== undefined && abs.opacity < 100) {\n    css += ` / ${ abs.opacity }%`;\n  }\n  css += ')';\n  return css;\n}\n\nexport const toHexString = (hsl: Hsl): string => {\n  const rgb = toLibraryRgb(hsl);\n  return libraryRgbToHexString(rgb);\n}\n\nconst toLibrary = (hsl: Hsl): C.HSL => {\n  const abs = toAbsolute(hsl);\n  return {\n    h: abs.h,\n    s: abs.s,\n    l: abs.l,\n    alpha: abs.opacity,\n  }\n}\nfunction fromLibrary<T extends ParsingOptions<Hsl>>(hsl: C.HSL, parsingOptions: T): T extends { scalar: true } ? HslScalar : HslAbsolute;\n\nfunction fromLibrary<T extends Hsl>(hsl: C.HSL, parsingOptions: ParsingOptions<T> = {}): T {\n  if (typeof hsl === `undefined` || hsl === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n  const scalarOpt = parsingOptions.scalar ?? true;\n\n  // Library result is absolute\n  resultThrow(\n    numberInclusiveRangeTest(hsl.h, 0, 360, `h`),\n    numberInclusiveRangeTest(hsl.s, 0, 100, `s`),\n    numberInclusiveRangeTest(hsl.l, 0, 100, `l`),\n    percentTest((hsl.alpha ?? 1), `alpha`)\n    // () => hsl.alpha !== undefined ? numberInclusiveRangeTest(hsl.alpha, 0, 100, `alpha`) : { success: true, value: hsl },\n  );\n  if (scalarOpt) {\n    return scalar(hsl.h / 360, hsl.s / 100, hsl.l / 100, (hsl.alpha ?? 1)) as T;\n  } else {\n    return absolute(hsl.h, hsl.s, hsl.l, (hsl.alpha ?? 1) * 100) as T;\n  }\n}\n\nexport const toAbsolute = (hslOrString: Hsl | Rgb | string): HslAbsolute => {\n  // if (typeof hslOrString === `string`) {\n  //   return toAbsolute(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: false }));\n  // }\n  if (typeof hslOrString === `string`) {\n    return fromCss(hslOrString, { scalar: false });\n    // try {\n    //   return toScalar(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: true }));\n    // } catch (error) {\n    //   console.error(`Hsl.toScalar: ${ hslOrString }`);\n    //   throw error;\n    // }\n  }\n  if (isRgb(hslOrString)) {\n    return toAbsolute(fromLibrary(rgbToLibraryHsl(hslOrString), { scalar: false }));\n  }\n  const hsl = hslOrString;\n  guard(hsl);\n  if (hsl.unit === `absolute`) return hsl;\n  return {\n    h: hsl.h * 360,\n    s: hsl.s * 100,\n    l: hsl.l * 100,\n    opacity: (hsl.opacity ?? 1) * 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\n/**\n * Generates a {@link HslScalar} value.\n * \n * ```js\n * generateScaler(10); // 10deg, default to full saturation, half lightness and full opacity\n * \n * // Generate HSL value from radian angle and 50% saturation\n * generateScalar(`10rad`, 0.5); \n * \n * // Generate from numeric CSS variable\n * generateScalar(`--hue`);\n * ```\n * @param absoluteHslOrVariable Hue angle or CSS variable\n * @param saturation \n * @param lightness \n * @param opacity \n */\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, saturation = 1, lightness = 0.5, opacity = 1): HslScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  const hue = angleParse(absoluteHslOrVariable);\n  if (saturation > 1) throw new TypeError(`Param 'saturation' must be between 0..1`);\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  return {\n    h: hueDeg,\n    s: saturation,\n    l: lightness,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\n/**\n * Converts a {@link Hsl} value to scalar units, or parses a colour string\n * and converts it.\n * \n * ```js\n * toScalar({ h: 100, s: 50, l: 100, unit: `absolute` });\n * toScalar(`red`);\n * ```\n * @param hslOrString \n * @returns \n */\nexport const toScalar = (hslOrString: Rgb | Hsl | string): HslScalar => {\n  if (typeof hslOrString === `string`) {\n    return fromCss(hslOrString, { scalar: true });\n    // try {\n    //   return toScalar(fromLibrary(C.parseCSS(hslOrString, `hsl`), { scalar: true }));\n    // } catch (error) {\n    //   console.error(`Hsl.toScalar: ${ hslOrString }`);\n    //   throw error;\n    // }\n  }\n  if (isRgb(hslOrString)) {\n    return toScalar(fromLibrary(rgbToLibraryHsl(hslOrString), { scalar: true }));\n  }\n\n  const hsl = hslOrString;\n  guard(hsl);\n  if (hsl.unit === `scalar`) return hsl;\n  return {\n    h: hsl.h / 360,\n    s: hsl.s / 100,\n    l: hsl.l / 100,\n    opacity: (hsl.opacity ?? 1) / 100,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\nexport const guard = (hsl: Hsl) => {\n  const { h, s, l, opacity, space, unit } = hsl;\n  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${ space }`);\n  if (unit === `absolute`) {\n    resultThrow(\n      numberTest(h, `finite`, `h`),\n      numberInclusiveRangeTest(s, 0, 100, `s`),\n      numberInclusiveRangeTest(l, 0, 100, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 100, `opacity`);\n        }\n      });\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(h, `percentage`, `h`),\n      numberTest(s, `percentage`, `s`),\n      numberTest(l, `percentage`, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nexport const interpolator = (a: Hsl | string, b: Hsl | string, direction: `longer` | `shorter` = `shorter`) => {\n  a = toScalar(a);\n  b = toScalar(b);\n  const aOpacity = a.opacity ?? 1;\n  const distanceCalc = calculateHueDistance(a.h, b.h, 1);\n  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;\n  const satDistance = b.s - a.s;\n  const lightDistance = b.l - a.l;\n  const opacityDistance = (b.opacity ?? 1) - aOpacity;\n\n  return (amount: number): HslScalar => {\n    amount = clamp(amount);\n    let h = interpolate(amount, 0, Math.abs(hueDistance));\n    if (hueDistance < 0) h = a.h - h;\n    else h = a.h + h;\n\n    const s = interpolate(amount, 0, satDistance);\n    const l = interpolate(amount, 0, lightDistance);\n    const o = interpolate(amount, 0, opacityDistance);\n    return scalar(wrapScalarHue(h), s + a.s, l + a.l, o + aOpacity);\n  }\n}\n\n/**\n * Creates a HslScalar value from scalar (0..1) values\n * @param hue \n * @param sat \n * @param lightness \n * @param opacity \n * @returns \n */\nexport function scalar(hue = 0.5, sat = 1, lightness = 0.5, opacity = 1): HslScalar {\n  const hsl: HslScalar = {\n    unit: `scalar`,\n    space: `hsl`,\n    h: hue,\n    s: sat,\n    l: lightness,\n    opacity: opacity\n  }\n  guard(hsl);\n  return hsl;\n}\n\nexport function absolute(hue = 200, sat = 100, lightness = 50, opacity = 100): HslAbsolute {\n  const hsl: HslAbsolute = {\n    unit: `absolute`,\n    space: `hsl`,\n    h: hue,\n    s: sat,\n    l: lightness,\n    opacity: opacity\n  }\n  guard(hsl);\n  return hsl;\n}\n\n/**\n * It seems Colorizr can't handle 'deg' units\n * @param value \n */\nexport function parseCssHslFunction(value: string): Hsl {\n  if (value.startsWith(`hsla`)) throw new Error(`hsla() is not supported`);\n  if (!value.startsWith(`hsl(`)) throw new Error(`Expected hsl(..) CSS colour`);\n\n  const start = value.indexOf('(');\n  const end = value.indexOf(')');\n  if (end < start) throw new Error(`Is hsl() not terminated? Missing ')'`);\n\n  const part = value.substring(start + 1, end);\n  let split = part.split(/[\\s,]+/);\n  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${ split.length } length`);\n\n  let returnRelative = false;\n  if (split[ 0 ].endsWith(`%`)) returnRelative = true;\n  if (split[ 1 ].endsWith(`%`) && split[ 2 ].endsWith(`%`)) returnRelative = true;\n\n  const valueAsScalar = (v: string, pos: number) => {\n    if (v === `none`) return 0;\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100;\n    }\n    if (v.endsWith(`deg`) && pos === 0) {\n      v = v.substring(0, v.length - 3);\n    }\n\n    const vf = Number.parseFloat(v);\n    if (pos === 0) return vf / 360;\n    if (pos === 3) return vf; // opacity\n    return vf / 100;\n  }\n\n  const valueAsAbs = (v: string, pos: number) => {\n    if (v === `none`) return 0;\n    if (v.endsWith(`%`)) {\n      const vf = Number.parseFloat(v.substring(0, v.length - 1));\n      if (pos === 0) return vf * 360;\n      return vf;\n    }\n    if (v.endsWith(`deg`) && pos === 0) {\n      return Number.parseFloat(v.substring(0, v.length - 3));\n    }\n    const vf = Number.parseFloat(v);\n    return vf;\n  }\n\n  // Is there opacity?\n  if (split.length > 3) {\n    if (split[ 3 ] === '/') {\n      // Remove / part\n      split = [ split[ 0 ], split[ 1 ], split[ 2 ], split[ 4 ] ];\n    }\n  }\n  if (returnRelative) {\n    return scalar(\n      valueAsScalar(split[ 0 ], 0),\n      valueAsScalar(split[ 1 ], 1),\n      valueAsScalar(split[ 2 ], 2),\n      valueAsScalar(split[ 3 ] ?? `100%`, 3)\n    )\n  } else {\n    // Return as absolute\n    return absolute(\n      valueAsAbs(split[ 0 ], 0),\n      valueAsAbs(split[ 1 ], 1),\n      valueAsAbs(split[ 2 ], 2),\n      valueAsAbs(split[ 3 ] ?? `100%`, 3)\n    )\n  }\n}\n\n/**\n * Converts a Hsl structure (or CSS string) to Colorizr's RGB format\n * @param hsl HSL colour\n * @returns \n */\nexport function toLibraryRgb(hsl: Hsl | string): C.RGB {\n  if (typeof hsl === `string`) {\n    const parseResult = fromCss(hsl, { scalar: false });\n    //console.log(`parseResult hsl: ${ hsl } pr: `, parseResult);\n    return toLibraryRgb(parseResult);\n  }\n  hsl = toAbsolute(hsl);\n  //console.log(`toLibraryRgb hsl`, hsl);\n  const rgb = C.hsl2rgb({ h: hsl.h, s: hsl.s, l: hsl.l });\n  return { ...rgb, alpha: (hsl.opacity ?? 100) / 100 * 255 };\n}","import type { OkLch, OkLchAbsolute, OkLchScalar, ParsingOptions } from \"./types.js\";\nimport { numberInclusiveRangeTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport Colorizr, * as C from \"colorizr\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\nimport { calculateHueDistance, libraryRgbToHexString, wrapScalarHue } from \"./utility.js\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { parseCssRgbFunction, to8bit as rgbTo8bit } from \"./srgb.js\";\n\nexport const OKLCH_CHROMA_MAX = 0.4;\n\nexport const guard = (lch: OkLch) => {\n  const { l, c, h, opacity, space, unit } = lch;\n  if (space !== `oklch`) throw new Error(`Space is expected to be 'oklch'. Got: ${ space }`);\n\n  if (unit === `absolute`) {\n    resultThrow(\n      percentTest(l, `l`),\n      () => {\n        if (typeof c === `number`) {\n          return numberInclusiveRangeTest(c, 0, OKLCH_CHROMA_MAX, `c`);\n        }\n      },\n      () => {\n        if (typeof h === `number`) {\n          return numberInclusiveRangeTest(c, 0, 360, `h`);\n        }\n      },\n      percentTest((opacity ?? 1), `opacity`)\n    );\n  } else if (unit === `scalar`) {\n    // Percentage values for L,C,H\n    resultThrow(\n      percentTest(l, `l`),\n      percentTest(c, `c`),\n      percentTest(h, `h`),\n      percentTest((lch.opacity ?? 1), `opacity`)\n    );\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\n\n\n/**\n * Coverts from the Colorizr library\n * Tests ranges:\n * * l: 0..1\n * * c: 0..1\n * * h: 0..360\n * * alpha: 0..1\n * \n * Default option: { scalar: true }\n * @param lch LCH value\n * @param parsingOptions Options for parsing \n * @returns \n */\nexport function fromLibrary<T extends ParsingOptions<OkLch>>(lch: C.LCH, parsingOptions: T): T extends { scalar: true } ? OkLchScalar : OkLchAbsolute;\n\nexport function fromLibrary(lch: C.LCH, parsingOptions: ParsingOptions<OkLch> = {}): OkLch {\n  if (typeof lch === `undefined` || lch === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n\n  const scalarReturn = parsingOptions.scalar ?? true;\n\n  // Validate\n  resultThrow(\n    percentTest(lch.l, `l`),\n    percentTest(lch.c, `c`),\n    numberInclusiveRangeTest(lch.h, 0, 360, `h`),\n    percentTest((lch.alpha ?? 1), `alpha`)\n  );\n\n  if (scalarReturn) {\n    return scalar(lch.l, lch.c / OKLCH_CHROMA_MAX, lch.h / 360, (lch.alpha ?? 1));\n  } else {\n    return absolute(lch.l, lch.c, lch.h, (lch.alpha ?? 1));\n  }\n}\n\n/**\n * Parse a HEX-formatted colour into OkLch structured format\n * @param hexString \n * @param options \n * @returns \n */\nexport const fromHexString = (hexString: string, options: ParsingOptions<OkLch> = {}): OkLch => {\n  return fromLibrary(C.hex2oklch(hexString), options);\n}\n\nconst oklchTransparent: OkLchAbsolute = Object.freeze({\n  l: 0, c: 0, h: 0, opacity: 0, unit: `absolute`, space: `oklch`\n});\n\n/**\n * Converts from some CSS-representation of colour to a structured OkLch format.\n * \n * ```js\n * fromCss(`yellow`);\n * fromCss(`rgb(100,200,90)`);\n * fromCss(`#ff00ff`);\n * ```\n * \n * By default returns a {@link OkLchScalar} (relative) representation. Use the flag 'scalar:true' to get back\n * {@link OkLchAbsolute}.\n * @param value \n * @param options \n */\nexport function fromCss<T extends ParsingOptions<OkLch>>(value: string, options: T): T extends { scalar: true } ? OkLchScalar : OkLchAbsolute;\n\nexport function fromCss(value: string, options: ParsingOptions<OkLch> = {}): OkLch {\n  value = value.toLowerCase();\n  if (value.startsWith(`#`)) {\n    return fromHexString(value, options);\n  }\n  if (value === `transparent`) return oklchTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string, options);\n  }\n\n  if (value.startsWith(`rgb(`)) {\n    const rgb = rgbTo8bit(parseCssRgbFunction(value));\n    const lch = C.rgb2oklch({ r: rgb.r, g: rgb.g, b: rgb.b });\n    return fromLibrary(lch, options);\n  }\n\n  if (!value.startsWith(`hsl(`) && !value.startsWith(`oklch(`)) {\n    try {\n      const converted = C.convert(value, `oklch`);\n      value = converted;\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n  const cc = new Colorizr(value);\n  const lch = cc.oklch;\n  return fromLibrary(lch, options);\n}\n\n//export const fromCssScalar = (value: string, options: ParsingOptions<OkLchAbsolute> = {}): OkLchScalar => toScalar(fromCssAbsolute(value, options));\n\n/**\n * Returns a string or {@link OkLch} value to absolute form.\n * \n * This means ranges are:\n * * lightness: 0..1\n * * chroma: 0...CHROMA_MAX (0.4)\n * * hue: 0..360\n * @param lchOrString \n * @returns \n */\nexport const toAbsolute = (lchOrString: OkLch | string): OkLchAbsolute => {\n  if (typeof lchOrString === `string`) {\n    return toAbsolute(fromCss(lchOrString, { scalar: true }));\n  }\n  guard(lchOrString);\n  if (lchOrString.unit === `absolute`) return lchOrString;\n  return {\n    space: `oklch`,\n    unit: `absolute`,\n    l: lchOrString.l,\n    c: lchOrString.c * OKLCH_CHROMA_MAX,\n    h: lchOrString.h * 360,\n    opacity: lchOrString.opacity\n  }\n}\n\n\nexport const toScalar = (lchOrString: OkLch | string): OkLchScalar => {\n  if (typeof lchOrString === `string`) {\n    return toScalar(fromCss(lchOrString, { scalar: true }));\n  }\n  const lch = lchOrString;\n  guard(lch);\n\n  //console.log(`toScalar input: ${ JSON.stringify(lchOrString) } lch: `, lch);\n  // Already relative\n  if (lch.unit === `scalar`) return lch;\n\n  // Absolute values\n  return {\n    l: lch.l, // unchanged\n    c: lch.c / OKLCH_CHROMA_MAX,\n    h: lch.h / 360,\n    opacity: (lch.opacity ?? 1),\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\nconst toLibrary = (lch: OkLch): C.LCH => {\n  const abs = toAbsolute(lch);\n  return {\n    l: abs.l,\n    c: abs.c,\n    h: abs.h,\n    alpha: abs.opacity,\n  }\n}\n// const libraryLchToScalar = (c: C.LCH): OkLchScalar => {\n//   return {\n//     l: c.h,\n//     c: c.c,\n//     h: c.h / 360,\n//     opacity: c.alpha ?? 1,\n//     unit: `scalar`,\n//     space: `oklch`\n//   }\n// }\n\n\n/**\n * Returns the colour as a CSS colour string: `oklch(l c h / opacity)`.\n *\n * @param lch Colour\n * @param precision Set precision of numbers, defaults to 3 \n * @returns CSS colour string\n */\nexport const toCssString = (lch: OkLch, precision = 3): string => {\n  guard(lch);\n  const { l, c, h, opacity } = lch;\n  let css = ``;\n  switch (lch.unit) {\n    case `absolute`:\n      css = `oklch(${ (l * 100).toFixed(precision) }% ${ c.toFixed(precision) } ${ h.toFixed(precision) }`\n      break;\n    case `scalar`:\n      css = `oklch(${ l.toFixed(precision) } ${ (c * OKLCH_CHROMA_MAX).toFixed(precision) } ${ (h * 360).toFixed(precision) }`\n      break;\n  }\n  if (typeof opacity !== `undefined` && opacity !== 1) {\n    css += ` / ${ opacity.toFixed(precision) }`;\n  }\n  css += `)`;\n  return css;\n}\n\nexport const toHexString = (lch: OkLch): string => {\n  const lch1 = toLibrary(lch);\n  const rgb = C.oklch2rgb(lch1);\n  return libraryRgbToHexString(rgb);\n}\n\n// export const oklchFromCss = (css: string): OkLchScalar => {\n//   if (css.startsWith(`#`)) {\n//     libraryLchToScalar(C.hex2oklch(css));\n//   }\n//   const p = C.extractColorParts(css);\n//   return libraryToScalar(p);\n// }\n\n// const libraryToScalar = (colour: unknown): OkLchScalar => {\n//   if (C.isLCH(colour)) {\n//     return libraryLchToScalar(colour);\n//   }\n//   if (C.isRGB(colour)) {\n//     return libraryToScalar(C.rgb2oklch(colour));\n//   }\n//   if (C.isLAB(colour)) {\n//     return libraryToScalar(C.oklab2oklch(colour));\n//   }\n//   if (C.isHSL(colour)) {\n//     return libraryToScalar(C.hsl2oklch(colour));\n//   }\n//   if (C.isHex(colour)) {\n//     return libraryLchToScalar(C.hex2oklch(colour));\n//   }\n//   throw new Error(`Unexpected colour format`);\n// }\n\n// export const oklchToColorJs = (lch: OkLch): ColorConstructor => {\n//   throwNumberTest(lch.l, `percentage`, `lch.l`);\n//   throwNumberTest(lch.c, `percentage`, `lch.c`);\n//   throwNumberTest(lch.h, `percentage`, `lch.h`);\n//   throwNumberTest(lch.opacity, `percentage`, `lch.opacity`);\n//   return {\n//     alpha: lch.opacity,\n//     coords: [ lch.l, lch.c * 0.4, lch.h * 360 ],\n//     spaceId: `oklch`\n//   }\n// }\n\n// const oklchToColorJs = (oklch: OkLch) => {\n//   throwNumberTest(oklch.l, `percentage`, `oklch.l`);\n//   throwNumberTest(oklch.c, `percentage`, `oklch.c`);\n//   throwNumberTest(oklch.h, `percentage`, `oklch.h`);\n//   throwNumberTest(oklch.opacity, `percentage`, `oklch.opacity`);\n//   const coords: [ number, number, number ] = [\n//     oklch.l,\n//     oklch.c * 0.4,\n//     oklch.h * 360\n//   ]\n//   return new ColorJs.default(`oklch`, coords, oklch.opacity);\n// }\n\n// export const isOklch = (p: Colourish | undefined | null): p is OkLch => {\n//   if (typeof p === `undefined` || p === null) return false;\n//   if (typeof p !== `object`) return false;\n\n//   // Check if Colourjs\n//   //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n//   //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n//   if (p.space !== `oklch`) return false;\n//   if (typeof p.l === `undefined`) return false;\n//   if (typeof p.c === `undefined`) return false;\n//   if (typeof p.h === `undefined`) return false;\n//   return true;\n// }\n\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, chroma = 1, lightness = 0.5, opacity = 1): OkLchScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (chroma > 1) throw new TypeError(`Param 'chroma' must be between 0..1`);\n  const hue = angleParse(absoluteHslOrVariable);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n\n  return {\n    l: lightness,\n    c: chroma,\n    h: hueDeg,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\n/**\n * Scales the opacity value of an input Oklch value\n * ```js\n * withOpacity()\n * ```\n * @param value \n * @param fn \n * @returns \n */\nexport const withOpacity = <T extends OkLch>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport const interpolator = (a: OkLch | string, b: OkLch | string, direction: `longer` | `shorter` = `shorter`) => {\n  a = toScalar(a);\n  b = toScalar(b);\n  //console.log(`a`, a);\n  //console.log(`b`, b);\n\n  const aOpacity = a.opacity ?? 1;\n  const distanceCalc = calculateHueDistance(a.h, b.h, 1);\n  const hueDistance = direction === `longer` ? distanceCalc.long : distanceCalc.short;\n  const chromaDistance = b.c - a.c;\n  const lightDistance = b.l - a.l;\n  const opacityDistance = (b.opacity ?? 1) - aOpacity;\n  //console.log(`distanceCalc`, distanceCalc);\n  //console.log(`interpolator distances: hue: ${ hueDistance } c: ${ chromaDistance } light: ${ lightDistance } opacity: ${ opacityDistance }`);\n\n  return (amount: number): OkLchScalar => {\n    amount = clamp(amount);\n    let h = interpolate(amount, 0, Math.abs(hueDistance));\n    if (hueDistance < 0) h = a.h - h;\n    else h = a.h + h;\n\n    const c = interpolate(amount, 0, chromaDistance);\n    const l = interpolate(amount, 0, lightDistance);\n    const o = interpolate(amount, 0, opacityDistance);\n    //console.log(`amount: ${ amount } h: ${ h } s: ${ s } l: ${ l } o: ${ o }`);\n    return scalar(l + a.l, c + a.c, wrapScalarHue(h), o + aOpacity);\n  }\n}\n\nexport function scalar(lightness = 0.7, chroma = 0.1, hue = 0.5, opacity = 1): OkLchScalar {\n  const lch: OkLchScalar = {\n    unit: `scalar`,\n    space: `oklch`,\n    l: lightness,\n    c: chroma,\n    h: hue,\n    opacity: opacity\n  }\n  guard(lch);\n  return lch;\n}\n\n/**\n * Create an LCH colour using absolute hue\n * @param l Lightness 0..1\n * @param c Chroma 0..4\n * @param h Hue 0..360\n * @param opacity \n * @returns \n */\nexport const absolute = (l: number, c: number, h: number, opacity = 1): OkLchAbsolute => {\n  const lch: OkLchAbsolute = {\n    space: `oklch`,\n    unit: `absolute`,\n    opacity,\n    l, c, h\n  };\n  guard(lch);\n  return lch;\n}\n","import * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport * as OklchSpace from './oklch.js';\nimport type { Colour } from \"./types.js\";\n\n/**\n * Converts from some kind of colour that is legal in CSS\n * into a structured Colour type.\n * \n * Handles: hex format, CSS variables, colour names\n * ```js\n * fromCssColour(`#ffffff`);\n * fromCssColour(`blue`);\n * fromCssColour(`--some-variable`);\n * fromCssColour(`hsl(50, 50%, 50%)`);\n * fromCssColour(`rgb(50, 100, 100)`);\n * ```\n * @param colour \n * @returns \n */\nexport const fromCssColour = (colour: string): Colour => {\n  if (colour.startsWith(`#`)) {\n    return SrgbSpace.fromHexString(colour, true);\n  }\n\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return SrgbSpace.fromHexString(cssDefinedHexColours[ colour ] as string, true);\n  }\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0 || fromCss === null) throw new Error(`Variable missing: ${ colour }`);\n    return fromCssColour(fromCss);\n  }\n  colour = colour.toLowerCase();\n  if (colour.startsWith(`hsl(`)) {\n    return HslSpace.fromCss(colour, { scalar: true });\n  }\n  if (colour.startsWith(`rgb(`)) {\n    return SrgbSpace.fromCss(colour, { scalar: true });\n  }\n  if (colour.startsWith(`oklch(`)) {\n    return OklchSpace.fromCss(colour, { scalar: true });\n  }\n\n  throw new Error(`String colour is not a hex colour, CSS variable nor well-defined colour. Input: '${ colour }'`);\n}\n\n/**\n * Resolves a named colour or CSS variable to a colour string.\n * Doesn't do conversion or parsing.\n * \n * ```js\n * resolveCss(`red`);\n * resolveCss(`my-var`);\n * ```\n * @param colour Colour\n * @param fallback Fallback if CSS variable is missing\n * @returns \n */\nexport const resolveCss = (colour: string, fallback?: string): string => {\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0 || fromCss === null) {\n      if (typeof fallback !== `undefined`) return fallback;\n      throw new Error(`CSS variable missing: '${ colour }'`);\n    }\n    return resolveCss(fromCss); // Recurse, because value might be a named colour\n  }\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return cssDefinedHexColours[ colour ] as string;\n  }\n  return colour; // assume legit\n}\n\nexport const cssDefinedHexColours = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",\n  \"blue\": \"#0000ff\",\n  \"blueviolet\": \"#8a2be2\",\n  \"brown\": \"#a52a2a\",\n  \"burlywood\": \"#deb887\",\n  \"cadetblue\": \"#5f9ea0\",\n  \"chartreuse\": \"#7fff00\",\n  \"chocolate\": \"#d2691e\",\n  \"coral\": \"#ff7f50\",\n  \"cornflowerblue\": \"#6495ed\",\n  \"cornsilk\": \"#fff8dc\",\n  \"crimson\": \"#dc143c\",\n  \"cyan\": \"#00ffff\",\n  \"darkblue\": \"#00008b\",\n  \"darkcyan\": \"#008b8b\",\n  \"darkgoldenrod\": \"#b8860b\",\n  \"darkgray\": \"#a9a9a9\",\n  \"darkgreen\": \"#006400\",\n  \"darkkhaki\": \"#bdb76b\",\n  \"darkmagenta\": \"#8b008b\",\n  \"darkolivegreen\": \"#556b2f\",\n  \"darkorange\": \"#ff8c00\",\n  \"darkorchid\": \"#9932cc\",\n  \"darkred\": \"#8b0000\",\n  \"darksalmon\": \"#e9967a\",\n  \"darkseagreen\": \"#8fbc8f\",\n  \"darkslateblue\": \"#483d8b\",\n  \"darkslategray\": \"#2f4f4f\",\n  \"darkturquoise\": \"#00ced1\",\n  \"darkviolet\": \"#9400d3\",\n  \"deeppink\": \"#ff1493\",\n  \"deepskyblue\": \"#00bfff\",\n  \"dimgray\": \"#696969\",\n  \"dodgerblue\": \"#1e90ff\",\n  \"firebrick\": \"#b22222\",\n  \"floralwhite\": \"#fffaf0\",\n  \"forestgreen\": \"#228b22\",\n  \"fuchsia\": \"#ff00ff\",\n  \"gainsboro\": \"#dcdcdc\",\n  \"ghostwhite\": \"#f8f8ff\",\n  \"gold\": \"#ffd700\",\n  \"goldenrod\": \"#daa520\",\n  \"gray\": \"#808080\",\n  \"green\": \"#008000\",\n  \"greenyellow\": \"#adff2f\",\n  \"honeydew\": \"#f0fff0\",\n  \"hotpink\": \"#ff69b4\",\n  \"indianred\": \"#cd5c5c\",\n  \"indigo\": \"#4b0082\",\n  \"ivory\": \"#fffff0\",\n  \"khaki\": \"#f0e68c\",\n  \"lavender\": \"#e6e6fa\",\n  \"lavenderblush\": \"#fff0f5\",\n  \"lawngreen\": \"#7cfc00\",\n  \"lemonchiffon\": \"#fffacd\",\n  \"lightblue\": \"#add8e6\",\n  \"lightcoral\": \"#f08080\",\n  \"lightcyan\": \"#e0ffff\",\n  \"lightgoldenrodyellow\": \"#fafad2\",\n  \"lightgray\": \"#d3d3d3\",\n  \"lightgreen\": \"#90ee90\",\n  \"lightpink\": \"#ffb6c1\",\n  \"lightsalmon\": \"#ffa07a\",\n  \"lightseagreen\": \"#20b2aa\",\n  \"lightskyblue\": \"#87cefa\",\n  \"lightslategray\": \"#778899\",\n  \"lightsteelblue\": \"#b0c4de\",\n  \"lightyellow\": \"#ffffe0\",\n  \"lime\": \"#00ff00\",\n  \"limegreen\": \"#32cd32\",\n  \"linen\": \"#faf0e6\",\n  \"magenta\": \"#ff00ff\",\n  \"maroon\": \"#800000\",\n  \"mediumaquamarine\": \"#66cdaa\",\n  \"mediumblue\": \"#0000cd\",\n  \"mediumorchid\": \"#ba55d3\",\n  \"mediumpurple\": \"#9370db\",\n  \"mediumseagreen\": \"#3cb371\",\n  \"mediumslateblue\": \"#7b68ee\",\n  \"mediumspringgreen\": \"#00fa9a\",\n  \"mediumturquoise\": \"#48d1cc\",\n  \"mediumvioletred\": \"#c71585\",\n  \"midnightblue\": \"#191970\",\n  \"mintcream\": \"#f5fffa\",\n  \"mistyrose\": \"#ffe4e1\",\n  \"moccasin\": \"#ffe4b5\",\n  \"navajowhite\": \"#ffdead\",\n  \"navy\": \"#000080\",\n  \"oldlace\": \"#fdf5e6\",\n  \"olive\": \"#808000\",\n  \"olivedrab\": \"#6b8e23\",\n  \"orange\": \"#ffa500\",\n  \"orangered\": \"#ff4500\",\n  \"orchid\": \"#da70d6\",\n  \"palegoldenrod\": \"#eee8aa\",\n  \"palegreen\": \"#98fb98\",\n  \"paleturquoise\": \"#afeeee\",\n  \"palevioletred\": \"#db7093\",\n  \"papayawhip\": \"#ffefd5\",\n  \"peachpuff\": \"#ffdab9\",\n  \"peru\": \"#cd853f\",\n  \"pink\": \"#ffc0cb\",\n  \"plum\": \"#dda0dd\",\n  \"powderblue\": \"#b0e0e6\",\n  \"purple\": \"#800080\",\n  \"rebeccapurple\": \"#663399\",\n  \"red\": \"#ff0000\",\n  \"rosybrown\": \"#bc8f8f\",\n  \"royalblue\": \"#4169e1\",\n  \"saddlebrown\": \"#8b4513\",\n  \"salmon\": \"#fa8072\",\n  \"sandybrown\": \"#f4a460\",\n  \"seagreen\": \"#2e8b57\",\n  \"seashell\": \"#fff5ee\",\n  \"sienna\": \"#a0522d\",\n  \"silver\": \"#c0c0c0\",\n  \"skyblue\": \"#87ceeb\",\n  \"slateblue\": \"#6a5acd\",\n  \"slategray\": \"#708090\",\n  \"snow\": \"#fffafa\",\n  \"springgreen\": \"#00ff7f\",\n  \"steelblue\": \"#4682b4\",\n  \"tan\": \"#d2b48c\",\n  \"teal\": \"#008080\",\n  \"thistle\": \"#d8bfd8\",\n  \"tomato\": \"#ff6347\",\n  \"turquoise\": \"#40e0d0\",\n  \"violet\": \"#ee82ee\",\n  \"wheat\": \"#f5deb3\",\n  \"white\": \"#ffffff\",\n  \"whitesmoke\": \"#f5f5f5\",\n  \"yellow\": \"#ffff00\",\n  \"yellowgreen\": \"#9acd32\",\n  \"transparent\": \"#00000000\"\n}\n","import Colorizr, * as C from \"colorizr\";\n\nimport type { Hsl, ParsingOptions, Rgb, Rgb8Bit, RgbScalar } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { clamp, interpolate } from \"@ixfx/numbers\";\nimport { toLibraryRgb as hslToLibraryRgb } from \"./hsl.js\";\nimport { isHsl } from \"./guards.js\";\nimport { libraryRgbToHexString } from \"./utility.js\";\n\nexport const withOpacity = <T extends Rgb>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `8bit`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 255) / 255, value) * 255\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport function fromHexString<T extends boolean>(hexString: string, scalar: T): T extends true ? RgbScalar : Rgb8Bit;\nexport function fromHexString(hexString: string, scalar = true): RgbScalar | Rgb8Bit {\n  return fromLibrary(C.hex2rgb(hexString), { scalar });\n};\n\nconst srgbTansparent: Rgb8Bit = Object.freeze({\n  r: 0, g: 0, b: 0, opacity: 0, unit: `8bit`, space: `srgb`\n})\n\nexport function fromCss<T extends ParsingOptions<Rgb>>(value: string, options: T): T extends { scalar: true } ? RgbScalar : Rgb8Bit;\n\n/**\n * Converts a colour in a legal CSS form into Rgb value, by default RgbScalar (0..1) scale.\n * ```js\n * fromCss(`rebeccapurple`);\n * fromCss(`rgb(40% 20% 60%)`);\n * \n * // Get 8bit version on 0..255 scale\n * fromCss(`blue`, { scalar: false });\n * ```\n * \n * @param value \n * @param options \n * @returns \n */\nexport function fromCss(value: string, options: ParsingOptions<Rgb> = {}): Rgb {\n  value = value.toLowerCase();\n  if (value.startsWith(`hsla(`)) throw new Error(`hsla() not supported`);\n  if (value.startsWith(`rgba(`)) throw new Error(`rgba() not supported`);\n\n\n  const scalar = options.scalar ?? true;\n\n  // Convert from hex\n  if (value.startsWith(`#`)) return fromHexString(value, scalar);\n  // Special-case transparent\n  if (value === `transparent`) return srgbTansparent;\n  // Convert from named colour\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) fromHexString(cssDefinedHexColours[ value ] as string, scalar);\n\n  if (value.startsWith(`hsl(`)) {\n    const rgb = hslToLibraryRgb(value);\n    return fromLibrary(rgb, options);\n  }\n\n  // if (value.startsWith(`hsl(`)) {\n\n  //   const hslRel = hslToScalar(parseCssHslFunction(value));\n  //   const rgb = C.hsl2rgb({ h: hslRel.h, s: hslRel.s, l: hslRel.l, alpha: hslRel.opacity ?? 1 });\n  //   return fromLibrary(rgb, options);\n\n  // }\n\n  // Convert to rgb() colour function\n  if (!value.startsWith(`rgb(`)) {\n    try {\n      value = C.convert(value, `rgb`);\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  try {\n    // Hand-rolled rgb() parse because the package is broken\n    const rgb = parseCssRgbFunction(value);\n    if (scalar) return toScalar(rgb);\n    return to8bit(rgb);\n  } catch (error) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw error;\n  }\n}\n\nexport const toHexString = (rgb: Rgb): string => {\n  const rgb1 = toLibrary(rgb);\n  return libraryRgbToHexString(rgb1);\n}\n\nexport const toCssString = (rgb: Rgb): string => {\n  guard(rgb);\n  switch (rgb.unit) {\n    case `8bit`:\n      if (rgb.opacity === undefined || rgb.opacity === 255) {\n        return `rgb(${ rgb.r } ${ rgb.g } ${ rgb.b })`;\n      }\n      return `rgb(${ rgb.r } ${ rgb.g } ${ rgb.b } / ${ (rgb.opacity ?? 255) / 255 })`;\n    case `scalar`:\n      if (rgb.opacity === undefined || rgb.opacity === 1) {\n        return `rgb(${ rgb.r * 100 }% ${ rgb.g * 100 }% ${ rgb.b * 100 }%)`;\n      }\n      return `rgb(${ rgb.r * 100 }% ${ rgb.g * 100 }% ${ rgb.b * 100 }% / ${ (rgb.opacity ?? 1) * 100 }%)`;\n    default:\n\n      throw new Error(`Unknown unit: ${ (rgb as any).unit }`);\n  }\n}\n\nconst toLibrary = (rgb: Rgb): C.RGB => {\n  const abs = to8bit(rgb);\n  return {\n    r: abs.r,\n    g: abs.g,\n    b: abs.b,\n    alpha: abs.opacity,\n  }\n}\n\nfunction fromLibrary<T extends ParsingOptions<Rgb>>(rgb: C.RGB, parsingOptions: T):\n  T extends { scalar: true } ? RgbScalar : Rgb8Bit\n\nfunction fromLibrary(rgb: C.RGB, parsingOptions: ParsingOptions<Rgb> = {}): Rgb8Bit | RgbScalar {\n  if (parsingOptions.scalar) {\n    return {\n      r: rgb.r / 255,\n      g: rgb.g / 255,\n      b: rgb.b / 255,\n      opacity: rgb.alpha ?? 1,\n      unit: `scalar`,\n      space: `srgb`\n    }\n  } else {\n    return {\n      r: rgb.r,\n      g: rgb.g,\n      b: rgb.b,\n      opacity: rgb.alpha ?? 255,\n      unit: `8bit`,\n      space: `srgb`\n    }\n  }\n}\n\n\nexport const to8bit = (rgbOrString: Rgb | string): Rgb8Bit => {\n  if (typeof rgbOrString === `string`) {\n    return fromCss(rgbOrString, { scalar: false });\n  }\n  if (isHsl(rgbOrString)) {\n    return to8bit(fromLibrary(hslToLibraryRgb(rgbOrString), { scalar: false }));\n  }\n  guard(rgbOrString);\n  if (rgbOrString.unit === `8bit`) return rgbOrString;\n  return {\n    r: rgbOrString.r * 255,\n    g: rgbOrString.g * 255,\n    b: rgbOrString.b * 255,\n    opacity: (rgbOrString.opacity ?? 1) * 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nexport const toScalar = (rgbOrString: Rgb | Hsl | string): RgbScalar => {\n  if (typeof rgbOrString === `string`) {\n    return fromCss(rgbOrString, { scalar: true });\n  }\n  if (isHsl(rgbOrString)) {\n    return toScalar(fromLibrary(hslToLibraryRgb(rgbOrString), { scalar: true }));\n  }\n  guard(rgbOrString);\n  if (rgbOrString.unit === `scalar`) return rgbOrString;\n  return {\n    r: rgbOrString.r / 255,\n    g: rgbOrString.g / 255,\n    b: rgbOrString.b / 255,\n    opacity: (rgbOrString.opacity ?? 1) / 255,\n    unit: `scalar`,\n    space: `srgb`\n  }\n}\n\nexport const guard = (rgb: Rgb) => {\n  const { r, g, b, opacity, space, unit } = rgb;\n  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${ space }`);\n  if (unit === `8bit`) {\n    resultThrow(\n      numberInclusiveRangeTest(r, 0, 255, `r`),\n      numberInclusiveRangeTest(g, 0, 255, `g`),\n      numberInclusiveRangeTest(b, 0, 255, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 255, `opacity`);\n        }\n      }\n    );\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(r, `percentage`, `r`),\n      numberTest(g, `percentage`, `g`),\n      numberTest(b, `percentage`, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\n/**\n * Sets the lightness value.\n * \n * Amount to change:\n * * 'fixed': a fixed amount\n * * 'delta': increase/decrease by this amount\n * * 'pdelta': proportion of current value to change by ('percentage delta')\n * \n * Use negative values to decrease\n * @param rgb Colour\n * @param amount Amount to change\n */\nexport const changeLightness = (rgb: Rgb, amount: Partial<{ pdelta: number, delta: number, fixed: number }>): Rgb => {\n  let newL = 0;\n  const co = new Colorizr(toCssString(rgb));\n  const scalarUnit = rgb.unit === `scalar`;\n  if (typeof amount.pdelta !== `undefined`) {\n    newL = co.oklab.l + (co.oklab.l * amount.pdelta);\n  } else if (typeof amount.delta !== `undefined`) {\n    newL = co.oklab.l + amount.delta;\n  } else if (typeof amount.fixed !== `undefined`) {\n    if (amount.fixed < 0) throw new TypeError(`Amount cannot be negative when using 'fixed'`);\n    newL = amount.fixed;\n  } else {\n    throw new TypeError(`Parameter 'amount' is missing 'pdelta/delta/fixed' properties`);\n  }\n  if (newL < 0) newL = 0;\n  else if (newL > 1) newL = 1;\n\n  const rgbResult = C.oklab2rgb({ a: co.oklab.a, b: co.oklab.b, l: newL, alpha: co.oklab.alpha });\n  return fromLibrary(rgbResult, { scalar: scalarUnit });\n  //return eightBit ? fromLibrary8bit(rgbResult) : fromLibraryScalar(rgbResult);\n}\n\n/**\n * Returns a lightness value (0..1) for an RGB input\n * \n * Calculates lightness by converting to Oklab and using the 'L' value\n * @param rgb \n * @returns \n */\nexport function lightness(rgb: Rgb) {\n  const co = new Colorizr(toCssString(rgb));\n  return co.oklab.l;\n}\n\nconst scaleProperty = (rgb: Rgb, value: number, property: `r` | `g` | `b` | `opacity`) => {\n  if (rgb.unit === `scalar`) {\n    // 0..1 scale\n    if (value > 1) value = 1;\n    else if (value < 0) value = 0;\n  } else {\n    // 0..255 scale\n    if (value > 255) value = 255;\n    else if (value < 0) value = 0;\n  }\n  return value;\n}\n\n/**\n * Creates a Rgb8Bit value from 8bit (0..255) values\n * @param red \n * @param green \n * @param blue \n * @param opacity \n * @returns \n */\nexport function eightBit(red = 100, green = 100, blue = 100, opacity = 255): Rgb8Bit {\n  const rgb: Rgb8Bit = {\n    unit: `8bit`,\n    space: `srgb`,\n    r: red,\n    g: green,\n    b: blue,\n    opacity: opacity\n  }\n  guard(rgb);\n  return rgb;\n}\n\n/**\n * Creates a RgbScalar value from scalar (0..1) values\n * @param red \n * @param green \n * @param blue \n * @param opacity \n * @returns \n */\nexport function scalar(red = 0.5, green = 0.5, blue = 0.5, opacity = 1): RgbScalar {\n  const rgb: RgbScalar = {\n    unit: `scalar`,\n    space: `srgb`,\n    r: red,\n    g: green,\n    b: blue,\n    opacity: opacity\n  }\n  guard(rgb);\n  return rgb;\n}\n\n\n/**\n * It seems Colorizr can't handle % values properly :'(\n * @param value \n */\nexport function parseCssRgbFunction(value: string): Rgb {\n  if (value.startsWith(`rgba`)) throw new Error(`RGBA is not supported`);\n  if (!value.startsWith(`rgb(`)) throw new Error(`Expected rgb(..) CSS colour`);\n\n  const start = value.indexOf('(');\n  const end = value.indexOf(')');\n  if (end < start) throw new Error(`Is rgb() not terminated? Missing ')'`);\n\n  const part = value.substring(start + 1, end);\n  let split = part.split(/[\\s,]+/);\n  if (split.length < 3) throw new Error(`Expected three tokens. Got: ${ split.length } length`);\n\n  let relativeCount = 0;\n  for (const s of split) {\n    if (s.endsWith('%')) relativeCount++;\n  }\n\n  const valueAsScalar = (v: string, pos: number) => {\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100;\n    }\n    if (pos < 3) {\n      // r, g or b\n      return Number.parseFloat(v) / 255;\n    } else {\n      // opacity should already be in scalar value\n      return Number.parseFloat(v);\n    }\n  }\n\n  const valueAs8bit = (v: string, pos: number) => {\n    if (v.endsWith(`%`)) {\n      return Number.parseFloat(v.substring(0, v.length - 1)) / 100 * 255;\n    }\n    if (pos < 3) {\n      // r, g or b\n      return Number.parseFloat(v);\n    } else {\n      // opacity should already be in scalar value\n      return Number.parseFloat(v) * 255;\n    }\n  }\n\n  // Is there opacity?\n  if (split.length > 3) {\n    if (split[ 3 ] === '/') {\n      // Remove / part\n      split = [ split[ 0 ], split[ 1 ], split[ 2 ], split[ 4 ] ];\n    }\n  }\n  if (relativeCount > 1) {\n    // Return as scalar\n    return scalar(\n      valueAsScalar(split[ 0 ], 0),\n      valueAsScalar(split[ 1 ], 1),\n      valueAsScalar(split[ 2 ], 2),\n      valueAsScalar(split[ 3 ] ?? `1`, 3)\n    )\n  } else {\n    // Return as 8bit\n    return eightBit(\n      valueAs8bit(split[ 0 ], 0),\n      valueAs8bit(split[ 1 ], 1),\n      valueAs8bit(split[ 2 ], 2),\n      valueAs8bit(split[ 3 ] ?? `1`, 3)\n    )\n  }\n}\n\n/**\n * Interpolates colours in Srgb space. Probably\n * really ugly, use OkLch space isntead.\n * \n * ```js\n * const i = interpolator(`red`, `blue`);\n * i(0.5); // Get 50% between these colours\n * ```\n * @param colourA \n * @param colourB \n * @returns \n */\nexport const interpolator = (colourA: Rgb | string, colourB: Rgb | string) => {\n  const aa = toScalar(colourA);\n  const bb = toScalar(colourB);\n\n  const aOpacity = aa.opacity ?? 1;\n  const opacityDistance = (bb.opacity ?? 1) - aOpacity;\n\n  const r = bb.r - aa.r;\n  const g = bb.g - aa.g;\n  const b = bb.b - aa.b;\n\n  return (amount: number): RgbScalar => {\n    amount = clamp(amount);\n    return scalar(\n      aa.r + interpolate(amount, 0, r),\n      aa.g + interpolate(amount, 0, g),\n      aa.b + interpolate(amount, 0, b),\n      aOpacity + interpolate(amount, 0, opacityDistance));\n  }\n}\n\n/**\n * Converts a Rgb structure (or CSS string) to Colorizr's HSL format\n * @param rgb \n * @returns \n */\nexport function toLibraryHsl(rgb: Rgb | string): C.HSL {\n  if (typeof rgb === `string`) {\n    const parseResult = fromCss(rgb, { scalar: false });\n    return toLibraryHsl(parseResult);\n  }\n  rgb = to8bit(rgb);\n  const hsl = C.rgb2hsl({ r: rgb.r, g: rgb.g, b: rgb.b });\n  return { ...hsl, alpha: (rgb.opacity ?? 255) / 255 };\n}","import { Grids } from '@ixfx/geometry';\nimport * as SrgbSpace from './colour/srgb.js';\nimport type { Rgb, Rgb8Bit } from './colour/types.js';\n\n/**\n * Returns a {@link https://api.ixfx.fun/_ixfx/geometry/Grids/Grid/} based on the provided `image`\n * @param image ImageData\n * @returns Grid\n */\nexport const grid = (image: ImageData): Grids.Grid => {\n  const g = { rows: image.width, cols: image.height };\n  return g;\n}\n\n/**\n * Returns an object that allows get/set grid semantics on the underlying `image` data.\n * Uses 8-bit sRGB values, meaning 0..255 range for red, green, blue & opacity.\n * \n * ```js\n * // Get CANVAS element, drawing context and then image data\n * const canvasEl = document.querySelector(`#my-canvas`);\n * const ctx = canvasEl.getContext(`2d`);\n * const imageData = ctx.getImageData();\n * \n * // Now that we have image data, we can wrap it:\n * const asGrid = ImageDataGrid.wrap(imageData);\n * asGrid.get({ x:10, y: 20 }); // Get pixel at 10,20\n * asGrid.set(colour, { x:10, y: 20 }); // Set pixel value\n * \n * // Display changes back on the canvas\n * ctx.putImageData(imageData, 0, 0)\n * ```\n * @param image \n * @returns \n */\nexport const wrap = (image: ImageData): Grids.GridWritable<Rgb8Bit> & Grids.GridReadable<Rgb8Bit> => {\n  return {\n    ...grid(image),\n    get: accessor(image),\n    set: setter(image)\n  }\n}\n\n/**\n * Returns a function to access pixel values by x,y\n * @param image \n * @returns \n */\nexport const accessor = (image: ImageData): Grids.GridCellAccessor<Rgb8Bit> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellAccessor<Rgb8Bit> = (cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) return;\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      unit: `8bit`,\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns a function that sets pixel values\n * @param image \n * @returns \n */\nexport const setter = (image: ImageData): Grids.GridCellSetter<Rgb> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellSetter<Rgb> = (value: Rgb, cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) throw new Error(`Cell out of range. ${ cell.x },${ cell.y }`);\n    const pixel = SrgbSpace.to8bit(value);\n    const pxIndex = index * 4;\n    data[ pxIndex ] = pixel.r;\n    data[ pxIndex + 1 ] = pixel.g;\n    data[ pxIndex + 2 ] = pixel.b;\n    data[ pxIndex + 3 ] = pixel.opacity ?? 255;\n  };\n  return fn;\n}\n\n// export function* visit(image: ImageData, visitor: Grids.VisitGenerator) {\n//   const a = accessor(image);\n\n//   for (const cell of visitor) {\n//     yield a(cell, `undefined`);\n//   }\n// }\n\n/**\n * Yields pixels of an image row by row\n * @param image \n */\nexport function* byRow(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  const v = Grids.As.rows(g, { x: 0, y: 0 });\n  for (const row of v) {\n    const pixels = row.map(p => a(p, `undefined`));\n    yield pixels\n  }\n}\n\n/**\n * Yields pixels of an image column by column\n * @param image \n */\nexport function* byColumn(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  for (let x = 0; x < g.cols; x++) {\n    const col: Rgb8Bit[] = [];\n    for (let y = 0; y < g.rows; y++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) col.push(p);\n    }\n    yield col;\n  }\n}","import { ElementSizer, resolveEl, type ElementResizeLogic, type ElementSizerOptions } from '@ixfx/dom';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport type { ScaleBy, ScalerCombined } from '@ixfx/geometry';\nimport type { Rect, RectPositioned } from '@ixfx/geometry/rect';\nimport { Rects, scaler } from '@ixfx/geometry';\nimport * as Drawing from './drawing.js';\nimport * as ImageDataGrid from './image-data-grid.js';\nimport { cloneFromFields } from '@ixfx/core/records';\nimport type { Grid } from '@ixfx/geometry/grid';\nimport type { DrawingHelper } from './types.js';\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n\n  resized: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n  /**\n   * Pointerdown. \n   * \n   * Adds logicalX/Y to get logical pixel coordinate\n   */\n  pointerdown: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointerup. \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointerup: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointermove \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointermove: PointerEvent & { physicalX: number, physicalY: number },\n}\n\n\n/**\n * CanvasHelper options\n */\nexport type CanvasHelperOptions = Readonly<{\n  containerEl?: HTMLElement\n  /**\n   * Automatic canvas resizing logic.\n   */\n  resizeLogic?: ElementResizeLogic\n  /**\n   * By default, the helper emits pointer events from the canvas.\n   * Set this to _true_ to disable.\n   */\n  disablePointerEvents: boolean\n  /**\n   * By default the display DPI is used for scaling.\n   * If this is set, this will override.\n   */\n  pixelZoom: number\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  skipCss: boolean;\n  coordinateScale: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  onResizing?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  onResized?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Logical width of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  width: number\n  /**\n   * Logical height of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  zIndex: number\n  /**\n   * Colour space to use. Defaults to sRGB.\n   */\n  colourSpace: PredefinedColorSpace;\n\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx Drawing context\n   * @param size Viewport size\n   * @param helper CanvasHelper instance\n   * @returns \n   */\n  draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n}>;\n\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, draw });\n * ```\n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasHelperOptions\n\n  #scaler: ScalerCombined;\n  #scalerSize: ScalerCombined;\n  #viewport: RectPositioned = Rects.EmptyPositioned;\n  #logicalSize: Rect = Rects.Empty;\n  #ctx: CanvasRenderingContext2D | undefined;\n  #drawHelper: DrawingHelper | undefined;\n  #resizer: ElementSizer<HTMLCanvasElement> | undefined;\n  #disposed = false;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasHelperOptions> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined. Expected canvas element.`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n\n    const size = this.el.getBoundingClientRect();\n    this.opts = {\n      resizeLogic: opts.resizeLogic ?? `none`,\n      disablePointerEvents: opts.disablePointerEvents ?? false,\n      pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),\n      height: opts.height ?? size.height,\n      width: opts.width ?? size.width,\n      zIndex: opts.zIndex ?? -1,\n      coordinateScale: opts.coordinateScale ?? `both`,\n      onResizing: opts.onResizing,\n      onResized: opts.onResized,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false,\n      colourSpace: `srgb`\n    }\n\n    this.#scaler = scaler(`both`);\n    this.#scalerSize = scaler(`both`, size);\n    this.#init();\n  }\n\n  getRectangle(): RectPositioned {\n    return {\n      x: 0, y: 0,\n      ...this.#logicalSize\n    }\n  }\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizer) {\n      this.#resizer.dispose(`CanvasHelper disposing ${ reason }`.trim());\n      this.#resizer = undefined;\n    }\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  /**\n   * Gets the drawable area of the canvas.\n   * This accounts for scaling due to high-DPI displays etc.\n   * @returns \n   */\n  getPhysicalSize() {\n    return {\n      width: this.width * this.ratio,\n      height: this.height * this.ratio\n    }\n  }\n\n  /**\n   * Creates a drawing helper for the canvas.\n   * If one is already created it is reused.\n   */\n  getDrawHelper() {\n    if (!this.#drawHelper) {\n      this.#drawHelper = Drawing.makeHelper(this.#getContext(), {\n        width: this.width, height: this.height\n      });\n    }\n  }\n\n  setLogicalSize(logicalSize: Rect) {\n    Rects.guard(logicalSize, `logicalSize`);\n    const logicalSizeInteger = Rects.applyFields(v => Math.floor(v), logicalSize);\n    const ratio = this.opts.pixelZoom;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = scaler(this.opts.coordinateScale, logicalSize);\n    this.#scalerSize = scaler(`both`, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = Rects.multiplyScalar(logicalSize, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSizeInteger.width.toString() + `px`;\n    this.el.style.height = logicalSizeInteger.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#logicalSize = logicalSizeInteger;\n\n    //console.log(`setting logical size to ${ this.#logicalSize.width }x${ this.#logicalSize.height }`);\n\n    // Notify listeners of resize\n    // const r = this.opts.onResizing;\n    // if (r) {\n    //   setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    // }\n    if (this.opts.onResizing) {\n      this.opts.onResizing(this.ctx, this.size, this);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n\n  #init() {\n    //console.log(`init`, this.opts);\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#logicalSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n\n    if (!this.opts.disablePointerEvents) {\n      this.#handleEvents();\n    }\n\n    const resizeLogic = this.opts.resizeLogic ?? `none`;\n    if (resizeLogic === `none`) {\n      this.setLogicalSize({ width: this.opts.width, height: this.opts.height });\n    } else {\n      const resizerOptions: ElementSizerOptions<HTMLCanvasElement> = {\n        onSizeChanging: (size) => {\n          if (Rects.isEqual(this.#logicalSize, size)) return;\n          this.setLogicalSize(size);\n        },\n        onSizeDone: (size, el) => {\n          this.#onResizeDone(size);\n        },\n        containerEl: this.opts.containerEl,\n        naturalSize: { width: this.opts.width, height: this.opts.height },\n        stretch: this.opts.resizeLogic ?? `none`\n      };\n      this.#resizer = new ElementSizer(this.el, resizerOptions);\n    }\n\n    this.#getContext();\n  }\n\n  #onResizeDone(size: Rect) {\n    if (this.opts.onResized) this.opts.onResized(this.ctx, this.size, this);\n    this.fireEvent(`resized`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n  #handleEvents() {\n    const handlePointerEvent = (event: PointerEvent) => {\n      const { offsetX, offsetY } = event;\n      const physicalX = offsetX * this.ratio;\n      const physicalY = offsetY * this.ratio;\n      event = cloneFromFields(event);\n      const eventData = {\n        physicalX, physicalY,\n        // eslint-disable-next-line @typescript-eslint/no-misused-spread\n        ...event\n      };\n\n      switch (event.type) {\n        case `pointerup`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n        case `pointermove`: {\n          {\n            this.fireEvent(`pointermove`, eventData);\n            break;\n          };\n        }\n        case `pointerdown`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n      };\n    }\n\n    this.el.addEventListener(`pointermove`, handlePointerEvent);\n    this.el.addEventListener(`pointerdown`, handlePointerEvent);\n    this.el.addEventListener(`pointerup`, handlePointerEvent);\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `ctx.clearRect(0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (!this.#ctx) return;\n    this.#ctx.clearRect(0, 0, this.width, this.height);\n\n  }\n\n  /**\n   * Fills the canvas with a given colour.\n   * \n   * Shortcut for:\n   * ```js\n      * ctx.fillStyle = ``;\n   * ctx.fillRect(0, 0, this.width, this.height);\n   * ```\n   * @param colour Colour\n   */\n  fill(colour?: string) {\n    if (!this.#ctx) return;\n    if (colour) this.#ctx.fillStyle = colour;\n    this.#ctx.fillRect(0, 0, this.width, this.height);\n\n  }\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#logicalSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#logicalSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n\n\n  drawBounds(strokeStyle = `green`) {\n    const ctx = this.#getContext();\n    Drawing.rect(ctx,\n      { x: 0, y: 0, width: this.width, height: this.height },\n      { crossed: true, strokeStyle, strokeWidth: 1 });\n\n    Drawing.rect(ctx, this.#viewport, { crossed: true, strokeStyle: `silver`, strokeWidth: 3 })\n  }\n\n  /**\n   * Returns a Scaler that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n      * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toAbsoluteFixed() {\n    return this.#scalerSize.abs\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toRelativeFixed() {\n    return this.#scalerSize.rel;\n  }\n\n  get logicalCenter() {\n    return {\n      x: this.#logicalSize.width / 2,\n      y: this.#logicalSize.height / 2\n    }\n  }\n\n  /**\n * Returns a Scaler that converts from relative to absolute\n * coordinates.\n * This is based on the canvas size.\n * \n * ```js\n * // Assuming a canvas of 800x600\n * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n * ```\n */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n\n  /**\n   * Gets the image data for the canvas.\n   * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be\n   * 536x536 with a high-DPI display.\n   * @returns \n   */\n  getImageData(): ImageData {\n    const size = this.getPhysicalSize();\n    const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });\n\n    if (data === null || data === undefined) throw new Error(`Could not get image data from context`);\n    return data;\n  }\n\n  /**\n   * Returns the canvas frame data as a writable grid.\n   * When editing, make as many edits as needed before calling\n   * `flip`, which writes buffer back to the canvas.\n   * ```js\n      * const g = helper.getWritableBuffer();\n   * // Get {r,g,b,opacity} of pixel 10,10\n   * const pixel = g.get({ x: 10, y: 10 });\n   * \n   * // Set a colour to pixel 10,10\n   * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });\n   * \n   * // Write buffer to canvas\n   * g.flip();\n   * ```\n   * \n   * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will\n   * mean a higher number of rows and columns compared to the logical size.\n   * @returns\n   */\n  getWritableBuffer() {\n    const ctx = this.ctx;\n    const data = this.getImageData();\n    const grid = ImageDataGrid.grid(data);\n    const get = ImageDataGrid.accessor(data);\n    const set = ImageDataGrid.setter(data);\n\n    const flip = () => {\n      ctx.putImageData(data, 0, 0);\n    }\n\n    return { grid, get, set, flip };\n  }\n}\n\n// export const imageDataAsGrid = (canvas: HTMLCanvasElement, colorSpace: PredefinedColorSpace = `srgb`) => {\n//   const ctx = canvas.getContext(`2d`);\n//   if (!ctx) throw new Error(`Could not create context`);\n\n//   const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace });\n//   if (!data) throw new Error(`Could not get image data from context`);\n\n//   const get = ImageDataGrid.accessor(data);\n//   const set = ImageDataGrid.setter(data);\n// }","export const piPi = Math.PI*2;","import { scalerTwoWay, clamp } from \"@ixfx/numbers\";\nimport { resolveEl, resolveElementTry } from \"@ixfx/dom\";\nimport { resultErrorToString } from \"@ixfx/guards\";\nimport type { Rect, RectPositioned } from \"@ixfx/geometry/rect\";\nimport type { Point } from \"@ixfx/geometry/point\";\nimport { Points, Rects } from \"@ixfx/geometry\";\nimport type { CirclePositioned } from \"@ixfx/geometry/circle\";\nimport { piPi } from \"./pi-pi.js\";\n\nexport type CanvasRegionSpecRelativePositioned = {\n  relativePositioned: RectPositioned\n  scale?: `independent`\n}\n\nexport type CanvasRegionSpecAbsolutePositioned = {\n  absPositioned: RectPositioned\n}\n\nexport type CanvasRegionSpecRelativeSized = {\n  relativeSize: Rect\n  scale?: `independent`\n  /**\n   * Cardinal directions, or 'center' (default)\n   */\n  position: `center` | `n` | `s`\n}\n\nexport type CanvasRegionSpecMatched = {\n  match: HTMLElement | string\n}\n\nexport type CanvasRegionSpec = { marginPx?: number } & (CanvasRegionSpecAbsolutePositioned | CanvasRegionSpecRelativePositioned | CanvasRegionSpecRelativeSized | CanvasRegionSpecMatched);\n\n/**\n * Manges the drawing for a region of a canvas\n */\nexport class CanvasSource {\n  #canvasEl: HTMLCanvasElement;\n  #ctx: undefined | CanvasRenderingContext2D;\n  #sizeBasis: `min` | `max`;\n  #sizeScaler;\n  #logicalSize: Rect;\n  #pixelScaling: number;\n\n  #regions: CanvasRegion[] = [];\n\n  constructor(canvasElementOrQuery: HTMLCanvasElement | string, sizeBasis: `min` | `max` = `min`) {\n    this.#canvasEl = resolveEl<HTMLCanvasElement>(canvasElementOrQuery);\n    this.#sizeBasis = sizeBasis;\n    this.#pixelScaling = window.devicePixelRatio || 1;\n    this.#sizeScaler = this.#createSizeScaler();\n    this.#logicalSize = this.setLogicalSize({ width: this.#canvasEl.width, height: this.#canvasEl.height });\n  }\n\n\n  /**\n   * Set logical size for region\n   * @param size\n   * @returns \n   */\n  setLogicalSize(size: Rect) {\n    this.#logicalSize = size;\n    const el = this.#canvasEl;\n    el.width = (size.width * this.#pixelScaling);\n    el.height = (size.height * this.#pixelScaling);\n\n    el.style.width = `${ (size.width).toString() }px`;\n    el.style.height = `${ (size.height).toString() }px`;\n    this.#sizeScaler = this.#createSizeScaler();\n    this.invalidateContext();\n    return size;\n  }\n\n\n  #createSizeScaler() {\n    let inMax = 1;\n    switch (this.#sizeBasis) {\n      case `min`:\n        inMax = Math.min(this.#canvasEl.width, this.#canvasEl.height);\n        break;\n      case `max`:\n        inMax = Math.max(this.#canvasEl.width, this.#canvasEl.height);\n        break;\n    }\n    const s = scalerTwoWay(0, inMax, 0, 1);\n    return {\n      abs: s.in,\n      rel: s.out\n    }\n  }\n\n  /**\n   * Causes drawing context to be re-created\n   */\n  invalidateContext() {\n    this.#ctx = undefined;\n  }\n\n  #add(region: CanvasRegion) {\n    if (!region) throw new Error(`Param 'region' is undefined/null`);\n    if (this.#regions.includes(region)) throw new Error(`Region already exists`);\n    this.#regions.push(region);\n    return region;\n  }\n\n\n  /**\n   * Convert relative to absolute\n   * @param pt \n   * @param kind \n   * @returns \n   */\n  toAbsPoint(pt: Point, kind: `independent` = `independent`) {\n    let { x, y } = pt;\n    switch (kind) {\n      case `independent`:\n        x *= this.width;\n        y *= this.height;\n\n    }\n    return { x, y };\n  }\n\n  /**\n   * Gets the offset x,y\n   */\n  get offset() {\n    const b = this.#canvasEl.getBoundingClientRect();\n    return { x: b.left, y: b.top };\n  }\n\n  /**\n   * Converts an absolute point to relative\n   * @param pt \n   * @param source \n   * @param kind \n   * @param clamped \n   * @returns \n   */\n  toRelPoint(pt: Point, source: `screen` | `source`, kind: `independent` | `skip` = `independent`, clamped = true) {\n    let { x, y } = pt;\n    if (source === `screen`) {\n      const b = this.#canvasEl.getBoundingClientRect();\n      x -= b.x;\n      y -= b.y;\n    }\n    switch (kind) {\n      case `independent`:\n        x /= this.width;\n        y /= this.height;\n        break;\n      case `skip`:\n        break;\n    }\n    if (clamped) {\n      x = clamp(x);\n      y = clamp(y);\n    }\n    return { x, y };\n  }\n\n  /**\n   * Converts a rectangle to absolute coordinates\n   * @param rect \n   * @param kind \n   * @returns \n   */\n  toAbsRect(rect: Rect | RectPositioned, kind: `independent` = `independent`) {\n    let { width, height } = rect;\n    switch (kind) {\n      case `independent`:\n        width *= this.width;\n        height *= this.height;\n        if (Rects.isRectPositioned(rect)) {\n          return {\n            ...this.toAbsPoint(rect),\n            width,\n            height\n          }\n        }\n    }\n    return { width, height }\n  }\n\n\n  /**\n   * Creates a region\n   * \n   * Absolute positioned. Uses source coordinates which don't change\n   * ```js\n   * source.createRegion({ \n   *  absPositioned: { x: 0, y: 0, width: 100, height: 100} \n   * });\n   * ```\n   * \n   * Relative positioned. Uses coordiantes relative to source dimensions.\n   * Updated if source changes.\n   * ```js\n   * source.createRegion({\n   *  relativePositioned: { x: 0, y:0, width: 1, height: 0.5 },\n   *  scale: `independent`\n   * });\n   * ```\n   * \n   * Relative sized. Uses size relative to source dimension. By default centers.\n   * ```js\n   * source.createRegion({\n   *  relativeSize: { width: 0.5, height: 0.5 }\n   *  position: `center`\n   * })\n   * ```\n   * @param spec \n   * @returns \n   */\n  createRegion(spec: CanvasRegionSpec) {\n    const marginPx = spec.marginPx ?? 0;\n    const marginPx2 = marginPx * 2;\n    if (`absPositioned` in spec) {\n      const rect = Rects.subtractSize(spec.absPositioned, marginPx, marginPx);\n      return this.#add(new CanvasRegion(this, () => rect))\n    }\n\n    if (`relativePositioned` in spec) {\n      let compute: ((source: CanvasSource) => RectPositioned);\n      const rect = spec.relativePositioned;\n      switch (spec.scale) {\n        case `independent`:\n          compute = (source: CanvasSource): RectPositioned => ({\n            x: (rect.x * source.width) + marginPx,\n            y: (rect.y * source.height) + marginPx,\n            width: (rect.width * source.width) - marginPx2,\n            height: (rect.height * source.height) - marginPx2\n          });\n          break;\n        default:\n          throw new Error(`Param 'kind' unknown (${ spec.scale })`);\n      }\n      return this.#add(new CanvasRegion(this, compute));\n    }\n\n    if (`relativeSize` in spec) {\n      let compute: ((source: CanvasSource) => RectPositioned);\n      const rect = spec.relativeSize;\n      const position = spec.position;\n\n      switch (spec.scale) {\n        case `independent`:\n          compute = (source: CanvasSource): RectPositioned => {\n            const width = (rect.width * source.width) - marginPx2;\n            const height = (rect.height * source.height) - marginPx2;\n            let x = source.width / 2 - width / 2;\n            let y = source.height / 2 - height / 2;\n            switch (position) {\n              case `n`:\n                y = 0;\n                break;\n              case `s`:\n                y = source.height - height;\n                break;\n              default:\n              /** no-op, */\n            }\n            x += marginPx;\n            y += marginPx;\n            return { width, height, x, y }\n          }\n          break;\n        default:\n          throw new Error(`Param 'kind' unknown (${ spec.scale })`);\n      }\n      return this.#add(new CanvasRegion(this, compute));\n    }\n\n    if (`match` in spec) {\n      const result = resolveElementTry(spec.match);\n      if (!result.success) {\n        throw new Error(`Could not resolve match element. ${ resultErrorToString(result) }`);\n      }\n      const compute = (_source: CanvasSource): RectPositioned => {\n        const bounds = result.value.getBoundingClientRect();\n        return {\n          x: bounds.x + marginPx,\n          y: bounds.y + marginPx,\n          width: bounds.width - marginPx2,\n          height: bounds.height - marginPx2\n        }\n      }\n      return this.#add(new CanvasRegion(this, compute));\n    }\n    throw new Error(`Spec doesn't seem valid`);\n  }\n\n  /**\n   * Clears the region of the canvas\n   */\n  clear() {\n    const c = this.context;\n    c.clearRect(0, 0, this.width, this.height);\n  }\n\n  /**\n   * Gets - or creates - the drawing context\n   */\n  get context() {\n    if (this.#ctx) return this.#ctx;\n    const c = this.#canvasEl.getContext(`2d`);\n    if (!c) throw new Error(`Could not create 2d context`);\n    c.setTransform(1, 0, 0, 1, 0, 0);\n    c.scale(this.#pixelScaling, this.#pixelScaling);\n\n    this.#ctx = c;\n\n    for (const r of this.#regions) {\n      r.recomputeRegion();\n    }\n    return this.#ctx;\n  }\n\n  /**\n   * Gets a scaler for size\n   */\n  get sizeScaler() {\n    return this.#sizeScaler;\n  }\n\n  /**\n   * Gets the logical width\n   */\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  /**\n   * Gets the logical height\n   */\n  get height() {\n    return this.#logicalSize.height;\n  }\n}\n\n/**\n * Draws on a canvas, constrained to a specific region\n */\nexport class CanvasRegion {\n  source: CanvasSource;\n  #regionCompute: (parent: CanvasSource) => RectPositioned;\n  #r: RectPositioned;\n\n  /**\n   * Creates, using coordinate in canvas coordinates\n   */\n  constructor(source: CanvasSource, regionCompute: (parent: CanvasSource) => RectPositioned) {\n    this.source = source;\n    this.#regionCompute = regionCompute;\n    this.#r = regionCompute(source);\n  }\n\n  /**\n   * Calls the original `regionCompute` function passed in to the constructor\n   * to recompute the absolute region\n   */\n  recomputeRegion() {\n    this.#r = this.#regionCompute(this.source);\n  }\n\n  /**\n   * Converts a region-relative point (0..1) to an absolute\n   * point, which uses region-relative coordinates.\n   * \n   * Eg if the region had an x,y of 100,100, `toAbsRegion({x:0,y:0})`\n   * will return 0,0.\n   *\n   * @param regionRel \n   * @param scaleBy \n   * @returns \n   */\n  toAbsRegion(regionRel: Point, scaleBy: `both` = `both`) {\n    switch (scaleBy) {\n      case `both`:\n        return {\n          x: regionRel.x * this.#r.width,\n          y: regionRel.y * this.#r.height\n        }\n        break;\n    }\n  }\n\n  /**\n   * Returns a copy of `p` offset by the region's x & y\n   * @param p \n   * @returns \n   */\n  applyRegionOffset(p: Point) {\n    return {\n      x: p.x + this.#r.x,\n      y: p.y + this.#r.y\n    }\n  }\n\n  /**\n   * Draws a line from a series of points.\n   * Assumes region-relative, % coordinates (ie 0..1 scale)\n   * @param relativePoints Points to connect, in region-relative coordinates\n   * @param strokeStyle Stroke style\n   * @param lineWidth Line with\n   */\n  drawConnectedPointsRelative(relativePoints: Point[], strokeStyle: string, lineWidth = 1) {\n    const points = relativePoints.map(p => this.toAbsRegion(p));\n    this.drawConnectedPoints(points, strokeStyle, lineWidth);\n  }\n\n  /**\n   * Draws connected points in absolute coordinates,\n   * however with 0,0 being the top-left of the region.\n   * \n   * Thus, this will apply the region offset before drawing.\n   * @param points Points to draw\n   * @param strokeStyle Stroke style\n   * @param lineWidth Line width\n   */\n  drawConnectedPoints(points: Point[], strokeStyle: string, lineWidth = 1) {\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    c.beginPath();\n    c.strokeStyle = strokeStyle;\n    c.lineWidth = lineWidth;\n    for (let index = 0; index < points.length; index++) {\n      if (index === 0) {\n        c.moveTo(points[ index ].x, points[ index ].y);\n      } else {\n        c.lineTo(points[ index ].x, points[ index ].y);\n      }\n    }\n    c.stroke();\n    c.restore();\n  }\n\n  /**\n   * Fills text at a relative position\n   * @param text \n   * @param relPos Relative, meaning 0.5,0.5 is the middle of the region\n   * @param fillStyle \n   * @param baseline \n   * @param align \n   */\n  fillTextRelative(text: string, relPos: Point, fillStyle = `black`, font: string, baseline: CanvasTextBaseline = `alphabetic`, align: CanvasTextAlign = `start`) {\n    const point = this.toAbsRegion(relPos);\n    this.fillTextRelative(text, point, fillStyle, font, baseline, align);\n  }\n\n  /**\n   * Fills text at a region-relative position\n   * @param text \n   * @param point Region relative, meaning 0,0 is top-left of region\n   * @param fillStyle \n   * @param baseline \n   * @param align \n   */\n  fillText(text: string, point: Point, fillStyle = `black`, font: string, baseline: CanvasTextBaseline = `alphabetic`, align: CanvasTextAlign = `start`) {\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    if (font.length > 0) {\n      c.font = font;\n    }\n    c.textBaseline = baseline;\n    c.textAlign = align;\n    c.fillStyle = fillStyle;\n    c.fillText(text, point.x, point.y);\n    c.restore();\n  }\n\n  drawCircles(relativeCircles: CirclePositioned[], fillStyle: string, strokeStyle = ``, lineWidth = 1) {\n    const circles = relativeCircles.map(c => {\n      return {\n        ...this.toAbsRegion(c),\n        radius: this.source.sizeScaler.abs(c.radius)\n      }\n    });\n\n    const c = this.context;\n    c.save();\n    c.translate(this.#r.x, this.#r.y);\n    c.fillStyle = fillStyle;\n    c.strokeStyle = strokeStyle;\n    c.lineWidth = lineWidth;\n\n    for (const circle of circles) {\n      c.beginPath();\n      c.arc(circle.x, circle.y, circle.radius, 0, piPi);\n      c.closePath();\n      if (fillStyle.length > 0) {\n        c.fill();\n      }\n      if (strokeStyle.length > 0) {\n        c.stroke();\n      }\n    }\n    c.restore();\n  }\n\n  /**\n   * Clears the region\n   */\n  clear() {\n    const c = this.context;\n    c.clearRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);\n  }\n\n  /**\n   * Fills the region\n   * @param fillStyle\n   */\n  fill(fillStyle = `white`) {\n    const c = this.context;\n    c.fillStyle = fillStyle;\n    c.fillRect(this.#r.x, this.#r.y, this.#r.width, this.#r.height);\n  }\n\n  /**\n   * For debugging, draws an outline of the bounds\n   * @param strokeStyle \n   * @param lineWidth \n   */\n  drawBounds(strokeStyle: string, lineWidth = 1) {\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 0 },\n      { x: 1, y: 0 },\n      { x: 1, y: 1 },\n      { x: 0, y: 1 },\n      { x: 0, y: 0 }\n    ], strokeStyle, lineWidth);\n\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 1 },\n      { x: 1, y: 0 }\n    ], strokeStyle, lineWidth);\n    this.drawConnectedPointsRelative([\n      { x: 0, y: 0 },\n      { x: 1, y: 1 }\n    ], strokeStyle, lineWidth);\n  }\n\n  /**\n   * Converts a  point to a region-relative one.\n   * @param pt \n   * @param kind \n   * @returns \n   */\n  toRelPoint(pt: Point, source: `screen` | `source` = `screen`, kind: `independent` = `independent`, clamped = true) {\n    pt = this.source.toRelPoint(pt, source, `skip`, false);\n    let { x, y } = pt;\n    x -= this.x;\n    y -= this.y;\n\n    switch (kind) {\n      case `independent`:\n        x /= this.width;\n        y /= this.height;\n    }\n    if (clamped) {\n      x = clamp(x);\n      y = clamp(y);\n    }\n    return { x, y };\n  }\n\n  /**\n   * Converts absolute to region point\n   * @param pt \n   * @param source \n   * @param clamped \n   * @returns \n   */\n  absToRegionPoint(pt: Point, source: `screen`, clamped: boolean) {\n    if (source === `screen`) {\n      pt = Points.subtract(pt, this.source.offset);\n    }\n\n    let { x, y } = pt;\n    x -= this.x;\n    y -= this.y;\n\n    if (clamped) {\n      if (x < 0) x = 0;\n      if (y < 0) y = 0;\n      if (x > this.width + this.x) x = this.x + this.width;\n      if (y > this.height + this.y) y = this.y + this.height;\n    }\n    return { x, y };\n  }\n\n  /**\n   * Get center of region\n   */\n  get center() {\n    return Rects.center(this.#r);\n  }\n\n  /**\n   * Gets the drawing context\n   */\n  get context() {\n    return this.source.context;\n  }\n\n  /**\n   * SEts the region\n   */\n  set region(value: RectPositioned) {\n    this.#r = value;\n  }\n\n  /**\n   * Gets the region\n   */\n  get region() {\n    return this.#r;\n  }\n\n  /**\n   * Gets the width\n   */\n  get width() {\n    return this.#r.width;\n  }\n\n  /**\n   * Gets the height\n   */\n  get height() {\n    return this.#r.height;\n  }\n\n  /**\n   * Gets the x offset\n   */\n  get x() {\n    return this.#r.x;\n  }\n\n  /**\n   * Gets they y offset\n   */\n  get y() {\n    return this.#r.y;\n  }\n\n  /**\n   * Gets the width/height, whichever is smaller\n   */\n  get dimensionMin() {\n    return Math.min(this.#r.width, this.#r.height);\n  }\n}\n","import type { DrawingOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: fillStyle\n * @param elem Element\n * @param opts Drawing options\n */\nexport const applyOpts = (elem: SVGElement, opts: DrawingOpts) => {\n  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);\n  if (opts.opacity) {\n    elem.setAttributeNS(null, `opacity`, opts.opacity.toString());\n  }\n\n};","import { type Rect } from '@ixfx/geometry/rect';\n/**\n * Get the bounds of an SVG element (determined by its width/height attribs)\n * @param svg\n * @returns\n */\nexport const getBounds = (svg: SVGElement): Rect => {\n  const w = svg.getAttributeNS(null, `width`);\n  const width = w === null ? 0 : Number.parseFloat(w);\n  const h = svg.getAttributeNS(null, `height`);\n  const height = h === null ? 0 : Number.parseFloat(h);\n  return { width, height };\n};\n\n/**\n * Set the bounds of an element, using its width/height attribs.\n * @param svg\n * @param bounds\n */\nexport const setBounds = (svg: SVGElement, bounds: Rect): void => {\n  svg.setAttributeNS(null, `width`, bounds.width.toString());\n  svg.setAttributeNS(null, `height`, bounds.height.toString());\n};","/**\n * Creates an element of `type` and with `id` (if specified)\n * @param type Element type, eg `circle`\n * @param id Optional id to assign to element\n * @returns Element\n */\nexport const createEl = <V extends SVGElement>(\n  type: string,\n  id?: string\n): V => {\n  const m = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n  if (id) {\n    m.id = id;\n  }\n  return m;\n};\n\n\n/**\n * Creates and appends a SVG element.\n *\n * ```js\n * // Create a circle\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`);\n * ```\n *\n * If `queryOrExisting` is specified, it is used as a query to find an existing element. If\n * query starts with `#`, this will be set as the element id, if created.\n *\n * ```js\n * // Creates an element with id 'myCircle' if it doesn't exist\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`, `#myCircle`);\n * ```\n * @param parent Parent element\n * @param type Type of SVG element\n * @param queryOrExisting Query, eg `#id`\n * @returns\n */\nexport const createOrResolve = <V extends SVGElement>(\n  parent: SVGElement,\n  type: string,\n  queryOrExisting?: string | V,\n  suffix?: string\n): V => {\n  let existing:SVGElement|HTMLElement|null = null;\n  if (queryOrExisting !== undefined) {\n    existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;\n  }\n  if (existing === null) {\n    const p = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n    parent.append(p);\n    if (queryOrExisting && typeof queryOrExisting === `string` &&\n      queryOrExisting.startsWith(`#`)) {\n      p.id = suffix !== undefined && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);\n    }\n    return p;\n  }\n  return existing as V;\n};","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { type RandomSource } from '@ixfx/random';\nimport { scalar as hslScalar, toCssString } from './hsl.js';\n\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (\n  index: number,\n  saturation = 0.5,\n  lightness = 0.75,\n  alpha = 1\n) => {\n  resultThrow(\n    numberTest(index, `positive`, `index`),\n    numberTest(saturation, `percentage`, `saturation`),\n    numberTest(lightness, `percentage`, `lightness`),\n    numberTest(alpha, `percentage`, `alpha`)\n  );\n  // Via Stackoverflow\n  const hueDeg = index * 137.508; // use golden angle approximation\n  const hueRel = (hueDeg % 360) / 360\n  return toCssString(hslScalar(hueRel, saturation, lightness, alpha));\n  //return alpha === 1 ? `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%)` : `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%,${ alpha * 100 }%)`;\n};\n\n/**\n * Returns a random hue component (0..359)\n * \n * ```\n * // Generate hue\n * const h = randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand: RandomSource = Math.random): number => rand() * 360;\n","import type { Colour, Colourish, Hsl, OkLch, Rgb } from './types.js';\nimport { toColour, toCssColour } from './conversion.js';\nimport * as HslSpace from './hsl.js';\nimport * as SrgbSpace from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\nimport { OklchSpace } from './index.js';\nimport * as C from 'colorizr';\n\nexport function multiplyOpacity<T extends Colourish>(colourish: T, amount: number):\n  T extends string ? string :\n  T extends Hsl ? Hsl :\n  T extends OkLch ? OkLch :\n  T extends Rgb ? Rgb : never\n\n/**\n * Multiplies the opacity of a colour by `amount`, returning a computed CSS colour.\n * \n * ```js\n * multiplyOpacity(`red`, 0.5); // Returns a colour string\n * ```\n * \n * For example, to half the opacity, use `amount: 0.5`.\n * Clamps the result to ensure it's between 0..1\n * @param colourish Colour\n * @param amount Amount\n * @returns \n */\nexport function multiplyOpacity(colourish: Colourish, amount: number): Colourish {\n  return withOpacity(colourish, o => clamp(o * amount));\n}\n\n/**\n * Does a computation with the opacity of a colour, returning colour string\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n//export function withOpacity(colourish: string, fn: (scalarOpacity: number) => number): string;\n\n/**\n * Does a computation with the opacity of a colour in a HSL structure\n * @param hsl Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n//export function withOpacity(hsl: Hsl, fn: (scalarOpacity: number) => number): Hsl;\n\n/**\n * Does a computation with the opacity of a colour in a RGB structure\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\n\n//export function withOpacity(rgb: Rgb, fn: (scalarOpacity: number) => number): Rgb;\nexport function withOpacity<T extends Colourish>(colourish: T, fn: (scalarOpacity: number) => number):\n  T extends string ? string :\n  T extends Hsl ? Hsl :\n  T extends OkLch ? OkLch :\n  T extends Rgb ? Rgb : never\n\n/**\n * Does a computation with the opacity of a colour, returning colour.\n * \n * Passes operation to `HslSpace` or `SrgbSpace` depending on space of `colourish`.\n * @param colourish Colour\n * @param fn Function that takes original opacity as input and returns output opacity\n */\nexport function withOpacity(colourish: Colourish, fn: (scalarOpacity: number) => number): Colourish {\n  const colour = toColour(colourish);\n  let result: Colour | undefined;\n  switch (colour.space) {\n    case `hsl`:\n      result = HslSpace.withOpacity(colour, fn);\n      break;\n    case `srgb`:\n      result = SrgbSpace.withOpacity(colour, fn);\n      break;\n    case `oklch`:\n      result = OklchSpace.withOpacity(colour, fn);\n      break;\n    default:\n      throw new Error(`Unknown space: '${ colour.space }'. Expected hsl, srgb, oklch`)\n  }\n  if (!result) throw new Error(`Is colour in correct form?`);\n\n  // If input type was string, return result as string\n  if (typeof colourish === `string`) {\n    return toCssColour(result);\n  }\n  return result;\n};\n\nexport function setOpacity<T extends Colourish>(colourish: T, amount: number):\n  T extends string ? string :\n  T extends Hsl ? Hsl :\n  T extends OkLch ? OkLch :\n  T extends Rgb ? Rgb : never\n\nexport function setOpacity(colourish: Colourish, opacity: number): Colourish {\n  const colour = toColour(colourish);\n  colour.opacity = opacity;\n  if (typeof colourish === `string`) {\n    return toCssColour(colour);\n  }\n  return colour;\n}\n\n// export function lighten(colour: string, amount: number): string;\n// export function lighten(colour: Colour, amount: number): Colour;\n// export function lighten(colourish: Colourish, amount: number): Colourish {\n//   const asString = toCssColour(colourish);\n//   const result = C.lighten(asString, amount, ``)\n// }\n\n\n\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };","import type { Colour, ColourInterpolationOpts, ColourInterpolator, Colourish, ColourSpaces, ColourStepOpts, Hsl, HslScalar, OkLch, OkLchScalar, RgbScalar } from \"./types.js\";\nimport { pairwise } from '@ixfx/arrays';\nimport * as HslSpace from './hsl.js';\nimport { convert, toCssColour, type ConvertDestinations } from \"./conversion.js\";\nimport { convertScalar, OklchSpace, SrgbSpace } from \"./index.js\";\n\n/**\n * Returns a function to interpolate between colours\n * ```js\n * const i = interpolator([`orange`, `yellow`, `red`]);\n * \n * // Get a random colour on the above spectrum\n * i(Math.random());\n * ```\n * \n * Results will vary depending on the colour space used, play with the options.\n * When using a hue-based colour space, the `hue` option sets the logic for how hue values wrap.\n * \n * ```js\n * interpolator([`orange`, `yellow`, `red`], { space: `hsl`, hue: `longer })\n * ```\n * @param colours Colours to interpolate between\n * @param opts Options for interpolation\n * @returns \n */\n// export const interpolator = (colours: Colourish[], opts: Partial<ColourInterpolationOpts> = {}) => {\n//   const spaceDestination: ConvertDestinations = `oklch-scalar`;\n//   let ranges: Colour[] = [];\n//   const direction = opts.direction ?? `shorter`;\n\n//   switch (opts.space) {\n//     case `hsl`:\n//       ranges = interpolateInit(colours, `hsl-scalar`)\n//         .map(piece => HslSpace.interpolator(piece[ 0 ], piece[ 1 ], direction));\n//       break;\n//     default:\n//       ranges = interpolateInit(colours, `oklch-scalar`)\n//         .map(piece => OklchSpace.interpolator(piece[ 0 ], piece[ 1 ], direction));\n//       break;\n//   }\n\n\n//   return (amt: number): string => {\n//     amt = clamp(amt);\n\n//     // Scale to 0..1 to 0...ranges.length\n//     const s = scaleNumber(amt, 0, 1, 0, ranges.length);\n//     const index = Math.floor(s);\n//     const amtAdjusted = s - index;\n//     const range = ranges[ index ];\n\n//     // If we're at the end, return the last colour\n\n//     if (index === 1) return toHex(colours.at(-1)!);\n\n//     const colour = range(amtAdjusted);\n//     return colour.display();\n\n//   }\n// }\n\n// const interpolatorInit = (colours: Colourish[]) => {\n//   if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n//   if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n//   const c = colours.map(colour => toLibraryColour(colour));\n//   return [ ...pairwise(c) ];\n// }\n\n// function interpolateInit(colours: Colourish[], destination: `oklch-scalar`): OkLchScalar[][];\n// function interpolateInit(colours: Colourish[], destination: `hsl-scalar`): HslScalar[][];\nfunction interpolateInit<T extends ColourSpaces>(colours: Colourish[], destination: T):\n  T extends `oklch` ? OkLchScalar[][] :\n  T extends `hsl` ? HslScalar[][] :\n  T extends `srgb` ? RgbScalar[][] : HslScalar[][]\n\nfunction interpolateInit(colours: Colourish[], destination: ColourSpaces = `hsl`): (OkLchScalar | HslScalar | RgbScalar)[][] {\n  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n\n  const c = colours.map(colour => convertScalar(colour, destination));\n  return [ ...pairwise(c) ];\n}\n\n/**\n * Returns a CSS `linear-gradient` with stops corresponding to the given list of `colours`.\n * ```js\n * element.style.background = Colour.cssLinearGradient(['red','green','blue']);\n * ```\n * @param colours \n * @returns \n */\nexport const cssLinearGradient = (colours: Colourish[]) => {\n  const c = colours.map(c => toCssColour(c));\n  return `linear-gradient(to right, ${ c.join(`, `) })`;\n}\n\n/**\n * Returns a function that interpolates between two colours. Returns string colour values.\n * ```js\n * const i = interpolator(`blue`, `red`);\n * i(0.5); // Get the colour at 50%, as a string.\n * ```\n * \n * To work with structured colour values, use one of the space's `interpolate` functions.\n * @param colourA \n * @param colourB \n * @param options \n * @returns \n */\nexport const interpolator = (colourA: Colourish, colourB: Colourish, options: Partial<ColourInterpolationOpts> = {}) => {\n  const space = options.space ?? `oklch`;\n  const direction = options.direction ?? `shorter`;\n\n  let inter: ColourInterpolator<Colour> | undefined;\n  switch (space) {\n    case `hsl`:\n      inter = HslSpace.interpolator(convert(colourA, `hsl-scalar`), convert(colourB, `hsl-scalar`), direction);\n      break;\n    case `srgb`:\n      inter = SrgbSpace.interpolator(convert(colourA, `srgb-scalar`), convert(colourB, `srgb-scalar`));\n      break;\n    default:\n      inter = OklchSpace.interpolator(convert(colourA, `oklch-scalar`), convert(colourB, `oklch-scalar`), direction);\n  }\n\n  return (amount: number) => toCssColour(inter(amount));\n\n}\n\n/**\n * Produces a stepped scale of colours.\n * \n * ```js\n * // A scale of from red to green, with three colours in-between\n * const steps = Colour.scale([ `red`, `green` ], { stepsBetween: 3 });\n * for (const step of steps) {\n *  // A CSS colour string\n * }\n * ```\n * \n * {@link cssLinearGradient} can produce a smooth gradient in CSS on the basis\n * of the stepped colours.\n * @param colours \n * @param opts \n * @returns \n */\nexport const scale = (colours: Colourish[], opts: Partial<ColourStepOpts> = {}): string[] => {\n  const direction = opts.direction ?? `shorter`;\n  const space = opts.space ?? `oklch`;\n  const pieces = interpolateInit(colours, space);\n\n  let stepsBetween = 0;\n  if (typeof opts.stepsBetween === `number`) {\n    stepsBetween = opts.stepsBetween;\n    if (stepsBetween < 1) throw new Error(`Param 'stepsBetween' must be at least 1`);\n  } else if (typeof opts.stepsTotal === `number`) {\n    if (opts.stepsTotal <= colours.length) throw new Error(`Param 'stepsTotal' must be greater than number of provided colour stops (${ colours.length }) +1 per stop`);\n    const totalSteps = opts.stepsTotal - colours.length;\n    stepsBetween = Math.floor(totalSteps / pieces.length);\n  }\n\n  const steps = pieces.map((piece: Colour[]) => {\n    //const pieceSteps = HslSpace.createSteps(piece[ 0 ], piece[ 1 ], stepsBetween, direction, true);\n    const pieceSteps: Colour[] = createSteps(piece[ 0 ], piece[ 1 ], { steps: stepsBetween, space, direction, exclusive: true });\n\n    // Add end colour\n    pieceSteps.push(piece[ 1 ]);\n    return pieceSteps;\n  });\n\n  // Add very first colour\n  const firstPiece = pieces[ 0 ];\n  steps.unshift([ firstPiece[ 0 ] ]);\n  return steps.flat().map(c => toCssColour(c));\n}\n\nexport type CreateStepsOptions = Partial<{ space: ColourSpaces, steps: number, direction: `longer` | `shorter`, exclusive: boolean }>\n\n/**\n * Creates discrete colour steps between two colours. \n * \n * Start and end colours are included (and counted as a step) unless `exclusive` is set to _true_\n * \n * ```js\n * // Array of five HslScalar \n * createSteps(`red`,`blue`, { steps: 5 });\n * ```\n * \n * Defaults to the oklch colour space, 5 steps and non-exclusive.\n * @param a Start colour\n * @param b End colour\n * @param options\n * @returns \n */\nexport function createSteps<T extends CreateStepsOptions>(a: Colourish | string, b: Colourish, options: T):\n  T extends { space: `oklch` } ? OkLchScalar[] :\n  T extends { space: `srgb` } ? RgbScalar[] :\n  T extends { space: `hsl` } ? HslScalar[] : OkLchScalar[];\n\nexport function createSteps(a: Colourish | string, b: Colourish, options: CreateStepsOptions = {}): Colour[] {\n  const exclusive = options.exclusive ?? false;\n  const steps = options.steps ?? 5;\n  const space = options.space ?? `oklch`;\n  const direction = options.direction ?? `shorter`;\n\n  if (!exclusive && steps < 2) throw new Error(`Param 'steps' should be at least 2 when 'exclusive' is false`);\n  if (exclusive && steps < 1) throw new Error(`Param 'steps' should be at least 1 when 'exlusive' is true`);\n\n  const aa = convertScalar(a, space);\n  const bb = convertScalar(b, space);\n\n  // Create interpolator\n  let inter: ColourInterpolator<Colour> | undefined;\n  switch (space) {\n    case `hsl`:\n      inter = HslSpace.interpolator(aa as HslScalar, bb as HslScalar, direction);\n      break;\n    case `oklch`:\n      inter = OklchSpace.interpolator(aa as OkLchScalar, bb as OkLchScalar, direction);\n      break;\n    case `srgb`:\n      inter = SrgbSpace.interpolator(aa as RgbScalar, bb as RgbScalar);\n      break;\n    default:\n      throw new Error(`Colour space '${ space }' not supported for interpolation.`);\n  }\n  if (!inter) throw new Error(`Could not create interpolator for space: ${ space }`);\n\n  let stepBy = 0;\n  let startAt = 0;\n  let endAt = 1;\n  if (exclusive) {\n    stepBy = 1 / (steps + 1);\n    startAt = stepBy;\n    endAt = 1 - stepBy;\n  } else {\n    stepBy = 1 / (steps - 1);\n  }\n\n  const results: Colour[] = [];\n  for (let interpolateAmount = startAt; interpolateAmount <= endAt; interpolateAmount += stepBy) {\n    results.push(inter(interpolateAmount));\n  }\n\n  return results;\n}\n","export * from './conversion.js';\nexport * from './css-colours.js';\nexport * from './generate.js';\nexport * from './guards.js';\n//export * from './interpolate.js';\nexport * from './math.js';\nexport * from './interpolate.js';\nexport * as HslSpace from './hsl.js';\nexport * as OklchSpace from './oklch.js';\nexport * as SrgbSpace from './srgb.js';\n\nexport * from './types.js';","import Colorizr, * as C from \"colorizr\";\nimport { type Colour, type Colourish, type ColourSpaces, type Hsl, type HslAbsolute, type HslScalar, type OkLch, type OkLchAbsolute, type OkLchScalar, type Rgb, type Rgb8Bit, type RgbScalar } from \"./types.js\";\nimport * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport * as OkLchSpace from './oklch.js';\nimport { fromCssColour } from \"./css-colours.js\";\nimport { isHsl, isRgb, tryParseObjectToRgb, tryParseObjectToHsl, isColourish, isOkLch } from \"./guards.js\";\nimport { OklchSpace } from \"./index.js\";\n\nexport type ConvertDestinations = `hsl-scalar` | `hsl-absolute` | `oklch-scalar` | `oklch-absolute` | `srgb-8bit` | `srgb-scalar`;\n\nexport function convert<T extends ConvertDestinations>(colour: Colourish, destination: T):\n  T extends \"oklch-absolute\" ? OkLchAbsolute :\n  T extends \"oklch-scalar\" ? OkLchScalar :\n  T extends \"srgb-8bit\" ? Rgb8Bit :\n  T extends \"srgb-scalar\" ? RgbScalar :\n  T extends \"hsl-scalar\" ? HslScalar :\n  T extends \"hsl-absolute\" ? HslAbsolute : never\n\n/**\n * Converts an object or string representation of colour to ixfx's\n * structured colour.\n * Use {@link convertToString} if you want a CSS colour string instead.\n * @param colour \n * @param destination \n * @returns \n */\nexport function convert(colour: Colourish, destination: ConvertDestinations): Hsl | OkLch | Rgb {\n  if (destination === `hsl-scalar`) {\n    if (typeof colour === `string` || isHsl(colour) || isRgb(colour)) {\n      return HslSpace.toScalar(colour);\n    }\n  } else if (destination === `hsl-absolute`) {\n    if (typeof colour === `string` || isHsl(colour)) {\n      return HslSpace.toAbsolute(colour);\n    }\n  } else if (destination === `oklch-scalar`) {\n    if (typeof colour === `string` || isOkLch(colour)) {\n      return OkLchSpace.toScalar(colour);\n    }\n  } else if (destination === `oklch-absolute`) {\n    if (typeof colour === `string` || isOkLch(colour)) {\n      return OkLchSpace.toAbsolute(colour);\n    }\n  } else if (destination === `srgb-8bit`) {\n    if (typeof colour === `string` || isRgb(colour)) {\n      return SrgbSpace.to8bit(colour);\n    }\n  } else if (destination === `srgb-scalar`) {\n    if (typeof colour === `string` || isRgb(colour)) {\n      return SrgbSpace.toScalar(colour);\n    }\n  } else {\n    throw new Error(`Destination '${ destination }' not supported for input: ${ JSON.stringify(colour) }`);\n  }\n  return convert(toCssColour(colour), destination);\n}\n\n/**\n * Like {@link convert}, but result is a CSS colour string\n * @param colour \n * @param destination \n * @returns \n */\nexport function convertToString(colour: Colourish, destination: ConvertDestinations): string {\n  const c = convert(colour, destination);\n  return toCssColour(c);\n}\n\nexport function convertScalar<T extends ColourSpaces>(colour: Colourish, destination: T):\n  T extends \"oklch\" ? OkLchScalar :\n  T extends \"hsl\" ? HslScalar :\n  T extends \"srgb\" ? RgbScalar : never\n\nexport function convertScalar(colour: Colourish, destination: ColourSpaces): HslScalar | OkLchScalar | RgbScalar {\n  if (destination === `oklch`) return convert(colour, `oklch-scalar`);\n  if (destination === `srgb`) return convert(colour, `srgb-scalar`);\n  if (destination === `hsl`) return convert(colour, `hsl-scalar`);\n  throw new Error(`Unknown destination: '${ destination }'`);\n}\n\nexport const toCssColour = (colour: Colourish | object): string => {\n  if (typeof colour === `string`) return colour;\n\n  if (isHsl(colour)) {\n    return HslSpace.toCssString(colour);\n  }\n\n  if (isRgb(colour)) {\n    return SrgbSpace.toCssString(colour);\n  }\n\n  if (isOkLch(colour)) {\n    return OklchSpace.toCssString(colour);\n  }\n  const asRgb = tryParseObjectToRgb(colour);\n  if (asRgb) return SrgbSpace.toCssString(asRgb);\n\n  const asHsl = tryParseObjectToHsl(colour);\n  if (asHsl) return HslSpace.toCssString(asHsl);\n\n  throw new Error(`Unknown colour format: '${ JSON.stringify(colour) }'`);\n}\n\nexport const toHexColour = (colour: Colourish | object): string => {\n\n  if (isHsl(colour)) {\n    return HslSpace.toHexString(colour);\n  }\n\n  if (isRgb(colour)) {\n    return SrgbSpace.toHexString(colour);\n  }\n\n  if (isOkLch(colour)) {\n    return OklchSpace.toHexString(colour);\n  }\n\n  if (typeof colour === `string` && colour.startsWith(`#`)) return colour;\n\n  const asRgb = tryParseObjectToRgb(colour);\n  if (asRgb) return SrgbSpace.toHexString(asRgb);\n\n  const asHsl = tryParseObjectToHsl(colour);\n  if (asHsl) return HslSpace.toHexString(asHsl);\n\n  throw new Error(`Unknown colour format: '${ JSON.stringify(colour) }'`);\n}\n\n\n\nexport const toLibraryColour = (colour: Colourish): Colorizr => {\n  const asCss = toCssColour(colour);\n  return new Colorizr(asCss);\n}\n\n// export const convertColourString = (colour: string, destination: 'hex' | 'hsl' | 'oklab' | 'oklch' | 'srgb' | `rgb`): string => {\n//   if (destination === `srgb`) destination = `rgb`;\n//   return C.convert(colour, destination);\n// }\n\nexport const guard = (colour: Colour) => {\n  switch (colour.space) {\n    case `hsl`:\n      HslSpace.guard(colour);\n      break;\n    case `srgb`:\n      SrgbSpace.guard(colour);\n      break;\n    case `oklch`:\n      OkLchSpace.guard(colour);\n      break;\n    default:\n      throw new Error(`Unsupported colour space: '${ colour.space }'`);\n  }\n}\n\nexport const toColour = (colourish: any): Colour => {\n  if (!isColourish(colourish)) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc. Got: ${ JSON.stringify(colourish) }`);\n  let c: Colour | undefined;\n  if (typeof colourish === `string`) c = fromCssColour(colourish);\n  else c = colourish;\n  if (c === undefined) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n\n  guard(c);\n  return c;\n}\n\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const toStringFirst = (...colours: (Colourish | undefined)[]): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    try {\n      const c = toColour(colour);\n      return toCssColour(c);\n    } catch { /* empty */ }\n  }\n  return `rebeccapurple`;\n}\n\n\nexport function rgbToHsl(rgb: Rgb, scalarResult: true): HslScalar\nexport function rgbToHsl(rgb: Rgb, scalarResult: false): HslAbsolute\nexport function rgbToHsl(rgb: Rgb, scalarResult: boolean): Hsl {\n  // Needed because the Colorizr package has broken RGB to HSL\n  // Converts rgb { model: 'rgb', r: 40, g: 20, b: 60, alpha: undefined }\n  // to : { h: 270, s: 50, l: 0.06 }\n  // when it should be: { h: 270, s: 50, l: 40 }\n\n  // Source: https://www.jameslmilner.com/posts/converting-rgb-hex-hsl-colors/\n  let { r, g, b } = rgb;\n  const opacity = rgb.opacity ?? 1;\n  if (rgb.unit === `8bit`) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n  }\n\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n\n  let h = (max + min) / 2;\n  let s = h;\n  const l = h;\n\n  if (max === min) {\n    // Achromatic\n    if (scalarResult) {\n      return HslSpace.scalar(0, 0, 0, opacity);\n    } else {\n      return HslSpace.absolute(0, 0, 0, opacity);\n    }\n  }\n\n  const d = max - min;\n  s = l >= 0.5 ? d / (2 - (max + min)) : d / (max + min);\n  switch (max) {\n    case r:\n      h = ((g - b) / d + 0) * 60;\n      break;\n    case g:\n      h = ((b - r) / d + 2) * 60;\n      break;\n    case b:\n      h = ((r - g) / d + 4) * 60;\n      break;\n  }\n\n  if (scalarResult) {\n    return HslSpace.scalar(h / 360, s, l, opacity)\n  } else {\n    return HslSpace.absolute(h, s * 100, l * 100, opacity);\n  }\n}","import type { StrokeOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: strokeStyle, strokeWidth, strokeDash, strokeLineCap\n * @param elem Element\n * @param opts\n */\nexport const applyStrokeOpts = (elem: SVGElement, opts: StrokeOpts) => {\n  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);\n  if (opts.strokeWidth) {\n    elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());\n  }\n  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);\n  if (opts.strokeLineCap) {\n    elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);\n  }\n};","import { applyOpts } from \"./apply.js\";\nimport { createEl, createOrResolve } from \"./create.js\";\nimport type { DrawingOpts, MarkerOpts } from \"./types.js\";\n\nexport const createMarker = (\n  id: string,\n  opts: MarkerOpts,\n  childCreator?: () => SVGElement\n): SVGMarkerElement => {\n  const m = createEl<SVGMarkerElement>(`marker`, id);\n\n  if (opts.markerWidth) {\n    m.setAttribute(`markerWidth`, opts.markerWidth?.toString());\n  }\n  if (opts.markerHeight) {\n    m.setAttribute(`markerHeight`, opts.markerHeight?.toString());\n  }\n  if (opts.orient) m.setAttribute(`orient`, opts.orient.toString());\n  else m.setAttribute(`orient`, `auto-start-reverse`);\n\n  if (opts.viewBox) m.setAttribute(`viewBox`, opts.viewBox.toString());\n  if (opts.refX) m.setAttribute(`refX`, opts.refX.toString());\n  if (opts.refY) m.setAttribute(`refY`, opts.refY.toString());\n\n  if (childCreator) {\n    const c = childCreator();\n    m.appendChild(c);\n  }\n  return m;\n};\n\nexport const markerPrebuilt = (\n  elem: SVGElement | null,\n  opts: MarkerOpts,\n  _context: DrawingOpts\n): string => {\n  if (elem === null) return `(elem null)`;\n\n  const parent = elem.ownerSVGElement;\n  if (parent === null) throw new Error(`parent for elem is null`);\n  const defsEl = createOrResolve<SVGDefsElement>(parent, `defs`, `defs`);\n\n  //eslint-disable-next-line functional/no-let\n  let defEl = defsEl.querySelector(`#${ opts.id }`) as SVGElement | null;\n\n  if (defEl !== null) {\n    return `url(#${ opts.id })`;\n  }\n\n  if (opts.id === `triangle`) {\n    opts = { ...opts, strokeStyle: `transparent` };\n    if (!opts.markerHeight) opts = { ...opts, markerHeight: 6 };\n    if (!opts.markerWidth) opts = { ...opts, markerWidth: 6 };\n    if (!opts.refX) opts = { ...opts, refX: opts.markerWidth };\n    if (!opts.refY) opts = { ...opts, refY: opts.markerHeight };\n    if (!opts.fillStyle || opts.fillStyle === `none`) {\n      opts = { ...opts, fillStyle: `black` };\n    }\n    if (!opts.viewBox) opts = { ...opts, viewBox: `0 0 10 10` };\n\n    defEl = createMarker(opts.id, opts, () => {\n      const tri = createEl<SVGPathElement>(`path`);\n      tri.setAttribute(`d`, `M 0 0 L 10 5 L 0 10 z`);\n      if (opts) applyOpts(tri, opts);\n      return tri;\n    });\n  } else throw new Error(`Do not know how to make ${ opts.id }`);\n\n  //eslint-disable-next-line functional/immutable-data\n  defEl.id = opts.id;\n  defsEl.appendChild(defEl);\n\n  return `url(#${ opts.id })`;\n};\n","import type { DrawingOpts } from \"../drawing.js\";\nimport { markerPrebuilt } from \"./markers.js\";\nimport type { PathDrawingOpts } from \"./types.js\";\n\n/**\n * Applies path drawing options to given element\n * Applies: markerEnd, markerStart, markerMid\n * @param elem Element (presumed path)\n * @param opts Options\n */\nexport const applyPathOpts = (elem: SVGElement, opts: PathDrawingOpts) => {\n  if (opts.markerEnd) {\n    elem.setAttribute(\n      `marker-end`,\n      markerPrebuilt(elem, opts.markerEnd, opts as DrawingOpts)\n    );\n  }\n  if (opts.markerStart) {\n    elem.setAttribute(\n      `marker-start`,\n      markerPrebuilt(elem, opts.markerStart, opts as DrawingOpts)\n    );\n  }\n  if (opts.markerMid) {\n    elem.setAttribute(\n      `marker-mid`,\n      markerPrebuilt(elem, opts.markerMid, opts as DrawingOpts)\n    );\n  }\n};","\n//import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\n//import type { Point } from '../../geometry/point/PointType.js';\n//import type { Line } from '../../geometry/line/LineType.js';\n//import * as Lines from '../geometry/line/index.js';\nimport { Lines, Polar } from '@ixfx/geometry';\n//import * as Svg from './index.js';\nimport { toStringFirst as ColourStringFirst } from '../colour/conversion.js';\n//import { getCssVariable } from '../colour/index.js';\nimport type { CircleDrawingOpts, LineDrawingOpts, PathDrawingOpts, TextDrawingOpts, TextPathDrawingOpts } from './types.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { createEl, createOrResolve } from './create.js';\nimport { applyPathOpts } from './path.js';\nimport type { CirclePositioned } from '@ixfx/geometry/circle';\nimport type { Line } from '@ixfx/geometry/line';\nimport type { Point } from '@ixfx/geometry/point';\n//import type { PolarRay } from 'src/geometry/polar/Types.js';\n//import { toCartesian as polarRayToCartesian } from 'src/geometry/polar/Ray.js';\n//import {Palette} from \".\";\n\nconst numberOrPercentage = (v: number): string => {\n  if (v >= 0 && v <= 1) return `${ v * 100 }%`;\n  return v.toString();\n};\n\n/**\n * Creates and adds an SVG path element\n * @example\n * ```js\n * const paths = [\n *  `M300,200`,\n *  `a25,25 -30 0,1 50, -25 l 50,-25`\n * ]\n * const pathEl = path(paths, parentEl);\n * ```\n * @param svgOrArray Path syntax, or array of paths. Can be empty if path data will be added later\n * @param parent SVG parent element\n * @param opts Options Drawing options\n * @returns\n */\nexport const path = (\n  svgOrArray: string | readonly string[],\n  parent: SVGElement,\n  opts?: PathDrawingOpts,\n  queryOrExisting?: string | SVGPathElement\n): SVGPathElement => {\n  const elem = createOrResolve<SVGPathElement>(\n    parent,\n    `path`,\n    queryOrExisting\n  );\n  const svg =\n    typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`\\n`);\n\n  elem.setAttributeNS(null, `d`, svg);\n  parent.append(elem);\n  return pathUpdate(elem, opts);\n};\n\nexport const pathUpdate = (\n  elem: SVGPathElement,\n  opts?: PathDrawingOpts\n) => {\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n  return elem;\n};\n\n/**\n * Updates an existing `SVGCircleElement` with potentially updated circle data and drawing options\n * @param elem Element\n * @param circle Circle\n * @param opts Drawing options\n * @returns SVGCircleElement\n */\nexport const circleUpdate = (\n  elem: SVGCircleElement,\n  circle: CirclePositioned,\n  opts?: CircleDrawingOpts\n) => {\n  elem.setAttributeNS(null, `cx`, circle.x.toString());\n  elem.setAttributeNS(null, `cy`, circle.y.toString());\n  elem.setAttributeNS(null, `r`, circle.radius.toString());\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n\n  return elem;\n};\n\n/**\n * Creates or reuses a `SVGCircleElement`.\n *\n * To update an existing element, use `circleUpdate`\n * @param circle\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const circle = (\n  circle: CirclePositioned,\n  parent: SVGElement,\n  opts?: CircleDrawingOpts,\n  queryOrExisting?: string | SVGCircleElement\n): SVGCircleElement => {\n  const p = createOrResolve<SVGCircleElement>(\n    parent,\n    `circle`,\n    queryOrExisting\n  );\n  return circleUpdate(p, circle, opts);\n};\n\n/**\n * Creates or resuses a `SVGGElement` (group)\n *\n * To update an existing elemnet, use `groupUpdate`\n * @param children\n * @param parent\n * @param queryOrExisting\n * @returns\n */\nexport const group = (\n  children: readonly SVGElement[],\n  parent: SVGElement,\n  queryOrExisting?: string | SVGGElement\n): SVGGElement => {\n  const p = createOrResolve<SVGGElement>(parent, `g`, queryOrExisting);\n  return groupUpdate(p, children);\n};\n\nexport const groupUpdate = (\n  elem: SVGGElement,\n  children: readonly SVGElement[]\n) => {\n  for (const c of children) {\n    if (c.parentNode !== elem) {\n      elem.append(c);\n    }\n  }\n\n  return elem;\n};\n\n/**\n * Creates or reuses a SVGLineElement.\n *\n * @param line\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const line = (\n  line: Line,\n  parent: SVGElement,\n  opts?: LineDrawingOpts,\n  queryOrExisting?: string | SVGLineElement\n): SVGLineElement => {\n  const lineEl = createOrResolve<SVGLineElement>(\n    parent,\n    `line`,\n    queryOrExisting\n  );\n  return lineUpdate(lineEl, line, opts);\n};\n\n/**\n * Updates a SVGLineElement instance with potentially changed line and drawing data\n * @param lineEl\n * @param line\n * @param opts\n * @returns\n */\nexport const lineUpdate = (\n  lineEl: SVGLineElement,\n  line: Line,\n  opts?: LineDrawingOpts\n) => {\n  lineEl.setAttributeNS(null, `x1`, line.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, line.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, line.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, line.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n};\n\nexport const polarRayUpdate = (lineEl: SVGLineElement, ray: Polar.PolarRay, opts?: LineDrawingOpts) => {\n  const l = Polar.Ray.toCartesian(ray);\n  lineEl.setAttributeNS(null, `x1`, l.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, l.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, l.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, l.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n}\n\n/**\n * Updates an existing SVGTextPathElement instance with text and drawing options\n * @param el\n * @param text\n * @param opts\n * @returns\n */\nexport const textPathUpdate = (\n  el: SVGTextPathElement,\n  text?: string,\n  opts?: TextPathDrawingOpts\n) => {\n  if (opts?.method) el.setAttributeNS(null, `method`, opts.method);\n  if (opts?.side) el.setAttributeNS(null, `side`, opts.side);\n  if (opts?.spacing) el.setAttributeNS(null, `spacing`, opts.spacing);\n  if (opts?.startOffset) {\n    el.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));\n  }\n  if (opts?.textLength) {\n    el.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));\n  }\n\n  if (text) {\n    el.textContent = text;\n  }\n  if (opts) applyOpts(el, opts);\n  if (opts) applyStrokeOpts(el, opts);\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextPathElement.\n * @param pathReference\n * @param text\n * @param parent\n * @param opts\n * @param textQueryOrExisting\n * @param pathQueryOrExisting\n * @returns\n */\nexport const textPath = (\n  pathReference: string,\n  text: string,\n  parent: SVGElement,\n  opts?: TextPathDrawingOpts,\n  textQueryOrExisting?: string | SVGTextElement,\n  pathQueryOrExisting?: string | SVGTextPathElement\n): SVGTextPathElement => {\n  const textEl = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    textQueryOrExisting, `-text`\n  );\n  // Update text properties, but don't pass in position or text\n  textUpdate(textEl, undefined, undefined, opts);\n\n  const p = createOrResolve<SVGTextPathElement>(\n    textEl,\n    `textPath`,\n    pathQueryOrExisting\n  );\n  p.setAttributeNS(null, `href`, pathReference);\n  return textPathUpdate(p, text, opts);\n};\n\n/**\n * Updates an existing SVGTextElement instance with position, text and drawing options\n * @param el\n * @param pos\n * @param text\n * @param opts\n * @returns\n */\nexport const textUpdate = (\n  el: SVGTextElement,\n  pos?: Point,\n  text?: string,\n  opts?: TextDrawingOpts\n) => {\n  if (pos) {\n    el.setAttributeNS(null, `x`, pos.x.toString());\n    el.setAttributeNS(null, `y`, pos.y.toString());\n  }\n  if (text) {\n    el.textContent = text;\n  }\n\n  if (opts) {\n    applyOpts(el, opts);\n    if (opts) applyStrokeOpts(el, opts);\n\n    if (opts.anchor) el.setAttributeNS(null, `text-anchor`, opts.anchor);\n    if (opts.align) el.setAttributeNS(null, `alignment-baseline`, opts.align);\n\n    const userSelect = opts.userSelect ?? true;\n\n    if (!userSelect) {\n      el.style.userSelect = `none`;\n    }\n  }\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextElement\n * @param pos Position of text\n * @param text Text\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const text = (\n  text: string,\n  parent: SVGElement,\n  pos?: Point,\n  opts?: TextDrawingOpts,\n  queryOrExisting?: string | SVGTextElement\n): SVGTextElement => {\n  const p = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    queryOrExisting\n  );\n  return textUpdate(p, pos, text, opts);\n};\n\n/**\n * Creates a square grid based at a center point, with cells having `spacing` height and width.\n *\n * It fits in as many cells as it can within `width` and `height`.\n *\n * Returns a SVG group, consisting of horizontal and vertical lines\n * @param parent Parent element\n * @param center Center point of grid\n * @param spacing Width/height of cells\n * @param width How wide grid should be\n * @param height How high grid should be\n * @param opts\n */\nexport const grid = (\n  parent: SVGElement,\n  center: Point,\n  spacing: number,\n  width: number,\n  height: number,\n  opts: LineDrawingOpts = {}\n) => {\n  if (!opts.strokeStyle) {\n    opts = { ...opts, strokeStyle: ColourStringFirst(`bg-dim`, `silver`) };\n  }\n  if (!opts.strokeWidth) opts = { ...opts, strokeWidth: 1 };\n\n  const g = createEl<SVGGElement>(`g`);\n  applyOpts(g, opts);\n  applyPathOpts(g, opts);\n  applyStrokeOpts(g, opts);\n\n  // Horizontals\n  let y = 0;\n  while (y < height) {\n    const horiz = Lines.fromNumbers(0, y, width, y);\n    line(horiz, g);\n    y += spacing;\n  }\n\n  // Verticals\n  let x = 0;\n  while (x < width) {\n    const vert = Lines.fromNumbers(x, 0, x, height);\n    line(vert, g);\n    x += spacing;\n  }\n  parent.append(g);\n  return g;\n};\n","import { Polar } from \"@ixfx/geometry\";\nimport type { Line } from \"@ixfx/geometry/line\";\nimport type { Point } from \"@ixfx/geometry/point\";\n// import type { Line } from \"../../geometry/line/LineType.js\";\n// import type { Point } from \"../../geometry/point/PointType.js\";\n// import { fromLine as polarRayFromLine } from \"../../geometry/polar/Ray.js\";\n\n/**\n * Returns a Line type from an SVGLineElement\n * @param el SVG Line Element\n * @returns \n */\nexport const lineFromSvgLine = (el: SVGLineElement): Line => {\n  if (!el) throw new Error(`Param 'el' is undefined`);\n  const a = { x: el.x1.baseVal.value, y: el.y1.baseVal.value };\n  const b = { x: el.x2.baseVal.value, y: el.y2.baseVal.value };\n  return { a, b }\n}\n\nexport const polarRayFromSvgLine = (el: SVGLineElement, origin: Point): Polar.PolarRay => {\n  const l = lineFromSvgLine(el);\n  return Polar.Ray.fromLine(l, origin);\n}","/**\n * Removes an SVG element from a parent\n * @param parent Parent\n * @param queryOrExisting Query or existing element \n * @returns \n */\nexport const remove = <V extends SVGElement>(\n  parent: SVGElement,\n  queryOrExisting: string | V\n) => {\n  if (typeof queryOrExisting === `string`) {\n    const elem = parent.querySelector(queryOrExisting);\n    if (elem === null) return;\n    elem.remove();\n  } else {\n    queryOrExisting.remove();\n  }\n};\n\n/**\n * Removes all children of `parent`, but not `parent` itself.\n * @param parent \n */\nexport const clear = (parent: SVGElement) => {\n  let c = parent.lastElementChild;\n  while (c) {\n    c.remove();\n    c = parent.lastElementChild;\n  }\n};","// import { Point } from '@ixfx/geometry';\n// import type { Line } from '../../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\nimport type { CircleDrawingOpts, DrawingOpts, LineDrawingOpts, PathDrawingOpts, StrokeOpts, TextDrawingOpts } from './types.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { remove } from './remove.js';\nimport * as Elements from './elements.js';\nimport type { Point } from '@ixfx/geometry/point';\nimport type { CirclePositioned } from '@ixfx/geometry/circle';\nimport type { Line } from '@ixfx/geometry/line';\n\n/**\n * Helper to make SVG elements with a common parent.\n *\n * Create with {@link makeHelper}.\n */\nexport type SvgHelper = {\n  remove(queryOrExisting: string | SVGElement): void;\n  /**\n   * Creates a text element\n   * @param text Text\n   * @param pos Position\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  text(\n    text: string,\n    pos: Point,\n    opts?: TextDrawingOpts,\n    queryOrExisting?: string | SVGTextElement\n  ): SVGTextElement;\n  /**\n   * Creates text on a path\n   * @param pathReference Reference to path element\n   * @param text Text\n   * @param opts Drawing options\n   * @param textQueryOrExisting DOM query to look up existing element, or the element instance\n   * @param pathQueryOrExisting DOM query to look up existing element, or the element instance\n   */\n  textPath(\n    pathReference: string,\n    text: string,\n    opts?: TextDrawingOpts,\n    textQueryOrExisting?: string | SVGTextElement,\n    pathQueryOrExisting?: string | SVGTextPathElement\n  ): SVGTextPathElement;\n  /**\n   * Creates a line\n   * @param line Line\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  line(\n    line: Line,\n    opts?: LineDrawingOpts,\n    queryOrExisting?: string | SVGLineElement\n  ): SVGLineElement;\n  /**\n   * Creates a circle\n   * @param circle Circle\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  circle(\n    circle: CirclePositioned,\n    opts?: CircleDrawingOpts,\n    queryOrExisting?: string | SVGCircleElement\n  ): SVGCircleElement;\n  /**\n   * Creates a path\n   * @param svgString Path description, or empty string\n   * @param opts Drawing options\n   * @param queryOrExisting DOM query to look up existing element, or the element instance\n   */\n  path(\n    svgString: string | readonly string[],\n    opts?: PathDrawingOpts,\n    queryOrExisting?: string | SVGPathElement\n  ): SVGPathElement;\n  /**\n   * Creates a grid of horizontal and vertical lines inside of a group\n   * @param center Grid origin\n   * @param spacing Cell size\n   * @param width Width of grid\n   * @param height Height of grid\n   * @param opts Drawing options\n   */\n  grid(\n    center: Point,\n    spacing: number,\n    width: number,\n    height: number,\n    opts?: LineDrawingOpts\n  ): SVGGElement;\n  /**\n   * Returns an element if it exists in parent\n   * @param selectors Eg `#path`\n   */\n  query<V extends SVGElement>(selectors: string): V | null;\n  /**\n   * Gets/sets the width of the parent\n   */\n  get width(): number;\n  set width(width: number);\n  /**\n   * Gets the parent\n   */\n  get parent(): SVGElement;\n  /**\n   * Gets/sets the height of the parent\n   */\n  get height(): number;\n  set height(height: number);\n  /**\n   * Deletes all child elements\n   */\n  clear(): void;\n};\n\n/**\n * Creates a {@link SvgHelper} for the creating and management of SVG elements.\n * @param parent\n * @param parentOpts\n * @returns\n */\nexport const makeHelper = (\n  parent: SVGElement,\n  parentOpts?: DrawingOpts & StrokeOpts\n): SvgHelper => {\n  if (parentOpts) {\n    applyOpts(parent, parentOpts);\n    applyStrokeOpts(parent, parentOpts);\n  }\n\n  const o: SvgHelper = {\n    remove: (queryOrExisting: string | SVGElement) => { remove(parent, queryOrExisting); },\n    text: (\n      text: string,\n      pos: Point,\n      opts?: TextDrawingOpts,\n      queryOrExisting?: string | SVGTextElement\n    ) => Elements.text(text, parent, pos, opts, queryOrExisting),\n    textPath: (\n      pathReference: string,\n      text: string,\n      opts?: TextDrawingOpts,\n      textQueryOrExisting?: string | SVGTextElement,\n      pathQueryOrExisting?: string | SVGTextPathElement\n    ) => Elements.textPath(pathReference, text, parent, opts, textQueryOrExisting, pathQueryOrExisting),\n    line: (\n      line: Line,\n      opts?: LineDrawingOpts,\n      queryOrExisting?: string | SVGLineElement\n    ) => Elements.line(line, parent, opts, queryOrExisting),\n    circle: (\n      circle: CirclePositioned,\n      opts?: CircleDrawingOpts,\n      queryOrExisting?: string | SVGCircleElement\n    ) => Elements.circle(circle, parent, opts, queryOrExisting),\n    path: (\n      svgString: string | readonly string[],\n      opts?: PathDrawingOpts,\n      queryOrExisting?: string | SVGPathElement\n    ) => Elements.path(svgString, parent, opts, queryOrExisting),\n    grid: (\n      center: Point,\n      spacing: number,\n      width: number,\n      height: number,\n      opts?: LineDrawingOpts\n    ) => Elements.grid(parent, center, spacing, width, height, opts),\n    query: <V extends SVGElement>(selectors: string): V | null =>\n      parent.querySelector(selectors),\n    get width(): number {\n      const w = parent.getAttributeNS(null, `width`);\n      if (w === null) return 0;\n      return Number.parseFloat(w);\n    },\n    set width(width: number) {\n      parent.setAttributeNS(null, `width`, width.toString());\n    },\n    get parent(): SVGElement {\n      return parent;\n    },\n    get height(): number {\n      const w = parent.getAttributeNS(null, `height`);\n      if (w === null) return 0;\n      return Number.parseFloat(w);\n    },\n    set height(height: number) {\n      parent.setAttributeNS(null, `height`, height.toString());\n    },\n    clear: () => {\n      while (parent.firstChild) {\n        (parent.lastChild as HTMLElement).remove();\n      }\n    },\n  };\n  return o;\n};\n","export * from './apply.js'\nexport * from './bounds.js'\nexport * from './create.js'\nexport * as Elements from './elements.js';\nexport * from './geometry.js';\nexport * from './helper.js';\nexport * from './markers.js';\nexport * from './path.js'\nexport * from './remove.js';\nexport * from './stroke.js'\nexport type * from './types.js';\n","\nimport { PointsTracker } from '@ixfx/geometry/point';\nimport * as Svg from './svg/index.js';\nimport { ElementSizer, resolveEl } from '@ixfx/dom';\nexport type Opts = {\n  readonly touchRadius?: number;\n  readonly mouseRadius?: number;\n  readonly trace?: boolean;\n  readonly hue?: number;\n};\n\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery Element to monitor\n * @param options Options\n */\nexport const pointerVisualise = (\n  elOrQuery: HTMLElement | string,\n  options: Opts = {}\n) => {\n  const touchRadius = options.touchRadius ?? 45;\n  const mouseRadius = options.touchRadius ?? 20;\n  const trace = options.trace ?? false;\n  const hue = options.hue ?? 100;\n\n  const startFillStyle = `hsla(${ hue }, 100%, 10%, 10%)`;\n  let currentHue = hue;\n\n  const el = resolveEl(elOrQuery);\n  const tracker = new PointsTracker({\n    storeIntermediate: trace,\n  });\n\n\n  const svg = document.createElementNS(\n    `http://www.w3.org/2000/svg`,\n    `svg`\n  ) as any as SVGElement & HTMLElement;\n  svg.id = `pointerVis`;\n  svg.style.zIndex = `-1000`;\n  svg.style.position = `fixed`;\n  svg.style.top = `0`;\n  svg.style.left = `0`;\n  svg.style.width = `100%`;\n  svg.style.height = `100%`;\n  svg.style.boxSizing = `border-box`;\n  svg.style.border = `3px solid red`;\n  svg.style.pointerEvents = `none`;\n  svg.style.touchAction = `none`;\n\n  // const er = new ElementSizer(svg, {\n  //   containerEl:document.body,\n  //   stretch:`both`,\n  //   onSetSize(size) {\n  //     svg.setAttribute(`width`, size.width.toString());\n  //     svg.setAttribute(`height`, size.height.toString());\n  //   },\n  // })\n  const er = ElementSizer.svgViewport(svg);\n  //fullSizeElement(svg);\n  let pointerCount = 0;\n\n  const lostPointer = (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n\n    tracker.delete(id);\n    currentHue = hue;\n    svg.querySelector(`#pv-start-${ id }`)?.remove();\n\n    for (let index = 0; index < pointerCount + 10; index++) {\n      svg.querySelector(`#pv-progress-${ id }-${ index }`)?.remove();\n    }\n    pointerCount = 0;\n  };\n\n  const trackPointer = async (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    const pt = { x: event.x, y: event.y };\n    const type = event.pointerType;\n    if (event.type === `pointermove` && !tracker.has(id)) {\n      return;\n    }\n    const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n\n    if (info.values.length === 1) {\n      const el = Svg.Elements.circle(\n        {\n          ...info.values[ 0 ],\n          radius: type === `touch` ? touchRadius : mouseRadius,\n        },\n        svg,\n        {\n          fillStyle: startFillStyle,\n        },\n        `#pv-start-${ id }`\n      );\n      el.style.pointerEvents = `none`;\n      el.style.touchAction = `none`;\n    }\n\n    const fillStyle = `hsla(${ currentHue }, 100%, 50%, 50%)`;\n\n    const el2 = Svg.Elements.circle(\n      { ...pt, radius: type === `touch` ? touchRadius : mouseRadius },\n      svg,\n      {\n        fillStyle,\n      },\n      `#pv-progress-${ id }-${ info.values.length }`\n    );\n    el2.style.pointerEvents = `none`;\n    el2.style.touchAction = `none`;\n    currentHue += 1;\n    pointerCount = info.values.length;\n  };\n\n  document.body.append(svg);\n\n\n  el.addEventListener(`pointerdown`, trackPointer);\n\n  el.addEventListener(`pointermove`, trackPointer);\n  el.addEventListener(`pointerup`, lostPointer);\n  el.addEventListener(`pointerleave`, lostPointer);\n  el.addEventListener(`contextmenu`, (event) => {\n    event.preventDefault();\n  });\n};\n","import * as ImageDataGrid from './image-data-grid.js';\nimport { Grids } from '@ixfx/geometry';\nimport type { Rgb8Bit } from './colour/types.js';\n\nexport type Kernel<T> = readonly (readonly T[])[];\n//export type CellWithValue<V> = readonly [ cell: Grids.Cell, value: V | undefined ];\nexport type CellValueScalar<TCell, TKernel> = Grids.GridCellAndValue<TCell> & { kernel: TKernel };\n\nexport type KernelCompute = <V>(offset: Grids.GridCell, value: V) => V;\nexport type KernelReduce<TCell, TKernel> = (values: CellValueScalar<TCell, TKernel>[]) => TCell | undefined;\n\n/**\n * Multiply every element of kernel by the same `scalar` value.\n * Returns new result, input is unmodified\n * @param kernel \n * @param scalar \n * @returns \n */\nexport const multiply = (kernel: Kernel<number>, scalar: number): Kernel<number> => {\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  const copy: number[][] = [];\n  for (let row = 0; row < rows; row++) {\n    copy[ row ] = [];\n    for (let col = 0; col < cols; col++) {\n      copy[ row ][ col ] = kernel[ row ][ col ] * scalar;\n    }\n  }\n  return copy;\n};\n\n\nexport function convolveCell<TCell, TKernel>(cell: Grids.GridCell, kernel: Kernel2dArray<TKernel>, source: Grids.GridReadable<TCell>, reduce: KernelReduce<TCell, TKernel>): TCell | undefined {\n  const valuesAtKernelPos: CellValueScalar<TCell, TKernel>[] = kernel.map(o => {\n    // For a kernel cell vector, get the position in the source grid\n    const pos = Grids.offset(source, cell, o.cell, `stop`); // `stop` avoids fringing at extents of image\n\n    // If there's no cell, return undefined\n    let kernelValue: TKernel | undefined;\n    let sourceValue: TCell | undefined;\n\n    if (pos) {\n      sourceValue = source.get(pos, `undefined`);\n      kernelValue = o.value;\n    }\n    //if (!pos) return { cell: o.cell, value: undefined, scalar: NaN } as CellValueScalar<T>;\n    return { cell: o.cell, value: sourceValue, kernel: o.value } as CellValueScalar<TCell, TKernel>;\n  });\n  return reduce(valuesAtKernelPos);\n}\n\n/**\n * Performs kernel-based convolution over `image`.\n * @param kernel \n * @param image \n */\nexport function* convolveImage(kernel: Kernel<number>, image: ImageData) {\n  //const grid = { rows: image.width, cols: image.height };\n  const imageDataAsGrid = ImageDataGrid.wrap(image);\n  yield* convolve(kernel, imageDataAsGrid, Grids.By.cells(imageDataAsGrid), rgbReducer);\n}\n\nexport function* convolve<TCell, TKernel>(kernel: Kernel<TKernel>, source: Grids.GridReadable<TCell>, visitor: Iterable<Grids.GridCell>, reduce: KernelReduce<TCell, TKernel>, origin?: Grids.GridCell): IterableIterator<Grids.GridCellAndValue<TCell>> {\n  if (!origin) {\n    const kernelRows = kernel.length;\n    const kernelCols = kernel[ 0 ].length;\n    origin = { x: Math.floor(kernelRows / 2), y: Math.floor(kernelCols / 2) };\n  }\n\n  const asArray = kernel2dToArray(kernel, origin);\n  // for (const c of visitor) {\n  //   const v = convolveCell<V>(c, asArray, source, access, reduce);\n  //   yield [ c, v ];\n  // }\n  for (const cell of visitor) {\n    const value = convolveCell<TCell, TKernel>(cell, asArray, source, reduce);\n    yield { cell, value };\n  }\n}\n\nexport type Kernel2dArray<T> = Grids.GridCellAndValue<T>[];\n\n/**\n * For a given kernel, returns an array of offsets. These\n * consist of a cell offset (eg `{x:-1,y:-1}`) and the value at that kernel position.\n * @param kernel \n * @param origin \n * @returns \n */\nexport const kernel2dToArray = <T>(kernel: Kernel<T>, origin?: Grids.GridCell): Kernel2dArray<T> => {\n  const offsets: Kernel2dArray<T> = [];\n  const rows = kernel.length;\n  const cols = kernel[ 0 ].length;\n  if (!origin) {\n    origin = {\n      x: Math.floor(rows / 2),\n      y: Math.floor(cols / 2)\n    };\n  }\n\n  for (let xx = 0; xx < rows; xx++) {\n    for (let yy = 0; yy < cols; yy++) {\n      const v: Grids.GridCellAndValue<T> = {\n        cell: { x: xx - origin.x, y: yy - origin.y },\n        value: kernel[ xx ][ yy ]\n      }\n      offsets.push(v);\n      //offsets.push([ { x: xx - origin.x, y: yy - origin.y }, kernel[ xx ][ yy ] ]);\n    }\n  }\n  return offsets;\n};\n\nexport const rgbReducer: KernelReduce<Rgb8Bit, number> = (values: CellValueScalar<Rgb8Bit, number>[]) => {\n  let r = 0;\n  let g = 0;\n  let b = 0;\n  let opacity = 0;\n  for (const value of values) {\n    const rgb = value.value;\n    const kernelValue = value.kernel;\n    if (!rgb) continue;\n    if (rgb.opacity === 0) continue;\n    if (kernelValue === 0) continue;\n    r += (rgb.r * kernelValue);\n    g += (rgb.g * kernelValue);\n    b += (rgb.b * kernelValue);\n    opacity += ((rgb.opacity ?? 1) * kernelValue);\n  }\n\n  const result: Rgb8Bit = {\n    r, g, b,\n    unit: `8bit`,\n    space: `srgb`,\n    opacity\n  };\n  return result;\n};\nexport const identityKernel = [\n  [ 0, 0, 0 ],\n  [ 0, 1, 0 ],\n  [ 0, 0, 0 ]\n];\n\nexport const edgeDetectionKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 4, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const sharpenKernel = [\n  [ 0, -1, 0 ],\n  [ -1, 5, -1 ],\n  [ 0, -1, 0 ]\n];\n\nexport const boxBlurKernel = multiply([\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ],\n  [ 1, 1, 1 ]\n], 1 / 9);\n\nexport const gaussianBlur3Kernel = multiply([\n  [ 1, 2, 1 ],\n  [ 2, 4, 2 ],\n  [ 1, 2, 1 ]\n], 1 / 16);\n\nexport const gaussianBlur5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, 36, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], 1 / 256);\n\nexport const unsharpMasking5Kernel = multiply([\n  [ 1, 4, 6, 4, 1 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 6, 24, -476, 24, 6 ],\n  [ 4, 16, 24, 16, 4 ],\n  [ 1, 4, 6, 4, 1 ],\n], -1 / 256);","/**\n * Manage a set of named colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type NamedColourPalette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: ReadonlyArray<string>): NamedColourPalette =>\n  new NamedColourPaletteImpl(fallbacks);\n\nclass NamedColourPaletteImpl {\n  readonly #store: Map<string, string> = new Map();\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: ReadonlyArray<string>;\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: ReadonlyArray<string>) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const variableName = `--` + key;\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(variableName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import { continuously } from '@ixfx/core';\nimport { delayLoop } from '@ixfx/flow';\n\nexport type Capturer = {\n  start(): void;\n  cancel(): void;\n  readonly canvasEl: HTMLCanvasElement;\n};\n\nexport type ManualCapturer = {\n  capture(): ImageData;\n  readonly canvasEl: HTMLCanvasElement;\n  dispose(): void;\n};\n\nexport type CaptureOpts = {\n  /**\n   * Delay between reading frames.\n   * Default: 0, reading as fast as possible\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * Whether to show the created capture canvas.\n   * Default: false\n   */\n  readonly showCanvas?: boolean;\n  readonly workerScript?: string;\n  readonly onFrame?: (pixels: ImageData) => void;\n};\n\nexport type ManualCaptureOpts = {\n  /**\n   * If true, the intermediate canvas is shown\n   * The intermediate canvas is where captures from the source are put in order\n   * to get the ImageData\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * If specified, this is the canvas captured to\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Options for frames generator\n */\nexport type FramesOpts = {\n  /**\n   * Max frame rate (millis per frame), or 0 for animation speed\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * False by default, created canvas will be hidden\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If provided, this canvas will be used as the buffer rather than creating one.\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import { Video } from '@ixfx/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\n\nexport async function* frames(\n  sourceVideoEl: HTMLVideoElement,\n  opts: FramesOpts = {}\n): AsyncIterable<ImageData> {\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n\n  const showCanvas = opts.showCanvas ?? false;\n  let canvasEl = opts.canvasEl;\n  let w, h;\n  w = h = 0;\n\n  // Create & setup canvas\n  if (canvasEl === undefined) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-frames`);\n    if (!showCanvas) {\n      canvasEl.style.display = `none`;\n    }\n    document.body.appendChild(canvasEl);\n  }\n\n  // Update size of canvas based on video\n  const updateSize = () => {\n    if (canvasEl === undefined) return;\n    w = sourceVideoEl.videoWidth;\n    h = sourceVideoEl.videoHeight;\n    canvasEl.width = w;\n    canvasEl.height = h;\n  };\n\n  let c: CanvasRenderingContext2D | null = null;\n\n  const looper = delayLoop(maxIntervalMs);\n  for await (const _ of looper) {\n    // If we don't yet have the size of video, get it\n    if (w === 0 || h === 0) updateSize();\n\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n    if (w === 0 || h === 0) continue;\n\n    // Draw current frame from video element to hidden canvas\n    c ??= canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    // Get pixels\n    const pixels = c.getImageData(0, 0, w, h);\n    yield pixels;\n  }\n}\n\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: CaptureOpts = {}\n): Capturer => {\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  const showCanvas = opts.showCanvas ?? false;\n  const onFrame = opts.onFrame;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n  canvasEl.classList.add(`ixfx-capture`);\n\n  if (!showCanvas) {\n    canvasEl.style.display = `none`;\n  }\n  canvasEl.width = w;\n  canvasEl.height = h;\n  let c: CanvasRenderingContext2D | null = null;\n  let worker: Worker | undefined;\n  if (opts.workerScript) {\n    worker = new Worker(opts.workerScript);\n  }\n\n  // Should we get image data?\n  const getPixels = worker || onFrame;\n  if (!getPixels && !showCanvas) {\n    console.warn(\n      `Video will be captured to hidden element without any processing. Is this what you want?`\n    );\n  }\n\n  const loop = continuously(() => {\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n    let pixels: ImageData | undefined;\n\n    if (getPixels) {\n      // ImageData necessary\n      pixels = c.getImageData(0, 0, w, h);\n    }\n\n    if (worker) {\n      // Send to worker\n      worker.postMessage(\n        {\n          pixels: pixels!.data.buffer,\n          width: w,\n          height: h,\n          channels: 4,\n        },\n        [ pixels!.data.buffer ]\n      );\n    }\n    if (onFrame) {\n      // Send to callback\n      try {\n        onFrame(pixels!);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, maxIntervalMs);\n\n  return {\n    start: () => { loop.start(); },\n    cancel: () => { loop.cancel(); },\n    canvasEl,\n  };\n};\n\nexport const manualCapture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: ManualCaptureOpts = {}\n): ManualCapturer => {\n  const showCanvas = opts.showCanvas ?? false;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas if necessary\n  const definedCanvasEl = opts.canvasEl !== undefined;\n  let canvasEl = opts.canvasEl;\n  if (!canvasEl) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-capture`);\n    document.body.append(canvasEl);\n    if (!showCanvas) canvasEl.style.display = `none`;\n  }\n\n  canvasEl.width = w;\n  canvasEl.height = h;\n\n  const capture = (): ImageData => {\n    let c: CanvasRenderingContext2D | undefined | null;\n\n    // Draw current frame from video element to canvas\n    if (!c) c = canvasEl.getContext(`2d`, { willReadFrequently: true });\n    if (!c) throw new Error(`Could not create graphics context`);\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    const pixels = c.getImageData(0, 0, w, h);\n\n    (pixels as any).currentTime = sourceVideoEl.currentTime;\n\n    if (opts.postCaptureDraw) opts.postCaptureDraw(c, w, h);\n    return pixels;\n  };\n\n  const dispose = (): void => {\n    if (definedCanvasEl) return; // we didn't create it\n    try {\n      canvasEl.remove();\n    } catch (_) {\n      // no-op\n    }\n  };\n\n  const c: ManualCapturer = {\n    canvasEl,\n    capture,\n    dispose,\n  };\n  return c;\n};\n","import * as Drawing from \"../drawing.js\";\nimport { Bipolar } from \"@ixfx/numbers\";\nimport { type IQueueImmutable, QueueImmutable } from \"@ixfx/collections/queue\";\nimport * as Colour from \"../colour/index.js\";\nimport { type CirclePositioned } from \"@ixfx/geometry/circle\";\n\n/**\n * Options\n */\nexport type BipolarViewOptions = Readonly<{\n  width?: number,\n  height?: number,\n  labelPrecision?: number\n  labels?: [ string, string ],\n  axisColour?: string,\n  bgColour?: string,\n  whiskerColour?: string,\n  whiskerSize?: number,\n  dotColour?: string,\n  dotRadius?: number,\n  showWhiskers?: boolean,\n  showDot?: boolean,\n  showLabels?: boolean,\n  padding?: number,\n  labelColour?: string,\n  axisWidth?: number,\n  asPercentages?: boolean,\n  /**\n   * If non-zero, will render the last X number of values with increasing opacity.\n   * Default: 0\n   */\n  displayLastValues?: number\n  /**\n   * If _true_, (default) negative y values are at the bottom.\n   * If _false_  negative y values are at the top.\n   */\n  yAxisBottomNegative?: boolean,\n  /**\n   * Custom rendering for background\n   */\n  renderBackground?: Render\n}>\n\nfunction getNumericAttribute(el: HTMLElement, name: string, defaultValue: number) {\n  const a = el.getAttribute(name);\n  if (a === null) return defaultValue;\n  return Number.parseInt(a);\n}\n\nexport type Render = (ctx: CanvasRenderingContext2D, width: number, height: number) => void;\n/**\n * A function that plots a point on the graph\n */\nexport type BipolarView = (x: number, y: number) => void;\n\n/**\n * Initialises a plotter for bipolar values (-1...1)\n * \n * ```js\n * const p = BipolarView.init(`#my-canvas`);\n * // Shows the dot at 1, 0.5\n * p(1, 0.5);\n * ```\n * @param elementQuery \n * @param options \n * @returns \n */\nexport const init = (elementQuery: string, options: BipolarViewOptions = {}): BipolarView => {\n  const element = document.querySelector<HTMLCanvasElement>(elementQuery);\n  if (!element) throw new Error(`Element query could not be found (${ elementQuery })`);\n  const labels = options.labels ?? [ `x`, `y` ];\n  const labelPrecision = options.labelPrecision ?? 2;\n  const asPercentages = options.asPercentages ?? false;\n  const displayLastValues = options.displayLastValues ?? 0;\n  // Flags\n  const showWhiskers = options.showWhiskers ?? true;\n  const showDot = options.showDot ?? true;\n  const showLabels = options.showLabels ?? true;\n  const yAxisBottomNegative = options.yAxisBottomNegative ?? true;\n  // Colours\n  const axisColour = Colour.toStringFirst(options.axisColour, `silver`);\n  const bgColour = Colour.toStringFirst(options.bgColour, `white`);\n  const whiskerColour = Colour.toStringFirst(options.whiskerColour, `black`);\n  const dotColour = Colour.toStringFirst(options.dotColour, options.whiskerColour, `black`);\n  const labelColour = Colour.toStringFirst(options.labelColour, options.axisColour, `silver`);\n\n  // Sizes\n  const axisWidth = (options.axisWidth ?? 1 * window.devicePixelRatio);\n  const dotRadius = (options.dotRadius ?? 5 * window.devicePixelRatio);\n  const pad = (options.padding ?? 10 * window.devicePixelRatio);\n  const whiskerSize = (options.whiskerSize ?? 5 * window.devicePixelRatio);\n  const width = (options.width ?? getNumericAttribute(element, `width`, 200) * window.devicePixelRatio);\n  const height = (options.height ?? getNumericAttribute(element, `height`, 200) * window.devicePixelRatio);\n\n  let lastValues: IQueueImmutable<CirclePositioned> | undefined;\n  if (displayLastValues > 0) {\n    lastValues = new QueueImmutable<CirclePositioned>({\n      capacity: displayLastValues,\n      discardPolicy: `older`\n    });\n  }\n\n  element.width = width;// * window.devicePixelRatio;\n  element.height = height;// * window.devicePixelRatio;\n  element.style.width = `${ (width / window.devicePixelRatio) }px`;\n  element.style.height = `${ (height / window.devicePixelRatio) }px`;\n\n  const midY = height / 2;\n  const midX = width / 2;\n  const ctx = element.getContext(`2d`);\n  if (!ctx) throw new Error(`Could not create drawing context`);\n\n  if (window.devicePixelRatio >= 2) {\n    ctx.font = `20px sans-serif`;\n  }\n  const percentageFormat = (v: number) => `${ Math.round(v * 100) }%`;\n  const fixedFormat = (v: number) => v.toFixed(labelPrecision);\n\n  const valueFormat = asPercentages ? percentageFormat : fixedFormat;\n  if (showLabels) {\n    labels[ 0 ] = labels[ 0 ] + `:`;\n    labels[ 1 ] = labels[ 1 ] + `:`;\n  } else {\n    labels[ 0 ] = ``;\n    labels[ 1 ] = ``;\n  }\n\n  const renderBackground: Render = options.renderBackground ?? ((ctx, width, height): void => {\n    if (options.bgColour === `transparent`) {\n      ctx.clearRect(0, 0, width, height);\n    } else {\n      ctx.fillStyle = bgColour;\n      ctx.fillRect(0, 0, width, height);\n    }\n  });\n\n  return (x: number, y: number) => {\n    x = Bipolar.clamp(x);\n    y = Bipolar.clamp(y);\n\n    renderBackground(ctx, width, height);\n\n    // Labels\n    ctx.fillStyle = labelColour;\n    ctx.textBaseline = `top`;\n    ctx.save();\n    ctx.translate(midX, midY);\n    ctx.rotate(-Math.PI / 2);\n    ctx.fillText((labels[ 1 ] + ` ` + valueFormat(y)).trim(), -midX + pad, 1);\n    ctx.restore();\n    ctx.fillText((labels[ 0 ] + ` ` + valueFormat(x)).trim(), pad, midX + 2);\n\n    if (!yAxisBottomNegative) y *= -1;\n\n    // Axes\n    ctx.strokeStyle = axisColour;\n    ctx.lineWidth = axisWidth;\n    ctx.beginPath();\n    ctx.moveTo(pad, midY);\n    ctx.lineTo(width - pad, midY);\n    ctx.moveTo(midX, pad);\n    ctx.lineTo(midX, height - pad);\n    ctx.stroke();\n    ctx.closePath();\n\n    const yy = (height - pad - pad) / 2 * -y;\n    const xx = (width - pad - pad) / 2 * x;\n    const dotPos = { x: xx, y: yy, radius: dotRadius };\n\n    if (lastValues) {\n      lastValues = lastValues.enqueue(dotPos);\n    }\n    ctx.save();\n    ctx.translate(midX, midY);\n\n    // Dot\n    if (showDot) {\n      if (lastValues) {\n        const opacityStep = 1 / lastValues.length;\n        let opacity = 1;\n        lastValues.forEach(d => {\n          const colour = Colour.multiplyOpacity(dotColour, opacity);\n          Drawing.circle(ctx, d, { fillStyle: colour });\n          opacity -= opacityStep;\n        });\n      } else {\n        Drawing.circle(ctx, dotPos, { fillStyle: dotColour });\n      }\n    }\n\n    // Whiskers\n    if (showWhiskers) {\n      ctx.strokeStyle = whiskerColour;\n\n      // y line\n      ctx.beginPath();\n      ctx.moveTo(0, yy - whiskerSize);\n      ctx.lineTo(0, yy + whiskerSize);\n\n      // x line\n      ctx.moveTo(xx - whiskerSize, 0);\n      ctx.lineTo(xx + whiskerSize, 0);\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    // Restore transform\n    ctx.restore();\n  }\n}\n","\nimport { scaler } from \"@ixfx/numbers\";\nimport type { GridStyle, LineStyle, ShowOptions, TextStyle } from \"./types.js\";\nimport type { Point } from \"@ixfx/geometry/point\";\n\nexport type PointMinMax = { min: Point, max: Point, width: number, height: number, minDim: number, maxDim: number };\n\nexport type PlotPoint = Point & {\n  fillStyle?: string\n  radius?: number\n}\n\nexport type CartesianScaler = (pt: Point) => Point;\n\nexport type CartesianDataRange = {\n  /**\n   * Converts a data value to relative value (0..1)\n   */\n  absDataToRelative: CartesianScaler\n  /**\n   * Converts a relative value to element-based coordinates\n   * (ie 0,0 is top-left of CANVAS)\n   */\n  relDataToCanvas: CartesianScaler\n  canvasToRelData: CartesianScaler\n  /**\n   * Converts canvas coordinate to relative\n   */\n  regionSpaceToRelative: CartesianScaler,\n  /**\n   * Converts relative coordinate to value\n   */\n  relDataToAbs: CartesianScaler\n  range: PointMinMax\n}\n\n\nexport type CartesianPlotOptions = {\n  clear: `region` | `canvas`\n  onInvalidated: () => void\n  /**\n * Margin around whole plot area. Use\n * to avoid dots being cut off by edge of canvas\n */\n  visualPadding: number\n  // canvasWidth: number\n  // canvasHeight: number\n  // canvasResize: ElementResizeLogic\n  // coordinateScale: ScaleBy\n  show: Partial<ShowOptions>\n  /**\n   * If 'auto' (default), range of plot is based on data.\n   * Otherwise specify the range, eg:\n   * `{ min: {x:-1,y:-1}, {x:1,y:1}}`\n   * \n   */\n  range: `auto` | { min: Point, max: Point }\n\n  /**\n   * Gridline setting\n   */\n  grid: Partial<GridStyle>\n  /**\n   * Drawing settings for axis (if 'showAxes' is enabled)\n   */\n  axisStyle: LineStyle\n  /**\n   * How values are drawn. Default: 'dot'\n   */\n  valueStyle: `dot` | ``,\n  /**\n   * How values are connected. Default: '' (no connecting)\n   * Values are connected in order of dataset.\n   */\n  connectStyle: `` | `line`,\n  textStyle: TextStyle\n  whiskerLength: number\n}\n\nexport const computeMinMax = (mm: Point[]): PointMinMax => {\n  const x = mm.map(m => m.x);\n  const y = mm.map(m => m.y);\n  const minX = Math.min(...x);\n  const maxX = Math.max(...x);\n  const minY = Math.min(...y);\n  const maxY = Math.max(...y);\n  const width = maxX - minX;\n  const height = maxY - minY;\n\n  return {\n    min: { x: minX, y: minY },\n    max: { x: maxX, y: maxY },\n    width, height,\n    minDim: Math.min(width, height),\n    maxDim: Math.max(width, height)\n  }\n}\n\nexport const relativeCompute = (minMax: PointMinMax) => {\n  if (!Number.isFinite(minMax.height)) {\n    return (point: Point) => point;\n  }\n  const xScale = scaler(minMax.min.x, minMax.max.x);\n  const yScale = scaler(minMax.min.y, minMax.max.y);\n  return (point: Point) => ({\n    x: xScale(point.x),\n    y: yScale(point.y)\n  });\n}\n\nexport const absoluteCompute = (minMax: PointMinMax) => {\n  const xScale = scaler(0, 1, minMax.min.x, minMax.max.x);\n  const yScale = scaler(0, 1, minMax.min.y, minMax.max.y);\n  return (point: Point) => ({\n    x: xScale(point.x),\n    y: yScale(point.y)\n  });\n}\n\nexport type AxisMark = Point & {\n  major: boolean\n}\nexport const computeAxisMark = (mm: PointMinMax, increments: number, major: number): { x: AxisMark[], y: AxisMark[] } => {\n  // Vertical\n  const xValues: AxisMark[] = [];\n  let count = 0;\n\n  for (let x = mm.min.x; x < mm.max.x; x += increments) {\n    const isMajor = count % major === 0;\n    xValues.push({ x, y: 0, major: isMajor });\n    count++;\n  }\n\n  // Horizontal\n  count = 0;\n  const yValues: AxisMark[] = [];\n  for (let y = mm.min.y; y < mm.max.y; y += increments) {\n    const isMajor = count % major === 0;\n    yValues.push({ x: 0, y, major: isMajor })\n    count++;\n  }\n  return { x: xValues, y: yValues }\n}","import { MapOfSimpleMutable } from \"@ixfx/collections\";\n\nexport class DataSet<TValue, TSeriesMeta> {\n  #data;\n  #meta;\n  lastChange;\n\n  constructor() {\n    this.lastChange = performance.now();\n    this.#data = new MapOfSimpleMutable<TValue>();\n\n    this.#meta = new Map<string, TSeriesMeta>();\n  }\n\n  get metaCount() {\n    return this.#meta.size;\n  }\n\n  clear() {\n    this.#data.clear();\n    this.lastChange = performance.now();\n  }\n\n  set(series: string, data: TValue[]) {\n    this.#data.setValues(series, data);\n  }\n\n  deleteBySeries(series: string) {\n    const changed = this.#data.delete(series);\n    if (changed) {\n      this.lastChange = performance.now();\n    }\n    return changed;\n  }\n\n  setMeta(series: string, meta: TSeriesMeta) {\n    this.#meta.set(series, meta);\n  }\n\n  hasMeta(series: string) {\n    return this.#meta.has(series);\n  }\n\n  getMeta(series: string) {\n    return this.#meta.get(series);\n  }\n\n  *getValues() {\n    yield* this.#data.valuesFlat();\n  }\n\n  *getEntries() {\n    yield* this.#data.entries();\n  }\n\n  *getSeries() {\n    yield* this.#data.values();\n  }\n\n  add(value: TValue, series = `default`) {\n    this.#data.addKeyedValues(series, value);\n    this.lastChange = performance.now();\n  }\n}","\nimport { DataSet } from \"./DataSet.js\";\nimport * as Cart from './cartesian.js';\nimport { round } from \"@ixfx/numbers\";\nimport type { GridStyle, LineStyle, SeriesMeta, ShowOptions, TextStyle } from \"./types.js\";\nimport type { RecursivePartial } from \"@ixfx/core\";\nimport type { CanvasRegion, CanvasRegionSpec } from \"../canvas-region.js\";\nimport { CanvasSource } from \"../canvas-region.js\";\nimport { resolveEl } from \"@ixfx/dom\";\nimport { ElementSizer } from \"@ixfx/dom\";\nimport type { RectPositioned } from \"@ixfx/geometry/rect\";\nimport { Points, Rects } from \"@ixfx/geometry\";\nimport type { Line } from \"@ixfx/geometry/line\";\nimport type { Point } from \"@ixfx/geometry/point\";\nimport { goldenAngleColour } from \"../colour/generate.js\";\nimport { toCssColour as ColourToString } from \"../colour/conversion.js\";\nexport type InsertOptions = {\n  region?: CanvasRegionSpec\n  /**\n   * Parent to insert CANVAS element into.\n   * If undefined, it will be added to the body.\n   */\n  parent?: HTMLElement | string\n  /**\n   * How canvas should be sized\n   */\n  canvasResizeTo: `parent` | `viewport`\n};\n\n\nexport const insert = (insertOptions: InsertOptions, options: RecursivePartial<Cart.CartesianPlotOptions> = {}) => {\n\n  const parentEl = (insertOptions.parent === undefined) ? document.body : resolveEl(insertOptions.parent);\n  const canvasEl = document.createElement(`canvas`);\n  parentEl.prepend(canvasEl);\n\n  const ds = new DataSet<Cart.PlotPoint, SeriesMeta>();\n\n  const source = new CanvasSource(canvasEl, `min`);\n  const spec = insertOptions.region ?? ({ relativePositioned: { x: 0, y: 0, width: 1, height: 1 } });\n  const region = source.createRegion(spec);\n  const p = new CartesianCanvasPlot(region, ds, options);\n\n  if (insertOptions.canvasResizeTo === `viewport`) {\n    ElementSizer.canvasViewport(canvasEl, {\n      onSizeChanging: (size, _el) => {\n        source.setLogicalSize(size);\n        p.invalidateRange();\n        p.draw();\n      }\n    });\n  } else {\n    // Parent\n    ElementSizer.canvasParent(canvasEl, {\n      onSizeChanging: (size, _el) => {\n        source.setLogicalSize(size);\n        p.invalidateRange();\n        p.draw();\n      }\n    });\n  }\n  return p;\n}\n\n\n/**\n * Simple plotting of cartesian values.\n * \n * Create a plot that fills screen\n * ```js\n * const p = Plot.insert({fill`viewport});\n * const dataSet = p.dataSet;\n * \n * // Add data\n * ds.add({ x: 1, y: 2 });\n * \n * // Draw\n * p.draw();\n * ```\n *\n * Create a plot that fills a container\n * ```js\n * const p = Plot.insert({parent:`#someel`});\n * ```\n * \n * Add data using the created data set\n * ```js\n * \n * // Add a value to the `alpha` series\n * p.dataSet.add({x:1,y:1}, `alpha`);\n * ```\n * \n * Set default series formatting\n * ```js\n * p.setMeta(`default`, {\n *  colour: `hsl(50,100%,50%)`,\n *  lineWidth: 10\n * });\n * ```\n * \n * Series can have metadata associated with it in the DataSet\n * ```js\n * // Use 'pink' by default for the series 'alpha'\n * p.setMeta(`alpha`, { colour: `pink` });\n * ``\n * \n */\nexport class CartesianCanvasPlot {\n  #data;\n  #lastDataChange;\n  #canvasRegion: CanvasRegion;\n\n  actualDataRange: RectPositioned = Rects.EmptyPositioned;\n  visibleRange: RectPositioned = Rects.PlaceholderPositioned;\n  show: ShowOptions;\n  whiskerLength: number;\n  axisRounder = round(1, true);\n  onInvalidated: undefined | (() => void);\n\n  /**\n   * List of lines to draw after drawing everything else.\n   * Lines are given in value-coordinate space\n   */\n  overlayLines: (Line & LineStyle)[] = [];\n  #grid: GridStyle\n  #rangeMode;\n\n  #currentRange?: Cart.CartesianDataRange;\n\n  #axisStyle: LineStyle;\n  #valueStyle;\n  #connectStyle;\n  #rangeManual: Cart.PointMinMax | undefined;\n  #textStyle: TextStyle;\n  #visualPadding: number;\n  #visualClear: `region` | `canvas`;\n\n  constructor(cr: CanvasRegion, data: DataSet<Cart.PlotPoint, SeriesMeta>, options: RecursivePartial<Cart.CartesianPlotOptions> = {}) {\n    if (!data) throw new TypeError(`Param 'data' is undefined`);\n    if (typeof data !== `object`) throw new TypeError(`Param 'data' is not an object. Got: ${ typeof data }`);\n    this.onInvalidated = options.onInvalidated as undefined | (() => void);\n    this.#data = data;\n    this.#canvasRegion = cr;\n    this.#lastDataChange = 0;\n    this.#visualClear = options.clear ?? `region`;\n    this.#rangeMode = options.range ?? `auto`;\n    this.#valueStyle = options.valueStyle ?? `dot`;\n    this.#connectStyle = options.connectStyle ?? ``;\n    this.whiskerLength = options.whiskerLength ?? 5;\n    this.#visualPadding = options.visualPadding ?? 20;\n    this.show = {\n      axes: true,\n      axisValues: true,\n      grid: true,\n      whiskers: true,\n      ...options.show\n    };\n\n    this.#axisStyle = {\n      colour: `black`,\n      width: 2,\n      ...options.axisStyle\n    };\n    this.#textStyle = {\n      colour: `black`,\n      size: `1em`,\n      font: `system-ui`,\n      ...options.textStyle\n    };\n\n    this.#grid = {\n      increments: 0.1,\n      major: 5,\n      colour: `whitesmoke`,\n      width: 1,\n      ...options.grid\n    }\n  }\n\n  getCurrentRange() {\n    if (this.#data.lastChange === this.#lastDataChange && this.#currentRange) return this.#currentRange;\n    this.#lastDataChange = this.#data.lastChange;\n    const r = this.#createRange();\n    this.#currentRange = r;\n    if (this.onInvalidated) this.onInvalidated();\n    return r;\n  }\n\n  invalidateRange() {\n    this.#currentRange = undefined;\n  }\n\n  #createRange(): Cart.CartesianDataRange {\n    // Compute scale of data\n    const range = this.getDataRange(); // actual data range, or user-provided\n\n    const absDataToRelative = Cart.relativeCompute(range);\n    const relDataToAbs = Cart.absoluteCompute(range);\n    const cr = this.#canvasRegion;\n    const padding = this.#visualPadding;\n\n    // Offsets are in canvas coordinates, not region\n    // eg 0,0 is top-left corner of canvas\n    let xOffset = cr.x + padding;\n    let yOffset = cr.y + padding;\n\n    const allowedHeight = cr.height - (padding * 2);\n    const allowedWidth = cr.width - (padding * 2);\n    const dimensionMin = Math.min(allowedHeight, allowedWidth);;\n\n    if (allowedWidth >= allowedHeight) {\n      // Landscape\n      xOffset += (allowedWidth / 2) - (dimensionMin / 2);\n    } else {\n      // Portrait\n      yOffset += (allowedHeight / 2) - (dimensionMin / 2);\n    }\n\n    const relDataToCanvas = (pt: Point) => {\n      let { x, y } = pt;\n      if (x === Number.NEGATIVE_INFINITY) x = 0;\n      else if (x === Number.POSITIVE_INFINITY) x = 1;\n      if (y === Number.NEGATIVE_INFINITY) y = 0;\n      else if (y === Number.POSITIVE_INFINITY) y = 1;\n      x = x * dimensionMin;\n      y = (1 - y) * dimensionMin;\n\n      x += xOffset;\n      y += yOffset;\n\n      return { x, y }\n    };\n\n    const canvasToRelData = (pt: Point) => {\n      let { x, y } = pt;\n      x -= xOffset;\n      y -= yOffset;\n      x = x / dimensionMin;\n      y = 1 - (y / dimensionMin);\n      return { x, y }\n    };\n\n    // Convert region-space to plot area relative\n    const regionSpaceToRelative = (pt: Point) => {\n      let { x, y } = pt;\n      x = x - cr.x + this.#visualPadding;\n      y = (dimensionMin + this.#visualPadding) - y;\n      x /= dimensionMin;\n      y = (y / dimensionMin);\n      return { x, y }\n    }\n\n    return {\n      absDataToRelative, relDataToCanvas, canvasToRelData, regionSpaceToRelative, relDataToAbs, range\n    }\n  }\n\n\n  /**\n   * Positions an element at the viewport location of `data` point.\n   * Ensure the element has `position:absolute` set.\n   * @param data \n   * @param elementToPosition \n   * @param by \n   */\n  positionElementAt(data: Point, elementToPosition: HTMLElement | string, by: `middle` | `top-left` = `middle`, relativeToQuery?: HTMLElement | string) {\n    const el = resolveEl(elementToPosition);\n    let { x, y } = this.valueToScreenSpace(data);\n    // x -= this.canvasSource.offset.x;\n    // y -= this.canvasSource.offset.y;\n    if (by === `middle`) {\n      const bounds = el.getBoundingClientRect();\n      x -= bounds.width / 2;\n      y -= bounds.height / 2;\n    } else if (by === `top-left`) {\n      // no-op\n    } else throw new Error(`Param 'by' expected to be 'middle' or 'top-left'.`);\n    if (relativeToQuery) {\n      const relativeTo = resolveEl(relativeToQuery);\n      const bounds = relativeTo.getBoundingClientRect();\n\n      //console.log(`Plot relativeTo: ${ relativeTo.scrollTop } y:  ${ bounds.y }`);\n      x -= bounds.x;\n      y -= bounds.y;\n    }\n    el.style.left = `${ x }px`;\n    el.style.top = `${ y }px`;\n  }\n\n  /**\n   * When range is auto, returns the range of the data\n   * Otherwise returns the user-provided range.\n   * @returns \n   */\n  getDataRange(): Cart.PointMinMax {\n    if (this.#rangeMode === `auto`) {\n      return Cart.computeMinMax([ ...this.#data.getValues() ]);\n    } else {\n      if (!this.#rangeManual) {\n        this.#rangeManual = Cart.computeMinMax([ this.#rangeMode.max, this.#rangeMode.min ]);\n      }\n      return this.#rangeManual;\n    }\n  }\n\n  valueToScreenSpace(dataPoint: Point) {\n    const region = this.valueToRegionSpace(dataPoint);\n    const offset = this.canvasSource.offset;\n    const scr = {\n      x: region.x + offset.x,\n      y: region.y + offset.y\n    }\n    return scr;\n  }\n\n  valueToRegionSpace(dataValue: Point, debug = false) {\n    const ds = this.getCurrentRange();\n\n    // Scale absolute value relative to total dimensions of data\n    const rel = ds.absDataToRelative(dataValue);\n\n    // Scale relative data value to canvas space\n    const region = ds.relDataToCanvas(rel);\n\n    if (debug) console.log(`orig: ${ dataValue.x }x${ dataValue.y } rel: ${ rel.x }x${ rel.y } region: ${ region.x }x${ region.y }`);\n    return {\n      ...dataValue,\n      x: region.x,\n      y: region.y\n    }\n  }\n\n  // #regionSpaceToValue(scr: Point, clamped: boolean) {\n  //   const ds = this.getCurrentRange();\n\n  //   const rel = ds.regionSpaceToRelative(scr);\n  //   //console.log(`regionSpaceToRelative ${ rel.x.toFixed(2) },${ rel.y.toFixed(2) }`);\n\n  //   const value = ds.relDataToAbs(rel);\n  //   //if (debug) console.log(`orig: ${ a.x }x${ a.y } rel: ${ rel.x }x${ rel.y } scr: ${ scr.x }x${ scr.y }`);\n\n  //   const pt = {\n  //     ...scr,\n  //     x: value.x,\n  //     y: value.y\n  //   }\n  //   if (clamped) return clamp(pt);\n  //   return pt;\n  // }\n\n  /**\n   * Converts a point in pixel coordinates to a value.\n   * Useful for converting from user input coordinates.\n   * @param point \n   * @returns \n   */\n  pointToValue(point: Point, _source: `screen`) {\n    const ds = this.getCurrentRange();\n\n    // Apply offset\n    const canvasPoint = Points.subtract(point, this.canvasSource.offset);\n\n    const v = ds.canvasToRelData(canvasPoint);\n    return ds.relDataToAbs(v);\n  }\n\n  // valueToScreen(a: Point) {\n  //   const ds = this.getCurrentRange();\n  //   const rel = ds.valueToRelative(a);\n  //   const scr = ds.relativeToElementSpace(rel);\n  //   const bounds = this.helper.el.getBoundingClientRect();\n  //   return {\n  //     x: scr.x + bounds.x,\n  //     y: scr.y + bounds.y\n  //   }\n  // }\n\n  // valueRectToScreen(a: Point, b: Point): RectPositioned {\n  //   a = this.valueToScreen(a);\n  //   b = this.valueToScreen(b);\n  //   return {\n  //     x: a.x,\n  //     y: b.y,\n  //     width: b.x - a.x,\n  //     height: a.y - b.y\n  //   }\n  // }\n\n  /**\n   * Compute canvas-relative coordinates based on two points in value space\n   * @param valueA \n   * @param valueB \n   */\n  #valueLineToCanvasSpace(valueA: Point, valueB: Point, debug = false): Line {\n    valueA = this.valueToRegionSpace(valueA, debug) as Point;\n    valueB = this.valueToRegionSpace(valueB, debug) as Point;\n    return { a: valueA, b: valueB };\n  }\n\n  getDefaultMeta(): SeriesMeta {\n    return {\n      colour: goldenAngleColour(this.#data.metaCount),\n      lineWidth: 2,\n      dotRadius: 5\n    }\n  }\n\n  draw() {\n    if (this.#visualClear === `region`) {\n      this.#canvasRegion.clear();\n    } else {\n      this.canvasSource.clear();\n    }\n\n    //const ctx = this.helper.ctx;\n    //this.helper.drawBounds(`whitesmoke`);\n    //Drawing.rect(ctx, this.renderArea, { strokeStyle: `whitesmoke` });\n\n    this.#useGrid();\n    if (this.show.axes) this.#drawAxes();\n\n    //let seriesCount = 0;\n    for (const [ k, v ] of this.#data.getEntries()) {\n      let meta = this.#data.getMeta(k);\n      if (!meta) {\n        meta = this.getDefaultMeta();\n        this.#data.setMeta(k, meta);\n      }\n      this.#drawSeries(k, v, meta);\n      //seriesCount++;\n    }\n    //console.log(`series count: ${ seriesCount }`);\n    for (const line of this.overlayLines) {\n      this.drawLine(line, line.colour, line.width);\n    }\n  }\n\n  /**\n   * Draws a line in value-coordinate space\n   * @param line \n   * @param colour \n   * @param width \n   */\n  drawLine(line: Line, colour: string, width: number) {\n    const l = this.#valueLineToCanvasSpace(line.a, line.b);\n    this.#drawLineCanvasSpace(l, colour, width);\n  }\n\n  setMeta(series: string, meta: Partial<SeriesMeta>) {\n    this.#data.setMeta(series, {\n      ...this.getDefaultMeta(),\n      ...meta\n    })\n  }\n\n  #drawAxes() {\n    const { colour, width } = this.#axisStyle;\n    // Axis coordinates in canvas-space\n    const yAxis = this.#valueLineToCanvasSpace({ x: 0, y: Number.NEGATIVE_INFINITY }, { x: 0, y: Number.POSITIVE_INFINITY }, false);\n    const xAxis = this.#valueLineToCanvasSpace({ x: Number.NEGATIVE_INFINITY, y: 0 }, { x: Number.POSITIVE_INFINITY, y: 0 }, false);\n\n    //console.log(`x axis: ${ xAxis.a.x }-${ xAxis.b.x }`);\n    this.#drawLineCanvasSpace(xAxis, colour, width, false);\n    this.#drawLineCanvasSpace(yAxis, colour, width, false);\n  }\n\n\n  #drawYAxisValues(yPoints: Point[]) {\n    //const { ctx } = this.helper;\n    const ctx = this.#canvasRegion.context;\n\n    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;\n    ctx.fillStyle = this.#textStyle.colour;\n    ctx.textBaseline = `middle`;\n\n\n    for (const p of yPoints) {\n      if (p.x === 0 && p.y === 0) continue;\n      const reg = this.valueToRegionSpace(p, false);\n      const value = this.axisRounder(p.y);\n      const label = value.toString();\n      const measure = ctx.measureText(label);\n      const x = reg.x - measure.width - (this.whiskerLength / 2) - 5;\n      const y = reg.y;\n      ctx.fillText(label, x, y);\n    }\n  }\n\n  #drawXAxisValues(xPoints: Point[]) {\n    //const { ctx } = this.helper;\n    const ctx = this.#canvasRegion.context;\n    ctx.font = this.#textStyle.size + ` ` + this.#textStyle.font;\n    ctx.fillStyle = this.#textStyle.colour;\n    ctx.textBaseline = `top`;\n    for (const p of xPoints) {\n      const reg = this.valueToRegionSpace(p, false);\n      const value = this.axisRounder(p.x);\n      const label = value.toString();\n      const measure = ctx.measureText(label);\n      const x = reg.x - measure.width / 2;\n      const y = reg.y + measure.actualBoundingBoxAscent + measure.actualBoundingBoxDescent + (this.whiskerLength / 2);\n      ctx.fillText(label, x, y);\n    }\n  }\n\n  #drawWhisker(p: Cart.AxisMark, vertical: boolean) {\n    const whiskerHalfLength = this.whiskerLength / 2;\n    const v = vertical ? { x: p.x, y: 0 } : { y: p.y, x: 0 }\n    const reg = this.valueToRegionSpace(v, false);\n\n    const line = vertical ? {\n      a: { x: reg.x, y: reg.y - whiskerHalfLength },\n      b: { x: reg.x, y: reg.y + whiskerHalfLength },\n    } :\n      {\n        a: { y: reg.y, x: reg.x - whiskerHalfLength },\n        b: { y: reg.y, x: reg.x + whiskerHalfLength },\n      }\n    this.#drawLineCanvasSpace(line, this.#axisStyle.colour, this.#axisStyle.width, false);\n  }\n\n  #drawGridline(p: Cart.AxisMark, vertical: boolean) {\n    const line = vertical ?\n      this.#valueLineToCanvasSpace({ x: p.x, y: Number.NEGATIVE_INFINITY }, { x: p.x, y: Number.POSITIVE_INFINITY }) :\n      this.#valueLineToCanvasSpace({ y: p.y, x: Number.NEGATIVE_INFINITY }, { y: p.y, x: Number.POSITIVE_INFINITY }, false);\n    this.#drawLineCanvasSpace(line, this.#grid.colour, p.major ? this.#grid.width * 2 : this.#grid.width);\n  }\n\n  #useGrid() {\n    const g = this.#grid;\n    const showGrid = this.show.grid;\n    const showWhiskers = this.show.whiskers;\n    const showValues = this.show.axisValues;\n    const mm = this.getCurrentRange().range; // actual data range, or user-provided\n    const { increments, major } = g;\n\n    // Vertical lines\n    const axisMarks = Cart.computeAxisMark(mm, increments, major);\n    for (const p of axisMarks.x) {\n      if (showGrid) this.#drawGridline(p, true);\n      if (showWhiskers && p.major) this.#drawWhisker(p, true);\n    }\n\n    // Horizontal lines\n    for (const p of axisMarks.y) {\n      if (showGrid) this.#drawGridline(p, false);\n      if (showWhiskers && p.major) this.#drawWhisker(p, false);\n    }\n\n    if (showValues) {\n      this.#drawXAxisValues(axisMarks.x.filter(p => p.major));\n      this.#drawYAxisValues(axisMarks.y.filter(p => p.major));\n    }\n  }\n\n  #drawSeries(name: string, series: Cart.PlotPoint[], meta: SeriesMeta) {\n    if (this.#connectStyle === `line`) {\n      this.#drawConnected(series, meta.colour, meta.lineWidth);\n    }\n\n    //let valueCount = 0;\n    if (this.#valueStyle === `dot`) {\n      for (const v of series) {\n        this.#drawDot(v, meta.colour, meta.dotRadius);\n        //valueCount++;\n      }\n    }\n    //console.log(`valueCount: ${ valueCount }`);\n  }\n\n  #drawConnected(dots: Cart.PlotPoint[], colour: string, width: number) {\n    const ctx = this.#canvasRegion.context;\n    ctx.beginPath();\n    for (const [ index, dot_ ] of dots.entries()) {\n      const dot = this.valueToRegionSpace(dot_, false);\n      if (index === 0) ctx.moveTo(dot.x, dot.y);\n      ctx.lineTo(dot.x, dot.y);\n    }\n    ctx.strokeStyle = ColourToString(colour);\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  #drawDot(originalDot: Cart.PlotPoint, fallbackColour: string, fallbackRadius: number) {\n    const colour = ColourToString(originalDot.fillStyle ?? fallbackColour);\n    const pos = this.valueToRegionSpace(originalDot);\n    const radius = originalDot.radius ?? fallbackRadius;\n    this.#canvasRegion.drawCircles([\n      { ...pos, radius }\n    ], colour);\n\n    // const ctx = this.helper.ctx;\n    // const dot = this.#valueToElementSpace(originalDot, false);\n    // const radius = originalDot.radius ?? fallbackRadius;\n    // //console.log(`dot ${ dot.x }x${ dot.y } (from ${ originalDot.x }x${ originalDot.y })`);\n    // ctx.fillStyle = Colour.resolveToString(originalDot.fillStyle ?? fallbackColour);\n    // ctx.beginPath();\n    // ctx.arc(dot.x, dot.y, radius, 0, Math.PI * 2);\n    // ctx.fill();\n    // ctx.closePath();\n  }\n\n\n  #drawLineCanvasSpace(line: Line, colour: string, width: number, debug = false) {\n    if (debug) console.log(line);\n    const ctx = this.#canvasRegion.context;\n\n    colour = ColourToString(colour);\n    //this.#canvasRegion.drawConnectedPoints([ line.a, line.b ], colour, width);\n    ctx.beginPath();\n    ctx.moveTo(line.a.x, line.a.y);\n    ctx.lineTo(line.b.x, line.b.y);\n    ctx.strokeStyle = ColourToString(colour);\n    ctx.lineWidth = width;\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  get dataSet() {\n    return this.#data;\n  }\n\n  get canvasRegion() {\n    return this.#canvasRegion;\n  }\n\n  get canvasSource() {\n    return this.#canvasRegion.source;\n  }\n}","export * as BipolarView from './bipolar-view.js'\nexport * from './cartesian.js';\nexport * from './cartesian-canvas-plot.js';\nexport * from './DataSet.js';\nexport type * from './types.js';","export * from './canvas-helper.js';\nexport * from './canvas-region.js';\n\nexport * from './pointer-visualise.js';\nexport * as Svg from './svg/index.js';\nexport type * from './types.js';\n\nexport * as Convolve2d from './convolve-2d.js';\n\nimport * as NamedColourPalette from './named-colour-palette.js';\n\n\nimport * as Colour from './colour/index.js';\n\nexport * as Colour from './colour/index.js';\n\nimport * as Video from './video.js';\n\nexport * as Drawing from './drawing.js';\n\n/**\n * Wraps [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData) as an ixfx {@link https://api.ixfx.fun/_ixfx/geometry/Grids/Grid/} type.\n * This is useful because it's otherwise a one-dimensional array listing each rgba in turn.\n */\nexport * as ImageDataGrid from './image-data-grid.js';\n\nexport * as Plot from './plot/index.js';\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from '@ixfx/visual.js'\n * ```\n */\nexport * as Video from './video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        NamedColourPalette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n"],"mappings":"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"}